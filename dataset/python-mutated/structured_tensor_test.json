[
    {
        "func_name": "shape_v2_special",
        "original": "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateSpecialType)\ndef shape_v2_special(input: _PrivateSpecialType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    \"\"\"Returns a DynamicRaggedShape containing the shape of the input.\"\"\"\n    del name\n    return array_ops.shape_v2(input.ragged, out_type)",
        "mutated": [
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateSpecialType)\ndef shape_v2_special(input: _PrivateSpecialType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    return array_ops.shape_v2(input.ragged, out_type)",
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateSpecialType)\ndef shape_v2_special(input: _PrivateSpecialType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    return array_ops.shape_v2(input.ragged, out_type)",
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateSpecialType)\ndef shape_v2_special(input: _PrivateSpecialType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    return array_ops.shape_v2(input.ragged, out_type)",
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateSpecialType)\ndef shape_v2_special(input: _PrivateSpecialType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    return array_ops.shape_v2(input.ragged, out_type)",
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateSpecialType)\ndef shape_v2_special(input: _PrivateSpecialType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    return array_ops.shape_v2(input.ragged, out_type)"
        ]
    },
    {
        "func_name": "shape_v2_broken",
        "original": "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateBrokenType)\ndef shape_v2_broken(input: _PrivateBrokenType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    \"\"\"Returns a DynamicRaggedShape containing the shape of the input.\"\"\"\n    del name\n    del input\n    del out_type\n    return {'foo': 'This is not a shape', 'bar': 'But if I put a string here, it becomes a vector'}",
        "mutated": [
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateBrokenType)\ndef shape_v2_broken(input: _PrivateBrokenType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    del input\n    del out_type\n    return {'foo': 'This is not a shape', 'bar': 'But if I put a string here, it becomes a vector'}",
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateBrokenType)\ndef shape_v2_broken(input: _PrivateBrokenType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    del input\n    del out_type\n    return {'foo': 'This is not a shape', 'bar': 'But if I put a string here, it becomes a vector'}",
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateBrokenType)\ndef shape_v2_broken(input: _PrivateBrokenType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    del input\n    del out_type\n    return {'foo': 'This is not a shape', 'bar': 'But if I put a string here, it becomes a vector'}",
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateBrokenType)\ndef shape_v2_broken(input: _PrivateBrokenType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    del input\n    del out_type\n    return {'foo': 'This is not a shape', 'bar': 'But if I put a string here, it becomes a vector'}",
            "@dispatch.dispatch_for_types(array_ops.shape_v2, _PrivateBrokenType)\ndef shape_v2_broken(input: _PrivateBrokenType, out_type: dtypes.DType=None, name: Optional[str]=None) -> DynamicRaggedShape:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a DynamicRaggedShape containing the shape of the input.'\n    del name\n    del input\n    del out_type\n    return {'foo': 'This is not a shape', 'bar': 'But if I put a string here, it becomes a vector'}"
        ]
    },
    {
        "func_name": "assertAllEqual",
        "original": "def assertAllEqual(self, a, b, msg=None):\n    if not (isinstance(a, structured_tensor.StructuredTensor) or isinstance(b, structured_tensor.StructuredTensor)):\n        return super(StructuredTensorTest, self).assertAllEqual(a, b, msg)\n    if not isinstance(a, structured_tensor.StructuredTensor):\n        a = structured_tensor.StructuredTensor.from_pyval(a)\n        self._assertStructuredEqual(a, b, msg, False)\n    elif not isinstance(b, structured_tensor.StructuredTensor):\n        b = structured_tensor.StructuredTensor.from_pyval(b)\n        self._assertStructuredEqual(a, b, msg, False)\n    else:\n        self._assertStructuredEqual(a, b, msg, True)",
        "mutated": [
            "def assertAllEqual(self, a, b, msg=None):\n    if False:\n        i = 10\n    if not (isinstance(a, structured_tensor.StructuredTensor) or isinstance(b, structured_tensor.StructuredTensor)):\n        return super(StructuredTensorTest, self).assertAllEqual(a, b, msg)\n    if not isinstance(a, structured_tensor.StructuredTensor):\n        a = structured_tensor.StructuredTensor.from_pyval(a)\n        self._assertStructuredEqual(a, b, msg, False)\n    elif not isinstance(b, structured_tensor.StructuredTensor):\n        b = structured_tensor.StructuredTensor.from_pyval(b)\n        self._assertStructuredEqual(a, b, msg, False)\n    else:\n        self._assertStructuredEqual(a, b, msg, True)",
            "def assertAllEqual(self, a, b, msg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not (isinstance(a, structured_tensor.StructuredTensor) or isinstance(b, structured_tensor.StructuredTensor)):\n        return super(StructuredTensorTest, self).assertAllEqual(a, b, msg)\n    if not isinstance(a, structured_tensor.StructuredTensor):\n        a = structured_tensor.StructuredTensor.from_pyval(a)\n        self._assertStructuredEqual(a, b, msg, False)\n    elif not isinstance(b, structured_tensor.StructuredTensor):\n        b = structured_tensor.StructuredTensor.from_pyval(b)\n        self._assertStructuredEqual(a, b, msg, False)\n    else:\n        self._assertStructuredEqual(a, b, msg, True)",
            "def assertAllEqual(self, a, b, msg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not (isinstance(a, structured_tensor.StructuredTensor) or isinstance(b, structured_tensor.StructuredTensor)):\n        return super(StructuredTensorTest, self).assertAllEqual(a, b, msg)\n    if not isinstance(a, structured_tensor.StructuredTensor):\n        a = structured_tensor.StructuredTensor.from_pyval(a)\n        self._assertStructuredEqual(a, b, msg, False)\n    elif not isinstance(b, structured_tensor.StructuredTensor):\n        b = structured_tensor.StructuredTensor.from_pyval(b)\n        self._assertStructuredEqual(a, b, msg, False)\n    else:\n        self._assertStructuredEqual(a, b, msg, True)",
            "def assertAllEqual(self, a, b, msg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not (isinstance(a, structured_tensor.StructuredTensor) or isinstance(b, structured_tensor.StructuredTensor)):\n        return super(StructuredTensorTest, self).assertAllEqual(a, b, msg)\n    if not isinstance(a, structured_tensor.StructuredTensor):\n        a = structured_tensor.StructuredTensor.from_pyval(a)\n        self._assertStructuredEqual(a, b, msg, False)\n    elif not isinstance(b, structured_tensor.StructuredTensor):\n        b = structured_tensor.StructuredTensor.from_pyval(b)\n        self._assertStructuredEqual(a, b, msg, False)\n    else:\n        self._assertStructuredEqual(a, b, msg, True)",
            "def assertAllEqual(self, a, b, msg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not (isinstance(a, structured_tensor.StructuredTensor) or isinstance(b, structured_tensor.StructuredTensor)):\n        return super(StructuredTensorTest, self).assertAllEqual(a, b, msg)\n    if not isinstance(a, structured_tensor.StructuredTensor):\n        a = structured_tensor.StructuredTensor.from_pyval(a)\n        self._assertStructuredEqual(a, b, msg, False)\n    elif not isinstance(b, structured_tensor.StructuredTensor):\n        b = structured_tensor.StructuredTensor.from_pyval(b)\n        self._assertStructuredEqual(a, b, msg, False)\n    else:\n        self._assertStructuredEqual(a, b, msg, True)"
        ]
    },
    {
        "func_name": "_assertStructuredEqual",
        "original": "def _assertStructuredEqual(self, a, b, msg, check_shape):\n    if check_shape:\n        self.assertEqual(repr(a.shape), repr(b.shape))\n    self.assertEqual(set(a.field_names()), set(b.field_names()))\n    for field in a.field_names():\n        a_value = a.field_value(field)\n        b_value = b.field_value(field)\n        self.assertIs(type(a_value), type(b_value))\n        if isinstance(a_value, structured_tensor.StructuredTensor):\n            self._assertStructuredEqual(a_value, b_value, msg, check_shape)\n        else:\n            self.assertAllEqual(a_value, b_value, msg)",
        "mutated": [
            "def _assertStructuredEqual(self, a, b, msg, check_shape):\n    if False:\n        i = 10\n    if check_shape:\n        self.assertEqual(repr(a.shape), repr(b.shape))\n    self.assertEqual(set(a.field_names()), set(b.field_names()))\n    for field in a.field_names():\n        a_value = a.field_value(field)\n        b_value = b.field_value(field)\n        self.assertIs(type(a_value), type(b_value))\n        if isinstance(a_value, structured_tensor.StructuredTensor):\n            self._assertStructuredEqual(a_value, b_value, msg, check_shape)\n        else:\n            self.assertAllEqual(a_value, b_value, msg)",
            "def _assertStructuredEqual(self, a, b, msg, check_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if check_shape:\n        self.assertEqual(repr(a.shape), repr(b.shape))\n    self.assertEqual(set(a.field_names()), set(b.field_names()))\n    for field in a.field_names():\n        a_value = a.field_value(field)\n        b_value = b.field_value(field)\n        self.assertIs(type(a_value), type(b_value))\n        if isinstance(a_value, structured_tensor.StructuredTensor):\n            self._assertStructuredEqual(a_value, b_value, msg, check_shape)\n        else:\n            self.assertAllEqual(a_value, b_value, msg)",
            "def _assertStructuredEqual(self, a, b, msg, check_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if check_shape:\n        self.assertEqual(repr(a.shape), repr(b.shape))\n    self.assertEqual(set(a.field_names()), set(b.field_names()))\n    for field in a.field_names():\n        a_value = a.field_value(field)\n        b_value = b.field_value(field)\n        self.assertIs(type(a_value), type(b_value))\n        if isinstance(a_value, structured_tensor.StructuredTensor):\n            self._assertStructuredEqual(a_value, b_value, msg, check_shape)\n        else:\n            self.assertAllEqual(a_value, b_value, msg)",
            "def _assertStructuredEqual(self, a, b, msg, check_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if check_shape:\n        self.assertEqual(repr(a.shape), repr(b.shape))\n    self.assertEqual(set(a.field_names()), set(b.field_names()))\n    for field in a.field_names():\n        a_value = a.field_value(field)\n        b_value = b.field_value(field)\n        self.assertIs(type(a_value), type(b_value))\n        if isinstance(a_value, structured_tensor.StructuredTensor):\n            self._assertStructuredEqual(a_value, b_value, msg, check_shape)\n        else:\n            self.assertAllEqual(a_value, b_value, msg)",
            "def _assertStructuredEqual(self, a, b, msg, check_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if check_shape:\n        self.assertEqual(repr(a.shape), repr(b.shape))\n    self.assertEqual(set(a.field_names()), set(b.field_names()))\n    for field in a.field_names():\n        a_value = a.field_value(field)\n        b_value = b.field_value(field)\n        self.assertIs(type(a_value), type(b_value))\n        if isinstance(a_value, structured_tensor.StructuredTensor):\n            self._assertStructuredEqual(a_value, b_value, msg, check_shape)\n        else:\n            self.assertAllEqual(a_value, b_value, msg)"
        ]
    },
    {
        "func_name": "testFromFieldsAndRank",
        "original": "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithTensorFields', 'rank': 0, 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}, 'expected_shape': []}, {'testcase_name': 'Rank0_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithMixedFields', 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank1_WithExplicitNrows', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithMixedFields', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithNoElements', 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}, 'rank': 1, 'expected_shape': [0]}, {'testcase_name': 'Rank1_InferDimSize', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithTensorFields', 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'rank': 2, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithStructuredFields', 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithDiffDTypes', 'fields': lambda : {'a': ragged_factory_ops.constant_value([[1], [2, 3]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant_value([['a'], ['b', 'c']], row_splits_dtype=dtypes.int64)}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithMixedFields', 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'rank': 2, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithMixedFields', 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'rank': 4, 'expected_shape': [1, 2, 3, 1]}])\ndef testFromFieldsAndRank(self, fields, rank, expected_shape):\n    if callable(fields):\n        fields = fields()\n    struct = StructuredTensor.from_fields_and_rank(fields, rank)\n    self.assertEqual(struct.shape.as_list(), expected_shape)",
        "mutated": [
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithTensorFields', 'rank': 0, 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}, 'expected_shape': []}, {'testcase_name': 'Rank0_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithMixedFields', 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank1_WithExplicitNrows', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithMixedFields', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithNoElements', 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}, 'rank': 1, 'expected_shape': [0]}, {'testcase_name': 'Rank1_InferDimSize', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithTensorFields', 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'rank': 2, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithStructuredFields', 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithDiffDTypes', 'fields': lambda : {'a': ragged_factory_ops.constant_value([[1], [2, 3]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant_value([['a'], ['b', 'c']], row_splits_dtype=dtypes.int64)}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithMixedFields', 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'rank': 2, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithMixedFields', 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'rank': 4, 'expected_shape': [1, 2, 3, 1]}])\ndef testFromFieldsAndRank(self, fields, rank, expected_shape):\n    if False:\n        i = 10\n    if callable(fields):\n        fields = fields()\n    struct = StructuredTensor.from_fields_and_rank(fields, rank)\n    self.assertEqual(struct.shape.as_list(), expected_shape)",
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithTensorFields', 'rank': 0, 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}, 'expected_shape': []}, {'testcase_name': 'Rank0_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithMixedFields', 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank1_WithExplicitNrows', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithMixedFields', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithNoElements', 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}, 'rank': 1, 'expected_shape': [0]}, {'testcase_name': 'Rank1_InferDimSize', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithTensorFields', 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'rank': 2, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithStructuredFields', 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithDiffDTypes', 'fields': lambda : {'a': ragged_factory_ops.constant_value([[1], [2, 3]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant_value([['a'], ['b', 'c']], row_splits_dtype=dtypes.int64)}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithMixedFields', 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'rank': 2, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithMixedFields', 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'rank': 4, 'expected_shape': [1, 2, 3, 1]}])\ndef testFromFieldsAndRank(self, fields, rank, expected_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if callable(fields):\n        fields = fields()\n    struct = StructuredTensor.from_fields_and_rank(fields, rank)\n    self.assertEqual(struct.shape.as_list(), expected_shape)",
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithTensorFields', 'rank': 0, 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}, 'expected_shape': []}, {'testcase_name': 'Rank0_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithMixedFields', 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank1_WithExplicitNrows', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithMixedFields', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithNoElements', 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}, 'rank': 1, 'expected_shape': [0]}, {'testcase_name': 'Rank1_InferDimSize', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithTensorFields', 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'rank': 2, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithStructuredFields', 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithDiffDTypes', 'fields': lambda : {'a': ragged_factory_ops.constant_value([[1], [2, 3]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant_value([['a'], ['b', 'c']], row_splits_dtype=dtypes.int64)}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithMixedFields', 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'rank': 2, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithMixedFields', 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'rank': 4, 'expected_shape': [1, 2, 3, 1]}])\ndef testFromFieldsAndRank(self, fields, rank, expected_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if callable(fields):\n        fields = fields()\n    struct = StructuredTensor.from_fields_and_rank(fields, rank)\n    self.assertEqual(struct.shape.as_list(), expected_shape)",
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithTensorFields', 'rank': 0, 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}, 'expected_shape': []}, {'testcase_name': 'Rank0_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithMixedFields', 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank1_WithExplicitNrows', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithMixedFields', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithNoElements', 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}, 'rank': 1, 'expected_shape': [0]}, {'testcase_name': 'Rank1_InferDimSize', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithTensorFields', 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'rank': 2, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithStructuredFields', 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithDiffDTypes', 'fields': lambda : {'a': ragged_factory_ops.constant_value([[1], [2, 3]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant_value([['a'], ['b', 'c']], row_splits_dtype=dtypes.int64)}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithMixedFields', 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'rank': 2, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithMixedFields', 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'rank': 4, 'expected_shape': [1, 2, 3, 1]}])\ndef testFromFieldsAndRank(self, fields, rank, expected_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if callable(fields):\n        fields = fields()\n    struct = StructuredTensor.from_fields_and_rank(fields, rank)\n    self.assertEqual(struct.shape.as_list(), expected_shape)",
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithTensorFields', 'rank': 0, 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}, 'expected_shape': []}, {'testcase_name': 'Rank0_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank0_WithMixedFields', 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}, 'rank': 0, 'expected_shape': []}, {'testcase_name': 'Rank1_WithExplicitNrows', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithRaggedFields', 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithStructuredFields', 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithMixedFields', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithNoElements', 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}, 'rank': 1, 'expected_shape': [0]}, {'testcase_name': 'Rank1_InferDimSize', 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'rank': 1, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithTensorFields', 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'rank': 2, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithStructuredFields', 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithDiffDTypes', 'fields': lambda : {'a': ragged_factory_ops.constant_value([[1], [2, 3]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant_value([['a'], ['b', 'c']], row_splits_dtype=dtypes.int64)}, 'rank': 2, 'expected_shape': [2, None]}, {'testcase_name': 'Rank2_WithMixedFields', 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'rank': 2, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithMixedFields', 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'rank': 4, 'expected_shape': [1, 2, 3, 1]}])\ndef testFromFieldsAndRank(self, fields, rank, expected_shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if callable(fields):\n        fields = fields()\n    struct = StructuredTensor.from_fields_and_rank(fields, rank)\n    self.assertEqual(struct.shape.as_list(), expected_shape)"
        ]
    },
    {
        "func_name": "testFromFieldsAndRankError",
        "original": "@parameterized.named_parameters([{'testcase_name': 'NoFields', 'rank': 1, 'fields': {}, 'msg': 'Must provide at least one field'}, {'testcase_name': 'IntegerRank', 'rank': 0.5, 'fields': {'foo': [1]}, 'msg': 'rank must be an integer'}, {'testcase_name': 'NonNegativeRank', 'rank': -1, 'fields': {'bar': [1, 2, 3]}, 'msg': 'rank must be nonnegative'}])\ndef testFromFieldsAndRankError(self, fields, rank, msg):\n    if callable(fields):\n        fields = fields()\n    with self.assertRaisesRegex(ValueError, msg):\n        StructuredTensor.from_fields_and_rank(fields, rank)",
        "mutated": [
            "@parameterized.named_parameters([{'testcase_name': 'NoFields', 'rank': 1, 'fields': {}, 'msg': 'Must provide at least one field'}, {'testcase_name': 'IntegerRank', 'rank': 0.5, 'fields': {'foo': [1]}, 'msg': 'rank must be an integer'}, {'testcase_name': 'NonNegativeRank', 'rank': -1, 'fields': {'bar': [1, 2, 3]}, 'msg': 'rank must be nonnegative'}])\ndef testFromFieldsAndRankError(self, fields, rank, msg):\n    if False:\n        i = 10\n    if callable(fields):\n        fields = fields()\n    with self.assertRaisesRegex(ValueError, msg):\n        StructuredTensor.from_fields_and_rank(fields, rank)",
            "@parameterized.named_parameters([{'testcase_name': 'NoFields', 'rank': 1, 'fields': {}, 'msg': 'Must provide at least one field'}, {'testcase_name': 'IntegerRank', 'rank': 0.5, 'fields': {'foo': [1]}, 'msg': 'rank must be an integer'}, {'testcase_name': 'NonNegativeRank', 'rank': -1, 'fields': {'bar': [1, 2, 3]}, 'msg': 'rank must be nonnegative'}])\ndef testFromFieldsAndRankError(self, fields, rank, msg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if callable(fields):\n        fields = fields()\n    with self.assertRaisesRegex(ValueError, msg):\n        StructuredTensor.from_fields_and_rank(fields, rank)",
            "@parameterized.named_parameters([{'testcase_name': 'NoFields', 'rank': 1, 'fields': {}, 'msg': 'Must provide at least one field'}, {'testcase_name': 'IntegerRank', 'rank': 0.5, 'fields': {'foo': [1]}, 'msg': 'rank must be an integer'}, {'testcase_name': 'NonNegativeRank', 'rank': -1, 'fields': {'bar': [1, 2, 3]}, 'msg': 'rank must be nonnegative'}])\ndef testFromFieldsAndRankError(self, fields, rank, msg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if callable(fields):\n        fields = fields()\n    with self.assertRaisesRegex(ValueError, msg):\n        StructuredTensor.from_fields_and_rank(fields, rank)",
            "@parameterized.named_parameters([{'testcase_name': 'NoFields', 'rank': 1, 'fields': {}, 'msg': 'Must provide at least one field'}, {'testcase_name': 'IntegerRank', 'rank': 0.5, 'fields': {'foo': [1]}, 'msg': 'rank must be an integer'}, {'testcase_name': 'NonNegativeRank', 'rank': -1, 'fields': {'bar': [1, 2, 3]}, 'msg': 'rank must be nonnegative'}])\ndef testFromFieldsAndRankError(self, fields, rank, msg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if callable(fields):\n        fields = fields()\n    with self.assertRaisesRegex(ValueError, msg):\n        StructuredTensor.from_fields_and_rank(fields, rank)",
            "@parameterized.named_parameters([{'testcase_name': 'NoFields', 'rank': 1, 'fields': {}, 'msg': 'Must provide at least one field'}, {'testcase_name': 'IntegerRank', 'rank': 0.5, 'fields': {'foo': [1]}, 'msg': 'rank must be an integer'}, {'testcase_name': 'NonNegativeRank', 'rank': -1, 'fields': {'bar': [1, 2, 3]}, 'msg': 'rank must be nonnegative'}])\ndef testFromFieldsAndRankError(self, fields, rank, msg):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if callable(fields):\n        fields = fields()\n    with self.assertRaisesRegex(ValueError, msg):\n        StructuredTensor.from_fields_and_rank(fields, rank)"
        ]
    },
    {
        "func_name": "testFromFields",
        "original": "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithNoFields', 'shape': [], 'fields': {}}, {'testcase_name': 'Rank0_WithTensorFields', 'shape': [], 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}}, {'testcase_name': 'Rank0_WithRaggedFields', 'shape': [], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}}, {'testcase_name': 'Rank0_WithStructuredFields', 'shape': [], 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank0_WithMixedFields', 'shape': [], 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}}, {'testcase_name': 'Rank1_WithNoFields', 'shape': [2], 'fields': {}}, {'testcase_name': 'Rank1_WithExplicitNrows', 'shape': [None], 'nrows': 2, 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'shape': [2], 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}}, {'testcase_name': 'Rank1_WithRaggedFields', 'shape': [2], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}}, {'testcase_name': 'Rank1_WithStructuredFields', 'shape': [2], 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithMixedFields', 'shape': [2], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithNoElements', 'shape': [0], 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}}, {'testcase_name': 'Rank1_InferDimSize', 'shape': [None], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithNoFields', 'shape': [2, 8], 'fields': {}}, {'testcase_name': 'Rank2_WithNoFieldsAndExplicitRowPartitions', 'shape': [2, None], 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 7])], 'fields': {}}, {'testcase_name': 'Rank2_WithTensorFields', 'shape': [None, None], 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'shape': [2, None], 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}}, {'testcase_name': 'Rank2_WithStructuredFields', 'shape': [2, None], 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}}, {'testcase_name': 'Rank2_WithMixedFields', 'shape': [2, None], 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithNoFields', 'shape': [1, None, None, 3], 'fields': {}, 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3]), row_partition.RowPartition.from_row_lengths([2, 0, 1]), row_partition.RowPartition.from_uniform_row_length(3, nvals=9)]}, {'testcase_name': 'Rank4_WithMixedFields', 'shape': [1, None, None, 1], 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'expected_shape': [1, 2, 3, 1]}, {'testcase_name': 'mixed_shape_dtype', 'fields': {}, 'shape': [None, None], 'nrows': lambda : constant_op.constant(2, dtypes.int32), 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 4])], 'expected_shape': [2, None]}, {'testcase_name': 'mixed_shape_dtype_fields', 'fields': lambda : {'a': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int64)}, 'shape': [None, None], 'expected_shape': [1, None]}])\ndef testFromFields(self, shape, fields, expected_shape=None, nrows=None, row_partitions=None):\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    for validate in (True, False):\n        struct = StructuredTensor.from_fields(fields, shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        if expected_shape is None:\n            expected_shape = shape\n        self.assertEqual(struct.shape.as_list(), expected_shape)\n        self.assertLen(expected_shape, struct.rank)\n        self.assertCountEqual(struct.field_names(), tuple(fields.keys()))\n        for (field, value) in fields.items():\n            self.assertIsInstance(struct.field_value(field), (tensor.Tensor, structured_tensor.StructuredTensor, ragged_tensor.RaggedTensor))\n            self.assertAllEqual(struct.field_value(field), value)",
        "mutated": [
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithNoFields', 'shape': [], 'fields': {}}, {'testcase_name': 'Rank0_WithTensorFields', 'shape': [], 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}}, {'testcase_name': 'Rank0_WithRaggedFields', 'shape': [], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}}, {'testcase_name': 'Rank0_WithStructuredFields', 'shape': [], 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank0_WithMixedFields', 'shape': [], 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}}, {'testcase_name': 'Rank1_WithNoFields', 'shape': [2], 'fields': {}}, {'testcase_name': 'Rank1_WithExplicitNrows', 'shape': [None], 'nrows': 2, 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'shape': [2], 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}}, {'testcase_name': 'Rank1_WithRaggedFields', 'shape': [2], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}}, {'testcase_name': 'Rank1_WithStructuredFields', 'shape': [2], 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithMixedFields', 'shape': [2], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithNoElements', 'shape': [0], 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}}, {'testcase_name': 'Rank1_InferDimSize', 'shape': [None], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithNoFields', 'shape': [2, 8], 'fields': {}}, {'testcase_name': 'Rank2_WithNoFieldsAndExplicitRowPartitions', 'shape': [2, None], 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 7])], 'fields': {}}, {'testcase_name': 'Rank2_WithTensorFields', 'shape': [None, None], 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'shape': [2, None], 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}}, {'testcase_name': 'Rank2_WithStructuredFields', 'shape': [2, None], 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}}, {'testcase_name': 'Rank2_WithMixedFields', 'shape': [2, None], 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithNoFields', 'shape': [1, None, None, 3], 'fields': {}, 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3]), row_partition.RowPartition.from_row_lengths([2, 0, 1]), row_partition.RowPartition.from_uniform_row_length(3, nvals=9)]}, {'testcase_name': 'Rank4_WithMixedFields', 'shape': [1, None, None, 1], 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'expected_shape': [1, 2, 3, 1]}, {'testcase_name': 'mixed_shape_dtype', 'fields': {}, 'shape': [None, None], 'nrows': lambda : constant_op.constant(2, dtypes.int32), 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 4])], 'expected_shape': [2, None]}, {'testcase_name': 'mixed_shape_dtype_fields', 'fields': lambda : {'a': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int64)}, 'shape': [None, None], 'expected_shape': [1, None]}])\ndef testFromFields(self, shape, fields, expected_shape=None, nrows=None, row_partitions=None):\n    if False:\n        i = 10\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    for validate in (True, False):\n        struct = StructuredTensor.from_fields(fields, shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        if expected_shape is None:\n            expected_shape = shape\n        self.assertEqual(struct.shape.as_list(), expected_shape)\n        self.assertLen(expected_shape, struct.rank)\n        self.assertCountEqual(struct.field_names(), tuple(fields.keys()))\n        for (field, value) in fields.items():\n            self.assertIsInstance(struct.field_value(field), (tensor.Tensor, structured_tensor.StructuredTensor, ragged_tensor.RaggedTensor))\n            self.assertAllEqual(struct.field_value(field), value)",
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithNoFields', 'shape': [], 'fields': {}}, {'testcase_name': 'Rank0_WithTensorFields', 'shape': [], 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}}, {'testcase_name': 'Rank0_WithRaggedFields', 'shape': [], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}}, {'testcase_name': 'Rank0_WithStructuredFields', 'shape': [], 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank0_WithMixedFields', 'shape': [], 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}}, {'testcase_name': 'Rank1_WithNoFields', 'shape': [2], 'fields': {}}, {'testcase_name': 'Rank1_WithExplicitNrows', 'shape': [None], 'nrows': 2, 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'shape': [2], 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}}, {'testcase_name': 'Rank1_WithRaggedFields', 'shape': [2], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}}, {'testcase_name': 'Rank1_WithStructuredFields', 'shape': [2], 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithMixedFields', 'shape': [2], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithNoElements', 'shape': [0], 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}}, {'testcase_name': 'Rank1_InferDimSize', 'shape': [None], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithNoFields', 'shape': [2, 8], 'fields': {}}, {'testcase_name': 'Rank2_WithNoFieldsAndExplicitRowPartitions', 'shape': [2, None], 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 7])], 'fields': {}}, {'testcase_name': 'Rank2_WithTensorFields', 'shape': [None, None], 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'shape': [2, None], 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}}, {'testcase_name': 'Rank2_WithStructuredFields', 'shape': [2, None], 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}}, {'testcase_name': 'Rank2_WithMixedFields', 'shape': [2, None], 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithNoFields', 'shape': [1, None, None, 3], 'fields': {}, 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3]), row_partition.RowPartition.from_row_lengths([2, 0, 1]), row_partition.RowPartition.from_uniform_row_length(3, nvals=9)]}, {'testcase_name': 'Rank4_WithMixedFields', 'shape': [1, None, None, 1], 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'expected_shape': [1, 2, 3, 1]}, {'testcase_name': 'mixed_shape_dtype', 'fields': {}, 'shape': [None, None], 'nrows': lambda : constant_op.constant(2, dtypes.int32), 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 4])], 'expected_shape': [2, None]}, {'testcase_name': 'mixed_shape_dtype_fields', 'fields': lambda : {'a': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int64)}, 'shape': [None, None], 'expected_shape': [1, None]}])\ndef testFromFields(self, shape, fields, expected_shape=None, nrows=None, row_partitions=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    for validate in (True, False):\n        struct = StructuredTensor.from_fields(fields, shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        if expected_shape is None:\n            expected_shape = shape\n        self.assertEqual(struct.shape.as_list(), expected_shape)\n        self.assertLen(expected_shape, struct.rank)\n        self.assertCountEqual(struct.field_names(), tuple(fields.keys()))\n        for (field, value) in fields.items():\n            self.assertIsInstance(struct.field_value(field), (tensor.Tensor, structured_tensor.StructuredTensor, ragged_tensor.RaggedTensor))\n            self.assertAllEqual(struct.field_value(field), value)",
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithNoFields', 'shape': [], 'fields': {}}, {'testcase_name': 'Rank0_WithTensorFields', 'shape': [], 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}}, {'testcase_name': 'Rank0_WithRaggedFields', 'shape': [], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}}, {'testcase_name': 'Rank0_WithStructuredFields', 'shape': [], 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank0_WithMixedFields', 'shape': [], 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}}, {'testcase_name': 'Rank1_WithNoFields', 'shape': [2], 'fields': {}}, {'testcase_name': 'Rank1_WithExplicitNrows', 'shape': [None], 'nrows': 2, 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'shape': [2], 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}}, {'testcase_name': 'Rank1_WithRaggedFields', 'shape': [2], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}}, {'testcase_name': 'Rank1_WithStructuredFields', 'shape': [2], 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithMixedFields', 'shape': [2], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithNoElements', 'shape': [0], 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}}, {'testcase_name': 'Rank1_InferDimSize', 'shape': [None], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithNoFields', 'shape': [2, 8], 'fields': {}}, {'testcase_name': 'Rank2_WithNoFieldsAndExplicitRowPartitions', 'shape': [2, None], 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 7])], 'fields': {}}, {'testcase_name': 'Rank2_WithTensorFields', 'shape': [None, None], 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'shape': [2, None], 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}}, {'testcase_name': 'Rank2_WithStructuredFields', 'shape': [2, None], 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}}, {'testcase_name': 'Rank2_WithMixedFields', 'shape': [2, None], 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithNoFields', 'shape': [1, None, None, 3], 'fields': {}, 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3]), row_partition.RowPartition.from_row_lengths([2, 0, 1]), row_partition.RowPartition.from_uniform_row_length(3, nvals=9)]}, {'testcase_name': 'Rank4_WithMixedFields', 'shape': [1, None, None, 1], 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'expected_shape': [1, 2, 3, 1]}, {'testcase_name': 'mixed_shape_dtype', 'fields': {}, 'shape': [None, None], 'nrows': lambda : constant_op.constant(2, dtypes.int32), 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 4])], 'expected_shape': [2, None]}, {'testcase_name': 'mixed_shape_dtype_fields', 'fields': lambda : {'a': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int64)}, 'shape': [None, None], 'expected_shape': [1, None]}])\ndef testFromFields(self, shape, fields, expected_shape=None, nrows=None, row_partitions=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    for validate in (True, False):\n        struct = StructuredTensor.from_fields(fields, shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        if expected_shape is None:\n            expected_shape = shape\n        self.assertEqual(struct.shape.as_list(), expected_shape)\n        self.assertLen(expected_shape, struct.rank)\n        self.assertCountEqual(struct.field_names(), tuple(fields.keys()))\n        for (field, value) in fields.items():\n            self.assertIsInstance(struct.field_value(field), (tensor.Tensor, structured_tensor.StructuredTensor, ragged_tensor.RaggedTensor))\n            self.assertAllEqual(struct.field_value(field), value)",
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithNoFields', 'shape': [], 'fields': {}}, {'testcase_name': 'Rank0_WithTensorFields', 'shape': [], 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}}, {'testcase_name': 'Rank0_WithRaggedFields', 'shape': [], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}}, {'testcase_name': 'Rank0_WithStructuredFields', 'shape': [], 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank0_WithMixedFields', 'shape': [], 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}}, {'testcase_name': 'Rank1_WithNoFields', 'shape': [2], 'fields': {}}, {'testcase_name': 'Rank1_WithExplicitNrows', 'shape': [None], 'nrows': 2, 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'shape': [2], 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}}, {'testcase_name': 'Rank1_WithRaggedFields', 'shape': [2], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}}, {'testcase_name': 'Rank1_WithStructuredFields', 'shape': [2], 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithMixedFields', 'shape': [2], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithNoElements', 'shape': [0], 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}}, {'testcase_name': 'Rank1_InferDimSize', 'shape': [None], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithNoFields', 'shape': [2, 8], 'fields': {}}, {'testcase_name': 'Rank2_WithNoFieldsAndExplicitRowPartitions', 'shape': [2, None], 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 7])], 'fields': {}}, {'testcase_name': 'Rank2_WithTensorFields', 'shape': [None, None], 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'shape': [2, None], 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}}, {'testcase_name': 'Rank2_WithStructuredFields', 'shape': [2, None], 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}}, {'testcase_name': 'Rank2_WithMixedFields', 'shape': [2, None], 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithNoFields', 'shape': [1, None, None, 3], 'fields': {}, 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3]), row_partition.RowPartition.from_row_lengths([2, 0, 1]), row_partition.RowPartition.from_uniform_row_length(3, nvals=9)]}, {'testcase_name': 'Rank4_WithMixedFields', 'shape': [1, None, None, 1], 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'expected_shape': [1, 2, 3, 1]}, {'testcase_name': 'mixed_shape_dtype', 'fields': {}, 'shape': [None, None], 'nrows': lambda : constant_op.constant(2, dtypes.int32), 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 4])], 'expected_shape': [2, None]}, {'testcase_name': 'mixed_shape_dtype_fields', 'fields': lambda : {'a': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int64)}, 'shape': [None, None], 'expected_shape': [1, None]}])\ndef testFromFields(self, shape, fields, expected_shape=None, nrows=None, row_partitions=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    for validate in (True, False):\n        struct = StructuredTensor.from_fields(fields, shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        if expected_shape is None:\n            expected_shape = shape\n        self.assertEqual(struct.shape.as_list(), expected_shape)\n        self.assertLen(expected_shape, struct.rank)\n        self.assertCountEqual(struct.field_names(), tuple(fields.keys()))\n        for (field, value) in fields.items():\n            self.assertIsInstance(struct.field_value(field), (tensor.Tensor, structured_tensor.StructuredTensor, ragged_tensor.RaggedTensor))\n            self.assertAllEqual(struct.field_value(field), value)",
            "@parameterized.named_parameters([{'testcase_name': 'Rank0_WithNoFields', 'shape': [], 'fields': {}}, {'testcase_name': 'Rank0_WithTensorFields', 'shape': [], 'fields': {'Foo': 5, 'Bar': [1, 2, 3]}}, {'testcase_name': 'Rank0_WithRaggedFields', 'shape': [], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [], [[5, 6]]]), 'r': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=1), 's': ragged_factory_ops.constant_value([[[4]], [], [[5]]], ragged_rank=2)}}, {'testcase_name': 'Rank0_WithStructuredFields', 'shape': [], 'fields': lambda : {'foo': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]}), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank0_WithMixedFields', 'shape': [], 'fields': lambda : {'f1': 5, 'f2': [1, 2, 3], 'f3': ragged_factory_ops.constant_value([[1, 2], [3]]), 'f4': StructuredTensor.from_pyval({'a': 1, 'b': [1, 2, 3]})}}, {'testcase_name': 'Rank1_WithNoFields', 'shape': [2], 'fields': {}}, {'testcase_name': 'Rank1_WithExplicitNrows', 'shape': [None], 'nrows': 2, 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}, 'expected_shape': [2]}, {'testcase_name': 'Rank1_WithTensorFields', 'shape': [2], 'fields': {'x': [1, 2], 'y': [[1, 2], [3, 4]]}}, {'testcase_name': 'Rank1_WithRaggedFields', 'shape': [2], 'fields': {'p': ragged_factory_ops.constant_value([[1, 2], [3]]), 'q': ragged_factory_ops.constant_value([[[4]], [[5, 6], [7]]]), 'r': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]]), 's': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=1), 't': ragged_factory_ops.constant_value([[], [[[12]], [[13]]]], ragged_rank=2)}}, {'testcase_name': 'Rank1_WithStructuredFields', 'shape': [2], 'fields': lambda : {'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithMixedFields', 'shape': [2], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 's': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}}, {'testcase_name': 'Rank1_WithNoElements', 'shape': [0], 'fields': lambda : {'x': [], 'y': np.zeros([0, 8]), 'r': ragged_factory_ops.constant([], ragged_rank=1), 's': StructuredTensor.from_pyval([])}}, {'testcase_name': 'Rank1_InferDimSize', 'shape': [None], 'fields': lambda : {'x': [1, 2], 'y': [[1, 2], [3, 4]], 'r': ragged_factory_ops.constant_value([[1, 2], [3]]), 'p': ragged_factory_ops.constant_value([[4], [5, 6, 7]]), 'foo': StructuredTensor.from_pyval([{'a': 1, 'b': [1, 2, 3]}, {'a': 2, 'b': []}]), 'bar': StructuredTensor.from_pyval([[{'x': 12}], [{'x': 13}, {'x': 14}]])}, 'expected_shape': [2]}, {'testcase_name': 'Rank2_WithNoFields', 'shape': [2, 8], 'fields': {}}, {'testcase_name': 'Rank2_WithNoFieldsAndExplicitRowPartitions', 'shape': [2, None], 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 7])], 'fields': {}}, {'testcase_name': 'Rank2_WithTensorFields', 'shape': [None, None], 'fields': {'x': [[1, 2, 3], [4, 5, 6]], 'y': np.ones([2, 3, 8])}, 'expected_shape': [2, 3]}, {'testcase_name': 'Rank2_WithRaggedFields', 'shape': [2, None], 'fields': {'a': ragged_factory_ops.constant_value([[1, 2], [3]]), 'b': ragged_factory_ops.constant_value([[4, 5], [6]]), 'c': ragged_factory_ops.constant_value([[[1, 2], [3]], [[4, 5]]]), 'd': ragged_factory_ops.constant_value([[[[1, 2], [3]], [[4], [], [5]]], [[[6, 7, 8], []]]])}}, {'testcase_name': 'Rank2_WithStructuredFields', 'shape': [2, None], 'fields': lambda : {'a': StructuredTensor.from_pyval([[{'x': 1}], [{'x': 2}, {'x': 3}]]), 'b': StructuredTensor.from_pyval([[[{'y': 1}]], [[], [{'y': 2}, {'y': 3}]]])}}, {'testcase_name': 'Rank2_WithMixedFields', 'shape': [2, None], 'fields': lambda : {'a': [[1, 2], [3, 4]], 'b': ragged_factory_ops.constant_value([[1, 2], [3, 4]]), 'c': StructuredTensor.from_pyval([[[{'y': 1}], []], [[], [{'y': 2}, {'y': 3}]]]), 'd': ragged_factory_ops.constant_value([[[1, 2], []], [[3], [4]]])}, 'expected_shape': [2, 2]}, {'testcase_name': 'Rank4_WithNoFields', 'shape': [1, None, None, 3], 'fields': {}, 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3]), row_partition.RowPartition.from_row_lengths([2, 0, 1]), row_partition.RowPartition.from_uniform_row_length(3, nvals=9)]}, {'testcase_name': 'Rank4_WithMixedFields', 'shape': [1, None, None, 1], 'fields': lambda : {'a': np.ones([1, 2, 3, 1]), 'b': np.ones([1, 2, 3, 1, 5]), 'c': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1])), 'd': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3]).tolist(), ragged_rank=1), 'e': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 2, 2]).tolist(), ragged_rank=2), 'f': ragged_factory_ops.constant(np.zeros([1, 2, 3, 1, 3])), 'g': StructuredTensor.from_pyval([[[[{'x': j, 'y': k}] for k in range(3)] for j in range(2)]]), 'h': StructuredTensor.from_pyval([[[[[{'x': j, 'y': k, 'z': z} for z in range(j)]] for k in range(3)] for j in range(2)]])}, 'expected_shape': [1, 2, 3, 1]}, {'testcase_name': 'mixed_shape_dtype', 'fields': {}, 'shape': [None, None], 'nrows': lambda : constant_op.constant(2, dtypes.int32), 'row_partitions': lambda : [row_partition.RowPartition.from_row_lengths([3, 4])], 'expected_shape': [2, None]}, {'testcase_name': 'mixed_shape_dtype_fields', 'fields': lambda : {'a': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int32), 'b': ragged_factory_ops.constant([[1]], row_splits_dtype=dtypes.int64)}, 'shape': [None, None], 'expected_shape': [1, None]}])\ndef testFromFields(self, shape, fields, expected_shape=None, nrows=None, row_partitions=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    for validate in (True, False):\n        struct = StructuredTensor.from_fields(fields, shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        if expected_shape is None:\n            expected_shape = shape\n        self.assertEqual(struct.shape.as_list(), expected_shape)\n        self.assertLen(expected_shape, struct.rank)\n        self.assertCountEqual(struct.field_names(), tuple(fields.keys()))\n        for (field, value) in fields.items():\n            self.assertIsInstance(struct.field_value(field), (tensor.Tensor, structured_tensor.StructuredTensor, ragged_tensor.RaggedTensor))\n            self.assertAllEqual(struct.field_value(field), value)"
        ]
    },
    {
        "func_name": "testFromFieldsErrors",
        "original": "@parameterized.parameters([dict(fields={}, shape=object(), err=TypeError), dict(fields=object(), shape=[], err=TypeError, msg='fields must be a dictionary'), dict(fields={1: 2}, shape=[], err=TypeError, msg='Unexpected type for key'), dict(fields={'x': object()}, shape=[], err=(TypeError, ValueError), msg='Error with shape of x|Unexpected type for value'), dict(fields={}, shape=None, err=ValueError, msg=\"StructuredTensor's shape must have known rank\"), dict(fields={'f': 5}, shape=[5], err=ValueError, msg='Field f has shape \\\\(\\\\), which is incompatible with the shape that was specified or inferred from other fields: \\\\(5,\\\\)|Shapes'), dict(fields=dict(x=[1], y=[]), shape=[None], err=ValueError, msg='Error in shape of y'), dict(fields={'': 5}, shape=[], err=ValueError, msg=\"Field name '' is not currently allowed.\"), dict(fields={'_': 5}, shape=[], err=ValueError, msg=\"Field name '_' is not currently allowed.\"), dict(fields={'r1': ragged_factory_ops.constant_value([[1, 2], [3]]), 'r2': ragged_factory_ops.constant_value([[1, 2, 3], [4]])}, shape=[2, None], validate=True, err=ValueError, msg='Error in shape of r2'), dict(fields={}, shape=(), nrows=5, err=ValueError, msg='nrows must be None if shape.rank==0'), dict(fields={}, shape=(), row_partitions=[0], err=ValueError, msg='row_partitions must be None or \\\\[\\\\] if shape.rank<2'), dict(fields={}, shape=(None, None, None), row_partitions=[], err=ValueError, msg='len\\\\(row_partitions\\\\) must be shape.rank-1'), dict(fields={}, shape=[None], err=ValueError, msg='Must specify `nrows`, a fully specified `shape`, or have `fields` if `rank=1`'), dict(fields={}, shape=[None, None], err=ValueError, msg='Must specify row_partitions, a fully specified shape, or have fields if rank > 1')])\ndef testFromFieldsErrors(self, fields, shape, nrows=None, row_partitions=None, validate=False, err=ValueError, msg=None, test_in_eager=True):\n    if not test_in_eager and context.executing_eagerly():\n        return\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    with self.assertRaisesRegex(err, msg):\n        struct = StructuredTensor.from_fields(fields=fields, shape=shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        for field_name in struct.field_names():\n            self.evaluate(struct.field_value(field_name))\n        self.evaluate(struct.nrows())",
        "mutated": [
            "@parameterized.parameters([dict(fields={}, shape=object(), err=TypeError), dict(fields=object(), shape=[], err=TypeError, msg='fields must be a dictionary'), dict(fields={1: 2}, shape=[], err=TypeError, msg='Unexpected type for key'), dict(fields={'x': object()}, shape=[], err=(TypeError, ValueError), msg='Error with shape of x|Unexpected type for value'), dict(fields={}, shape=None, err=ValueError, msg=\"StructuredTensor's shape must have known rank\"), dict(fields={'f': 5}, shape=[5], err=ValueError, msg='Field f has shape \\\\(\\\\), which is incompatible with the shape that was specified or inferred from other fields: \\\\(5,\\\\)|Shapes'), dict(fields=dict(x=[1], y=[]), shape=[None], err=ValueError, msg='Error in shape of y'), dict(fields={'': 5}, shape=[], err=ValueError, msg=\"Field name '' is not currently allowed.\"), dict(fields={'_': 5}, shape=[], err=ValueError, msg=\"Field name '_' is not currently allowed.\"), dict(fields={'r1': ragged_factory_ops.constant_value([[1, 2], [3]]), 'r2': ragged_factory_ops.constant_value([[1, 2, 3], [4]])}, shape=[2, None], validate=True, err=ValueError, msg='Error in shape of r2'), dict(fields={}, shape=(), nrows=5, err=ValueError, msg='nrows must be None if shape.rank==0'), dict(fields={}, shape=(), row_partitions=[0], err=ValueError, msg='row_partitions must be None or \\\\[\\\\] if shape.rank<2'), dict(fields={}, shape=(None, None, None), row_partitions=[], err=ValueError, msg='len\\\\(row_partitions\\\\) must be shape.rank-1'), dict(fields={}, shape=[None], err=ValueError, msg='Must specify `nrows`, a fully specified `shape`, or have `fields` if `rank=1`'), dict(fields={}, shape=[None, None], err=ValueError, msg='Must specify row_partitions, a fully specified shape, or have fields if rank > 1')])\ndef testFromFieldsErrors(self, fields, shape, nrows=None, row_partitions=None, validate=False, err=ValueError, msg=None, test_in_eager=True):\n    if False:\n        i = 10\n    if not test_in_eager and context.executing_eagerly():\n        return\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    with self.assertRaisesRegex(err, msg):\n        struct = StructuredTensor.from_fields(fields=fields, shape=shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        for field_name in struct.field_names():\n            self.evaluate(struct.field_value(field_name))\n        self.evaluate(struct.nrows())",
            "@parameterized.parameters([dict(fields={}, shape=object(), err=TypeError), dict(fields=object(), shape=[], err=TypeError, msg='fields must be a dictionary'), dict(fields={1: 2}, shape=[], err=TypeError, msg='Unexpected type for key'), dict(fields={'x': object()}, shape=[], err=(TypeError, ValueError), msg='Error with shape of x|Unexpected type for value'), dict(fields={}, shape=None, err=ValueError, msg=\"StructuredTensor's shape must have known rank\"), dict(fields={'f': 5}, shape=[5], err=ValueError, msg='Field f has shape \\\\(\\\\), which is incompatible with the shape that was specified or inferred from other fields: \\\\(5,\\\\)|Shapes'), dict(fields=dict(x=[1], y=[]), shape=[None], err=ValueError, msg='Error in shape of y'), dict(fields={'': 5}, shape=[], err=ValueError, msg=\"Field name '' is not currently allowed.\"), dict(fields={'_': 5}, shape=[], err=ValueError, msg=\"Field name '_' is not currently allowed.\"), dict(fields={'r1': ragged_factory_ops.constant_value([[1, 2], [3]]), 'r2': ragged_factory_ops.constant_value([[1, 2, 3], [4]])}, shape=[2, None], validate=True, err=ValueError, msg='Error in shape of r2'), dict(fields={}, shape=(), nrows=5, err=ValueError, msg='nrows must be None if shape.rank==0'), dict(fields={}, shape=(), row_partitions=[0], err=ValueError, msg='row_partitions must be None or \\\\[\\\\] if shape.rank<2'), dict(fields={}, shape=(None, None, None), row_partitions=[], err=ValueError, msg='len\\\\(row_partitions\\\\) must be shape.rank-1'), dict(fields={}, shape=[None], err=ValueError, msg='Must specify `nrows`, a fully specified `shape`, or have `fields` if `rank=1`'), dict(fields={}, shape=[None, None], err=ValueError, msg='Must specify row_partitions, a fully specified shape, or have fields if rank > 1')])\ndef testFromFieldsErrors(self, fields, shape, nrows=None, row_partitions=None, validate=False, err=ValueError, msg=None, test_in_eager=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not test_in_eager and context.executing_eagerly():\n        return\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    with self.assertRaisesRegex(err, msg):\n        struct = StructuredTensor.from_fields(fields=fields, shape=shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        for field_name in struct.field_names():\n            self.evaluate(struct.field_value(field_name))\n        self.evaluate(struct.nrows())",
            "@parameterized.parameters([dict(fields={}, shape=object(), err=TypeError), dict(fields=object(), shape=[], err=TypeError, msg='fields must be a dictionary'), dict(fields={1: 2}, shape=[], err=TypeError, msg='Unexpected type for key'), dict(fields={'x': object()}, shape=[], err=(TypeError, ValueError), msg='Error with shape of x|Unexpected type for value'), dict(fields={}, shape=None, err=ValueError, msg=\"StructuredTensor's shape must have known rank\"), dict(fields={'f': 5}, shape=[5], err=ValueError, msg='Field f has shape \\\\(\\\\), which is incompatible with the shape that was specified or inferred from other fields: \\\\(5,\\\\)|Shapes'), dict(fields=dict(x=[1], y=[]), shape=[None], err=ValueError, msg='Error in shape of y'), dict(fields={'': 5}, shape=[], err=ValueError, msg=\"Field name '' is not currently allowed.\"), dict(fields={'_': 5}, shape=[], err=ValueError, msg=\"Field name '_' is not currently allowed.\"), dict(fields={'r1': ragged_factory_ops.constant_value([[1, 2], [3]]), 'r2': ragged_factory_ops.constant_value([[1, 2, 3], [4]])}, shape=[2, None], validate=True, err=ValueError, msg='Error in shape of r2'), dict(fields={}, shape=(), nrows=5, err=ValueError, msg='nrows must be None if shape.rank==0'), dict(fields={}, shape=(), row_partitions=[0], err=ValueError, msg='row_partitions must be None or \\\\[\\\\] if shape.rank<2'), dict(fields={}, shape=(None, None, None), row_partitions=[], err=ValueError, msg='len\\\\(row_partitions\\\\) must be shape.rank-1'), dict(fields={}, shape=[None], err=ValueError, msg='Must specify `nrows`, a fully specified `shape`, or have `fields` if `rank=1`'), dict(fields={}, shape=[None, None], err=ValueError, msg='Must specify row_partitions, a fully specified shape, or have fields if rank > 1')])\ndef testFromFieldsErrors(self, fields, shape, nrows=None, row_partitions=None, validate=False, err=ValueError, msg=None, test_in_eager=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not test_in_eager and context.executing_eagerly():\n        return\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    with self.assertRaisesRegex(err, msg):\n        struct = StructuredTensor.from_fields(fields=fields, shape=shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        for field_name in struct.field_names():\n            self.evaluate(struct.field_value(field_name))\n        self.evaluate(struct.nrows())",
            "@parameterized.parameters([dict(fields={}, shape=object(), err=TypeError), dict(fields=object(), shape=[], err=TypeError, msg='fields must be a dictionary'), dict(fields={1: 2}, shape=[], err=TypeError, msg='Unexpected type for key'), dict(fields={'x': object()}, shape=[], err=(TypeError, ValueError), msg='Error with shape of x|Unexpected type for value'), dict(fields={}, shape=None, err=ValueError, msg=\"StructuredTensor's shape must have known rank\"), dict(fields={'f': 5}, shape=[5], err=ValueError, msg='Field f has shape \\\\(\\\\), which is incompatible with the shape that was specified or inferred from other fields: \\\\(5,\\\\)|Shapes'), dict(fields=dict(x=[1], y=[]), shape=[None], err=ValueError, msg='Error in shape of y'), dict(fields={'': 5}, shape=[], err=ValueError, msg=\"Field name '' is not currently allowed.\"), dict(fields={'_': 5}, shape=[], err=ValueError, msg=\"Field name '_' is not currently allowed.\"), dict(fields={'r1': ragged_factory_ops.constant_value([[1, 2], [3]]), 'r2': ragged_factory_ops.constant_value([[1, 2, 3], [4]])}, shape=[2, None], validate=True, err=ValueError, msg='Error in shape of r2'), dict(fields={}, shape=(), nrows=5, err=ValueError, msg='nrows must be None if shape.rank==0'), dict(fields={}, shape=(), row_partitions=[0], err=ValueError, msg='row_partitions must be None or \\\\[\\\\] if shape.rank<2'), dict(fields={}, shape=(None, None, None), row_partitions=[], err=ValueError, msg='len\\\\(row_partitions\\\\) must be shape.rank-1'), dict(fields={}, shape=[None], err=ValueError, msg='Must specify `nrows`, a fully specified `shape`, or have `fields` if `rank=1`'), dict(fields={}, shape=[None, None], err=ValueError, msg='Must specify row_partitions, a fully specified shape, or have fields if rank > 1')])\ndef testFromFieldsErrors(self, fields, shape, nrows=None, row_partitions=None, validate=False, err=ValueError, msg=None, test_in_eager=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not test_in_eager and context.executing_eagerly():\n        return\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    with self.assertRaisesRegex(err, msg):\n        struct = StructuredTensor.from_fields(fields=fields, shape=shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        for field_name in struct.field_names():\n            self.evaluate(struct.field_value(field_name))\n        self.evaluate(struct.nrows())",
            "@parameterized.parameters([dict(fields={}, shape=object(), err=TypeError), dict(fields=object(), shape=[], err=TypeError, msg='fields must be a dictionary'), dict(fields={1: 2}, shape=[], err=TypeError, msg='Unexpected type for key'), dict(fields={'x': object()}, shape=[], err=(TypeError, ValueError), msg='Error with shape of x|Unexpected type for value'), dict(fields={}, shape=None, err=ValueError, msg=\"StructuredTensor's shape must have known rank\"), dict(fields={'f': 5}, shape=[5], err=ValueError, msg='Field f has shape \\\\(\\\\), which is incompatible with the shape that was specified or inferred from other fields: \\\\(5,\\\\)|Shapes'), dict(fields=dict(x=[1], y=[]), shape=[None], err=ValueError, msg='Error in shape of y'), dict(fields={'': 5}, shape=[], err=ValueError, msg=\"Field name '' is not currently allowed.\"), dict(fields={'_': 5}, shape=[], err=ValueError, msg=\"Field name '_' is not currently allowed.\"), dict(fields={'r1': ragged_factory_ops.constant_value([[1, 2], [3]]), 'r2': ragged_factory_ops.constant_value([[1, 2, 3], [4]])}, shape=[2, None], validate=True, err=ValueError, msg='Error in shape of r2'), dict(fields={}, shape=(), nrows=5, err=ValueError, msg='nrows must be None if shape.rank==0'), dict(fields={}, shape=(), row_partitions=[0], err=ValueError, msg='row_partitions must be None or \\\\[\\\\] if shape.rank<2'), dict(fields={}, shape=(None, None, None), row_partitions=[], err=ValueError, msg='len\\\\(row_partitions\\\\) must be shape.rank-1'), dict(fields={}, shape=[None], err=ValueError, msg='Must specify `nrows`, a fully specified `shape`, or have `fields` if `rank=1`'), dict(fields={}, shape=[None, None], err=ValueError, msg='Must specify row_partitions, a fully specified shape, or have fields if rank > 1')])\ndef testFromFieldsErrors(self, fields, shape, nrows=None, row_partitions=None, validate=False, err=ValueError, msg=None, test_in_eager=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not test_in_eager and context.executing_eagerly():\n        return\n    if callable(fields):\n        fields = fields()\n    if callable(nrows):\n        nrows = nrows()\n    if callable(row_partitions):\n        row_partitions = row_partitions()\n    with self.assertRaisesRegex(err, msg):\n        struct = StructuredTensor.from_fields(fields=fields, shape=shape, nrows=nrows, row_partitions=row_partitions, validate=validate)\n        for field_name in struct.field_names():\n            self.evaluate(struct.field_value(field_name))\n        self.evaluate(struct.nrows())"
        ]
    },
    {
        "func_name": "testMergeNrowsErrors",
        "original": "def testMergeNrowsErrors(self):\n    nrows = constant_op.constant(5)\n    static_nrows = tensor_shape.Dimension(5)\n    value = constant_op.constant([1, 2, 3])\n    with self.assertRaisesRegex(ValueError, 'fields have incompatible nrows'):\n        structured_tensor._merge_nrows(nrows, static_nrows, value, dtypes.int32, validate=False)",
        "mutated": [
            "def testMergeNrowsErrors(self):\n    if False:\n        i = 10\n    nrows = constant_op.constant(5)\n    static_nrows = tensor_shape.Dimension(5)\n    value = constant_op.constant([1, 2, 3])\n    with self.assertRaisesRegex(ValueError, 'fields have incompatible nrows'):\n        structured_tensor._merge_nrows(nrows, static_nrows, value, dtypes.int32, validate=False)",
            "def testMergeNrowsErrors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nrows = constant_op.constant(5)\n    static_nrows = tensor_shape.Dimension(5)\n    value = constant_op.constant([1, 2, 3])\n    with self.assertRaisesRegex(ValueError, 'fields have incompatible nrows'):\n        structured_tensor._merge_nrows(nrows, static_nrows, value, dtypes.int32, validate=False)",
            "def testMergeNrowsErrors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nrows = constant_op.constant(5)\n    static_nrows = tensor_shape.Dimension(5)\n    value = constant_op.constant([1, 2, 3])\n    with self.assertRaisesRegex(ValueError, 'fields have incompatible nrows'):\n        structured_tensor._merge_nrows(nrows, static_nrows, value, dtypes.int32, validate=False)",
            "def testMergeNrowsErrors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nrows = constant_op.constant(5)\n    static_nrows = tensor_shape.Dimension(5)\n    value = constant_op.constant([1, 2, 3])\n    with self.assertRaisesRegex(ValueError, 'fields have incompatible nrows'):\n        structured_tensor._merge_nrows(nrows, static_nrows, value, dtypes.int32, validate=False)",
            "def testMergeNrowsErrors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nrows = constant_op.constant(5)\n    static_nrows = tensor_shape.Dimension(5)\n    value = constant_op.constant([1, 2, 3])\n    with self.assertRaisesRegex(ValueError, 'fields have incompatible nrows'):\n        structured_tensor._merge_nrows(nrows, static_nrows, value, dtypes.int32, validate=False)"
        ]
    },
    {
        "func_name": "testNestedStructConstruction",
        "original": "def testNestedStructConstruction(self):\n    rt = ragged_factory_ops.constant([[1, 2], [3]])\n    struct1 = StructuredTensor.from_fields(shape=[], fields={'x': [1, 2]})\n    struct2 = StructuredTensor.from_fields(shape=[2], fields={'x': [1, 2]})\n    struct3 = StructuredTensor.from_fields(shape=[], fields={'r': rt, 's': struct1})\n    struct4 = StructuredTensor.from_fields(shape=[2], fields={'r': rt, 's': struct2})\n    self.assertEqual(struct3.shape.as_list(), [])\n    self.assertEqual(struct3.rank, 0)\n    self.assertEqual(set(struct3.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct3.field_value('r'), rt)\n    self.assertAllEqual(struct3.field_value('s'), struct1)\n    self.assertEqual(struct4.shape.as_list(), [2])\n    self.assertEqual(struct4.rank, 1)\n    self.assertEqual(set(struct4.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct4.field_value('r'), rt)\n    self.assertAllEqual(struct4.field_value('s'), struct2)",
        "mutated": [
            "def testNestedStructConstruction(self):\n    if False:\n        i = 10\n    rt = ragged_factory_ops.constant([[1, 2], [3]])\n    struct1 = StructuredTensor.from_fields(shape=[], fields={'x': [1, 2]})\n    struct2 = StructuredTensor.from_fields(shape=[2], fields={'x': [1, 2]})\n    struct3 = StructuredTensor.from_fields(shape=[], fields={'r': rt, 's': struct1})\n    struct4 = StructuredTensor.from_fields(shape=[2], fields={'r': rt, 's': struct2})\n    self.assertEqual(struct3.shape.as_list(), [])\n    self.assertEqual(struct3.rank, 0)\n    self.assertEqual(set(struct3.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct3.field_value('r'), rt)\n    self.assertAllEqual(struct3.field_value('s'), struct1)\n    self.assertEqual(struct4.shape.as_list(), [2])\n    self.assertEqual(struct4.rank, 1)\n    self.assertEqual(set(struct4.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct4.field_value('r'), rt)\n    self.assertAllEqual(struct4.field_value('s'), struct2)",
            "def testNestedStructConstruction(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rt = ragged_factory_ops.constant([[1, 2], [3]])\n    struct1 = StructuredTensor.from_fields(shape=[], fields={'x': [1, 2]})\n    struct2 = StructuredTensor.from_fields(shape=[2], fields={'x': [1, 2]})\n    struct3 = StructuredTensor.from_fields(shape=[], fields={'r': rt, 's': struct1})\n    struct4 = StructuredTensor.from_fields(shape=[2], fields={'r': rt, 's': struct2})\n    self.assertEqual(struct3.shape.as_list(), [])\n    self.assertEqual(struct3.rank, 0)\n    self.assertEqual(set(struct3.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct3.field_value('r'), rt)\n    self.assertAllEqual(struct3.field_value('s'), struct1)\n    self.assertEqual(struct4.shape.as_list(), [2])\n    self.assertEqual(struct4.rank, 1)\n    self.assertEqual(set(struct4.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct4.field_value('r'), rt)\n    self.assertAllEqual(struct4.field_value('s'), struct2)",
            "def testNestedStructConstruction(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rt = ragged_factory_ops.constant([[1, 2], [3]])\n    struct1 = StructuredTensor.from_fields(shape=[], fields={'x': [1, 2]})\n    struct2 = StructuredTensor.from_fields(shape=[2], fields={'x': [1, 2]})\n    struct3 = StructuredTensor.from_fields(shape=[], fields={'r': rt, 's': struct1})\n    struct4 = StructuredTensor.from_fields(shape=[2], fields={'r': rt, 's': struct2})\n    self.assertEqual(struct3.shape.as_list(), [])\n    self.assertEqual(struct3.rank, 0)\n    self.assertEqual(set(struct3.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct3.field_value('r'), rt)\n    self.assertAllEqual(struct3.field_value('s'), struct1)\n    self.assertEqual(struct4.shape.as_list(), [2])\n    self.assertEqual(struct4.rank, 1)\n    self.assertEqual(set(struct4.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct4.field_value('r'), rt)\n    self.assertAllEqual(struct4.field_value('s'), struct2)",
            "def testNestedStructConstruction(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rt = ragged_factory_ops.constant([[1, 2], [3]])\n    struct1 = StructuredTensor.from_fields(shape=[], fields={'x': [1, 2]})\n    struct2 = StructuredTensor.from_fields(shape=[2], fields={'x': [1, 2]})\n    struct3 = StructuredTensor.from_fields(shape=[], fields={'r': rt, 's': struct1})\n    struct4 = StructuredTensor.from_fields(shape=[2], fields={'r': rt, 's': struct2})\n    self.assertEqual(struct3.shape.as_list(), [])\n    self.assertEqual(struct3.rank, 0)\n    self.assertEqual(set(struct3.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct3.field_value('r'), rt)\n    self.assertAllEqual(struct3.field_value('s'), struct1)\n    self.assertEqual(struct4.shape.as_list(), [2])\n    self.assertEqual(struct4.rank, 1)\n    self.assertEqual(set(struct4.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct4.field_value('r'), rt)\n    self.assertAllEqual(struct4.field_value('s'), struct2)",
            "def testNestedStructConstruction(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rt = ragged_factory_ops.constant([[1, 2], [3]])\n    struct1 = StructuredTensor.from_fields(shape=[], fields={'x': [1, 2]})\n    struct2 = StructuredTensor.from_fields(shape=[2], fields={'x': [1, 2]})\n    struct3 = StructuredTensor.from_fields(shape=[], fields={'r': rt, 's': struct1})\n    struct4 = StructuredTensor.from_fields(shape=[2], fields={'r': rt, 's': struct2})\n    self.assertEqual(struct3.shape.as_list(), [])\n    self.assertEqual(struct3.rank, 0)\n    self.assertEqual(set(struct3.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct3.field_value('r'), rt)\n    self.assertAllEqual(struct3.field_value('s'), struct1)\n    self.assertEqual(struct4.shape.as_list(), [2])\n    self.assertEqual(struct4.rank, 1)\n    self.assertEqual(set(struct4.field_names()), set(['r', 's']))\n    self.assertAllEqual(struct4.field_value('r'), rt)\n    self.assertAllEqual(struct4.field_value('s'), struct2)"
        ]
    },
    {
        "func_name": "testPartitionOuterDims",
        "original": "def testPartitionOuterDims(self):\n    a = dict(x=1, y=[1, 2])\n    b = dict(x=2, y=[3, 4])\n    c = dict(x=3, y=[5, 6])\n    d = dict(x=4, y=[7, 8])\n    st1 = StructuredTensor.from_pyval([a, b, c, d])\n    st2 = st1.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 2, 2, 3, 4]))\n    self.assertAllEqual(st2, [[a, b], [], [c], [d]])\n    st3 = st2.partition_outer_dimension(row_partition.RowPartition.from_row_lengths([1, 0, 3, 0]))\n    self.assertAllEqual(st3, [[[a, b]], [], [[], [c], [d]], []])\n    st4 = st1.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(uniform_row_length=2, nvals=4, nrows=2))\n    self.assertAllEqual(st4, structured_tensor.StructuredTensor.from_pyval([[a, b], [c, d]], structured_tensor.StructuredTensor.Spec(_ragged_shape=DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[2, 2], dtype=dtypes.int64), _fields={'x': tensor.TensorSpec([2, 2], dtypes.int32), 'y': ragged_tensor.RaggedTensorSpec([2, 2, None], dtypes.int32)})))",
        "mutated": [
            "def testPartitionOuterDims(self):\n    if False:\n        i = 10\n    a = dict(x=1, y=[1, 2])\n    b = dict(x=2, y=[3, 4])\n    c = dict(x=3, y=[5, 6])\n    d = dict(x=4, y=[7, 8])\n    st1 = StructuredTensor.from_pyval([a, b, c, d])\n    st2 = st1.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 2, 2, 3, 4]))\n    self.assertAllEqual(st2, [[a, b], [], [c], [d]])\n    st3 = st2.partition_outer_dimension(row_partition.RowPartition.from_row_lengths([1, 0, 3, 0]))\n    self.assertAllEqual(st3, [[[a, b]], [], [[], [c], [d]], []])\n    st4 = st1.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(uniform_row_length=2, nvals=4, nrows=2))\n    self.assertAllEqual(st4, structured_tensor.StructuredTensor.from_pyval([[a, b], [c, d]], structured_tensor.StructuredTensor.Spec(_ragged_shape=DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[2, 2], dtype=dtypes.int64), _fields={'x': tensor.TensorSpec([2, 2], dtypes.int32), 'y': ragged_tensor.RaggedTensorSpec([2, 2, None], dtypes.int32)})))",
            "def testPartitionOuterDims(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = dict(x=1, y=[1, 2])\n    b = dict(x=2, y=[3, 4])\n    c = dict(x=3, y=[5, 6])\n    d = dict(x=4, y=[7, 8])\n    st1 = StructuredTensor.from_pyval([a, b, c, d])\n    st2 = st1.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 2, 2, 3, 4]))\n    self.assertAllEqual(st2, [[a, b], [], [c], [d]])\n    st3 = st2.partition_outer_dimension(row_partition.RowPartition.from_row_lengths([1, 0, 3, 0]))\n    self.assertAllEqual(st3, [[[a, b]], [], [[], [c], [d]], []])\n    st4 = st1.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(uniform_row_length=2, nvals=4, nrows=2))\n    self.assertAllEqual(st4, structured_tensor.StructuredTensor.from_pyval([[a, b], [c, d]], structured_tensor.StructuredTensor.Spec(_ragged_shape=DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[2, 2], dtype=dtypes.int64), _fields={'x': tensor.TensorSpec([2, 2], dtypes.int32), 'y': ragged_tensor.RaggedTensorSpec([2, 2, None], dtypes.int32)})))",
            "def testPartitionOuterDims(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = dict(x=1, y=[1, 2])\n    b = dict(x=2, y=[3, 4])\n    c = dict(x=3, y=[5, 6])\n    d = dict(x=4, y=[7, 8])\n    st1 = StructuredTensor.from_pyval([a, b, c, d])\n    st2 = st1.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 2, 2, 3, 4]))\n    self.assertAllEqual(st2, [[a, b], [], [c], [d]])\n    st3 = st2.partition_outer_dimension(row_partition.RowPartition.from_row_lengths([1, 0, 3, 0]))\n    self.assertAllEqual(st3, [[[a, b]], [], [[], [c], [d]], []])\n    st4 = st1.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(uniform_row_length=2, nvals=4, nrows=2))\n    self.assertAllEqual(st4, structured_tensor.StructuredTensor.from_pyval([[a, b], [c, d]], structured_tensor.StructuredTensor.Spec(_ragged_shape=DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[2, 2], dtype=dtypes.int64), _fields={'x': tensor.TensorSpec([2, 2], dtypes.int32), 'y': ragged_tensor.RaggedTensorSpec([2, 2, None], dtypes.int32)})))",
            "def testPartitionOuterDims(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = dict(x=1, y=[1, 2])\n    b = dict(x=2, y=[3, 4])\n    c = dict(x=3, y=[5, 6])\n    d = dict(x=4, y=[7, 8])\n    st1 = StructuredTensor.from_pyval([a, b, c, d])\n    st2 = st1.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 2, 2, 3, 4]))\n    self.assertAllEqual(st2, [[a, b], [], [c], [d]])\n    st3 = st2.partition_outer_dimension(row_partition.RowPartition.from_row_lengths([1, 0, 3, 0]))\n    self.assertAllEqual(st3, [[[a, b]], [], [[], [c], [d]], []])\n    st4 = st1.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(uniform_row_length=2, nvals=4, nrows=2))\n    self.assertAllEqual(st4, structured_tensor.StructuredTensor.from_pyval([[a, b], [c, d]], structured_tensor.StructuredTensor.Spec(_ragged_shape=DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[2, 2], dtype=dtypes.int64), _fields={'x': tensor.TensorSpec([2, 2], dtypes.int32), 'y': ragged_tensor.RaggedTensorSpec([2, 2, None], dtypes.int32)})))",
            "def testPartitionOuterDims(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = dict(x=1, y=[1, 2])\n    b = dict(x=2, y=[3, 4])\n    c = dict(x=3, y=[5, 6])\n    d = dict(x=4, y=[7, 8])\n    st1 = StructuredTensor.from_pyval([a, b, c, d])\n    st2 = st1.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 2, 2, 3, 4]))\n    self.assertAllEqual(st2, [[a, b], [], [c], [d]])\n    st3 = st2.partition_outer_dimension(row_partition.RowPartition.from_row_lengths([1, 0, 3, 0]))\n    self.assertAllEqual(st3, [[[a, b]], [], [[], [c], [d]], []])\n    st4 = st1.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(uniform_row_length=2, nvals=4, nrows=2))\n    self.assertAllEqual(st4, structured_tensor.StructuredTensor.from_pyval([[a, b], [c, d]], structured_tensor.StructuredTensor.Spec(_ragged_shape=DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[2, 2], dtype=dtypes.int64), _fields={'x': tensor.TensorSpec([2, 2], dtypes.int32), 'y': ragged_tensor.RaggedTensorSpec([2, 2, None], dtypes.int32)})))"
        ]
    },
    {
        "func_name": "testPartitionOuterDimension3",
        "original": "def testPartitionOuterDimension3(self):\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = structured_tensor.StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertEqual(3, struct_3.rank)",
        "mutated": [
            "def testPartitionOuterDimension3(self):\n    if False:\n        i = 10\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = structured_tensor.StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertEqual(3, struct_3.rank)",
            "def testPartitionOuterDimension3(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = structured_tensor.StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertEqual(3, struct_3.rank)",
            "def testPartitionOuterDimension3(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = structured_tensor.StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertEqual(3, struct_3.rank)",
            "def testPartitionOuterDimension3(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = structured_tensor.StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertEqual(3, struct_3.rank)",
            "def testPartitionOuterDimension3(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = structured_tensor.StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertEqual(3, struct_3.rank)"
        ]
    },
    {
        "func_name": "testWithPrivateSpecialType",
        "original": "def testWithPrivateSpecialType(self):\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pst = _PrivateSpecialType(rt)\n    pst_shape = array_ops.shape_v2(pst)\n    st = structured_tensor.StructuredTensor.from_fields_and_rank({'r': pst}, 1)\n    st_shape = st._ragged_shape\n    self.assertEqual(1, st.rank)\n    self.assertAllEqual(pst_shape[0], st_shape[0])",
        "mutated": [
            "def testWithPrivateSpecialType(self):\n    if False:\n        i = 10\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pst = _PrivateSpecialType(rt)\n    pst_shape = array_ops.shape_v2(pst)\n    st = structured_tensor.StructuredTensor.from_fields_and_rank({'r': pst}, 1)\n    st_shape = st._ragged_shape\n    self.assertEqual(1, st.rank)\n    self.assertAllEqual(pst_shape[0], st_shape[0])",
            "def testWithPrivateSpecialType(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pst = _PrivateSpecialType(rt)\n    pst_shape = array_ops.shape_v2(pst)\n    st = structured_tensor.StructuredTensor.from_fields_and_rank({'r': pst}, 1)\n    st_shape = st._ragged_shape\n    self.assertEqual(1, st.rank)\n    self.assertAllEqual(pst_shape[0], st_shape[0])",
            "def testWithPrivateSpecialType(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pst = _PrivateSpecialType(rt)\n    pst_shape = array_ops.shape_v2(pst)\n    st = structured_tensor.StructuredTensor.from_fields_and_rank({'r': pst}, 1)\n    st_shape = st._ragged_shape\n    self.assertEqual(1, st.rank)\n    self.assertAllEqual(pst_shape[0], st_shape[0])",
            "def testWithPrivateSpecialType(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pst = _PrivateSpecialType(rt)\n    pst_shape = array_ops.shape_v2(pst)\n    st = structured_tensor.StructuredTensor.from_fields_and_rank({'r': pst}, 1)\n    st_shape = st._ragged_shape\n    self.assertEqual(1, st.rank)\n    self.assertAllEqual(pst_shape[0], st_shape[0])",
            "def testWithPrivateSpecialType(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pst = _PrivateSpecialType(rt)\n    pst_shape = array_ops.shape_v2(pst)\n    st = structured_tensor.StructuredTensor.from_fields_and_rank({'r': pst}, 1)\n    st_shape = st._ragged_shape\n    self.assertEqual(1, st.rank)\n    self.assertAllEqual(pst_shape[0], st_shape[0])"
        ]
    },
    {
        "func_name": "testWithPrivateBrokenType",
        "original": "def testWithPrivateBrokenType(self):\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pbt = _PrivateBrokenType(rt)\n    with self.assertRaisesRegex(ValueError, 'Error in shape of r'):\n        structured_tensor.StructuredTensor.from_fields_and_rank({'r': pbt}, 1)",
        "mutated": [
            "def testWithPrivateBrokenType(self):\n    if False:\n        i = 10\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pbt = _PrivateBrokenType(rt)\n    with self.assertRaisesRegex(ValueError, 'Error in shape of r'):\n        structured_tensor.StructuredTensor.from_fields_and_rank({'r': pbt}, 1)",
            "def testWithPrivateBrokenType(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pbt = _PrivateBrokenType(rt)\n    with self.assertRaisesRegex(ValueError, 'Error in shape of r'):\n        structured_tensor.StructuredTensor.from_fields_and_rank({'r': pbt}, 1)",
            "def testWithPrivateBrokenType(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pbt = _PrivateBrokenType(rt)\n    with self.assertRaisesRegex(ValueError, 'Error in shape of r'):\n        structured_tensor.StructuredTensor.from_fields_and_rank({'r': pbt}, 1)",
            "def testWithPrivateBrokenType(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pbt = _PrivateBrokenType(rt)\n    with self.assertRaisesRegex(ValueError, 'Error in shape of r'):\n        structured_tensor.StructuredTensor.from_fields_and_rank({'r': pbt}, 1)",
            "def testWithPrivateBrokenType(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    pbt = _PrivateBrokenType(rt)\n    with self.assertRaisesRegex(ValueError, 'Error in shape of r'):\n        structured_tensor.StructuredTensor.from_fields_and_rank({'r': pbt}, 1)"
        ]
    },
    {
        "func_name": "testPartitionOuterDimsErrors",
        "original": "def testPartitionOuterDimsErrors(self):\n    st = StructuredTensor.from_fields({})\n    partition = row_partition.RowPartition.from_row_splits([0])\n    with self.assertRaisesRegex(ValueError, 'Shape \\\\(\\\\) must have rank at least 1'):\n        st.partition_outer_dimension(partition)\n    with self.assertRaisesRegex(TypeError, 'row_partition must be a RowPartition'):\n        st.partition_outer_dimension(10)",
        "mutated": [
            "def testPartitionOuterDimsErrors(self):\n    if False:\n        i = 10\n    st = StructuredTensor.from_fields({})\n    partition = row_partition.RowPartition.from_row_splits([0])\n    with self.assertRaisesRegex(ValueError, 'Shape \\\\(\\\\) must have rank at least 1'):\n        st.partition_outer_dimension(partition)\n    with self.assertRaisesRegex(TypeError, 'row_partition must be a RowPartition'):\n        st.partition_outer_dimension(10)",
            "def testPartitionOuterDimsErrors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st = StructuredTensor.from_fields({})\n    partition = row_partition.RowPartition.from_row_splits([0])\n    with self.assertRaisesRegex(ValueError, 'Shape \\\\(\\\\) must have rank at least 1'):\n        st.partition_outer_dimension(partition)\n    with self.assertRaisesRegex(TypeError, 'row_partition must be a RowPartition'):\n        st.partition_outer_dimension(10)",
            "def testPartitionOuterDimsErrors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st = StructuredTensor.from_fields({})\n    partition = row_partition.RowPartition.from_row_splits([0])\n    with self.assertRaisesRegex(ValueError, 'Shape \\\\(\\\\) must have rank at least 1'):\n        st.partition_outer_dimension(partition)\n    with self.assertRaisesRegex(TypeError, 'row_partition must be a RowPartition'):\n        st.partition_outer_dimension(10)",
            "def testPartitionOuterDimsErrors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st = StructuredTensor.from_fields({})\n    partition = row_partition.RowPartition.from_row_splits([0])\n    with self.assertRaisesRegex(ValueError, 'Shape \\\\(\\\\) must have rank at least 1'):\n        st.partition_outer_dimension(partition)\n    with self.assertRaisesRegex(TypeError, 'row_partition must be a RowPartition'):\n        st.partition_outer_dimension(10)",
            "def testPartitionOuterDimsErrors(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st = StructuredTensor.from_fields({})\n    partition = row_partition.RowPartition.from_row_splits([0])\n    with self.assertRaisesRegex(ValueError, 'Shape \\\\(\\\\) must have rank at least 1'):\n        st.partition_outer_dimension(partition)\n    with self.assertRaisesRegex(TypeError, 'row_partition must be a RowPartition'):\n        st.partition_outer_dimension(10)"
        ]
    },
    {
        "func_name": "testPyvalConversion",
        "original": "@parameterized.named_parameters([{'testcase_name': 'ScalarEmpty', 'pyval': {}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={})}, {'testcase_name': 'ScalarSimple', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarSimpleWithTypeSpec', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'type_spec': StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0), 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarWithNestedStruct', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': {'x': b'Z', 'y': [10, 20]}}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': StructuredTensor.from_fields(shape=[], fields={'x': 'Z', 'y': [10, 20]})})}, {'testcase_name': 'EmptyList', 'pyval': [], 'expected': lambda : []}, {'testcase_name': 'ListOfEmptyList', 'pyval': [[], []], 'expected': lambda : [[], []]}, {'testcase_name': 'EmptyListWithTypeSpecAndFields', 'pyval': [], 'type_spec': structured_tensor.StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([0], dtypes.int32)}, rank=1), 'expected': lambda : StructuredTensor.from_fields(shape=[0], fields={'a': []})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape0_5', 'pyval': [], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[0, 5], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_fields(shape=[0, 5], fields={})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape1_0', 'pyval': [[]], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 0], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_shape(DynamicRaggedShape.from_lengths([1, 0]))}, {'testcase_name': 'VectorOfDict', 'pyval': [{'a': 1}, {'a': 2}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2]})}, {'testcase_name': 'VectorOfDictWithNestedStructScalar', 'pyval': [{'a': 1, 'b': {'x': [1, 2]}}, {'a': 2, 'b': {'x': [3]}}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2], fields={'x': ragged_factory_ops.constant([[1, 2], [3]])})})}, {'testcase_name': 'VectorOfDictWithNestedStructVector', 'pyval': [{'a': 1, 'b': [{'x': [1, 2]}, {'x': [5]}]}, {'a': 2, 'b': [{'x': [3]}]}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2, None], fields={'x': ragged_factory_ops.constant([[[1, 2], [5]], [[3]]])})})}, {'testcase_name': 'Ragged2DOfDict', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5]])})}, {'testcase_name': 'MatrixOfDictWithoutTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5, 6]])})}, {'testcase_name': 'MatrixOfDictWithTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'type_spec': structured_tensor.StructuredTensorSpec([2, 3], {'a': tensor.TensorSpec(None, dtypes.int32)}), 'expected': lambda : StructuredTensor.from_fields(shape=[2, 3], fields={'a': [[1, 2, 3], [4, 5, 6]]})}])\ndef testPyvalConversion(self, pyval, expected, type_spec=None):\n    expected = expected()\n    actual = structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)\n    self.assertAllEqual(actual, expected)\n    if isinstance(actual, structured_tensor.StructuredTensor):\n        if context.executing_eagerly():\n            self.assertEqual(actual.to_pyval(), pyval)",
        "mutated": [
            "@parameterized.named_parameters([{'testcase_name': 'ScalarEmpty', 'pyval': {}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={})}, {'testcase_name': 'ScalarSimple', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarSimpleWithTypeSpec', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'type_spec': StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0), 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarWithNestedStruct', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': {'x': b'Z', 'y': [10, 20]}}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': StructuredTensor.from_fields(shape=[], fields={'x': 'Z', 'y': [10, 20]})})}, {'testcase_name': 'EmptyList', 'pyval': [], 'expected': lambda : []}, {'testcase_name': 'ListOfEmptyList', 'pyval': [[], []], 'expected': lambda : [[], []]}, {'testcase_name': 'EmptyListWithTypeSpecAndFields', 'pyval': [], 'type_spec': structured_tensor.StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([0], dtypes.int32)}, rank=1), 'expected': lambda : StructuredTensor.from_fields(shape=[0], fields={'a': []})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape0_5', 'pyval': [], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[0, 5], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_fields(shape=[0, 5], fields={})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape1_0', 'pyval': [[]], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 0], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_shape(DynamicRaggedShape.from_lengths([1, 0]))}, {'testcase_name': 'VectorOfDict', 'pyval': [{'a': 1}, {'a': 2}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2]})}, {'testcase_name': 'VectorOfDictWithNestedStructScalar', 'pyval': [{'a': 1, 'b': {'x': [1, 2]}}, {'a': 2, 'b': {'x': [3]}}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2], fields={'x': ragged_factory_ops.constant([[1, 2], [3]])})})}, {'testcase_name': 'VectorOfDictWithNestedStructVector', 'pyval': [{'a': 1, 'b': [{'x': [1, 2]}, {'x': [5]}]}, {'a': 2, 'b': [{'x': [3]}]}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2, None], fields={'x': ragged_factory_ops.constant([[[1, 2], [5]], [[3]]])})})}, {'testcase_name': 'Ragged2DOfDict', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5]])})}, {'testcase_name': 'MatrixOfDictWithoutTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5, 6]])})}, {'testcase_name': 'MatrixOfDictWithTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'type_spec': structured_tensor.StructuredTensorSpec([2, 3], {'a': tensor.TensorSpec(None, dtypes.int32)}), 'expected': lambda : StructuredTensor.from_fields(shape=[2, 3], fields={'a': [[1, 2, 3], [4, 5, 6]]})}])\ndef testPyvalConversion(self, pyval, expected, type_spec=None):\n    if False:\n        i = 10\n    expected = expected()\n    actual = structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)\n    self.assertAllEqual(actual, expected)\n    if isinstance(actual, structured_tensor.StructuredTensor):\n        if context.executing_eagerly():\n            self.assertEqual(actual.to_pyval(), pyval)",
            "@parameterized.named_parameters([{'testcase_name': 'ScalarEmpty', 'pyval': {}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={})}, {'testcase_name': 'ScalarSimple', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarSimpleWithTypeSpec', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'type_spec': StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0), 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarWithNestedStruct', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': {'x': b'Z', 'y': [10, 20]}}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': StructuredTensor.from_fields(shape=[], fields={'x': 'Z', 'y': [10, 20]})})}, {'testcase_name': 'EmptyList', 'pyval': [], 'expected': lambda : []}, {'testcase_name': 'ListOfEmptyList', 'pyval': [[], []], 'expected': lambda : [[], []]}, {'testcase_name': 'EmptyListWithTypeSpecAndFields', 'pyval': [], 'type_spec': structured_tensor.StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([0], dtypes.int32)}, rank=1), 'expected': lambda : StructuredTensor.from_fields(shape=[0], fields={'a': []})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape0_5', 'pyval': [], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[0, 5], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_fields(shape=[0, 5], fields={})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape1_0', 'pyval': [[]], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 0], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_shape(DynamicRaggedShape.from_lengths([1, 0]))}, {'testcase_name': 'VectorOfDict', 'pyval': [{'a': 1}, {'a': 2}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2]})}, {'testcase_name': 'VectorOfDictWithNestedStructScalar', 'pyval': [{'a': 1, 'b': {'x': [1, 2]}}, {'a': 2, 'b': {'x': [3]}}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2], fields={'x': ragged_factory_ops.constant([[1, 2], [3]])})})}, {'testcase_name': 'VectorOfDictWithNestedStructVector', 'pyval': [{'a': 1, 'b': [{'x': [1, 2]}, {'x': [5]}]}, {'a': 2, 'b': [{'x': [3]}]}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2, None], fields={'x': ragged_factory_ops.constant([[[1, 2], [5]], [[3]]])})})}, {'testcase_name': 'Ragged2DOfDict', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5]])})}, {'testcase_name': 'MatrixOfDictWithoutTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5, 6]])})}, {'testcase_name': 'MatrixOfDictWithTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'type_spec': structured_tensor.StructuredTensorSpec([2, 3], {'a': tensor.TensorSpec(None, dtypes.int32)}), 'expected': lambda : StructuredTensor.from_fields(shape=[2, 3], fields={'a': [[1, 2, 3], [4, 5, 6]]})}])\ndef testPyvalConversion(self, pyval, expected, type_spec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    expected = expected()\n    actual = structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)\n    self.assertAllEqual(actual, expected)\n    if isinstance(actual, structured_tensor.StructuredTensor):\n        if context.executing_eagerly():\n            self.assertEqual(actual.to_pyval(), pyval)",
            "@parameterized.named_parameters([{'testcase_name': 'ScalarEmpty', 'pyval': {}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={})}, {'testcase_name': 'ScalarSimple', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarSimpleWithTypeSpec', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'type_spec': StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0), 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarWithNestedStruct', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': {'x': b'Z', 'y': [10, 20]}}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': StructuredTensor.from_fields(shape=[], fields={'x': 'Z', 'y': [10, 20]})})}, {'testcase_name': 'EmptyList', 'pyval': [], 'expected': lambda : []}, {'testcase_name': 'ListOfEmptyList', 'pyval': [[], []], 'expected': lambda : [[], []]}, {'testcase_name': 'EmptyListWithTypeSpecAndFields', 'pyval': [], 'type_spec': structured_tensor.StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([0], dtypes.int32)}, rank=1), 'expected': lambda : StructuredTensor.from_fields(shape=[0], fields={'a': []})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape0_5', 'pyval': [], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[0, 5], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_fields(shape=[0, 5], fields={})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape1_0', 'pyval': [[]], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 0], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_shape(DynamicRaggedShape.from_lengths([1, 0]))}, {'testcase_name': 'VectorOfDict', 'pyval': [{'a': 1}, {'a': 2}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2]})}, {'testcase_name': 'VectorOfDictWithNestedStructScalar', 'pyval': [{'a': 1, 'b': {'x': [1, 2]}}, {'a': 2, 'b': {'x': [3]}}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2], fields={'x': ragged_factory_ops.constant([[1, 2], [3]])})})}, {'testcase_name': 'VectorOfDictWithNestedStructVector', 'pyval': [{'a': 1, 'b': [{'x': [1, 2]}, {'x': [5]}]}, {'a': 2, 'b': [{'x': [3]}]}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2, None], fields={'x': ragged_factory_ops.constant([[[1, 2], [5]], [[3]]])})})}, {'testcase_name': 'Ragged2DOfDict', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5]])})}, {'testcase_name': 'MatrixOfDictWithoutTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5, 6]])})}, {'testcase_name': 'MatrixOfDictWithTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'type_spec': structured_tensor.StructuredTensorSpec([2, 3], {'a': tensor.TensorSpec(None, dtypes.int32)}), 'expected': lambda : StructuredTensor.from_fields(shape=[2, 3], fields={'a': [[1, 2, 3], [4, 5, 6]]})}])\ndef testPyvalConversion(self, pyval, expected, type_spec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    expected = expected()\n    actual = structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)\n    self.assertAllEqual(actual, expected)\n    if isinstance(actual, structured_tensor.StructuredTensor):\n        if context.executing_eagerly():\n            self.assertEqual(actual.to_pyval(), pyval)",
            "@parameterized.named_parameters([{'testcase_name': 'ScalarEmpty', 'pyval': {}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={})}, {'testcase_name': 'ScalarSimple', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarSimpleWithTypeSpec', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'type_spec': StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0), 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarWithNestedStruct', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': {'x': b'Z', 'y': [10, 20]}}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': StructuredTensor.from_fields(shape=[], fields={'x': 'Z', 'y': [10, 20]})})}, {'testcase_name': 'EmptyList', 'pyval': [], 'expected': lambda : []}, {'testcase_name': 'ListOfEmptyList', 'pyval': [[], []], 'expected': lambda : [[], []]}, {'testcase_name': 'EmptyListWithTypeSpecAndFields', 'pyval': [], 'type_spec': structured_tensor.StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([0], dtypes.int32)}, rank=1), 'expected': lambda : StructuredTensor.from_fields(shape=[0], fields={'a': []})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape0_5', 'pyval': [], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[0, 5], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_fields(shape=[0, 5], fields={})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape1_0', 'pyval': [[]], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 0], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_shape(DynamicRaggedShape.from_lengths([1, 0]))}, {'testcase_name': 'VectorOfDict', 'pyval': [{'a': 1}, {'a': 2}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2]})}, {'testcase_name': 'VectorOfDictWithNestedStructScalar', 'pyval': [{'a': 1, 'b': {'x': [1, 2]}}, {'a': 2, 'b': {'x': [3]}}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2], fields={'x': ragged_factory_ops.constant([[1, 2], [3]])})})}, {'testcase_name': 'VectorOfDictWithNestedStructVector', 'pyval': [{'a': 1, 'b': [{'x': [1, 2]}, {'x': [5]}]}, {'a': 2, 'b': [{'x': [3]}]}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2, None], fields={'x': ragged_factory_ops.constant([[[1, 2], [5]], [[3]]])})})}, {'testcase_name': 'Ragged2DOfDict', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5]])})}, {'testcase_name': 'MatrixOfDictWithoutTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5, 6]])})}, {'testcase_name': 'MatrixOfDictWithTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'type_spec': structured_tensor.StructuredTensorSpec([2, 3], {'a': tensor.TensorSpec(None, dtypes.int32)}), 'expected': lambda : StructuredTensor.from_fields(shape=[2, 3], fields={'a': [[1, 2, 3], [4, 5, 6]]})}])\ndef testPyvalConversion(self, pyval, expected, type_spec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    expected = expected()\n    actual = structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)\n    self.assertAllEqual(actual, expected)\n    if isinstance(actual, structured_tensor.StructuredTensor):\n        if context.executing_eagerly():\n            self.assertEqual(actual.to_pyval(), pyval)",
            "@parameterized.named_parameters([{'testcase_name': 'ScalarEmpty', 'pyval': {}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={})}, {'testcase_name': 'ScalarSimple', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarSimpleWithTypeSpec', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': [[1, 2], [3]]}, 'type_spec': StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0), 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': ragged_factory_ops.constant([[1, 2], [3]])})}, {'testcase_name': 'ScalarWithNestedStruct', 'pyval': {'a': 12, 'b': [1, 2, 3], 'c': {'x': b'Z', 'y': [10, 20]}}, 'expected': lambda : StructuredTensor.from_fields(shape=[], fields={'a': 12, 'b': [1, 2, 3], 'c': StructuredTensor.from_fields(shape=[], fields={'x': 'Z', 'y': [10, 20]})})}, {'testcase_name': 'EmptyList', 'pyval': [], 'expected': lambda : []}, {'testcase_name': 'ListOfEmptyList', 'pyval': [[], []], 'expected': lambda : [[], []]}, {'testcase_name': 'EmptyListWithTypeSpecAndFields', 'pyval': [], 'type_spec': structured_tensor.StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([0], dtypes.int32)}, rank=1), 'expected': lambda : StructuredTensor.from_fields(shape=[0], fields={'a': []})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape0_5', 'pyval': [], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[0, 5], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_fields(shape=[0, 5], fields={})}, {'testcase_name': 'EmptyListWithTypeSpecNoFieldsShape1_0', 'pyval': [[]], 'type_spec': StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 0], dtype=dtypes.int64)), 'expected': lambda : StructuredTensor.from_shape(DynamicRaggedShape.from_lengths([1, 0]))}, {'testcase_name': 'VectorOfDict', 'pyval': [{'a': 1}, {'a': 2}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2]})}, {'testcase_name': 'VectorOfDictWithNestedStructScalar', 'pyval': [{'a': 1, 'b': {'x': [1, 2]}}, {'a': 2, 'b': {'x': [3]}}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2], fields={'x': ragged_factory_ops.constant([[1, 2], [3]])})})}, {'testcase_name': 'VectorOfDictWithNestedStructVector', 'pyval': [{'a': 1, 'b': [{'x': [1, 2]}, {'x': [5]}]}, {'a': 2, 'b': [{'x': [3]}]}], 'expected': lambda : StructuredTensor.from_fields(shape=[2], fields={'a': [1, 2], 'b': StructuredTensor.from_fields(shape=[2, None], fields={'x': ragged_factory_ops.constant([[[1, 2], [5]], [[3]]])})})}, {'testcase_name': 'Ragged2DOfDict', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5]])})}, {'testcase_name': 'MatrixOfDictWithoutTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'expected': lambda : StructuredTensor.from_fields(shape=[2, None], fields={'a': ragged_factory_ops.constant([[1, 2, 3], [4, 5, 6]])})}, {'testcase_name': 'MatrixOfDictWithTypeSpec', 'pyval': [[{'a': 1}, {'a': 2}, {'a': 3}], [{'a': 4}, {'a': 5}, {'a': 6}]], 'type_spec': structured_tensor.StructuredTensorSpec([2, 3], {'a': tensor.TensorSpec(None, dtypes.int32)}), 'expected': lambda : StructuredTensor.from_fields(shape=[2, 3], fields={'a': [[1, 2, 3], [4, 5, 6]]})}])\ndef testPyvalConversion(self, pyval, expected, type_spec=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    expected = expected()\n    actual = structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)\n    self.assertAllEqual(actual, expected)\n    if isinstance(actual, structured_tensor.StructuredTensor):\n        if context.executing_eagerly():\n            self.assertEqual(actual.to_pyval(), pyval)"
        ]
    },
    {
        "func_name": "testStructuredTensorSpecFactory",
        "original": "def testStructuredTensorSpecFactory(self):\n    spec = StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0)\n    self.assertEqual(spec.rank, 0)",
        "mutated": [
            "def testStructuredTensorSpecFactory(self):\n    if False:\n        i = 10\n    spec = StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0)\n    self.assertEqual(spec.rank, 0)",
            "def testStructuredTensorSpecFactory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    spec = StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0)\n    self.assertEqual(spec.rank, 0)",
            "def testStructuredTensorSpecFactory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    spec = StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0)\n    self.assertEqual(spec.rank, 0)",
            "def testStructuredTensorSpecFactory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    spec = StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0)\n    self.assertEqual(spec.rank, 0)",
            "def testStructuredTensorSpecFactory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    spec = StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32), 'b': tensor.TensorSpec([None], dtypes.int32), 'c': ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)}, rank=0)\n    self.assertEqual(spec.rank, 0)"
        ]
    },
    {
        "func_name": "testToPyval",
        "original": "@parameterized.named_parameters([dict(testcase_name='NoFieldsRaggedRank0', st=lambda : StructuredTensor.from_fields({}, (3,)), expected=[{}, {}, {}]), dict(testcase_name='NoFieldsRaggedRank1', st=lambda : StructuredTensor.from_fields({}, (2, None), row_partitions=[row_partition.RowPartition.from_row_lengths([3, 2])]), expected=[[{}, {}, {}], [{}, {}]]), dict(testcase_name='NoFieldsRaggedRank2', st=lambda : StructuredTensor.from_fields({}, (2, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2, 1]), row_partition.RowPartition.from_row_lengths([2, 3, 1])]), expected=[[[{}, {}], [{}, {}, {}]], [[{}]]]), dict(testcase_name='NoFieldsRaggedRank2NoDicts', st=lambda : StructuredTensor.from_fields({}, (1, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0])]), expected=[[[], []]]), dict(testcase_name='NestedStructTensorWithNoFields', st=lambda : StructuredTensor.from_fields({'foo': ragged_factory_ops.constant([[[], []]]), 'bar': StructuredTensor.from_fields({}, (1, None, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0]), row_partition.RowPartition.from_row_lengths([])])}, (1, None, None)), expected=[[[], []]])])\ndef testToPyval(self, st, expected):\n    if context.executing_eagerly():\n        st = st()\n        self.assertEqual(st.to_pyval(), expected)",
        "mutated": [
            "@parameterized.named_parameters([dict(testcase_name='NoFieldsRaggedRank0', st=lambda : StructuredTensor.from_fields({}, (3,)), expected=[{}, {}, {}]), dict(testcase_name='NoFieldsRaggedRank1', st=lambda : StructuredTensor.from_fields({}, (2, None), row_partitions=[row_partition.RowPartition.from_row_lengths([3, 2])]), expected=[[{}, {}, {}], [{}, {}]]), dict(testcase_name='NoFieldsRaggedRank2', st=lambda : StructuredTensor.from_fields({}, (2, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2, 1]), row_partition.RowPartition.from_row_lengths([2, 3, 1])]), expected=[[[{}, {}], [{}, {}, {}]], [[{}]]]), dict(testcase_name='NoFieldsRaggedRank2NoDicts', st=lambda : StructuredTensor.from_fields({}, (1, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0])]), expected=[[[], []]]), dict(testcase_name='NestedStructTensorWithNoFields', st=lambda : StructuredTensor.from_fields({'foo': ragged_factory_ops.constant([[[], []]]), 'bar': StructuredTensor.from_fields({}, (1, None, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0]), row_partition.RowPartition.from_row_lengths([])])}, (1, None, None)), expected=[[[], []]])])\ndef testToPyval(self, st, expected):\n    if False:\n        i = 10\n    if context.executing_eagerly():\n        st = st()\n        self.assertEqual(st.to_pyval(), expected)",
            "@parameterized.named_parameters([dict(testcase_name='NoFieldsRaggedRank0', st=lambda : StructuredTensor.from_fields({}, (3,)), expected=[{}, {}, {}]), dict(testcase_name='NoFieldsRaggedRank1', st=lambda : StructuredTensor.from_fields({}, (2, None), row_partitions=[row_partition.RowPartition.from_row_lengths([3, 2])]), expected=[[{}, {}, {}], [{}, {}]]), dict(testcase_name='NoFieldsRaggedRank2', st=lambda : StructuredTensor.from_fields({}, (2, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2, 1]), row_partition.RowPartition.from_row_lengths([2, 3, 1])]), expected=[[[{}, {}], [{}, {}, {}]], [[{}]]]), dict(testcase_name='NoFieldsRaggedRank2NoDicts', st=lambda : StructuredTensor.from_fields({}, (1, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0])]), expected=[[[], []]]), dict(testcase_name='NestedStructTensorWithNoFields', st=lambda : StructuredTensor.from_fields({'foo': ragged_factory_ops.constant([[[], []]]), 'bar': StructuredTensor.from_fields({}, (1, None, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0]), row_partition.RowPartition.from_row_lengths([])])}, (1, None, None)), expected=[[[], []]])])\ndef testToPyval(self, st, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if context.executing_eagerly():\n        st = st()\n        self.assertEqual(st.to_pyval(), expected)",
            "@parameterized.named_parameters([dict(testcase_name='NoFieldsRaggedRank0', st=lambda : StructuredTensor.from_fields({}, (3,)), expected=[{}, {}, {}]), dict(testcase_name='NoFieldsRaggedRank1', st=lambda : StructuredTensor.from_fields({}, (2, None), row_partitions=[row_partition.RowPartition.from_row_lengths([3, 2])]), expected=[[{}, {}, {}], [{}, {}]]), dict(testcase_name='NoFieldsRaggedRank2', st=lambda : StructuredTensor.from_fields({}, (2, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2, 1]), row_partition.RowPartition.from_row_lengths([2, 3, 1])]), expected=[[[{}, {}], [{}, {}, {}]], [[{}]]]), dict(testcase_name='NoFieldsRaggedRank2NoDicts', st=lambda : StructuredTensor.from_fields({}, (1, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0])]), expected=[[[], []]]), dict(testcase_name='NestedStructTensorWithNoFields', st=lambda : StructuredTensor.from_fields({'foo': ragged_factory_ops.constant([[[], []]]), 'bar': StructuredTensor.from_fields({}, (1, None, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0]), row_partition.RowPartition.from_row_lengths([])])}, (1, None, None)), expected=[[[], []]])])\ndef testToPyval(self, st, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if context.executing_eagerly():\n        st = st()\n        self.assertEqual(st.to_pyval(), expected)",
            "@parameterized.named_parameters([dict(testcase_name='NoFieldsRaggedRank0', st=lambda : StructuredTensor.from_fields({}, (3,)), expected=[{}, {}, {}]), dict(testcase_name='NoFieldsRaggedRank1', st=lambda : StructuredTensor.from_fields({}, (2, None), row_partitions=[row_partition.RowPartition.from_row_lengths([3, 2])]), expected=[[{}, {}, {}], [{}, {}]]), dict(testcase_name='NoFieldsRaggedRank2', st=lambda : StructuredTensor.from_fields({}, (2, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2, 1]), row_partition.RowPartition.from_row_lengths([2, 3, 1])]), expected=[[[{}, {}], [{}, {}, {}]], [[{}]]]), dict(testcase_name='NoFieldsRaggedRank2NoDicts', st=lambda : StructuredTensor.from_fields({}, (1, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0])]), expected=[[[], []]]), dict(testcase_name='NestedStructTensorWithNoFields', st=lambda : StructuredTensor.from_fields({'foo': ragged_factory_ops.constant([[[], []]]), 'bar': StructuredTensor.from_fields({}, (1, None, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0]), row_partition.RowPartition.from_row_lengths([])])}, (1, None, None)), expected=[[[], []]])])\ndef testToPyval(self, st, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if context.executing_eagerly():\n        st = st()\n        self.assertEqual(st.to_pyval(), expected)",
            "@parameterized.named_parameters([dict(testcase_name='NoFieldsRaggedRank0', st=lambda : StructuredTensor.from_fields({}, (3,)), expected=[{}, {}, {}]), dict(testcase_name='NoFieldsRaggedRank1', st=lambda : StructuredTensor.from_fields({}, (2, None), row_partitions=[row_partition.RowPartition.from_row_lengths([3, 2])]), expected=[[{}, {}, {}], [{}, {}]]), dict(testcase_name='NoFieldsRaggedRank2', st=lambda : StructuredTensor.from_fields({}, (2, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2, 1]), row_partition.RowPartition.from_row_lengths([2, 3, 1])]), expected=[[[{}, {}], [{}, {}, {}]], [[{}]]]), dict(testcase_name='NoFieldsRaggedRank2NoDicts', st=lambda : StructuredTensor.from_fields({}, (1, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0])]), expected=[[[], []]]), dict(testcase_name='NestedStructTensorWithNoFields', st=lambda : StructuredTensor.from_fields({'foo': ragged_factory_ops.constant([[[], []]]), 'bar': StructuredTensor.from_fields({}, (1, None, None, None), row_partitions=[row_partition.RowPartition.from_row_lengths([2]), row_partition.RowPartition.from_row_lengths([0, 0]), row_partition.RowPartition.from_row_lengths([])])}, (1, None, None)), expected=[[[], []]])])\ndef testToPyval(self, st, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if context.executing_eagerly():\n        st = st()\n        self.assertEqual(st.to_pyval(), expected)"
        ]
    },
    {
        "func_name": "testFromPyvalError",
        "original": "@parameterized.named_parameters([dict(testcase_name='MissingKeys', pyval=[{'a': [1, 2]}, {'b': [3, 4]}], err=KeyError, msg=\"'b'\"), dict(testcase_name='TypeSpecMismatch_DictKey', pyval={'a': 1}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListDictKey', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_RankMismatch', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg='Value at \\\\(\\\\) does not match typespec \\\\(rank mismatch\\\\)'), dict(testcase_name='TypeSpecMismatch_Scalar', pyval=0, type_spec=StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[], dtype=dtypes.int64)), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListTensor', pyval={'a': [[1]]}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg=\"Value at \\\\('a',\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep', pyval={'a': {'b': [[1]]}}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([], dtypes.int32)}, rank=0)}, rank=0), msg=\"Value at \\\\('a', 'b'\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer', pyval={'a': [{'b': [[1]]}, {'b': [['c']]}]}, type_spec=None, msg=\"Error parsing path \\\\('a', 'b'\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer2', pyval=[{'a': 1}, {'a': 'c'}], type_spec=None, msg=\"Error parsing path \\\\('a',\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListSparse', pyval=[1, 2], type_spec=sparse_tensor.SparseTensorSpec([None], dtypes.int32), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListStruct', pyval=[[1]], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([1, 1], dtypes.int32)}, rank=2), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='InconsistentDictionaryDepth', pyval=[{}, [{}]], msg='Inconsistent depth of dictionaries'), dict(testcase_name='FOO', pyval=[[{}], 5], msg='Expected dict or nested list/tuple of dict')])\ndef testFromPyvalError(self, pyval, err=ValueError, type_spec=None, msg=None):\n    with self.assertRaisesRegex(err, msg):\n        structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)",
        "mutated": [
            "@parameterized.named_parameters([dict(testcase_name='MissingKeys', pyval=[{'a': [1, 2]}, {'b': [3, 4]}], err=KeyError, msg=\"'b'\"), dict(testcase_name='TypeSpecMismatch_DictKey', pyval={'a': 1}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListDictKey', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_RankMismatch', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg='Value at \\\\(\\\\) does not match typespec \\\\(rank mismatch\\\\)'), dict(testcase_name='TypeSpecMismatch_Scalar', pyval=0, type_spec=StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[], dtype=dtypes.int64)), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListTensor', pyval={'a': [[1]]}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg=\"Value at \\\\('a',\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep', pyval={'a': {'b': [[1]]}}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([], dtypes.int32)}, rank=0)}, rank=0), msg=\"Value at \\\\('a', 'b'\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer', pyval={'a': [{'b': [[1]]}, {'b': [['c']]}]}, type_spec=None, msg=\"Error parsing path \\\\('a', 'b'\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer2', pyval=[{'a': 1}, {'a': 'c'}], type_spec=None, msg=\"Error parsing path \\\\('a',\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListSparse', pyval=[1, 2], type_spec=sparse_tensor.SparseTensorSpec([None], dtypes.int32), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListStruct', pyval=[[1]], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([1, 1], dtypes.int32)}, rank=2), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='InconsistentDictionaryDepth', pyval=[{}, [{}]], msg='Inconsistent depth of dictionaries'), dict(testcase_name='FOO', pyval=[[{}], 5], msg='Expected dict or nested list/tuple of dict')])\ndef testFromPyvalError(self, pyval, err=ValueError, type_spec=None, msg=None):\n    if False:\n        i = 10\n    with self.assertRaisesRegex(err, msg):\n        structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)",
            "@parameterized.named_parameters([dict(testcase_name='MissingKeys', pyval=[{'a': [1, 2]}, {'b': [3, 4]}], err=KeyError, msg=\"'b'\"), dict(testcase_name='TypeSpecMismatch_DictKey', pyval={'a': 1}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListDictKey', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_RankMismatch', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg='Value at \\\\(\\\\) does not match typespec \\\\(rank mismatch\\\\)'), dict(testcase_name='TypeSpecMismatch_Scalar', pyval=0, type_spec=StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[], dtype=dtypes.int64)), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListTensor', pyval={'a': [[1]]}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg=\"Value at \\\\('a',\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep', pyval={'a': {'b': [[1]]}}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([], dtypes.int32)}, rank=0)}, rank=0), msg=\"Value at \\\\('a', 'b'\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer', pyval={'a': [{'b': [[1]]}, {'b': [['c']]}]}, type_spec=None, msg=\"Error parsing path \\\\('a', 'b'\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer2', pyval=[{'a': 1}, {'a': 'c'}], type_spec=None, msg=\"Error parsing path \\\\('a',\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListSparse', pyval=[1, 2], type_spec=sparse_tensor.SparseTensorSpec([None], dtypes.int32), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListStruct', pyval=[[1]], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([1, 1], dtypes.int32)}, rank=2), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='InconsistentDictionaryDepth', pyval=[{}, [{}]], msg='Inconsistent depth of dictionaries'), dict(testcase_name='FOO', pyval=[[{}], 5], msg='Expected dict or nested list/tuple of dict')])\ndef testFromPyvalError(self, pyval, err=ValueError, type_spec=None, msg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with self.assertRaisesRegex(err, msg):\n        structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)",
            "@parameterized.named_parameters([dict(testcase_name='MissingKeys', pyval=[{'a': [1, 2]}, {'b': [3, 4]}], err=KeyError, msg=\"'b'\"), dict(testcase_name='TypeSpecMismatch_DictKey', pyval={'a': 1}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListDictKey', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_RankMismatch', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg='Value at \\\\(\\\\) does not match typespec \\\\(rank mismatch\\\\)'), dict(testcase_name='TypeSpecMismatch_Scalar', pyval=0, type_spec=StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[], dtype=dtypes.int64)), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListTensor', pyval={'a': [[1]]}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg=\"Value at \\\\('a',\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep', pyval={'a': {'b': [[1]]}}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([], dtypes.int32)}, rank=0)}, rank=0), msg=\"Value at \\\\('a', 'b'\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer', pyval={'a': [{'b': [[1]]}, {'b': [['c']]}]}, type_spec=None, msg=\"Error parsing path \\\\('a', 'b'\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer2', pyval=[{'a': 1}, {'a': 'c'}], type_spec=None, msg=\"Error parsing path \\\\('a',\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListSparse', pyval=[1, 2], type_spec=sparse_tensor.SparseTensorSpec([None], dtypes.int32), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListStruct', pyval=[[1]], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([1, 1], dtypes.int32)}, rank=2), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='InconsistentDictionaryDepth', pyval=[{}, [{}]], msg='Inconsistent depth of dictionaries'), dict(testcase_name='FOO', pyval=[[{}], 5], msg='Expected dict or nested list/tuple of dict')])\ndef testFromPyvalError(self, pyval, err=ValueError, type_spec=None, msg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with self.assertRaisesRegex(err, msg):\n        structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)",
            "@parameterized.named_parameters([dict(testcase_name='MissingKeys', pyval=[{'a': [1, 2]}, {'b': [3, 4]}], err=KeyError, msg=\"'b'\"), dict(testcase_name='TypeSpecMismatch_DictKey', pyval={'a': 1}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListDictKey', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_RankMismatch', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg='Value at \\\\(\\\\) does not match typespec \\\\(rank mismatch\\\\)'), dict(testcase_name='TypeSpecMismatch_Scalar', pyval=0, type_spec=StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[], dtype=dtypes.int64)), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListTensor', pyval={'a': [[1]]}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg=\"Value at \\\\('a',\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep', pyval={'a': {'b': [[1]]}}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([], dtypes.int32)}, rank=0)}, rank=0), msg=\"Value at \\\\('a', 'b'\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer', pyval={'a': [{'b': [[1]]}, {'b': [['c']]}]}, type_spec=None, msg=\"Error parsing path \\\\('a', 'b'\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer2', pyval=[{'a': 1}, {'a': 'c'}], type_spec=None, msg=\"Error parsing path \\\\('a',\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListSparse', pyval=[1, 2], type_spec=sparse_tensor.SparseTensorSpec([None], dtypes.int32), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListStruct', pyval=[[1]], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([1, 1], dtypes.int32)}, rank=2), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='InconsistentDictionaryDepth', pyval=[{}, [{}]], msg='Inconsistent depth of dictionaries'), dict(testcase_name='FOO', pyval=[[{}], 5], msg='Expected dict or nested list/tuple of dict')])\ndef testFromPyvalError(self, pyval, err=ValueError, type_spec=None, msg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with self.assertRaisesRegex(err, msg):\n        structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)",
            "@parameterized.named_parameters([dict(testcase_name='MissingKeys', pyval=[{'a': [1, 2]}, {'b': [3, 4]}], err=KeyError, msg=\"'b'\"), dict(testcase_name='TypeSpecMismatch_DictKey', pyval={'a': 1}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListDictKey', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([1], dtypes.int32)}, rank=1), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_RankMismatch', pyval=[{'a': 1}], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg='Value at \\\\(\\\\) does not match typespec \\\\(rank mismatch\\\\)'), dict(testcase_name='TypeSpecMismatch_Scalar', pyval=0, type_spec=StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[], dtype=dtypes.int64)), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListTensor', pyval={'a': [[1]]}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([], dtypes.int32)}, rank=0), msg=\"Value at \\\\('a',\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep', pyval={'a': {'b': [[1]]}}, type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': StructuredTensor.Spec._from_fields_and_rank(fields={'b': tensor.TensorSpec([], dtypes.int32)}, rank=0)}, rank=0), msg=\"Value at \\\\('a', 'b'\\\\) does not match typespec\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer', pyval={'a': [{'b': [[1]]}, {'b': [['c']]}]}, type_spec=None, msg=\"Error parsing path \\\\('a', 'b'\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListTensorDeep_infer2', pyval=[{'a': 1}, {'a': 'c'}], type_spec=None, msg=\"Error parsing path \\\\('a',\\\\)\"), dict(testcase_name='TypeSpecMismatch_ListSparse', pyval=[1, 2], type_spec=sparse_tensor.SparseTensorSpec([None], dtypes.int32), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='TypeSpecMismatch_ListStruct', pyval=[[1]], type_spec=StructuredTensor.Spec._from_fields_and_rank(fields={'a': tensor.TensorSpec([1, 1], dtypes.int32)}, rank=2), msg='Value at \\\\(\\\\) does not match typespec'), dict(testcase_name='InconsistentDictionaryDepth', pyval=[{}, [{}]], msg='Inconsistent depth of dictionaries'), dict(testcase_name='FOO', pyval=[[{}], 5], msg='Expected dict or nested list/tuple of dict')])\ndef testFromPyvalError(self, pyval, err=ValueError, type_spec=None, msg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with self.assertRaisesRegex(err, msg):\n        structured_tensor.StructuredTensor.from_pyval(pyval, type_spec)"
        ]
    },
    {
        "func_name": "testToPyvalRequiresEagerMode",
        "original": "def testToPyvalRequiresEagerMode(self):\n    st = structured_tensor.StructuredTensor.from_pyval({'a': 5})\n    if not context.executing_eagerly():\n        with self.assertRaisesRegex(ValueError, 'only supported in eager mode.'):\n            st.to_pyval()",
        "mutated": [
            "def testToPyvalRequiresEagerMode(self):\n    if False:\n        i = 10\n    st = structured_tensor.StructuredTensor.from_pyval({'a': 5})\n    if not context.executing_eagerly():\n        with self.assertRaisesRegex(ValueError, 'only supported in eager mode.'):\n            st.to_pyval()",
            "def testToPyvalRequiresEagerMode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st = structured_tensor.StructuredTensor.from_pyval({'a': 5})\n    if not context.executing_eagerly():\n        with self.assertRaisesRegex(ValueError, 'only supported in eager mode.'):\n            st.to_pyval()",
            "def testToPyvalRequiresEagerMode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st = structured_tensor.StructuredTensor.from_pyval({'a': 5})\n    if not context.executing_eagerly():\n        with self.assertRaisesRegex(ValueError, 'only supported in eager mode.'):\n            st.to_pyval()",
            "def testToPyvalRequiresEagerMode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st = structured_tensor.StructuredTensor.from_pyval({'a': 5})\n    if not context.executing_eagerly():\n        with self.assertRaisesRegex(ValueError, 'only supported in eager mode.'):\n            st.to_pyval()",
            "def testToPyvalRequiresEagerMode(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st = structured_tensor.StructuredTensor.from_pyval({'a': 5})\n    if not context.executing_eagerly():\n        with self.assertRaisesRegex(ValueError, 'only supported in eager mode.'):\n            st.to_pyval()"
        ]
    },
    {
        "func_name": "testRowPartitionsFromUniformShape",
        "original": "@parameterized.named_parameters([('Rank0', []), ('Rank1', [5, 3]), ('Rank2', [5, 8, 3]), ('Rank5', [1, 2, 3, 4, 5])])\ndef testRowPartitionsFromUniformShape(self, shape):\n    for rank in range(len(shape)):\n        partitions = structured_tensor._row_partitions_for_uniform_shape(ops.convert_to_tensor(shape), rank)\n        self.assertLen(partitions, max(0, rank - 1))\n        if partitions:\n            self.assertAllEqual(shape[0], partitions[0].nrows())\n        for (dim, partition) in enumerate(partitions):\n            self.assertAllEqual(shape[dim + 1], partition.uniform_row_length())",
        "mutated": [
            "@parameterized.named_parameters([('Rank0', []), ('Rank1', [5, 3]), ('Rank2', [5, 8, 3]), ('Rank5', [1, 2, 3, 4, 5])])\ndef testRowPartitionsFromUniformShape(self, shape):\n    if False:\n        i = 10\n    for rank in range(len(shape)):\n        partitions = structured_tensor._row_partitions_for_uniform_shape(ops.convert_to_tensor(shape), rank)\n        self.assertLen(partitions, max(0, rank - 1))\n        if partitions:\n            self.assertAllEqual(shape[0], partitions[0].nrows())\n        for (dim, partition) in enumerate(partitions):\n            self.assertAllEqual(shape[dim + 1], partition.uniform_row_length())",
            "@parameterized.named_parameters([('Rank0', []), ('Rank1', [5, 3]), ('Rank2', [5, 8, 3]), ('Rank5', [1, 2, 3, 4, 5])])\ndef testRowPartitionsFromUniformShape(self, shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for rank in range(len(shape)):\n        partitions = structured_tensor._row_partitions_for_uniform_shape(ops.convert_to_tensor(shape), rank)\n        self.assertLen(partitions, max(0, rank - 1))\n        if partitions:\n            self.assertAllEqual(shape[0], partitions[0].nrows())\n        for (dim, partition) in enumerate(partitions):\n            self.assertAllEqual(shape[dim + 1], partition.uniform_row_length())",
            "@parameterized.named_parameters([('Rank0', []), ('Rank1', [5, 3]), ('Rank2', [5, 8, 3]), ('Rank5', [1, 2, 3, 4, 5])])\ndef testRowPartitionsFromUniformShape(self, shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for rank in range(len(shape)):\n        partitions = structured_tensor._row_partitions_for_uniform_shape(ops.convert_to_tensor(shape), rank)\n        self.assertLen(partitions, max(0, rank - 1))\n        if partitions:\n            self.assertAllEqual(shape[0], partitions[0].nrows())\n        for (dim, partition) in enumerate(partitions):\n            self.assertAllEqual(shape[dim + 1], partition.uniform_row_length())",
            "@parameterized.named_parameters([('Rank0', []), ('Rank1', [5, 3]), ('Rank2', [5, 8, 3]), ('Rank5', [1, 2, 3, 4, 5])])\ndef testRowPartitionsFromUniformShape(self, shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for rank in range(len(shape)):\n        partitions = structured_tensor._row_partitions_for_uniform_shape(ops.convert_to_tensor(shape), rank)\n        self.assertLen(partitions, max(0, rank - 1))\n        if partitions:\n            self.assertAllEqual(shape[0], partitions[0].nrows())\n        for (dim, partition) in enumerate(partitions):\n            self.assertAllEqual(shape[dim + 1], partition.uniform_row_length())",
            "@parameterized.named_parameters([('Rank0', []), ('Rank1', [5, 3]), ('Rank2', [5, 8, 3]), ('Rank5', [1, 2, 3, 4, 5])])\ndef testRowPartitionsFromUniformShape(self, shape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for rank in range(len(shape)):\n        partitions = structured_tensor._row_partitions_for_uniform_shape(ops.convert_to_tensor(shape), rank)\n        self.assertLen(partitions, max(0, rank - 1))\n        if partitions:\n            self.assertAllEqual(shape[0], partitions[0].nrows())\n        for (dim, partition) in enumerate(partitions):\n            self.assertAllEqual(shape[dim + 1], partition.uniform_row_length())"
        ]
    },
    {
        "func_name": "testRowPartitionsForRaggedTensor",
        "original": "@parameterized.named_parameters([dict(testcase_name='Shape_UR_Rank2', rt=[[1, 2], [], [3]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 0, 1]]), dict(testcase_name='Shape_URR_Rank2', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URU_Rank2', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URR_Rank3', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[2, 1], [2, 0, 1]]), dict(testcase_name='Shape_URU_Rank3', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=3, expected_row_lengths=[[2, 1], [1, 1, 1]]), dict(testcase_name='Shape_URRUU_Rank2', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[1]]), dict(testcase_name='Shape_URRUU_Rank3', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[1], [1]]), dict(testcase_name='Shape_URRUU_Rank4', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=4, expected_row_lengths=[[1], [1], [1]]), dict(testcase_name='Shape_URRUU_Rank5', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=5, expected_row_lengths=[[1], [1], [1], [2]])])\ndef testRowPartitionsForRaggedTensor(self, rt, rt_ragged_rank, rank, expected_row_lengths):\n    rt = ragged_factory_ops.constant(rt, rt_ragged_rank)\n    partitions = structured_tensor._row_partitions_for_ragged_tensor(rt, rank, dtypes.int64)\n    self.assertLen(partitions, rank - 1)\n    self.assertLen(partitions, len(expected_row_lengths))\n    for (partition, expected) in zip(partitions, expected_row_lengths):\n        self.assertAllEqual(partition.row_lengths(), expected)",
        "mutated": [
            "@parameterized.named_parameters([dict(testcase_name='Shape_UR_Rank2', rt=[[1, 2], [], [3]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 0, 1]]), dict(testcase_name='Shape_URR_Rank2', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URU_Rank2', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URR_Rank3', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[2, 1], [2, 0, 1]]), dict(testcase_name='Shape_URU_Rank3', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=3, expected_row_lengths=[[2, 1], [1, 1, 1]]), dict(testcase_name='Shape_URRUU_Rank2', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[1]]), dict(testcase_name='Shape_URRUU_Rank3', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[1], [1]]), dict(testcase_name='Shape_URRUU_Rank4', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=4, expected_row_lengths=[[1], [1], [1]]), dict(testcase_name='Shape_URRUU_Rank5', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=5, expected_row_lengths=[[1], [1], [1], [2]])])\ndef testRowPartitionsForRaggedTensor(self, rt, rt_ragged_rank, rank, expected_row_lengths):\n    if False:\n        i = 10\n    rt = ragged_factory_ops.constant(rt, rt_ragged_rank)\n    partitions = structured_tensor._row_partitions_for_ragged_tensor(rt, rank, dtypes.int64)\n    self.assertLen(partitions, rank - 1)\n    self.assertLen(partitions, len(expected_row_lengths))\n    for (partition, expected) in zip(partitions, expected_row_lengths):\n        self.assertAllEqual(partition.row_lengths(), expected)",
            "@parameterized.named_parameters([dict(testcase_name='Shape_UR_Rank2', rt=[[1, 2], [], [3]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 0, 1]]), dict(testcase_name='Shape_URR_Rank2', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URU_Rank2', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URR_Rank3', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[2, 1], [2, 0, 1]]), dict(testcase_name='Shape_URU_Rank3', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=3, expected_row_lengths=[[2, 1], [1, 1, 1]]), dict(testcase_name='Shape_URRUU_Rank2', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[1]]), dict(testcase_name='Shape_URRUU_Rank3', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[1], [1]]), dict(testcase_name='Shape_URRUU_Rank4', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=4, expected_row_lengths=[[1], [1], [1]]), dict(testcase_name='Shape_URRUU_Rank5', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=5, expected_row_lengths=[[1], [1], [1], [2]])])\ndef testRowPartitionsForRaggedTensor(self, rt, rt_ragged_rank, rank, expected_row_lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rt = ragged_factory_ops.constant(rt, rt_ragged_rank)\n    partitions = structured_tensor._row_partitions_for_ragged_tensor(rt, rank, dtypes.int64)\n    self.assertLen(partitions, rank - 1)\n    self.assertLen(partitions, len(expected_row_lengths))\n    for (partition, expected) in zip(partitions, expected_row_lengths):\n        self.assertAllEqual(partition.row_lengths(), expected)",
            "@parameterized.named_parameters([dict(testcase_name='Shape_UR_Rank2', rt=[[1, 2], [], [3]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 0, 1]]), dict(testcase_name='Shape_URR_Rank2', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URU_Rank2', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URR_Rank3', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[2, 1], [2, 0, 1]]), dict(testcase_name='Shape_URU_Rank3', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=3, expected_row_lengths=[[2, 1], [1, 1, 1]]), dict(testcase_name='Shape_URRUU_Rank2', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[1]]), dict(testcase_name='Shape_URRUU_Rank3', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[1], [1]]), dict(testcase_name='Shape_URRUU_Rank4', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=4, expected_row_lengths=[[1], [1], [1]]), dict(testcase_name='Shape_URRUU_Rank5', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=5, expected_row_lengths=[[1], [1], [1], [2]])])\ndef testRowPartitionsForRaggedTensor(self, rt, rt_ragged_rank, rank, expected_row_lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rt = ragged_factory_ops.constant(rt, rt_ragged_rank)\n    partitions = structured_tensor._row_partitions_for_ragged_tensor(rt, rank, dtypes.int64)\n    self.assertLen(partitions, rank - 1)\n    self.assertLen(partitions, len(expected_row_lengths))\n    for (partition, expected) in zip(partitions, expected_row_lengths):\n        self.assertAllEqual(partition.row_lengths(), expected)",
            "@parameterized.named_parameters([dict(testcase_name='Shape_UR_Rank2', rt=[[1, 2], [], [3]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 0, 1]]), dict(testcase_name='Shape_URR_Rank2', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URU_Rank2', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URR_Rank3', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[2, 1], [2, 0, 1]]), dict(testcase_name='Shape_URU_Rank3', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=3, expected_row_lengths=[[2, 1], [1, 1, 1]]), dict(testcase_name='Shape_URRUU_Rank2', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[1]]), dict(testcase_name='Shape_URRUU_Rank3', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[1], [1]]), dict(testcase_name='Shape_URRUU_Rank4', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=4, expected_row_lengths=[[1], [1], [1]]), dict(testcase_name='Shape_URRUU_Rank5', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=5, expected_row_lengths=[[1], [1], [1], [2]])])\ndef testRowPartitionsForRaggedTensor(self, rt, rt_ragged_rank, rank, expected_row_lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rt = ragged_factory_ops.constant(rt, rt_ragged_rank)\n    partitions = structured_tensor._row_partitions_for_ragged_tensor(rt, rank, dtypes.int64)\n    self.assertLen(partitions, rank - 1)\n    self.assertLen(partitions, len(expected_row_lengths))\n    for (partition, expected) in zip(partitions, expected_row_lengths):\n        self.assertAllEqual(partition.row_lengths(), expected)",
            "@parameterized.named_parameters([dict(testcase_name='Shape_UR_Rank2', rt=[[1, 2], [], [3]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 0, 1]]), dict(testcase_name='Shape_URR_Rank2', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URU_Rank2', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=2, expected_row_lengths=[[2, 1]]), dict(testcase_name='Shape_URR_Rank3', rt=[[[1, 2], []], [[3]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[2, 1], [2, 0, 1]]), dict(testcase_name='Shape_URU_Rank3', rt=[[[1], [2]], [[3]]], rt_ragged_rank=1, rank=3, expected_row_lengths=[[2, 1], [1, 1, 1]]), dict(testcase_name='Shape_URRUU_Rank2', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=2, expected_row_lengths=[[1]]), dict(testcase_name='Shape_URRUU_Rank3', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=3, expected_row_lengths=[[1], [1]]), dict(testcase_name='Shape_URRUU_Rank4', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=4, expected_row_lengths=[[1], [1], [1]]), dict(testcase_name='Shape_URRUU_Rank5', rt=[[[[[1, 2]]]]], rt_ragged_rank=2, rank=5, expected_row_lengths=[[1], [1], [1], [2]])])\ndef testRowPartitionsForRaggedTensor(self, rt, rt_ragged_rank, rank, expected_row_lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rt = ragged_factory_ops.constant(rt, rt_ragged_rank)\n    partitions = structured_tensor._row_partitions_for_ragged_tensor(rt, rank, dtypes.int64)\n    self.assertLen(partitions, rank - 1)\n    self.assertLen(partitions, len(expected_row_lengths))\n    for (partition, expected) in zip(partitions, expected_row_lengths):\n        self.assertAllEqual(partition.row_lengths(), expected)"
        ]
    },
    {
        "func_name": "testMergeDims",
        "original": "@parameterized.named_parameters([dict(testcase_name='2D_0_1', st=[[{'x': 1}, {'x': 2}], [{'x': 3}]], outer_axis=0, inner_axis=1, expected=[{'x': 1}, {'x': 2}, {'x': 3}]), dict(testcase_name='3D_0_1', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=1, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_1_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=1, inner_axis=2, expected=[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_0_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=2, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}]), dict(testcase_name='4D_0_1', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=1, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]], [[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_0_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=2, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}], [{'x': 5}], [{'x': 6}], [{'x': 7}]]), dict(testcase_name='4D_0_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=3, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}, {'x': 5}, {'x': 6}, {'x': 7}]), dict(testcase_name='4D_1_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=2, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_1_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=3, expected=[[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}], [{'x': 5}, {'x': 6}, {'x': 7}]]), dict(testcase_name='4D_2_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=2, inner_axis=3, expected=[[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}, {'x': 7}]]])])\ndef testMergeDims(self, st, outer_axis, inner_axis, expected):\n    st = StructuredTensor.from_pyval(st)\n    result = st.merge_dims(outer_axis, inner_axis)\n    self.assertAllEqual(result, expected)",
        "mutated": [
            "@parameterized.named_parameters([dict(testcase_name='2D_0_1', st=[[{'x': 1}, {'x': 2}], [{'x': 3}]], outer_axis=0, inner_axis=1, expected=[{'x': 1}, {'x': 2}, {'x': 3}]), dict(testcase_name='3D_0_1', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=1, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_1_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=1, inner_axis=2, expected=[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_0_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=2, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}]), dict(testcase_name='4D_0_1', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=1, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]], [[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_0_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=2, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}], [{'x': 5}], [{'x': 6}], [{'x': 7}]]), dict(testcase_name='4D_0_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=3, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}, {'x': 5}, {'x': 6}, {'x': 7}]), dict(testcase_name='4D_1_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=2, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_1_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=3, expected=[[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}], [{'x': 5}, {'x': 6}, {'x': 7}]]), dict(testcase_name='4D_2_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=2, inner_axis=3, expected=[[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}, {'x': 7}]]])])\ndef testMergeDims(self, st, outer_axis, inner_axis, expected):\n    if False:\n        i = 10\n    st = StructuredTensor.from_pyval(st)\n    result = st.merge_dims(outer_axis, inner_axis)\n    self.assertAllEqual(result, expected)",
            "@parameterized.named_parameters([dict(testcase_name='2D_0_1', st=[[{'x': 1}, {'x': 2}], [{'x': 3}]], outer_axis=0, inner_axis=1, expected=[{'x': 1}, {'x': 2}, {'x': 3}]), dict(testcase_name='3D_0_1', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=1, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_1_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=1, inner_axis=2, expected=[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_0_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=2, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}]), dict(testcase_name='4D_0_1', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=1, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]], [[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_0_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=2, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}], [{'x': 5}], [{'x': 6}], [{'x': 7}]]), dict(testcase_name='4D_0_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=3, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}, {'x': 5}, {'x': 6}, {'x': 7}]), dict(testcase_name='4D_1_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=2, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_1_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=3, expected=[[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}], [{'x': 5}, {'x': 6}, {'x': 7}]]), dict(testcase_name='4D_2_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=2, inner_axis=3, expected=[[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}, {'x': 7}]]])])\ndef testMergeDims(self, st, outer_axis, inner_axis, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st = StructuredTensor.from_pyval(st)\n    result = st.merge_dims(outer_axis, inner_axis)\n    self.assertAllEqual(result, expected)",
            "@parameterized.named_parameters([dict(testcase_name='2D_0_1', st=[[{'x': 1}, {'x': 2}], [{'x': 3}]], outer_axis=0, inner_axis=1, expected=[{'x': 1}, {'x': 2}, {'x': 3}]), dict(testcase_name='3D_0_1', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=1, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_1_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=1, inner_axis=2, expected=[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_0_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=2, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}]), dict(testcase_name='4D_0_1', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=1, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]], [[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_0_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=2, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}], [{'x': 5}], [{'x': 6}], [{'x': 7}]]), dict(testcase_name='4D_0_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=3, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}, {'x': 5}, {'x': 6}, {'x': 7}]), dict(testcase_name='4D_1_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=2, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_1_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=3, expected=[[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}], [{'x': 5}, {'x': 6}, {'x': 7}]]), dict(testcase_name='4D_2_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=2, inner_axis=3, expected=[[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}, {'x': 7}]]])])\ndef testMergeDims(self, st, outer_axis, inner_axis, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st = StructuredTensor.from_pyval(st)\n    result = st.merge_dims(outer_axis, inner_axis)\n    self.assertAllEqual(result, expected)",
            "@parameterized.named_parameters([dict(testcase_name='2D_0_1', st=[[{'x': 1}, {'x': 2}], [{'x': 3}]], outer_axis=0, inner_axis=1, expected=[{'x': 1}, {'x': 2}, {'x': 3}]), dict(testcase_name='3D_0_1', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=1, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_1_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=1, inner_axis=2, expected=[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_0_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=2, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}]), dict(testcase_name='4D_0_1', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=1, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]], [[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_0_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=2, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}], [{'x': 5}], [{'x': 6}], [{'x': 7}]]), dict(testcase_name='4D_0_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=3, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}, {'x': 5}, {'x': 6}, {'x': 7}]), dict(testcase_name='4D_1_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=2, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_1_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=3, expected=[[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}], [{'x': 5}, {'x': 6}, {'x': 7}]]), dict(testcase_name='4D_2_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=2, inner_axis=3, expected=[[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}, {'x': 7}]]])])\ndef testMergeDims(self, st, outer_axis, inner_axis, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st = StructuredTensor.from_pyval(st)\n    result = st.merge_dims(outer_axis, inner_axis)\n    self.assertAllEqual(result, expected)",
            "@parameterized.named_parameters([dict(testcase_name='2D_0_1', st=[[{'x': 1}, {'x': 2}], [{'x': 3}]], outer_axis=0, inner_axis=1, expected=[{'x': 1}, {'x': 2}, {'x': 3}]), dict(testcase_name='3D_0_1', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=1, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_1_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=1, inner_axis=2, expected=[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]]), dict(testcase_name='3D_0_2', st=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], outer_axis=0, inner_axis=2, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}]), dict(testcase_name='4D_0_1', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=1, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]], [[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_0_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=2, expected=[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}], [{'x': 5}], [{'x': 6}], [{'x': 7}]]), dict(testcase_name='4D_0_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=0, inner_axis=3, expected=[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}, {'x': 5}, {'x': 6}, {'x': 7}]), dict(testcase_name='4D_1_2', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=2, expected=[[[{'x': 1}, {'x': 2}], [{'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}], [{'x': 7}]]]), dict(testcase_name='4D_1_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=1, inner_axis=3, expected=[[{'x': 1}, {'x': 2}, {'x': 3}, {'x': 4}], [{'x': 5}, {'x': 6}, {'x': 7}]]), dict(testcase_name='4D_2_3', st=[[[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]], [[[{'x': 5}]], [[{'x': 6}], [{'x': 7}]]]], outer_axis=2, inner_axis=3, expected=[[[{'x': 1}, {'x': 2}, {'x': 3}], [{'x': 4}]], [[{'x': 5}], [{'x': 6}, {'x': 7}]]])])\ndef testMergeDims(self, st, outer_axis, inner_axis, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st = StructuredTensor.from_pyval(st)\n    result = st.merge_dims(outer_axis, inner_axis)\n    self.assertAllEqual(result, expected)"
        ]
    },
    {
        "func_name": "testMergeDimsDetail_3D_0_1",
        "original": "def testMergeDimsDetail_3D_0_1(self):\n    st = StructuredTensor.from_pyval([[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]])\n    result = st.merge_dims(0, 1)\n    expected_shape = tensor_shape.TensorShape([3, None])\n    self.assertTrue(expected_shape.is_compatible_with(result.shape))",
        "mutated": [
            "def testMergeDimsDetail_3D_0_1(self):\n    if False:\n        i = 10\n    st = StructuredTensor.from_pyval([[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]])\n    result = st.merge_dims(0, 1)\n    expected_shape = tensor_shape.TensorShape([3, None])\n    self.assertTrue(expected_shape.is_compatible_with(result.shape))",
            "def testMergeDimsDetail_3D_0_1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st = StructuredTensor.from_pyval([[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]])\n    result = st.merge_dims(0, 1)\n    expected_shape = tensor_shape.TensorShape([3, None])\n    self.assertTrue(expected_shape.is_compatible_with(result.shape))",
            "def testMergeDimsDetail_3D_0_1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st = StructuredTensor.from_pyval([[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]])\n    result = st.merge_dims(0, 1)\n    expected_shape = tensor_shape.TensorShape([3, None])\n    self.assertTrue(expected_shape.is_compatible_with(result.shape))",
            "def testMergeDimsDetail_3D_0_1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st = StructuredTensor.from_pyval([[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]])\n    result = st.merge_dims(0, 1)\n    expected_shape = tensor_shape.TensorShape([3, None])\n    self.assertTrue(expected_shape.is_compatible_with(result.shape))",
            "def testMergeDimsDetail_3D_0_1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st = StructuredTensor.from_pyval([[[{'x': 1}, {'x': 2}], [{'x': 3}]], [[{'x': 4}]]])\n    result = st.merge_dims(0, 1)\n    expected_shape = tensor_shape.TensorShape([3, None])\n    self.assertTrue(expected_shape.is_compatible_with(result.shape))"
        ]
    },
    {
        "func_name": "testMergeDims_0_1",
        "original": "def testMergeDims_0_1(self):\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertLen(struct_3.row_partitions, 2)\n    merged = struct_3.merge_dims(0, 1)\n    self.assertLen(merged.row_partitions, 1)",
        "mutated": [
            "def testMergeDims_0_1(self):\n    if False:\n        i = 10\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertLen(struct_3.row_partitions, 2)\n    merged = struct_3.merge_dims(0, 1)\n    self.assertLen(merged.row_partitions, 1)",
            "def testMergeDims_0_1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertLen(struct_3.row_partitions, 2)\n    merged = struct_3.merge_dims(0, 1)\n    self.assertLen(merged.row_partitions, 1)",
            "def testMergeDims_0_1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertLen(struct_3.row_partitions, 2)\n    merged = struct_3.merge_dims(0, 1)\n    self.assertLen(merged.row_partitions, 1)",
            "def testMergeDims_0_1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertLen(struct_3.row_partitions, 2)\n    merged = struct_3.merge_dims(0, 1)\n    self.assertLen(merged.row_partitions, 1)",
            "def testMergeDims_0_1(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rt = ragged_tensor.RaggedTensor.from_value_rowids(array_ops.constant([[1, 2], [3, 4], [5, 6]]), [0, 0, 1])\n    struct = StructuredTensor.from_fields({'r': rt}, [2])\n    struct_2 = struct.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    struct_3 = struct_2.partition_outer_dimension(row_partition.RowPartition.from_row_splits([0, 1, 2]))\n    self.assertLen(struct_3.row_partitions, 2)\n    merged = struct_3.merge_dims(0, 1)\n    self.assertLen(merged.row_partitions, 1)"
        ]
    },
    {
        "func_name": "testMergeDimsError",
        "original": "def testMergeDimsError(self):\n    st = StructuredTensor.from_pyval([[[{'a': 5}]]])\n    with self.assertRaisesRegex(ValueError, 'Expected outer_axis \\\\(2\\\\) to be less than or equal to inner_axis \\\\(1\\\\)'):\n        st.merge_dims(2, 1)",
        "mutated": [
            "def testMergeDimsError(self):\n    if False:\n        i = 10\n    st = StructuredTensor.from_pyval([[[{'a': 5}]]])\n    with self.assertRaisesRegex(ValueError, 'Expected outer_axis \\\\(2\\\\) to be less than or equal to inner_axis \\\\(1\\\\)'):\n        st.merge_dims(2, 1)",
            "def testMergeDimsError(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st = StructuredTensor.from_pyval([[[{'a': 5}]]])\n    with self.assertRaisesRegex(ValueError, 'Expected outer_axis \\\\(2\\\\) to be less than or equal to inner_axis \\\\(1\\\\)'):\n        st.merge_dims(2, 1)",
            "def testMergeDimsError(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st = StructuredTensor.from_pyval([[[{'a': 5}]]])\n    with self.assertRaisesRegex(ValueError, 'Expected outer_axis \\\\(2\\\\) to be less than or equal to inner_axis \\\\(1\\\\)'):\n        st.merge_dims(2, 1)",
            "def testMergeDimsError(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st = StructuredTensor.from_pyval([[[{'a': 5}]]])\n    with self.assertRaisesRegex(ValueError, 'Expected outer_axis \\\\(2\\\\) to be less than or equal to inner_axis \\\\(1\\\\)'):\n        st.merge_dims(2, 1)",
            "def testMergeDimsError(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st = StructuredTensor.from_pyval([[[{'a': 5}]]])\n    with self.assertRaisesRegex(ValueError, 'Expected outer_axis \\\\(2\\\\) to be less than or equal to inner_axis \\\\(1\\\\)'):\n        st.merge_dims(2, 1)"
        ]
    },
    {
        "func_name": "testTupleFieldValue",
        "original": "def testTupleFieldValue(self):\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    self.assertAllEqual(st.field_value(('a',)), 5)\n    self.assertAllEqual(st.field_value(('b', 'c')), [1, 2, 3])\n    expected = 'Field path \\\\(.*a.*,.*b.*\\\\) not found in .*'\n    with self.assertRaisesRegex(KeyError, expected):\n        st.field_value(('a', 'b'))",
        "mutated": [
            "def testTupleFieldValue(self):\n    if False:\n        i = 10\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    self.assertAllEqual(st.field_value(('a',)), 5)\n    self.assertAllEqual(st.field_value(('b', 'c')), [1, 2, 3])\n    expected = 'Field path \\\\(.*a.*,.*b.*\\\\) not found in .*'\n    with self.assertRaisesRegex(KeyError, expected):\n        st.field_value(('a', 'b'))",
            "def testTupleFieldValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    self.assertAllEqual(st.field_value(('a',)), 5)\n    self.assertAllEqual(st.field_value(('b', 'c')), [1, 2, 3])\n    expected = 'Field path \\\\(.*a.*,.*b.*\\\\) not found in .*'\n    with self.assertRaisesRegex(KeyError, expected):\n        st.field_value(('a', 'b'))",
            "def testTupleFieldValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    self.assertAllEqual(st.field_value(('a',)), 5)\n    self.assertAllEqual(st.field_value(('b', 'c')), [1, 2, 3])\n    expected = 'Field path \\\\(.*a.*,.*b.*\\\\) not found in .*'\n    with self.assertRaisesRegex(KeyError, expected):\n        st.field_value(('a', 'b'))",
            "def testTupleFieldValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    self.assertAllEqual(st.field_value(('a',)), 5)\n    self.assertAllEqual(st.field_value(('b', 'c')), [1, 2, 3])\n    expected = 'Field path \\\\(.*a.*,.*b.*\\\\) not found in .*'\n    with self.assertRaisesRegex(KeyError, expected):\n        st.field_value(('a', 'b'))",
            "def testTupleFieldValue(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    self.assertAllEqual(st.field_value(('a',)), 5)\n    self.assertAllEqual(st.field_value(('b', 'c')), [1, 2, 3])\n    expected = 'Field path \\\\(.*a.*,.*b.*\\\\) not found in .*'\n    with self.assertRaisesRegex(KeyError, expected):\n        st.field_value(('a', 'b'))"
        ]
    },
    {
        "func_name": "testPromote",
        "original": "@parameterized.named_parameters([dict(testcase_name='scalar_scalar_scalar', st={'b': {'a': 5}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': 5}, 'new_field': 5}), dict(testcase_name='scalar_scalar_repeated', st={'b': {'a': [5, 3]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [5, 3]}, 'new_field': [5, 3]}), dict(testcase_name='scalar_scalar_repeated2', st={'b': {'a': [[7], [5, 3]]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [[7], [5, 3]]}, 'new_field': [[7], [5, 3]]}), dict(testcase_name='repeated_scalar_repeated', st=[{'b': {'a': [7]}}, {'b': {'a': [5, 3]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [7]}, 'new_field': [7]}, {'b': {'a': [5, 3]}, 'new_field': [5, 3]}]), dict(testcase_name='repeated_scalar_repeated2', st=[{'b': {'a': [[5, 7], []]}}, {'b': {'a': [[5, 1], [3]]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [[5, 7], []]}, 'new_field': [[5, 7], []]}, {'b': {'a': [[5, 1], [3]]}, 'new_field': [[5, 1], [3]]}]), dict(testcase_name='scalar_scalar_scalar_scalar', st={'a': {'b': {'c': 7}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': 7}, 'new_field': 7}}), dict(testcase_name='repeated_scalar_scalar_scalar', st=[{'a': {'b': {'c': 7}}}, {'a': {'b': {'c': 5}}}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': {'b': {'c': 7}, 'new_field': 7}}, {'a': {'b': {'c': 5}, 'new_field': 5}}]), dict(testcase_name='repeated_repeated_scalar_scalar', st=[{'a': [{'b': {'c': 7}}, {'b': {'c': 3}}]}, {'a': [{'b': {'c': 5}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': 7}, 'new_field': 7}, {'b': {'c': 3}, 'new_field': 3}]}, {'a': [{'b': {'c': 5}, 'new_field': 5}]}]), dict(testcase_name='docs_tokens', st=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}]}, {'docs': [{'tokens': [5, 15]}]}], source_path=('docs', 'tokens'), new_field_name='docs_tokens', expected=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}], 'docs_tokens': [7, 17, 3, 13]}, {'docs': [{'tokens': [5, 15]}], 'docs_tokens': [5, 15]}]), dict(testcase_name='repeated_repeated_scalar_repeated', st=[{'a': [{'b': {'c': [7, 17]}}, {'b': {'c': [3, 13]}}]}, {'a': [{'b': {'c': [5, 15]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [7, 17]}, 'new_field': [7, 17]}, {'b': {'c': [3, 13]}, 'new_field': [3, 13]}]}, {'a': [{'b': {'c': [5, 15]}, 'new_field': [5, 15]}]}]), dict(testcase_name='scalar_scalar_scalar_repeated', st={'a': {'b': {'c': [7, 3, 5]}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': [7, 3, 5]}, 'new_field': [7, 3, 5]}}), dict(testcase_name='repeated_repeated_scalar_repeated2', st=[{'a': [{'b': {'c': [[7, 3], [17]]}}, {'b': {'c': [[3, 13]]}}]}, {'a': [{'b': {'c': [[5, 15]]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [[7, 3], [17]]}, 'new_field': [[7, 3], [17]]}, {'b': {'c': [[3, 13]]}, 'new_field': [[3, 13]]}]}, {'a': [{'b': {'c': [[5, 15]]}, 'new_field': [[5, 15]]}]}]), dict(testcase_name='example_4_promote_of_labeled_vector', st=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}]}], source_path=('user_info', 'gaia_id'), new_field_name='user_info_gaia_id', expected=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}], 'user_info_gaia_id': [{'vec': [0, 1, 2]}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}], 'user_info_gaia_id': [{'vec': [3, 4, 5]}]}]), dict(testcase_name='promote_structure', st=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}]}]}, {'a': [{'aa': [{'b': {'c': 12}}]}]}], source_path=('a', 'aa', 'b'), new_field_name='new_field', expected=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}], 'new_field': [{'c': 1}, {'c': 8}]}]}, {'a': [{'aa': [{'b': {'c': 12}}], 'new_field': [{'c': 12}]}]}])])\ndef testPromote(self, st, source_path, new_field_name, expected):\n    st2 = StructuredTensor.from_pyval(st)\n    expected2 = StructuredTensor.from_pyval(expected)\n    result = st2.promote(source_path, new_field_name)\n    self.assertAllEqual(result, expected2)",
        "mutated": [
            "@parameterized.named_parameters([dict(testcase_name='scalar_scalar_scalar', st={'b': {'a': 5}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': 5}, 'new_field': 5}), dict(testcase_name='scalar_scalar_repeated', st={'b': {'a': [5, 3]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [5, 3]}, 'new_field': [5, 3]}), dict(testcase_name='scalar_scalar_repeated2', st={'b': {'a': [[7], [5, 3]]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [[7], [5, 3]]}, 'new_field': [[7], [5, 3]]}), dict(testcase_name='repeated_scalar_repeated', st=[{'b': {'a': [7]}}, {'b': {'a': [5, 3]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [7]}, 'new_field': [7]}, {'b': {'a': [5, 3]}, 'new_field': [5, 3]}]), dict(testcase_name='repeated_scalar_repeated2', st=[{'b': {'a': [[5, 7], []]}}, {'b': {'a': [[5, 1], [3]]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [[5, 7], []]}, 'new_field': [[5, 7], []]}, {'b': {'a': [[5, 1], [3]]}, 'new_field': [[5, 1], [3]]}]), dict(testcase_name='scalar_scalar_scalar_scalar', st={'a': {'b': {'c': 7}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': 7}, 'new_field': 7}}), dict(testcase_name='repeated_scalar_scalar_scalar', st=[{'a': {'b': {'c': 7}}}, {'a': {'b': {'c': 5}}}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': {'b': {'c': 7}, 'new_field': 7}}, {'a': {'b': {'c': 5}, 'new_field': 5}}]), dict(testcase_name='repeated_repeated_scalar_scalar', st=[{'a': [{'b': {'c': 7}}, {'b': {'c': 3}}]}, {'a': [{'b': {'c': 5}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': 7}, 'new_field': 7}, {'b': {'c': 3}, 'new_field': 3}]}, {'a': [{'b': {'c': 5}, 'new_field': 5}]}]), dict(testcase_name='docs_tokens', st=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}]}, {'docs': [{'tokens': [5, 15]}]}], source_path=('docs', 'tokens'), new_field_name='docs_tokens', expected=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}], 'docs_tokens': [7, 17, 3, 13]}, {'docs': [{'tokens': [5, 15]}], 'docs_tokens': [5, 15]}]), dict(testcase_name='repeated_repeated_scalar_repeated', st=[{'a': [{'b': {'c': [7, 17]}}, {'b': {'c': [3, 13]}}]}, {'a': [{'b': {'c': [5, 15]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [7, 17]}, 'new_field': [7, 17]}, {'b': {'c': [3, 13]}, 'new_field': [3, 13]}]}, {'a': [{'b': {'c': [5, 15]}, 'new_field': [5, 15]}]}]), dict(testcase_name='scalar_scalar_scalar_repeated', st={'a': {'b': {'c': [7, 3, 5]}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': [7, 3, 5]}, 'new_field': [7, 3, 5]}}), dict(testcase_name='repeated_repeated_scalar_repeated2', st=[{'a': [{'b': {'c': [[7, 3], [17]]}}, {'b': {'c': [[3, 13]]}}]}, {'a': [{'b': {'c': [[5, 15]]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [[7, 3], [17]]}, 'new_field': [[7, 3], [17]]}, {'b': {'c': [[3, 13]]}, 'new_field': [[3, 13]]}]}, {'a': [{'b': {'c': [[5, 15]]}, 'new_field': [[5, 15]]}]}]), dict(testcase_name='example_4_promote_of_labeled_vector', st=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}]}], source_path=('user_info', 'gaia_id'), new_field_name='user_info_gaia_id', expected=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}], 'user_info_gaia_id': [{'vec': [0, 1, 2]}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}], 'user_info_gaia_id': [{'vec': [3, 4, 5]}]}]), dict(testcase_name='promote_structure', st=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}]}]}, {'a': [{'aa': [{'b': {'c': 12}}]}]}], source_path=('a', 'aa', 'b'), new_field_name='new_field', expected=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}], 'new_field': [{'c': 1}, {'c': 8}]}]}, {'a': [{'aa': [{'b': {'c': 12}}], 'new_field': [{'c': 12}]}]}])])\ndef testPromote(self, st, source_path, new_field_name, expected):\n    if False:\n        i = 10\n    st2 = StructuredTensor.from_pyval(st)\n    expected2 = StructuredTensor.from_pyval(expected)\n    result = st2.promote(source_path, new_field_name)\n    self.assertAllEqual(result, expected2)",
            "@parameterized.named_parameters([dict(testcase_name='scalar_scalar_scalar', st={'b': {'a': 5}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': 5}, 'new_field': 5}), dict(testcase_name='scalar_scalar_repeated', st={'b': {'a': [5, 3]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [5, 3]}, 'new_field': [5, 3]}), dict(testcase_name='scalar_scalar_repeated2', st={'b': {'a': [[7], [5, 3]]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [[7], [5, 3]]}, 'new_field': [[7], [5, 3]]}), dict(testcase_name='repeated_scalar_repeated', st=[{'b': {'a': [7]}}, {'b': {'a': [5, 3]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [7]}, 'new_field': [7]}, {'b': {'a': [5, 3]}, 'new_field': [5, 3]}]), dict(testcase_name='repeated_scalar_repeated2', st=[{'b': {'a': [[5, 7], []]}}, {'b': {'a': [[5, 1], [3]]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [[5, 7], []]}, 'new_field': [[5, 7], []]}, {'b': {'a': [[5, 1], [3]]}, 'new_field': [[5, 1], [3]]}]), dict(testcase_name='scalar_scalar_scalar_scalar', st={'a': {'b': {'c': 7}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': 7}, 'new_field': 7}}), dict(testcase_name='repeated_scalar_scalar_scalar', st=[{'a': {'b': {'c': 7}}}, {'a': {'b': {'c': 5}}}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': {'b': {'c': 7}, 'new_field': 7}}, {'a': {'b': {'c': 5}, 'new_field': 5}}]), dict(testcase_name='repeated_repeated_scalar_scalar', st=[{'a': [{'b': {'c': 7}}, {'b': {'c': 3}}]}, {'a': [{'b': {'c': 5}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': 7}, 'new_field': 7}, {'b': {'c': 3}, 'new_field': 3}]}, {'a': [{'b': {'c': 5}, 'new_field': 5}]}]), dict(testcase_name='docs_tokens', st=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}]}, {'docs': [{'tokens': [5, 15]}]}], source_path=('docs', 'tokens'), new_field_name='docs_tokens', expected=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}], 'docs_tokens': [7, 17, 3, 13]}, {'docs': [{'tokens': [5, 15]}], 'docs_tokens': [5, 15]}]), dict(testcase_name='repeated_repeated_scalar_repeated', st=[{'a': [{'b': {'c': [7, 17]}}, {'b': {'c': [3, 13]}}]}, {'a': [{'b': {'c': [5, 15]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [7, 17]}, 'new_field': [7, 17]}, {'b': {'c': [3, 13]}, 'new_field': [3, 13]}]}, {'a': [{'b': {'c': [5, 15]}, 'new_field': [5, 15]}]}]), dict(testcase_name='scalar_scalar_scalar_repeated', st={'a': {'b': {'c': [7, 3, 5]}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': [7, 3, 5]}, 'new_field': [7, 3, 5]}}), dict(testcase_name='repeated_repeated_scalar_repeated2', st=[{'a': [{'b': {'c': [[7, 3], [17]]}}, {'b': {'c': [[3, 13]]}}]}, {'a': [{'b': {'c': [[5, 15]]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [[7, 3], [17]]}, 'new_field': [[7, 3], [17]]}, {'b': {'c': [[3, 13]]}, 'new_field': [[3, 13]]}]}, {'a': [{'b': {'c': [[5, 15]]}, 'new_field': [[5, 15]]}]}]), dict(testcase_name='example_4_promote_of_labeled_vector', st=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}]}], source_path=('user_info', 'gaia_id'), new_field_name='user_info_gaia_id', expected=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}], 'user_info_gaia_id': [{'vec': [0, 1, 2]}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}], 'user_info_gaia_id': [{'vec': [3, 4, 5]}]}]), dict(testcase_name='promote_structure', st=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}]}]}, {'a': [{'aa': [{'b': {'c': 12}}]}]}], source_path=('a', 'aa', 'b'), new_field_name='new_field', expected=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}], 'new_field': [{'c': 1}, {'c': 8}]}]}, {'a': [{'aa': [{'b': {'c': 12}}], 'new_field': [{'c': 12}]}]}])])\ndef testPromote(self, st, source_path, new_field_name, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st2 = StructuredTensor.from_pyval(st)\n    expected2 = StructuredTensor.from_pyval(expected)\n    result = st2.promote(source_path, new_field_name)\n    self.assertAllEqual(result, expected2)",
            "@parameterized.named_parameters([dict(testcase_name='scalar_scalar_scalar', st={'b': {'a': 5}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': 5}, 'new_field': 5}), dict(testcase_name='scalar_scalar_repeated', st={'b': {'a': [5, 3]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [5, 3]}, 'new_field': [5, 3]}), dict(testcase_name='scalar_scalar_repeated2', st={'b': {'a': [[7], [5, 3]]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [[7], [5, 3]]}, 'new_field': [[7], [5, 3]]}), dict(testcase_name='repeated_scalar_repeated', st=[{'b': {'a': [7]}}, {'b': {'a': [5, 3]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [7]}, 'new_field': [7]}, {'b': {'a': [5, 3]}, 'new_field': [5, 3]}]), dict(testcase_name='repeated_scalar_repeated2', st=[{'b': {'a': [[5, 7], []]}}, {'b': {'a': [[5, 1], [3]]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [[5, 7], []]}, 'new_field': [[5, 7], []]}, {'b': {'a': [[5, 1], [3]]}, 'new_field': [[5, 1], [3]]}]), dict(testcase_name='scalar_scalar_scalar_scalar', st={'a': {'b': {'c': 7}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': 7}, 'new_field': 7}}), dict(testcase_name='repeated_scalar_scalar_scalar', st=[{'a': {'b': {'c': 7}}}, {'a': {'b': {'c': 5}}}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': {'b': {'c': 7}, 'new_field': 7}}, {'a': {'b': {'c': 5}, 'new_field': 5}}]), dict(testcase_name='repeated_repeated_scalar_scalar', st=[{'a': [{'b': {'c': 7}}, {'b': {'c': 3}}]}, {'a': [{'b': {'c': 5}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': 7}, 'new_field': 7}, {'b': {'c': 3}, 'new_field': 3}]}, {'a': [{'b': {'c': 5}, 'new_field': 5}]}]), dict(testcase_name='docs_tokens', st=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}]}, {'docs': [{'tokens': [5, 15]}]}], source_path=('docs', 'tokens'), new_field_name='docs_tokens', expected=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}], 'docs_tokens': [7, 17, 3, 13]}, {'docs': [{'tokens': [5, 15]}], 'docs_tokens': [5, 15]}]), dict(testcase_name='repeated_repeated_scalar_repeated', st=[{'a': [{'b': {'c': [7, 17]}}, {'b': {'c': [3, 13]}}]}, {'a': [{'b': {'c': [5, 15]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [7, 17]}, 'new_field': [7, 17]}, {'b': {'c': [3, 13]}, 'new_field': [3, 13]}]}, {'a': [{'b': {'c': [5, 15]}, 'new_field': [5, 15]}]}]), dict(testcase_name='scalar_scalar_scalar_repeated', st={'a': {'b': {'c': [7, 3, 5]}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': [7, 3, 5]}, 'new_field': [7, 3, 5]}}), dict(testcase_name='repeated_repeated_scalar_repeated2', st=[{'a': [{'b': {'c': [[7, 3], [17]]}}, {'b': {'c': [[3, 13]]}}]}, {'a': [{'b': {'c': [[5, 15]]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [[7, 3], [17]]}, 'new_field': [[7, 3], [17]]}, {'b': {'c': [[3, 13]]}, 'new_field': [[3, 13]]}]}, {'a': [{'b': {'c': [[5, 15]]}, 'new_field': [[5, 15]]}]}]), dict(testcase_name='example_4_promote_of_labeled_vector', st=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}]}], source_path=('user_info', 'gaia_id'), new_field_name='user_info_gaia_id', expected=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}], 'user_info_gaia_id': [{'vec': [0, 1, 2]}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}], 'user_info_gaia_id': [{'vec': [3, 4, 5]}]}]), dict(testcase_name='promote_structure', st=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}]}]}, {'a': [{'aa': [{'b': {'c': 12}}]}]}], source_path=('a', 'aa', 'b'), new_field_name='new_field', expected=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}], 'new_field': [{'c': 1}, {'c': 8}]}]}, {'a': [{'aa': [{'b': {'c': 12}}], 'new_field': [{'c': 12}]}]}])])\ndef testPromote(self, st, source_path, new_field_name, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st2 = StructuredTensor.from_pyval(st)\n    expected2 = StructuredTensor.from_pyval(expected)\n    result = st2.promote(source_path, new_field_name)\n    self.assertAllEqual(result, expected2)",
            "@parameterized.named_parameters([dict(testcase_name='scalar_scalar_scalar', st={'b': {'a': 5}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': 5}, 'new_field': 5}), dict(testcase_name='scalar_scalar_repeated', st={'b': {'a': [5, 3]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [5, 3]}, 'new_field': [5, 3]}), dict(testcase_name='scalar_scalar_repeated2', st={'b': {'a': [[7], [5, 3]]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [[7], [5, 3]]}, 'new_field': [[7], [5, 3]]}), dict(testcase_name='repeated_scalar_repeated', st=[{'b': {'a': [7]}}, {'b': {'a': [5, 3]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [7]}, 'new_field': [7]}, {'b': {'a': [5, 3]}, 'new_field': [5, 3]}]), dict(testcase_name='repeated_scalar_repeated2', st=[{'b': {'a': [[5, 7], []]}}, {'b': {'a': [[5, 1], [3]]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [[5, 7], []]}, 'new_field': [[5, 7], []]}, {'b': {'a': [[5, 1], [3]]}, 'new_field': [[5, 1], [3]]}]), dict(testcase_name='scalar_scalar_scalar_scalar', st={'a': {'b': {'c': 7}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': 7}, 'new_field': 7}}), dict(testcase_name='repeated_scalar_scalar_scalar', st=[{'a': {'b': {'c': 7}}}, {'a': {'b': {'c': 5}}}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': {'b': {'c': 7}, 'new_field': 7}}, {'a': {'b': {'c': 5}, 'new_field': 5}}]), dict(testcase_name='repeated_repeated_scalar_scalar', st=[{'a': [{'b': {'c': 7}}, {'b': {'c': 3}}]}, {'a': [{'b': {'c': 5}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': 7}, 'new_field': 7}, {'b': {'c': 3}, 'new_field': 3}]}, {'a': [{'b': {'c': 5}, 'new_field': 5}]}]), dict(testcase_name='docs_tokens', st=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}]}, {'docs': [{'tokens': [5, 15]}]}], source_path=('docs', 'tokens'), new_field_name='docs_tokens', expected=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}], 'docs_tokens': [7, 17, 3, 13]}, {'docs': [{'tokens': [5, 15]}], 'docs_tokens': [5, 15]}]), dict(testcase_name='repeated_repeated_scalar_repeated', st=[{'a': [{'b': {'c': [7, 17]}}, {'b': {'c': [3, 13]}}]}, {'a': [{'b': {'c': [5, 15]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [7, 17]}, 'new_field': [7, 17]}, {'b': {'c': [3, 13]}, 'new_field': [3, 13]}]}, {'a': [{'b': {'c': [5, 15]}, 'new_field': [5, 15]}]}]), dict(testcase_name='scalar_scalar_scalar_repeated', st={'a': {'b': {'c': [7, 3, 5]}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': [7, 3, 5]}, 'new_field': [7, 3, 5]}}), dict(testcase_name='repeated_repeated_scalar_repeated2', st=[{'a': [{'b': {'c': [[7, 3], [17]]}}, {'b': {'c': [[3, 13]]}}]}, {'a': [{'b': {'c': [[5, 15]]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [[7, 3], [17]]}, 'new_field': [[7, 3], [17]]}, {'b': {'c': [[3, 13]]}, 'new_field': [[3, 13]]}]}, {'a': [{'b': {'c': [[5, 15]]}, 'new_field': [[5, 15]]}]}]), dict(testcase_name='example_4_promote_of_labeled_vector', st=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}]}], source_path=('user_info', 'gaia_id'), new_field_name='user_info_gaia_id', expected=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}], 'user_info_gaia_id': [{'vec': [0, 1, 2]}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}], 'user_info_gaia_id': [{'vec': [3, 4, 5]}]}]), dict(testcase_name='promote_structure', st=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}]}]}, {'a': [{'aa': [{'b': {'c': 12}}]}]}], source_path=('a', 'aa', 'b'), new_field_name='new_field', expected=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}], 'new_field': [{'c': 1}, {'c': 8}]}]}, {'a': [{'aa': [{'b': {'c': 12}}], 'new_field': [{'c': 12}]}]}])])\ndef testPromote(self, st, source_path, new_field_name, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st2 = StructuredTensor.from_pyval(st)\n    expected2 = StructuredTensor.from_pyval(expected)\n    result = st2.promote(source_path, new_field_name)\n    self.assertAllEqual(result, expected2)",
            "@parameterized.named_parameters([dict(testcase_name='scalar_scalar_scalar', st={'b': {'a': 5}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': 5}, 'new_field': 5}), dict(testcase_name='scalar_scalar_repeated', st={'b': {'a': [5, 3]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [5, 3]}, 'new_field': [5, 3]}), dict(testcase_name='scalar_scalar_repeated2', st={'b': {'a': [[7], [5, 3]]}}, source_path=('b', 'a'), new_field_name='new_field', expected={'b': {'a': [[7], [5, 3]]}, 'new_field': [[7], [5, 3]]}), dict(testcase_name='repeated_scalar_repeated', st=[{'b': {'a': [7]}}, {'b': {'a': [5, 3]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [7]}, 'new_field': [7]}, {'b': {'a': [5, 3]}, 'new_field': [5, 3]}]), dict(testcase_name='repeated_scalar_repeated2', st=[{'b': {'a': [[5, 7], []]}}, {'b': {'a': [[5, 1], [3]]}}], source_path=('b', 'a'), new_field_name='new_field', expected=[{'b': {'a': [[5, 7], []]}, 'new_field': [[5, 7], []]}, {'b': {'a': [[5, 1], [3]]}, 'new_field': [[5, 1], [3]]}]), dict(testcase_name='scalar_scalar_scalar_scalar', st={'a': {'b': {'c': 7}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': 7}, 'new_field': 7}}), dict(testcase_name='repeated_scalar_scalar_scalar', st=[{'a': {'b': {'c': 7}}}, {'a': {'b': {'c': 5}}}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': {'b': {'c': 7}, 'new_field': 7}}, {'a': {'b': {'c': 5}, 'new_field': 5}}]), dict(testcase_name='repeated_repeated_scalar_scalar', st=[{'a': [{'b': {'c': 7}}, {'b': {'c': 3}}]}, {'a': [{'b': {'c': 5}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': 7}, 'new_field': 7}, {'b': {'c': 3}, 'new_field': 3}]}, {'a': [{'b': {'c': 5}, 'new_field': 5}]}]), dict(testcase_name='docs_tokens', st=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}]}, {'docs': [{'tokens': [5, 15]}]}], source_path=('docs', 'tokens'), new_field_name='docs_tokens', expected=[{'docs': [{'tokens': [7, 17]}, {'tokens': [3, 13]}], 'docs_tokens': [7, 17, 3, 13]}, {'docs': [{'tokens': [5, 15]}], 'docs_tokens': [5, 15]}]), dict(testcase_name='repeated_repeated_scalar_repeated', st=[{'a': [{'b': {'c': [7, 17]}}, {'b': {'c': [3, 13]}}]}, {'a': [{'b': {'c': [5, 15]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [7, 17]}, 'new_field': [7, 17]}, {'b': {'c': [3, 13]}, 'new_field': [3, 13]}]}, {'a': [{'b': {'c': [5, 15]}, 'new_field': [5, 15]}]}]), dict(testcase_name='scalar_scalar_scalar_repeated', st={'a': {'b': {'c': [7, 3, 5]}}}, source_path=('a', 'b', 'c'), new_field_name='new_field', expected={'a': {'b': {'c': [7, 3, 5]}, 'new_field': [7, 3, 5]}}), dict(testcase_name='repeated_repeated_scalar_repeated2', st=[{'a': [{'b': {'c': [[7, 3], [17]]}}, {'b': {'c': [[3, 13]]}}]}, {'a': [{'b': {'c': [[5, 15]]}}]}], source_path=('a', 'b', 'c'), new_field_name='new_field', expected=[{'a': [{'b': {'c': [[7, 3], [17]]}, 'new_field': [[7, 3], [17]]}, {'b': {'c': [[3, 13]]}, 'new_field': [[3, 13]]}]}, {'a': [{'b': {'c': [[5, 15]]}, 'new_field': [[5, 15]]}]}]), dict(testcase_name='example_4_promote_of_labeled_vector', st=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}]}], source_path=('user_info', 'gaia_id'), new_field_name='user_info_gaia_id', expected=[{'user_info': [{'gaia_id': {'vec': [0, 1, 2]}}], 'user_info_gaia_id': [{'vec': [0, 1, 2]}]}, {'user_info': [{'gaia_id': {'vec': [3, 4, 5]}}], 'user_info_gaia_id': [{'vec': [3, 4, 5]}]}]), dict(testcase_name='promote_structure', st=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}]}]}, {'a': [{'aa': [{'b': {'c': 12}}]}]}], source_path=('a', 'aa', 'b'), new_field_name='new_field', expected=[{'a': [{'aa': [{'b': {'c': 1}}, {'b': {'c': 8}}], 'new_field': [{'c': 1}, {'c': 8}]}]}, {'a': [{'aa': [{'b': {'c': 12}}], 'new_field': [{'c': 12}]}]}])])\ndef testPromote(self, st, source_path, new_field_name, expected):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st2 = StructuredTensor.from_pyval(st)\n    expected2 = StructuredTensor.from_pyval(expected)\n    result = st2.promote(source_path, new_field_name)\n    self.assertAllEqual(result, expected2)"
        ]
    },
    {
        "func_name": "testPromoteDense",
        "original": "def testPromoteDense(self):\n    st = StructuredTensor.from_fields({'a': StructuredTensor.from_fields({'b': [[[1, 11], [2, 12]], [[3, 13], [4, 14]]]}, shape=[2, 2, 2])}, shape=[2])\n    result = st.promote(('a', 'b'), 'new_field')\n    self.assertEqual(st.rank, 1)\n    self.assertEqual(st.field_value('a').rank, 3)\n    self.assertAllEqual(result.field_value('new_field'), [[1, 11, 2, 12], [3, 13, 4, 14]])",
        "mutated": [
            "def testPromoteDense(self):\n    if False:\n        i = 10\n    st = StructuredTensor.from_fields({'a': StructuredTensor.from_fields({'b': [[[1, 11], [2, 12]], [[3, 13], [4, 14]]]}, shape=[2, 2, 2])}, shape=[2])\n    result = st.promote(('a', 'b'), 'new_field')\n    self.assertEqual(st.rank, 1)\n    self.assertEqual(st.field_value('a').rank, 3)\n    self.assertAllEqual(result.field_value('new_field'), [[1, 11, 2, 12], [3, 13, 4, 14]])",
            "def testPromoteDense(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st = StructuredTensor.from_fields({'a': StructuredTensor.from_fields({'b': [[[1, 11], [2, 12]], [[3, 13], [4, 14]]]}, shape=[2, 2, 2])}, shape=[2])\n    result = st.promote(('a', 'b'), 'new_field')\n    self.assertEqual(st.rank, 1)\n    self.assertEqual(st.field_value('a').rank, 3)\n    self.assertAllEqual(result.field_value('new_field'), [[1, 11, 2, 12], [3, 13, 4, 14]])",
            "def testPromoteDense(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st = StructuredTensor.from_fields({'a': StructuredTensor.from_fields({'b': [[[1, 11], [2, 12]], [[3, 13], [4, 14]]]}, shape=[2, 2, 2])}, shape=[2])\n    result = st.promote(('a', 'b'), 'new_field')\n    self.assertEqual(st.rank, 1)\n    self.assertEqual(st.field_value('a').rank, 3)\n    self.assertAllEqual(result.field_value('new_field'), [[1, 11, 2, 12], [3, 13, 4, 14]])",
            "def testPromoteDense(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st = StructuredTensor.from_fields({'a': StructuredTensor.from_fields({'b': [[[1, 11], [2, 12]], [[3, 13], [4, 14]]]}, shape=[2, 2, 2])}, shape=[2])\n    result = st.promote(('a', 'b'), 'new_field')\n    self.assertEqual(st.rank, 1)\n    self.assertEqual(st.field_value('a').rank, 3)\n    self.assertAllEqual(result.field_value('new_field'), [[1, 11, 2, 12], [3, 13, 4, 14]])",
            "def testPromoteDense(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st = StructuredTensor.from_fields({'a': StructuredTensor.from_fields({'b': [[[1, 11], [2, 12]], [[3, 13], [4, 14]]]}, shape=[2, 2, 2])}, shape=[2])\n    result = st.promote(('a', 'b'), 'new_field')\n    self.assertEqual(st.rank, 1)\n    self.assertEqual(st.field_value('a').rank, 3)\n    self.assertAllEqual(result.field_value('new_field'), [[1, 11, 2, 12], [3, 13, 4, 14]])"
        ]
    },
    {
        "func_name": "testMergeDimsGeneric",
        "original": "def testMergeDimsGeneric(self):\n    \"\"\"This is an example of a dense tensor being merged, when outer=rank.\n\n    Note that outer=rank is equivalent to outer=rank - 1. And yet, from the\n    perspective of promote, it is nice to be able to have this functionality\n    directly available, because sometimes the rank of the parent equals the\n    rank of the child.\n\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\n    accept this as a valid argument.\n\n    Note: _merge_dims_generic is private, but these unit tests help to\n    discuss the proper API definition.\n    \"\"\"\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 1, 3)\n    self.assertAllEqual(t2, [[1, 11, 2, 12], [3, 13, 4, 14]])",
        "mutated": [
            "def testMergeDimsGeneric(self):\n    if False:\n        i = 10\n    'This is an example of a dense tensor being merged, when outer=rank.\\n\\n    Note that outer=rank is equivalent to outer=rank - 1. And yet, from the\\n    perspective of promote, it is nice to be able to have this functionality\\n    directly available, because sometimes the rank of the parent equals the\\n    rank of the child.\\n\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument.\\n\\n    Note: _merge_dims_generic is private, but these unit tests help to\\n    discuss the proper API definition.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 1, 3)\n    self.assertAllEqual(t2, [[1, 11, 2, 12], [3, 13, 4, 14]])",
            "def testMergeDimsGeneric(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'This is an example of a dense tensor being merged, when outer=rank.\\n\\n    Note that outer=rank is equivalent to outer=rank - 1. And yet, from the\\n    perspective of promote, it is nice to be able to have this functionality\\n    directly available, because sometimes the rank of the parent equals the\\n    rank of the child.\\n\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument.\\n\\n    Note: _merge_dims_generic is private, but these unit tests help to\\n    discuss the proper API definition.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 1, 3)\n    self.assertAllEqual(t2, [[1, 11, 2, 12], [3, 13, 4, 14]])",
            "def testMergeDimsGeneric(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'This is an example of a dense tensor being merged, when outer=rank.\\n\\n    Note that outer=rank is equivalent to outer=rank - 1. And yet, from the\\n    perspective of promote, it is nice to be able to have this functionality\\n    directly available, because sometimes the rank of the parent equals the\\n    rank of the child.\\n\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument.\\n\\n    Note: _merge_dims_generic is private, but these unit tests help to\\n    discuss the proper API definition.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 1, 3)\n    self.assertAllEqual(t2, [[1, 11, 2, 12], [3, 13, 4, 14]])",
            "def testMergeDimsGeneric(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'This is an example of a dense tensor being merged, when outer=rank.\\n\\n    Note that outer=rank is equivalent to outer=rank - 1. And yet, from the\\n    perspective of promote, it is nice to be able to have this functionality\\n    directly available, because sometimes the rank of the parent equals the\\n    rank of the child.\\n\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument.\\n\\n    Note: _merge_dims_generic is private, but these unit tests help to\\n    discuss the proper API definition.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 1, 3)\n    self.assertAllEqual(t2, [[1, 11, 2, 12], [3, 13, 4, 14]])",
            "def testMergeDimsGeneric(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'This is an example of a dense tensor being merged, when outer=rank.\\n\\n    Note that outer=rank is equivalent to outer=rank - 1. And yet, from the\\n    perspective of promote, it is nice to be able to have this functionality\\n    directly available, because sometimes the rank of the parent equals the\\n    rank of the child.\\n\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument.\\n\\n    Note: _merge_dims_generic is private, but these unit tests help to\\n    discuss the proper API definition.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 1, 3)\n    self.assertAllEqual(t2, [[1, 11, 2, 12], [3, 13, 4, 14]])"
        ]
    },
    {
        "func_name": "testMergeDimsGenericNoop",
        "original": "def testMergeDimsGenericNoop(self):\n    \"\"\"This is an example of a dense tensor being merged, when outer=inner.\n\n    Sometimes, when promoting, the parent and grandparent ranks are equal.\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\n    accept this as a valid argument. This should be aligned.\n    \"\"\"\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 2, 2)\n    self.assertAllEqual(t2, [[[1, 11], [2, 12]], [[3, 13], [4, 14]]])",
        "mutated": [
            "def testMergeDimsGenericNoop(self):\n    if False:\n        i = 10\n    'This is an example of a dense tensor being merged, when outer=inner.\\n\\n    Sometimes, when promoting, the parent and grandparent ranks are equal.\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument. This should be aligned.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 2, 2)\n    self.assertAllEqual(t2, [[[1, 11], [2, 12]], [[3, 13], [4, 14]]])",
            "def testMergeDimsGenericNoop(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'This is an example of a dense tensor being merged, when outer=inner.\\n\\n    Sometimes, when promoting, the parent and grandparent ranks are equal.\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument. This should be aligned.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 2, 2)\n    self.assertAllEqual(t2, [[[1, 11], [2, 12]], [[3, 13], [4, 14]]])",
            "def testMergeDimsGenericNoop(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'This is an example of a dense tensor being merged, when outer=inner.\\n\\n    Sometimes, when promoting, the parent and grandparent ranks are equal.\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument. This should be aligned.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 2, 2)\n    self.assertAllEqual(t2, [[[1, 11], [2, 12]], [[3, 13], [4, 14]]])",
            "def testMergeDimsGenericNoop(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'This is an example of a dense tensor being merged, when outer=inner.\\n\\n    Sometimes, when promoting, the parent and grandparent ranks are equal.\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument. This should be aligned.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 2, 2)\n    self.assertAllEqual(t2, [[[1, 11], [2, 12]], [[3, 13], [4, 14]]])",
            "def testMergeDimsGenericNoop(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'This is an example of a dense tensor being merged, when outer=inner.\\n\\n    Sometimes, when promoting, the parent and grandparent ranks are equal.\\n    Finally, note that merge_dims for Ragged and StructuredTensor would not\\n    accept this as a valid argument. This should be aligned.\\n    '\n    t = array_ops.constant([[[1, 11], [2, 12]], [[3, 13], [4, 14]]])\n    t2 = structured_tensor._merge_dims_generic(t, 2, 2)\n    self.assertAllEqual(t2, [[[1, 11], [2, 12]], [[3, 13], [4, 14]]])"
        ]
    },
    {
        "func_name": "testRepr",
        "original": "def testRepr(self):\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    if context.executing_eagerly():\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": tf.Tensor(5, shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": tf.Tensor([1 2 3], shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    else:\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": Tensor(\"Const:0\", shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": Tensor(\"RaggedConstant/Const:0\", shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    self.assertEqual(repr(st), expected)",
        "mutated": [
            "def testRepr(self):\n    if False:\n        i = 10\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    if context.executing_eagerly():\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": tf.Tensor(5, shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": tf.Tensor([1 2 3], shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    else:\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": Tensor(\"Const:0\", shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": Tensor(\"RaggedConstant/Const:0\", shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    self.assertEqual(repr(st), expected)",
            "def testRepr(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    if context.executing_eagerly():\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": tf.Tensor(5, shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": tf.Tensor([1 2 3], shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    else:\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": Tensor(\"Const:0\", shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": Tensor(\"RaggedConstant/Const:0\", shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    self.assertEqual(repr(st), expected)",
            "def testRepr(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    if context.executing_eagerly():\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": tf.Tensor(5, shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": tf.Tensor([1 2 3], shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    else:\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": Tensor(\"Const:0\", shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": Tensor(\"RaggedConstant/Const:0\", shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    self.assertEqual(repr(st), expected)",
            "def testRepr(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    if context.executing_eagerly():\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": tf.Tensor(5, shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": tf.Tensor([1 2 3], shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    else:\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": Tensor(\"Const:0\", shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": Tensor(\"RaggedConstant/Const:0\", shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    self.assertEqual(repr(st), expected)",
            "def testRepr(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st = StructuredTensor.from_pyval({'a': 5, 'b': {'c': [1, 2, 3]}})\n    if context.executing_eagerly():\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": tf.Tensor(5, shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": tf.Tensor([1 2 3], shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    else:\n        expected = textwrap.dedent('\\n          <StructuredTensor(\\n              fields={\\n                  \"a\": Tensor(\"Const:0\", shape=(), dtype=int32),\\n                  \"b\": <StructuredTensor(\\n                          fields={\\n                              \"c\": Tensor(\"RaggedConstant/Const:0\", shape=(3,), dtype=int32)},\\n                          shape=())>},\\n              shape=())>')[1:]\n    self.assertEqual(repr(st), expected)"
        ]
    },
    {
        "func_name": "testPartitionOuterDimension2DDenseField",
        "original": "def testPartitionOuterDimension2DDenseField(self):\n    struct = structured_tensor.StructuredTensor.from_fields(fields={'r': array_ops.constant([[1, 2], [3, 4]])}, shape=[2])\n    result = struct.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(2, 2))\n    r = result.field_value('r')\n    self.assertAllEqual(r, [[[1, 2], [3, 4]]])",
        "mutated": [
            "def testPartitionOuterDimension2DDenseField(self):\n    if False:\n        i = 10\n    struct = structured_tensor.StructuredTensor.from_fields(fields={'r': array_ops.constant([[1, 2], [3, 4]])}, shape=[2])\n    result = struct.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(2, 2))\n    r = result.field_value('r')\n    self.assertAllEqual(r, [[[1, 2], [3, 4]]])",
            "def testPartitionOuterDimension2DDenseField(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    struct = structured_tensor.StructuredTensor.from_fields(fields={'r': array_ops.constant([[1, 2], [3, 4]])}, shape=[2])\n    result = struct.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(2, 2))\n    r = result.field_value('r')\n    self.assertAllEqual(r, [[[1, 2], [3, 4]]])",
            "def testPartitionOuterDimension2DDenseField(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    struct = structured_tensor.StructuredTensor.from_fields(fields={'r': array_ops.constant([[1, 2], [3, 4]])}, shape=[2])\n    result = struct.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(2, 2))\n    r = result.field_value('r')\n    self.assertAllEqual(r, [[[1, 2], [3, 4]]])",
            "def testPartitionOuterDimension2DDenseField(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    struct = structured_tensor.StructuredTensor.from_fields(fields={'r': array_ops.constant([[1, 2], [3, 4]])}, shape=[2])\n    result = struct.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(2, 2))\n    r = result.field_value('r')\n    self.assertAllEqual(r, [[[1, 2], [3, 4]]])",
            "def testPartitionOuterDimension2DDenseField(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    struct = structured_tensor.StructuredTensor.from_fields(fields={'r': array_ops.constant([[1, 2], [3, 4]])}, shape=[2])\n    result = struct.partition_outer_dimension(row_partition.RowPartition.from_uniform_row_length(2, 2))\n    r = result.field_value('r')\n    self.assertAllEqual(r, [[[1, 2], [3, 4]]])"
        ]
    },
    {
        "func_name": "testWithUpdatesValues",
        "original": "@parameterized.parameters([({'a': 12, 'b': 23}, {'a': 7}), ({'a': 12}, {('b',): 13}), ({'a': 12, 'b': {'c': 23}}, {('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23}}, {'a': 3, ('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'd', 'e'): 13}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'f'): 13}), ({'a': 5}, {'a': ragged_factory_ops.constant_value([[51, 52], [61, 62, 63]])}), ({'c': {'a': [5, 3], 'b': 2}}, {('c', 'a'): 5}), ([{'a': 5}, {'a': 6}], {'a': [15, 16], 'b': np.array([0.9, 1.1])}), ([[{'a': [5]}], [{'a': [3, 4]}, {'a': [8]}]], {'a': ragged_factory_ops.constant_value([[[50, 60]], [[30], []]])})])\ndef testWithUpdatesValues(self, pyval, updates):\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates(updates, validate=False)\n    for (key, value) in updates.items():\n        got = updated_st.field_value(key)\n        self.assertAllEqual(value, got, 'Update failed: key={}, value={}, got={}'.format(key, value, got))",
        "mutated": [
            "@parameterized.parameters([({'a': 12, 'b': 23}, {'a': 7}), ({'a': 12}, {('b',): 13}), ({'a': 12, 'b': {'c': 23}}, {('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23}}, {'a': 3, ('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'd', 'e'): 13}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'f'): 13}), ({'a': 5}, {'a': ragged_factory_ops.constant_value([[51, 52], [61, 62, 63]])}), ({'c': {'a': [5, 3], 'b': 2}}, {('c', 'a'): 5}), ([{'a': 5}, {'a': 6}], {'a': [15, 16], 'b': np.array([0.9, 1.1])}), ([[{'a': [5]}], [{'a': [3, 4]}, {'a': [8]}]], {'a': ragged_factory_ops.constant_value([[[50, 60]], [[30], []]])})])\ndef testWithUpdatesValues(self, pyval, updates):\n    if False:\n        i = 10\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates(updates, validate=False)\n    for (key, value) in updates.items():\n        got = updated_st.field_value(key)\n        self.assertAllEqual(value, got, 'Update failed: key={}, value={}, got={}'.format(key, value, got))",
            "@parameterized.parameters([({'a': 12, 'b': 23}, {'a': 7}), ({'a': 12}, {('b',): 13}), ({'a': 12, 'b': {'c': 23}}, {('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23}}, {'a': 3, ('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'd', 'e'): 13}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'f'): 13}), ({'a': 5}, {'a': ragged_factory_ops.constant_value([[51, 52], [61, 62, 63]])}), ({'c': {'a': [5, 3], 'b': 2}}, {('c', 'a'): 5}), ([{'a': 5}, {'a': 6}], {'a': [15, 16], 'b': np.array([0.9, 1.1])}), ([[{'a': [5]}], [{'a': [3, 4]}, {'a': [8]}]], {'a': ragged_factory_ops.constant_value([[[50, 60]], [[30], []]])})])\ndef testWithUpdatesValues(self, pyval, updates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates(updates, validate=False)\n    for (key, value) in updates.items():\n        got = updated_st.field_value(key)\n        self.assertAllEqual(value, got, 'Update failed: key={}, value={}, got={}'.format(key, value, got))",
            "@parameterized.parameters([({'a': 12, 'b': 23}, {'a': 7}), ({'a': 12}, {('b',): 13}), ({'a': 12, 'b': {'c': 23}}, {('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23}}, {'a': 3, ('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'd', 'e'): 13}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'f'): 13}), ({'a': 5}, {'a': ragged_factory_ops.constant_value([[51, 52], [61, 62, 63]])}), ({'c': {'a': [5, 3], 'b': 2}}, {('c', 'a'): 5}), ([{'a': 5}, {'a': 6}], {'a': [15, 16], 'b': np.array([0.9, 1.1])}), ([[{'a': [5]}], [{'a': [3, 4]}, {'a': [8]}]], {'a': ragged_factory_ops.constant_value([[[50, 60]], [[30], []]])})])\ndef testWithUpdatesValues(self, pyval, updates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates(updates, validate=False)\n    for (key, value) in updates.items():\n        got = updated_st.field_value(key)\n        self.assertAllEqual(value, got, 'Update failed: key={}, value={}, got={}'.format(key, value, got))",
            "@parameterized.parameters([({'a': 12, 'b': 23}, {'a': 7}), ({'a': 12}, {('b',): 13}), ({'a': 12, 'b': {'c': 23}}, {('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23}}, {'a': 3, ('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'd', 'e'): 13}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'f'): 13}), ({'a': 5}, {'a': ragged_factory_ops.constant_value([[51, 52], [61, 62, 63]])}), ({'c': {'a': [5, 3], 'b': 2}}, {('c', 'a'): 5}), ([{'a': 5}, {'a': 6}], {'a': [15, 16], 'b': np.array([0.9, 1.1])}), ([[{'a': [5]}], [{'a': [3, 4]}, {'a': [8]}]], {'a': ragged_factory_ops.constant_value([[[50, 60]], [[30], []]])})])\ndef testWithUpdatesValues(self, pyval, updates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates(updates, validate=False)\n    for (key, value) in updates.items():\n        got = updated_st.field_value(key)\n        self.assertAllEqual(value, got, 'Update failed: key={}, value={}, got={}'.format(key, value, got))",
            "@parameterized.parameters([({'a': 12, 'b': 23}, {'a': 7}), ({'a': 12}, {('b',): 13}), ({'a': 12, 'b': {'c': 23}}, {('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23}}, {'a': 3, ('b', 'c'): 7}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'd', 'e'): 13}), ({'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}, {('b', 'c'): 7, ('b', 'f'): 13}), ({'a': 5}, {'a': ragged_factory_ops.constant_value([[51, 52], [61, 62, 63]])}), ({'c': {'a': [5, 3], 'b': 2}}, {('c', 'a'): 5}), ([{'a': 5}, {'a': 6}], {'a': [15, 16], 'b': np.array([0.9, 1.1])}), ([[{'a': [5]}], [{'a': [3, 4]}, {'a': [8]}]], {'a': ragged_factory_ops.constant_value([[[50, 60]], [[30], []]])})])\ndef testWithUpdatesValues(self, pyval, updates):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates(updates, validate=False)\n    for (key, value) in updates.items():\n        got = updated_st.field_value(key)\n        self.assertAllEqual(value, got, 'Update failed: key={}, value={}, got={}'.format(key, value, got))"
        ]
    },
    {
        "func_name": "testWithUpdatesFunctions",
        "original": "def testWithUpdatesFunctions(self):\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    st_updated = st.with_updates({'a': lambda x: x + 1, ('b', 'd', 'e'): lambda x: x + 7}, validate=True)\n    self.assertAllEqual(st_updated.field_value('a'), 13)\n    self.assertAllEqual(st_updated.field_value(('b', 'd', 'e')), 18)\n    self.assertAllEqual(st_updated.field_value(('b', 'c')), 23)",
        "mutated": [
            "def testWithUpdatesFunctions(self):\n    if False:\n        i = 10\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    st_updated = st.with_updates({'a': lambda x: x + 1, ('b', 'd', 'e'): lambda x: x + 7}, validate=True)\n    self.assertAllEqual(st_updated.field_value('a'), 13)\n    self.assertAllEqual(st_updated.field_value(('b', 'd', 'e')), 18)\n    self.assertAllEqual(st_updated.field_value(('b', 'c')), 23)",
            "def testWithUpdatesFunctions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    st_updated = st.with_updates({'a': lambda x: x + 1, ('b', 'd', 'e'): lambda x: x + 7}, validate=True)\n    self.assertAllEqual(st_updated.field_value('a'), 13)\n    self.assertAllEqual(st_updated.field_value(('b', 'd', 'e')), 18)\n    self.assertAllEqual(st_updated.field_value(('b', 'c')), 23)",
            "def testWithUpdatesFunctions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    st_updated = st.with_updates({'a': lambda x: x + 1, ('b', 'd', 'e'): lambda x: x + 7}, validate=True)\n    self.assertAllEqual(st_updated.field_value('a'), 13)\n    self.assertAllEqual(st_updated.field_value(('b', 'd', 'e')), 18)\n    self.assertAllEqual(st_updated.field_value(('b', 'c')), 23)",
            "def testWithUpdatesFunctions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    st_updated = st.with_updates({'a': lambda x: x + 1, ('b', 'd', 'e'): lambda x: x + 7}, validate=True)\n    self.assertAllEqual(st_updated.field_value('a'), 13)\n    self.assertAllEqual(st_updated.field_value(('b', 'd', 'e')), 18)\n    self.assertAllEqual(st_updated.field_value(('b', 'c')), 23)",
            "def testWithUpdatesFunctions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    st_updated = st.with_updates({'a': lambda x: x + 1, ('b', 'd', 'e'): lambda x: x + 7}, validate=True)\n    self.assertAllEqual(st_updated.field_value('a'), 13)\n    self.assertAllEqual(st_updated.field_value(('b', 'd', 'e')), 18)\n    self.assertAllEqual(st_updated.field_value(('b', 'c')), 23)"
        ]
    },
    {
        "func_name": "test_from_pyval_list_of_empty",
        "original": "def test_from_pyval_list_of_empty(self):\n    \"\"\"See b/183245576.\"\"\"\n    st = structured_tensor.StructuredTensor.from_pyval([{}])\n    self.assertAllEqual([1], st.shape.as_list())",
        "mutated": [
            "def test_from_pyval_list_of_empty(self):\n    if False:\n        i = 10\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}])\n    self.assertAllEqual([1], st.shape.as_list())",
            "def test_from_pyval_list_of_empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}])\n    self.assertAllEqual([1], st.shape.as_list())",
            "def test_from_pyval_list_of_empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}])\n    self.assertAllEqual([1], st.shape.as_list())",
            "def test_from_pyval_list_of_empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}])\n    self.assertAllEqual([1], st.shape.as_list())",
            "def test_from_pyval_list_of_empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}])\n    self.assertAllEqual([1], st.shape.as_list())"
        ]
    },
    {
        "func_name": "test_from_pyval_list_of_empty_three",
        "original": "def test_from_pyval_list_of_empty_three(self):\n    \"\"\"See b/183245576.\"\"\"\n    st = structured_tensor.StructuredTensor.from_pyval([{}, {}, {}])\n    self.assertAllEqual([3], st.shape.as_list())\n    self.assertEmpty(st.field_names())",
        "mutated": [
            "def test_from_pyval_list_of_empty_three(self):\n    if False:\n        i = 10\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}, {}, {}])\n    self.assertAllEqual([3], st.shape.as_list())\n    self.assertEmpty(st.field_names())",
            "def test_from_pyval_list_of_empty_three(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}, {}, {}])\n    self.assertAllEqual([3], st.shape.as_list())\n    self.assertEmpty(st.field_names())",
            "def test_from_pyval_list_of_empty_three(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}, {}, {}])\n    self.assertAllEqual([3], st.shape.as_list())\n    self.assertEmpty(st.field_names())",
            "def test_from_pyval_list_of_empty_three(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}, {}, {}])\n    self.assertAllEqual([3], st.shape.as_list())\n    self.assertEmpty(st.field_names())",
            "def test_from_pyval_list_of_empty_three(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([{}, {}, {}])\n    self.assertAllEqual([3], st.shape.as_list())\n    self.assertEmpty(st.field_names())"
        ]
    },
    {
        "func_name": "test_from_pyval_deep_list_of_empty",
        "original": "def test_from_pyval_deep_list_of_empty(self):\n    \"\"\"See b/183245576.\"\"\"\n    st = structured_tensor.StructuredTensor.from_pyval([[{'a': {}, 'b': [3, 4]}, {'a': {}, 'b': [5]}], [{'a': {}, 'b': [7, 8, 9]}]])\n    self.assertAllEqual(2, st.rank)\n    self.assertEqual(2, st.shape[0])\n    self.assertEmpty(st.field_value('a').field_names())",
        "mutated": [
            "def test_from_pyval_deep_list_of_empty(self):\n    if False:\n        i = 10\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([[{'a': {}, 'b': [3, 4]}, {'a': {}, 'b': [5]}], [{'a': {}, 'b': [7, 8, 9]}]])\n    self.assertAllEqual(2, st.rank)\n    self.assertEqual(2, st.shape[0])\n    self.assertEmpty(st.field_value('a').field_names())",
            "def test_from_pyval_deep_list_of_empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([[{'a': {}, 'b': [3, 4]}, {'a': {}, 'b': [5]}], [{'a': {}, 'b': [7, 8, 9]}]])\n    self.assertAllEqual(2, st.rank)\n    self.assertEqual(2, st.shape[0])\n    self.assertEmpty(st.field_value('a').field_names())",
            "def test_from_pyval_deep_list_of_empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([[{'a': {}, 'b': [3, 4]}, {'a': {}, 'b': [5]}], [{'a': {}, 'b': [7, 8, 9]}]])\n    self.assertAllEqual(2, st.rank)\n    self.assertEqual(2, st.shape[0])\n    self.assertEmpty(st.field_value('a').field_names())",
            "def test_from_pyval_deep_list_of_empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([[{'a': {}, 'b': [3, 4]}, {'a': {}, 'b': [5]}], [{'a': {}, 'b': [7, 8, 9]}]])\n    self.assertAllEqual(2, st.rank)\n    self.assertEqual(2, st.shape[0])\n    self.assertEmpty(st.field_value('a').field_names())",
            "def test_from_pyval_deep_list_of_empty(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'See b/183245576.'\n    st = structured_tensor.StructuredTensor.from_pyval([[{'a': {}, 'b': [3, 4]}, {'a': {}, 'b': [5]}], [{'a': {}, 'b': [7, 8, 9]}]])\n    self.assertAllEqual(2, st.rank)\n    self.assertEqual(2, st.shape[0])\n    self.assertEmpty(st.field_value('a').field_names())"
        ]
    },
    {
        "func_name": "testWithUpdatesChecks",
        "original": "def testWithUpdatesChecks(self):\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'x'\\\\).*is not set\"):\n        st.with_updates({('b', 'x', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'c'\\\\).*is not a `StructuredTensor`\"):\n        st.with_updates({('b', 'c', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot update.*\\\\('b', 'd', 'x'\\\\).*does not already exist\"):\n        st.with_updates({('b', 'd', 'x'): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({(): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({('b', ''): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, \"does not allow both parent and child nodes.*parent=\\\\('b'.*child=\\\\('b', 'd'\"):\n        st.with_updates({('b', 'd'): lambda x: x + 1, 'a': 3, 'b': 10})\n    with self.assertRaisesRegex(ValueError, \"`StructuredTensor.with_updates` failed for field \\\\('c',\\\\)\"):\n        st_with_shape = StructuredTensor.from_pyval([[{'c': {'a': 5, 'b': 2}}], [{'c': {'a': 3, 'b': 1}}, {'c': {'a': 8, 'b': 18}}]])\n        st_with_shape.with_updates({('c', 'a'): 3})",
        "mutated": [
            "def testWithUpdatesChecks(self):\n    if False:\n        i = 10\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'x'\\\\).*is not set\"):\n        st.with_updates({('b', 'x', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'c'\\\\).*is not a `StructuredTensor`\"):\n        st.with_updates({('b', 'c', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot update.*\\\\('b', 'd', 'x'\\\\).*does not already exist\"):\n        st.with_updates({('b', 'd', 'x'): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({(): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({('b', ''): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, \"does not allow both parent and child nodes.*parent=\\\\('b'.*child=\\\\('b', 'd'\"):\n        st.with_updates({('b', 'd'): lambda x: x + 1, 'a': 3, 'b': 10})\n    with self.assertRaisesRegex(ValueError, \"`StructuredTensor.with_updates` failed for field \\\\('c',\\\\)\"):\n        st_with_shape = StructuredTensor.from_pyval([[{'c': {'a': 5, 'b': 2}}], [{'c': {'a': 3, 'b': 1}}, {'c': {'a': 8, 'b': 18}}]])\n        st_with_shape.with_updates({('c', 'a'): 3})",
            "def testWithUpdatesChecks(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'x'\\\\).*is not set\"):\n        st.with_updates({('b', 'x', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'c'\\\\).*is not a `StructuredTensor`\"):\n        st.with_updates({('b', 'c', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot update.*\\\\('b', 'd', 'x'\\\\).*does not already exist\"):\n        st.with_updates({('b', 'd', 'x'): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({(): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({('b', ''): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, \"does not allow both parent and child nodes.*parent=\\\\('b'.*child=\\\\('b', 'd'\"):\n        st.with_updates({('b', 'd'): lambda x: x + 1, 'a': 3, 'b': 10})\n    with self.assertRaisesRegex(ValueError, \"`StructuredTensor.with_updates` failed for field \\\\('c',\\\\)\"):\n        st_with_shape = StructuredTensor.from_pyval([[{'c': {'a': 5, 'b': 2}}], [{'c': {'a': 3, 'b': 1}}, {'c': {'a': 8, 'b': 18}}]])\n        st_with_shape.with_updates({('c', 'a'): 3})",
            "def testWithUpdatesChecks(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'x'\\\\).*is not set\"):\n        st.with_updates({('b', 'x', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'c'\\\\).*is not a `StructuredTensor`\"):\n        st.with_updates({('b', 'c', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot update.*\\\\('b', 'd', 'x'\\\\).*does not already exist\"):\n        st.with_updates({('b', 'd', 'x'): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({(): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({('b', ''): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, \"does not allow both parent and child nodes.*parent=\\\\('b'.*child=\\\\('b', 'd'\"):\n        st.with_updates({('b', 'd'): lambda x: x + 1, 'a': 3, 'b': 10})\n    with self.assertRaisesRegex(ValueError, \"`StructuredTensor.with_updates` failed for field \\\\('c',\\\\)\"):\n        st_with_shape = StructuredTensor.from_pyval([[{'c': {'a': 5, 'b': 2}}], [{'c': {'a': 3, 'b': 1}}, {'c': {'a': 8, 'b': 18}}]])\n        st_with_shape.with_updates({('c', 'a'): 3})",
            "def testWithUpdatesChecks(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'x'\\\\).*is not set\"):\n        st.with_updates({('b', 'x', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'c'\\\\).*is not a `StructuredTensor`\"):\n        st.with_updates({('b', 'c', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot update.*\\\\('b', 'd', 'x'\\\\).*does not already exist\"):\n        st.with_updates({('b', 'd', 'x'): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({(): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({('b', ''): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, \"does not allow both parent and child nodes.*parent=\\\\('b'.*child=\\\\('b', 'd'\"):\n        st.with_updates({('b', 'd'): lambda x: x + 1, 'a': 3, 'b': 10})\n    with self.assertRaisesRegex(ValueError, \"`StructuredTensor.with_updates` failed for field \\\\('c',\\\\)\"):\n        st_with_shape = StructuredTensor.from_pyval([[{'c': {'a': 5, 'b': 2}}], [{'c': {'a': 3, 'b': 1}}, {'c': {'a': 8, 'b': 18}}]])\n        st_with_shape.with_updates({('c', 'a'): 3})",
            "def testWithUpdatesChecks(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'x'\\\\).*is not set\"):\n        st.with_updates({('b', 'x', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot create new sub-field.*\\\\('b', 'c'\\\\).*is not a `StructuredTensor`\"):\n        st.with_updates({('b', 'c', 'e'): 5})\n    with self.assertRaisesRegex(ValueError, \"cannot update.*\\\\('b', 'd', 'x'\\\\).*does not already exist\"):\n        st.with_updates({('b', 'd', 'x'): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({(): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, 'does not allow empty names'):\n        st.with_updates({('b', ''): lambda x: x + 1})\n    with self.assertRaisesRegex(ValueError, \"does not allow both parent and child nodes.*parent=\\\\('b'.*child=\\\\('b', 'd'\"):\n        st.with_updates({('b', 'd'): lambda x: x + 1, 'a': 3, 'b': 10})\n    with self.assertRaisesRegex(ValueError, \"`StructuredTensor.with_updates` failed for field \\\\('c',\\\\)\"):\n        st_with_shape = StructuredTensor.from_pyval([[{'c': {'a': 5, 'b': 2}}], [{'c': {'a': 3, 'b': 1}}, {'c': {'a': 8, 'b': 18}}]])\n        st_with_shape.with_updates({('c', 'a'): 3})"
        ]
    },
    {
        "func_name": "testWithUpdatesDelete",
        "original": "def testWithUpdatesDelete(self):\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates({('b', 'c'): None}, validate=True)\n    self.assertNotIn('c', updated_st.field_value('b').field_names())\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\('b', 'x'\\\\).*not present\"):\n        st.with_updates({('b', 'x'): None}, validate=True)\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\'x'.*not present\"):\n        st.with_updates({'x': None}, validate=False)\n    pyval = [[{'a': 1}, {'a': 2}], [{'a': 3}]]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertLen(st.row_partitions, 1)\n    self.assertAllEqual(st.nrows(), 2)\n    self.assertAllEqual(st.row_partitions[0].row_lengths(), [2, 1])\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertLen(updated_st.row_partitions, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    self.assertAllEqual(updated_st.row_partitions[0].row_lengths(), [2, 1])\n    pyval = [{'a': 1}, {'a': 2}]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 1)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    pyval = {'a': [0, 1]}\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 0)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 0)\n    self.assertFalse(updated_st.row_partitions)\n    self.assertIsNone(updated_st.nrows())",
        "mutated": [
            "def testWithUpdatesDelete(self):\n    if False:\n        i = 10\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates({('b', 'c'): None}, validate=True)\n    self.assertNotIn('c', updated_st.field_value('b').field_names())\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\('b', 'x'\\\\).*not present\"):\n        st.with_updates({('b', 'x'): None}, validate=True)\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\'x'.*not present\"):\n        st.with_updates({'x': None}, validate=False)\n    pyval = [[{'a': 1}, {'a': 2}], [{'a': 3}]]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertLen(st.row_partitions, 1)\n    self.assertAllEqual(st.nrows(), 2)\n    self.assertAllEqual(st.row_partitions[0].row_lengths(), [2, 1])\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertLen(updated_st.row_partitions, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    self.assertAllEqual(updated_st.row_partitions[0].row_lengths(), [2, 1])\n    pyval = [{'a': 1}, {'a': 2}]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 1)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    pyval = {'a': [0, 1]}\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 0)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 0)\n    self.assertFalse(updated_st.row_partitions)\n    self.assertIsNone(updated_st.nrows())",
            "def testWithUpdatesDelete(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates({('b', 'c'): None}, validate=True)\n    self.assertNotIn('c', updated_st.field_value('b').field_names())\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\('b', 'x'\\\\).*not present\"):\n        st.with_updates({('b', 'x'): None}, validate=True)\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\'x'.*not present\"):\n        st.with_updates({'x': None}, validate=False)\n    pyval = [[{'a': 1}, {'a': 2}], [{'a': 3}]]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertLen(st.row_partitions, 1)\n    self.assertAllEqual(st.nrows(), 2)\n    self.assertAllEqual(st.row_partitions[0].row_lengths(), [2, 1])\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertLen(updated_st.row_partitions, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    self.assertAllEqual(updated_st.row_partitions[0].row_lengths(), [2, 1])\n    pyval = [{'a': 1}, {'a': 2}]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 1)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    pyval = {'a': [0, 1]}\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 0)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 0)\n    self.assertFalse(updated_st.row_partitions)\n    self.assertIsNone(updated_st.nrows())",
            "def testWithUpdatesDelete(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates({('b', 'c'): None}, validate=True)\n    self.assertNotIn('c', updated_st.field_value('b').field_names())\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\('b', 'x'\\\\).*not present\"):\n        st.with_updates({('b', 'x'): None}, validate=True)\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\'x'.*not present\"):\n        st.with_updates({'x': None}, validate=False)\n    pyval = [[{'a': 1}, {'a': 2}], [{'a': 3}]]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertLen(st.row_partitions, 1)\n    self.assertAllEqual(st.nrows(), 2)\n    self.assertAllEqual(st.row_partitions[0].row_lengths(), [2, 1])\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertLen(updated_st.row_partitions, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    self.assertAllEqual(updated_st.row_partitions[0].row_lengths(), [2, 1])\n    pyval = [{'a': 1}, {'a': 2}]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 1)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    pyval = {'a': [0, 1]}\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 0)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 0)\n    self.assertFalse(updated_st.row_partitions)\n    self.assertIsNone(updated_st.nrows())",
            "def testWithUpdatesDelete(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates({('b', 'c'): None}, validate=True)\n    self.assertNotIn('c', updated_st.field_value('b').field_names())\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\('b', 'x'\\\\).*not present\"):\n        st.with_updates({('b', 'x'): None}, validate=True)\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\'x'.*not present\"):\n        st.with_updates({'x': None}, validate=False)\n    pyval = [[{'a': 1}, {'a': 2}], [{'a': 3}]]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertLen(st.row_partitions, 1)\n    self.assertAllEqual(st.nrows(), 2)\n    self.assertAllEqual(st.row_partitions[0].row_lengths(), [2, 1])\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertLen(updated_st.row_partitions, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    self.assertAllEqual(updated_st.row_partitions[0].row_lengths(), [2, 1])\n    pyval = [{'a': 1}, {'a': 2}]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 1)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    pyval = {'a': [0, 1]}\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 0)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 0)\n    self.assertFalse(updated_st.row_partitions)\n    self.assertIsNone(updated_st.nrows())",
            "def testWithUpdatesDelete(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pyval = {'a': 12, 'b': {'c': 23, 'd': {'e': 11}}}\n    st = StructuredTensor.from_pyval(pyval)\n    updated_st = st.with_updates({('b', 'c'): None}, validate=True)\n    self.assertNotIn('c', updated_st.field_value('b').field_names())\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\('b', 'x'\\\\).*not present\"):\n        st.with_updates({('b', 'x'): None}, validate=True)\n    with self.assertRaisesRegex(ValueError, \"cannot delete.*\\\\'x'.*not present\"):\n        st.with_updates({'x': None}, validate=False)\n    pyval = [[{'a': 1}, {'a': 2}], [{'a': 3}]]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertLen(st.row_partitions, 1)\n    self.assertAllEqual(st.nrows(), 2)\n    self.assertAllEqual(st.row_partitions[0].row_lengths(), [2, 1])\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertLen(updated_st.row_partitions, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    self.assertAllEqual(updated_st.row_partitions[0].row_lengths(), [2, 1])\n    pyval = [{'a': 1}, {'a': 2}]\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 1)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 1)\n    self.assertAllEqual(updated_st.nrows(), 2)\n    pyval = {'a': [0, 1]}\n    st = StructuredTensor.from_pyval(pyval)\n    self.assertEqual(st.rank, 0)\n    updated_st = st.with_updates({('a',): None}, validate=True)\n    self.assertEqual(updated_st.rank, 0)\n    self.assertFalse(updated_st.row_partitions)\n    self.assertIsNone(updated_st.nrows())"
        ]
    },
    {
        "func_name": "test_from_pyval_deep_row_partitions",
        "original": "def test_from_pyval_deep_row_partitions(self):\n    \"\"\"See b/179195750.\"\"\"\n    st = structured_tensor.StructuredTensor.from_pyval([{'foo': [{'bar': [{'baz': [b'FW']}]}]}])\n    st2 = st.field_value(('foo', 'bar'))\n    self.assertLen(st2.row_partitions, st2.rank - 1)",
        "mutated": [
            "def test_from_pyval_deep_row_partitions(self):\n    if False:\n        i = 10\n    'See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([{'foo': [{'bar': [{'baz': [b'FW']}]}]}])\n    st2 = st.field_value(('foo', 'bar'))\n    self.assertLen(st2.row_partitions, st2.rank - 1)",
            "def test_from_pyval_deep_row_partitions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([{'foo': [{'bar': [{'baz': [b'FW']}]}]}])\n    st2 = st.field_value(('foo', 'bar'))\n    self.assertLen(st2.row_partitions, st2.rank - 1)",
            "def test_from_pyval_deep_row_partitions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([{'foo': [{'bar': [{'baz': [b'FW']}]}]}])\n    st2 = st.field_value(('foo', 'bar'))\n    self.assertLen(st2.row_partitions, st2.rank - 1)",
            "def test_from_pyval_deep_row_partitions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([{'foo': [{'bar': [{'baz': [b'FW']}]}]}])\n    st2 = st.field_value(('foo', 'bar'))\n    self.assertLen(st2.row_partitions, st2.rank - 1)",
            "def test_from_pyval_deep_row_partitions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([{'foo': [{'bar': [{'baz': [b'FW']}]}]}])\n    st2 = st.field_value(('foo', 'bar'))\n    self.assertLen(st2.row_partitions, st2.rank - 1)"
        ]
    },
    {
        "func_name": "test_from_fields_deep_row_partitions",
        "original": "def test_from_fields_deep_row_partitions(self):\n    \"\"\"Test a field with its own row_partition. See b/179195750.\"\"\"\n    st = structured_tensor.StructuredTensor.from_pyval([[[{'baz': [b'FW']}]]])\n    self.assertLen(st.row_partitions, st.rank - 1)\n    st2 = structured_tensor.StructuredTensor.from_fields(fields={'bar': st}, shape=(None, None), validate=False)\n    st3 = st2.field_value('bar')\n    self.assertLen(st3.row_partitions, st3.rank - 1)",
        "mutated": [
            "def test_from_fields_deep_row_partitions(self):\n    if False:\n        i = 10\n    'Test a field with its own row_partition. See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([[[{'baz': [b'FW']}]]])\n    self.assertLen(st.row_partitions, st.rank - 1)\n    st2 = structured_tensor.StructuredTensor.from_fields(fields={'bar': st}, shape=(None, None), validate=False)\n    st3 = st2.field_value('bar')\n    self.assertLen(st3.row_partitions, st3.rank - 1)",
            "def test_from_fields_deep_row_partitions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test a field with its own row_partition. See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([[[{'baz': [b'FW']}]]])\n    self.assertLen(st.row_partitions, st.rank - 1)\n    st2 = structured_tensor.StructuredTensor.from_fields(fields={'bar': st}, shape=(None, None), validate=False)\n    st3 = st2.field_value('bar')\n    self.assertLen(st3.row_partitions, st3.rank - 1)",
            "def test_from_fields_deep_row_partitions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test a field with its own row_partition. See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([[[{'baz': [b'FW']}]]])\n    self.assertLen(st.row_partitions, st.rank - 1)\n    st2 = structured_tensor.StructuredTensor.from_fields(fields={'bar': st}, shape=(None, None), validate=False)\n    st3 = st2.field_value('bar')\n    self.assertLen(st3.row_partitions, st3.rank - 1)",
            "def test_from_fields_deep_row_partitions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test a field with its own row_partition. See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([[[{'baz': [b'FW']}]]])\n    self.assertLen(st.row_partitions, st.rank - 1)\n    st2 = structured_tensor.StructuredTensor.from_fields(fields={'bar': st}, shape=(None, None), validate=False)\n    st3 = st2.field_value('bar')\n    self.assertLen(st3.row_partitions, st3.rank - 1)",
            "def test_from_fields_deep_row_partitions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test a field with its own row_partition. See b/179195750.'\n    st = structured_tensor.StructuredTensor.from_pyval([[[{'baz': [b'FW']}]]])\n    self.assertLen(st.row_partitions, st.rank - 1)\n    st2 = structured_tensor.StructuredTensor.from_fields(fields={'bar': st}, shape=(None, None), validate=False)\n    st3 = st2.field_value('bar')\n    self.assertLen(st3.row_partitions, st3.rank - 1)"
        ]
    },
    {
        "func_name": "test_structured_tensor_spec_shape_property",
        "original": "def test_structured_tensor_spec_shape_property(self):\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 2], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [1, 2])\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[None], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [None])",
        "mutated": [
            "def test_structured_tensor_spec_shape_property(self):\n    if False:\n        i = 10\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 2], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [1, 2])\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[None], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [None])",
            "def test_structured_tensor_spec_shape_property(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 2], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [1, 2])\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[None], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [None])",
            "def test_structured_tensor_spec_shape_property(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 2], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [1, 2])\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[None], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [None])",
            "def test_structured_tensor_spec_shape_property(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 2], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [1, 2])\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[None], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [None])",
            "def test_structured_tensor_spec_shape_property(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[1, 2], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [1, 2])\n    spec = StructuredTensor.Spec._from_shape(DynamicRaggedShape.Spec(row_partitions=[], static_inner_shape=[None], dtype=dtypes.int64))\n    self.assertEqual(spec.shape.as_list(), [None])"
        ]
    },
    {
        "func_name": "test_dynamic_ragged_shape_init_vector",
        "original": "def test_dynamic_ragged_shape_init_vector(self):\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = constant_op.constant(4)\n    shape = tensor_shape.TensorShape((4,))\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((4,))))",
        "mutated": [
            "def test_dynamic_ragged_shape_init_vector(self):\n    if False:\n        i = 10\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = constant_op.constant(4)\n    shape = tensor_shape.TensorShape((4,))\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((4,))))",
            "def test_dynamic_ragged_shape_init_vector(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = constant_op.constant(4)\n    shape = tensor_shape.TensorShape((4,))\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((4,))))",
            "def test_dynamic_ragged_shape_init_vector(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = constant_op.constant(4)\n    shape = tensor_shape.TensorShape((4,))\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((4,))))",
            "def test_dynamic_ragged_shape_init_vector(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = constant_op.constant(4)\n    shape = tensor_shape.TensorShape((4,))\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((4,))))",
            "def test_dynamic_ragged_shape_init_vector(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = constant_op.constant(4)\n    shape = tensor_shape.TensorShape((4,))\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((4,))))"
        ]
    },
    {
        "func_name": "test_dynamic_ragged_shape_init_scalar",
        "original": "def test_dynamic_ragged_shape_init_scalar(self):\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = None\n    shape = tensor_shape.TensorShape(())\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape(())))",
        "mutated": [
            "def test_dynamic_ragged_shape_init_scalar(self):\n    if False:\n        i = 10\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = None\n    shape = tensor_shape.TensorShape(())\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape(())))",
            "def test_dynamic_ragged_shape_init_scalar(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = None\n    shape = tensor_shape.TensorShape(())\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape(())))",
            "def test_dynamic_ragged_shape_init_scalar(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = None\n    shape = tensor_shape.TensorShape(())\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape(())))",
            "def test_dynamic_ragged_shape_init_scalar(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = None\n    shape = tensor_shape.TensorShape(())\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape(())))",
            "def test_dynamic_ragged_shape_init_scalar(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = constant_op.constant([1, 2, 3, 4])\n    y = constant_op.constant([[1, 2], [3, 4], [5, 6], [7, 8]])\n    fields = {'x': x, 'y': y}\n    nrows = None\n    shape = tensor_shape.TensorShape(())\n    row_partitions = ()\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape(())))"
        ]
    },
    {
        "func_name": "test_dynamic_ragged_shape_init_ragged",
        "original": "def test_dynamic_ragged_shape_init_ragged(self):\n    x = ragged_factory_ops.constant_value([[1, 2, 3], [4]])\n    fields = {'x': x}\n    nrows = constant_op.constant(2, dtype=dtypes.int64)\n    shape = tensor_shape.TensorShape([2, None])\n    row_partitions = tuple(x._nested_row_partitions)\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((2, None))))",
        "mutated": [
            "def test_dynamic_ragged_shape_init_ragged(self):\n    if False:\n        i = 10\n    x = ragged_factory_ops.constant_value([[1, 2, 3], [4]])\n    fields = {'x': x}\n    nrows = constant_op.constant(2, dtype=dtypes.int64)\n    shape = tensor_shape.TensorShape([2, None])\n    row_partitions = tuple(x._nested_row_partitions)\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((2, None))))",
            "def test_dynamic_ragged_shape_init_ragged(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = ragged_factory_ops.constant_value([[1, 2, 3], [4]])\n    fields = {'x': x}\n    nrows = constant_op.constant(2, dtype=dtypes.int64)\n    shape = tensor_shape.TensorShape([2, None])\n    row_partitions = tuple(x._nested_row_partitions)\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((2, None))))",
            "def test_dynamic_ragged_shape_init_ragged(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = ragged_factory_ops.constant_value([[1, 2, 3], [4]])\n    fields = {'x': x}\n    nrows = constant_op.constant(2, dtype=dtypes.int64)\n    shape = tensor_shape.TensorShape([2, None])\n    row_partitions = tuple(x._nested_row_partitions)\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((2, None))))",
            "def test_dynamic_ragged_shape_init_ragged(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = ragged_factory_ops.constant_value([[1, 2, 3], [4]])\n    fields = {'x': x}\n    nrows = constant_op.constant(2, dtype=dtypes.int64)\n    shape = tensor_shape.TensorShape([2, None])\n    row_partitions = tuple(x._nested_row_partitions)\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((2, None))))",
            "def test_dynamic_ragged_shape_init_ragged(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = ragged_factory_ops.constant_value([[1, 2, 3], [4]])\n    fields = {'x': x}\n    nrows = constant_op.constant(2, dtype=dtypes.int64)\n    shape = tensor_shape.TensorShape([2, None])\n    row_partitions = tuple(x._nested_row_partitions)\n    rs = structured_tensor_dynamic._dynamic_ragged_shape_init(fields, shape, nrows, row_partitions)\n    self.assertEqual(repr(rs._to_tensor_shape()), repr(tensor_shape.TensorShape((2, None))))"
        ]
    }
]