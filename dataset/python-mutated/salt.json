[
    {
        "func_name": "cmd",
        "original": "def cmd(fun, *args, **kwargs):\n    \"\"\"\n    .. versionchanged:: 2018.3.0\n        Added ``with_pillar`` argument\n\n    Execute ``fun`` with the given ``args`` and ``kwargs``.  Parameter ``fun``\n    should be the string :ref:`name <all-salt.modules>` of the execution module\n    to call.\n\n    .. note::\n        Execution modules will be loaded *every time* this function is called.\n        Additionally, keep in mind that since runners execute on the master,\n        custom execution modules will need to be synced to the master using\n        :py:func:`salt-run saltutil.sync_modules\n        <salt.runners.saltutil.sync_modules>`, otherwise they will not be\n        available.\n\n    with_pillar : False\n        If ``True``, pillar data will be compiled for the master\n\n        .. note::\n            To target the master in the pillar top file, keep in mind that the\n            default ``id`` for the master is ``<hostname>_master``. This can be\n            overridden by setting an ``id`` configuration parameter in the\n            master config file.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-run salt.cmd test.ping\n        # call functions with arguments and keyword arguments\n        salt-run salt.cmd test.arg 1 2 3 a=1\n        salt-run salt.cmd mymod.myfunc with_pillar=True\n    \"\"\"\n    log.debug('Called salt.cmd runner with minion function %s', fun)\n    kwargs = salt.utils.args.clean_kwargs(**kwargs)\n    with_pillar = kwargs.pop('with_pillar', False)\n    opts = copy.deepcopy(__opts__)\n    opts['grains'] = salt.loader.grains(opts)\n    if with_pillar:\n        opts['pillar'] = salt.pillar.get_pillar(opts, opts['grains'], opts['id'], saltenv=opts['saltenv'], pillarenv=opts.get('pillarenv')).compile_pillar()\n    else:\n        opts['pillar'] = {}\n    functions = salt.loader.minion_mods(opts, utils=salt.loader.utils(opts), context=__context__)\n    return functions[fun](*args, **kwargs) if fun in functions else \"'{}' is not available.\".format(fun)",
        "mutated": [
            "def cmd(fun, *args, **kwargs):\n    if False:\n        i = 10\n    '\\n    .. versionchanged:: 2018.3.0\\n        Added ``with_pillar`` argument\\n\\n    Execute ``fun`` with the given ``args`` and ``kwargs``.  Parameter ``fun``\\n    should be the string :ref:`name <all-salt.modules>` of the execution module\\n    to call.\\n\\n    .. note::\\n        Execution modules will be loaded *every time* this function is called.\\n        Additionally, keep in mind that since runners execute on the master,\\n        custom execution modules will need to be synced to the master using\\n        :py:func:`salt-run saltutil.sync_modules\\n        <salt.runners.saltutil.sync_modules>`, otherwise they will not be\\n        available.\\n\\n    with_pillar : False\\n        If ``True``, pillar data will be compiled for the master\\n\\n        .. note::\\n            To target the master in the pillar top file, keep in mind that the\\n            default ``id`` for the master is ``<hostname>_master``. This can be\\n            overridden by setting an ``id`` configuration parameter in the\\n            master config file.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run salt.cmd test.ping\\n        # call functions with arguments and keyword arguments\\n        salt-run salt.cmd test.arg 1 2 3 a=1\\n        salt-run salt.cmd mymod.myfunc with_pillar=True\\n    '\n    log.debug('Called salt.cmd runner with minion function %s', fun)\n    kwargs = salt.utils.args.clean_kwargs(**kwargs)\n    with_pillar = kwargs.pop('with_pillar', False)\n    opts = copy.deepcopy(__opts__)\n    opts['grains'] = salt.loader.grains(opts)\n    if with_pillar:\n        opts['pillar'] = salt.pillar.get_pillar(opts, opts['grains'], opts['id'], saltenv=opts['saltenv'], pillarenv=opts.get('pillarenv')).compile_pillar()\n    else:\n        opts['pillar'] = {}\n    functions = salt.loader.minion_mods(opts, utils=salt.loader.utils(opts), context=__context__)\n    return functions[fun](*args, **kwargs) if fun in functions else \"'{}' is not available.\".format(fun)",
            "def cmd(fun, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    .. versionchanged:: 2018.3.0\\n        Added ``with_pillar`` argument\\n\\n    Execute ``fun`` with the given ``args`` and ``kwargs``.  Parameter ``fun``\\n    should be the string :ref:`name <all-salt.modules>` of the execution module\\n    to call.\\n\\n    .. note::\\n        Execution modules will be loaded *every time* this function is called.\\n        Additionally, keep in mind that since runners execute on the master,\\n        custom execution modules will need to be synced to the master using\\n        :py:func:`salt-run saltutil.sync_modules\\n        <salt.runners.saltutil.sync_modules>`, otherwise they will not be\\n        available.\\n\\n    with_pillar : False\\n        If ``True``, pillar data will be compiled for the master\\n\\n        .. note::\\n            To target the master in the pillar top file, keep in mind that the\\n            default ``id`` for the master is ``<hostname>_master``. This can be\\n            overridden by setting an ``id`` configuration parameter in the\\n            master config file.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run salt.cmd test.ping\\n        # call functions with arguments and keyword arguments\\n        salt-run salt.cmd test.arg 1 2 3 a=1\\n        salt-run salt.cmd mymod.myfunc with_pillar=True\\n    '\n    log.debug('Called salt.cmd runner with minion function %s', fun)\n    kwargs = salt.utils.args.clean_kwargs(**kwargs)\n    with_pillar = kwargs.pop('with_pillar', False)\n    opts = copy.deepcopy(__opts__)\n    opts['grains'] = salt.loader.grains(opts)\n    if with_pillar:\n        opts['pillar'] = salt.pillar.get_pillar(opts, opts['grains'], opts['id'], saltenv=opts['saltenv'], pillarenv=opts.get('pillarenv')).compile_pillar()\n    else:\n        opts['pillar'] = {}\n    functions = salt.loader.minion_mods(opts, utils=salt.loader.utils(opts), context=__context__)\n    return functions[fun](*args, **kwargs) if fun in functions else \"'{}' is not available.\".format(fun)",
            "def cmd(fun, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    .. versionchanged:: 2018.3.0\\n        Added ``with_pillar`` argument\\n\\n    Execute ``fun`` with the given ``args`` and ``kwargs``.  Parameter ``fun``\\n    should be the string :ref:`name <all-salt.modules>` of the execution module\\n    to call.\\n\\n    .. note::\\n        Execution modules will be loaded *every time* this function is called.\\n        Additionally, keep in mind that since runners execute on the master,\\n        custom execution modules will need to be synced to the master using\\n        :py:func:`salt-run saltutil.sync_modules\\n        <salt.runners.saltutil.sync_modules>`, otherwise they will not be\\n        available.\\n\\n    with_pillar : False\\n        If ``True``, pillar data will be compiled for the master\\n\\n        .. note::\\n            To target the master in the pillar top file, keep in mind that the\\n            default ``id`` for the master is ``<hostname>_master``. This can be\\n            overridden by setting an ``id`` configuration parameter in the\\n            master config file.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run salt.cmd test.ping\\n        # call functions with arguments and keyword arguments\\n        salt-run salt.cmd test.arg 1 2 3 a=1\\n        salt-run salt.cmd mymod.myfunc with_pillar=True\\n    '\n    log.debug('Called salt.cmd runner with minion function %s', fun)\n    kwargs = salt.utils.args.clean_kwargs(**kwargs)\n    with_pillar = kwargs.pop('with_pillar', False)\n    opts = copy.deepcopy(__opts__)\n    opts['grains'] = salt.loader.grains(opts)\n    if with_pillar:\n        opts['pillar'] = salt.pillar.get_pillar(opts, opts['grains'], opts['id'], saltenv=opts['saltenv'], pillarenv=opts.get('pillarenv')).compile_pillar()\n    else:\n        opts['pillar'] = {}\n    functions = salt.loader.minion_mods(opts, utils=salt.loader.utils(opts), context=__context__)\n    return functions[fun](*args, **kwargs) if fun in functions else \"'{}' is not available.\".format(fun)",
            "def cmd(fun, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    .. versionchanged:: 2018.3.0\\n        Added ``with_pillar`` argument\\n\\n    Execute ``fun`` with the given ``args`` and ``kwargs``.  Parameter ``fun``\\n    should be the string :ref:`name <all-salt.modules>` of the execution module\\n    to call.\\n\\n    .. note::\\n        Execution modules will be loaded *every time* this function is called.\\n        Additionally, keep in mind that since runners execute on the master,\\n        custom execution modules will need to be synced to the master using\\n        :py:func:`salt-run saltutil.sync_modules\\n        <salt.runners.saltutil.sync_modules>`, otherwise they will not be\\n        available.\\n\\n    with_pillar : False\\n        If ``True``, pillar data will be compiled for the master\\n\\n        .. note::\\n            To target the master in the pillar top file, keep in mind that the\\n            default ``id`` for the master is ``<hostname>_master``. This can be\\n            overridden by setting an ``id`` configuration parameter in the\\n            master config file.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run salt.cmd test.ping\\n        # call functions with arguments and keyword arguments\\n        salt-run salt.cmd test.arg 1 2 3 a=1\\n        salt-run salt.cmd mymod.myfunc with_pillar=True\\n    '\n    log.debug('Called salt.cmd runner with minion function %s', fun)\n    kwargs = salt.utils.args.clean_kwargs(**kwargs)\n    with_pillar = kwargs.pop('with_pillar', False)\n    opts = copy.deepcopy(__opts__)\n    opts['grains'] = salt.loader.grains(opts)\n    if with_pillar:\n        opts['pillar'] = salt.pillar.get_pillar(opts, opts['grains'], opts['id'], saltenv=opts['saltenv'], pillarenv=opts.get('pillarenv')).compile_pillar()\n    else:\n        opts['pillar'] = {}\n    functions = salt.loader.minion_mods(opts, utils=salt.loader.utils(opts), context=__context__)\n    return functions[fun](*args, **kwargs) if fun in functions else \"'{}' is not available.\".format(fun)",
            "def cmd(fun, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    .. versionchanged:: 2018.3.0\\n        Added ``with_pillar`` argument\\n\\n    Execute ``fun`` with the given ``args`` and ``kwargs``.  Parameter ``fun``\\n    should be the string :ref:`name <all-salt.modules>` of the execution module\\n    to call.\\n\\n    .. note::\\n        Execution modules will be loaded *every time* this function is called.\\n        Additionally, keep in mind that since runners execute on the master,\\n        custom execution modules will need to be synced to the master using\\n        :py:func:`salt-run saltutil.sync_modules\\n        <salt.runners.saltutil.sync_modules>`, otherwise they will not be\\n        available.\\n\\n    with_pillar : False\\n        If ``True``, pillar data will be compiled for the master\\n\\n        .. note::\\n            To target the master in the pillar top file, keep in mind that the\\n            default ``id`` for the master is ``<hostname>_master``. This can be\\n            overridden by setting an ``id`` configuration parameter in the\\n            master config file.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt-run salt.cmd test.ping\\n        # call functions with arguments and keyword arguments\\n        salt-run salt.cmd test.arg 1 2 3 a=1\\n        salt-run salt.cmd mymod.myfunc with_pillar=True\\n    '\n    log.debug('Called salt.cmd runner with minion function %s', fun)\n    kwargs = salt.utils.args.clean_kwargs(**kwargs)\n    with_pillar = kwargs.pop('with_pillar', False)\n    opts = copy.deepcopy(__opts__)\n    opts['grains'] = salt.loader.grains(opts)\n    if with_pillar:\n        opts['pillar'] = salt.pillar.get_pillar(opts, opts['grains'], opts['id'], saltenv=opts['saltenv'], pillarenv=opts.get('pillarenv')).compile_pillar()\n    else:\n        opts['pillar'] = {}\n    functions = salt.loader.minion_mods(opts, utils=salt.loader.utils(opts), context=__context__)\n    return functions[fun](*args, **kwargs) if fun in functions else \"'{}' is not available.\".format(fun)"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(tgt, fun, arg=(), timeout=None, tgt_type='glob', ret='', jid='', kwarg=None, **kwargs):\n    \"\"\"\n    .. versionadded:: 2017.7.0\n\n    Execute ``fun`` on all minions matched by ``tgt`` and ``tgt_type``.\n    Parameter ``fun`` is the name of execution module function to call.\n\n    This function should mainly be used as a helper for runner modules,\n    in order to avoid redundant code.\n    For example, when inside a runner one needs to execute a certain function\n    on arbitrary groups of minions, only has to:\n\n    .. code-block:: python\n\n        ret1 = __salt__['salt.execute']('*', 'mod.fun')\n        ret2 = __salt__['salt.execute']('my_nodegroup', 'mod2.fun2', tgt_type='nodegroup')\n\n    It can also be used to schedule jobs directly on the master, for example:\n\n    .. code-block:: yaml\n\n        schedule:\n            collect_bgp_stats:\n                function: salt.execute\n                args:\n                    - edge-routers\n                    - bgp.neighbors\n                kwargs:\n                    tgt_type: nodegroup\n                days: 1\n                returner: redis\n    \"\"\"\n    with salt.client.get_local_client(__opts__['conf_file']) as client:\n        try:\n            return client.cmd(tgt, fun, arg=arg, timeout=timeout or __opts__['timeout'], tgt_type=tgt_type, ret=ret, jid=jid, kwarg=kwarg, **kwargs)\n        except SaltClientError as client_error:\n            log.error('Error while executing %s on %s (%s)', fun, tgt, tgt_type)\n            log.error(client_error)\n            return {}",
        "mutated": [
            "def execute(tgt, fun, arg=(), timeout=None, tgt_type='glob', ret='', jid='', kwarg=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Execute ``fun`` on all minions matched by ``tgt`` and ``tgt_type``.\\n    Parameter ``fun`` is the name of execution module function to call.\\n\\n    This function should mainly be used as a helper for runner modules,\\n    in order to avoid redundant code.\\n    For example, when inside a runner one needs to execute a certain function\\n    on arbitrary groups of minions, only has to:\\n\\n    .. code-block:: python\\n\\n        ret1 = __salt__['salt.execute']('*', 'mod.fun')\\n        ret2 = __salt__['salt.execute']('my_nodegroup', 'mod2.fun2', tgt_type='nodegroup')\\n\\n    It can also be used to schedule jobs directly on the master, for example:\\n\\n    .. code-block:: yaml\\n\\n        schedule:\\n            collect_bgp_stats:\\n                function: salt.execute\\n                args:\\n                    - edge-routers\\n                    - bgp.neighbors\\n                kwargs:\\n                    tgt_type: nodegroup\\n                days: 1\\n                returner: redis\\n    \"\n    with salt.client.get_local_client(__opts__['conf_file']) as client:\n        try:\n            return client.cmd(tgt, fun, arg=arg, timeout=timeout or __opts__['timeout'], tgt_type=tgt_type, ret=ret, jid=jid, kwarg=kwarg, **kwargs)\n        except SaltClientError as client_error:\n            log.error('Error while executing %s on %s (%s)', fun, tgt, tgt_type)\n            log.error(client_error)\n            return {}",
            "def execute(tgt, fun, arg=(), timeout=None, tgt_type='glob', ret='', jid='', kwarg=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Execute ``fun`` on all minions matched by ``tgt`` and ``tgt_type``.\\n    Parameter ``fun`` is the name of execution module function to call.\\n\\n    This function should mainly be used as a helper for runner modules,\\n    in order to avoid redundant code.\\n    For example, when inside a runner one needs to execute a certain function\\n    on arbitrary groups of minions, only has to:\\n\\n    .. code-block:: python\\n\\n        ret1 = __salt__['salt.execute']('*', 'mod.fun')\\n        ret2 = __salt__['salt.execute']('my_nodegroup', 'mod2.fun2', tgt_type='nodegroup')\\n\\n    It can also be used to schedule jobs directly on the master, for example:\\n\\n    .. code-block:: yaml\\n\\n        schedule:\\n            collect_bgp_stats:\\n                function: salt.execute\\n                args:\\n                    - edge-routers\\n                    - bgp.neighbors\\n                kwargs:\\n                    tgt_type: nodegroup\\n                days: 1\\n                returner: redis\\n    \"\n    with salt.client.get_local_client(__opts__['conf_file']) as client:\n        try:\n            return client.cmd(tgt, fun, arg=arg, timeout=timeout or __opts__['timeout'], tgt_type=tgt_type, ret=ret, jid=jid, kwarg=kwarg, **kwargs)\n        except SaltClientError as client_error:\n            log.error('Error while executing %s on %s (%s)', fun, tgt, tgt_type)\n            log.error(client_error)\n            return {}",
            "def execute(tgt, fun, arg=(), timeout=None, tgt_type='glob', ret='', jid='', kwarg=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Execute ``fun`` on all minions matched by ``tgt`` and ``tgt_type``.\\n    Parameter ``fun`` is the name of execution module function to call.\\n\\n    This function should mainly be used as a helper for runner modules,\\n    in order to avoid redundant code.\\n    For example, when inside a runner one needs to execute a certain function\\n    on arbitrary groups of minions, only has to:\\n\\n    .. code-block:: python\\n\\n        ret1 = __salt__['salt.execute']('*', 'mod.fun')\\n        ret2 = __salt__['salt.execute']('my_nodegroup', 'mod2.fun2', tgt_type='nodegroup')\\n\\n    It can also be used to schedule jobs directly on the master, for example:\\n\\n    .. code-block:: yaml\\n\\n        schedule:\\n            collect_bgp_stats:\\n                function: salt.execute\\n                args:\\n                    - edge-routers\\n                    - bgp.neighbors\\n                kwargs:\\n                    tgt_type: nodegroup\\n                days: 1\\n                returner: redis\\n    \"\n    with salt.client.get_local_client(__opts__['conf_file']) as client:\n        try:\n            return client.cmd(tgt, fun, arg=arg, timeout=timeout or __opts__['timeout'], tgt_type=tgt_type, ret=ret, jid=jid, kwarg=kwarg, **kwargs)\n        except SaltClientError as client_error:\n            log.error('Error while executing %s on %s (%s)', fun, tgt, tgt_type)\n            log.error(client_error)\n            return {}",
            "def execute(tgt, fun, arg=(), timeout=None, tgt_type='glob', ret='', jid='', kwarg=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Execute ``fun`` on all minions matched by ``tgt`` and ``tgt_type``.\\n    Parameter ``fun`` is the name of execution module function to call.\\n\\n    This function should mainly be used as a helper for runner modules,\\n    in order to avoid redundant code.\\n    For example, when inside a runner one needs to execute a certain function\\n    on arbitrary groups of minions, only has to:\\n\\n    .. code-block:: python\\n\\n        ret1 = __salt__['salt.execute']('*', 'mod.fun')\\n        ret2 = __salt__['salt.execute']('my_nodegroup', 'mod2.fun2', tgt_type='nodegroup')\\n\\n    It can also be used to schedule jobs directly on the master, for example:\\n\\n    .. code-block:: yaml\\n\\n        schedule:\\n            collect_bgp_stats:\\n                function: salt.execute\\n                args:\\n                    - edge-routers\\n                    - bgp.neighbors\\n                kwargs:\\n                    tgt_type: nodegroup\\n                days: 1\\n                returner: redis\\n    \"\n    with salt.client.get_local_client(__opts__['conf_file']) as client:\n        try:\n            return client.cmd(tgt, fun, arg=arg, timeout=timeout or __opts__['timeout'], tgt_type=tgt_type, ret=ret, jid=jid, kwarg=kwarg, **kwargs)\n        except SaltClientError as client_error:\n            log.error('Error while executing %s on %s (%s)', fun, tgt, tgt_type)\n            log.error(client_error)\n            return {}",
            "def execute(tgt, fun, arg=(), timeout=None, tgt_type='glob', ret='', jid='', kwarg=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2017.7.0\\n\\n    Execute ``fun`` on all minions matched by ``tgt`` and ``tgt_type``.\\n    Parameter ``fun`` is the name of execution module function to call.\\n\\n    This function should mainly be used as a helper for runner modules,\\n    in order to avoid redundant code.\\n    For example, when inside a runner one needs to execute a certain function\\n    on arbitrary groups of minions, only has to:\\n\\n    .. code-block:: python\\n\\n        ret1 = __salt__['salt.execute']('*', 'mod.fun')\\n        ret2 = __salt__['salt.execute']('my_nodegroup', 'mod2.fun2', tgt_type='nodegroup')\\n\\n    It can also be used to schedule jobs directly on the master, for example:\\n\\n    .. code-block:: yaml\\n\\n        schedule:\\n            collect_bgp_stats:\\n                function: salt.execute\\n                args:\\n                    - edge-routers\\n                    - bgp.neighbors\\n                kwargs:\\n                    tgt_type: nodegroup\\n                days: 1\\n                returner: redis\\n    \"\n    with salt.client.get_local_client(__opts__['conf_file']) as client:\n        try:\n            return client.cmd(tgt, fun, arg=arg, timeout=timeout or __opts__['timeout'], tgt_type=tgt_type, ret=ret, jid=jid, kwarg=kwarg, **kwargs)\n        except SaltClientError as client_error:\n            log.error('Error while executing %s on %s (%s)', fun, tgt, tgt_type)\n            log.error(client_error)\n            return {}"
        ]
    }
]