[
    {
        "func_name": "build_param",
        "original": "def build_param(ast, name, default, annotation=None):\n    \"\"\"build parameters:\n        - handle defaults\n        - handle format tuple parameters\n        \"\"\"\n    value = default\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
        "mutated": [
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n    'build parameters:\\n        - handle defaults\\n        - handle format tuple parameters\\n        '\n    value = default\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'build parameters:\\n        - handle defaults\\n        - handle format tuple parameters\\n        '\n    value = default\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'build parameters:\\n        - handle defaults\\n        - handle format tuple parameters\\n        '\n    value = default\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'build parameters:\\n        - handle defaults\\n        - handle format tuple parameters\\n        '\n    value = default\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result",
            "def build_param(ast, name, default, annotation=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'build parameters:\\n        - handle defaults\\n        - handle format tuple parameters\\n        '\n    value = default\n    maybe_show_tree_param_default(self.showast, name, value)\n    if annotation:\n        result = '%s: %s=%s' % (name, annotation, value)\n    else:\n        result = '%s=%s' % (name, value)\n    if result[-2:] == '= ':\n        result += 'None'\n    return result"
        ]
    },
    {
        "func_name": "make_function36",
        "original": "def make_function36(self, node, is_lambda, nested=1, code_node=None):\n    \"\"\"Dump function definition, doc string, and function body in\n    Python version 3.6 and above.\n    \"\"\"\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n        - handle defaults\n        - handle format tuple parameters\n        \"\"\"\n        value = default\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    lambda_index = -3\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if len(args_attr) == 3:\n        (_, kw_args, annotate_argc) = args_attr\n    else:\n        (_, kw_args, annotate_argc, closure) = args_attr\n    if node[-2] != 'docstring':\n        i = -4\n    else:\n        i = -5\n    if annotate_argc:\n        annotate_node = node[i]\n        if annotate_node == 'expr':\n            annotate_node = annotate_node[0]\n            annotate_name_node = annotate_node[-1]\n            if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                names = annotate_node[-2].attr\n                length = len(types)\n                assert length == len(names)\n                for i in range(length):\n                    annotate_dict[names[i]] = types[i]\n                pass\n            pass\n        i -= 1\n    if closure:\n        i -= 1\n    defparams = []\n    (default, kw_args, annotate_argc) = args_node.attr[0:3]\n    if default:\n        expr_node = node[0]\n        if node[0] == 'pos_arg':\n            expr_node = expr_node[0]\n        assert expr_node == 'expr', 'expecting mkfunc default node to be an expr'\n        if expr_node[0] == 'LOAD_CONST' and isinstance(expr_node[0].attr, tuple):\n            defparams = [repr(a) for a in expr_node[0].attr]\n        elif expr_node[0] in frozenset(('list', 'tuple', 'dict', 'set')):\n            defparams = [self.traverse(n, indent='') for n in expr_node[0][:-1]]\n    else:\n        defparams = []\n    pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    debug_opts = self.debug_opts['asm'] if self.debug_opts else None\n    scanner_code = Code(code, self.scanner, self.currentclass, debug_opts)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        tree = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(tree, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n        argc += 1\n    if is_lambda:\n        self.write('lambda')\n        if len(params):\n            self.write(' ', ', '.join(params))\n        elif kwonlyargcount > 0 and (not 4 & code.co_flags):\n            assert argc == 0\n            self.write(' ')\n        if len(tree) > 1 and self.traverse(tree[-1]) == 'None' and self.traverse(tree[-2]).strip().startswith('yield'):\n            del tree[-1]\n            tree_expr = tree[-1]\n            while tree_expr.kind != 'expr':\n                tree_expr = tree_expr[0]\n            tree[-1] = tree_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n        elif argc > 0:\n            self.write(', ')\n        kw_dict = None\n        fn_bits = node[-1].attr\n        index = -5 if node[-2] == 'docstring' else -4\n        if fn_bits[-1]:\n            index -= 1\n        if fn_bits[-2]:\n            index -= 1\n        if fn_bits[-3]:\n            kw_dict = node[index]\n            index -= 1\n        if fn_bits[-4]:\n            pass\n        if kw_dict == 'expr':\n            kw_dict = kw_dict[0]\n        kw_args = [None] * kwonlyargcount\n        if kw_dict:\n            assert kw_dict == 'dict'\n            const_list = kw_dict[0]\n            if kw_dict[0] == 'const_list':\n                add_consts = const_list[1]\n                assert add_consts == 'add_consts'\n                names = add_consts[-1].attr\n                defaults = [v.pattr for v in add_consts[:-1]]\n            else:\n                defaults = [self.traverse(n, indent='') for n in kw_dict[:-2]]\n                names = eval(self.traverse(kw_dict[-2]))\n            assert len(defaults) == len(names)\n            for (i, n) in enumerate(names):\n                idx = kwargs.index(n)\n                if annotate_dict and n in annotate_dict:\n                    t = '%s: %s=%s' % (n, annotate_dict[n], defaults[i])\n                else:\n                    t = '%s=%s' % (n, defaults[i])\n                kw_args[idx] = t\n                pass\n            pass\n        other_kw = [c is None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if node[-2] == 'docstring' and (not is_lambda):\n        self.println(self.traverse(node[-2]))\n    assert tree in ('stmts', 'lambda_start')\n    all_globals = find_all_globals(tree, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(tree, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(tree))\n    self.gen_source(tree, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & (CO_GENERATOR | CO_ASYNC_GENERATOR):\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token == 'YIELD_VALUE':\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
        "mutated": [
            "def make_function36(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n    'Dump function definition, doc string, and function body in\\n    Python version 3.6 and above.\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n        - handle defaults\n        - handle format tuple parameters\n        \"\"\"\n        value = default\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    lambda_index = -3\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if len(args_attr) == 3:\n        (_, kw_args, annotate_argc) = args_attr\n    else:\n        (_, kw_args, annotate_argc, closure) = args_attr\n    if node[-2] != 'docstring':\n        i = -4\n    else:\n        i = -5\n    if annotate_argc:\n        annotate_node = node[i]\n        if annotate_node == 'expr':\n            annotate_node = annotate_node[0]\n            annotate_name_node = annotate_node[-1]\n            if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                names = annotate_node[-2].attr\n                length = len(types)\n                assert length == len(names)\n                for i in range(length):\n                    annotate_dict[names[i]] = types[i]\n                pass\n            pass\n        i -= 1\n    if closure:\n        i -= 1\n    defparams = []\n    (default, kw_args, annotate_argc) = args_node.attr[0:3]\n    if default:\n        expr_node = node[0]\n        if node[0] == 'pos_arg':\n            expr_node = expr_node[0]\n        assert expr_node == 'expr', 'expecting mkfunc default node to be an expr'\n        if expr_node[0] == 'LOAD_CONST' and isinstance(expr_node[0].attr, tuple):\n            defparams = [repr(a) for a in expr_node[0].attr]\n        elif expr_node[0] in frozenset(('list', 'tuple', 'dict', 'set')):\n            defparams = [self.traverse(n, indent='') for n in expr_node[0][:-1]]\n    else:\n        defparams = []\n    pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    debug_opts = self.debug_opts['asm'] if self.debug_opts else None\n    scanner_code = Code(code, self.scanner, self.currentclass, debug_opts)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        tree = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(tree, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n        argc += 1\n    if is_lambda:\n        self.write('lambda')\n        if len(params):\n            self.write(' ', ', '.join(params))\n        elif kwonlyargcount > 0 and (not 4 & code.co_flags):\n            assert argc == 0\n            self.write(' ')\n        if len(tree) > 1 and self.traverse(tree[-1]) == 'None' and self.traverse(tree[-2]).strip().startswith('yield'):\n            del tree[-1]\n            tree_expr = tree[-1]\n            while tree_expr.kind != 'expr':\n                tree_expr = tree_expr[0]\n            tree[-1] = tree_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n        elif argc > 0:\n            self.write(', ')\n        kw_dict = None\n        fn_bits = node[-1].attr\n        index = -5 if node[-2] == 'docstring' else -4\n        if fn_bits[-1]:\n            index -= 1\n        if fn_bits[-2]:\n            index -= 1\n        if fn_bits[-3]:\n            kw_dict = node[index]\n            index -= 1\n        if fn_bits[-4]:\n            pass\n        if kw_dict == 'expr':\n            kw_dict = kw_dict[0]\n        kw_args = [None] * kwonlyargcount\n        if kw_dict:\n            assert kw_dict == 'dict'\n            const_list = kw_dict[0]\n            if kw_dict[0] == 'const_list':\n                add_consts = const_list[1]\n                assert add_consts == 'add_consts'\n                names = add_consts[-1].attr\n                defaults = [v.pattr for v in add_consts[:-1]]\n            else:\n                defaults = [self.traverse(n, indent='') for n in kw_dict[:-2]]\n                names = eval(self.traverse(kw_dict[-2]))\n            assert len(defaults) == len(names)\n            for (i, n) in enumerate(names):\n                idx = kwargs.index(n)\n                if annotate_dict and n in annotate_dict:\n                    t = '%s: %s=%s' % (n, annotate_dict[n], defaults[i])\n                else:\n                    t = '%s=%s' % (n, defaults[i])\n                kw_args[idx] = t\n                pass\n            pass\n        other_kw = [c is None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if node[-2] == 'docstring' and (not is_lambda):\n        self.println(self.traverse(node[-2]))\n    assert tree in ('stmts', 'lambda_start')\n    all_globals = find_all_globals(tree, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(tree, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(tree))\n    self.gen_source(tree, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & (CO_GENERATOR | CO_ASYNC_GENERATOR):\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token == 'YIELD_VALUE':\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
            "def make_function36(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Dump function definition, doc string, and function body in\\n    Python version 3.6 and above.\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n        - handle defaults\n        - handle format tuple parameters\n        \"\"\"\n        value = default\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    lambda_index = -3\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if len(args_attr) == 3:\n        (_, kw_args, annotate_argc) = args_attr\n    else:\n        (_, kw_args, annotate_argc, closure) = args_attr\n    if node[-2] != 'docstring':\n        i = -4\n    else:\n        i = -5\n    if annotate_argc:\n        annotate_node = node[i]\n        if annotate_node == 'expr':\n            annotate_node = annotate_node[0]\n            annotate_name_node = annotate_node[-1]\n            if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                names = annotate_node[-2].attr\n                length = len(types)\n                assert length == len(names)\n                for i in range(length):\n                    annotate_dict[names[i]] = types[i]\n                pass\n            pass\n        i -= 1\n    if closure:\n        i -= 1\n    defparams = []\n    (default, kw_args, annotate_argc) = args_node.attr[0:3]\n    if default:\n        expr_node = node[0]\n        if node[0] == 'pos_arg':\n            expr_node = expr_node[0]\n        assert expr_node == 'expr', 'expecting mkfunc default node to be an expr'\n        if expr_node[0] == 'LOAD_CONST' and isinstance(expr_node[0].attr, tuple):\n            defparams = [repr(a) for a in expr_node[0].attr]\n        elif expr_node[0] in frozenset(('list', 'tuple', 'dict', 'set')):\n            defparams = [self.traverse(n, indent='') for n in expr_node[0][:-1]]\n    else:\n        defparams = []\n    pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    debug_opts = self.debug_opts['asm'] if self.debug_opts else None\n    scanner_code = Code(code, self.scanner, self.currentclass, debug_opts)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        tree = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(tree, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n        argc += 1\n    if is_lambda:\n        self.write('lambda')\n        if len(params):\n            self.write(' ', ', '.join(params))\n        elif kwonlyargcount > 0 and (not 4 & code.co_flags):\n            assert argc == 0\n            self.write(' ')\n        if len(tree) > 1 and self.traverse(tree[-1]) == 'None' and self.traverse(tree[-2]).strip().startswith('yield'):\n            del tree[-1]\n            tree_expr = tree[-1]\n            while tree_expr.kind != 'expr':\n                tree_expr = tree_expr[0]\n            tree[-1] = tree_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n        elif argc > 0:\n            self.write(', ')\n        kw_dict = None\n        fn_bits = node[-1].attr\n        index = -5 if node[-2] == 'docstring' else -4\n        if fn_bits[-1]:\n            index -= 1\n        if fn_bits[-2]:\n            index -= 1\n        if fn_bits[-3]:\n            kw_dict = node[index]\n            index -= 1\n        if fn_bits[-4]:\n            pass\n        if kw_dict == 'expr':\n            kw_dict = kw_dict[0]\n        kw_args = [None] * kwonlyargcount\n        if kw_dict:\n            assert kw_dict == 'dict'\n            const_list = kw_dict[0]\n            if kw_dict[0] == 'const_list':\n                add_consts = const_list[1]\n                assert add_consts == 'add_consts'\n                names = add_consts[-1].attr\n                defaults = [v.pattr for v in add_consts[:-1]]\n            else:\n                defaults = [self.traverse(n, indent='') for n in kw_dict[:-2]]\n                names = eval(self.traverse(kw_dict[-2]))\n            assert len(defaults) == len(names)\n            for (i, n) in enumerate(names):\n                idx = kwargs.index(n)\n                if annotate_dict and n in annotate_dict:\n                    t = '%s: %s=%s' % (n, annotate_dict[n], defaults[i])\n                else:\n                    t = '%s=%s' % (n, defaults[i])\n                kw_args[idx] = t\n                pass\n            pass\n        other_kw = [c is None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if node[-2] == 'docstring' and (not is_lambda):\n        self.println(self.traverse(node[-2]))\n    assert tree in ('stmts', 'lambda_start')\n    all_globals = find_all_globals(tree, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(tree, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(tree))\n    self.gen_source(tree, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & (CO_GENERATOR | CO_ASYNC_GENERATOR):\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token == 'YIELD_VALUE':\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
            "def make_function36(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Dump function definition, doc string, and function body in\\n    Python version 3.6 and above.\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n        - handle defaults\n        - handle format tuple parameters\n        \"\"\"\n        value = default\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    lambda_index = -3\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if len(args_attr) == 3:\n        (_, kw_args, annotate_argc) = args_attr\n    else:\n        (_, kw_args, annotate_argc, closure) = args_attr\n    if node[-2] != 'docstring':\n        i = -4\n    else:\n        i = -5\n    if annotate_argc:\n        annotate_node = node[i]\n        if annotate_node == 'expr':\n            annotate_node = annotate_node[0]\n            annotate_name_node = annotate_node[-1]\n            if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                names = annotate_node[-2].attr\n                length = len(types)\n                assert length == len(names)\n                for i in range(length):\n                    annotate_dict[names[i]] = types[i]\n                pass\n            pass\n        i -= 1\n    if closure:\n        i -= 1\n    defparams = []\n    (default, kw_args, annotate_argc) = args_node.attr[0:3]\n    if default:\n        expr_node = node[0]\n        if node[0] == 'pos_arg':\n            expr_node = expr_node[0]\n        assert expr_node == 'expr', 'expecting mkfunc default node to be an expr'\n        if expr_node[0] == 'LOAD_CONST' and isinstance(expr_node[0].attr, tuple):\n            defparams = [repr(a) for a in expr_node[0].attr]\n        elif expr_node[0] in frozenset(('list', 'tuple', 'dict', 'set')):\n            defparams = [self.traverse(n, indent='') for n in expr_node[0][:-1]]\n    else:\n        defparams = []\n    pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    debug_opts = self.debug_opts['asm'] if self.debug_opts else None\n    scanner_code = Code(code, self.scanner, self.currentclass, debug_opts)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        tree = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(tree, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n        argc += 1\n    if is_lambda:\n        self.write('lambda')\n        if len(params):\n            self.write(' ', ', '.join(params))\n        elif kwonlyargcount > 0 and (not 4 & code.co_flags):\n            assert argc == 0\n            self.write(' ')\n        if len(tree) > 1 and self.traverse(tree[-1]) == 'None' and self.traverse(tree[-2]).strip().startswith('yield'):\n            del tree[-1]\n            tree_expr = tree[-1]\n            while tree_expr.kind != 'expr':\n                tree_expr = tree_expr[0]\n            tree[-1] = tree_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n        elif argc > 0:\n            self.write(', ')\n        kw_dict = None\n        fn_bits = node[-1].attr\n        index = -5 if node[-2] == 'docstring' else -4\n        if fn_bits[-1]:\n            index -= 1\n        if fn_bits[-2]:\n            index -= 1\n        if fn_bits[-3]:\n            kw_dict = node[index]\n            index -= 1\n        if fn_bits[-4]:\n            pass\n        if kw_dict == 'expr':\n            kw_dict = kw_dict[0]\n        kw_args = [None] * kwonlyargcount\n        if kw_dict:\n            assert kw_dict == 'dict'\n            const_list = kw_dict[0]\n            if kw_dict[0] == 'const_list':\n                add_consts = const_list[1]\n                assert add_consts == 'add_consts'\n                names = add_consts[-1].attr\n                defaults = [v.pattr for v in add_consts[:-1]]\n            else:\n                defaults = [self.traverse(n, indent='') for n in kw_dict[:-2]]\n                names = eval(self.traverse(kw_dict[-2]))\n            assert len(defaults) == len(names)\n            for (i, n) in enumerate(names):\n                idx = kwargs.index(n)\n                if annotate_dict and n in annotate_dict:\n                    t = '%s: %s=%s' % (n, annotate_dict[n], defaults[i])\n                else:\n                    t = '%s=%s' % (n, defaults[i])\n                kw_args[idx] = t\n                pass\n            pass\n        other_kw = [c is None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if node[-2] == 'docstring' and (not is_lambda):\n        self.println(self.traverse(node[-2]))\n    assert tree in ('stmts', 'lambda_start')\n    all_globals = find_all_globals(tree, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(tree, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(tree))\n    self.gen_source(tree, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & (CO_GENERATOR | CO_ASYNC_GENERATOR):\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token == 'YIELD_VALUE':\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
            "def make_function36(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Dump function definition, doc string, and function body in\\n    Python version 3.6 and above.\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n        - handle defaults\n        - handle format tuple parameters\n        \"\"\"\n        value = default\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    lambda_index = -3\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if len(args_attr) == 3:\n        (_, kw_args, annotate_argc) = args_attr\n    else:\n        (_, kw_args, annotate_argc, closure) = args_attr\n    if node[-2] != 'docstring':\n        i = -4\n    else:\n        i = -5\n    if annotate_argc:\n        annotate_node = node[i]\n        if annotate_node == 'expr':\n            annotate_node = annotate_node[0]\n            annotate_name_node = annotate_node[-1]\n            if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                names = annotate_node[-2].attr\n                length = len(types)\n                assert length == len(names)\n                for i in range(length):\n                    annotate_dict[names[i]] = types[i]\n                pass\n            pass\n        i -= 1\n    if closure:\n        i -= 1\n    defparams = []\n    (default, kw_args, annotate_argc) = args_node.attr[0:3]\n    if default:\n        expr_node = node[0]\n        if node[0] == 'pos_arg':\n            expr_node = expr_node[0]\n        assert expr_node == 'expr', 'expecting mkfunc default node to be an expr'\n        if expr_node[0] == 'LOAD_CONST' and isinstance(expr_node[0].attr, tuple):\n            defparams = [repr(a) for a in expr_node[0].attr]\n        elif expr_node[0] in frozenset(('list', 'tuple', 'dict', 'set')):\n            defparams = [self.traverse(n, indent='') for n in expr_node[0][:-1]]\n    else:\n        defparams = []\n    pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    debug_opts = self.debug_opts['asm'] if self.debug_opts else None\n    scanner_code = Code(code, self.scanner, self.currentclass, debug_opts)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        tree = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(tree, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n        argc += 1\n    if is_lambda:\n        self.write('lambda')\n        if len(params):\n            self.write(' ', ', '.join(params))\n        elif kwonlyargcount > 0 and (not 4 & code.co_flags):\n            assert argc == 0\n            self.write(' ')\n        if len(tree) > 1 and self.traverse(tree[-1]) == 'None' and self.traverse(tree[-2]).strip().startswith('yield'):\n            del tree[-1]\n            tree_expr = tree[-1]\n            while tree_expr.kind != 'expr':\n                tree_expr = tree_expr[0]\n            tree[-1] = tree_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n        elif argc > 0:\n            self.write(', ')\n        kw_dict = None\n        fn_bits = node[-1].attr\n        index = -5 if node[-2] == 'docstring' else -4\n        if fn_bits[-1]:\n            index -= 1\n        if fn_bits[-2]:\n            index -= 1\n        if fn_bits[-3]:\n            kw_dict = node[index]\n            index -= 1\n        if fn_bits[-4]:\n            pass\n        if kw_dict == 'expr':\n            kw_dict = kw_dict[0]\n        kw_args = [None] * kwonlyargcount\n        if kw_dict:\n            assert kw_dict == 'dict'\n            const_list = kw_dict[0]\n            if kw_dict[0] == 'const_list':\n                add_consts = const_list[1]\n                assert add_consts == 'add_consts'\n                names = add_consts[-1].attr\n                defaults = [v.pattr for v in add_consts[:-1]]\n            else:\n                defaults = [self.traverse(n, indent='') for n in kw_dict[:-2]]\n                names = eval(self.traverse(kw_dict[-2]))\n            assert len(defaults) == len(names)\n            for (i, n) in enumerate(names):\n                idx = kwargs.index(n)\n                if annotate_dict and n in annotate_dict:\n                    t = '%s: %s=%s' % (n, annotate_dict[n], defaults[i])\n                else:\n                    t = '%s=%s' % (n, defaults[i])\n                kw_args[idx] = t\n                pass\n            pass\n        other_kw = [c is None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if node[-2] == 'docstring' and (not is_lambda):\n        self.println(self.traverse(node[-2]))\n    assert tree in ('stmts', 'lambda_start')\n    all_globals = find_all_globals(tree, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(tree, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(tree))\n    self.gen_source(tree, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & (CO_GENERATOR | CO_ASYNC_GENERATOR):\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token == 'YIELD_VALUE':\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None",
            "def make_function36(self, node, is_lambda, nested=1, code_node=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Dump function definition, doc string, and function body in\\n    Python version 3.6 and above.\\n    '\n\n    def build_param(ast, name, default, annotation=None):\n        \"\"\"build parameters:\n        - handle defaults\n        - handle format tuple parameters\n        \"\"\"\n        value = default\n        maybe_show_tree_param_default(self.showast, name, value)\n        if annotation:\n            result = '%s: %s=%s' % (name, annotation, value)\n        else:\n            result = '%s=%s' % (name, value)\n        if result[-2:] == '= ':\n            result += 'None'\n        return result\n    assert node[-1].kind.startswith('MAKE_')\n    lambda_index = -3\n    args_node = node[-1]\n    annotate_dict = {}\n    args_attr = args_node.attr\n    if len(args_attr) == 3:\n        (_, kw_args, annotate_argc) = args_attr\n    else:\n        (_, kw_args, annotate_argc, closure) = args_attr\n    if node[-2] != 'docstring':\n        i = -4\n    else:\n        i = -5\n    if annotate_argc:\n        annotate_node = node[i]\n        if annotate_node == 'expr':\n            annotate_node = annotate_node[0]\n            annotate_name_node = annotate_node[-1]\n            if annotate_node == 'dict' and annotate_name_node.kind.startswith('BUILD_CONST_KEY_MAP'):\n                types = [self.traverse(n, indent='') for n in annotate_node[:-2]]\n                names = annotate_node[-2].attr\n                length = len(types)\n                assert length == len(names)\n                for i in range(length):\n                    annotate_dict[names[i]] = types[i]\n                pass\n            pass\n        i -= 1\n    if closure:\n        i -= 1\n    defparams = []\n    (default, kw_args, annotate_argc) = args_node.attr[0:3]\n    if default:\n        expr_node = node[0]\n        if node[0] == 'pos_arg':\n            expr_node = expr_node[0]\n        assert expr_node == 'expr', 'expecting mkfunc default node to be an expr'\n        if expr_node[0] == 'LOAD_CONST' and isinstance(expr_node[0].attr, tuple):\n            defparams = [repr(a) for a in expr_node[0].attr]\n        elif expr_node[0] in frozenset(('list', 'tuple', 'dict', 'set')):\n            defparams = [self.traverse(n, indent='') for n in expr_node[0][:-1]]\n    else:\n        defparams = []\n    pass\n    if lambda_index and is_lambda and iscode(node[lambda_index].attr):\n        assert node[lambda_index].kind == 'LOAD_LAMBDA'\n        code = node[lambda_index].attr\n    else:\n        code = code_node.attr\n    assert iscode(code)\n    debug_opts = self.debug_opts['asm'] if self.debug_opts else None\n    scanner_code = Code(code, self.scanner, self.currentclass, debug_opts)\n    argc = code.co_argcount\n    kwonlyargcount = code.co_kwonlyargcount\n    paramnames = list(scanner_code.co_varnames[:argc])\n    kwargs = list(scanner_code.co_varnames[argc:argc + kwonlyargcount])\n    paramnames.reverse()\n    defparams.reverse()\n    try:\n        tree = self.build_ast(scanner_code._tokens, scanner_code._customize, scanner_code, is_lambda=is_lambda, noneInNames='None' in code.co_names)\n    except (ParserError, ParserError2) as p:\n        self.write(str(p))\n        if not self.tolerate_errors:\n            self.ERROR = p\n        return\n    i = len(paramnames) - len(defparams)\n    params = []\n    if defparams:\n        for (i, defparam) in enumerate(defparams):\n            params.append(build_param(tree, paramnames[i], defparam, annotate_dict.get(paramnames[i])))\n        for param in paramnames[i + 1:]:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    else:\n        for param in paramnames:\n            if param in annotate_dict:\n                params.append('%s: %s' % (param, annotate_dict[param]))\n            else:\n                params.append(param)\n    params.reverse()\n    if code_has_star_arg(code):\n        star_arg = code.co_varnames[argc + kwonlyargcount]\n        if star_arg in annotate_dict:\n            params.append('*%s: %s' % (star_arg, annotate_dict[star_arg]))\n        else:\n            params.append('*%s' % star_arg)\n        argc += 1\n    if is_lambda:\n        self.write('lambda')\n        if len(params):\n            self.write(' ', ', '.join(params))\n        elif kwonlyargcount > 0 and (not 4 & code.co_flags):\n            assert argc == 0\n            self.write(' ')\n        if len(tree) > 1 and self.traverse(tree[-1]) == 'None' and self.traverse(tree[-2]).strip().startswith('yield'):\n            del tree[-1]\n            tree_expr = tree[-1]\n            while tree_expr.kind != 'expr':\n                tree_expr = tree_expr[0]\n            tree[-1] = tree_expr\n            pass\n    else:\n        self.write('(', ', '.join(params))\n    ends_in_comma = False\n    if kwonlyargcount > 0:\n        if not 4 & code.co_flags:\n            if argc > 0:\n                self.write(', *, ')\n            else:\n                self.write('*, ')\n            pass\n        elif argc > 0:\n            self.write(', ')\n        kw_dict = None\n        fn_bits = node[-1].attr\n        index = -5 if node[-2] == 'docstring' else -4\n        if fn_bits[-1]:\n            index -= 1\n        if fn_bits[-2]:\n            index -= 1\n        if fn_bits[-3]:\n            kw_dict = node[index]\n            index -= 1\n        if fn_bits[-4]:\n            pass\n        if kw_dict == 'expr':\n            kw_dict = kw_dict[0]\n        kw_args = [None] * kwonlyargcount\n        if kw_dict:\n            assert kw_dict == 'dict'\n            const_list = kw_dict[0]\n            if kw_dict[0] == 'const_list':\n                add_consts = const_list[1]\n                assert add_consts == 'add_consts'\n                names = add_consts[-1].attr\n                defaults = [v.pattr for v in add_consts[:-1]]\n            else:\n                defaults = [self.traverse(n, indent='') for n in kw_dict[:-2]]\n                names = eval(self.traverse(kw_dict[-2]))\n            assert len(defaults) == len(names)\n            for (i, n) in enumerate(names):\n                idx = kwargs.index(n)\n                if annotate_dict and n in annotate_dict:\n                    t = '%s: %s=%s' % (n, annotate_dict[n], defaults[i])\n                else:\n                    t = '%s=%s' % (n, defaults[i])\n                kw_args[idx] = t\n                pass\n            pass\n        other_kw = [c is None for c in kw_args]\n        for (i, flag) in enumerate(other_kw):\n            if flag:\n                n = kwargs[i]\n                if n in annotate_dict:\n                    kw_args[i] = '%s: %s' % (n, annotate_dict[n])\n                else:\n                    kw_args[i] = '%s' % n\n        self.write(', '.join(kw_args))\n        ends_in_comma = False\n        pass\n    elif argc == 0:\n        ends_in_comma = True\n    if code_has_star_star_arg(code):\n        if not ends_in_comma:\n            self.write(', ')\n        star_star_arg = code.co_varnames[argc + kwonlyargcount]\n        if annotate_dict and star_star_arg in annotate_dict:\n            self.write('**%s: %s' % (star_star_arg, annotate_dict[star_star_arg]))\n        else:\n            self.write('**%s' % star_star_arg)\n    if is_lambda:\n        self.write(': ')\n    else:\n        self.write(')')\n        if annotate_dict and 'return' in annotate_dict:\n            self.write(' -> %s' % annotate_dict['return'])\n        self.println(':')\n    if node[-2] == 'docstring' and (not is_lambda):\n        self.println(self.traverse(node[-2]))\n    assert tree in ('stmts', 'lambda_start')\n    all_globals = find_all_globals(tree, set())\n    (globals, nonlocals) = find_globals_and_nonlocals(tree, set(), set(), code, self.version)\n    for g in sorted(all_globals & self.mod_globs | globals):\n        self.println(self.indent, 'global ', g)\n    for nl in sorted(nonlocals):\n        self.println(self.indent, 'nonlocal ', nl)\n    self.mod_globs -= all_globals\n    has_none = 'None' in code.co_names\n    rn = has_none and (not find_none(tree))\n    self.gen_source(tree, code.co_name, scanner_code._customize, is_lambda=is_lambda, returnNone=rn, debug_opts=self.debug_opts)\n    if not is_lambda and code.co_flags & (CO_GENERATOR | CO_ASYNC_GENERATOR):\n        need_bogus_yield = True\n        for token in scanner_code._tokens:\n            if token == 'YIELD_VALUE':\n                need_bogus_yield = False\n                break\n            pass\n        if need_bogus_yield:\n            self.template_engine(('%|if False:\\n%+%|yield None%-',), node)\n    scanner_code._tokens = None\n    scanner_code._customize = None"
        ]
    }
]