[
    {
        "func_name": "normalised_kendall_tau_distance",
        "original": "def normalised_kendall_tau_distance(values1, values2):\n    \"\"\"Compute the Kendall tau distance.\"\"\"\n    n = len(values1)\n    assert len(values2) == n, 'Both lists have to be of equal length'\n    (i, j) = np.meshgrid(np.arange(n), np.arange(n))\n    a = np.argsort(values1)\n    b = np.argsort(values2)\n    ndisordered = np.logical_or(np.logical_and(a[i] < a[j], b[i] > b[j]), np.logical_and(a[i] > a[j], b[i] < b[j])).sum()\n    return ndisordered / (n * (n - 1))",
        "mutated": [
            "def normalised_kendall_tau_distance(values1, values2):\n    if False:\n        i = 10\n    'Compute the Kendall tau distance.'\n    n = len(values1)\n    assert len(values2) == n, 'Both lists have to be of equal length'\n    (i, j) = np.meshgrid(np.arange(n), np.arange(n))\n    a = np.argsort(values1)\n    b = np.argsort(values2)\n    ndisordered = np.logical_or(np.logical_and(a[i] < a[j], b[i] > b[j]), np.logical_and(a[i] > a[j], b[i] < b[j])).sum()\n    return ndisordered / (n * (n - 1))",
            "def normalised_kendall_tau_distance(values1, values2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the Kendall tau distance.'\n    n = len(values1)\n    assert len(values2) == n, 'Both lists have to be of equal length'\n    (i, j) = np.meshgrid(np.arange(n), np.arange(n))\n    a = np.argsort(values1)\n    b = np.argsort(values2)\n    ndisordered = np.logical_or(np.logical_and(a[i] < a[j], b[i] > b[j]), np.logical_and(a[i] > a[j], b[i] < b[j])).sum()\n    return ndisordered / (n * (n - 1))",
            "def normalised_kendall_tau_distance(values1, values2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the Kendall tau distance.'\n    n = len(values1)\n    assert len(values2) == n, 'Both lists have to be of equal length'\n    (i, j) = np.meshgrid(np.arange(n), np.arange(n))\n    a = np.argsort(values1)\n    b = np.argsort(values2)\n    ndisordered = np.logical_or(np.logical_and(a[i] < a[j], b[i] > b[j]), np.logical_and(a[i] > a[j], b[i] < b[j])).sum()\n    return ndisordered / (n * (n - 1))",
            "def normalised_kendall_tau_distance(values1, values2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the Kendall tau distance.'\n    n = len(values1)\n    assert len(values2) == n, 'Both lists have to be of equal length'\n    (i, j) = np.meshgrid(np.arange(n), np.arange(n))\n    a = np.argsort(values1)\n    b = np.argsort(values2)\n    ndisordered = np.logical_or(np.logical_and(a[i] < a[j], b[i] > b[j]), np.logical_and(a[i] > a[j], b[i] < b[j])).sum()\n    return ndisordered / (n * (n - 1))",
            "def normalised_kendall_tau_distance(values1, values2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the Kendall tau distance.'\n    n = len(values1)\n    assert len(values2) == n, 'Both lists have to be of equal length'\n    (i, j) = np.meshgrid(np.arange(n), np.arange(n))\n    a = np.argsort(values1)\n    b = np.argsort(values2)\n    ndisordered = np.logical_or(np.logical_and(a[i] < a[j], b[i] > b[j]), np.logical_and(a[i] > a[j], b[i] < b[j])).sum()\n    return ndisordered / (n * (n - 1))"
        ]
    },
    {
        "func_name": "get_df",
        "original": "def get_df():\n    \"\"\"\n    Simple method that computes merged rankings and compares them to each user.\n    Most interesting output for end-user is presumably the last that lists each user with their\n    correlation to the mean ranking.\n    Lower means less well aligned to the mean, higher means more well aligned.\n    Note that rankings with fewer options are more likely to be wrong, so this could\n    yield to misleading results:\n    **You cannot use this for automatic flagging!**\n    \"\"\"\n    conn = psycopg2.connect('host=0.0.0.0 port=5432 user=postgres password=postgres dbname=postgres')\n    role = \"'assistant'\"\n    message_tree_id = None\n    query = f\"\\n        -- get all ranking results of completed tasks for all parents with >= 2 children\\n        SELECT DISTINCT p.parent_id, p.message_tree_id, mr.* FROM\\n        (\\n            -- find parents with > 1 children\\n            SELECT m.parent_id, m.message_tree_id, COUNT(m.id) children_count\\n            FROM message_tree_state mts\\n            INNER JOIN message m ON mts.message_tree_id = m.message_tree_id\\n            WHERE m.review_result                  -- must be reviewed\\n            AND NOT m.deleted                   -- not deleted\\n            AND m.parent_id IS NOT NULL         -- ignore initial prompts\\n            AND ({role} IS NULL OR m.role = {role}) -- children with matching role\\n            -- AND mts.message_tree_id = {message_tree_id}\\n            GROUP BY m.parent_id, m.message_tree_id\\n            HAVING COUNT(m.id) > 1\\n        ) as p\\n        LEFT JOIN task t ON p.parent_id = t.parent_message_id AND t.done AND (t.payload_type = 'RankPrompterRepliesPayload' OR t.payload_type = 'RankAssistantRepliesPayload')\\n        LEFT JOIN message_reaction mr ON mr.task_id = t.id AND mr.payload_type = 'RankingReactionPayload'\\n        \"\n    df = pd.read_sql(query, con=conn)\n    print(df[['message_tree_id', 'parent_id', 'payload']])\n    conn.close()\n    users = set()\n    messages = set()\n    rankings = defaultdict(list)\n    rankings_with_user = defaultdict(list)\n    for row in df.itertuples(index=False):\n        row = row._asdict()\n        users.add(str(row['user_id']))\n        messages.add(str(row['message_tree_id']))\n        if row['payload'] is None:\n            continue\n        ranking = row['payload']['payload']['ranked_message_ids']\n        rankings_with_user[str(row['parent_id'])].append((ranking, str(row['user_id'])))\n        rankings[str(row['parent_id'])].append(ranking)\n    print(*[f'{k} : {v}' for (k, v) in rankings.items()], sep='\\n')\n    users = list(users)\n    messages = list(messages)\n    consensus = dict()\n    total_correlation = list()\n    for (k, v) in rankings.items():\n        common_set = set.intersection(*map(set, v))\n        v = [list(filter(lambda x: x in common_set, ids)) for ids in v]\n        merged_rankings = ranked_pairs(v)\n        consensus[k] = merged_rankings\n        ls = []\n        for (vote, id) in rankings_with_user[k]:\n            vote = list(filter(lambda x: x in common_set, vote))\n            ls.append((kendalltau(merged_rankings, vote), id))\n        rankings_with_user[k] = ls\n        total_correlation.extend(ls)\n    correlation_by_user = defaultdict(list)\n    for u in users:\n        for (c, m) in total_correlation:\n            if m == u:\n                correlation_by_user[u].append(c)\n    return (consensus, users, messages, rankings_with_user, correlation_by_user)",
        "mutated": [
            "def get_df():\n    if False:\n        i = 10\n    '\\n    Simple method that computes merged rankings and compares them to each user.\\n    Most interesting output for end-user is presumably the last that lists each user with their\\n    correlation to the mean ranking.\\n    Lower means less well aligned to the mean, higher means more well aligned.\\n    Note that rankings with fewer options are more likely to be wrong, so this could\\n    yield to misleading results:\\n    **You cannot use this for automatic flagging!**\\n    '\n    conn = psycopg2.connect('host=0.0.0.0 port=5432 user=postgres password=postgres dbname=postgres')\n    role = \"'assistant'\"\n    message_tree_id = None\n    query = f\"\\n        -- get all ranking results of completed tasks for all parents with >= 2 children\\n        SELECT DISTINCT p.parent_id, p.message_tree_id, mr.* FROM\\n        (\\n            -- find parents with > 1 children\\n            SELECT m.parent_id, m.message_tree_id, COUNT(m.id) children_count\\n            FROM message_tree_state mts\\n            INNER JOIN message m ON mts.message_tree_id = m.message_tree_id\\n            WHERE m.review_result                  -- must be reviewed\\n            AND NOT m.deleted                   -- not deleted\\n            AND m.parent_id IS NOT NULL         -- ignore initial prompts\\n            AND ({role} IS NULL OR m.role = {role}) -- children with matching role\\n            -- AND mts.message_tree_id = {message_tree_id}\\n            GROUP BY m.parent_id, m.message_tree_id\\n            HAVING COUNT(m.id) > 1\\n        ) as p\\n        LEFT JOIN task t ON p.parent_id = t.parent_message_id AND t.done AND (t.payload_type = 'RankPrompterRepliesPayload' OR t.payload_type = 'RankAssistantRepliesPayload')\\n        LEFT JOIN message_reaction mr ON mr.task_id = t.id AND mr.payload_type = 'RankingReactionPayload'\\n        \"\n    df = pd.read_sql(query, con=conn)\n    print(df[['message_tree_id', 'parent_id', 'payload']])\n    conn.close()\n    users = set()\n    messages = set()\n    rankings = defaultdict(list)\n    rankings_with_user = defaultdict(list)\n    for row in df.itertuples(index=False):\n        row = row._asdict()\n        users.add(str(row['user_id']))\n        messages.add(str(row['message_tree_id']))\n        if row['payload'] is None:\n            continue\n        ranking = row['payload']['payload']['ranked_message_ids']\n        rankings_with_user[str(row['parent_id'])].append((ranking, str(row['user_id'])))\n        rankings[str(row['parent_id'])].append(ranking)\n    print(*[f'{k} : {v}' for (k, v) in rankings.items()], sep='\\n')\n    users = list(users)\n    messages = list(messages)\n    consensus = dict()\n    total_correlation = list()\n    for (k, v) in rankings.items():\n        common_set = set.intersection(*map(set, v))\n        v = [list(filter(lambda x: x in common_set, ids)) for ids in v]\n        merged_rankings = ranked_pairs(v)\n        consensus[k] = merged_rankings\n        ls = []\n        for (vote, id) in rankings_with_user[k]:\n            vote = list(filter(lambda x: x in common_set, vote))\n            ls.append((kendalltau(merged_rankings, vote), id))\n        rankings_with_user[k] = ls\n        total_correlation.extend(ls)\n    correlation_by_user = defaultdict(list)\n    for u in users:\n        for (c, m) in total_correlation:\n            if m == u:\n                correlation_by_user[u].append(c)\n    return (consensus, users, messages, rankings_with_user, correlation_by_user)",
            "def get_df():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Simple method that computes merged rankings and compares them to each user.\\n    Most interesting output for end-user is presumably the last that lists each user with their\\n    correlation to the mean ranking.\\n    Lower means less well aligned to the mean, higher means more well aligned.\\n    Note that rankings with fewer options are more likely to be wrong, so this could\\n    yield to misleading results:\\n    **You cannot use this for automatic flagging!**\\n    '\n    conn = psycopg2.connect('host=0.0.0.0 port=5432 user=postgres password=postgres dbname=postgres')\n    role = \"'assistant'\"\n    message_tree_id = None\n    query = f\"\\n        -- get all ranking results of completed tasks for all parents with >= 2 children\\n        SELECT DISTINCT p.parent_id, p.message_tree_id, mr.* FROM\\n        (\\n            -- find parents with > 1 children\\n            SELECT m.parent_id, m.message_tree_id, COUNT(m.id) children_count\\n            FROM message_tree_state mts\\n            INNER JOIN message m ON mts.message_tree_id = m.message_tree_id\\n            WHERE m.review_result                  -- must be reviewed\\n            AND NOT m.deleted                   -- not deleted\\n            AND m.parent_id IS NOT NULL         -- ignore initial prompts\\n            AND ({role} IS NULL OR m.role = {role}) -- children with matching role\\n            -- AND mts.message_tree_id = {message_tree_id}\\n            GROUP BY m.parent_id, m.message_tree_id\\n            HAVING COUNT(m.id) > 1\\n        ) as p\\n        LEFT JOIN task t ON p.parent_id = t.parent_message_id AND t.done AND (t.payload_type = 'RankPrompterRepliesPayload' OR t.payload_type = 'RankAssistantRepliesPayload')\\n        LEFT JOIN message_reaction mr ON mr.task_id = t.id AND mr.payload_type = 'RankingReactionPayload'\\n        \"\n    df = pd.read_sql(query, con=conn)\n    print(df[['message_tree_id', 'parent_id', 'payload']])\n    conn.close()\n    users = set()\n    messages = set()\n    rankings = defaultdict(list)\n    rankings_with_user = defaultdict(list)\n    for row in df.itertuples(index=False):\n        row = row._asdict()\n        users.add(str(row['user_id']))\n        messages.add(str(row['message_tree_id']))\n        if row['payload'] is None:\n            continue\n        ranking = row['payload']['payload']['ranked_message_ids']\n        rankings_with_user[str(row['parent_id'])].append((ranking, str(row['user_id'])))\n        rankings[str(row['parent_id'])].append(ranking)\n    print(*[f'{k} : {v}' for (k, v) in rankings.items()], sep='\\n')\n    users = list(users)\n    messages = list(messages)\n    consensus = dict()\n    total_correlation = list()\n    for (k, v) in rankings.items():\n        common_set = set.intersection(*map(set, v))\n        v = [list(filter(lambda x: x in common_set, ids)) for ids in v]\n        merged_rankings = ranked_pairs(v)\n        consensus[k] = merged_rankings\n        ls = []\n        for (vote, id) in rankings_with_user[k]:\n            vote = list(filter(lambda x: x in common_set, vote))\n            ls.append((kendalltau(merged_rankings, vote), id))\n        rankings_with_user[k] = ls\n        total_correlation.extend(ls)\n    correlation_by_user = defaultdict(list)\n    for u in users:\n        for (c, m) in total_correlation:\n            if m == u:\n                correlation_by_user[u].append(c)\n    return (consensus, users, messages, rankings_with_user, correlation_by_user)",
            "def get_df():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Simple method that computes merged rankings and compares them to each user.\\n    Most interesting output for end-user is presumably the last that lists each user with their\\n    correlation to the mean ranking.\\n    Lower means less well aligned to the mean, higher means more well aligned.\\n    Note that rankings with fewer options are more likely to be wrong, so this could\\n    yield to misleading results:\\n    **You cannot use this for automatic flagging!**\\n    '\n    conn = psycopg2.connect('host=0.0.0.0 port=5432 user=postgres password=postgres dbname=postgres')\n    role = \"'assistant'\"\n    message_tree_id = None\n    query = f\"\\n        -- get all ranking results of completed tasks for all parents with >= 2 children\\n        SELECT DISTINCT p.parent_id, p.message_tree_id, mr.* FROM\\n        (\\n            -- find parents with > 1 children\\n            SELECT m.parent_id, m.message_tree_id, COUNT(m.id) children_count\\n            FROM message_tree_state mts\\n            INNER JOIN message m ON mts.message_tree_id = m.message_tree_id\\n            WHERE m.review_result                  -- must be reviewed\\n            AND NOT m.deleted                   -- not deleted\\n            AND m.parent_id IS NOT NULL         -- ignore initial prompts\\n            AND ({role} IS NULL OR m.role = {role}) -- children with matching role\\n            -- AND mts.message_tree_id = {message_tree_id}\\n            GROUP BY m.parent_id, m.message_tree_id\\n            HAVING COUNT(m.id) > 1\\n        ) as p\\n        LEFT JOIN task t ON p.parent_id = t.parent_message_id AND t.done AND (t.payload_type = 'RankPrompterRepliesPayload' OR t.payload_type = 'RankAssistantRepliesPayload')\\n        LEFT JOIN message_reaction mr ON mr.task_id = t.id AND mr.payload_type = 'RankingReactionPayload'\\n        \"\n    df = pd.read_sql(query, con=conn)\n    print(df[['message_tree_id', 'parent_id', 'payload']])\n    conn.close()\n    users = set()\n    messages = set()\n    rankings = defaultdict(list)\n    rankings_with_user = defaultdict(list)\n    for row in df.itertuples(index=False):\n        row = row._asdict()\n        users.add(str(row['user_id']))\n        messages.add(str(row['message_tree_id']))\n        if row['payload'] is None:\n            continue\n        ranking = row['payload']['payload']['ranked_message_ids']\n        rankings_with_user[str(row['parent_id'])].append((ranking, str(row['user_id'])))\n        rankings[str(row['parent_id'])].append(ranking)\n    print(*[f'{k} : {v}' for (k, v) in rankings.items()], sep='\\n')\n    users = list(users)\n    messages = list(messages)\n    consensus = dict()\n    total_correlation = list()\n    for (k, v) in rankings.items():\n        common_set = set.intersection(*map(set, v))\n        v = [list(filter(lambda x: x in common_set, ids)) for ids in v]\n        merged_rankings = ranked_pairs(v)\n        consensus[k] = merged_rankings\n        ls = []\n        for (vote, id) in rankings_with_user[k]:\n            vote = list(filter(lambda x: x in common_set, vote))\n            ls.append((kendalltau(merged_rankings, vote), id))\n        rankings_with_user[k] = ls\n        total_correlation.extend(ls)\n    correlation_by_user = defaultdict(list)\n    for u in users:\n        for (c, m) in total_correlation:\n            if m == u:\n                correlation_by_user[u].append(c)\n    return (consensus, users, messages, rankings_with_user, correlation_by_user)",
            "def get_df():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Simple method that computes merged rankings and compares them to each user.\\n    Most interesting output for end-user is presumably the last that lists each user with their\\n    correlation to the mean ranking.\\n    Lower means less well aligned to the mean, higher means more well aligned.\\n    Note that rankings with fewer options are more likely to be wrong, so this could\\n    yield to misleading results:\\n    **You cannot use this for automatic flagging!**\\n    '\n    conn = psycopg2.connect('host=0.0.0.0 port=5432 user=postgres password=postgres dbname=postgres')\n    role = \"'assistant'\"\n    message_tree_id = None\n    query = f\"\\n        -- get all ranking results of completed tasks for all parents with >= 2 children\\n        SELECT DISTINCT p.parent_id, p.message_tree_id, mr.* FROM\\n        (\\n            -- find parents with > 1 children\\n            SELECT m.parent_id, m.message_tree_id, COUNT(m.id) children_count\\n            FROM message_tree_state mts\\n            INNER JOIN message m ON mts.message_tree_id = m.message_tree_id\\n            WHERE m.review_result                  -- must be reviewed\\n            AND NOT m.deleted                   -- not deleted\\n            AND m.parent_id IS NOT NULL         -- ignore initial prompts\\n            AND ({role} IS NULL OR m.role = {role}) -- children with matching role\\n            -- AND mts.message_tree_id = {message_tree_id}\\n            GROUP BY m.parent_id, m.message_tree_id\\n            HAVING COUNT(m.id) > 1\\n        ) as p\\n        LEFT JOIN task t ON p.parent_id = t.parent_message_id AND t.done AND (t.payload_type = 'RankPrompterRepliesPayload' OR t.payload_type = 'RankAssistantRepliesPayload')\\n        LEFT JOIN message_reaction mr ON mr.task_id = t.id AND mr.payload_type = 'RankingReactionPayload'\\n        \"\n    df = pd.read_sql(query, con=conn)\n    print(df[['message_tree_id', 'parent_id', 'payload']])\n    conn.close()\n    users = set()\n    messages = set()\n    rankings = defaultdict(list)\n    rankings_with_user = defaultdict(list)\n    for row in df.itertuples(index=False):\n        row = row._asdict()\n        users.add(str(row['user_id']))\n        messages.add(str(row['message_tree_id']))\n        if row['payload'] is None:\n            continue\n        ranking = row['payload']['payload']['ranked_message_ids']\n        rankings_with_user[str(row['parent_id'])].append((ranking, str(row['user_id'])))\n        rankings[str(row['parent_id'])].append(ranking)\n    print(*[f'{k} : {v}' for (k, v) in rankings.items()], sep='\\n')\n    users = list(users)\n    messages = list(messages)\n    consensus = dict()\n    total_correlation = list()\n    for (k, v) in rankings.items():\n        common_set = set.intersection(*map(set, v))\n        v = [list(filter(lambda x: x in common_set, ids)) for ids in v]\n        merged_rankings = ranked_pairs(v)\n        consensus[k] = merged_rankings\n        ls = []\n        for (vote, id) in rankings_with_user[k]:\n            vote = list(filter(lambda x: x in common_set, vote))\n            ls.append((kendalltau(merged_rankings, vote), id))\n        rankings_with_user[k] = ls\n        total_correlation.extend(ls)\n    correlation_by_user = defaultdict(list)\n    for u in users:\n        for (c, m) in total_correlation:\n            if m == u:\n                correlation_by_user[u].append(c)\n    return (consensus, users, messages, rankings_with_user, correlation_by_user)",
            "def get_df():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Simple method that computes merged rankings and compares them to each user.\\n    Most interesting output for end-user is presumably the last that lists each user with their\\n    correlation to the mean ranking.\\n    Lower means less well aligned to the mean, higher means more well aligned.\\n    Note that rankings with fewer options are more likely to be wrong, so this could\\n    yield to misleading results:\\n    **You cannot use this for automatic flagging!**\\n    '\n    conn = psycopg2.connect('host=0.0.0.0 port=5432 user=postgres password=postgres dbname=postgres')\n    role = \"'assistant'\"\n    message_tree_id = None\n    query = f\"\\n        -- get all ranking results of completed tasks for all parents with >= 2 children\\n        SELECT DISTINCT p.parent_id, p.message_tree_id, mr.* FROM\\n        (\\n            -- find parents with > 1 children\\n            SELECT m.parent_id, m.message_tree_id, COUNT(m.id) children_count\\n            FROM message_tree_state mts\\n            INNER JOIN message m ON mts.message_tree_id = m.message_tree_id\\n            WHERE m.review_result                  -- must be reviewed\\n            AND NOT m.deleted                   -- not deleted\\n            AND m.parent_id IS NOT NULL         -- ignore initial prompts\\n            AND ({role} IS NULL OR m.role = {role}) -- children with matching role\\n            -- AND mts.message_tree_id = {message_tree_id}\\n            GROUP BY m.parent_id, m.message_tree_id\\n            HAVING COUNT(m.id) > 1\\n        ) as p\\n        LEFT JOIN task t ON p.parent_id = t.parent_message_id AND t.done AND (t.payload_type = 'RankPrompterRepliesPayload' OR t.payload_type = 'RankAssistantRepliesPayload')\\n        LEFT JOIN message_reaction mr ON mr.task_id = t.id AND mr.payload_type = 'RankingReactionPayload'\\n        \"\n    df = pd.read_sql(query, con=conn)\n    print(df[['message_tree_id', 'parent_id', 'payload']])\n    conn.close()\n    users = set()\n    messages = set()\n    rankings = defaultdict(list)\n    rankings_with_user = defaultdict(list)\n    for row in df.itertuples(index=False):\n        row = row._asdict()\n        users.add(str(row['user_id']))\n        messages.add(str(row['message_tree_id']))\n        if row['payload'] is None:\n            continue\n        ranking = row['payload']['payload']['ranked_message_ids']\n        rankings_with_user[str(row['parent_id'])].append((ranking, str(row['user_id'])))\n        rankings[str(row['parent_id'])].append(ranking)\n    print(*[f'{k} : {v}' for (k, v) in rankings.items()], sep='\\n')\n    users = list(users)\n    messages = list(messages)\n    consensus = dict()\n    total_correlation = list()\n    for (k, v) in rankings.items():\n        common_set = set.intersection(*map(set, v))\n        v = [list(filter(lambda x: x in common_set, ids)) for ids in v]\n        merged_rankings = ranked_pairs(v)\n        consensus[k] = merged_rankings\n        ls = []\n        for (vote, id) in rankings_with_user[k]:\n            vote = list(filter(lambda x: x in common_set, vote))\n            ls.append((kendalltau(merged_rankings, vote), id))\n        rankings_with_user[k] = ls\n        total_correlation.extend(ls)\n    correlation_by_user = defaultdict(list)\n    for u in users:\n        for (c, m) in total_correlation:\n            if m == u:\n                correlation_by_user[u].append(c)\n    return (consensus, users, messages, rankings_with_user, correlation_by_user)"
        ]
    }
]