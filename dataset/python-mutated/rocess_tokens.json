[
    {
        "func_name": "__init__",
        "original": "def __init__(self, in_file, exception_handler, bug_handler, copy=None, run_level=1):\n    self.__file = in_file\n    self.__bug_handler = bug_handler\n    self.__copy = copy\n    self.__run_level = run_level\n    self.__write_to = better_mktemp()\n    self.initiate_token_dict()\n    self.compile_expressions()\n    self.__bracket_count = 0\n    self.__exception_handler = exception_handler\n    self.__bug_handler = bug_handler",
        "mutated": [
            "def __init__(self, in_file, exception_handler, bug_handler, copy=None, run_level=1):\n    if False:\n        i = 10\n    self.__file = in_file\n    self.__bug_handler = bug_handler\n    self.__copy = copy\n    self.__run_level = run_level\n    self.__write_to = better_mktemp()\n    self.initiate_token_dict()\n    self.compile_expressions()\n    self.__bracket_count = 0\n    self.__exception_handler = exception_handler\n    self.__bug_handler = bug_handler",
            "def __init__(self, in_file, exception_handler, bug_handler, copy=None, run_level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__file = in_file\n    self.__bug_handler = bug_handler\n    self.__copy = copy\n    self.__run_level = run_level\n    self.__write_to = better_mktemp()\n    self.initiate_token_dict()\n    self.compile_expressions()\n    self.__bracket_count = 0\n    self.__exception_handler = exception_handler\n    self.__bug_handler = bug_handler",
            "def __init__(self, in_file, exception_handler, bug_handler, copy=None, run_level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__file = in_file\n    self.__bug_handler = bug_handler\n    self.__copy = copy\n    self.__run_level = run_level\n    self.__write_to = better_mktemp()\n    self.initiate_token_dict()\n    self.compile_expressions()\n    self.__bracket_count = 0\n    self.__exception_handler = exception_handler\n    self.__bug_handler = bug_handler",
            "def __init__(self, in_file, exception_handler, bug_handler, copy=None, run_level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__file = in_file\n    self.__bug_handler = bug_handler\n    self.__copy = copy\n    self.__run_level = run_level\n    self.__write_to = better_mktemp()\n    self.initiate_token_dict()\n    self.compile_expressions()\n    self.__bracket_count = 0\n    self.__exception_handler = exception_handler\n    self.__bug_handler = bug_handler",
            "def __init__(self, in_file, exception_handler, bug_handler, copy=None, run_level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__file = in_file\n    self.__bug_handler = bug_handler\n    self.__copy = copy\n    self.__run_level = run_level\n    self.__write_to = better_mktemp()\n    self.initiate_token_dict()\n    self.compile_expressions()\n    self.__bracket_count = 0\n    self.__exception_handler = exception_handler\n    self.__bug_handler = bug_handler"
        ]
    },
    {
        "func_name": "compile_expressions",
        "original": "def compile_expressions(self):\n    self.__num_exp = re.compile('([a-zA-Z]+)(.*)')\n    self.__utf_exp = re.compile('(&.*?;)')",
        "mutated": [
            "def compile_expressions(self):\n    if False:\n        i = 10\n    self.__num_exp = re.compile('([a-zA-Z]+)(.*)')\n    self.__utf_exp = re.compile('(&.*?;)')",
            "def compile_expressions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__num_exp = re.compile('([a-zA-Z]+)(.*)')\n    self.__utf_exp = re.compile('(&.*?;)')",
            "def compile_expressions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__num_exp = re.compile('([a-zA-Z]+)(.*)')\n    self.__utf_exp = re.compile('(&.*?;)')",
            "def compile_expressions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__num_exp = re.compile('([a-zA-Z]+)(.*)')\n    self.__utf_exp = re.compile('(&.*?;)')",
            "def compile_expressions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__num_exp = re.compile('([a-zA-Z]+)(.*)')\n    self.__utf_exp = re.compile('(&.*?;)')"
        ]
    },
    {
        "func_name": "initiate_token_dict",
        "original": "def initiate_token_dict(self):\n    self.__return_code = 0\n    self.dict_token = {'mshex': ('nu', '__________', self.__ms_hex_func), '{': ('nu', '{', self.ob_func), '}': ('nu', '}', self.cb_func), 'ldblquote': ('mc', 'ldblquote', self.ms_sub_func), 'rdblquote': ('mc', 'rdblquote', self.ms_sub_func), 'rquote': ('mc', 'rquote', self.ms_sub_func), 'lquote': ('mc', 'lquote', self.ms_sub_func), 'emdash': ('mc', 'emdash', self.ms_sub_func), 'endash': ('mc', 'endash', self.ms_sub_func), 'bullet': ('mc', 'bullet', self.ms_sub_func), '~': ('mc', '~', self.ms_sub_func), 'tab': ('mc', 'tab', self.ms_sub_func), '_': ('mc', '_', self.ms_sub_func), ';': ('mc', ';', self.ms_sub_func), '-': ('mc', '-', self.ms_sub_func), 'line': ('mi', 'hardline-break', self.direct_conv_func), '*': ('ml', 'asterisk__', self.default_func), ':': ('ml', 'colon_____', self.default_func), 'backslash': ('nu', '\\\\', self.text_func), 'ob': ('nu', '{', self.text_func), 'cb': ('nu', '}', self.text_func), 'page': ('pf', 'page-break', self.default_func), 'par': ('pf', 'par-end___', self.default_func), 'pard': ('pf', 'par-def___', self.default_func), 'keepn': ('pf', 'keep-w-nex', self.bool_st_func), 'widctlpar': ('pf', 'widow-cntl', self.bool_st_func), 'adjustright': ('pf', 'adjust-rgt', self.bool_st_func), 'lang': ('pf', 'language__', self.__language_func), 'ri': ('pf', 'right-inde', self.divide_by_20), 'fi': ('pf', 'fir-ln-ind', self.divide_by_20), 'li': ('pf', 'left-inden', self.divide_by_20), 'sb': ('pf', 'space-befo', self.divide_by_20), 'sa': ('pf', 'space-afte', self.divide_by_20), 'sl': ('pf', 'line-space', self.divide_by_20), 'deftab': ('pf', 'default-ta', self.divide_by_20), 'ql': ('pf', 'align_____<left', self.two_part_func), 'qc': ('pf', 'align_____<cent', self.two_part_func), 'qj': ('pf', 'align_____<just', self.two_part_func), 'qr': ('pf', 'align_____<right', self.two_part_func), 'nowidctlpar': ('pf', 'widow-cntr<false', self.two_part_func), 'tx': ('pf', 'tab-stop__', self.divide_by_20), 'tb': ('pf', 'tab-bar-st', self.divide_by_20), 'tqr': ('pf', 'tab-right_', self.default_func), 'tqdec': ('pf', 'tab-dec___', self.default_func), 'tqc': ('pf', 'tab-center', self.default_func), 'tlul': ('pf', 'leader-und', self.default_func), 'tlhyph': ('pf', 'leader-hyp', self.default_func), 'tldot': ('pf', 'leader-dot', self.default_func), 'stylesheet': ('ss', 'style-shet', self.default_func), 'sbasedon': ('ss', 'based-on__', self.default_func), 'snext': ('ss', 'next-style', self.default_func), 'cs': ('ss', 'char-style', self.default_func), 's': ('ss', 'para-style', self.default_func), 'pict': ('gr', 'picture___', self.default_func), 'objclass': ('gr', 'obj-class_', self.default_func), 'macpict': ('gr', 'mac-pic___', self.default_func), 'sect': ('sc', 'section___', self.default_func), 'sectd': ('sc', 'sect-defin', self.default_func), 'endhere': ('sc', 'sect-note_', self.default_func), 'pntext': ('ls', 'list-text_', self.default_func), 'listtext': ('ls', 'list-text_', self.default_func), 'pn': ('ls', 'list______', self.default_func), 'pnseclvl': ('ls', 'list-level', self.default_func), 'pncard': ('ls', 'list-cardi', self.bool_st_func), 'pndec': ('ls', 'list-decim', self.bool_st_func), 'pnucltr': ('ls', 'list-up-al', self.bool_st_func), 'pnucrm': ('ls', 'list-up-ro', self.bool_st_func), 'pnord': ('ls', 'list-ord__', self.bool_st_func), 'pnordt': ('ls', 'list-ordte', self.bool_st_func), 'pnlvlblt': ('ls', 'list-bulli', self.bool_st_func), 'pnlvlbody': ('ls', 'list-simpi', self.bool_st_func), 'pnlvlcont': ('ls', 'list-conti', self.bool_st_func), 'pnhang': ('ls', 'list-hang_', self.bool_st_func), 'pntxtb': ('ls', 'list-tebef', self.bool_st_func), 'ilvl': ('ls', 'list-level', self.default_func), 'ls': ('ls', 'list-id___', self.default_func), 'pnstart': ('ls', 'list-start', self.default_func), 'itap': ('ls', 'nest-level', self.default_func), 'leveltext': ('ls', 'level-text', self.default_func), 'levelnumbers': ('ls', 'level-numb', self.default_func), 'list': ('ls', 'list-in-tb', self.default_func), 'listlevel': ('ls', 'list-tb-le', self.default_func), 'listname': ('ls', 'list-name_', self.default_func), 'listtemplateid': ('ls', 'ls-tem-id_', self.default_func), 'leveltemplateid': ('ls', 'lv-tem-id_', self.default_func), 'listhybrid': ('ls', 'list-hybri', self.default_func), 'levelstartat': ('ls', 'level-star', self.default_func), 'levelspace': ('ls', 'level-spac', self.divide_by_20), 'levelindent': ('ls', 'level-inde', self.default_func), 'levelnfc': ('ls', 'level-type', self.__list_type_func), 'levelnfcn': ('ls', 'level-type', self.__list_type_func), 'listid': ('ls', 'lis-tbl-id', self.default_func), 'listoverride': ('ls', 'lis-overid', self.default_func), 'pnlvl': ('ls', 'list-level', self.default_func), 'rtf': ('ri', 'rtf_______', self.default_func), 'deff': ('ri', 'deflt-font', self.default_func), 'mac': ('ri', 'macintosh_', self.default_func), 'pc': ('ri', 'pc________', self.default_func), 'pca': ('ri', 'pca_______', self.default_func), 'ansi': ('ri', 'ansi______', self.default_func), 'ansicpg': ('ri', 'ansi-codpg', self.default_func), 'footnote': ('nt', 'footnote__', self.default_func), 'ftnalt': ('nt', 'type______<endnote', self.two_part_func), 'tc': ('an', 'toc_______', self.default_func), 'bkmkstt': ('an', 'book-mk-st', self.default_func), 'bkmkstart': ('an', 'book-mk-st', self.default_func), 'bkmkend': ('an', 'book-mk-en', self.default_func), 'xe': ('an', 'index-mark', self.default_func), 'rxe': ('an', 'place_____', self.default_func), 'bxe': ('in', 'index-bold', self.default_func), 'ixe': ('in', 'index-ital', self.default_func), 'txe': ('in', 'index-see_', self.default_func), 'tcl': ('tc', 'toc-level_', self.default_func), 'tcn': ('tc', 'toc-sup-nu', self.default_func), 'field': ('fd', 'field_____', self.default_func), 'fldinst': ('fd', 'field-inst', self.default_func), 'fldrslt': ('fd', 'field-rslt', self.default_func), 'datafield': ('fd', 'datafield_', self.default_func), 'fonttbl': ('it', 'font-table', self.default_func), 'colortbl': ('it', 'colr-table', self.default_func), 'listoverridetable': ('it', 'lovr-table', self.default_func), 'listtable': ('it', 'listtable_', self.default_func), 'revtbl': ('it', 'revi-table', self.default_func), 'b': ('ci', 'bold______', self.bool_st_func), 'blue': ('ci', 'blue______', self.color_func), 'caps': ('ci', 'caps______', self.bool_st_func), 'cf': ('ci', 'font-color', self.colorz_func), 'chftn': ('ci', 'footnot-mk', self.bool_st_func), 'dn': ('ci', 'font-down_', self.divide_by_2), 'embo': ('ci', 'emboss____', self.bool_st_func), 'f': ('ci', 'font-style', self.default_func), 'fs': ('ci', 'font-size_', self.divide_by_2), 'green': ('ci', 'green_____', self.color_func), 'i': ('ci', 'italics___', self.bool_st_func), 'impr': ('ci', 'engrave___', self.bool_st_func), 'outl': ('ci', 'outline___', self.bool_st_func), 'plain': ('ci', 'plain_____', self.bool_st_func), 'red': ('ci', 'red_______', self.color_func), 'scaps': ('ci', 'small-caps', self.bool_st_func), 'shad': ('ci', 'shadow____', self.bool_st_func), 'strike': ('ci', 'strike-thr', self.bool_st_func), 'striked': ('ci', 'dbl-strike', self.bool_st_func), 'sub': ('ci', 'subscript_', self.bool_st_func), 'super': ('ci', 'superscrip', self.bool_st_func), 'nosupersub': ('ci', 'no-su-supe', self.__no_sup_sub_func), 'up': ('ci', 'font-up___', self.divide_by_2), 'v': ('ci', 'hidden____', self.default_func), 'ul': ('ci', 'underlined<continous', self.two_part_func), 'uld': ('ci', 'underlined<dotted', self.two_part_func), 'uldash': ('ci', 'underlined<dash', self.two_part_func), 'uldashd': ('ci', 'underlined<dash-dot', self.two_part_func), 'uldashdd': ('ci', 'underlined<dash-dot-dot', self.two_part_func), 'uldb': ('ci', 'underlined<double', self.two_part_func), 'ulhwave': ('ci', 'underlined<heavy-wave', self.two_part_func), 'ulldash': ('ci', 'underlined<long-dash', self.two_part_func), 'ulth': ('ci', 'underlined<thich', self.two_part_func), 'ulthd': ('ci', 'underlined<thick-dotted', self.two_part_func), 'ulthdash': ('ci', 'underlined<thick-dash', self.two_part_func), 'ulthdashd': ('ci', 'underlined<thick-dash-dot', self.two_part_func), 'ulthdashdd': ('ci', 'underlined<thick-dash-dot-dot', self.two_part_func), 'ulthldash': ('ci', 'underlined<thick-long-dash', self.two_part_func), 'ululdbwave': ('ci', 'underlined<double-wave', self.two_part_func), 'ulw': ('ci', 'underlined<word', self.two_part_func), 'ulwave': ('ci', 'underlined<wave', self.two_part_func), 'ulnone': ('ci', 'underlined<false', self.two_part_func), 'trowd': ('tb', 'row-def___', self.default_func), 'cell': ('tb', 'cell______', self.default_func), 'row': ('tb', 'row_______', self.default_func), 'intbl': ('tb', 'in-table__', self.default_func), 'cols': ('tb', 'columns___', self.default_func), 'trleft': ('tb', 'row-pos-le', self.divide_by_20), 'cellx': ('tb', 'cell-posit', self.divide_by_20), 'trhdr': ('tb', 'row-header', self.default_func), 'info': ('di', 'doc-info__', self.default_func), 'title': ('di', 'title_____', self.default_func), 'author': ('di', 'author____', self.default_func), 'operator': ('di', 'operator__', self.default_func), 'manager': ('di', 'manager___', self.default_func), 'company': ('di', 'company___', self.default_func), 'keywords': ('di', 'keywords__', self.default_func), 'category': ('di', 'category__', self.default_func), 'doccomm': ('di', 'doc-notes_', self.default_func), 'comment': ('di', 'doc-notes_', self.default_func), 'subject': ('di', 'subject___', self.default_func), 'creatim': ('di', 'create-tim', self.default_func), 'yr': ('di', 'year______', self.default_func), 'mo': ('di', 'month_____', self.default_func), 'dy': ('di', 'day_______', self.default_func), 'min': ('di', 'minute____', self.default_func), 'sec': ('di', 'second____', self.default_func), 'revtim': ('di', 'revis-time', self.default_func), 'edmins': ('di', 'edit-time_', self.default_func), 'printim': ('di', 'print-time', self.default_func), 'buptim': ('di', 'backuptime', self.default_func), 'nofwords': ('di', 'num-of-wor', self.default_func), 'nofchars': ('di', 'num-of-chr', self.default_func), 'nofcharsws': ('di', 'numofchrws', self.default_func), 'nofpages': ('di', 'num-of-pag', self.default_func), 'version': ('di', 'version___', self.default_func), 'vern': ('di', 'intern-ver', self.default_func), 'hlinkbase': ('di', 'linkbase__', self.default_func), 'id': ('di', 'internalID', self.default_func), 'headerf': ('hf', 'head-first', self.default_func), 'headerl': ('hf', 'head-left_', self.default_func), 'headerr': ('hf', 'head-right', self.default_func), 'footerf': ('hf', 'foot-first', self.default_func), 'footerl': ('hf', 'foot-left_', self.default_func), 'footerr': ('hf', 'foot-right', self.default_func), 'header': ('hf', 'header____', self.default_func), 'footer': ('hf', 'footer____', self.default_func), 'margl': ('pa', 'margin-lef', self.divide_by_20), 'margr': ('pa', 'margin-rig', self.divide_by_20), 'margb': ('pa', 'margin-bot', self.divide_by_20), 'margt': ('pa', 'margin-top', self.divide_by_20), 'gutter': ('pa', 'gutter____', self.divide_by_20), 'paperw': ('pa', 'paper-widt', self.divide_by_20), 'paperh': ('pa', 'paper-hght', self.divide_by_20), 'annotation': ('an', 'annotation', self.default_func), 'trbrdrh': ('bd', 'bor-t-r-hi', self.default_func), 'trbrdrv': ('bd', 'bor-t-r-vi', self.default_func), 'trbrdrt': ('bd', 'bor-t-r-to', self.default_func), 'trbrdrl': ('bd', 'bor-t-r-le', self.default_func), 'trbrdrb': ('bd', 'bor-t-r-bo', self.default_func), 'trbrdrr': ('bd', 'bor-t-r-ri', self.default_func), 'clbrdrb': ('bd', 'bor-cel-bo', self.default_func), 'clbrdrt': ('bd', 'bor-cel-to', self.default_func), 'clbrdrl': ('bd', 'bor-cel-le', self.default_func), 'clbrdrr': ('bd', 'bor-cel-ri', self.default_func), 'brdrb': ('bd', 'bor-par-bo', self.default_func), 'brdrt': ('bd', 'bor-par-to', self.default_func), 'brdrl': ('bd', 'bor-par-le', self.default_func), 'brdrr': ('bd', 'bor-par-ri', self.default_func), 'box': ('bd', 'bor-par-bx', self.default_func), 'chbrdr': ('bd', 'bor-par-bo', self.default_func), 'brdrbtw': ('bd', 'bor-for-ev', self.default_func), 'brdrbar': ('bd', 'bor-outsid', self.default_func), 'brdrnone': ('bd', 'bor-none__<false', self.two_part_func), 'brdrs': ('bt', 'bdr-single', self.default_func), 'brdrth': ('bt', 'bdr-doubtb', self.default_func), 'brdrsh': ('bt', 'bdr-shadow', self.default_func), 'brdrdb': ('bt', 'bdr-double', self.default_func), 'brdrdot': ('bt', 'bdr-dotted', self.default_func), 'brdrdash': ('bt', 'bdr-dashed', self.default_func), 'brdrhair': ('bt', 'bdr-hair__', self.default_func), 'brdrinset': ('bt', 'bdr-inset_', self.default_func), 'brdrdashsm': ('bt', 'bdr-das-sm', self.default_func), 'brdrdashd': ('bt', 'bdr-dot-sm', self.default_func), 'brdrdashdd': ('bt', 'bdr-dot-do', self.default_func), 'brdroutset': ('bt', 'bdr-outset', self.default_func), 'brdrtriple': ('bt', 'bdr-trippl', self.default_func), 'brdrtnthsg': ('bt', 'bdr-thsm__', self.default_func), 'brdrthtnsg': ('bt', 'bdr-htsm__', self.default_func), 'brdrtnthtnsg': ('bt', 'bdr-hthsm_', self.default_func), 'brdrtnthmg': ('bt', 'bdr-thm___', self.default_func), 'brdrthtnmg': ('bt', 'bdr-htm___', self.default_func), 'brdrtnthtnmg': ('bt', 'bdr-hthm__', self.default_func), 'brdrtnthlg': ('bt', 'bdr-thl___', self.default_func), 'brdrtnthtnlg': ('bt', 'bdr-hthl__', self.default_func), 'brdrwavy': ('bt', 'bdr-wavy__', self.default_func), 'brdrwavydb': ('bt', 'bdr-d-wav_', self.default_func), 'brdrdashdotstr': ('bt', 'bdr-strip_', self.default_func), 'brdremboss': ('bt', 'bdr-embos_', self.default_func), 'brdrengrave': ('bt', 'bdr-engra_', self.default_func), 'brdrframe': ('bt', 'bdr-frame_', self.default_func), 'brdrw': ('bt', 'bdr-li-wid', self.divide_by_20), 'brsp': ('bt', 'bdr-sp-wid', self.divide_by_20), 'brdrcf': ('bt', 'bdr-color_', self.default_func)}\n    self.__number_type_dict = {0: 'Arabic', 1: 'uppercase Roman numeral', 2: 'lowercase Roman numeral', 3: 'uppercase letter', 4: 'lowercase letter', 5: 'ordinal number', 6: 'cardianl text number', 7: 'ordinal text number', 10: 'Kanji numbering without the digit character', 11: 'Kanji numbering with the digit character', 1246: 'phonetic Katakana characters in aiueo order', 1346: 'phonetic katakana characters in iroha order', 14: 'double byte character', 15: 'single byte character', 16: 'Kanji numbering 3', 17: 'Kanji numbering 4', 18: 'Circle numbering', 19: 'double-byte Arabic numbering', 2046: 'phonetic double-byte Katakana characters', 2146: 'phonetic double-byte katakana characters', 22: 'Arabic with leading zero', 23: 'bullet', 24: 'Korean numbering 2', 25: 'Korean numbering 1', 26: 'Chinese numbering 1', 27: 'Chinese numbering 2', 28: 'Chinese numbering 3', 29: 'Chinese numbering 4', 30: 'Chinese Zodiac numbering 1', 31: 'Chinese Zodiac numbering 2', 32: 'Chinese Zodiac numbering 3', 33: 'Taiwanese double-byte numbering 1', 34: 'Taiwanese double-byte numbering 2', 35: 'Taiwanese double-byte numbering 3', 36: 'Taiwanese double-byte numbering 4', 37: 'Chinese double-byte numbering 1', 38: 'Chinese double-byte numbering 2', 39: 'Chinese double-byte numbering 3', 40: 'Chinese double-byte numbering 4', 41: 'Korean double-byte numbering 1', 42: 'Korean double-byte numbering 2', 43: 'Korean double-byte numbering 3', 44: 'Korean double-byte numbering 4', 45: 'Hebrew non-standard decimal', 46: 'Arabic Alif Ba Tah', 47: 'Hebrew Biblical standard', 48: 'Arabic Abjad style', 255: 'No number'}\n    self.__language_dict = {1078: 'Afrikaans', 1052: 'Albanian', 1025: 'Arabic', 5121: 'Arabic Algeria', 15361: 'Arabic Bahrain', 3073: 'Arabic Egypt', 1: 'Arabic General', 2049: 'Arabic Iraq', 11265: 'Arabic Jordan', 13313: 'Arabic Kuwait', 12289: 'Arabic Lebanon', 4097: 'Arabic Libya', 6145: 'Arabic Morocco', 8193: 'Arabic Oman', 16385: 'Arabic Qatar', 10241: 'Arabic Syria', 7169: 'Arabic Tunisia', 14337: 'Arabic U.A.E.', 9217: 'Arabic Yemen', 1067: 'Armenian', 1101: 'Assamese', 2092: 'Azeri Cyrillic', 1068: 'Azeri Latin', 1069: 'Basque', 1093: 'Bengali', 4122: 'Bosnia Herzegovina', 1026: 'Bulgarian', 1109: 'Burmese', 1059: 'Byelorussian', 1027: 'Catalan', 2052: 'Chinese China', 4: 'Chinese General', 3076: 'Chinese Hong Kong', 4100: 'Chinese Singapore', 1028: 'Chinese Taiwan', 1050: 'Croatian', 1029: 'Czech', 1030: 'Danish', 2067: 'Dutch Belgium', 1043: 'Dutch Standard', 3081: 'English Australia', 10249: 'English Belize', 2057: 'English British', 4105: 'English Canada', 9225: 'English Caribbean', 9: 'English General', 6153: 'English Ireland', 8201: 'English Jamaica', 5129: 'English New Zealand', 13321: 'English Philippines', 7177: 'English South Africa', 11273: 'English Trinidad', 1033: 'English United States', 1061: 'Estonian', 1080: 'Faerose', 1065: 'Farsi', 1035: 'Finnish', 1036: 'French', 2060: 'French Belgium', 11276: 'French Cameroon', 3084: 'French Canada', 12300: \"French Cote d'Ivoire\", 5132: 'French Luxembourg', 13324: 'French Mali', 6156: 'French Monaco', 8204: 'French Reunion', 10252: 'French Senegal', 4108: 'French Swiss', 7180: 'French West Indies', 9228: 'French Democratic Republic of the Congo', 1122: 'Frisian', 1084: 'Gaelic', 2108: 'Gaelic Ireland', 1110: 'Galician', 1079: 'Georgian', 1031: 'German', 3079: 'German Austrian', 5127: 'German Liechtenstein', 4103: 'German Luxembourg', 2055: 'German Switzerland', 1032: 'Greek', 1095: 'Gujarati', 1037: 'Hebrew', 1081: 'Hindi', 1038: 'Hungarian', 1039: 'Icelandic', 1057: 'Indonesian', 1040: 'Italian', 2064: 'Italian Switzerland', 1041: 'Japanese', 1099: 'Kannada', 1120: 'Kashmiri', 2144: 'Kashmiri India', 1087: 'Kazakh', 1107: 'Khmer', 1088: 'Kirghiz', 1111: 'Konkani', 1042: 'Korean', 2066: 'Korean Johab', 1108: 'Lao', 1062: 'Latvian', 1063: 'Lithuanian', 2087: 'Lithuanian Classic', 1086: 'Malay', 2110: 'Malay Brunei Darussalam', 1100: 'Malayalam', 1082: 'Maltese', 1112: 'Manipuri', 1102: 'Marathi', 1104: 'Mongolian', 1121: 'Nepali', 2145: 'Nepali India', 1044: 'Norwegian Bokmal', 2068: 'Norwegian Nynorsk', 1096: 'Oriya', 1045: 'Polish', 1046: 'Portuguese (Brazil)', 2070: 'Portuguese (Portugal)', 1094: 'Punjabi', 1047: 'Rhaeto-Romanic', 1048: 'Romanian', 2072: 'Romanian Moldova', 1049: 'Russian', 2073: 'Russian Moldova', 1083: 'Sami Lappish', 1103: 'Sanskrit', 3098: 'Serbian Cyrillic', 2074: 'Serbian Latin', 1113: 'Sindhi', 1051: 'Slovak', 1060: 'Slovenian', 1070: 'Sorbian', 11274: 'Spanish Argentina', 16394: 'Spanish Bolivia', 13322: 'Spanish Chile', 9226: 'Spanish Colombia', 5130: 'Spanish Costa Rica', 7178: 'Spanish Dominican Republic', 12298: 'Spanish Ecuador', 17418: 'Spanish El Salvador', 4106: 'Spanish Guatemala', 18442: 'Spanish Honduras', 2058: 'Spanish Mexico', 3082: 'Spanish Modern', 19466: 'Spanish Nicaragua', 6154: 'Spanish Panama', 15370: 'Spanish Paraguay', 10250: 'Spanish Peru', 20490: 'Spanish Puerto Rico', 1034: 'Spanish Traditional', 14346: 'Spanish Uruguay', 8202: 'Spanish Venezuela', 1072: 'Sutu', 1089: 'Swahili', 1053: 'Swedish', 2077: 'Swedish Finland', 1064: 'Tajik', 1097: 'Tamil', 1092: 'Tatar', 1098: 'Telugu', 1054: 'Thai', 1105: 'Tibetan', 1073: 'Tsonga', 1074: 'Tswana', 1055: 'Turkish', 1090: 'Turkmen', 1058: 'Ukranian', 1056: 'Urdu', 2080: 'Urdu India', 2115: 'Uzbek Cyrillic', 1091: 'Uzbek Latin', 1075: 'Venda', 1066: 'Vietnamese', 1106: 'Welsh', 1076: 'Xhosa', 1085: 'Yiddish', 1077: 'Zulu', 1024: 'Unkown', 255: 'Unkown'}",
        "mutated": [
            "def initiate_token_dict(self):\n    if False:\n        i = 10\n    self.__return_code = 0\n    self.dict_token = {'mshex': ('nu', '__________', self.__ms_hex_func), '{': ('nu', '{', self.ob_func), '}': ('nu', '}', self.cb_func), 'ldblquote': ('mc', 'ldblquote', self.ms_sub_func), 'rdblquote': ('mc', 'rdblquote', self.ms_sub_func), 'rquote': ('mc', 'rquote', self.ms_sub_func), 'lquote': ('mc', 'lquote', self.ms_sub_func), 'emdash': ('mc', 'emdash', self.ms_sub_func), 'endash': ('mc', 'endash', self.ms_sub_func), 'bullet': ('mc', 'bullet', self.ms_sub_func), '~': ('mc', '~', self.ms_sub_func), 'tab': ('mc', 'tab', self.ms_sub_func), '_': ('mc', '_', self.ms_sub_func), ';': ('mc', ';', self.ms_sub_func), '-': ('mc', '-', self.ms_sub_func), 'line': ('mi', 'hardline-break', self.direct_conv_func), '*': ('ml', 'asterisk__', self.default_func), ':': ('ml', 'colon_____', self.default_func), 'backslash': ('nu', '\\\\', self.text_func), 'ob': ('nu', '{', self.text_func), 'cb': ('nu', '}', self.text_func), 'page': ('pf', 'page-break', self.default_func), 'par': ('pf', 'par-end___', self.default_func), 'pard': ('pf', 'par-def___', self.default_func), 'keepn': ('pf', 'keep-w-nex', self.bool_st_func), 'widctlpar': ('pf', 'widow-cntl', self.bool_st_func), 'adjustright': ('pf', 'adjust-rgt', self.bool_st_func), 'lang': ('pf', 'language__', self.__language_func), 'ri': ('pf', 'right-inde', self.divide_by_20), 'fi': ('pf', 'fir-ln-ind', self.divide_by_20), 'li': ('pf', 'left-inden', self.divide_by_20), 'sb': ('pf', 'space-befo', self.divide_by_20), 'sa': ('pf', 'space-afte', self.divide_by_20), 'sl': ('pf', 'line-space', self.divide_by_20), 'deftab': ('pf', 'default-ta', self.divide_by_20), 'ql': ('pf', 'align_____<left', self.two_part_func), 'qc': ('pf', 'align_____<cent', self.two_part_func), 'qj': ('pf', 'align_____<just', self.two_part_func), 'qr': ('pf', 'align_____<right', self.two_part_func), 'nowidctlpar': ('pf', 'widow-cntr<false', self.two_part_func), 'tx': ('pf', 'tab-stop__', self.divide_by_20), 'tb': ('pf', 'tab-bar-st', self.divide_by_20), 'tqr': ('pf', 'tab-right_', self.default_func), 'tqdec': ('pf', 'tab-dec___', self.default_func), 'tqc': ('pf', 'tab-center', self.default_func), 'tlul': ('pf', 'leader-und', self.default_func), 'tlhyph': ('pf', 'leader-hyp', self.default_func), 'tldot': ('pf', 'leader-dot', self.default_func), 'stylesheet': ('ss', 'style-shet', self.default_func), 'sbasedon': ('ss', 'based-on__', self.default_func), 'snext': ('ss', 'next-style', self.default_func), 'cs': ('ss', 'char-style', self.default_func), 's': ('ss', 'para-style', self.default_func), 'pict': ('gr', 'picture___', self.default_func), 'objclass': ('gr', 'obj-class_', self.default_func), 'macpict': ('gr', 'mac-pic___', self.default_func), 'sect': ('sc', 'section___', self.default_func), 'sectd': ('sc', 'sect-defin', self.default_func), 'endhere': ('sc', 'sect-note_', self.default_func), 'pntext': ('ls', 'list-text_', self.default_func), 'listtext': ('ls', 'list-text_', self.default_func), 'pn': ('ls', 'list______', self.default_func), 'pnseclvl': ('ls', 'list-level', self.default_func), 'pncard': ('ls', 'list-cardi', self.bool_st_func), 'pndec': ('ls', 'list-decim', self.bool_st_func), 'pnucltr': ('ls', 'list-up-al', self.bool_st_func), 'pnucrm': ('ls', 'list-up-ro', self.bool_st_func), 'pnord': ('ls', 'list-ord__', self.bool_st_func), 'pnordt': ('ls', 'list-ordte', self.bool_st_func), 'pnlvlblt': ('ls', 'list-bulli', self.bool_st_func), 'pnlvlbody': ('ls', 'list-simpi', self.bool_st_func), 'pnlvlcont': ('ls', 'list-conti', self.bool_st_func), 'pnhang': ('ls', 'list-hang_', self.bool_st_func), 'pntxtb': ('ls', 'list-tebef', self.bool_st_func), 'ilvl': ('ls', 'list-level', self.default_func), 'ls': ('ls', 'list-id___', self.default_func), 'pnstart': ('ls', 'list-start', self.default_func), 'itap': ('ls', 'nest-level', self.default_func), 'leveltext': ('ls', 'level-text', self.default_func), 'levelnumbers': ('ls', 'level-numb', self.default_func), 'list': ('ls', 'list-in-tb', self.default_func), 'listlevel': ('ls', 'list-tb-le', self.default_func), 'listname': ('ls', 'list-name_', self.default_func), 'listtemplateid': ('ls', 'ls-tem-id_', self.default_func), 'leveltemplateid': ('ls', 'lv-tem-id_', self.default_func), 'listhybrid': ('ls', 'list-hybri', self.default_func), 'levelstartat': ('ls', 'level-star', self.default_func), 'levelspace': ('ls', 'level-spac', self.divide_by_20), 'levelindent': ('ls', 'level-inde', self.default_func), 'levelnfc': ('ls', 'level-type', self.__list_type_func), 'levelnfcn': ('ls', 'level-type', self.__list_type_func), 'listid': ('ls', 'lis-tbl-id', self.default_func), 'listoverride': ('ls', 'lis-overid', self.default_func), 'pnlvl': ('ls', 'list-level', self.default_func), 'rtf': ('ri', 'rtf_______', self.default_func), 'deff': ('ri', 'deflt-font', self.default_func), 'mac': ('ri', 'macintosh_', self.default_func), 'pc': ('ri', 'pc________', self.default_func), 'pca': ('ri', 'pca_______', self.default_func), 'ansi': ('ri', 'ansi______', self.default_func), 'ansicpg': ('ri', 'ansi-codpg', self.default_func), 'footnote': ('nt', 'footnote__', self.default_func), 'ftnalt': ('nt', 'type______<endnote', self.two_part_func), 'tc': ('an', 'toc_______', self.default_func), 'bkmkstt': ('an', 'book-mk-st', self.default_func), 'bkmkstart': ('an', 'book-mk-st', self.default_func), 'bkmkend': ('an', 'book-mk-en', self.default_func), 'xe': ('an', 'index-mark', self.default_func), 'rxe': ('an', 'place_____', self.default_func), 'bxe': ('in', 'index-bold', self.default_func), 'ixe': ('in', 'index-ital', self.default_func), 'txe': ('in', 'index-see_', self.default_func), 'tcl': ('tc', 'toc-level_', self.default_func), 'tcn': ('tc', 'toc-sup-nu', self.default_func), 'field': ('fd', 'field_____', self.default_func), 'fldinst': ('fd', 'field-inst', self.default_func), 'fldrslt': ('fd', 'field-rslt', self.default_func), 'datafield': ('fd', 'datafield_', self.default_func), 'fonttbl': ('it', 'font-table', self.default_func), 'colortbl': ('it', 'colr-table', self.default_func), 'listoverridetable': ('it', 'lovr-table', self.default_func), 'listtable': ('it', 'listtable_', self.default_func), 'revtbl': ('it', 'revi-table', self.default_func), 'b': ('ci', 'bold______', self.bool_st_func), 'blue': ('ci', 'blue______', self.color_func), 'caps': ('ci', 'caps______', self.bool_st_func), 'cf': ('ci', 'font-color', self.colorz_func), 'chftn': ('ci', 'footnot-mk', self.bool_st_func), 'dn': ('ci', 'font-down_', self.divide_by_2), 'embo': ('ci', 'emboss____', self.bool_st_func), 'f': ('ci', 'font-style', self.default_func), 'fs': ('ci', 'font-size_', self.divide_by_2), 'green': ('ci', 'green_____', self.color_func), 'i': ('ci', 'italics___', self.bool_st_func), 'impr': ('ci', 'engrave___', self.bool_st_func), 'outl': ('ci', 'outline___', self.bool_st_func), 'plain': ('ci', 'plain_____', self.bool_st_func), 'red': ('ci', 'red_______', self.color_func), 'scaps': ('ci', 'small-caps', self.bool_st_func), 'shad': ('ci', 'shadow____', self.bool_st_func), 'strike': ('ci', 'strike-thr', self.bool_st_func), 'striked': ('ci', 'dbl-strike', self.bool_st_func), 'sub': ('ci', 'subscript_', self.bool_st_func), 'super': ('ci', 'superscrip', self.bool_st_func), 'nosupersub': ('ci', 'no-su-supe', self.__no_sup_sub_func), 'up': ('ci', 'font-up___', self.divide_by_2), 'v': ('ci', 'hidden____', self.default_func), 'ul': ('ci', 'underlined<continous', self.two_part_func), 'uld': ('ci', 'underlined<dotted', self.two_part_func), 'uldash': ('ci', 'underlined<dash', self.two_part_func), 'uldashd': ('ci', 'underlined<dash-dot', self.two_part_func), 'uldashdd': ('ci', 'underlined<dash-dot-dot', self.two_part_func), 'uldb': ('ci', 'underlined<double', self.two_part_func), 'ulhwave': ('ci', 'underlined<heavy-wave', self.two_part_func), 'ulldash': ('ci', 'underlined<long-dash', self.two_part_func), 'ulth': ('ci', 'underlined<thich', self.two_part_func), 'ulthd': ('ci', 'underlined<thick-dotted', self.two_part_func), 'ulthdash': ('ci', 'underlined<thick-dash', self.two_part_func), 'ulthdashd': ('ci', 'underlined<thick-dash-dot', self.two_part_func), 'ulthdashdd': ('ci', 'underlined<thick-dash-dot-dot', self.two_part_func), 'ulthldash': ('ci', 'underlined<thick-long-dash', self.two_part_func), 'ululdbwave': ('ci', 'underlined<double-wave', self.two_part_func), 'ulw': ('ci', 'underlined<word', self.two_part_func), 'ulwave': ('ci', 'underlined<wave', self.two_part_func), 'ulnone': ('ci', 'underlined<false', self.two_part_func), 'trowd': ('tb', 'row-def___', self.default_func), 'cell': ('tb', 'cell______', self.default_func), 'row': ('tb', 'row_______', self.default_func), 'intbl': ('tb', 'in-table__', self.default_func), 'cols': ('tb', 'columns___', self.default_func), 'trleft': ('tb', 'row-pos-le', self.divide_by_20), 'cellx': ('tb', 'cell-posit', self.divide_by_20), 'trhdr': ('tb', 'row-header', self.default_func), 'info': ('di', 'doc-info__', self.default_func), 'title': ('di', 'title_____', self.default_func), 'author': ('di', 'author____', self.default_func), 'operator': ('di', 'operator__', self.default_func), 'manager': ('di', 'manager___', self.default_func), 'company': ('di', 'company___', self.default_func), 'keywords': ('di', 'keywords__', self.default_func), 'category': ('di', 'category__', self.default_func), 'doccomm': ('di', 'doc-notes_', self.default_func), 'comment': ('di', 'doc-notes_', self.default_func), 'subject': ('di', 'subject___', self.default_func), 'creatim': ('di', 'create-tim', self.default_func), 'yr': ('di', 'year______', self.default_func), 'mo': ('di', 'month_____', self.default_func), 'dy': ('di', 'day_______', self.default_func), 'min': ('di', 'minute____', self.default_func), 'sec': ('di', 'second____', self.default_func), 'revtim': ('di', 'revis-time', self.default_func), 'edmins': ('di', 'edit-time_', self.default_func), 'printim': ('di', 'print-time', self.default_func), 'buptim': ('di', 'backuptime', self.default_func), 'nofwords': ('di', 'num-of-wor', self.default_func), 'nofchars': ('di', 'num-of-chr', self.default_func), 'nofcharsws': ('di', 'numofchrws', self.default_func), 'nofpages': ('di', 'num-of-pag', self.default_func), 'version': ('di', 'version___', self.default_func), 'vern': ('di', 'intern-ver', self.default_func), 'hlinkbase': ('di', 'linkbase__', self.default_func), 'id': ('di', 'internalID', self.default_func), 'headerf': ('hf', 'head-first', self.default_func), 'headerl': ('hf', 'head-left_', self.default_func), 'headerr': ('hf', 'head-right', self.default_func), 'footerf': ('hf', 'foot-first', self.default_func), 'footerl': ('hf', 'foot-left_', self.default_func), 'footerr': ('hf', 'foot-right', self.default_func), 'header': ('hf', 'header____', self.default_func), 'footer': ('hf', 'footer____', self.default_func), 'margl': ('pa', 'margin-lef', self.divide_by_20), 'margr': ('pa', 'margin-rig', self.divide_by_20), 'margb': ('pa', 'margin-bot', self.divide_by_20), 'margt': ('pa', 'margin-top', self.divide_by_20), 'gutter': ('pa', 'gutter____', self.divide_by_20), 'paperw': ('pa', 'paper-widt', self.divide_by_20), 'paperh': ('pa', 'paper-hght', self.divide_by_20), 'annotation': ('an', 'annotation', self.default_func), 'trbrdrh': ('bd', 'bor-t-r-hi', self.default_func), 'trbrdrv': ('bd', 'bor-t-r-vi', self.default_func), 'trbrdrt': ('bd', 'bor-t-r-to', self.default_func), 'trbrdrl': ('bd', 'bor-t-r-le', self.default_func), 'trbrdrb': ('bd', 'bor-t-r-bo', self.default_func), 'trbrdrr': ('bd', 'bor-t-r-ri', self.default_func), 'clbrdrb': ('bd', 'bor-cel-bo', self.default_func), 'clbrdrt': ('bd', 'bor-cel-to', self.default_func), 'clbrdrl': ('bd', 'bor-cel-le', self.default_func), 'clbrdrr': ('bd', 'bor-cel-ri', self.default_func), 'brdrb': ('bd', 'bor-par-bo', self.default_func), 'brdrt': ('bd', 'bor-par-to', self.default_func), 'brdrl': ('bd', 'bor-par-le', self.default_func), 'brdrr': ('bd', 'bor-par-ri', self.default_func), 'box': ('bd', 'bor-par-bx', self.default_func), 'chbrdr': ('bd', 'bor-par-bo', self.default_func), 'brdrbtw': ('bd', 'bor-for-ev', self.default_func), 'brdrbar': ('bd', 'bor-outsid', self.default_func), 'brdrnone': ('bd', 'bor-none__<false', self.two_part_func), 'brdrs': ('bt', 'bdr-single', self.default_func), 'brdrth': ('bt', 'bdr-doubtb', self.default_func), 'brdrsh': ('bt', 'bdr-shadow', self.default_func), 'brdrdb': ('bt', 'bdr-double', self.default_func), 'brdrdot': ('bt', 'bdr-dotted', self.default_func), 'brdrdash': ('bt', 'bdr-dashed', self.default_func), 'brdrhair': ('bt', 'bdr-hair__', self.default_func), 'brdrinset': ('bt', 'bdr-inset_', self.default_func), 'brdrdashsm': ('bt', 'bdr-das-sm', self.default_func), 'brdrdashd': ('bt', 'bdr-dot-sm', self.default_func), 'brdrdashdd': ('bt', 'bdr-dot-do', self.default_func), 'brdroutset': ('bt', 'bdr-outset', self.default_func), 'brdrtriple': ('bt', 'bdr-trippl', self.default_func), 'brdrtnthsg': ('bt', 'bdr-thsm__', self.default_func), 'brdrthtnsg': ('bt', 'bdr-htsm__', self.default_func), 'brdrtnthtnsg': ('bt', 'bdr-hthsm_', self.default_func), 'brdrtnthmg': ('bt', 'bdr-thm___', self.default_func), 'brdrthtnmg': ('bt', 'bdr-htm___', self.default_func), 'brdrtnthtnmg': ('bt', 'bdr-hthm__', self.default_func), 'brdrtnthlg': ('bt', 'bdr-thl___', self.default_func), 'brdrtnthtnlg': ('bt', 'bdr-hthl__', self.default_func), 'brdrwavy': ('bt', 'bdr-wavy__', self.default_func), 'brdrwavydb': ('bt', 'bdr-d-wav_', self.default_func), 'brdrdashdotstr': ('bt', 'bdr-strip_', self.default_func), 'brdremboss': ('bt', 'bdr-embos_', self.default_func), 'brdrengrave': ('bt', 'bdr-engra_', self.default_func), 'brdrframe': ('bt', 'bdr-frame_', self.default_func), 'brdrw': ('bt', 'bdr-li-wid', self.divide_by_20), 'brsp': ('bt', 'bdr-sp-wid', self.divide_by_20), 'brdrcf': ('bt', 'bdr-color_', self.default_func)}\n    self.__number_type_dict = {0: 'Arabic', 1: 'uppercase Roman numeral', 2: 'lowercase Roman numeral', 3: 'uppercase letter', 4: 'lowercase letter', 5: 'ordinal number', 6: 'cardianl text number', 7: 'ordinal text number', 10: 'Kanji numbering without the digit character', 11: 'Kanji numbering with the digit character', 1246: 'phonetic Katakana characters in aiueo order', 1346: 'phonetic katakana characters in iroha order', 14: 'double byte character', 15: 'single byte character', 16: 'Kanji numbering 3', 17: 'Kanji numbering 4', 18: 'Circle numbering', 19: 'double-byte Arabic numbering', 2046: 'phonetic double-byte Katakana characters', 2146: 'phonetic double-byte katakana characters', 22: 'Arabic with leading zero', 23: 'bullet', 24: 'Korean numbering 2', 25: 'Korean numbering 1', 26: 'Chinese numbering 1', 27: 'Chinese numbering 2', 28: 'Chinese numbering 3', 29: 'Chinese numbering 4', 30: 'Chinese Zodiac numbering 1', 31: 'Chinese Zodiac numbering 2', 32: 'Chinese Zodiac numbering 3', 33: 'Taiwanese double-byte numbering 1', 34: 'Taiwanese double-byte numbering 2', 35: 'Taiwanese double-byte numbering 3', 36: 'Taiwanese double-byte numbering 4', 37: 'Chinese double-byte numbering 1', 38: 'Chinese double-byte numbering 2', 39: 'Chinese double-byte numbering 3', 40: 'Chinese double-byte numbering 4', 41: 'Korean double-byte numbering 1', 42: 'Korean double-byte numbering 2', 43: 'Korean double-byte numbering 3', 44: 'Korean double-byte numbering 4', 45: 'Hebrew non-standard decimal', 46: 'Arabic Alif Ba Tah', 47: 'Hebrew Biblical standard', 48: 'Arabic Abjad style', 255: 'No number'}\n    self.__language_dict = {1078: 'Afrikaans', 1052: 'Albanian', 1025: 'Arabic', 5121: 'Arabic Algeria', 15361: 'Arabic Bahrain', 3073: 'Arabic Egypt', 1: 'Arabic General', 2049: 'Arabic Iraq', 11265: 'Arabic Jordan', 13313: 'Arabic Kuwait', 12289: 'Arabic Lebanon', 4097: 'Arabic Libya', 6145: 'Arabic Morocco', 8193: 'Arabic Oman', 16385: 'Arabic Qatar', 10241: 'Arabic Syria', 7169: 'Arabic Tunisia', 14337: 'Arabic U.A.E.', 9217: 'Arabic Yemen', 1067: 'Armenian', 1101: 'Assamese', 2092: 'Azeri Cyrillic', 1068: 'Azeri Latin', 1069: 'Basque', 1093: 'Bengali', 4122: 'Bosnia Herzegovina', 1026: 'Bulgarian', 1109: 'Burmese', 1059: 'Byelorussian', 1027: 'Catalan', 2052: 'Chinese China', 4: 'Chinese General', 3076: 'Chinese Hong Kong', 4100: 'Chinese Singapore', 1028: 'Chinese Taiwan', 1050: 'Croatian', 1029: 'Czech', 1030: 'Danish', 2067: 'Dutch Belgium', 1043: 'Dutch Standard', 3081: 'English Australia', 10249: 'English Belize', 2057: 'English British', 4105: 'English Canada', 9225: 'English Caribbean', 9: 'English General', 6153: 'English Ireland', 8201: 'English Jamaica', 5129: 'English New Zealand', 13321: 'English Philippines', 7177: 'English South Africa', 11273: 'English Trinidad', 1033: 'English United States', 1061: 'Estonian', 1080: 'Faerose', 1065: 'Farsi', 1035: 'Finnish', 1036: 'French', 2060: 'French Belgium', 11276: 'French Cameroon', 3084: 'French Canada', 12300: \"French Cote d'Ivoire\", 5132: 'French Luxembourg', 13324: 'French Mali', 6156: 'French Monaco', 8204: 'French Reunion', 10252: 'French Senegal', 4108: 'French Swiss', 7180: 'French West Indies', 9228: 'French Democratic Republic of the Congo', 1122: 'Frisian', 1084: 'Gaelic', 2108: 'Gaelic Ireland', 1110: 'Galician', 1079: 'Georgian', 1031: 'German', 3079: 'German Austrian', 5127: 'German Liechtenstein', 4103: 'German Luxembourg', 2055: 'German Switzerland', 1032: 'Greek', 1095: 'Gujarati', 1037: 'Hebrew', 1081: 'Hindi', 1038: 'Hungarian', 1039: 'Icelandic', 1057: 'Indonesian', 1040: 'Italian', 2064: 'Italian Switzerland', 1041: 'Japanese', 1099: 'Kannada', 1120: 'Kashmiri', 2144: 'Kashmiri India', 1087: 'Kazakh', 1107: 'Khmer', 1088: 'Kirghiz', 1111: 'Konkani', 1042: 'Korean', 2066: 'Korean Johab', 1108: 'Lao', 1062: 'Latvian', 1063: 'Lithuanian', 2087: 'Lithuanian Classic', 1086: 'Malay', 2110: 'Malay Brunei Darussalam', 1100: 'Malayalam', 1082: 'Maltese', 1112: 'Manipuri', 1102: 'Marathi', 1104: 'Mongolian', 1121: 'Nepali', 2145: 'Nepali India', 1044: 'Norwegian Bokmal', 2068: 'Norwegian Nynorsk', 1096: 'Oriya', 1045: 'Polish', 1046: 'Portuguese (Brazil)', 2070: 'Portuguese (Portugal)', 1094: 'Punjabi', 1047: 'Rhaeto-Romanic', 1048: 'Romanian', 2072: 'Romanian Moldova', 1049: 'Russian', 2073: 'Russian Moldova', 1083: 'Sami Lappish', 1103: 'Sanskrit', 3098: 'Serbian Cyrillic', 2074: 'Serbian Latin', 1113: 'Sindhi', 1051: 'Slovak', 1060: 'Slovenian', 1070: 'Sorbian', 11274: 'Spanish Argentina', 16394: 'Spanish Bolivia', 13322: 'Spanish Chile', 9226: 'Spanish Colombia', 5130: 'Spanish Costa Rica', 7178: 'Spanish Dominican Republic', 12298: 'Spanish Ecuador', 17418: 'Spanish El Salvador', 4106: 'Spanish Guatemala', 18442: 'Spanish Honduras', 2058: 'Spanish Mexico', 3082: 'Spanish Modern', 19466: 'Spanish Nicaragua', 6154: 'Spanish Panama', 15370: 'Spanish Paraguay', 10250: 'Spanish Peru', 20490: 'Spanish Puerto Rico', 1034: 'Spanish Traditional', 14346: 'Spanish Uruguay', 8202: 'Spanish Venezuela', 1072: 'Sutu', 1089: 'Swahili', 1053: 'Swedish', 2077: 'Swedish Finland', 1064: 'Tajik', 1097: 'Tamil', 1092: 'Tatar', 1098: 'Telugu', 1054: 'Thai', 1105: 'Tibetan', 1073: 'Tsonga', 1074: 'Tswana', 1055: 'Turkish', 1090: 'Turkmen', 1058: 'Ukranian', 1056: 'Urdu', 2080: 'Urdu India', 2115: 'Uzbek Cyrillic', 1091: 'Uzbek Latin', 1075: 'Venda', 1066: 'Vietnamese', 1106: 'Welsh', 1076: 'Xhosa', 1085: 'Yiddish', 1077: 'Zulu', 1024: 'Unkown', 255: 'Unkown'}",
            "def initiate_token_dict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__return_code = 0\n    self.dict_token = {'mshex': ('nu', '__________', self.__ms_hex_func), '{': ('nu', '{', self.ob_func), '}': ('nu', '}', self.cb_func), 'ldblquote': ('mc', 'ldblquote', self.ms_sub_func), 'rdblquote': ('mc', 'rdblquote', self.ms_sub_func), 'rquote': ('mc', 'rquote', self.ms_sub_func), 'lquote': ('mc', 'lquote', self.ms_sub_func), 'emdash': ('mc', 'emdash', self.ms_sub_func), 'endash': ('mc', 'endash', self.ms_sub_func), 'bullet': ('mc', 'bullet', self.ms_sub_func), '~': ('mc', '~', self.ms_sub_func), 'tab': ('mc', 'tab', self.ms_sub_func), '_': ('mc', '_', self.ms_sub_func), ';': ('mc', ';', self.ms_sub_func), '-': ('mc', '-', self.ms_sub_func), 'line': ('mi', 'hardline-break', self.direct_conv_func), '*': ('ml', 'asterisk__', self.default_func), ':': ('ml', 'colon_____', self.default_func), 'backslash': ('nu', '\\\\', self.text_func), 'ob': ('nu', '{', self.text_func), 'cb': ('nu', '}', self.text_func), 'page': ('pf', 'page-break', self.default_func), 'par': ('pf', 'par-end___', self.default_func), 'pard': ('pf', 'par-def___', self.default_func), 'keepn': ('pf', 'keep-w-nex', self.bool_st_func), 'widctlpar': ('pf', 'widow-cntl', self.bool_st_func), 'adjustright': ('pf', 'adjust-rgt', self.bool_st_func), 'lang': ('pf', 'language__', self.__language_func), 'ri': ('pf', 'right-inde', self.divide_by_20), 'fi': ('pf', 'fir-ln-ind', self.divide_by_20), 'li': ('pf', 'left-inden', self.divide_by_20), 'sb': ('pf', 'space-befo', self.divide_by_20), 'sa': ('pf', 'space-afte', self.divide_by_20), 'sl': ('pf', 'line-space', self.divide_by_20), 'deftab': ('pf', 'default-ta', self.divide_by_20), 'ql': ('pf', 'align_____<left', self.two_part_func), 'qc': ('pf', 'align_____<cent', self.two_part_func), 'qj': ('pf', 'align_____<just', self.two_part_func), 'qr': ('pf', 'align_____<right', self.two_part_func), 'nowidctlpar': ('pf', 'widow-cntr<false', self.two_part_func), 'tx': ('pf', 'tab-stop__', self.divide_by_20), 'tb': ('pf', 'tab-bar-st', self.divide_by_20), 'tqr': ('pf', 'tab-right_', self.default_func), 'tqdec': ('pf', 'tab-dec___', self.default_func), 'tqc': ('pf', 'tab-center', self.default_func), 'tlul': ('pf', 'leader-und', self.default_func), 'tlhyph': ('pf', 'leader-hyp', self.default_func), 'tldot': ('pf', 'leader-dot', self.default_func), 'stylesheet': ('ss', 'style-shet', self.default_func), 'sbasedon': ('ss', 'based-on__', self.default_func), 'snext': ('ss', 'next-style', self.default_func), 'cs': ('ss', 'char-style', self.default_func), 's': ('ss', 'para-style', self.default_func), 'pict': ('gr', 'picture___', self.default_func), 'objclass': ('gr', 'obj-class_', self.default_func), 'macpict': ('gr', 'mac-pic___', self.default_func), 'sect': ('sc', 'section___', self.default_func), 'sectd': ('sc', 'sect-defin', self.default_func), 'endhere': ('sc', 'sect-note_', self.default_func), 'pntext': ('ls', 'list-text_', self.default_func), 'listtext': ('ls', 'list-text_', self.default_func), 'pn': ('ls', 'list______', self.default_func), 'pnseclvl': ('ls', 'list-level', self.default_func), 'pncard': ('ls', 'list-cardi', self.bool_st_func), 'pndec': ('ls', 'list-decim', self.bool_st_func), 'pnucltr': ('ls', 'list-up-al', self.bool_st_func), 'pnucrm': ('ls', 'list-up-ro', self.bool_st_func), 'pnord': ('ls', 'list-ord__', self.bool_st_func), 'pnordt': ('ls', 'list-ordte', self.bool_st_func), 'pnlvlblt': ('ls', 'list-bulli', self.bool_st_func), 'pnlvlbody': ('ls', 'list-simpi', self.bool_st_func), 'pnlvlcont': ('ls', 'list-conti', self.bool_st_func), 'pnhang': ('ls', 'list-hang_', self.bool_st_func), 'pntxtb': ('ls', 'list-tebef', self.bool_st_func), 'ilvl': ('ls', 'list-level', self.default_func), 'ls': ('ls', 'list-id___', self.default_func), 'pnstart': ('ls', 'list-start', self.default_func), 'itap': ('ls', 'nest-level', self.default_func), 'leveltext': ('ls', 'level-text', self.default_func), 'levelnumbers': ('ls', 'level-numb', self.default_func), 'list': ('ls', 'list-in-tb', self.default_func), 'listlevel': ('ls', 'list-tb-le', self.default_func), 'listname': ('ls', 'list-name_', self.default_func), 'listtemplateid': ('ls', 'ls-tem-id_', self.default_func), 'leveltemplateid': ('ls', 'lv-tem-id_', self.default_func), 'listhybrid': ('ls', 'list-hybri', self.default_func), 'levelstartat': ('ls', 'level-star', self.default_func), 'levelspace': ('ls', 'level-spac', self.divide_by_20), 'levelindent': ('ls', 'level-inde', self.default_func), 'levelnfc': ('ls', 'level-type', self.__list_type_func), 'levelnfcn': ('ls', 'level-type', self.__list_type_func), 'listid': ('ls', 'lis-tbl-id', self.default_func), 'listoverride': ('ls', 'lis-overid', self.default_func), 'pnlvl': ('ls', 'list-level', self.default_func), 'rtf': ('ri', 'rtf_______', self.default_func), 'deff': ('ri', 'deflt-font', self.default_func), 'mac': ('ri', 'macintosh_', self.default_func), 'pc': ('ri', 'pc________', self.default_func), 'pca': ('ri', 'pca_______', self.default_func), 'ansi': ('ri', 'ansi______', self.default_func), 'ansicpg': ('ri', 'ansi-codpg', self.default_func), 'footnote': ('nt', 'footnote__', self.default_func), 'ftnalt': ('nt', 'type______<endnote', self.two_part_func), 'tc': ('an', 'toc_______', self.default_func), 'bkmkstt': ('an', 'book-mk-st', self.default_func), 'bkmkstart': ('an', 'book-mk-st', self.default_func), 'bkmkend': ('an', 'book-mk-en', self.default_func), 'xe': ('an', 'index-mark', self.default_func), 'rxe': ('an', 'place_____', self.default_func), 'bxe': ('in', 'index-bold', self.default_func), 'ixe': ('in', 'index-ital', self.default_func), 'txe': ('in', 'index-see_', self.default_func), 'tcl': ('tc', 'toc-level_', self.default_func), 'tcn': ('tc', 'toc-sup-nu', self.default_func), 'field': ('fd', 'field_____', self.default_func), 'fldinst': ('fd', 'field-inst', self.default_func), 'fldrslt': ('fd', 'field-rslt', self.default_func), 'datafield': ('fd', 'datafield_', self.default_func), 'fonttbl': ('it', 'font-table', self.default_func), 'colortbl': ('it', 'colr-table', self.default_func), 'listoverridetable': ('it', 'lovr-table', self.default_func), 'listtable': ('it', 'listtable_', self.default_func), 'revtbl': ('it', 'revi-table', self.default_func), 'b': ('ci', 'bold______', self.bool_st_func), 'blue': ('ci', 'blue______', self.color_func), 'caps': ('ci', 'caps______', self.bool_st_func), 'cf': ('ci', 'font-color', self.colorz_func), 'chftn': ('ci', 'footnot-mk', self.bool_st_func), 'dn': ('ci', 'font-down_', self.divide_by_2), 'embo': ('ci', 'emboss____', self.bool_st_func), 'f': ('ci', 'font-style', self.default_func), 'fs': ('ci', 'font-size_', self.divide_by_2), 'green': ('ci', 'green_____', self.color_func), 'i': ('ci', 'italics___', self.bool_st_func), 'impr': ('ci', 'engrave___', self.bool_st_func), 'outl': ('ci', 'outline___', self.bool_st_func), 'plain': ('ci', 'plain_____', self.bool_st_func), 'red': ('ci', 'red_______', self.color_func), 'scaps': ('ci', 'small-caps', self.bool_st_func), 'shad': ('ci', 'shadow____', self.bool_st_func), 'strike': ('ci', 'strike-thr', self.bool_st_func), 'striked': ('ci', 'dbl-strike', self.bool_st_func), 'sub': ('ci', 'subscript_', self.bool_st_func), 'super': ('ci', 'superscrip', self.bool_st_func), 'nosupersub': ('ci', 'no-su-supe', self.__no_sup_sub_func), 'up': ('ci', 'font-up___', self.divide_by_2), 'v': ('ci', 'hidden____', self.default_func), 'ul': ('ci', 'underlined<continous', self.two_part_func), 'uld': ('ci', 'underlined<dotted', self.two_part_func), 'uldash': ('ci', 'underlined<dash', self.two_part_func), 'uldashd': ('ci', 'underlined<dash-dot', self.two_part_func), 'uldashdd': ('ci', 'underlined<dash-dot-dot', self.two_part_func), 'uldb': ('ci', 'underlined<double', self.two_part_func), 'ulhwave': ('ci', 'underlined<heavy-wave', self.two_part_func), 'ulldash': ('ci', 'underlined<long-dash', self.two_part_func), 'ulth': ('ci', 'underlined<thich', self.two_part_func), 'ulthd': ('ci', 'underlined<thick-dotted', self.two_part_func), 'ulthdash': ('ci', 'underlined<thick-dash', self.two_part_func), 'ulthdashd': ('ci', 'underlined<thick-dash-dot', self.two_part_func), 'ulthdashdd': ('ci', 'underlined<thick-dash-dot-dot', self.two_part_func), 'ulthldash': ('ci', 'underlined<thick-long-dash', self.two_part_func), 'ululdbwave': ('ci', 'underlined<double-wave', self.two_part_func), 'ulw': ('ci', 'underlined<word', self.two_part_func), 'ulwave': ('ci', 'underlined<wave', self.two_part_func), 'ulnone': ('ci', 'underlined<false', self.two_part_func), 'trowd': ('tb', 'row-def___', self.default_func), 'cell': ('tb', 'cell______', self.default_func), 'row': ('tb', 'row_______', self.default_func), 'intbl': ('tb', 'in-table__', self.default_func), 'cols': ('tb', 'columns___', self.default_func), 'trleft': ('tb', 'row-pos-le', self.divide_by_20), 'cellx': ('tb', 'cell-posit', self.divide_by_20), 'trhdr': ('tb', 'row-header', self.default_func), 'info': ('di', 'doc-info__', self.default_func), 'title': ('di', 'title_____', self.default_func), 'author': ('di', 'author____', self.default_func), 'operator': ('di', 'operator__', self.default_func), 'manager': ('di', 'manager___', self.default_func), 'company': ('di', 'company___', self.default_func), 'keywords': ('di', 'keywords__', self.default_func), 'category': ('di', 'category__', self.default_func), 'doccomm': ('di', 'doc-notes_', self.default_func), 'comment': ('di', 'doc-notes_', self.default_func), 'subject': ('di', 'subject___', self.default_func), 'creatim': ('di', 'create-tim', self.default_func), 'yr': ('di', 'year______', self.default_func), 'mo': ('di', 'month_____', self.default_func), 'dy': ('di', 'day_______', self.default_func), 'min': ('di', 'minute____', self.default_func), 'sec': ('di', 'second____', self.default_func), 'revtim': ('di', 'revis-time', self.default_func), 'edmins': ('di', 'edit-time_', self.default_func), 'printim': ('di', 'print-time', self.default_func), 'buptim': ('di', 'backuptime', self.default_func), 'nofwords': ('di', 'num-of-wor', self.default_func), 'nofchars': ('di', 'num-of-chr', self.default_func), 'nofcharsws': ('di', 'numofchrws', self.default_func), 'nofpages': ('di', 'num-of-pag', self.default_func), 'version': ('di', 'version___', self.default_func), 'vern': ('di', 'intern-ver', self.default_func), 'hlinkbase': ('di', 'linkbase__', self.default_func), 'id': ('di', 'internalID', self.default_func), 'headerf': ('hf', 'head-first', self.default_func), 'headerl': ('hf', 'head-left_', self.default_func), 'headerr': ('hf', 'head-right', self.default_func), 'footerf': ('hf', 'foot-first', self.default_func), 'footerl': ('hf', 'foot-left_', self.default_func), 'footerr': ('hf', 'foot-right', self.default_func), 'header': ('hf', 'header____', self.default_func), 'footer': ('hf', 'footer____', self.default_func), 'margl': ('pa', 'margin-lef', self.divide_by_20), 'margr': ('pa', 'margin-rig', self.divide_by_20), 'margb': ('pa', 'margin-bot', self.divide_by_20), 'margt': ('pa', 'margin-top', self.divide_by_20), 'gutter': ('pa', 'gutter____', self.divide_by_20), 'paperw': ('pa', 'paper-widt', self.divide_by_20), 'paperh': ('pa', 'paper-hght', self.divide_by_20), 'annotation': ('an', 'annotation', self.default_func), 'trbrdrh': ('bd', 'bor-t-r-hi', self.default_func), 'trbrdrv': ('bd', 'bor-t-r-vi', self.default_func), 'trbrdrt': ('bd', 'bor-t-r-to', self.default_func), 'trbrdrl': ('bd', 'bor-t-r-le', self.default_func), 'trbrdrb': ('bd', 'bor-t-r-bo', self.default_func), 'trbrdrr': ('bd', 'bor-t-r-ri', self.default_func), 'clbrdrb': ('bd', 'bor-cel-bo', self.default_func), 'clbrdrt': ('bd', 'bor-cel-to', self.default_func), 'clbrdrl': ('bd', 'bor-cel-le', self.default_func), 'clbrdrr': ('bd', 'bor-cel-ri', self.default_func), 'brdrb': ('bd', 'bor-par-bo', self.default_func), 'brdrt': ('bd', 'bor-par-to', self.default_func), 'brdrl': ('bd', 'bor-par-le', self.default_func), 'brdrr': ('bd', 'bor-par-ri', self.default_func), 'box': ('bd', 'bor-par-bx', self.default_func), 'chbrdr': ('bd', 'bor-par-bo', self.default_func), 'brdrbtw': ('bd', 'bor-for-ev', self.default_func), 'brdrbar': ('bd', 'bor-outsid', self.default_func), 'brdrnone': ('bd', 'bor-none__<false', self.two_part_func), 'brdrs': ('bt', 'bdr-single', self.default_func), 'brdrth': ('bt', 'bdr-doubtb', self.default_func), 'brdrsh': ('bt', 'bdr-shadow', self.default_func), 'brdrdb': ('bt', 'bdr-double', self.default_func), 'brdrdot': ('bt', 'bdr-dotted', self.default_func), 'brdrdash': ('bt', 'bdr-dashed', self.default_func), 'brdrhair': ('bt', 'bdr-hair__', self.default_func), 'brdrinset': ('bt', 'bdr-inset_', self.default_func), 'brdrdashsm': ('bt', 'bdr-das-sm', self.default_func), 'brdrdashd': ('bt', 'bdr-dot-sm', self.default_func), 'brdrdashdd': ('bt', 'bdr-dot-do', self.default_func), 'brdroutset': ('bt', 'bdr-outset', self.default_func), 'brdrtriple': ('bt', 'bdr-trippl', self.default_func), 'brdrtnthsg': ('bt', 'bdr-thsm__', self.default_func), 'brdrthtnsg': ('bt', 'bdr-htsm__', self.default_func), 'brdrtnthtnsg': ('bt', 'bdr-hthsm_', self.default_func), 'brdrtnthmg': ('bt', 'bdr-thm___', self.default_func), 'brdrthtnmg': ('bt', 'bdr-htm___', self.default_func), 'brdrtnthtnmg': ('bt', 'bdr-hthm__', self.default_func), 'brdrtnthlg': ('bt', 'bdr-thl___', self.default_func), 'brdrtnthtnlg': ('bt', 'bdr-hthl__', self.default_func), 'brdrwavy': ('bt', 'bdr-wavy__', self.default_func), 'brdrwavydb': ('bt', 'bdr-d-wav_', self.default_func), 'brdrdashdotstr': ('bt', 'bdr-strip_', self.default_func), 'brdremboss': ('bt', 'bdr-embos_', self.default_func), 'brdrengrave': ('bt', 'bdr-engra_', self.default_func), 'brdrframe': ('bt', 'bdr-frame_', self.default_func), 'brdrw': ('bt', 'bdr-li-wid', self.divide_by_20), 'brsp': ('bt', 'bdr-sp-wid', self.divide_by_20), 'brdrcf': ('bt', 'bdr-color_', self.default_func)}\n    self.__number_type_dict = {0: 'Arabic', 1: 'uppercase Roman numeral', 2: 'lowercase Roman numeral', 3: 'uppercase letter', 4: 'lowercase letter', 5: 'ordinal number', 6: 'cardianl text number', 7: 'ordinal text number', 10: 'Kanji numbering without the digit character', 11: 'Kanji numbering with the digit character', 1246: 'phonetic Katakana characters in aiueo order', 1346: 'phonetic katakana characters in iroha order', 14: 'double byte character', 15: 'single byte character', 16: 'Kanji numbering 3', 17: 'Kanji numbering 4', 18: 'Circle numbering', 19: 'double-byte Arabic numbering', 2046: 'phonetic double-byte Katakana characters', 2146: 'phonetic double-byte katakana characters', 22: 'Arabic with leading zero', 23: 'bullet', 24: 'Korean numbering 2', 25: 'Korean numbering 1', 26: 'Chinese numbering 1', 27: 'Chinese numbering 2', 28: 'Chinese numbering 3', 29: 'Chinese numbering 4', 30: 'Chinese Zodiac numbering 1', 31: 'Chinese Zodiac numbering 2', 32: 'Chinese Zodiac numbering 3', 33: 'Taiwanese double-byte numbering 1', 34: 'Taiwanese double-byte numbering 2', 35: 'Taiwanese double-byte numbering 3', 36: 'Taiwanese double-byte numbering 4', 37: 'Chinese double-byte numbering 1', 38: 'Chinese double-byte numbering 2', 39: 'Chinese double-byte numbering 3', 40: 'Chinese double-byte numbering 4', 41: 'Korean double-byte numbering 1', 42: 'Korean double-byte numbering 2', 43: 'Korean double-byte numbering 3', 44: 'Korean double-byte numbering 4', 45: 'Hebrew non-standard decimal', 46: 'Arabic Alif Ba Tah', 47: 'Hebrew Biblical standard', 48: 'Arabic Abjad style', 255: 'No number'}\n    self.__language_dict = {1078: 'Afrikaans', 1052: 'Albanian', 1025: 'Arabic', 5121: 'Arabic Algeria', 15361: 'Arabic Bahrain', 3073: 'Arabic Egypt', 1: 'Arabic General', 2049: 'Arabic Iraq', 11265: 'Arabic Jordan', 13313: 'Arabic Kuwait', 12289: 'Arabic Lebanon', 4097: 'Arabic Libya', 6145: 'Arabic Morocco', 8193: 'Arabic Oman', 16385: 'Arabic Qatar', 10241: 'Arabic Syria', 7169: 'Arabic Tunisia', 14337: 'Arabic U.A.E.', 9217: 'Arabic Yemen', 1067: 'Armenian', 1101: 'Assamese', 2092: 'Azeri Cyrillic', 1068: 'Azeri Latin', 1069: 'Basque', 1093: 'Bengali', 4122: 'Bosnia Herzegovina', 1026: 'Bulgarian', 1109: 'Burmese', 1059: 'Byelorussian', 1027: 'Catalan', 2052: 'Chinese China', 4: 'Chinese General', 3076: 'Chinese Hong Kong', 4100: 'Chinese Singapore', 1028: 'Chinese Taiwan', 1050: 'Croatian', 1029: 'Czech', 1030: 'Danish', 2067: 'Dutch Belgium', 1043: 'Dutch Standard', 3081: 'English Australia', 10249: 'English Belize', 2057: 'English British', 4105: 'English Canada', 9225: 'English Caribbean', 9: 'English General', 6153: 'English Ireland', 8201: 'English Jamaica', 5129: 'English New Zealand', 13321: 'English Philippines', 7177: 'English South Africa', 11273: 'English Trinidad', 1033: 'English United States', 1061: 'Estonian', 1080: 'Faerose', 1065: 'Farsi', 1035: 'Finnish', 1036: 'French', 2060: 'French Belgium', 11276: 'French Cameroon', 3084: 'French Canada', 12300: \"French Cote d'Ivoire\", 5132: 'French Luxembourg', 13324: 'French Mali', 6156: 'French Monaco', 8204: 'French Reunion', 10252: 'French Senegal', 4108: 'French Swiss', 7180: 'French West Indies', 9228: 'French Democratic Republic of the Congo', 1122: 'Frisian', 1084: 'Gaelic', 2108: 'Gaelic Ireland', 1110: 'Galician', 1079: 'Georgian', 1031: 'German', 3079: 'German Austrian', 5127: 'German Liechtenstein', 4103: 'German Luxembourg', 2055: 'German Switzerland', 1032: 'Greek', 1095: 'Gujarati', 1037: 'Hebrew', 1081: 'Hindi', 1038: 'Hungarian', 1039: 'Icelandic', 1057: 'Indonesian', 1040: 'Italian', 2064: 'Italian Switzerland', 1041: 'Japanese', 1099: 'Kannada', 1120: 'Kashmiri', 2144: 'Kashmiri India', 1087: 'Kazakh', 1107: 'Khmer', 1088: 'Kirghiz', 1111: 'Konkani', 1042: 'Korean', 2066: 'Korean Johab', 1108: 'Lao', 1062: 'Latvian', 1063: 'Lithuanian', 2087: 'Lithuanian Classic', 1086: 'Malay', 2110: 'Malay Brunei Darussalam', 1100: 'Malayalam', 1082: 'Maltese', 1112: 'Manipuri', 1102: 'Marathi', 1104: 'Mongolian', 1121: 'Nepali', 2145: 'Nepali India', 1044: 'Norwegian Bokmal', 2068: 'Norwegian Nynorsk', 1096: 'Oriya', 1045: 'Polish', 1046: 'Portuguese (Brazil)', 2070: 'Portuguese (Portugal)', 1094: 'Punjabi', 1047: 'Rhaeto-Romanic', 1048: 'Romanian', 2072: 'Romanian Moldova', 1049: 'Russian', 2073: 'Russian Moldova', 1083: 'Sami Lappish', 1103: 'Sanskrit', 3098: 'Serbian Cyrillic', 2074: 'Serbian Latin', 1113: 'Sindhi', 1051: 'Slovak', 1060: 'Slovenian', 1070: 'Sorbian', 11274: 'Spanish Argentina', 16394: 'Spanish Bolivia', 13322: 'Spanish Chile', 9226: 'Spanish Colombia', 5130: 'Spanish Costa Rica', 7178: 'Spanish Dominican Republic', 12298: 'Spanish Ecuador', 17418: 'Spanish El Salvador', 4106: 'Spanish Guatemala', 18442: 'Spanish Honduras', 2058: 'Spanish Mexico', 3082: 'Spanish Modern', 19466: 'Spanish Nicaragua', 6154: 'Spanish Panama', 15370: 'Spanish Paraguay', 10250: 'Spanish Peru', 20490: 'Spanish Puerto Rico', 1034: 'Spanish Traditional', 14346: 'Spanish Uruguay', 8202: 'Spanish Venezuela', 1072: 'Sutu', 1089: 'Swahili', 1053: 'Swedish', 2077: 'Swedish Finland', 1064: 'Tajik', 1097: 'Tamil', 1092: 'Tatar', 1098: 'Telugu', 1054: 'Thai', 1105: 'Tibetan', 1073: 'Tsonga', 1074: 'Tswana', 1055: 'Turkish', 1090: 'Turkmen', 1058: 'Ukranian', 1056: 'Urdu', 2080: 'Urdu India', 2115: 'Uzbek Cyrillic', 1091: 'Uzbek Latin', 1075: 'Venda', 1066: 'Vietnamese', 1106: 'Welsh', 1076: 'Xhosa', 1085: 'Yiddish', 1077: 'Zulu', 1024: 'Unkown', 255: 'Unkown'}",
            "def initiate_token_dict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__return_code = 0\n    self.dict_token = {'mshex': ('nu', '__________', self.__ms_hex_func), '{': ('nu', '{', self.ob_func), '}': ('nu', '}', self.cb_func), 'ldblquote': ('mc', 'ldblquote', self.ms_sub_func), 'rdblquote': ('mc', 'rdblquote', self.ms_sub_func), 'rquote': ('mc', 'rquote', self.ms_sub_func), 'lquote': ('mc', 'lquote', self.ms_sub_func), 'emdash': ('mc', 'emdash', self.ms_sub_func), 'endash': ('mc', 'endash', self.ms_sub_func), 'bullet': ('mc', 'bullet', self.ms_sub_func), '~': ('mc', '~', self.ms_sub_func), 'tab': ('mc', 'tab', self.ms_sub_func), '_': ('mc', '_', self.ms_sub_func), ';': ('mc', ';', self.ms_sub_func), '-': ('mc', '-', self.ms_sub_func), 'line': ('mi', 'hardline-break', self.direct_conv_func), '*': ('ml', 'asterisk__', self.default_func), ':': ('ml', 'colon_____', self.default_func), 'backslash': ('nu', '\\\\', self.text_func), 'ob': ('nu', '{', self.text_func), 'cb': ('nu', '}', self.text_func), 'page': ('pf', 'page-break', self.default_func), 'par': ('pf', 'par-end___', self.default_func), 'pard': ('pf', 'par-def___', self.default_func), 'keepn': ('pf', 'keep-w-nex', self.bool_st_func), 'widctlpar': ('pf', 'widow-cntl', self.bool_st_func), 'adjustright': ('pf', 'adjust-rgt', self.bool_st_func), 'lang': ('pf', 'language__', self.__language_func), 'ri': ('pf', 'right-inde', self.divide_by_20), 'fi': ('pf', 'fir-ln-ind', self.divide_by_20), 'li': ('pf', 'left-inden', self.divide_by_20), 'sb': ('pf', 'space-befo', self.divide_by_20), 'sa': ('pf', 'space-afte', self.divide_by_20), 'sl': ('pf', 'line-space', self.divide_by_20), 'deftab': ('pf', 'default-ta', self.divide_by_20), 'ql': ('pf', 'align_____<left', self.two_part_func), 'qc': ('pf', 'align_____<cent', self.two_part_func), 'qj': ('pf', 'align_____<just', self.two_part_func), 'qr': ('pf', 'align_____<right', self.two_part_func), 'nowidctlpar': ('pf', 'widow-cntr<false', self.two_part_func), 'tx': ('pf', 'tab-stop__', self.divide_by_20), 'tb': ('pf', 'tab-bar-st', self.divide_by_20), 'tqr': ('pf', 'tab-right_', self.default_func), 'tqdec': ('pf', 'tab-dec___', self.default_func), 'tqc': ('pf', 'tab-center', self.default_func), 'tlul': ('pf', 'leader-und', self.default_func), 'tlhyph': ('pf', 'leader-hyp', self.default_func), 'tldot': ('pf', 'leader-dot', self.default_func), 'stylesheet': ('ss', 'style-shet', self.default_func), 'sbasedon': ('ss', 'based-on__', self.default_func), 'snext': ('ss', 'next-style', self.default_func), 'cs': ('ss', 'char-style', self.default_func), 's': ('ss', 'para-style', self.default_func), 'pict': ('gr', 'picture___', self.default_func), 'objclass': ('gr', 'obj-class_', self.default_func), 'macpict': ('gr', 'mac-pic___', self.default_func), 'sect': ('sc', 'section___', self.default_func), 'sectd': ('sc', 'sect-defin', self.default_func), 'endhere': ('sc', 'sect-note_', self.default_func), 'pntext': ('ls', 'list-text_', self.default_func), 'listtext': ('ls', 'list-text_', self.default_func), 'pn': ('ls', 'list______', self.default_func), 'pnseclvl': ('ls', 'list-level', self.default_func), 'pncard': ('ls', 'list-cardi', self.bool_st_func), 'pndec': ('ls', 'list-decim', self.bool_st_func), 'pnucltr': ('ls', 'list-up-al', self.bool_st_func), 'pnucrm': ('ls', 'list-up-ro', self.bool_st_func), 'pnord': ('ls', 'list-ord__', self.bool_st_func), 'pnordt': ('ls', 'list-ordte', self.bool_st_func), 'pnlvlblt': ('ls', 'list-bulli', self.bool_st_func), 'pnlvlbody': ('ls', 'list-simpi', self.bool_st_func), 'pnlvlcont': ('ls', 'list-conti', self.bool_st_func), 'pnhang': ('ls', 'list-hang_', self.bool_st_func), 'pntxtb': ('ls', 'list-tebef', self.bool_st_func), 'ilvl': ('ls', 'list-level', self.default_func), 'ls': ('ls', 'list-id___', self.default_func), 'pnstart': ('ls', 'list-start', self.default_func), 'itap': ('ls', 'nest-level', self.default_func), 'leveltext': ('ls', 'level-text', self.default_func), 'levelnumbers': ('ls', 'level-numb', self.default_func), 'list': ('ls', 'list-in-tb', self.default_func), 'listlevel': ('ls', 'list-tb-le', self.default_func), 'listname': ('ls', 'list-name_', self.default_func), 'listtemplateid': ('ls', 'ls-tem-id_', self.default_func), 'leveltemplateid': ('ls', 'lv-tem-id_', self.default_func), 'listhybrid': ('ls', 'list-hybri', self.default_func), 'levelstartat': ('ls', 'level-star', self.default_func), 'levelspace': ('ls', 'level-spac', self.divide_by_20), 'levelindent': ('ls', 'level-inde', self.default_func), 'levelnfc': ('ls', 'level-type', self.__list_type_func), 'levelnfcn': ('ls', 'level-type', self.__list_type_func), 'listid': ('ls', 'lis-tbl-id', self.default_func), 'listoverride': ('ls', 'lis-overid', self.default_func), 'pnlvl': ('ls', 'list-level', self.default_func), 'rtf': ('ri', 'rtf_______', self.default_func), 'deff': ('ri', 'deflt-font', self.default_func), 'mac': ('ri', 'macintosh_', self.default_func), 'pc': ('ri', 'pc________', self.default_func), 'pca': ('ri', 'pca_______', self.default_func), 'ansi': ('ri', 'ansi______', self.default_func), 'ansicpg': ('ri', 'ansi-codpg', self.default_func), 'footnote': ('nt', 'footnote__', self.default_func), 'ftnalt': ('nt', 'type______<endnote', self.two_part_func), 'tc': ('an', 'toc_______', self.default_func), 'bkmkstt': ('an', 'book-mk-st', self.default_func), 'bkmkstart': ('an', 'book-mk-st', self.default_func), 'bkmkend': ('an', 'book-mk-en', self.default_func), 'xe': ('an', 'index-mark', self.default_func), 'rxe': ('an', 'place_____', self.default_func), 'bxe': ('in', 'index-bold', self.default_func), 'ixe': ('in', 'index-ital', self.default_func), 'txe': ('in', 'index-see_', self.default_func), 'tcl': ('tc', 'toc-level_', self.default_func), 'tcn': ('tc', 'toc-sup-nu', self.default_func), 'field': ('fd', 'field_____', self.default_func), 'fldinst': ('fd', 'field-inst', self.default_func), 'fldrslt': ('fd', 'field-rslt', self.default_func), 'datafield': ('fd', 'datafield_', self.default_func), 'fonttbl': ('it', 'font-table', self.default_func), 'colortbl': ('it', 'colr-table', self.default_func), 'listoverridetable': ('it', 'lovr-table', self.default_func), 'listtable': ('it', 'listtable_', self.default_func), 'revtbl': ('it', 'revi-table', self.default_func), 'b': ('ci', 'bold______', self.bool_st_func), 'blue': ('ci', 'blue______', self.color_func), 'caps': ('ci', 'caps______', self.bool_st_func), 'cf': ('ci', 'font-color', self.colorz_func), 'chftn': ('ci', 'footnot-mk', self.bool_st_func), 'dn': ('ci', 'font-down_', self.divide_by_2), 'embo': ('ci', 'emboss____', self.bool_st_func), 'f': ('ci', 'font-style', self.default_func), 'fs': ('ci', 'font-size_', self.divide_by_2), 'green': ('ci', 'green_____', self.color_func), 'i': ('ci', 'italics___', self.bool_st_func), 'impr': ('ci', 'engrave___', self.bool_st_func), 'outl': ('ci', 'outline___', self.bool_st_func), 'plain': ('ci', 'plain_____', self.bool_st_func), 'red': ('ci', 'red_______', self.color_func), 'scaps': ('ci', 'small-caps', self.bool_st_func), 'shad': ('ci', 'shadow____', self.bool_st_func), 'strike': ('ci', 'strike-thr', self.bool_st_func), 'striked': ('ci', 'dbl-strike', self.bool_st_func), 'sub': ('ci', 'subscript_', self.bool_st_func), 'super': ('ci', 'superscrip', self.bool_st_func), 'nosupersub': ('ci', 'no-su-supe', self.__no_sup_sub_func), 'up': ('ci', 'font-up___', self.divide_by_2), 'v': ('ci', 'hidden____', self.default_func), 'ul': ('ci', 'underlined<continous', self.two_part_func), 'uld': ('ci', 'underlined<dotted', self.two_part_func), 'uldash': ('ci', 'underlined<dash', self.two_part_func), 'uldashd': ('ci', 'underlined<dash-dot', self.two_part_func), 'uldashdd': ('ci', 'underlined<dash-dot-dot', self.two_part_func), 'uldb': ('ci', 'underlined<double', self.two_part_func), 'ulhwave': ('ci', 'underlined<heavy-wave', self.two_part_func), 'ulldash': ('ci', 'underlined<long-dash', self.two_part_func), 'ulth': ('ci', 'underlined<thich', self.two_part_func), 'ulthd': ('ci', 'underlined<thick-dotted', self.two_part_func), 'ulthdash': ('ci', 'underlined<thick-dash', self.two_part_func), 'ulthdashd': ('ci', 'underlined<thick-dash-dot', self.two_part_func), 'ulthdashdd': ('ci', 'underlined<thick-dash-dot-dot', self.two_part_func), 'ulthldash': ('ci', 'underlined<thick-long-dash', self.two_part_func), 'ululdbwave': ('ci', 'underlined<double-wave', self.two_part_func), 'ulw': ('ci', 'underlined<word', self.two_part_func), 'ulwave': ('ci', 'underlined<wave', self.two_part_func), 'ulnone': ('ci', 'underlined<false', self.two_part_func), 'trowd': ('tb', 'row-def___', self.default_func), 'cell': ('tb', 'cell______', self.default_func), 'row': ('tb', 'row_______', self.default_func), 'intbl': ('tb', 'in-table__', self.default_func), 'cols': ('tb', 'columns___', self.default_func), 'trleft': ('tb', 'row-pos-le', self.divide_by_20), 'cellx': ('tb', 'cell-posit', self.divide_by_20), 'trhdr': ('tb', 'row-header', self.default_func), 'info': ('di', 'doc-info__', self.default_func), 'title': ('di', 'title_____', self.default_func), 'author': ('di', 'author____', self.default_func), 'operator': ('di', 'operator__', self.default_func), 'manager': ('di', 'manager___', self.default_func), 'company': ('di', 'company___', self.default_func), 'keywords': ('di', 'keywords__', self.default_func), 'category': ('di', 'category__', self.default_func), 'doccomm': ('di', 'doc-notes_', self.default_func), 'comment': ('di', 'doc-notes_', self.default_func), 'subject': ('di', 'subject___', self.default_func), 'creatim': ('di', 'create-tim', self.default_func), 'yr': ('di', 'year______', self.default_func), 'mo': ('di', 'month_____', self.default_func), 'dy': ('di', 'day_______', self.default_func), 'min': ('di', 'minute____', self.default_func), 'sec': ('di', 'second____', self.default_func), 'revtim': ('di', 'revis-time', self.default_func), 'edmins': ('di', 'edit-time_', self.default_func), 'printim': ('di', 'print-time', self.default_func), 'buptim': ('di', 'backuptime', self.default_func), 'nofwords': ('di', 'num-of-wor', self.default_func), 'nofchars': ('di', 'num-of-chr', self.default_func), 'nofcharsws': ('di', 'numofchrws', self.default_func), 'nofpages': ('di', 'num-of-pag', self.default_func), 'version': ('di', 'version___', self.default_func), 'vern': ('di', 'intern-ver', self.default_func), 'hlinkbase': ('di', 'linkbase__', self.default_func), 'id': ('di', 'internalID', self.default_func), 'headerf': ('hf', 'head-first', self.default_func), 'headerl': ('hf', 'head-left_', self.default_func), 'headerr': ('hf', 'head-right', self.default_func), 'footerf': ('hf', 'foot-first', self.default_func), 'footerl': ('hf', 'foot-left_', self.default_func), 'footerr': ('hf', 'foot-right', self.default_func), 'header': ('hf', 'header____', self.default_func), 'footer': ('hf', 'footer____', self.default_func), 'margl': ('pa', 'margin-lef', self.divide_by_20), 'margr': ('pa', 'margin-rig', self.divide_by_20), 'margb': ('pa', 'margin-bot', self.divide_by_20), 'margt': ('pa', 'margin-top', self.divide_by_20), 'gutter': ('pa', 'gutter____', self.divide_by_20), 'paperw': ('pa', 'paper-widt', self.divide_by_20), 'paperh': ('pa', 'paper-hght', self.divide_by_20), 'annotation': ('an', 'annotation', self.default_func), 'trbrdrh': ('bd', 'bor-t-r-hi', self.default_func), 'trbrdrv': ('bd', 'bor-t-r-vi', self.default_func), 'trbrdrt': ('bd', 'bor-t-r-to', self.default_func), 'trbrdrl': ('bd', 'bor-t-r-le', self.default_func), 'trbrdrb': ('bd', 'bor-t-r-bo', self.default_func), 'trbrdrr': ('bd', 'bor-t-r-ri', self.default_func), 'clbrdrb': ('bd', 'bor-cel-bo', self.default_func), 'clbrdrt': ('bd', 'bor-cel-to', self.default_func), 'clbrdrl': ('bd', 'bor-cel-le', self.default_func), 'clbrdrr': ('bd', 'bor-cel-ri', self.default_func), 'brdrb': ('bd', 'bor-par-bo', self.default_func), 'brdrt': ('bd', 'bor-par-to', self.default_func), 'brdrl': ('bd', 'bor-par-le', self.default_func), 'brdrr': ('bd', 'bor-par-ri', self.default_func), 'box': ('bd', 'bor-par-bx', self.default_func), 'chbrdr': ('bd', 'bor-par-bo', self.default_func), 'brdrbtw': ('bd', 'bor-for-ev', self.default_func), 'brdrbar': ('bd', 'bor-outsid', self.default_func), 'brdrnone': ('bd', 'bor-none__<false', self.two_part_func), 'brdrs': ('bt', 'bdr-single', self.default_func), 'brdrth': ('bt', 'bdr-doubtb', self.default_func), 'brdrsh': ('bt', 'bdr-shadow', self.default_func), 'brdrdb': ('bt', 'bdr-double', self.default_func), 'brdrdot': ('bt', 'bdr-dotted', self.default_func), 'brdrdash': ('bt', 'bdr-dashed', self.default_func), 'brdrhair': ('bt', 'bdr-hair__', self.default_func), 'brdrinset': ('bt', 'bdr-inset_', self.default_func), 'brdrdashsm': ('bt', 'bdr-das-sm', self.default_func), 'brdrdashd': ('bt', 'bdr-dot-sm', self.default_func), 'brdrdashdd': ('bt', 'bdr-dot-do', self.default_func), 'brdroutset': ('bt', 'bdr-outset', self.default_func), 'brdrtriple': ('bt', 'bdr-trippl', self.default_func), 'brdrtnthsg': ('bt', 'bdr-thsm__', self.default_func), 'brdrthtnsg': ('bt', 'bdr-htsm__', self.default_func), 'brdrtnthtnsg': ('bt', 'bdr-hthsm_', self.default_func), 'brdrtnthmg': ('bt', 'bdr-thm___', self.default_func), 'brdrthtnmg': ('bt', 'bdr-htm___', self.default_func), 'brdrtnthtnmg': ('bt', 'bdr-hthm__', self.default_func), 'brdrtnthlg': ('bt', 'bdr-thl___', self.default_func), 'brdrtnthtnlg': ('bt', 'bdr-hthl__', self.default_func), 'brdrwavy': ('bt', 'bdr-wavy__', self.default_func), 'brdrwavydb': ('bt', 'bdr-d-wav_', self.default_func), 'brdrdashdotstr': ('bt', 'bdr-strip_', self.default_func), 'brdremboss': ('bt', 'bdr-embos_', self.default_func), 'brdrengrave': ('bt', 'bdr-engra_', self.default_func), 'brdrframe': ('bt', 'bdr-frame_', self.default_func), 'brdrw': ('bt', 'bdr-li-wid', self.divide_by_20), 'brsp': ('bt', 'bdr-sp-wid', self.divide_by_20), 'brdrcf': ('bt', 'bdr-color_', self.default_func)}\n    self.__number_type_dict = {0: 'Arabic', 1: 'uppercase Roman numeral', 2: 'lowercase Roman numeral', 3: 'uppercase letter', 4: 'lowercase letter', 5: 'ordinal number', 6: 'cardianl text number', 7: 'ordinal text number', 10: 'Kanji numbering without the digit character', 11: 'Kanji numbering with the digit character', 1246: 'phonetic Katakana characters in aiueo order', 1346: 'phonetic katakana characters in iroha order', 14: 'double byte character', 15: 'single byte character', 16: 'Kanji numbering 3', 17: 'Kanji numbering 4', 18: 'Circle numbering', 19: 'double-byte Arabic numbering', 2046: 'phonetic double-byte Katakana characters', 2146: 'phonetic double-byte katakana characters', 22: 'Arabic with leading zero', 23: 'bullet', 24: 'Korean numbering 2', 25: 'Korean numbering 1', 26: 'Chinese numbering 1', 27: 'Chinese numbering 2', 28: 'Chinese numbering 3', 29: 'Chinese numbering 4', 30: 'Chinese Zodiac numbering 1', 31: 'Chinese Zodiac numbering 2', 32: 'Chinese Zodiac numbering 3', 33: 'Taiwanese double-byte numbering 1', 34: 'Taiwanese double-byte numbering 2', 35: 'Taiwanese double-byte numbering 3', 36: 'Taiwanese double-byte numbering 4', 37: 'Chinese double-byte numbering 1', 38: 'Chinese double-byte numbering 2', 39: 'Chinese double-byte numbering 3', 40: 'Chinese double-byte numbering 4', 41: 'Korean double-byte numbering 1', 42: 'Korean double-byte numbering 2', 43: 'Korean double-byte numbering 3', 44: 'Korean double-byte numbering 4', 45: 'Hebrew non-standard decimal', 46: 'Arabic Alif Ba Tah', 47: 'Hebrew Biblical standard', 48: 'Arabic Abjad style', 255: 'No number'}\n    self.__language_dict = {1078: 'Afrikaans', 1052: 'Albanian', 1025: 'Arabic', 5121: 'Arabic Algeria', 15361: 'Arabic Bahrain', 3073: 'Arabic Egypt', 1: 'Arabic General', 2049: 'Arabic Iraq', 11265: 'Arabic Jordan', 13313: 'Arabic Kuwait', 12289: 'Arabic Lebanon', 4097: 'Arabic Libya', 6145: 'Arabic Morocco', 8193: 'Arabic Oman', 16385: 'Arabic Qatar', 10241: 'Arabic Syria', 7169: 'Arabic Tunisia', 14337: 'Arabic U.A.E.', 9217: 'Arabic Yemen', 1067: 'Armenian', 1101: 'Assamese', 2092: 'Azeri Cyrillic', 1068: 'Azeri Latin', 1069: 'Basque', 1093: 'Bengali', 4122: 'Bosnia Herzegovina', 1026: 'Bulgarian', 1109: 'Burmese', 1059: 'Byelorussian', 1027: 'Catalan', 2052: 'Chinese China', 4: 'Chinese General', 3076: 'Chinese Hong Kong', 4100: 'Chinese Singapore', 1028: 'Chinese Taiwan', 1050: 'Croatian', 1029: 'Czech', 1030: 'Danish', 2067: 'Dutch Belgium', 1043: 'Dutch Standard', 3081: 'English Australia', 10249: 'English Belize', 2057: 'English British', 4105: 'English Canada', 9225: 'English Caribbean', 9: 'English General', 6153: 'English Ireland', 8201: 'English Jamaica', 5129: 'English New Zealand', 13321: 'English Philippines', 7177: 'English South Africa', 11273: 'English Trinidad', 1033: 'English United States', 1061: 'Estonian', 1080: 'Faerose', 1065: 'Farsi', 1035: 'Finnish', 1036: 'French', 2060: 'French Belgium', 11276: 'French Cameroon', 3084: 'French Canada', 12300: \"French Cote d'Ivoire\", 5132: 'French Luxembourg', 13324: 'French Mali', 6156: 'French Monaco', 8204: 'French Reunion', 10252: 'French Senegal', 4108: 'French Swiss', 7180: 'French West Indies', 9228: 'French Democratic Republic of the Congo', 1122: 'Frisian', 1084: 'Gaelic', 2108: 'Gaelic Ireland', 1110: 'Galician', 1079: 'Georgian', 1031: 'German', 3079: 'German Austrian', 5127: 'German Liechtenstein', 4103: 'German Luxembourg', 2055: 'German Switzerland', 1032: 'Greek', 1095: 'Gujarati', 1037: 'Hebrew', 1081: 'Hindi', 1038: 'Hungarian', 1039: 'Icelandic', 1057: 'Indonesian', 1040: 'Italian', 2064: 'Italian Switzerland', 1041: 'Japanese', 1099: 'Kannada', 1120: 'Kashmiri', 2144: 'Kashmiri India', 1087: 'Kazakh', 1107: 'Khmer', 1088: 'Kirghiz', 1111: 'Konkani', 1042: 'Korean', 2066: 'Korean Johab', 1108: 'Lao', 1062: 'Latvian', 1063: 'Lithuanian', 2087: 'Lithuanian Classic', 1086: 'Malay', 2110: 'Malay Brunei Darussalam', 1100: 'Malayalam', 1082: 'Maltese', 1112: 'Manipuri', 1102: 'Marathi', 1104: 'Mongolian', 1121: 'Nepali', 2145: 'Nepali India', 1044: 'Norwegian Bokmal', 2068: 'Norwegian Nynorsk', 1096: 'Oriya', 1045: 'Polish', 1046: 'Portuguese (Brazil)', 2070: 'Portuguese (Portugal)', 1094: 'Punjabi', 1047: 'Rhaeto-Romanic', 1048: 'Romanian', 2072: 'Romanian Moldova', 1049: 'Russian', 2073: 'Russian Moldova', 1083: 'Sami Lappish', 1103: 'Sanskrit', 3098: 'Serbian Cyrillic', 2074: 'Serbian Latin', 1113: 'Sindhi', 1051: 'Slovak', 1060: 'Slovenian', 1070: 'Sorbian', 11274: 'Spanish Argentina', 16394: 'Spanish Bolivia', 13322: 'Spanish Chile', 9226: 'Spanish Colombia', 5130: 'Spanish Costa Rica', 7178: 'Spanish Dominican Republic', 12298: 'Spanish Ecuador', 17418: 'Spanish El Salvador', 4106: 'Spanish Guatemala', 18442: 'Spanish Honduras', 2058: 'Spanish Mexico', 3082: 'Spanish Modern', 19466: 'Spanish Nicaragua', 6154: 'Spanish Panama', 15370: 'Spanish Paraguay', 10250: 'Spanish Peru', 20490: 'Spanish Puerto Rico', 1034: 'Spanish Traditional', 14346: 'Spanish Uruguay', 8202: 'Spanish Venezuela', 1072: 'Sutu', 1089: 'Swahili', 1053: 'Swedish', 2077: 'Swedish Finland', 1064: 'Tajik', 1097: 'Tamil', 1092: 'Tatar', 1098: 'Telugu', 1054: 'Thai', 1105: 'Tibetan', 1073: 'Tsonga', 1074: 'Tswana', 1055: 'Turkish', 1090: 'Turkmen', 1058: 'Ukranian', 1056: 'Urdu', 2080: 'Urdu India', 2115: 'Uzbek Cyrillic', 1091: 'Uzbek Latin', 1075: 'Venda', 1066: 'Vietnamese', 1106: 'Welsh', 1076: 'Xhosa', 1085: 'Yiddish', 1077: 'Zulu', 1024: 'Unkown', 255: 'Unkown'}",
            "def initiate_token_dict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__return_code = 0\n    self.dict_token = {'mshex': ('nu', '__________', self.__ms_hex_func), '{': ('nu', '{', self.ob_func), '}': ('nu', '}', self.cb_func), 'ldblquote': ('mc', 'ldblquote', self.ms_sub_func), 'rdblquote': ('mc', 'rdblquote', self.ms_sub_func), 'rquote': ('mc', 'rquote', self.ms_sub_func), 'lquote': ('mc', 'lquote', self.ms_sub_func), 'emdash': ('mc', 'emdash', self.ms_sub_func), 'endash': ('mc', 'endash', self.ms_sub_func), 'bullet': ('mc', 'bullet', self.ms_sub_func), '~': ('mc', '~', self.ms_sub_func), 'tab': ('mc', 'tab', self.ms_sub_func), '_': ('mc', '_', self.ms_sub_func), ';': ('mc', ';', self.ms_sub_func), '-': ('mc', '-', self.ms_sub_func), 'line': ('mi', 'hardline-break', self.direct_conv_func), '*': ('ml', 'asterisk__', self.default_func), ':': ('ml', 'colon_____', self.default_func), 'backslash': ('nu', '\\\\', self.text_func), 'ob': ('nu', '{', self.text_func), 'cb': ('nu', '}', self.text_func), 'page': ('pf', 'page-break', self.default_func), 'par': ('pf', 'par-end___', self.default_func), 'pard': ('pf', 'par-def___', self.default_func), 'keepn': ('pf', 'keep-w-nex', self.bool_st_func), 'widctlpar': ('pf', 'widow-cntl', self.bool_st_func), 'adjustright': ('pf', 'adjust-rgt', self.bool_st_func), 'lang': ('pf', 'language__', self.__language_func), 'ri': ('pf', 'right-inde', self.divide_by_20), 'fi': ('pf', 'fir-ln-ind', self.divide_by_20), 'li': ('pf', 'left-inden', self.divide_by_20), 'sb': ('pf', 'space-befo', self.divide_by_20), 'sa': ('pf', 'space-afte', self.divide_by_20), 'sl': ('pf', 'line-space', self.divide_by_20), 'deftab': ('pf', 'default-ta', self.divide_by_20), 'ql': ('pf', 'align_____<left', self.two_part_func), 'qc': ('pf', 'align_____<cent', self.two_part_func), 'qj': ('pf', 'align_____<just', self.two_part_func), 'qr': ('pf', 'align_____<right', self.two_part_func), 'nowidctlpar': ('pf', 'widow-cntr<false', self.two_part_func), 'tx': ('pf', 'tab-stop__', self.divide_by_20), 'tb': ('pf', 'tab-bar-st', self.divide_by_20), 'tqr': ('pf', 'tab-right_', self.default_func), 'tqdec': ('pf', 'tab-dec___', self.default_func), 'tqc': ('pf', 'tab-center', self.default_func), 'tlul': ('pf', 'leader-und', self.default_func), 'tlhyph': ('pf', 'leader-hyp', self.default_func), 'tldot': ('pf', 'leader-dot', self.default_func), 'stylesheet': ('ss', 'style-shet', self.default_func), 'sbasedon': ('ss', 'based-on__', self.default_func), 'snext': ('ss', 'next-style', self.default_func), 'cs': ('ss', 'char-style', self.default_func), 's': ('ss', 'para-style', self.default_func), 'pict': ('gr', 'picture___', self.default_func), 'objclass': ('gr', 'obj-class_', self.default_func), 'macpict': ('gr', 'mac-pic___', self.default_func), 'sect': ('sc', 'section___', self.default_func), 'sectd': ('sc', 'sect-defin', self.default_func), 'endhere': ('sc', 'sect-note_', self.default_func), 'pntext': ('ls', 'list-text_', self.default_func), 'listtext': ('ls', 'list-text_', self.default_func), 'pn': ('ls', 'list______', self.default_func), 'pnseclvl': ('ls', 'list-level', self.default_func), 'pncard': ('ls', 'list-cardi', self.bool_st_func), 'pndec': ('ls', 'list-decim', self.bool_st_func), 'pnucltr': ('ls', 'list-up-al', self.bool_st_func), 'pnucrm': ('ls', 'list-up-ro', self.bool_st_func), 'pnord': ('ls', 'list-ord__', self.bool_st_func), 'pnordt': ('ls', 'list-ordte', self.bool_st_func), 'pnlvlblt': ('ls', 'list-bulli', self.bool_st_func), 'pnlvlbody': ('ls', 'list-simpi', self.bool_st_func), 'pnlvlcont': ('ls', 'list-conti', self.bool_st_func), 'pnhang': ('ls', 'list-hang_', self.bool_st_func), 'pntxtb': ('ls', 'list-tebef', self.bool_st_func), 'ilvl': ('ls', 'list-level', self.default_func), 'ls': ('ls', 'list-id___', self.default_func), 'pnstart': ('ls', 'list-start', self.default_func), 'itap': ('ls', 'nest-level', self.default_func), 'leveltext': ('ls', 'level-text', self.default_func), 'levelnumbers': ('ls', 'level-numb', self.default_func), 'list': ('ls', 'list-in-tb', self.default_func), 'listlevel': ('ls', 'list-tb-le', self.default_func), 'listname': ('ls', 'list-name_', self.default_func), 'listtemplateid': ('ls', 'ls-tem-id_', self.default_func), 'leveltemplateid': ('ls', 'lv-tem-id_', self.default_func), 'listhybrid': ('ls', 'list-hybri', self.default_func), 'levelstartat': ('ls', 'level-star', self.default_func), 'levelspace': ('ls', 'level-spac', self.divide_by_20), 'levelindent': ('ls', 'level-inde', self.default_func), 'levelnfc': ('ls', 'level-type', self.__list_type_func), 'levelnfcn': ('ls', 'level-type', self.__list_type_func), 'listid': ('ls', 'lis-tbl-id', self.default_func), 'listoverride': ('ls', 'lis-overid', self.default_func), 'pnlvl': ('ls', 'list-level', self.default_func), 'rtf': ('ri', 'rtf_______', self.default_func), 'deff': ('ri', 'deflt-font', self.default_func), 'mac': ('ri', 'macintosh_', self.default_func), 'pc': ('ri', 'pc________', self.default_func), 'pca': ('ri', 'pca_______', self.default_func), 'ansi': ('ri', 'ansi______', self.default_func), 'ansicpg': ('ri', 'ansi-codpg', self.default_func), 'footnote': ('nt', 'footnote__', self.default_func), 'ftnalt': ('nt', 'type______<endnote', self.two_part_func), 'tc': ('an', 'toc_______', self.default_func), 'bkmkstt': ('an', 'book-mk-st', self.default_func), 'bkmkstart': ('an', 'book-mk-st', self.default_func), 'bkmkend': ('an', 'book-mk-en', self.default_func), 'xe': ('an', 'index-mark', self.default_func), 'rxe': ('an', 'place_____', self.default_func), 'bxe': ('in', 'index-bold', self.default_func), 'ixe': ('in', 'index-ital', self.default_func), 'txe': ('in', 'index-see_', self.default_func), 'tcl': ('tc', 'toc-level_', self.default_func), 'tcn': ('tc', 'toc-sup-nu', self.default_func), 'field': ('fd', 'field_____', self.default_func), 'fldinst': ('fd', 'field-inst', self.default_func), 'fldrslt': ('fd', 'field-rslt', self.default_func), 'datafield': ('fd', 'datafield_', self.default_func), 'fonttbl': ('it', 'font-table', self.default_func), 'colortbl': ('it', 'colr-table', self.default_func), 'listoverridetable': ('it', 'lovr-table', self.default_func), 'listtable': ('it', 'listtable_', self.default_func), 'revtbl': ('it', 'revi-table', self.default_func), 'b': ('ci', 'bold______', self.bool_st_func), 'blue': ('ci', 'blue______', self.color_func), 'caps': ('ci', 'caps______', self.bool_st_func), 'cf': ('ci', 'font-color', self.colorz_func), 'chftn': ('ci', 'footnot-mk', self.bool_st_func), 'dn': ('ci', 'font-down_', self.divide_by_2), 'embo': ('ci', 'emboss____', self.bool_st_func), 'f': ('ci', 'font-style', self.default_func), 'fs': ('ci', 'font-size_', self.divide_by_2), 'green': ('ci', 'green_____', self.color_func), 'i': ('ci', 'italics___', self.bool_st_func), 'impr': ('ci', 'engrave___', self.bool_st_func), 'outl': ('ci', 'outline___', self.bool_st_func), 'plain': ('ci', 'plain_____', self.bool_st_func), 'red': ('ci', 'red_______', self.color_func), 'scaps': ('ci', 'small-caps', self.bool_st_func), 'shad': ('ci', 'shadow____', self.bool_st_func), 'strike': ('ci', 'strike-thr', self.bool_st_func), 'striked': ('ci', 'dbl-strike', self.bool_st_func), 'sub': ('ci', 'subscript_', self.bool_st_func), 'super': ('ci', 'superscrip', self.bool_st_func), 'nosupersub': ('ci', 'no-su-supe', self.__no_sup_sub_func), 'up': ('ci', 'font-up___', self.divide_by_2), 'v': ('ci', 'hidden____', self.default_func), 'ul': ('ci', 'underlined<continous', self.two_part_func), 'uld': ('ci', 'underlined<dotted', self.two_part_func), 'uldash': ('ci', 'underlined<dash', self.two_part_func), 'uldashd': ('ci', 'underlined<dash-dot', self.two_part_func), 'uldashdd': ('ci', 'underlined<dash-dot-dot', self.two_part_func), 'uldb': ('ci', 'underlined<double', self.two_part_func), 'ulhwave': ('ci', 'underlined<heavy-wave', self.two_part_func), 'ulldash': ('ci', 'underlined<long-dash', self.two_part_func), 'ulth': ('ci', 'underlined<thich', self.two_part_func), 'ulthd': ('ci', 'underlined<thick-dotted', self.two_part_func), 'ulthdash': ('ci', 'underlined<thick-dash', self.two_part_func), 'ulthdashd': ('ci', 'underlined<thick-dash-dot', self.two_part_func), 'ulthdashdd': ('ci', 'underlined<thick-dash-dot-dot', self.two_part_func), 'ulthldash': ('ci', 'underlined<thick-long-dash', self.two_part_func), 'ululdbwave': ('ci', 'underlined<double-wave', self.two_part_func), 'ulw': ('ci', 'underlined<word', self.two_part_func), 'ulwave': ('ci', 'underlined<wave', self.two_part_func), 'ulnone': ('ci', 'underlined<false', self.two_part_func), 'trowd': ('tb', 'row-def___', self.default_func), 'cell': ('tb', 'cell______', self.default_func), 'row': ('tb', 'row_______', self.default_func), 'intbl': ('tb', 'in-table__', self.default_func), 'cols': ('tb', 'columns___', self.default_func), 'trleft': ('tb', 'row-pos-le', self.divide_by_20), 'cellx': ('tb', 'cell-posit', self.divide_by_20), 'trhdr': ('tb', 'row-header', self.default_func), 'info': ('di', 'doc-info__', self.default_func), 'title': ('di', 'title_____', self.default_func), 'author': ('di', 'author____', self.default_func), 'operator': ('di', 'operator__', self.default_func), 'manager': ('di', 'manager___', self.default_func), 'company': ('di', 'company___', self.default_func), 'keywords': ('di', 'keywords__', self.default_func), 'category': ('di', 'category__', self.default_func), 'doccomm': ('di', 'doc-notes_', self.default_func), 'comment': ('di', 'doc-notes_', self.default_func), 'subject': ('di', 'subject___', self.default_func), 'creatim': ('di', 'create-tim', self.default_func), 'yr': ('di', 'year______', self.default_func), 'mo': ('di', 'month_____', self.default_func), 'dy': ('di', 'day_______', self.default_func), 'min': ('di', 'minute____', self.default_func), 'sec': ('di', 'second____', self.default_func), 'revtim': ('di', 'revis-time', self.default_func), 'edmins': ('di', 'edit-time_', self.default_func), 'printim': ('di', 'print-time', self.default_func), 'buptim': ('di', 'backuptime', self.default_func), 'nofwords': ('di', 'num-of-wor', self.default_func), 'nofchars': ('di', 'num-of-chr', self.default_func), 'nofcharsws': ('di', 'numofchrws', self.default_func), 'nofpages': ('di', 'num-of-pag', self.default_func), 'version': ('di', 'version___', self.default_func), 'vern': ('di', 'intern-ver', self.default_func), 'hlinkbase': ('di', 'linkbase__', self.default_func), 'id': ('di', 'internalID', self.default_func), 'headerf': ('hf', 'head-first', self.default_func), 'headerl': ('hf', 'head-left_', self.default_func), 'headerr': ('hf', 'head-right', self.default_func), 'footerf': ('hf', 'foot-first', self.default_func), 'footerl': ('hf', 'foot-left_', self.default_func), 'footerr': ('hf', 'foot-right', self.default_func), 'header': ('hf', 'header____', self.default_func), 'footer': ('hf', 'footer____', self.default_func), 'margl': ('pa', 'margin-lef', self.divide_by_20), 'margr': ('pa', 'margin-rig', self.divide_by_20), 'margb': ('pa', 'margin-bot', self.divide_by_20), 'margt': ('pa', 'margin-top', self.divide_by_20), 'gutter': ('pa', 'gutter____', self.divide_by_20), 'paperw': ('pa', 'paper-widt', self.divide_by_20), 'paperh': ('pa', 'paper-hght', self.divide_by_20), 'annotation': ('an', 'annotation', self.default_func), 'trbrdrh': ('bd', 'bor-t-r-hi', self.default_func), 'trbrdrv': ('bd', 'bor-t-r-vi', self.default_func), 'trbrdrt': ('bd', 'bor-t-r-to', self.default_func), 'trbrdrl': ('bd', 'bor-t-r-le', self.default_func), 'trbrdrb': ('bd', 'bor-t-r-bo', self.default_func), 'trbrdrr': ('bd', 'bor-t-r-ri', self.default_func), 'clbrdrb': ('bd', 'bor-cel-bo', self.default_func), 'clbrdrt': ('bd', 'bor-cel-to', self.default_func), 'clbrdrl': ('bd', 'bor-cel-le', self.default_func), 'clbrdrr': ('bd', 'bor-cel-ri', self.default_func), 'brdrb': ('bd', 'bor-par-bo', self.default_func), 'brdrt': ('bd', 'bor-par-to', self.default_func), 'brdrl': ('bd', 'bor-par-le', self.default_func), 'brdrr': ('bd', 'bor-par-ri', self.default_func), 'box': ('bd', 'bor-par-bx', self.default_func), 'chbrdr': ('bd', 'bor-par-bo', self.default_func), 'brdrbtw': ('bd', 'bor-for-ev', self.default_func), 'brdrbar': ('bd', 'bor-outsid', self.default_func), 'brdrnone': ('bd', 'bor-none__<false', self.two_part_func), 'brdrs': ('bt', 'bdr-single', self.default_func), 'brdrth': ('bt', 'bdr-doubtb', self.default_func), 'brdrsh': ('bt', 'bdr-shadow', self.default_func), 'brdrdb': ('bt', 'bdr-double', self.default_func), 'brdrdot': ('bt', 'bdr-dotted', self.default_func), 'brdrdash': ('bt', 'bdr-dashed', self.default_func), 'brdrhair': ('bt', 'bdr-hair__', self.default_func), 'brdrinset': ('bt', 'bdr-inset_', self.default_func), 'brdrdashsm': ('bt', 'bdr-das-sm', self.default_func), 'brdrdashd': ('bt', 'bdr-dot-sm', self.default_func), 'brdrdashdd': ('bt', 'bdr-dot-do', self.default_func), 'brdroutset': ('bt', 'bdr-outset', self.default_func), 'brdrtriple': ('bt', 'bdr-trippl', self.default_func), 'brdrtnthsg': ('bt', 'bdr-thsm__', self.default_func), 'brdrthtnsg': ('bt', 'bdr-htsm__', self.default_func), 'brdrtnthtnsg': ('bt', 'bdr-hthsm_', self.default_func), 'brdrtnthmg': ('bt', 'bdr-thm___', self.default_func), 'brdrthtnmg': ('bt', 'bdr-htm___', self.default_func), 'brdrtnthtnmg': ('bt', 'bdr-hthm__', self.default_func), 'brdrtnthlg': ('bt', 'bdr-thl___', self.default_func), 'brdrtnthtnlg': ('bt', 'bdr-hthl__', self.default_func), 'brdrwavy': ('bt', 'bdr-wavy__', self.default_func), 'brdrwavydb': ('bt', 'bdr-d-wav_', self.default_func), 'brdrdashdotstr': ('bt', 'bdr-strip_', self.default_func), 'brdremboss': ('bt', 'bdr-embos_', self.default_func), 'brdrengrave': ('bt', 'bdr-engra_', self.default_func), 'brdrframe': ('bt', 'bdr-frame_', self.default_func), 'brdrw': ('bt', 'bdr-li-wid', self.divide_by_20), 'brsp': ('bt', 'bdr-sp-wid', self.divide_by_20), 'brdrcf': ('bt', 'bdr-color_', self.default_func)}\n    self.__number_type_dict = {0: 'Arabic', 1: 'uppercase Roman numeral', 2: 'lowercase Roman numeral', 3: 'uppercase letter', 4: 'lowercase letter', 5: 'ordinal number', 6: 'cardianl text number', 7: 'ordinal text number', 10: 'Kanji numbering without the digit character', 11: 'Kanji numbering with the digit character', 1246: 'phonetic Katakana characters in aiueo order', 1346: 'phonetic katakana characters in iroha order', 14: 'double byte character', 15: 'single byte character', 16: 'Kanji numbering 3', 17: 'Kanji numbering 4', 18: 'Circle numbering', 19: 'double-byte Arabic numbering', 2046: 'phonetic double-byte Katakana characters', 2146: 'phonetic double-byte katakana characters', 22: 'Arabic with leading zero', 23: 'bullet', 24: 'Korean numbering 2', 25: 'Korean numbering 1', 26: 'Chinese numbering 1', 27: 'Chinese numbering 2', 28: 'Chinese numbering 3', 29: 'Chinese numbering 4', 30: 'Chinese Zodiac numbering 1', 31: 'Chinese Zodiac numbering 2', 32: 'Chinese Zodiac numbering 3', 33: 'Taiwanese double-byte numbering 1', 34: 'Taiwanese double-byte numbering 2', 35: 'Taiwanese double-byte numbering 3', 36: 'Taiwanese double-byte numbering 4', 37: 'Chinese double-byte numbering 1', 38: 'Chinese double-byte numbering 2', 39: 'Chinese double-byte numbering 3', 40: 'Chinese double-byte numbering 4', 41: 'Korean double-byte numbering 1', 42: 'Korean double-byte numbering 2', 43: 'Korean double-byte numbering 3', 44: 'Korean double-byte numbering 4', 45: 'Hebrew non-standard decimal', 46: 'Arabic Alif Ba Tah', 47: 'Hebrew Biblical standard', 48: 'Arabic Abjad style', 255: 'No number'}\n    self.__language_dict = {1078: 'Afrikaans', 1052: 'Albanian', 1025: 'Arabic', 5121: 'Arabic Algeria', 15361: 'Arabic Bahrain', 3073: 'Arabic Egypt', 1: 'Arabic General', 2049: 'Arabic Iraq', 11265: 'Arabic Jordan', 13313: 'Arabic Kuwait', 12289: 'Arabic Lebanon', 4097: 'Arabic Libya', 6145: 'Arabic Morocco', 8193: 'Arabic Oman', 16385: 'Arabic Qatar', 10241: 'Arabic Syria', 7169: 'Arabic Tunisia', 14337: 'Arabic U.A.E.', 9217: 'Arabic Yemen', 1067: 'Armenian', 1101: 'Assamese', 2092: 'Azeri Cyrillic', 1068: 'Azeri Latin', 1069: 'Basque', 1093: 'Bengali', 4122: 'Bosnia Herzegovina', 1026: 'Bulgarian', 1109: 'Burmese', 1059: 'Byelorussian', 1027: 'Catalan', 2052: 'Chinese China', 4: 'Chinese General', 3076: 'Chinese Hong Kong', 4100: 'Chinese Singapore', 1028: 'Chinese Taiwan', 1050: 'Croatian', 1029: 'Czech', 1030: 'Danish', 2067: 'Dutch Belgium', 1043: 'Dutch Standard', 3081: 'English Australia', 10249: 'English Belize', 2057: 'English British', 4105: 'English Canada', 9225: 'English Caribbean', 9: 'English General', 6153: 'English Ireland', 8201: 'English Jamaica', 5129: 'English New Zealand', 13321: 'English Philippines', 7177: 'English South Africa', 11273: 'English Trinidad', 1033: 'English United States', 1061: 'Estonian', 1080: 'Faerose', 1065: 'Farsi', 1035: 'Finnish', 1036: 'French', 2060: 'French Belgium', 11276: 'French Cameroon', 3084: 'French Canada', 12300: \"French Cote d'Ivoire\", 5132: 'French Luxembourg', 13324: 'French Mali', 6156: 'French Monaco', 8204: 'French Reunion', 10252: 'French Senegal', 4108: 'French Swiss', 7180: 'French West Indies', 9228: 'French Democratic Republic of the Congo', 1122: 'Frisian', 1084: 'Gaelic', 2108: 'Gaelic Ireland', 1110: 'Galician', 1079: 'Georgian', 1031: 'German', 3079: 'German Austrian', 5127: 'German Liechtenstein', 4103: 'German Luxembourg', 2055: 'German Switzerland', 1032: 'Greek', 1095: 'Gujarati', 1037: 'Hebrew', 1081: 'Hindi', 1038: 'Hungarian', 1039: 'Icelandic', 1057: 'Indonesian', 1040: 'Italian', 2064: 'Italian Switzerland', 1041: 'Japanese', 1099: 'Kannada', 1120: 'Kashmiri', 2144: 'Kashmiri India', 1087: 'Kazakh', 1107: 'Khmer', 1088: 'Kirghiz', 1111: 'Konkani', 1042: 'Korean', 2066: 'Korean Johab', 1108: 'Lao', 1062: 'Latvian', 1063: 'Lithuanian', 2087: 'Lithuanian Classic', 1086: 'Malay', 2110: 'Malay Brunei Darussalam', 1100: 'Malayalam', 1082: 'Maltese', 1112: 'Manipuri', 1102: 'Marathi', 1104: 'Mongolian', 1121: 'Nepali', 2145: 'Nepali India', 1044: 'Norwegian Bokmal', 2068: 'Norwegian Nynorsk', 1096: 'Oriya', 1045: 'Polish', 1046: 'Portuguese (Brazil)', 2070: 'Portuguese (Portugal)', 1094: 'Punjabi', 1047: 'Rhaeto-Romanic', 1048: 'Romanian', 2072: 'Romanian Moldova', 1049: 'Russian', 2073: 'Russian Moldova', 1083: 'Sami Lappish', 1103: 'Sanskrit', 3098: 'Serbian Cyrillic', 2074: 'Serbian Latin', 1113: 'Sindhi', 1051: 'Slovak', 1060: 'Slovenian', 1070: 'Sorbian', 11274: 'Spanish Argentina', 16394: 'Spanish Bolivia', 13322: 'Spanish Chile', 9226: 'Spanish Colombia', 5130: 'Spanish Costa Rica', 7178: 'Spanish Dominican Republic', 12298: 'Spanish Ecuador', 17418: 'Spanish El Salvador', 4106: 'Spanish Guatemala', 18442: 'Spanish Honduras', 2058: 'Spanish Mexico', 3082: 'Spanish Modern', 19466: 'Spanish Nicaragua', 6154: 'Spanish Panama', 15370: 'Spanish Paraguay', 10250: 'Spanish Peru', 20490: 'Spanish Puerto Rico', 1034: 'Spanish Traditional', 14346: 'Spanish Uruguay', 8202: 'Spanish Venezuela', 1072: 'Sutu', 1089: 'Swahili', 1053: 'Swedish', 2077: 'Swedish Finland', 1064: 'Tajik', 1097: 'Tamil', 1092: 'Tatar', 1098: 'Telugu', 1054: 'Thai', 1105: 'Tibetan', 1073: 'Tsonga', 1074: 'Tswana', 1055: 'Turkish', 1090: 'Turkmen', 1058: 'Ukranian', 1056: 'Urdu', 2080: 'Urdu India', 2115: 'Uzbek Cyrillic', 1091: 'Uzbek Latin', 1075: 'Venda', 1066: 'Vietnamese', 1106: 'Welsh', 1076: 'Xhosa', 1085: 'Yiddish', 1077: 'Zulu', 1024: 'Unkown', 255: 'Unkown'}",
            "def initiate_token_dict(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__return_code = 0\n    self.dict_token = {'mshex': ('nu', '__________', self.__ms_hex_func), '{': ('nu', '{', self.ob_func), '}': ('nu', '}', self.cb_func), 'ldblquote': ('mc', 'ldblquote', self.ms_sub_func), 'rdblquote': ('mc', 'rdblquote', self.ms_sub_func), 'rquote': ('mc', 'rquote', self.ms_sub_func), 'lquote': ('mc', 'lquote', self.ms_sub_func), 'emdash': ('mc', 'emdash', self.ms_sub_func), 'endash': ('mc', 'endash', self.ms_sub_func), 'bullet': ('mc', 'bullet', self.ms_sub_func), '~': ('mc', '~', self.ms_sub_func), 'tab': ('mc', 'tab', self.ms_sub_func), '_': ('mc', '_', self.ms_sub_func), ';': ('mc', ';', self.ms_sub_func), '-': ('mc', '-', self.ms_sub_func), 'line': ('mi', 'hardline-break', self.direct_conv_func), '*': ('ml', 'asterisk__', self.default_func), ':': ('ml', 'colon_____', self.default_func), 'backslash': ('nu', '\\\\', self.text_func), 'ob': ('nu', '{', self.text_func), 'cb': ('nu', '}', self.text_func), 'page': ('pf', 'page-break', self.default_func), 'par': ('pf', 'par-end___', self.default_func), 'pard': ('pf', 'par-def___', self.default_func), 'keepn': ('pf', 'keep-w-nex', self.bool_st_func), 'widctlpar': ('pf', 'widow-cntl', self.bool_st_func), 'adjustright': ('pf', 'adjust-rgt', self.bool_st_func), 'lang': ('pf', 'language__', self.__language_func), 'ri': ('pf', 'right-inde', self.divide_by_20), 'fi': ('pf', 'fir-ln-ind', self.divide_by_20), 'li': ('pf', 'left-inden', self.divide_by_20), 'sb': ('pf', 'space-befo', self.divide_by_20), 'sa': ('pf', 'space-afte', self.divide_by_20), 'sl': ('pf', 'line-space', self.divide_by_20), 'deftab': ('pf', 'default-ta', self.divide_by_20), 'ql': ('pf', 'align_____<left', self.two_part_func), 'qc': ('pf', 'align_____<cent', self.two_part_func), 'qj': ('pf', 'align_____<just', self.two_part_func), 'qr': ('pf', 'align_____<right', self.two_part_func), 'nowidctlpar': ('pf', 'widow-cntr<false', self.two_part_func), 'tx': ('pf', 'tab-stop__', self.divide_by_20), 'tb': ('pf', 'tab-bar-st', self.divide_by_20), 'tqr': ('pf', 'tab-right_', self.default_func), 'tqdec': ('pf', 'tab-dec___', self.default_func), 'tqc': ('pf', 'tab-center', self.default_func), 'tlul': ('pf', 'leader-und', self.default_func), 'tlhyph': ('pf', 'leader-hyp', self.default_func), 'tldot': ('pf', 'leader-dot', self.default_func), 'stylesheet': ('ss', 'style-shet', self.default_func), 'sbasedon': ('ss', 'based-on__', self.default_func), 'snext': ('ss', 'next-style', self.default_func), 'cs': ('ss', 'char-style', self.default_func), 's': ('ss', 'para-style', self.default_func), 'pict': ('gr', 'picture___', self.default_func), 'objclass': ('gr', 'obj-class_', self.default_func), 'macpict': ('gr', 'mac-pic___', self.default_func), 'sect': ('sc', 'section___', self.default_func), 'sectd': ('sc', 'sect-defin', self.default_func), 'endhere': ('sc', 'sect-note_', self.default_func), 'pntext': ('ls', 'list-text_', self.default_func), 'listtext': ('ls', 'list-text_', self.default_func), 'pn': ('ls', 'list______', self.default_func), 'pnseclvl': ('ls', 'list-level', self.default_func), 'pncard': ('ls', 'list-cardi', self.bool_st_func), 'pndec': ('ls', 'list-decim', self.bool_st_func), 'pnucltr': ('ls', 'list-up-al', self.bool_st_func), 'pnucrm': ('ls', 'list-up-ro', self.bool_st_func), 'pnord': ('ls', 'list-ord__', self.bool_st_func), 'pnordt': ('ls', 'list-ordte', self.bool_st_func), 'pnlvlblt': ('ls', 'list-bulli', self.bool_st_func), 'pnlvlbody': ('ls', 'list-simpi', self.bool_st_func), 'pnlvlcont': ('ls', 'list-conti', self.bool_st_func), 'pnhang': ('ls', 'list-hang_', self.bool_st_func), 'pntxtb': ('ls', 'list-tebef', self.bool_st_func), 'ilvl': ('ls', 'list-level', self.default_func), 'ls': ('ls', 'list-id___', self.default_func), 'pnstart': ('ls', 'list-start', self.default_func), 'itap': ('ls', 'nest-level', self.default_func), 'leveltext': ('ls', 'level-text', self.default_func), 'levelnumbers': ('ls', 'level-numb', self.default_func), 'list': ('ls', 'list-in-tb', self.default_func), 'listlevel': ('ls', 'list-tb-le', self.default_func), 'listname': ('ls', 'list-name_', self.default_func), 'listtemplateid': ('ls', 'ls-tem-id_', self.default_func), 'leveltemplateid': ('ls', 'lv-tem-id_', self.default_func), 'listhybrid': ('ls', 'list-hybri', self.default_func), 'levelstartat': ('ls', 'level-star', self.default_func), 'levelspace': ('ls', 'level-spac', self.divide_by_20), 'levelindent': ('ls', 'level-inde', self.default_func), 'levelnfc': ('ls', 'level-type', self.__list_type_func), 'levelnfcn': ('ls', 'level-type', self.__list_type_func), 'listid': ('ls', 'lis-tbl-id', self.default_func), 'listoverride': ('ls', 'lis-overid', self.default_func), 'pnlvl': ('ls', 'list-level', self.default_func), 'rtf': ('ri', 'rtf_______', self.default_func), 'deff': ('ri', 'deflt-font', self.default_func), 'mac': ('ri', 'macintosh_', self.default_func), 'pc': ('ri', 'pc________', self.default_func), 'pca': ('ri', 'pca_______', self.default_func), 'ansi': ('ri', 'ansi______', self.default_func), 'ansicpg': ('ri', 'ansi-codpg', self.default_func), 'footnote': ('nt', 'footnote__', self.default_func), 'ftnalt': ('nt', 'type______<endnote', self.two_part_func), 'tc': ('an', 'toc_______', self.default_func), 'bkmkstt': ('an', 'book-mk-st', self.default_func), 'bkmkstart': ('an', 'book-mk-st', self.default_func), 'bkmkend': ('an', 'book-mk-en', self.default_func), 'xe': ('an', 'index-mark', self.default_func), 'rxe': ('an', 'place_____', self.default_func), 'bxe': ('in', 'index-bold', self.default_func), 'ixe': ('in', 'index-ital', self.default_func), 'txe': ('in', 'index-see_', self.default_func), 'tcl': ('tc', 'toc-level_', self.default_func), 'tcn': ('tc', 'toc-sup-nu', self.default_func), 'field': ('fd', 'field_____', self.default_func), 'fldinst': ('fd', 'field-inst', self.default_func), 'fldrslt': ('fd', 'field-rslt', self.default_func), 'datafield': ('fd', 'datafield_', self.default_func), 'fonttbl': ('it', 'font-table', self.default_func), 'colortbl': ('it', 'colr-table', self.default_func), 'listoverridetable': ('it', 'lovr-table', self.default_func), 'listtable': ('it', 'listtable_', self.default_func), 'revtbl': ('it', 'revi-table', self.default_func), 'b': ('ci', 'bold______', self.bool_st_func), 'blue': ('ci', 'blue______', self.color_func), 'caps': ('ci', 'caps______', self.bool_st_func), 'cf': ('ci', 'font-color', self.colorz_func), 'chftn': ('ci', 'footnot-mk', self.bool_st_func), 'dn': ('ci', 'font-down_', self.divide_by_2), 'embo': ('ci', 'emboss____', self.bool_st_func), 'f': ('ci', 'font-style', self.default_func), 'fs': ('ci', 'font-size_', self.divide_by_2), 'green': ('ci', 'green_____', self.color_func), 'i': ('ci', 'italics___', self.bool_st_func), 'impr': ('ci', 'engrave___', self.bool_st_func), 'outl': ('ci', 'outline___', self.bool_st_func), 'plain': ('ci', 'plain_____', self.bool_st_func), 'red': ('ci', 'red_______', self.color_func), 'scaps': ('ci', 'small-caps', self.bool_st_func), 'shad': ('ci', 'shadow____', self.bool_st_func), 'strike': ('ci', 'strike-thr', self.bool_st_func), 'striked': ('ci', 'dbl-strike', self.bool_st_func), 'sub': ('ci', 'subscript_', self.bool_st_func), 'super': ('ci', 'superscrip', self.bool_st_func), 'nosupersub': ('ci', 'no-su-supe', self.__no_sup_sub_func), 'up': ('ci', 'font-up___', self.divide_by_2), 'v': ('ci', 'hidden____', self.default_func), 'ul': ('ci', 'underlined<continous', self.two_part_func), 'uld': ('ci', 'underlined<dotted', self.two_part_func), 'uldash': ('ci', 'underlined<dash', self.two_part_func), 'uldashd': ('ci', 'underlined<dash-dot', self.two_part_func), 'uldashdd': ('ci', 'underlined<dash-dot-dot', self.two_part_func), 'uldb': ('ci', 'underlined<double', self.two_part_func), 'ulhwave': ('ci', 'underlined<heavy-wave', self.two_part_func), 'ulldash': ('ci', 'underlined<long-dash', self.two_part_func), 'ulth': ('ci', 'underlined<thich', self.two_part_func), 'ulthd': ('ci', 'underlined<thick-dotted', self.two_part_func), 'ulthdash': ('ci', 'underlined<thick-dash', self.two_part_func), 'ulthdashd': ('ci', 'underlined<thick-dash-dot', self.two_part_func), 'ulthdashdd': ('ci', 'underlined<thick-dash-dot-dot', self.two_part_func), 'ulthldash': ('ci', 'underlined<thick-long-dash', self.two_part_func), 'ululdbwave': ('ci', 'underlined<double-wave', self.two_part_func), 'ulw': ('ci', 'underlined<word', self.two_part_func), 'ulwave': ('ci', 'underlined<wave', self.two_part_func), 'ulnone': ('ci', 'underlined<false', self.two_part_func), 'trowd': ('tb', 'row-def___', self.default_func), 'cell': ('tb', 'cell______', self.default_func), 'row': ('tb', 'row_______', self.default_func), 'intbl': ('tb', 'in-table__', self.default_func), 'cols': ('tb', 'columns___', self.default_func), 'trleft': ('tb', 'row-pos-le', self.divide_by_20), 'cellx': ('tb', 'cell-posit', self.divide_by_20), 'trhdr': ('tb', 'row-header', self.default_func), 'info': ('di', 'doc-info__', self.default_func), 'title': ('di', 'title_____', self.default_func), 'author': ('di', 'author____', self.default_func), 'operator': ('di', 'operator__', self.default_func), 'manager': ('di', 'manager___', self.default_func), 'company': ('di', 'company___', self.default_func), 'keywords': ('di', 'keywords__', self.default_func), 'category': ('di', 'category__', self.default_func), 'doccomm': ('di', 'doc-notes_', self.default_func), 'comment': ('di', 'doc-notes_', self.default_func), 'subject': ('di', 'subject___', self.default_func), 'creatim': ('di', 'create-tim', self.default_func), 'yr': ('di', 'year______', self.default_func), 'mo': ('di', 'month_____', self.default_func), 'dy': ('di', 'day_______', self.default_func), 'min': ('di', 'minute____', self.default_func), 'sec': ('di', 'second____', self.default_func), 'revtim': ('di', 'revis-time', self.default_func), 'edmins': ('di', 'edit-time_', self.default_func), 'printim': ('di', 'print-time', self.default_func), 'buptim': ('di', 'backuptime', self.default_func), 'nofwords': ('di', 'num-of-wor', self.default_func), 'nofchars': ('di', 'num-of-chr', self.default_func), 'nofcharsws': ('di', 'numofchrws', self.default_func), 'nofpages': ('di', 'num-of-pag', self.default_func), 'version': ('di', 'version___', self.default_func), 'vern': ('di', 'intern-ver', self.default_func), 'hlinkbase': ('di', 'linkbase__', self.default_func), 'id': ('di', 'internalID', self.default_func), 'headerf': ('hf', 'head-first', self.default_func), 'headerl': ('hf', 'head-left_', self.default_func), 'headerr': ('hf', 'head-right', self.default_func), 'footerf': ('hf', 'foot-first', self.default_func), 'footerl': ('hf', 'foot-left_', self.default_func), 'footerr': ('hf', 'foot-right', self.default_func), 'header': ('hf', 'header____', self.default_func), 'footer': ('hf', 'footer____', self.default_func), 'margl': ('pa', 'margin-lef', self.divide_by_20), 'margr': ('pa', 'margin-rig', self.divide_by_20), 'margb': ('pa', 'margin-bot', self.divide_by_20), 'margt': ('pa', 'margin-top', self.divide_by_20), 'gutter': ('pa', 'gutter____', self.divide_by_20), 'paperw': ('pa', 'paper-widt', self.divide_by_20), 'paperh': ('pa', 'paper-hght', self.divide_by_20), 'annotation': ('an', 'annotation', self.default_func), 'trbrdrh': ('bd', 'bor-t-r-hi', self.default_func), 'trbrdrv': ('bd', 'bor-t-r-vi', self.default_func), 'trbrdrt': ('bd', 'bor-t-r-to', self.default_func), 'trbrdrl': ('bd', 'bor-t-r-le', self.default_func), 'trbrdrb': ('bd', 'bor-t-r-bo', self.default_func), 'trbrdrr': ('bd', 'bor-t-r-ri', self.default_func), 'clbrdrb': ('bd', 'bor-cel-bo', self.default_func), 'clbrdrt': ('bd', 'bor-cel-to', self.default_func), 'clbrdrl': ('bd', 'bor-cel-le', self.default_func), 'clbrdrr': ('bd', 'bor-cel-ri', self.default_func), 'brdrb': ('bd', 'bor-par-bo', self.default_func), 'brdrt': ('bd', 'bor-par-to', self.default_func), 'brdrl': ('bd', 'bor-par-le', self.default_func), 'brdrr': ('bd', 'bor-par-ri', self.default_func), 'box': ('bd', 'bor-par-bx', self.default_func), 'chbrdr': ('bd', 'bor-par-bo', self.default_func), 'brdrbtw': ('bd', 'bor-for-ev', self.default_func), 'brdrbar': ('bd', 'bor-outsid', self.default_func), 'brdrnone': ('bd', 'bor-none__<false', self.two_part_func), 'brdrs': ('bt', 'bdr-single', self.default_func), 'brdrth': ('bt', 'bdr-doubtb', self.default_func), 'brdrsh': ('bt', 'bdr-shadow', self.default_func), 'brdrdb': ('bt', 'bdr-double', self.default_func), 'brdrdot': ('bt', 'bdr-dotted', self.default_func), 'brdrdash': ('bt', 'bdr-dashed', self.default_func), 'brdrhair': ('bt', 'bdr-hair__', self.default_func), 'brdrinset': ('bt', 'bdr-inset_', self.default_func), 'brdrdashsm': ('bt', 'bdr-das-sm', self.default_func), 'brdrdashd': ('bt', 'bdr-dot-sm', self.default_func), 'brdrdashdd': ('bt', 'bdr-dot-do', self.default_func), 'brdroutset': ('bt', 'bdr-outset', self.default_func), 'brdrtriple': ('bt', 'bdr-trippl', self.default_func), 'brdrtnthsg': ('bt', 'bdr-thsm__', self.default_func), 'brdrthtnsg': ('bt', 'bdr-htsm__', self.default_func), 'brdrtnthtnsg': ('bt', 'bdr-hthsm_', self.default_func), 'brdrtnthmg': ('bt', 'bdr-thm___', self.default_func), 'brdrthtnmg': ('bt', 'bdr-htm___', self.default_func), 'brdrtnthtnmg': ('bt', 'bdr-hthm__', self.default_func), 'brdrtnthlg': ('bt', 'bdr-thl___', self.default_func), 'brdrtnthtnlg': ('bt', 'bdr-hthl__', self.default_func), 'brdrwavy': ('bt', 'bdr-wavy__', self.default_func), 'brdrwavydb': ('bt', 'bdr-d-wav_', self.default_func), 'brdrdashdotstr': ('bt', 'bdr-strip_', self.default_func), 'brdremboss': ('bt', 'bdr-embos_', self.default_func), 'brdrengrave': ('bt', 'bdr-engra_', self.default_func), 'brdrframe': ('bt', 'bdr-frame_', self.default_func), 'brdrw': ('bt', 'bdr-li-wid', self.divide_by_20), 'brsp': ('bt', 'bdr-sp-wid', self.divide_by_20), 'brdrcf': ('bt', 'bdr-color_', self.default_func)}\n    self.__number_type_dict = {0: 'Arabic', 1: 'uppercase Roman numeral', 2: 'lowercase Roman numeral', 3: 'uppercase letter', 4: 'lowercase letter', 5: 'ordinal number', 6: 'cardianl text number', 7: 'ordinal text number', 10: 'Kanji numbering without the digit character', 11: 'Kanji numbering with the digit character', 1246: 'phonetic Katakana characters in aiueo order', 1346: 'phonetic katakana characters in iroha order', 14: 'double byte character', 15: 'single byte character', 16: 'Kanji numbering 3', 17: 'Kanji numbering 4', 18: 'Circle numbering', 19: 'double-byte Arabic numbering', 2046: 'phonetic double-byte Katakana characters', 2146: 'phonetic double-byte katakana characters', 22: 'Arabic with leading zero', 23: 'bullet', 24: 'Korean numbering 2', 25: 'Korean numbering 1', 26: 'Chinese numbering 1', 27: 'Chinese numbering 2', 28: 'Chinese numbering 3', 29: 'Chinese numbering 4', 30: 'Chinese Zodiac numbering 1', 31: 'Chinese Zodiac numbering 2', 32: 'Chinese Zodiac numbering 3', 33: 'Taiwanese double-byte numbering 1', 34: 'Taiwanese double-byte numbering 2', 35: 'Taiwanese double-byte numbering 3', 36: 'Taiwanese double-byte numbering 4', 37: 'Chinese double-byte numbering 1', 38: 'Chinese double-byte numbering 2', 39: 'Chinese double-byte numbering 3', 40: 'Chinese double-byte numbering 4', 41: 'Korean double-byte numbering 1', 42: 'Korean double-byte numbering 2', 43: 'Korean double-byte numbering 3', 44: 'Korean double-byte numbering 4', 45: 'Hebrew non-standard decimal', 46: 'Arabic Alif Ba Tah', 47: 'Hebrew Biblical standard', 48: 'Arabic Abjad style', 255: 'No number'}\n    self.__language_dict = {1078: 'Afrikaans', 1052: 'Albanian', 1025: 'Arabic', 5121: 'Arabic Algeria', 15361: 'Arabic Bahrain', 3073: 'Arabic Egypt', 1: 'Arabic General', 2049: 'Arabic Iraq', 11265: 'Arabic Jordan', 13313: 'Arabic Kuwait', 12289: 'Arabic Lebanon', 4097: 'Arabic Libya', 6145: 'Arabic Morocco', 8193: 'Arabic Oman', 16385: 'Arabic Qatar', 10241: 'Arabic Syria', 7169: 'Arabic Tunisia', 14337: 'Arabic U.A.E.', 9217: 'Arabic Yemen', 1067: 'Armenian', 1101: 'Assamese', 2092: 'Azeri Cyrillic', 1068: 'Azeri Latin', 1069: 'Basque', 1093: 'Bengali', 4122: 'Bosnia Herzegovina', 1026: 'Bulgarian', 1109: 'Burmese', 1059: 'Byelorussian', 1027: 'Catalan', 2052: 'Chinese China', 4: 'Chinese General', 3076: 'Chinese Hong Kong', 4100: 'Chinese Singapore', 1028: 'Chinese Taiwan', 1050: 'Croatian', 1029: 'Czech', 1030: 'Danish', 2067: 'Dutch Belgium', 1043: 'Dutch Standard', 3081: 'English Australia', 10249: 'English Belize', 2057: 'English British', 4105: 'English Canada', 9225: 'English Caribbean', 9: 'English General', 6153: 'English Ireland', 8201: 'English Jamaica', 5129: 'English New Zealand', 13321: 'English Philippines', 7177: 'English South Africa', 11273: 'English Trinidad', 1033: 'English United States', 1061: 'Estonian', 1080: 'Faerose', 1065: 'Farsi', 1035: 'Finnish', 1036: 'French', 2060: 'French Belgium', 11276: 'French Cameroon', 3084: 'French Canada', 12300: \"French Cote d'Ivoire\", 5132: 'French Luxembourg', 13324: 'French Mali', 6156: 'French Monaco', 8204: 'French Reunion', 10252: 'French Senegal', 4108: 'French Swiss', 7180: 'French West Indies', 9228: 'French Democratic Republic of the Congo', 1122: 'Frisian', 1084: 'Gaelic', 2108: 'Gaelic Ireland', 1110: 'Galician', 1079: 'Georgian', 1031: 'German', 3079: 'German Austrian', 5127: 'German Liechtenstein', 4103: 'German Luxembourg', 2055: 'German Switzerland', 1032: 'Greek', 1095: 'Gujarati', 1037: 'Hebrew', 1081: 'Hindi', 1038: 'Hungarian', 1039: 'Icelandic', 1057: 'Indonesian', 1040: 'Italian', 2064: 'Italian Switzerland', 1041: 'Japanese', 1099: 'Kannada', 1120: 'Kashmiri', 2144: 'Kashmiri India', 1087: 'Kazakh', 1107: 'Khmer', 1088: 'Kirghiz', 1111: 'Konkani', 1042: 'Korean', 2066: 'Korean Johab', 1108: 'Lao', 1062: 'Latvian', 1063: 'Lithuanian', 2087: 'Lithuanian Classic', 1086: 'Malay', 2110: 'Malay Brunei Darussalam', 1100: 'Malayalam', 1082: 'Maltese', 1112: 'Manipuri', 1102: 'Marathi', 1104: 'Mongolian', 1121: 'Nepali', 2145: 'Nepali India', 1044: 'Norwegian Bokmal', 2068: 'Norwegian Nynorsk', 1096: 'Oriya', 1045: 'Polish', 1046: 'Portuguese (Brazil)', 2070: 'Portuguese (Portugal)', 1094: 'Punjabi', 1047: 'Rhaeto-Romanic', 1048: 'Romanian', 2072: 'Romanian Moldova', 1049: 'Russian', 2073: 'Russian Moldova', 1083: 'Sami Lappish', 1103: 'Sanskrit', 3098: 'Serbian Cyrillic', 2074: 'Serbian Latin', 1113: 'Sindhi', 1051: 'Slovak', 1060: 'Slovenian', 1070: 'Sorbian', 11274: 'Spanish Argentina', 16394: 'Spanish Bolivia', 13322: 'Spanish Chile', 9226: 'Spanish Colombia', 5130: 'Spanish Costa Rica', 7178: 'Spanish Dominican Republic', 12298: 'Spanish Ecuador', 17418: 'Spanish El Salvador', 4106: 'Spanish Guatemala', 18442: 'Spanish Honduras', 2058: 'Spanish Mexico', 3082: 'Spanish Modern', 19466: 'Spanish Nicaragua', 6154: 'Spanish Panama', 15370: 'Spanish Paraguay', 10250: 'Spanish Peru', 20490: 'Spanish Puerto Rico', 1034: 'Spanish Traditional', 14346: 'Spanish Uruguay', 8202: 'Spanish Venezuela', 1072: 'Sutu', 1089: 'Swahili', 1053: 'Swedish', 2077: 'Swedish Finland', 1064: 'Tajik', 1097: 'Tamil', 1092: 'Tatar', 1098: 'Telugu', 1054: 'Thai', 1105: 'Tibetan', 1073: 'Tsonga', 1074: 'Tswana', 1055: 'Turkish', 1090: 'Turkmen', 1058: 'Ukranian', 1056: 'Urdu', 2080: 'Urdu India', 2115: 'Uzbek Cyrillic', 1091: 'Uzbek Latin', 1075: 'Venda', 1066: 'Vietnamese', 1106: 'Welsh', 1076: 'Xhosa', 1085: 'Yiddish', 1077: 'Zulu', 1024: 'Unkown', 255: 'Unkown'}"
        ]
    },
    {
        "func_name": "__ms_hex_func",
        "original": "def __ms_hex_func(self, pre, token, num):\n    num = num[1:]\n    num = num.upper()\n    return \"tx<hx<__________<'%s\\n\" % num",
        "mutated": [
            "def __ms_hex_func(self, pre, token, num):\n    if False:\n        i = 10\n    num = num[1:]\n    num = num.upper()\n    return \"tx<hx<__________<'%s\\n\" % num",
            "def __ms_hex_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    num = num[1:]\n    num = num.upper()\n    return \"tx<hx<__________<'%s\\n\" % num",
            "def __ms_hex_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    num = num[1:]\n    num = num.upper()\n    return \"tx<hx<__________<'%s\\n\" % num",
            "def __ms_hex_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    num = num[1:]\n    num = num.upper()\n    return \"tx<hx<__________<'%s\\n\" % num",
            "def __ms_hex_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    num = num[1:]\n    num = num.upper()\n    return \"tx<hx<__________<'%s\\n\" % num"
        ]
    },
    {
        "func_name": "ms_sub_func",
        "original": "def ms_sub_func(self, pre, token, num):\n    return 'tx<mc<__________<%s\\n' % token",
        "mutated": [
            "def ms_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n    return 'tx<mc<__________<%s\\n' % token",
            "def ms_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'tx<mc<__________<%s\\n' % token",
            "def ms_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'tx<mc<__________<%s\\n' % token",
            "def ms_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'tx<mc<__________<%s\\n' % token",
            "def ms_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'tx<mc<__________<%s\\n' % token"
        ]
    },
    {
        "func_name": "direct_conv_func",
        "original": "def direct_conv_func(self, pre, token, num):\n    return 'mi<tg<empty_____<%s\\n' % token",
        "mutated": [
            "def direct_conv_func(self, pre, token, num):\n    if False:\n        i = 10\n    return 'mi<tg<empty_____<%s\\n' % token",
            "def direct_conv_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'mi<tg<empty_____<%s\\n' % token",
            "def direct_conv_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'mi<tg<empty_____<%s\\n' % token",
            "def direct_conv_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'mi<tg<empty_____<%s\\n' % token",
            "def direct_conv_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'mi<tg<empty_____<%s\\n' % token"
        ]
    },
    {
        "func_name": "default_func",
        "original": "def default_func(self, pre, token, num):\n    if num is None:\n        num = 'true'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
        "mutated": [
            "def default_func(self, pre, token, num):\n    if False:\n        i = 10\n    if num is None:\n        num = 'true'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def default_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if num is None:\n        num = 'true'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def default_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if num is None:\n        num = 'true'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def default_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if num is None:\n        num = 'true'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def default_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if num is None:\n        num = 'true'\n    return f'cw<{pre}<{token}<nu<{num}\\n'"
        ]
    },
    {
        "func_name": "colorz_func",
        "original": "def colorz_func(self, pre, token, num):\n    if num is None:\n        num = '0'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
        "mutated": [
            "def colorz_func(self, pre, token, num):\n    if False:\n        i = 10\n    if num is None:\n        num = '0'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def colorz_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if num is None:\n        num = '0'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def colorz_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if num is None:\n        num = '0'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def colorz_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if num is None:\n        num = '0'\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def colorz_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if num is None:\n        num = '0'\n    return f'cw<{pre}<{token}<nu<{num}\\n'"
        ]
    },
    {
        "func_name": "__list_type_func",
        "original": "def __list_type_func(self, pre, token, num):\n    type = 'arabic'\n    if num is None:\n        type = 'Arabic'\n    else:\n        try:\n            num = int(num)\n        except ValueError:\n            if self.__run_level > 3:\n                msg = 'Number \"%s\" cannot be converted to integer\\n' % num\n                raise self.__bug_handler(msg)\n        type = self.__number_type_dict.get(num)\n        if type is None:\n            if self.__run_level > 3:\n                msg = 'No type for \"%s\" in self.__number_type_dict\\n'\n                raise self.__bug_handler\n            type = 'Arabic'\n    return f'cw<{pre}<{token}<nu<{type}\\n'",
        "mutated": [
            "def __list_type_func(self, pre, token, num):\n    if False:\n        i = 10\n    type = 'arabic'\n    if num is None:\n        type = 'Arabic'\n    else:\n        try:\n            num = int(num)\n        except ValueError:\n            if self.__run_level > 3:\n                msg = 'Number \"%s\" cannot be converted to integer\\n' % num\n                raise self.__bug_handler(msg)\n        type = self.__number_type_dict.get(num)\n        if type is None:\n            if self.__run_level > 3:\n                msg = 'No type for \"%s\" in self.__number_type_dict\\n'\n                raise self.__bug_handler\n            type = 'Arabic'\n    return f'cw<{pre}<{token}<nu<{type}\\n'",
            "def __list_type_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    type = 'arabic'\n    if num is None:\n        type = 'Arabic'\n    else:\n        try:\n            num = int(num)\n        except ValueError:\n            if self.__run_level > 3:\n                msg = 'Number \"%s\" cannot be converted to integer\\n' % num\n                raise self.__bug_handler(msg)\n        type = self.__number_type_dict.get(num)\n        if type is None:\n            if self.__run_level > 3:\n                msg = 'No type for \"%s\" in self.__number_type_dict\\n'\n                raise self.__bug_handler\n            type = 'Arabic'\n    return f'cw<{pre}<{token}<nu<{type}\\n'",
            "def __list_type_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    type = 'arabic'\n    if num is None:\n        type = 'Arabic'\n    else:\n        try:\n            num = int(num)\n        except ValueError:\n            if self.__run_level > 3:\n                msg = 'Number \"%s\" cannot be converted to integer\\n' % num\n                raise self.__bug_handler(msg)\n        type = self.__number_type_dict.get(num)\n        if type is None:\n            if self.__run_level > 3:\n                msg = 'No type for \"%s\" in self.__number_type_dict\\n'\n                raise self.__bug_handler\n            type = 'Arabic'\n    return f'cw<{pre}<{token}<nu<{type}\\n'",
            "def __list_type_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    type = 'arabic'\n    if num is None:\n        type = 'Arabic'\n    else:\n        try:\n            num = int(num)\n        except ValueError:\n            if self.__run_level > 3:\n                msg = 'Number \"%s\" cannot be converted to integer\\n' % num\n                raise self.__bug_handler(msg)\n        type = self.__number_type_dict.get(num)\n        if type is None:\n            if self.__run_level > 3:\n                msg = 'No type for \"%s\" in self.__number_type_dict\\n'\n                raise self.__bug_handler\n            type = 'Arabic'\n    return f'cw<{pre}<{token}<nu<{type}\\n'",
            "def __list_type_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    type = 'arabic'\n    if num is None:\n        type = 'Arabic'\n    else:\n        try:\n            num = int(num)\n        except ValueError:\n            if self.__run_level > 3:\n                msg = 'Number \"%s\" cannot be converted to integer\\n' % num\n                raise self.__bug_handler(msg)\n        type = self.__number_type_dict.get(num)\n        if type is None:\n            if self.__run_level > 3:\n                msg = 'No type for \"%s\" in self.__number_type_dict\\n'\n                raise self.__bug_handler\n            type = 'Arabic'\n    return f'cw<{pre}<{token}<nu<{type}\\n'"
        ]
    },
    {
        "func_name": "__language_func",
        "original": "def __language_func(self, pre, token, num):\n    lang_name = self.__language_dict.get(int(re.search('[0-9]+', num).group()))\n    if not lang_name:\n        lang_name = 'not defined'\n        if self.__run_level > 3:\n            msg = 'No entry for number \"%s\"' % num\n            raise self.__bug_handler(msg)\n    return f'cw<{pre}<{token}<nu<{lang_name}\\n'",
        "mutated": [
            "def __language_func(self, pre, token, num):\n    if False:\n        i = 10\n    lang_name = self.__language_dict.get(int(re.search('[0-9]+', num).group()))\n    if not lang_name:\n        lang_name = 'not defined'\n        if self.__run_level > 3:\n            msg = 'No entry for number \"%s\"' % num\n            raise self.__bug_handler(msg)\n    return f'cw<{pre}<{token}<nu<{lang_name}\\n'",
            "def __language_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    lang_name = self.__language_dict.get(int(re.search('[0-9]+', num).group()))\n    if not lang_name:\n        lang_name = 'not defined'\n        if self.__run_level > 3:\n            msg = 'No entry for number \"%s\"' % num\n            raise self.__bug_handler(msg)\n    return f'cw<{pre}<{token}<nu<{lang_name}\\n'",
            "def __language_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    lang_name = self.__language_dict.get(int(re.search('[0-9]+', num).group()))\n    if not lang_name:\n        lang_name = 'not defined'\n        if self.__run_level > 3:\n            msg = 'No entry for number \"%s\"' % num\n            raise self.__bug_handler(msg)\n    return f'cw<{pre}<{token}<nu<{lang_name}\\n'",
            "def __language_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    lang_name = self.__language_dict.get(int(re.search('[0-9]+', num).group()))\n    if not lang_name:\n        lang_name = 'not defined'\n        if self.__run_level > 3:\n            msg = 'No entry for number \"%s\"' % num\n            raise self.__bug_handler(msg)\n    return f'cw<{pre}<{token}<nu<{lang_name}\\n'",
            "def __language_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    lang_name = self.__language_dict.get(int(re.search('[0-9]+', num).group()))\n    if not lang_name:\n        lang_name = 'not defined'\n        if self.__run_level > 3:\n            msg = 'No entry for number \"%s\"' % num\n            raise self.__bug_handler(msg)\n    return f'cw<{pre}<{token}<nu<{lang_name}\\n'"
        ]
    },
    {
        "func_name": "two_part_func",
        "original": "def two_part_func(self, pre, token, num):\n    list = token.split('<')\n    token = list[0]\n    num = list[1]\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
        "mutated": [
            "def two_part_func(self, pre, token, num):\n    if False:\n        i = 10\n    list = token.split('<')\n    token = list[0]\n    num = list[1]\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def two_part_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    list = token.split('<')\n    token = list[0]\n    num = list[1]\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def two_part_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    list = token.split('<')\n    token = list[0]\n    num = list[1]\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def two_part_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    list = token.split('<')\n    token = list[0]\n    num = list[1]\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def two_part_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    list = token.split('<')\n    token = list[0]\n    num = list[1]\n    return f'cw<{pre}<{token}<nu<{num}\\n'"
        ]
    },
    {
        "func_name": "divide_by_2",
        "original": "def divide_by_2(self, pre, token, num):\n    num = self.divide_num(num, 2)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
        "mutated": [
            "def divide_by_2(self, pre, token, num):\n    if False:\n        i = 10\n    num = self.divide_num(num, 2)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def divide_by_2(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    num = self.divide_num(num, 2)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def divide_by_2(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    num = self.divide_num(num, 2)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def divide_by_2(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    num = self.divide_num(num, 2)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def divide_by_2(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    num = self.divide_num(num, 2)\n    return f'cw<{pre}<{token}<nu<{num}\\n'"
        ]
    },
    {
        "func_name": "divide_by_20",
        "original": "def divide_by_20(self, pre, token, num):\n    num = self.divide_num(num, 20)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
        "mutated": [
            "def divide_by_20(self, pre, token, num):\n    if False:\n        i = 10\n    num = self.divide_num(num, 20)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def divide_by_20(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    num = self.divide_num(num, 20)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def divide_by_20(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    num = self.divide_num(num, 20)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def divide_by_20(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    num = self.divide_num(num, 20)\n    return f'cw<{pre}<{token}<nu<{num}\\n'",
            "def divide_by_20(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    num = self.divide_num(num, 20)\n    return f'cw<{pre}<{token}<nu<{num}\\n'"
        ]
    },
    {
        "func_name": "text_func",
        "original": "def text_func(self, pre, token, num=None):\n    return 'tx<nu<__________<%s\\n' % token",
        "mutated": [
            "def text_func(self, pre, token, num=None):\n    if False:\n        i = 10\n    return 'tx<nu<__________<%s\\n' % token",
            "def text_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'tx<nu<__________<%s\\n' % token",
            "def text_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'tx<nu<__________<%s\\n' % token",
            "def text_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'tx<nu<__________<%s\\n' % token",
            "def text_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'tx<nu<__________<%s\\n' % token"
        ]
    },
    {
        "func_name": "ob_func",
        "original": "def ob_func(self, pre, token, num=None):\n    self.__bracket_count += 1\n    return 'ob<nu<open-brack<%04d\\n' % self.__bracket_count",
        "mutated": [
            "def ob_func(self, pre, token, num=None):\n    if False:\n        i = 10\n    self.__bracket_count += 1\n    return 'ob<nu<open-brack<%04d\\n' % self.__bracket_count",
            "def ob_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__bracket_count += 1\n    return 'ob<nu<open-brack<%04d\\n' % self.__bracket_count",
            "def ob_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__bracket_count += 1\n    return 'ob<nu<open-brack<%04d\\n' % self.__bracket_count",
            "def ob_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__bracket_count += 1\n    return 'ob<nu<open-brack<%04d\\n' % self.__bracket_count",
            "def ob_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__bracket_count += 1\n    return 'ob<nu<open-brack<%04d\\n' % self.__bracket_count"
        ]
    },
    {
        "func_name": "cb_func",
        "original": "def cb_func(self, pre, token, num=None):\n    line = 'cb<nu<clos-brack<%04d\\n' % self.__bracket_count\n    self.__bracket_count -= 1\n    return line",
        "mutated": [
            "def cb_func(self, pre, token, num=None):\n    if False:\n        i = 10\n    line = 'cb<nu<clos-brack<%04d\\n' % self.__bracket_count\n    self.__bracket_count -= 1\n    return line",
            "def cb_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    line = 'cb<nu<clos-brack<%04d\\n' % self.__bracket_count\n    self.__bracket_count -= 1\n    return line",
            "def cb_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    line = 'cb<nu<clos-brack<%04d\\n' % self.__bracket_count\n    self.__bracket_count -= 1\n    return line",
            "def cb_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    line = 'cb<nu<clos-brack<%04d\\n' % self.__bracket_count\n    self.__bracket_count -= 1\n    return line",
            "def cb_func(self, pre, token, num=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    line = 'cb<nu<clos-brack<%04d\\n' % self.__bracket_count\n    self.__bracket_count -= 1\n    return line"
        ]
    },
    {
        "func_name": "color_func",
        "original": "def color_func(self, pre, token, num):\n    third_field = 'nu'\n    if num[-1] == ';':\n        num = num[:-1]\n        third_field = 'en'\n    num = '%X' % int(num)\n    if len(num) != 2:\n        num = '0' + num\n    return f'cw<{pre}<{token}<{third_field}<{num}\\n'",
        "mutated": [
            "def color_func(self, pre, token, num):\n    if False:\n        i = 10\n    third_field = 'nu'\n    if num[-1] == ';':\n        num = num[:-1]\n        third_field = 'en'\n    num = '%X' % int(num)\n    if len(num) != 2:\n        num = '0' + num\n    return f'cw<{pre}<{token}<{third_field}<{num}\\n'",
            "def color_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    third_field = 'nu'\n    if num[-1] == ';':\n        num = num[:-1]\n        third_field = 'en'\n    num = '%X' % int(num)\n    if len(num) != 2:\n        num = '0' + num\n    return f'cw<{pre}<{token}<{third_field}<{num}\\n'",
            "def color_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    third_field = 'nu'\n    if num[-1] == ';':\n        num = num[:-1]\n        third_field = 'en'\n    num = '%X' % int(num)\n    if len(num) != 2:\n        num = '0' + num\n    return f'cw<{pre}<{token}<{third_field}<{num}\\n'",
            "def color_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    third_field = 'nu'\n    if num[-1] == ';':\n        num = num[:-1]\n        third_field = 'en'\n    num = '%X' % int(num)\n    if len(num) != 2:\n        num = '0' + num\n    return f'cw<{pre}<{token}<{third_field}<{num}\\n'",
            "def color_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    third_field = 'nu'\n    if num[-1] == ';':\n        num = num[:-1]\n        third_field = 'en'\n    num = '%X' % int(num)\n    if len(num) != 2:\n        num = '0' + num\n    return f'cw<{pre}<{token}<{third_field}<{num}\\n'"
        ]
    },
    {
        "func_name": "bool_st_func",
        "original": "def bool_st_func(self, pre, token, num):\n    if num is None or num == '' or num == '1':\n        return f'cw<{pre}<{token}<nu<true\\n'\n    elif num == '0':\n        return f'cw<{pre}<{token}<nu<false\\n'\n    else:\n        msg = f\"boolean should have some value module process tokens\\ntoken is {token}\\n'{num}'\\n\"\n        raise self.__bug_handler(msg)",
        "mutated": [
            "def bool_st_func(self, pre, token, num):\n    if False:\n        i = 10\n    if num is None or num == '' or num == '1':\n        return f'cw<{pre}<{token}<nu<true\\n'\n    elif num == '0':\n        return f'cw<{pre}<{token}<nu<false\\n'\n    else:\n        msg = f\"boolean should have some value module process tokens\\ntoken is {token}\\n'{num}'\\n\"\n        raise self.__bug_handler(msg)",
            "def bool_st_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if num is None or num == '' or num == '1':\n        return f'cw<{pre}<{token}<nu<true\\n'\n    elif num == '0':\n        return f'cw<{pre}<{token}<nu<false\\n'\n    else:\n        msg = f\"boolean should have some value module process tokens\\ntoken is {token}\\n'{num}'\\n\"\n        raise self.__bug_handler(msg)",
            "def bool_st_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if num is None or num == '' or num == '1':\n        return f'cw<{pre}<{token}<nu<true\\n'\n    elif num == '0':\n        return f'cw<{pre}<{token}<nu<false\\n'\n    else:\n        msg = f\"boolean should have some value module process tokens\\ntoken is {token}\\n'{num}'\\n\"\n        raise self.__bug_handler(msg)",
            "def bool_st_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if num is None or num == '' or num == '1':\n        return f'cw<{pre}<{token}<nu<true\\n'\n    elif num == '0':\n        return f'cw<{pre}<{token}<nu<false\\n'\n    else:\n        msg = f\"boolean should have some value module process tokens\\ntoken is {token}\\n'{num}'\\n\"\n        raise self.__bug_handler(msg)",
            "def bool_st_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if num is None or num == '' or num == '1':\n        return f'cw<{pre}<{token}<nu<true\\n'\n    elif num == '0':\n        return f'cw<{pre}<{token}<nu<false\\n'\n    else:\n        msg = f\"boolean should have some value module process tokens\\ntoken is {token}\\n'{num}'\\n\"\n        raise self.__bug_handler(msg)"
        ]
    },
    {
        "func_name": "__no_sup_sub_func",
        "original": "def __no_sup_sub_func(self, pre, token, num):\n    the_string = 'cw<ci<subscript_<nu<false\\n'\n    the_string += 'cw<ci<superscrip<nu<false\\n'\n    return the_string",
        "mutated": [
            "def __no_sup_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n    the_string = 'cw<ci<subscript_<nu<false\\n'\n    the_string += 'cw<ci<superscrip<nu<false\\n'\n    return the_string",
            "def __no_sup_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    the_string = 'cw<ci<subscript_<nu<false\\n'\n    the_string += 'cw<ci<superscrip<nu<false\\n'\n    return the_string",
            "def __no_sup_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    the_string = 'cw<ci<subscript_<nu<false\\n'\n    the_string += 'cw<ci<superscrip<nu<false\\n'\n    return the_string",
            "def __no_sup_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    the_string = 'cw<ci<subscript_<nu<false\\n'\n    the_string += 'cw<ci<superscrip<nu<false\\n'\n    return the_string",
            "def __no_sup_sub_func(self, pre, token, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    the_string = 'cw<ci<subscript_<nu<false\\n'\n    the_string += 'cw<ci<superscrip<nu<false\\n'\n    return the_string"
        ]
    },
    {
        "func_name": "divide_num",
        "original": "def divide_num(self, numerator, denominator):\n    try:\n        numerator = float(re.search('[0-9.\\\\-]+', numerator).group())\n    except TypeError as msg:\n        if self.__run_level > 3:\n            msg = 'No number to process?\\nthis indicates that the token \\\\(\\\\li\\\\)                 should have a number and does not\\nnumerator is                 \"%s\"\\ndenominator is \"%s\"\\n' % (numerator, denominator)\n            raise self.__bug_handler(msg)\n        if 5 > self.__return_code:\n            self.__return_code = 5\n        return 0\n    num = '%0.2f' % round(numerator / denominator, 2)\n    return num\n    string_num = str(num)\n    if string_num[-2:] == '.0':\n        string_num = string_num[:-2]\n    return string_num",
        "mutated": [
            "def divide_num(self, numerator, denominator):\n    if False:\n        i = 10\n    try:\n        numerator = float(re.search('[0-9.\\\\-]+', numerator).group())\n    except TypeError as msg:\n        if self.__run_level > 3:\n            msg = 'No number to process?\\nthis indicates that the token \\\\(\\\\li\\\\)                 should have a number and does not\\nnumerator is                 \"%s\"\\ndenominator is \"%s\"\\n' % (numerator, denominator)\n            raise self.__bug_handler(msg)\n        if 5 > self.__return_code:\n            self.__return_code = 5\n        return 0\n    num = '%0.2f' % round(numerator / denominator, 2)\n    return num\n    string_num = str(num)\n    if string_num[-2:] == '.0':\n        string_num = string_num[:-2]\n    return string_num",
            "def divide_num(self, numerator, denominator):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        numerator = float(re.search('[0-9.\\\\-]+', numerator).group())\n    except TypeError as msg:\n        if self.__run_level > 3:\n            msg = 'No number to process?\\nthis indicates that the token \\\\(\\\\li\\\\)                 should have a number and does not\\nnumerator is                 \"%s\"\\ndenominator is \"%s\"\\n' % (numerator, denominator)\n            raise self.__bug_handler(msg)\n        if 5 > self.__return_code:\n            self.__return_code = 5\n        return 0\n    num = '%0.2f' % round(numerator / denominator, 2)\n    return num\n    string_num = str(num)\n    if string_num[-2:] == '.0':\n        string_num = string_num[:-2]\n    return string_num",
            "def divide_num(self, numerator, denominator):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        numerator = float(re.search('[0-9.\\\\-]+', numerator).group())\n    except TypeError as msg:\n        if self.__run_level > 3:\n            msg = 'No number to process?\\nthis indicates that the token \\\\(\\\\li\\\\)                 should have a number and does not\\nnumerator is                 \"%s\"\\ndenominator is \"%s\"\\n' % (numerator, denominator)\n            raise self.__bug_handler(msg)\n        if 5 > self.__return_code:\n            self.__return_code = 5\n        return 0\n    num = '%0.2f' % round(numerator / denominator, 2)\n    return num\n    string_num = str(num)\n    if string_num[-2:] == '.0':\n        string_num = string_num[:-2]\n    return string_num",
            "def divide_num(self, numerator, denominator):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        numerator = float(re.search('[0-9.\\\\-]+', numerator).group())\n    except TypeError as msg:\n        if self.__run_level > 3:\n            msg = 'No number to process?\\nthis indicates that the token \\\\(\\\\li\\\\)                 should have a number and does not\\nnumerator is                 \"%s\"\\ndenominator is \"%s\"\\n' % (numerator, denominator)\n            raise self.__bug_handler(msg)\n        if 5 > self.__return_code:\n            self.__return_code = 5\n        return 0\n    num = '%0.2f' % round(numerator / denominator, 2)\n    return num\n    string_num = str(num)\n    if string_num[-2:] == '.0':\n        string_num = string_num[:-2]\n    return string_num",
            "def divide_num(self, numerator, denominator):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        numerator = float(re.search('[0-9.\\\\-]+', numerator).group())\n    except TypeError as msg:\n        if self.__run_level > 3:\n            msg = 'No number to process?\\nthis indicates that the token \\\\(\\\\li\\\\)                 should have a number and does not\\nnumerator is                 \"%s\"\\ndenominator is \"%s\"\\n' % (numerator, denominator)\n            raise self.__bug_handler(msg)\n        if 5 > self.__return_code:\n            self.__return_code = 5\n        return 0\n    num = '%0.2f' % round(numerator / denominator, 2)\n    return num\n    string_num = str(num)\n    if string_num[-2:] == '.0':\n        string_num = string_num[:-2]\n    return string_num"
        ]
    },
    {
        "func_name": "split_let_num",
        "original": "def split_let_num(self, token):\n    match_obj = re.search(self.__num_exp, token)\n    if match_obj is not None:\n        first = match_obj.group(1)\n        second = match_obj.group(2)\n        if not second:\n            if self.__run_level > 3:\n                msg = \"token is '%s' \\n\" % token\n                raise self.__bug_handler(msg)\n            return (first, 0)\n    else:\n        if self.__run_level > 3:\n            msg = \"token is '%s' \\n\" % token\n            raise self.__bug_handler\n        return (token, 0)\n    return (first, second)",
        "mutated": [
            "def split_let_num(self, token):\n    if False:\n        i = 10\n    match_obj = re.search(self.__num_exp, token)\n    if match_obj is not None:\n        first = match_obj.group(1)\n        second = match_obj.group(2)\n        if not second:\n            if self.__run_level > 3:\n                msg = \"token is '%s' \\n\" % token\n                raise self.__bug_handler(msg)\n            return (first, 0)\n    else:\n        if self.__run_level > 3:\n            msg = \"token is '%s' \\n\" % token\n            raise self.__bug_handler\n        return (token, 0)\n    return (first, second)",
            "def split_let_num(self, token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    match_obj = re.search(self.__num_exp, token)\n    if match_obj is not None:\n        first = match_obj.group(1)\n        second = match_obj.group(2)\n        if not second:\n            if self.__run_level > 3:\n                msg = \"token is '%s' \\n\" % token\n                raise self.__bug_handler(msg)\n            return (first, 0)\n    else:\n        if self.__run_level > 3:\n            msg = \"token is '%s' \\n\" % token\n            raise self.__bug_handler\n        return (token, 0)\n    return (first, second)",
            "def split_let_num(self, token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    match_obj = re.search(self.__num_exp, token)\n    if match_obj is not None:\n        first = match_obj.group(1)\n        second = match_obj.group(2)\n        if not second:\n            if self.__run_level > 3:\n                msg = \"token is '%s' \\n\" % token\n                raise self.__bug_handler(msg)\n            return (first, 0)\n    else:\n        if self.__run_level > 3:\n            msg = \"token is '%s' \\n\" % token\n            raise self.__bug_handler\n        return (token, 0)\n    return (first, second)",
            "def split_let_num(self, token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    match_obj = re.search(self.__num_exp, token)\n    if match_obj is not None:\n        first = match_obj.group(1)\n        second = match_obj.group(2)\n        if not second:\n            if self.__run_level > 3:\n                msg = \"token is '%s' \\n\" % token\n                raise self.__bug_handler(msg)\n            return (first, 0)\n    else:\n        if self.__run_level > 3:\n            msg = \"token is '%s' \\n\" % token\n            raise self.__bug_handler\n        return (token, 0)\n    return (first, second)",
            "def split_let_num(self, token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    match_obj = re.search(self.__num_exp, token)\n    if match_obj is not None:\n        first = match_obj.group(1)\n        second = match_obj.group(2)\n        if not second:\n            if self.__run_level > 3:\n                msg = \"token is '%s' \\n\" % token\n                raise self.__bug_handler(msg)\n            return (first, 0)\n    else:\n        if self.__run_level > 3:\n            msg = \"token is '%s' \\n\" % token\n            raise self.__bug_handler\n        return (token, 0)\n    return (first, second)"
        ]
    },
    {
        "func_name": "convert_to_hex",
        "original": "def convert_to_hex(self, number):\n    \"\"\"Convert a string to uppercase hexadecimal\"\"\"\n    num = int(number)\n    try:\n        hex_num = '%X' % num\n        return hex_num\n    except:\n        raise self.__bug_handler",
        "mutated": [
            "def convert_to_hex(self, number):\n    if False:\n        i = 10\n    'Convert a string to uppercase hexadecimal'\n    num = int(number)\n    try:\n        hex_num = '%X' % num\n        return hex_num\n    except:\n        raise self.__bug_handler",
            "def convert_to_hex(self, number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert a string to uppercase hexadecimal'\n    num = int(number)\n    try:\n        hex_num = '%X' % num\n        return hex_num\n    except:\n        raise self.__bug_handler",
            "def convert_to_hex(self, number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert a string to uppercase hexadecimal'\n    num = int(number)\n    try:\n        hex_num = '%X' % num\n        return hex_num\n    except:\n        raise self.__bug_handler",
            "def convert_to_hex(self, number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert a string to uppercase hexadecimal'\n    num = int(number)\n    try:\n        hex_num = '%X' % num\n        return hex_num\n    except:\n        raise self.__bug_handler",
            "def convert_to_hex(self, number):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert a string to uppercase hexadecimal'\n    num = int(number)\n    try:\n        hex_num = '%X' % num\n        return hex_num\n    except:\n        raise self.__bug_handler"
        ]
    },
    {
        "func_name": "process_cw",
        "original": "def process_cw(self, token):\n    \"\"\"Change the value of the control word by determining what dictionary\n        it belongs to\"\"\"\n    special = ['*', ':', '}', '{', '~', '_', '-', ';']\n    token = token[1:]\n    token = token.replace(' ', '')\n    only_alpha = token.isalpha()\n    num = None\n    if not only_alpha and token not in special:\n        (token, num) = self.split_let_num(token)\n    (pre, token, action) = self.dict_token.get(token, (None, None, None))\n    if action:\n        return action(pre, token, num)",
        "mutated": [
            "def process_cw(self, token):\n    if False:\n        i = 10\n    'Change the value of the control word by determining what dictionary\\n        it belongs to'\n    special = ['*', ':', '}', '{', '~', '_', '-', ';']\n    token = token[1:]\n    token = token.replace(' ', '')\n    only_alpha = token.isalpha()\n    num = None\n    if not only_alpha and token not in special:\n        (token, num) = self.split_let_num(token)\n    (pre, token, action) = self.dict_token.get(token, (None, None, None))\n    if action:\n        return action(pre, token, num)",
            "def process_cw(self, token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Change the value of the control word by determining what dictionary\\n        it belongs to'\n    special = ['*', ':', '}', '{', '~', '_', '-', ';']\n    token = token[1:]\n    token = token.replace(' ', '')\n    only_alpha = token.isalpha()\n    num = None\n    if not only_alpha and token not in special:\n        (token, num) = self.split_let_num(token)\n    (pre, token, action) = self.dict_token.get(token, (None, None, None))\n    if action:\n        return action(pre, token, num)",
            "def process_cw(self, token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Change the value of the control word by determining what dictionary\\n        it belongs to'\n    special = ['*', ':', '}', '{', '~', '_', '-', ';']\n    token = token[1:]\n    token = token.replace(' ', '')\n    only_alpha = token.isalpha()\n    num = None\n    if not only_alpha and token not in special:\n        (token, num) = self.split_let_num(token)\n    (pre, token, action) = self.dict_token.get(token, (None, None, None))\n    if action:\n        return action(pre, token, num)",
            "def process_cw(self, token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Change the value of the control word by determining what dictionary\\n        it belongs to'\n    special = ['*', ':', '}', '{', '~', '_', '-', ';']\n    token = token[1:]\n    token = token.replace(' ', '')\n    only_alpha = token.isalpha()\n    num = None\n    if not only_alpha and token not in special:\n        (token, num) = self.split_let_num(token)\n    (pre, token, action) = self.dict_token.get(token, (None, None, None))\n    if action:\n        return action(pre, token, num)",
            "def process_cw(self, token):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Change the value of the control word by determining what dictionary\\n        it belongs to'\n    special = ['*', ':', '}', '{', '~', '_', '-', ';']\n    token = token[1:]\n    token = token.replace(' ', '')\n    only_alpha = token.isalpha()\n    num = None\n    if not only_alpha and token not in special:\n        (token, num) = self.split_let_num(token)\n    (pre, token, action) = self.dict_token.get(token, (None, None, None))\n    if action:\n        return action(pre, token, num)"
        ]
    },
    {
        "func_name": "__check_brackets",
        "original": "def __check_brackets(self, in_file):\n    self.__check_brack_obj = check_brackets.CheckBrackets(file=in_file)\n    good_br = self.__check_brack_obj.check_brackets()[0]\n    if not good_br:\n        return 1",
        "mutated": [
            "def __check_brackets(self, in_file):\n    if False:\n        i = 10\n    self.__check_brack_obj = check_brackets.CheckBrackets(file=in_file)\n    good_br = self.__check_brack_obj.check_brackets()[0]\n    if not good_br:\n        return 1",
            "def __check_brackets(self, in_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__check_brack_obj = check_brackets.CheckBrackets(file=in_file)\n    good_br = self.__check_brack_obj.check_brackets()[0]\n    if not good_br:\n        return 1",
            "def __check_brackets(self, in_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__check_brack_obj = check_brackets.CheckBrackets(file=in_file)\n    good_br = self.__check_brack_obj.check_brackets()[0]\n    if not good_br:\n        return 1",
            "def __check_brackets(self, in_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__check_brack_obj = check_brackets.CheckBrackets(file=in_file)\n    good_br = self.__check_brack_obj.check_brackets()[0]\n    if not good_br:\n        return 1",
            "def __check_brackets(self, in_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__check_brack_obj = check_brackets.CheckBrackets(file=in_file)\n    good_br = self.__check_brack_obj.check_brackets()[0]\n    if not good_br:\n        return 1"
        ]
    },
    {
        "func_name": "process_tokens",
        "original": "def process_tokens(self):\n    \"\"\"Main method for handling other methods. \"\"\"\n    line_count = 0\n    with open_for_read(self.__file) as read_obj:\n        with open_for_write(self.__write_to) as write_obj:\n            for line in read_obj:\n                token = line.replace('\\n', '')\n                line_count += 1\n                if line_count == 1 and token != '\\\\{':\n                    msg = \"\\nInvalid RTF: document doesn't start with {\\n\"\n                    raise self.__exception_handler(msg)\n                elif line_count == 2 and token[0:4] != '\\\\rtf':\n                    msg = \"\\nInvalid RTF: document doesn't start with \\\\rtf \\n\"\n                    raise self.__exception_handler(msg)\n                the_index = token.find('\\\\ ')\n                if token is not None and the_index > -1:\n                    msg = '\\nInvalid RTF: token \"\\\\ \" not valid.\\nError at line %d' % line_count\n                    raise self.__exception_handler(msg)\n                elif token[:1] == '\\\\':\n                    line = self.process_cw(token)\n                    if line is not None:\n                        write_obj.write(line)\n                else:\n                    fields = re.split(self.__utf_exp, token)\n                    for field in fields:\n                        if not field:\n                            continue\n                        if field[0:1] == '&':\n                            write_obj.write('tx<ut<__________<%s\\n' % field)\n                        else:\n                            write_obj.write('tx<nu<__________<%s\\n' % field)\n    if not line_count:\n        msg = '\\nInvalid RTF: file appears to be empty.\\n'\n        raise self.__exception_handler(msg)\n    copy_obj = copy.Copy(bug_handler=self.__bug_handler)\n    if self.__copy:\n        copy_obj.copy_file(self.__write_to, 'processed_tokens.data')\n    copy_obj.rename(self.__write_to, self.__file)\n    os.remove(self.__write_to)\n    bad_brackets = self.__check_brackets(self.__file)\n    if bad_brackets:\n        msg = '\\nInvalid RTF: document does not have matching brackets.\\n'\n        raise self.__exception_handler(msg)\n    else:\n        return self.__return_code",
        "mutated": [
            "def process_tokens(self):\n    if False:\n        i = 10\n    'Main method for handling other methods. '\n    line_count = 0\n    with open_for_read(self.__file) as read_obj:\n        with open_for_write(self.__write_to) as write_obj:\n            for line in read_obj:\n                token = line.replace('\\n', '')\n                line_count += 1\n                if line_count == 1 and token != '\\\\{':\n                    msg = \"\\nInvalid RTF: document doesn't start with {\\n\"\n                    raise self.__exception_handler(msg)\n                elif line_count == 2 and token[0:4] != '\\\\rtf':\n                    msg = \"\\nInvalid RTF: document doesn't start with \\\\rtf \\n\"\n                    raise self.__exception_handler(msg)\n                the_index = token.find('\\\\ ')\n                if token is not None and the_index > -1:\n                    msg = '\\nInvalid RTF: token \"\\\\ \" not valid.\\nError at line %d' % line_count\n                    raise self.__exception_handler(msg)\n                elif token[:1] == '\\\\':\n                    line = self.process_cw(token)\n                    if line is not None:\n                        write_obj.write(line)\n                else:\n                    fields = re.split(self.__utf_exp, token)\n                    for field in fields:\n                        if not field:\n                            continue\n                        if field[0:1] == '&':\n                            write_obj.write('tx<ut<__________<%s\\n' % field)\n                        else:\n                            write_obj.write('tx<nu<__________<%s\\n' % field)\n    if not line_count:\n        msg = '\\nInvalid RTF: file appears to be empty.\\n'\n        raise self.__exception_handler(msg)\n    copy_obj = copy.Copy(bug_handler=self.__bug_handler)\n    if self.__copy:\n        copy_obj.copy_file(self.__write_to, 'processed_tokens.data')\n    copy_obj.rename(self.__write_to, self.__file)\n    os.remove(self.__write_to)\n    bad_brackets = self.__check_brackets(self.__file)\n    if bad_brackets:\n        msg = '\\nInvalid RTF: document does not have matching brackets.\\n'\n        raise self.__exception_handler(msg)\n    else:\n        return self.__return_code",
            "def process_tokens(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Main method for handling other methods. '\n    line_count = 0\n    with open_for_read(self.__file) as read_obj:\n        with open_for_write(self.__write_to) as write_obj:\n            for line in read_obj:\n                token = line.replace('\\n', '')\n                line_count += 1\n                if line_count == 1 and token != '\\\\{':\n                    msg = \"\\nInvalid RTF: document doesn't start with {\\n\"\n                    raise self.__exception_handler(msg)\n                elif line_count == 2 and token[0:4] != '\\\\rtf':\n                    msg = \"\\nInvalid RTF: document doesn't start with \\\\rtf \\n\"\n                    raise self.__exception_handler(msg)\n                the_index = token.find('\\\\ ')\n                if token is not None and the_index > -1:\n                    msg = '\\nInvalid RTF: token \"\\\\ \" not valid.\\nError at line %d' % line_count\n                    raise self.__exception_handler(msg)\n                elif token[:1] == '\\\\':\n                    line = self.process_cw(token)\n                    if line is not None:\n                        write_obj.write(line)\n                else:\n                    fields = re.split(self.__utf_exp, token)\n                    for field in fields:\n                        if not field:\n                            continue\n                        if field[0:1] == '&':\n                            write_obj.write('tx<ut<__________<%s\\n' % field)\n                        else:\n                            write_obj.write('tx<nu<__________<%s\\n' % field)\n    if not line_count:\n        msg = '\\nInvalid RTF: file appears to be empty.\\n'\n        raise self.__exception_handler(msg)\n    copy_obj = copy.Copy(bug_handler=self.__bug_handler)\n    if self.__copy:\n        copy_obj.copy_file(self.__write_to, 'processed_tokens.data')\n    copy_obj.rename(self.__write_to, self.__file)\n    os.remove(self.__write_to)\n    bad_brackets = self.__check_brackets(self.__file)\n    if bad_brackets:\n        msg = '\\nInvalid RTF: document does not have matching brackets.\\n'\n        raise self.__exception_handler(msg)\n    else:\n        return self.__return_code",
            "def process_tokens(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Main method for handling other methods. '\n    line_count = 0\n    with open_for_read(self.__file) as read_obj:\n        with open_for_write(self.__write_to) as write_obj:\n            for line in read_obj:\n                token = line.replace('\\n', '')\n                line_count += 1\n                if line_count == 1 and token != '\\\\{':\n                    msg = \"\\nInvalid RTF: document doesn't start with {\\n\"\n                    raise self.__exception_handler(msg)\n                elif line_count == 2 and token[0:4] != '\\\\rtf':\n                    msg = \"\\nInvalid RTF: document doesn't start with \\\\rtf \\n\"\n                    raise self.__exception_handler(msg)\n                the_index = token.find('\\\\ ')\n                if token is not None and the_index > -1:\n                    msg = '\\nInvalid RTF: token \"\\\\ \" not valid.\\nError at line %d' % line_count\n                    raise self.__exception_handler(msg)\n                elif token[:1] == '\\\\':\n                    line = self.process_cw(token)\n                    if line is not None:\n                        write_obj.write(line)\n                else:\n                    fields = re.split(self.__utf_exp, token)\n                    for field in fields:\n                        if not field:\n                            continue\n                        if field[0:1] == '&':\n                            write_obj.write('tx<ut<__________<%s\\n' % field)\n                        else:\n                            write_obj.write('tx<nu<__________<%s\\n' % field)\n    if not line_count:\n        msg = '\\nInvalid RTF: file appears to be empty.\\n'\n        raise self.__exception_handler(msg)\n    copy_obj = copy.Copy(bug_handler=self.__bug_handler)\n    if self.__copy:\n        copy_obj.copy_file(self.__write_to, 'processed_tokens.data')\n    copy_obj.rename(self.__write_to, self.__file)\n    os.remove(self.__write_to)\n    bad_brackets = self.__check_brackets(self.__file)\n    if bad_brackets:\n        msg = '\\nInvalid RTF: document does not have matching brackets.\\n'\n        raise self.__exception_handler(msg)\n    else:\n        return self.__return_code",
            "def process_tokens(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Main method for handling other methods. '\n    line_count = 0\n    with open_for_read(self.__file) as read_obj:\n        with open_for_write(self.__write_to) as write_obj:\n            for line in read_obj:\n                token = line.replace('\\n', '')\n                line_count += 1\n                if line_count == 1 and token != '\\\\{':\n                    msg = \"\\nInvalid RTF: document doesn't start with {\\n\"\n                    raise self.__exception_handler(msg)\n                elif line_count == 2 and token[0:4] != '\\\\rtf':\n                    msg = \"\\nInvalid RTF: document doesn't start with \\\\rtf \\n\"\n                    raise self.__exception_handler(msg)\n                the_index = token.find('\\\\ ')\n                if token is not None and the_index > -1:\n                    msg = '\\nInvalid RTF: token \"\\\\ \" not valid.\\nError at line %d' % line_count\n                    raise self.__exception_handler(msg)\n                elif token[:1] == '\\\\':\n                    line = self.process_cw(token)\n                    if line is not None:\n                        write_obj.write(line)\n                else:\n                    fields = re.split(self.__utf_exp, token)\n                    for field in fields:\n                        if not field:\n                            continue\n                        if field[0:1] == '&':\n                            write_obj.write('tx<ut<__________<%s\\n' % field)\n                        else:\n                            write_obj.write('tx<nu<__________<%s\\n' % field)\n    if not line_count:\n        msg = '\\nInvalid RTF: file appears to be empty.\\n'\n        raise self.__exception_handler(msg)\n    copy_obj = copy.Copy(bug_handler=self.__bug_handler)\n    if self.__copy:\n        copy_obj.copy_file(self.__write_to, 'processed_tokens.data')\n    copy_obj.rename(self.__write_to, self.__file)\n    os.remove(self.__write_to)\n    bad_brackets = self.__check_brackets(self.__file)\n    if bad_brackets:\n        msg = '\\nInvalid RTF: document does not have matching brackets.\\n'\n        raise self.__exception_handler(msg)\n    else:\n        return self.__return_code",
            "def process_tokens(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Main method for handling other methods. '\n    line_count = 0\n    with open_for_read(self.__file) as read_obj:\n        with open_for_write(self.__write_to) as write_obj:\n            for line in read_obj:\n                token = line.replace('\\n', '')\n                line_count += 1\n                if line_count == 1 and token != '\\\\{':\n                    msg = \"\\nInvalid RTF: document doesn't start with {\\n\"\n                    raise self.__exception_handler(msg)\n                elif line_count == 2 and token[0:4] != '\\\\rtf':\n                    msg = \"\\nInvalid RTF: document doesn't start with \\\\rtf \\n\"\n                    raise self.__exception_handler(msg)\n                the_index = token.find('\\\\ ')\n                if token is not None and the_index > -1:\n                    msg = '\\nInvalid RTF: token \"\\\\ \" not valid.\\nError at line %d' % line_count\n                    raise self.__exception_handler(msg)\n                elif token[:1] == '\\\\':\n                    line = self.process_cw(token)\n                    if line is not None:\n                        write_obj.write(line)\n                else:\n                    fields = re.split(self.__utf_exp, token)\n                    for field in fields:\n                        if not field:\n                            continue\n                        if field[0:1] == '&':\n                            write_obj.write('tx<ut<__________<%s\\n' % field)\n                        else:\n                            write_obj.write('tx<nu<__________<%s\\n' % field)\n    if not line_count:\n        msg = '\\nInvalid RTF: file appears to be empty.\\n'\n        raise self.__exception_handler(msg)\n    copy_obj = copy.Copy(bug_handler=self.__bug_handler)\n    if self.__copy:\n        copy_obj.copy_file(self.__write_to, 'processed_tokens.data')\n    copy_obj.rename(self.__write_to, self.__file)\n    os.remove(self.__write_to)\n    bad_brackets = self.__check_brackets(self.__file)\n    if bad_brackets:\n        msg = '\\nInvalid RTF: document does not have matching brackets.\\n'\n        raise self.__exception_handler(msg)\n    else:\n        return self.__return_code"
        ]
    }
]