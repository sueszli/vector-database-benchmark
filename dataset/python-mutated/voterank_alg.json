[
    {
        "func_name": "voterank",
        "original": "@nx._dispatch\ndef voterank(G, number_of_nodes=None):\n    \"\"\"Select a list of influential nodes in a graph using VoteRank algorithm\n\n    VoteRank [1]_ computes a ranking of the nodes in a graph G based on a\n    voting scheme. With VoteRank, all nodes vote for each of its in-neighbours\n    and the node with the highest votes is elected iteratively. The voting\n    ability of out-neighbors of elected nodes is decreased in subsequent turns.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX graph.\n\n    number_of_nodes : integer, optional\n        Number of ranked nodes to extract (default all nodes).\n\n    Returns\n    -------\n    voterank : list\n        Ordered list of computed seeds.\n        Only nodes with positive number of votes are returned.\n\n    Examples\n    --------\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 4)])\n    >>> nx.voterank(G)\n    [0, 1]\n\n    The algorithm can be used both for undirected and directed graphs.\n    However, the directed version is different in two ways:\n    (i) nodes only vote for their in-neighbors and\n    (ii) only the voting ability of elected node and its out-neighbors are updated:\n\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (2, 3), (3, 4)])\n    >>> nx.voterank(G)\n    [2, 3]\n\n    Notes\n    -----\n    Each edge is treated independently in case of multigraphs.\n\n    References\n    ----------\n    .. [1] Zhang, J.-X. et al. (2016).\n        Identifying a set of influential spreaders in complex networks.\n        Sci. Rep. 6, 27823; doi: 10.1038/srep27823.\n    \"\"\"\n    influential_nodes = []\n    vote_rank = {}\n    if len(G) == 0:\n        return influential_nodes\n    if number_of_nodes is None or number_of_nodes > len(G):\n        number_of_nodes = len(G)\n    if G.is_directed():\n        avgDegree = sum((deg for (_, deg) in G.out_degree())) / len(G)\n    else:\n        avgDegree = sum((deg for (_, deg) in G.degree())) / len(G)\n    for n in G.nodes():\n        vote_rank[n] = [0, 1]\n    for _ in range(number_of_nodes):\n        for n in G.nodes():\n            vote_rank[n][0] = 0\n        for (n, nbr) in G.edges():\n            vote_rank[n][0] += vote_rank[nbr][1]\n            if not G.is_directed():\n                vote_rank[nbr][0] += vote_rank[n][1]\n        for n in influential_nodes:\n            vote_rank[n][0] = 0\n        n = max(G.nodes, key=lambda x: vote_rank[x][0])\n        if vote_rank[n][0] == 0:\n            return influential_nodes\n        influential_nodes.append(n)\n        vote_rank[n] = [0, 0]\n        for (_, nbr) in G.edges(n):\n            vote_rank[nbr][1] -= 1 / avgDegree\n            vote_rank[nbr][1] = max(vote_rank[nbr][1], 0)\n    return influential_nodes",
        "mutated": [
            "@nx._dispatch\ndef voterank(G, number_of_nodes=None):\n    if False:\n        i = 10\n    'Select a list of influential nodes in a graph using VoteRank algorithm\\n\\n    VoteRank [1]_ computes a ranking of the nodes in a graph G based on a\\n    voting scheme. With VoteRank, all nodes vote for each of its in-neighbours\\n    and the node with the highest votes is elected iteratively. The voting\\n    ability of out-neighbors of elected nodes is decreased in subsequent turns.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph.\\n\\n    number_of_nodes : integer, optional\\n        Number of ranked nodes to extract (default all nodes).\\n\\n    Returns\\n    -------\\n    voterank : list\\n        Ordered list of computed seeds.\\n        Only nodes with positive number of votes are returned.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 4)])\\n    >>> nx.voterank(G)\\n    [0, 1]\\n\\n    The algorithm can be used both for undirected and directed graphs.\\n    However, the directed version is different in two ways:\\n    (i) nodes only vote for their in-neighbors and\\n    (ii) only the voting ability of elected node and its out-neighbors are updated:\\n\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (2, 3), (3, 4)])\\n    >>> nx.voterank(G)\\n    [2, 3]\\n\\n    Notes\\n    -----\\n    Each edge is treated independently in case of multigraphs.\\n\\n    References\\n    ----------\\n    .. [1] Zhang, J.-X. et al. (2016).\\n        Identifying a set of influential spreaders in complex networks.\\n        Sci. Rep. 6, 27823; doi: 10.1038/srep27823.\\n    '\n    influential_nodes = []\n    vote_rank = {}\n    if len(G) == 0:\n        return influential_nodes\n    if number_of_nodes is None or number_of_nodes > len(G):\n        number_of_nodes = len(G)\n    if G.is_directed():\n        avgDegree = sum((deg for (_, deg) in G.out_degree())) / len(G)\n    else:\n        avgDegree = sum((deg for (_, deg) in G.degree())) / len(G)\n    for n in G.nodes():\n        vote_rank[n] = [0, 1]\n    for _ in range(number_of_nodes):\n        for n in G.nodes():\n            vote_rank[n][0] = 0\n        for (n, nbr) in G.edges():\n            vote_rank[n][0] += vote_rank[nbr][1]\n            if not G.is_directed():\n                vote_rank[nbr][0] += vote_rank[n][1]\n        for n in influential_nodes:\n            vote_rank[n][0] = 0\n        n = max(G.nodes, key=lambda x: vote_rank[x][0])\n        if vote_rank[n][0] == 0:\n            return influential_nodes\n        influential_nodes.append(n)\n        vote_rank[n] = [0, 0]\n        for (_, nbr) in G.edges(n):\n            vote_rank[nbr][1] -= 1 / avgDegree\n            vote_rank[nbr][1] = max(vote_rank[nbr][1], 0)\n    return influential_nodes",
            "@nx._dispatch\ndef voterank(G, number_of_nodes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Select a list of influential nodes in a graph using VoteRank algorithm\\n\\n    VoteRank [1]_ computes a ranking of the nodes in a graph G based on a\\n    voting scheme. With VoteRank, all nodes vote for each of its in-neighbours\\n    and the node with the highest votes is elected iteratively. The voting\\n    ability of out-neighbors of elected nodes is decreased in subsequent turns.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph.\\n\\n    number_of_nodes : integer, optional\\n        Number of ranked nodes to extract (default all nodes).\\n\\n    Returns\\n    -------\\n    voterank : list\\n        Ordered list of computed seeds.\\n        Only nodes with positive number of votes are returned.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 4)])\\n    >>> nx.voterank(G)\\n    [0, 1]\\n\\n    The algorithm can be used both for undirected and directed graphs.\\n    However, the directed version is different in two ways:\\n    (i) nodes only vote for their in-neighbors and\\n    (ii) only the voting ability of elected node and its out-neighbors are updated:\\n\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (2, 3), (3, 4)])\\n    >>> nx.voterank(G)\\n    [2, 3]\\n\\n    Notes\\n    -----\\n    Each edge is treated independently in case of multigraphs.\\n\\n    References\\n    ----------\\n    .. [1] Zhang, J.-X. et al. (2016).\\n        Identifying a set of influential spreaders in complex networks.\\n        Sci. Rep. 6, 27823; doi: 10.1038/srep27823.\\n    '\n    influential_nodes = []\n    vote_rank = {}\n    if len(G) == 0:\n        return influential_nodes\n    if number_of_nodes is None or number_of_nodes > len(G):\n        number_of_nodes = len(G)\n    if G.is_directed():\n        avgDegree = sum((deg for (_, deg) in G.out_degree())) / len(G)\n    else:\n        avgDegree = sum((deg for (_, deg) in G.degree())) / len(G)\n    for n in G.nodes():\n        vote_rank[n] = [0, 1]\n    for _ in range(number_of_nodes):\n        for n in G.nodes():\n            vote_rank[n][0] = 0\n        for (n, nbr) in G.edges():\n            vote_rank[n][0] += vote_rank[nbr][1]\n            if not G.is_directed():\n                vote_rank[nbr][0] += vote_rank[n][1]\n        for n in influential_nodes:\n            vote_rank[n][0] = 0\n        n = max(G.nodes, key=lambda x: vote_rank[x][0])\n        if vote_rank[n][0] == 0:\n            return influential_nodes\n        influential_nodes.append(n)\n        vote_rank[n] = [0, 0]\n        for (_, nbr) in G.edges(n):\n            vote_rank[nbr][1] -= 1 / avgDegree\n            vote_rank[nbr][1] = max(vote_rank[nbr][1], 0)\n    return influential_nodes",
            "@nx._dispatch\ndef voterank(G, number_of_nodes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Select a list of influential nodes in a graph using VoteRank algorithm\\n\\n    VoteRank [1]_ computes a ranking of the nodes in a graph G based on a\\n    voting scheme. With VoteRank, all nodes vote for each of its in-neighbours\\n    and the node with the highest votes is elected iteratively. The voting\\n    ability of out-neighbors of elected nodes is decreased in subsequent turns.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph.\\n\\n    number_of_nodes : integer, optional\\n        Number of ranked nodes to extract (default all nodes).\\n\\n    Returns\\n    -------\\n    voterank : list\\n        Ordered list of computed seeds.\\n        Only nodes with positive number of votes are returned.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 4)])\\n    >>> nx.voterank(G)\\n    [0, 1]\\n\\n    The algorithm can be used both for undirected and directed graphs.\\n    However, the directed version is different in two ways:\\n    (i) nodes only vote for their in-neighbors and\\n    (ii) only the voting ability of elected node and its out-neighbors are updated:\\n\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (2, 3), (3, 4)])\\n    >>> nx.voterank(G)\\n    [2, 3]\\n\\n    Notes\\n    -----\\n    Each edge is treated independently in case of multigraphs.\\n\\n    References\\n    ----------\\n    .. [1] Zhang, J.-X. et al. (2016).\\n        Identifying a set of influential spreaders in complex networks.\\n        Sci. Rep. 6, 27823; doi: 10.1038/srep27823.\\n    '\n    influential_nodes = []\n    vote_rank = {}\n    if len(G) == 0:\n        return influential_nodes\n    if number_of_nodes is None or number_of_nodes > len(G):\n        number_of_nodes = len(G)\n    if G.is_directed():\n        avgDegree = sum((deg for (_, deg) in G.out_degree())) / len(G)\n    else:\n        avgDegree = sum((deg for (_, deg) in G.degree())) / len(G)\n    for n in G.nodes():\n        vote_rank[n] = [0, 1]\n    for _ in range(number_of_nodes):\n        for n in G.nodes():\n            vote_rank[n][0] = 0\n        for (n, nbr) in G.edges():\n            vote_rank[n][0] += vote_rank[nbr][1]\n            if not G.is_directed():\n                vote_rank[nbr][0] += vote_rank[n][1]\n        for n in influential_nodes:\n            vote_rank[n][0] = 0\n        n = max(G.nodes, key=lambda x: vote_rank[x][0])\n        if vote_rank[n][0] == 0:\n            return influential_nodes\n        influential_nodes.append(n)\n        vote_rank[n] = [0, 0]\n        for (_, nbr) in G.edges(n):\n            vote_rank[nbr][1] -= 1 / avgDegree\n            vote_rank[nbr][1] = max(vote_rank[nbr][1], 0)\n    return influential_nodes",
            "@nx._dispatch\ndef voterank(G, number_of_nodes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Select a list of influential nodes in a graph using VoteRank algorithm\\n\\n    VoteRank [1]_ computes a ranking of the nodes in a graph G based on a\\n    voting scheme. With VoteRank, all nodes vote for each of its in-neighbours\\n    and the node with the highest votes is elected iteratively. The voting\\n    ability of out-neighbors of elected nodes is decreased in subsequent turns.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph.\\n\\n    number_of_nodes : integer, optional\\n        Number of ranked nodes to extract (default all nodes).\\n\\n    Returns\\n    -------\\n    voterank : list\\n        Ordered list of computed seeds.\\n        Only nodes with positive number of votes are returned.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 4)])\\n    >>> nx.voterank(G)\\n    [0, 1]\\n\\n    The algorithm can be used both for undirected and directed graphs.\\n    However, the directed version is different in two ways:\\n    (i) nodes only vote for their in-neighbors and\\n    (ii) only the voting ability of elected node and its out-neighbors are updated:\\n\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (2, 3), (3, 4)])\\n    >>> nx.voterank(G)\\n    [2, 3]\\n\\n    Notes\\n    -----\\n    Each edge is treated independently in case of multigraphs.\\n\\n    References\\n    ----------\\n    .. [1] Zhang, J.-X. et al. (2016).\\n        Identifying a set of influential spreaders in complex networks.\\n        Sci. Rep. 6, 27823; doi: 10.1038/srep27823.\\n    '\n    influential_nodes = []\n    vote_rank = {}\n    if len(G) == 0:\n        return influential_nodes\n    if number_of_nodes is None or number_of_nodes > len(G):\n        number_of_nodes = len(G)\n    if G.is_directed():\n        avgDegree = sum((deg for (_, deg) in G.out_degree())) / len(G)\n    else:\n        avgDegree = sum((deg for (_, deg) in G.degree())) / len(G)\n    for n in G.nodes():\n        vote_rank[n] = [0, 1]\n    for _ in range(number_of_nodes):\n        for n in G.nodes():\n            vote_rank[n][0] = 0\n        for (n, nbr) in G.edges():\n            vote_rank[n][0] += vote_rank[nbr][1]\n            if not G.is_directed():\n                vote_rank[nbr][0] += vote_rank[n][1]\n        for n in influential_nodes:\n            vote_rank[n][0] = 0\n        n = max(G.nodes, key=lambda x: vote_rank[x][0])\n        if vote_rank[n][0] == 0:\n            return influential_nodes\n        influential_nodes.append(n)\n        vote_rank[n] = [0, 0]\n        for (_, nbr) in G.edges(n):\n            vote_rank[nbr][1] -= 1 / avgDegree\n            vote_rank[nbr][1] = max(vote_rank[nbr][1], 0)\n    return influential_nodes",
            "@nx._dispatch\ndef voterank(G, number_of_nodes=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Select a list of influential nodes in a graph using VoteRank algorithm\\n\\n    VoteRank [1]_ computes a ranking of the nodes in a graph G based on a\\n    voting scheme. With VoteRank, all nodes vote for each of its in-neighbours\\n    and the node with the highest votes is elected iteratively. The voting\\n    ability of out-neighbors of elected nodes is decreased in subsequent turns.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph.\\n\\n    number_of_nodes : integer, optional\\n        Number of ranked nodes to extract (default all nodes).\\n\\n    Returns\\n    -------\\n    voterank : list\\n        Ordered list of computed seeds.\\n        Only nodes with positive number of votes are returned.\\n\\n    Examples\\n    --------\\n    >>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 4)])\\n    >>> nx.voterank(G)\\n    [0, 1]\\n\\n    The algorithm can be used both for undirected and directed graphs.\\n    However, the directed version is different in two ways:\\n    (i) nodes only vote for their in-neighbors and\\n    (ii) only the voting ability of elected node and its out-neighbors are updated:\\n\\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (2, 3), (3, 4)])\\n    >>> nx.voterank(G)\\n    [2, 3]\\n\\n    Notes\\n    -----\\n    Each edge is treated independently in case of multigraphs.\\n\\n    References\\n    ----------\\n    .. [1] Zhang, J.-X. et al. (2016).\\n        Identifying a set of influential spreaders in complex networks.\\n        Sci. Rep. 6, 27823; doi: 10.1038/srep27823.\\n    '\n    influential_nodes = []\n    vote_rank = {}\n    if len(G) == 0:\n        return influential_nodes\n    if number_of_nodes is None or number_of_nodes > len(G):\n        number_of_nodes = len(G)\n    if G.is_directed():\n        avgDegree = sum((deg for (_, deg) in G.out_degree())) / len(G)\n    else:\n        avgDegree = sum((deg for (_, deg) in G.degree())) / len(G)\n    for n in G.nodes():\n        vote_rank[n] = [0, 1]\n    for _ in range(number_of_nodes):\n        for n in G.nodes():\n            vote_rank[n][0] = 0\n        for (n, nbr) in G.edges():\n            vote_rank[n][0] += vote_rank[nbr][1]\n            if not G.is_directed():\n                vote_rank[nbr][0] += vote_rank[n][1]\n        for n in influential_nodes:\n            vote_rank[n][0] = 0\n        n = max(G.nodes, key=lambda x: vote_rank[x][0])\n        if vote_rank[n][0] == 0:\n            return influential_nodes\n        influential_nodes.append(n)\n        vote_rank[n] = [0, 0]\n        for (_, nbr) in G.edges(n):\n            vote_rank[nbr][1] -= 1 / avgDegree\n            vote_rank[nbr][1] = max(vote_rank[nbr][1], 0)\n    return influential_nodes"
        ]
    }
]