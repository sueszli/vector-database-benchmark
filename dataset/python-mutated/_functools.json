[
    {
        "func_name": "wrapper",
        "original": "def wrapper(self, *args, **kwargs):\n    bound_method = types.MethodType(method, self)\n    cached_method = cache_wrapper(bound_method)\n    setattr(self, method.__name__, cached_method)\n    return cached_method(*args, **kwargs)",
        "mutated": [
            "def wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n    bound_method = types.MethodType(method, self)\n    cached_method = cache_wrapper(bound_method)\n    setattr(self, method.__name__, cached_method)\n    return cached_method(*args, **kwargs)",
            "def wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    bound_method = types.MethodType(method, self)\n    cached_method = cache_wrapper(bound_method)\n    setattr(self, method.__name__, cached_method)\n    return cached_method(*args, **kwargs)",
            "def wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    bound_method = types.MethodType(method, self)\n    cached_method = cache_wrapper(bound_method)\n    setattr(self, method.__name__, cached_method)\n    return cached_method(*args, **kwargs)",
            "def wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    bound_method = types.MethodType(method, self)\n    cached_method = cache_wrapper(bound_method)\n    setattr(self, method.__name__, cached_method)\n    return cached_method(*args, **kwargs)",
            "def wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    bound_method = types.MethodType(method, self)\n    cached_method = cache_wrapper(bound_method)\n    setattr(self, method.__name__, cached_method)\n    return cached_method(*args, **kwargs)"
        ]
    },
    {
        "func_name": "method_cache",
        "original": "def method_cache(method, cache_wrapper=None):\n    \"\"\"\n    Wrap lru_cache to support storing the cache data in the object instances.\n\n    Abstracts the common paradigm where the method explicitly saves an\n    underscore-prefixed protected property on first call and returns that\n    subsequently.\n\n    >>> class MyClass:\n    ...     calls = 0\n    ...\n    ...     @method_cache\n    ...     def method(self, value):\n    ...         self.calls += 1\n    ...         return value\n\n    >>> a = MyClass()\n    >>> a.method(3)\n    3\n    >>> for x in range(75):\n    ...     res = a.method(x)\n    >>> a.calls\n    75\n\n    Note that the apparent behavior will be exactly like that of lru_cache\n    except that the cache is stored on each instance, so values in one\n    instance will not flush values from another, and when an instance is\n    deleted, so are the cached values for that instance.\n\n    >>> b = MyClass()\n    >>> for x in range(35):\n    ...     res = b.method(x)\n    >>> b.calls\n    35\n    >>> a.method(0)\n    0\n    >>> a.calls\n    75\n\n    Note that if method had been decorated with ``functools.lru_cache()``,\n    a.calls would have been 76 (due to the cached value of 0 having been\n    flushed by the 'b' instance).\n\n    Clear the cache with ``.cache_clear()``\n\n    >>> a.method.cache_clear()\n\n    Same for a method that hasn't yet been called.\n\n    >>> c = MyClass()\n    >>> c.method.cache_clear()\n\n    Another cache wrapper may be supplied:\n\n    >>> cache = functools.lru_cache(maxsize=2)\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\n    >>> a = MyClass()\n    >>> a.method2()\n    3\n\n    Caution - do not subsequently wrap the method with another decorator, such\n    as ``@property``, which changes the semantics of the function.\n\n    See also\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\n    for another implementation and additional justification.\n    \"\"\"\n    cache_wrapper = cache_wrapper or functools.lru_cache()\n\n    def wrapper(self, *args, **kwargs):\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n    wrapper.cache_clear = lambda : None\n    return wrapper",
        "mutated": [
            "def method_cache(method, cache_wrapper=None):\n    if False:\n        i = 10\n    \"\\n    Wrap lru_cache to support storing the cache data in the object instances.\\n\\n    Abstracts the common paradigm where the method explicitly saves an\\n    underscore-prefixed protected property on first call and returns that\\n    subsequently.\\n\\n    >>> class MyClass:\\n    ...     calls = 0\\n    ...\\n    ...     @method_cache\\n    ...     def method(self, value):\\n    ...         self.calls += 1\\n    ...         return value\\n\\n    >>> a = MyClass()\\n    >>> a.method(3)\\n    3\\n    >>> for x in range(75):\\n    ...     res = a.method(x)\\n    >>> a.calls\\n    75\\n\\n    Note that the apparent behavior will be exactly like that of lru_cache\\n    except that the cache is stored on each instance, so values in one\\n    instance will not flush values from another, and when an instance is\\n    deleted, so are the cached values for that instance.\\n\\n    >>> b = MyClass()\\n    >>> for x in range(35):\\n    ...     res = b.method(x)\\n    >>> b.calls\\n    35\\n    >>> a.method(0)\\n    0\\n    >>> a.calls\\n    75\\n\\n    Note that if method had been decorated with ``functools.lru_cache()``,\\n    a.calls would have been 76 (due to the cached value of 0 having been\\n    flushed by the 'b' instance).\\n\\n    Clear the cache with ``.cache_clear()``\\n\\n    >>> a.method.cache_clear()\\n\\n    Same for a method that hasn't yet been called.\\n\\n    >>> c = MyClass()\\n    >>> c.method.cache_clear()\\n\\n    Another cache wrapper may be supplied:\\n\\n    >>> cache = functools.lru_cache(maxsize=2)\\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\\n    >>> a = MyClass()\\n    >>> a.method2()\\n    3\\n\\n    Caution - do not subsequently wrap the method with another decorator, such\\n    as ``@property``, which changes the semantics of the function.\\n\\n    See also\\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\\n    for another implementation and additional justification.\\n    \"\n    cache_wrapper = cache_wrapper or functools.lru_cache()\n\n    def wrapper(self, *args, **kwargs):\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n    wrapper.cache_clear = lambda : None\n    return wrapper",
            "def method_cache(method, cache_wrapper=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Wrap lru_cache to support storing the cache data in the object instances.\\n\\n    Abstracts the common paradigm where the method explicitly saves an\\n    underscore-prefixed protected property on first call and returns that\\n    subsequently.\\n\\n    >>> class MyClass:\\n    ...     calls = 0\\n    ...\\n    ...     @method_cache\\n    ...     def method(self, value):\\n    ...         self.calls += 1\\n    ...         return value\\n\\n    >>> a = MyClass()\\n    >>> a.method(3)\\n    3\\n    >>> for x in range(75):\\n    ...     res = a.method(x)\\n    >>> a.calls\\n    75\\n\\n    Note that the apparent behavior will be exactly like that of lru_cache\\n    except that the cache is stored on each instance, so values in one\\n    instance will not flush values from another, and when an instance is\\n    deleted, so are the cached values for that instance.\\n\\n    >>> b = MyClass()\\n    >>> for x in range(35):\\n    ...     res = b.method(x)\\n    >>> b.calls\\n    35\\n    >>> a.method(0)\\n    0\\n    >>> a.calls\\n    75\\n\\n    Note that if method had been decorated with ``functools.lru_cache()``,\\n    a.calls would have been 76 (due to the cached value of 0 having been\\n    flushed by the 'b' instance).\\n\\n    Clear the cache with ``.cache_clear()``\\n\\n    >>> a.method.cache_clear()\\n\\n    Same for a method that hasn't yet been called.\\n\\n    >>> c = MyClass()\\n    >>> c.method.cache_clear()\\n\\n    Another cache wrapper may be supplied:\\n\\n    >>> cache = functools.lru_cache(maxsize=2)\\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\\n    >>> a = MyClass()\\n    >>> a.method2()\\n    3\\n\\n    Caution - do not subsequently wrap the method with another decorator, such\\n    as ``@property``, which changes the semantics of the function.\\n\\n    See also\\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\\n    for another implementation and additional justification.\\n    \"\n    cache_wrapper = cache_wrapper or functools.lru_cache()\n\n    def wrapper(self, *args, **kwargs):\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n    wrapper.cache_clear = lambda : None\n    return wrapper",
            "def method_cache(method, cache_wrapper=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Wrap lru_cache to support storing the cache data in the object instances.\\n\\n    Abstracts the common paradigm where the method explicitly saves an\\n    underscore-prefixed protected property on first call and returns that\\n    subsequently.\\n\\n    >>> class MyClass:\\n    ...     calls = 0\\n    ...\\n    ...     @method_cache\\n    ...     def method(self, value):\\n    ...         self.calls += 1\\n    ...         return value\\n\\n    >>> a = MyClass()\\n    >>> a.method(3)\\n    3\\n    >>> for x in range(75):\\n    ...     res = a.method(x)\\n    >>> a.calls\\n    75\\n\\n    Note that the apparent behavior will be exactly like that of lru_cache\\n    except that the cache is stored on each instance, so values in one\\n    instance will not flush values from another, and when an instance is\\n    deleted, so are the cached values for that instance.\\n\\n    >>> b = MyClass()\\n    >>> for x in range(35):\\n    ...     res = b.method(x)\\n    >>> b.calls\\n    35\\n    >>> a.method(0)\\n    0\\n    >>> a.calls\\n    75\\n\\n    Note that if method had been decorated with ``functools.lru_cache()``,\\n    a.calls would have been 76 (due to the cached value of 0 having been\\n    flushed by the 'b' instance).\\n\\n    Clear the cache with ``.cache_clear()``\\n\\n    >>> a.method.cache_clear()\\n\\n    Same for a method that hasn't yet been called.\\n\\n    >>> c = MyClass()\\n    >>> c.method.cache_clear()\\n\\n    Another cache wrapper may be supplied:\\n\\n    >>> cache = functools.lru_cache(maxsize=2)\\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\\n    >>> a = MyClass()\\n    >>> a.method2()\\n    3\\n\\n    Caution - do not subsequently wrap the method with another decorator, such\\n    as ``@property``, which changes the semantics of the function.\\n\\n    See also\\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\\n    for another implementation and additional justification.\\n    \"\n    cache_wrapper = cache_wrapper or functools.lru_cache()\n\n    def wrapper(self, *args, **kwargs):\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n    wrapper.cache_clear = lambda : None\n    return wrapper",
            "def method_cache(method, cache_wrapper=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Wrap lru_cache to support storing the cache data in the object instances.\\n\\n    Abstracts the common paradigm where the method explicitly saves an\\n    underscore-prefixed protected property on first call and returns that\\n    subsequently.\\n\\n    >>> class MyClass:\\n    ...     calls = 0\\n    ...\\n    ...     @method_cache\\n    ...     def method(self, value):\\n    ...         self.calls += 1\\n    ...         return value\\n\\n    >>> a = MyClass()\\n    >>> a.method(3)\\n    3\\n    >>> for x in range(75):\\n    ...     res = a.method(x)\\n    >>> a.calls\\n    75\\n\\n    Note that the apparent behavior will be exactly like that of lru_cache\\n    except that the cache is stored on each instance, so values in one\\n    instance will not flush values from another, and when an instance is\\n    deleted, so are the cached values for that instance.\\n\\n    >>> b = MyClass()\\n    >>> for x in range(35):\\n    ...     res = b.method(x)\\n    >>> b.calls\\n    35\\n    >>> a.method(0)\\n    0\\n    >>> a.calls\\n    75\\n\\n    Note that if method had been decorated with ``functools.lru_cache()``,\\n    a.calls would have been 76 (due to the cached value of 0 having been\\n    flushed by the 'b' instance).\\n\\n    Clear the cache with ``.cache_clear()``\\n\\n    >>> a.method.cache_clear()\\n\\n    Same for a method that hasn't yet been called.\\n\\n    >>> c = MyClass()\\n    >>> c.method.cache_clear()\\n\\n    Another cache wrapper may be supplied:\\n\\n    >>> cache = functools.lru_cache(maxsize=2)\\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\\n    >>> a = MyClass()\\n    >>> a.method2()\\n    3\\n\\n    Caution - do not subsequently wrap the method with another decorator, such\\n    as ``@property``, which changes the semantics of the function.\\n\\n    See also\\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\\n    for another implementation and additional justification.\\n    \"\n    cache_wrapper = cache_wrapper or functools.lru_cache()\n\n    def wrapper(self, *args, **kwargs):\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n    wrapper.cache_clear = lambda : None\n    return wrapper",
            "def method_cache(method, cache_wrapper=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Wrap lru_cache to support storing the cache data in the object instances.\\n\\n    Abstracts the common paradigm where the method explicitly saves an\\n    underscore-prefixed protected property on first call and returns that\\n    subsequently.\\n\\n    >>> class MyClass:\\n    ...     calls = 0\\n    ...\\n    ...     @method_cache\\n    ...     def method(self, value):\\n    ...         self.calls += 1\\n    ...         return value\\n\\n    >>> a = MyClass()\\n    >>> a.method(3)\\n    3\\n    >>> for x in range(75):\\n    ...     res = a.method(x)\\n    >>> a.calls\\n    75\\n\\n    Note that the apparent behavior will be exactly like that of lru_cache\\n    except that the cache is stored on each instance, so values in one\\n    instance will not flush values from another, and when an instance is\\n    deleted, so are the cached values for that instance.\\n\\n    >>> b = MyClass()\\n    >>> for x in range(35):\\n    ...     res = b.method(x)\\n    >>> b.calls\\n    35\\n    >>> a.method(0)\\n    0\\n    >>> a.calls\\n    75\\n\\n    Note that if method had been decorated with ``functools.lru_cache()``,\\n    a.calls would have been 76 (due to the cached value of 0 having been\\n    flushed by the 'b' instance).\\n\\n    Clear the cache with ``.cache_clear()``\\n\\n    >>> a.method.cache_clear()\\n\\n    Same for a method that hasn't yet been called.\\n\\n    >>> c = MyClass()\\n    >>> c.method.cache_clear()\\n\\n    Another cache wrapper may be supplied:\\n\\n    >>> cache = functools.lru_cache(maxsize=2)\\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\\n    >>> a = MyClass()\\n    >>> a.method2()\\n    3\\n\\n    Caution - do not subsequently wrap the method with another decorator, such\\n    as ``@property``, which changes the semantics of the function.\\n\\n    See also\\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\\n    for another implementation and additional justification.\\n    \"\n    cache_wrapper = cache_wrapper or functools.lru_cache()\n\n    def wrapper(self, *args, **kwargs):\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n    wrapper.cache_clear = lambda : None\n    return wrapper"
        ]
    },
    {
        "func_name": "wrapper",
        "original": "@functools.wraps(func)\ndef wrapper(param, *args, **kwargs):\n    if param is not None:\n        return func(param, *args, **kwargs)",
        "mutated": [
            "@functools.wraps(func)\ndef wrapper(param, *args, **kwargs):\n    if False:\n        i = 10\n    if param is not None:\n        return func(param, *args, **kwargs)",
            "@functools.wraps(func)\ndef wrapper(param, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if param is not None:\n        return func(param, *args, **kwargs)",
            "@functools.wraps(func)\ndef wrapper(param, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if param is not None:\n        return func(param, *args, **kwargs)",
            "@functools.wraps(func)\ndef wrapper(param, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if param is not None:\n        return func(param, *args, **kwargs)",
            "@functools.wraps(func)\ndef wrapper(param, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if param is not None:\n        return func(param, *args, **kwargs)"
        ]
    },
    {
        "func_name": "pass_none",
        "original": "def pass_none(func):\n    \"\"\"\n    Wrap func so it's not called if its first param is None\n\n    >>> print_text = pass_none(print)\n    >>> print_text('text')\n    text\n    >>> print_text(None)\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n    return wrapper",
        "mutated": [
            "def pass_none(func):\n    if False:\n        i = 10\n    \"\\n    Wrap func so it's not called if its first param is None\\n\\n    >>> print_text = pass_none(print)\\n    >>> print_text('text')\\n    text\\n    >>> print_text(None)\\n    \"\n\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n    return wrapper",
            "def pass_none(func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Wrap func so it's not called if its first param is None\\n\\n    >>> print_text = pass_none(print)\\n    >>> print_text('text')\\n    text\\n    >>> print_text(None)\\n    \"\n\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n    return wrapper",
            "def pass_none(func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Wrap func so it's not called if its first param is None\\n\\n    >>> print_text = pass_none(print)\\n    >>> print_text('text')\\n    text\\n    >>> print_text(None)\\n    \"\n\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n    return wrapper",
            "def pass_none(func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Wrap func so it's not called if its first param is None\\n\\n    >>> print_text = pass_none(print)\\n    >>> print_text('text')\\n    text\\n    >>> print_text(None)\\n    \"\n\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n    return wrapper",
            "def pass_none(func):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Wrap func so it's not called if its first param is None\\n\\n    >>> print_text = pass_none(print)\\n    >>> print_text('text')\\n    text\\n    >>> print_text(None)\\n    \"\n\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n    return wrapper"
        ]
    }
]