[
    {
        "func_name": "worker_thread1",
        "original": "def worker_thread1(thread_name, run_freq, window):\n    \"\"\"\n    A worker thread that communicates with the GUI\n    These threads can call functions that block without affecting the GUI (a good thing)\n    Note that this function is the code started as each thread. All threads are identical in this way\n    :param thread_name: Text name used  for displaying info\n    :param run_freq: How often the thread should run in milliseconds\n    :param window: window this thread will be conversing with\n    :type window: sg.Window\n    :return:\n    \"\"\"\n    print('Starting thread 1 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
        "mutated": [
            "def worker_thread1(thread_name, run_freq, window):\n    if False:\n        i = 10\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 1 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread1(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 1 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread1(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 1 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread1(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 1 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread1(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 1 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')"
        ]
    },
    {
        "func_name": "worker_thread2",
        "original": "def worker_thread2(thread_name, run_freq, window):\n    \"\"\"\n    A worker thread that communicates with the GUI\n    These threads can call functions that block without affecting the GUI (a good thing)\n    Note that this function is the code started as each thread. All threads are identical in this way\n    :param thread_name: Text name used  for displaying info\n    :param run_freq: How often the thread should run in milliseconds\n    :param window: window this thread will be conversing with\n    :type window: sg.Window\n    :return:\n    \"\"\"\n    print('Starting thread 2 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
        "mutated": [
            "def worker_thread2(thread_name, run_freq, window):\n    if False:\n        i = 10\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 2 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread2(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 2 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread2(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 2 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread2(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 2 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread2(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 2 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')"
        ]
    },
    {
        "func_name": "worker_thread3",
        "original": "def worker_thread3(thread_name, run_freq, window):\n    \"\"\"\n    A worker thread that communicates with the GUI\n    These threads can call functions that block without affecting the GUI (a good thing)\n    Note that this function is the code started as each thread. All threads are identical in this way\n    :param thread_name: Text name used  for displaying info\n    :param run_freq: How often the thread should run in milliseconds\n    :param window: window this thread will be conversing with\n    :type window: sg.Window\n    :return:\n    \"\"\"\n    print('Starting thread 3 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
        "mutated": [
            "def worker_thread3(thread_name, run_freq, window):\n    if False:\n        i = 10\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 3 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread3(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 3 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread3(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 3 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread3(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 3 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')",
            "def worker_thread3(thread_name, run_freq, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    A worker thread that communicates with the GUI\\n    These threads can call functions that block without affecting the GUI (a good thing)\\n    Note that this function is the code started as each thread. All threads are identical in this way\\n    :param thread_name: Text name used  for displaying info\\n    :param run_freq: How often the thread should run in milliseconds\\n    :param window: window this thread will be conversing with\\n    :type window: sg.Window\\n    :return:\\n    '\n    print('Starting thread 3 - {} that runs every {} ms'.format(thread_name, run_freq))\n    for i in itertools.count():\n        time.sleep(run_freq / 1000)\n        window.write_event_value(thread_name, f'count = {i}')"
        ]
    },
    {
        "func_name": "the_gui",
        "original": "def the_gui():\n    \"\"\"\n    Starts and executes the GUI\n    Reads data from a Queue and displays the data to the window\n    Returns when the user exits / closes the window\n        (that means it does NOT return until the user exits the window)\n    :param gui_queue: Queue the GUI should read from\n    :return:\n    \"\"\"\n    layout = [[sg.Text('Multithreaded Window Example')], [sg.Text('', size=(15, 1), key='-OUTPUT-')], [sg.Multiline(size=(40, 26), key='-ML-', autoscroll=True)], [sg.Button('Exit')]]\n    window = sg.Window('Multithreaded Window', layout, finalize=True)\n    threading.Thread(target=worker_thread1, args=('Thread 1', 500, window), daemon=True).start()\n    threading.Thread(target=worker_thread2, args=('Thread 2', 200, window), daemon=True).start()\n    threading.Thread(target=worker_thread3, args=('Thread 3', 1000, window), daemon=True).start()\n    sg.cprint_set_output_destination(window, '-ML-')\n    colors = {'Thread 1': ('white', 'red'), 'Thread 2': ('white', 'purple'), 'Thread 3': ('white', 'blue')}\n    while True:\n        (event, values) = window.read()\n        if event in (sg.WIN_CLOSED, 'Exit'):\n            break\n        sg.cprint(event, values[event], c=colors[event])\n    window.close()",
        "mutated": [
            "def the_gui():\n    if False:\n        i = 10\n    '\\n    Starts and executes the GUI\\n    Reads data from a Queue and displays the data to the window\\n    Returns when the user exits / closes the window\\n        (that means it does NOT return until the user exits the window)\\n    :param gui_queue: Queue the GUI should read from\\n    :return:\\n    '\n    layout = [[sg.Text('Multithreaded Window Example')], [sg.Text('', size=(15, 1), key='-OUTPUT-')], [sg.Multiline(size=(40, 26), key='-ML-', autoscroll=True)], [sg.Button('Exit')]]\n    window = sg.Window('Multithreaded Window', layout, finalize=True)\n    threading.Thread(target=worker_thread1, args=('Thread 1', 500, window), daemon=True).start()\n    threading.Thread(target=worker_thread2, args=('Thread 2', 200, window), daemon=True).start()\n    threading.Thread(target=worker_thread3, args=('Thread 3', 1000, window), daemon=True).start()\n    sg.cprint_set_output_destination(window, '-ML-')\n    colors = {'Thread 1': ('white', 'red'), 'Thread 2': ('white', 'purple'), 'Thread 3': ('white', 'blue')}\n    while True:\n        (event, values) = window.read()\n        if event in (sg.WIN_CLOSED, 'Exit'):\n            break\n        sg.cprint(event, values[event], c=colors[event])\n    window.close()",
            "def the_gui():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Starts and executes the GUI\\n    Reads data from a Queue and displays the data to the window\\n    Returns when the user exits / closes the window\\n        (that means it does NOT return until the user exits the window)\\n    :param gui_queue: Queue the GUI should read from\\n    :return:\\n    '\n    layout = [[sg.Text('Multithreaded Window Example')], [sg.Text('', size=(15, 1), key='-OUTPUT-')], [sg.Multiline(size=(40, 26), key='-ML-', autoscroll=True)], [sg.Button('Exit')]]\n    window = sg.Window('Multithreaded Window', layout, finalize=True)\n    threading.Thread(target=worker_thread1, args=('Thread 1', 500, window), daemon=True).start()\n    threading.Thread(target=worker_thread2, args=('Thread 2', 200, window), daemon=True).start()\n    threading.Thread(target=worker_thread3, args=('Thread 3', 1000, window), daemon=True).start()\n    sg.cprint_set_output_destination(window, '-ML-')\n    colors = {'Thread 1': ('white', 'red'), 'Thread 2': ('white', 'purple'), 'Thread 3': ('white', 'blue')}\n    while True:\n        (event, values) = window.read()\n        if event in (sg.WIN_CLOSED, 'Exit'):\n            break\n        sg.cprint(event, values[event], c=colors[event])\n    window.close()",
            "def the_gui():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Starts and executes the GUI\\n    Reads data from a Queue and displays the data to the window\\n    Returns when the user exits / closes the window\\n        (that means it does NOT return until the user exits the window)\\n    :param gui_queue: Queue the GUI should read from\\n    :return:\\n    '\n    layout = [[sg.Text('Multithreaded Window Example')], [sg.Text('', size=(15, 1), key='-OUTPUT-')], [sg.Multiline(size=(40, 26), key='-ML-', autoscroll=True)], [sg.Button('Exit')]]\n    window = sg.Window('Multithreaded Window', layout, finalize=True)\n    threading.Thread(target=worker_thread1, args=('Thread 1', 500, window), daemon=True).start()\n    threading.Thread(target=worker_thread2, args=('Thread 2', 200, window), daemon=True).start()\n    threading.Thread(target=worker_thread3, args=('Thread 3', 1000, window), daemon=True).start()\n    sg.cprint_set_output_destination(window, '-ML-')\n    colors = {'Thread 1': ('white', 'red'), 'Thread 2': ('white', 'purple'), 'Thread 3': ('white', 'blue')}\n    while True:\n        (event, values) = window.read()\n        if event in (sg.WIN_CLOSED, 'Exit'):\n            break\n        sg.cprint(event, values[event], c=colors[event])\n    window.close()",
            "def the_gui():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Starts and executes the GUI\\n    Reads data from a Queue and displays the data to the window\\n    Returns when the user exits / closes the window\\n        (that means it does NOT return until the user exits the window)\\n    :param gui_queue: Queue the GUI should read from\\n    :return:\\n    '\n    layout = [[sg.Text('Multithreaded Window Example')], [sg.Text('', size=(15, 1), key='-OUTPUT-')], [sg.Multiline(size=(40, 26), key='-ML-', autoscroll=True)], [sg.Button('Exit')]]\n    window = sg.Window('Multithreaded Window', layout, finalize=True)\n    threading.Thread(target=worker_thread1, args=('Thread 1', 500, window), daemon=True).start()\n    threading.Thread(target=worker_thread2, args=('Thread 2', 200, window), daemon=True).start()\n    threading.Thread(target=worker_thread3, args=('Thread 3', 1000, window), daemon=True).start()\n    sg.cprint_set_output_destination(window, '-ML-')\n    colors = {'Thread 1': ('white', 'red'), 'Thread 2': ('white', 'purple'), 'Thread 3': ('white', 'blue')}\n    while True:\n        (event, values) = window.read()\n        if event in (sg.WIN_CLOSED, 'Exit'):\n            break\n        sg.cprint(event, values[event], c=colors[event])\n    window.close()",
            "def the_gui():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Starts and executes the GUI\\n    Reads data from a Queue and displays the data to the window\\n    Returns when the user exits / closes the window\\n        (that means it does NOT return until the user exits the window)\\n    :param gui_queue: Queue the GUI should read from\\n    :return:\\n    '\n    layout = [[sg.Text('Multithreaded Window Example')], [sg.Text('', size=(15, 1), key='-OUTPUT-')], [sg.Multiline(size=(40, 26), key='-ML-', autoscroll=True)], [sg.Button('Exit')]]\n    window = sg.Window('Multithreaded Window', layout, finalize=True)\n    threading.Thread(target=worker_thread1, args=('Thread 1', 500, window), daemon=True).start()\n    threading.Thread(target=worker_thread2, args=('Thread 2', 200, window), daemon=True).start()\n    threading.Thread(target=worker_thread3, args=('Thread 3', 1000, window), daemon=True).start()\n    sg.cprint_set_output_destination(window, '-ML-')\n    colors = {'Thread 1': ('white', 'red'), 'Thread 2': ('white', 'purple'), 'Thread 3': ('white', 'blue')}\n    while True:\n        (event, values) = window.read()\n        if event in (sg.WIN_CLOSED, 'Exit'):\n            break\n        sg.cprint(event, values[event], c=colors[event])\n    window.close()"
        ]
    }
]