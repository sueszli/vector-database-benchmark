[
    {
        "func_name": "classify",
        "original": "def classify(text, verbose=True):\n    \"\"\"Classify the input text into categories.\"\"\"\n    language_client = language_v1.LanguageServiceClient()\n    document = language_v1.Document(content=text, type_=language_v1.Document.Type.PLAIN_TEXT)\n    response = language_client.classify_text(request={'document': document})\n    categories = response.categories\n    result = {}\n    for category in categories:\n        result[category.name] = category.confidence\n    if verbose:\n        print(text)\n        for category in categories:\n            print('=' * 20)\n            print('{:<16}: {}'.format('category', category.name))\n            print('{:<16}: {}'.format('confidence', category.confidence))\n    return result",
        "mutated": [
            "def classify(text, verbose=True):\n    if False:\n        i = 10\n    'Classify the input text into categories.'\n    language_client = language_v1.LanguageServiceClient()\n    document = language_v1.Document(content=text, type_=language_v1.Document.Type.PLAIN_TEXT)\n    response = language_client.classify_text(request={'document': document})\n    categories = response.categories\n    result = {}\n    for category in categories:\n        result[category.name] = category.confidence\n    if verbose:\n        print(text)\n        for category in categories:\n            print('=' * 20)\n            print('{:<16}: {}'.format('category', category.name))\n            print('{:<16}: {}'.format('confidence', category.confidence))\n    return result",
            "def classify(text, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Classify the input text into categories.'\n    language_client = language_v1.LanguageServiceClient()\n    document = language_v1.Document(content=text, type_=language_v1.Document.Type.PLAIN_TEXT)\n    response = language_client.classify_text(request={'document': document})\n    categories = response.categories\n    result = {}\n    for category in categories:\n        result[category.name] = category.confidence\n    if verbose:\n        print(text)\n        for category in categories:\n            print('=' * 20)\n            print('{:<16}: {}'.format('category', category.name))\n            print('{:<16}: {}'.format('confidence', category.confidence))\n    return result",
            "def classify(text, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Classify the input text into categories.'\n    language_client = language_v1.LanguageServiceClient()\n    document = language_v1.Document(content=text, type_=language_v1.Document.Type.PLAIN_TEXT)\n    response = language_client.classify_text(request={'document': document})\n    categories = response.categories\n    result = {}\n    for category in categories:\n        result[category.name] = category.confidence\n    if verbose:\n        print(text)\n        for category in categories:\n            print('=' * 20)\n            print('{:<16}: {}'.format('category', category.name))\n            print('{:<16}: {}'.format('confidence', category.confidence))\n    return result",
            "def classify(text, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Classify the input text into categories.'\n    language_client = language_v1.LanguageServiceClient()\n    document = language_v1.Document(content=text, type_=language_v1.Document.Type.PLAIN_TEXT)\n    response = language_client.classify_text(request={'document': document})\n    categories = response.categories\n    result = {}\n    for category in categories:\n        result[category.name] = category.confidence\n    if verbose:\n        print(text)\n        for category in categories:\n            print('=' * 20)\n            print('{:<16}: {}'.format('category', category.name))\n            print('{:<16}: {}'.format('confidence', category.confidence))\n    return result",
            "def classify(text, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Classify the input text into categories.'\n    language_client = language_v1.LanguageServiceClient()\n    document = language_v1.Document(content=text, type_=language_v1.Document.Type.PLAIN_TEXT)\n    response = language_client.classify_text(request={'document': document})\n    categories = response.categories\n    result = {}\n    for category in categories:\n        result[category.name] = category.confidence\n    if verbose:\n        print(text)\n        for category in categories:\n            print('=' * 20)\n            print('{:<16}: {}'.format('category', category.name))\n            print('{:<16}: {}'.format('confidence', category.confidence))\n    return result"
        ]
    },
    {
        "func_name": "index",
        "original": "def index(path, index_file):\n    \"\"\"Classify each text file in a directory and write\n    the results to the index_file.\n    \"\"\"\n    result = {}\n    for filename in os.listdir(path):\n        file_path = os.path.join(path, filename)\n        if not os.path.isfile(file_path):\n            continue\n        try:\n            with open(file_path) as f:\n                text = f.read()\n                categories = classify(text, verbose=False)\n                result[filename] = categories\n        except Exception:\n            print(f'Failed to process {file_path}')\n    with open(index_file, 'w', encoding='utf-8') as f:\n        f.write(json.dumps(result, ensure_ascii=False))\n    print(f'Texts indexed in file: {index_file}')\n    return result",
        "mutated": [
            "def index(path, index_file):\n    if False:\n        i = 10\n    'Classify each text file in a directory and write\\n    the results to the index_file.\\n    '\n    result = {}\n    for filename in os.listdir(path):\n        file_path = os.path.join(path, filename)\n        if not os.path.isfile(file_path):\n            continue\n        try:\n            with open(file_path) as f:\n                text = f.read()\n                categories = classify(text, verbose=False)\n                result[filename] = categories\n        except Exception:\n            print(f'Failed to process {file_path}')\n    with open(index_file, 'w', encoding='utf-8') as f:\n        f.write(json.dumps(result, ensure_ascii=False))\n    print(f'Texts indexed in file: {index_file}')\n    return result",
            "def index(path, index_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Classify each text file in a directory and write\\n    the results to the index_file.\\n    '\n    result = {}\n    for filename in os.listdir(path):\n        file_path = os.path.join(path, filename)\n        if not os.path.isfile(file_path):\n            continue\n        try:\n            with open(file_path) as f:\n                text = f.read()\n                categories = classify(text, verbose=False)\n                result[filename] = categories\n        except Exception:\n            print(f'Failed to process {file_path}')\n    with open(index_file, 'w', encoding='utf-8') as f:\n        f.write(json.dumps(result, ensure_ascii=False))\n    print(f'Texts indexed in file: {index_file}')\n    return result",
            "def index(path, index_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Classify each text file in a directory and write\\n    the results to the index_file.\\n    '\n    result = {}\n    for filename in os.listdir(path):\n        file_path = os.path.join(path, filename)\n        if not os.path.isfile(file_path):\n            continue\n        try:\n            with open(file_path) as f:\n                text = f.read()\n                categories = classify(text, verbose=False)\n                result[filename] = categories\n        except Exception:\n            print(f'Failed to process {file_path}')\n    with open(index_file, 'w', encoding='utf-8') as f:\n        f.write(json.dumps(result, ensure_ascii=False))\n    print(f'Texts indexed in file: {index_file}')\n    return result",
            "def index(path, index_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Classify each text file in a directory and write\\n    the results to the index_file.\\n    '\n    result = {}\n    for filename in os.listdir(path):\n        file_path = os.path.join(path, filename)\n        if not os.path.isfile(file_path):\n            continue\n        try:\n            with open(file_path) as f:\n                text = f.read()\n                categories = classify(text, verbose=False)\n                result[filename] = categories\n        except Exception:\n            print(f'Failed to process {file_path}')\n    with open(index_file, 'w', encoding='utf-8') as f:\n        f.write(json.dumps(result, ensure_ascii=False))\n    print(f'Texts indexed in file: {index_file}')\n    return result",
            "def index(path, index_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Classify each text file in a directory and write\\n    the results to the index_file.\\n    '\n    result = {}\n    for filename in os.listdir(path):\n        file_path = os.path.join(path, filename)\n        if not os.path.isfile(file_path):\n            continue\n        try:\n            with open(file_path) as f:\n                text = f.read()\n                categories = classify(text, verbose=False)\n                result[filename] = categories\n        except Exception:\n            print(f'Failed to process {file_path}')\n    with open(index_file, 'w', encoding='utf-8') as f:\n        f.write(json.dumps(result, ensure_ascii=False))\n    print(f'Texts indexed in file: {index_file}')\n    return result"
        ]
    },
    {
        "func_name": "split_labels",
        "original": "def split_labels(categories):\n    \"\"\"The category labels are of the form \"/a/b/c\" up to three levels,\n    for example \"/Computers & Electronics/Software\", and these labels\n    are used as keys in the categories dictionary, whose values are\n    confidence scores.\n\n    The split_labels function splits the keys into individual levels\n    while duplicating the confidence score, which allows a natural\n    boost in how we calculate similarity when more levels are in common.\n\n    Example:\n    If we have\n\n    x = {\"/a/b/c\": 0.5}\n    y = {\"/a/b\": 0.5}\n    z = {\"/a\": 0.5}\n\n    Then x and y are considered more similar than y and z.\n    \"\"\"\n    _categories = {}\n    for (name, confidence) in categories.items():\n        labels = [label for label in name.split('/') if label]\n        for label in labels:\n            _categories[label] = confidence\n    return _categories",
        "mutated": [
            "def split_labels(categories):\n    if False:\n        i = 10\n    'The category labels are of the form \"/a/b/c\" up to three levels,\\n    for example \"/Computers & Electronics/Software\", and these labels\\n    are used as keys in the categories dictionary, whose values are\\n    confidence scores.\\n\\n    The split_labels function splits the keys into individual levels\\n    while duplicating the confidence score, which allows a natural\\n    boost in how we calculate similarity when more levels are in common.\\n\\n    Example:\\n    If we have\\n\\n    x = {\"/a/b/c\": 0.5}\\n    y = {\"/a/b\": 0.5}\\n    z = {\"/a\": 0.5}\\n\\n    Then x and y are considered more similar than y and z.\\n    '\n    _categories = {}\n    for (name, confidence) in categories.items():\n        labels = [label for label in name.split('/') if label]\n        for label in labels:\n            _categories[label] = confidence\n    return _categories",
            "def split_labels(categories):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'The category labels are of the form \"/a/b/c\" up to three levels,\\n    for example \"/Computers & Electronics/Software\", and these labels\\n    are used as keys in the categories dictionary, whose values are\\n    confidence scores.\\n\\n    The split_labels function splits the keys into individual levels\\n    while duplicating the confidence score, which allows a natural\\n    boost in how we calculate similarity when more levels are in common.\\n\\n    Example:\\n    If we have\\n\\n    x = {\"/a/b/c\": 0.5}\\n    y = {\"/a/b\": 0.5}\\n    z = {\"/a\": 0.5}\\n\\n    Then x and y are considered more similar than y and z.\\n    '\n    _categories = {}\n    for (name, confidence) in categories.items():\n        labels = [label for label in name.split('/') if label]\n        for label in labels:\n            _categories[label] = confidence\n    return _categories",
            "def split_labels(categories):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'The category labels are of the form \"/a/b/c\" up to three levels,\\n    for example \"/Computers & Electronics/Software\", and these labels\\n    are used as keys in the categories dictionary, whose values are\\n    confidence scores.\\n\\n    The split_labels function splits the keys into individual levels\\n    while duplicating the confidence score, which allows a natural\\n    boost in how we calculate similarity when more levels are in common.\\n\\n    Example:\\n    If we have\\n\\n    x = {\"/a/b/c\": 0.5}\\n    y = {\"/a/b\": 0.5}\\n    z = {\"/a\": 0.5}\\n\\n    Then x and y are considered more similar than y and z.\\n    '\n    _categories = {}\n    for (name, confidence) in categories.items():\n        labels = [label for label in name.split('/') if label]\n        for label in labels:\n            _categories[label] = confidence\n    return _categories",
            "def split_labels(categories):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'The category labels are of the form \"/a/b/c\" up to three levels,\\n    for example \"/Computers & Electronics/Software\", and these labels\\n    are used as keys in the categories dictionary, whose values are\\n    confidence scores.\\n\\n    The split_labels function splits the keys into individual levels\\n    while duplicating the confidence score, which allows a natural\\n    boost in how we calculate similarity when more levels are in common.\\n\\n    Example:\\n    If we have\\n\\n    x = {\"/a/b/c\": 0.5}\\n    y = {\"/a/b\": 0.5}\\n    z = {\"/a\": 0.5}\\n\\n    Then x and y are considered more similar than y and z.\\n    '\n    _categories = {}\n    for (name, confidence) in categories.items():\n        labels = [label for label in name.split('/') if label]\n        for label in labels:\n            _categories[label] = confidence\n    return _categories",
            "def split_labels(categories):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'The category labels are of the form \"/a/b/c\" up to three levels,\\n    for example \"/Computers & Electronics/Software\", and these labels\\n    are used as keys in the categories dictionary, whose values are\\n    confidence scores.\\n\\n    The split_labels function splits the keys into individual levels\\n    while duplicating the confidence score, which allows a natural\\n    boost in how we calculate similarity when more levels are in common.\\n\\n    Example:\\n    If we have\\n\\n    x = {\"/a/b/c\": 0.5}\\n    y = {\"/a/b\": 0.5}\\n    z = {\"/a\": 0.5}\\n\\n    Then x and y are considered more similar than y and z.\\n    '\n    _categories = {}\n    for (name, confidence) in categories.items():\n        labels = [label for label in name.split('/') if label]\n        for label in labels:\n            _categories[label] = confidence\n    return _categories"
        ]
    },
    {
        "func_name": "similarity",
        "original": "def similarity(categories1, categories2):\n    \"\"\"Cosine similarity of the categories treated as sparse vectors.\"\"\"\n    categories1 = split_labels(categories1)\n    categories2 = split_labels(categories2)\n    norm1 = numpy.linalg.norm(list(categories1.values()))\n    norm2 = numpy.linalg.norm(list(categories2.values()))\n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    dot = 0.0\n    for (label, confidence) in categories1.items():\n        dot += confidence * categories2.get(label, 0.0)\n    return dot / (norm1 * norm2)",
        "mutated": [
            "def similarity(categories1, categories2):\n    if False:\n        i = 10\n    'Cosine similarity of the categories treated as sparse vectors.'\n    categories1 = split_labels(categories1)\n    categories2 = split_labels(categories2)\n    norm1 = numpy.linalg.norm(list(categories1.values()))\n    norm2 = numpy.linalg.norm(list(categories2.values()))\n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    dot = 0.0\n    for (label, confidence) in categories1.items():\n        dot += confidence * categories2.get(label, 0.0)\n    return dot / (norm1 * norm2)",
            "def similarity(categories1, categories2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Cosine similarity of the categories treated as sparse vectors.'\n    categories1 = split_labels(categories1)\n    categories2 = split_labels(categories2)\n    norm1 = numpy.linalg.norm(list(categories1.values()))\n    norm2 = numpy.linalg.norm(list(categories2.values()))\n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    dot = 0.0\n    for (label, confidence) in categories1.items():\n        dot += confidence * categories2.get(label, 0.0)\n    return dot / (norm1 * norm2)",
            "def similarity(categories1, categories2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Cosine similarity of the categories treated as sparse vectors.'\n    categories1 = split_labels(categories1)\n    categories2 = split_labels(categories2)\n    norm1 = numpy.linalg.norm(list(categories1.values()))\n    norm2 = numpy.linalg.norm(list(categories2.values()))\n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    dot = 0.0\n    for (label, confidence) in categories1.items():\n        dot += confidence * categories2.get(label, 0.0)\n    return dot / (norm1 * norm2)",
            "def similarity(categories1, categories2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Cosine similarity of the categories treated as sparse vectors.'\n    categories1 = split_labels(categories1)\n    categories2 = split_labels(categories2)\n    norm1 = numpy.linalg.norm(list(categories1.values()))\n    norm2 = numpy.linalg.norm(list(categories2.values()))\n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    dot = 0.0\n    for (label, confidence) in categories1.items():\n        dot += confidence * categories2.get(label, 0.0)\n    return dot / (norm1 * norm2)",
            "def similarity(categories1, categories2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Cosine similarity of the categories treated as sparse vectors.'\n    categories1 = split_labels(categories1)\n    categories2 = split_labels(categories2)\n    norm1 = numpy.linalg.norm(list(categories1.values()))\n    norm2 = numpy.linalg.norm(list(categories2.values()))\n    if norm1 == 0 or norm2 == 0:\n        return 0.0\n    dot = 0.0\n    for (label, confidence) in categories1.items():\n        dot += confidence * categories2.get(label, 0.0)\n    return dot / (norm1 * norm2)"
        ]
    },
    {
        "func_name": "query",
        "original": "def query(index_file, text, n_top=3):\n    \"\"\"Find the indexed files that are the most similar to\n    the query text.\n    \"\"\"\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = classify(text, verbose=False)\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {text}\\n')\n    for (category, confidence) in query_categories.items():\n        print(f'\\tCategory: {category}, confidence: {confidence}')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
        "mutated": [
            "def query(index_file, text, n_top=3):\n    if False:\n        i = 10\n    'Find the indexed files that are the most similar to\\n    the query text.\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = classify(text, verbose=False)\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {text}\\n')\n    for (category, confidence) in query_categories.items():\n        print(f'\\tCategory: {category}, confidence: {confidence}')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
            "def query(index_file, text, n_top=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find the indexed files that are the most similar to\\n    the query text.\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = classify(text, verbose=False)\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {text}\\n')\n    for (category, confidence) in query_categories.items():\n        print(f'\\tCategory: {category}, confidence: {confidence}')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
            "def query(index_file, text, n_top=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find the indexed files that are the most similar to\\n    the query text.\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = classify(text, verbose=False)\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {text}\\n')\n    for (category, confidence) in query_categories.items():\n        print(f'\\tCategory: {category}, confidence: {confidence}')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
            "def query(index_file, text, n_top=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find the indexed files that are the most similar to\\n    the query text.\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = classify(text, verbose=False)\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {text}\\n')\n    for (category, confidence) in query_categories.items():\n        print(f'\\tCategory: {category}, confidence: {confidence}')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
            "def query(index_file, text, n_top=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find the indexed files that are the most similar to\\n    the query text.\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = classify(text, verbose=False)\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {text}\\n')\n    for (category, confidence) in query_categories.items():\n        print(f'\\tCategory: {category}, confidence: {confidence}')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities"
        ]
    },
    {
        "func_name": "query_category",
        "original": "def query_category(index_file, category_string, n_top=3):\n    \"\"\"Find the indexed files that are the most similar to\n    the query label.\n\n    The list of all available labels:\n    https://cloud.google.com/natural-language/docs/categories\n    \"\"\"\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = {category_string: 1.0}\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {category_string}\\n')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
        "mutated": [
            "def query_category(index_file, category_string, n_top=3):\n    if False:\n        i = 10\n    'Find the indexed files that are the most similar to\\n    the query label.\\n\\n    The list of all available labels:\\n    https://cloud.google.com/natural-language/docs/categories\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = {category_string: 1.0}\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {category_string}\\n')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
            "def query_category(index_file, category_string, n_top=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find the indexed files that are the most similar to\\n    the query label.\\n\\n    The list of all available labels:\\n    https://cloud.google.com/natural-language/docs/categories\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = {category_string: 1.0}\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {category_string}\\n')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
            "def query_category(index_file, category_string, n_top=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find the indexed files that are the most similar to\\n    the query label.\\n\\n    The list of all available labels:\\n    https://cloud.google.com/natural-language/docs/categories\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = {category_string: 1.0}\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {category_string}\\n')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
            "def query_category(index_file, category_string, n_top=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find the indexed files that are the most similar to\\n    the query label.\\n\\n    The list of all available labels:\\n    https://cloud.google.com/natural-language/docs/categories\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = {category_string: 1.0}\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {category_string}\\n')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities",
            "def query_category(index_file, category_string, n_top=3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find the indexed files that are the most similar to\\n    the query label.\\n\\n    The list of all available labels:\\n    https://cloud.google.com/natural-language/docs/categories\\n    '\n    with open(index_file) as f:\n        index = json.load(f)\n    query_categories = {category_string: 1.0}\n    similarities = []\n    for (filename, categories) in index.items():\n        similarities.append((filename, similarity(query_categories, categories)))\n    similarities = sorted(similarities, key=lambda p: p[1], reverse=True)\n    print('=' * 20)\n    print(f'Query: {category_string}\\n')\n    print(f'\\nMost similar {n_top} indexed texts:')\n    for (filename, sim) in similarities[:n_top]:\n        print(f'\\tFilename: {filename}')\n        print(f'\\tSimilarity: {sim}')\n        print('\\n')\n    return similarities"
        ]
    }
]