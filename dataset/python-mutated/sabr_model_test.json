[
    {
        "func_name": "test_volatility",
        "original": "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0), ('correlated_process', 0.5, 1, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_volatility(self, beta, volvol, rho, time_step, initial_forward=1.0, initial_volatility=0.1):\n    \"\"\"Tests that volatility follows a log-normal distribution.\"\"\"\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        time = times[i]\n        path_slice = paths[:, i, 1]\n        path_slice = path_slice[path_slice > 0]\n        self.assertGreaterEqual(len(path_slice), num_samples * 0.9, msg='Too many invalid samples')\n        mean = np.mean(np.log(path_slice))\n        stddev = np.std(np.log(path_slice))\n        self.assertAllClose((-0.5 * volvol ** 2 * time, volvol * math.sqrt(time)), (mean - math.log(initial_volatility), stddev), rtol=0.1, atol=0.1)",
        "mutated": [
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0), ('correlated_process', 0.5, 1, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_volatility(self, beta, volvol, rho, time_step, initial_forward=1.0, initial_volatility=0.1):\n    if False:\n        i = 10\n    'Tests that volatility follows a log-normal distribution.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        time = times[i]\n        path_slice = paths[:, i, 1]\n        path_slice = path_slice[path_slice > 0]\n        self.assertGreaterEqual(len(path_slice), num_samples * 0.9, msg='Too many invalid samples')\n        mean = np.mean(np.log(path_slice))\n        stddev = np.std(np.log(path_slice))\n        self.assertAllClose((-0.5 * volvol ** 2 * time, volvol * math.sqrt(time)), (mean - math.log(initial_volatility), stddev), rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0), ('correlated_process', 0.5, 1, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_volatility(self, beta, volvol, rho, time_step, initial_forward=1.0, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that volatility follows a log-normal distribution.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        time = times[i]\n        path_slice = paths[:, i, 1]\n        path_slice = path_slice[path_slice > 0]\n        self.assertGreaterEqual(len(path_slice), num_samples * 0.9, msg='Too many invalid samples')\n        mean = np.mean(np.log(path_slice))\n        stddev = np.std(np.log(path_slice))\n        self.assertAllClose((-0.5 * volvol ** 2 * time, volvol * math.sqrt(time)), (mean - math.log(initial_volatility), stddev), rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0), ('correlated_process', 0.5, 1, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_volatility(self, beta, volvol, rho, time_step, initial_forward=1.0, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that volatility follows a log-normal distribution.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        time = times[i]\n        path_slice = paths[:, i, 1]\n        path_slice = path_slice[path_slice > 0]\n        self.assertGreaterEqual(len(path_slice), num_samples * 0.9, msg='Too many invalid samples')\n        mean = np.mean(np.log(path_slice))\n        stddev = np.std(np.log(path_slice))\n        self.assertAllClose((-0.5 * volvol ** 2 * time, volvol * math.sqrt(time)), (mean - math.log(initial_volatility), stddev), rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0), ('correlated_process', 0.5, 1, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_volatility(self, beta, volvol, rho, time_step, initial_forward=1.0, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that volatility follows a log-normal distribution.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        time = times[i]\n        path_slice = paths[:, i, 1]\n        path_slice = path_slice[path_slice > 0]\n        self.assertGreaterEqual(len(path_slice), num_samples * 0.9, msg='Too many invalid samples')\n        mean = np.mean(np.log(path_slice))\n        stddev = np.std(np.log(path_slice))\n        self.assertAllClose((-0.5 * volvol ** 2 * time, volvol * math.sqrt(time)), (mean - math.log(initial_volatility), stddev), rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0), ('correlated_process', 0.5, 1, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_volatility(self, beta, volvol, rho, time_step, initial_forward=1.0, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that volatility follows a log-normal distribution.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        time = times[i]\n        path_slice = paths[:, i, 1]\n        path_slice = path_slice[path_slice > 0]\n        self.assertGreaterEqual(len(path_slice), num_samples * 0.9, msg='Too many invalid samples')\n        mean = np.mean(np.log(path_slice))\n        stddev = np.std(np.log(path_slice))\n        self.assertAllClose((-0.5 * volvol ** 2 * time, volvol * math.sqrt(time)), (mean - math.log(initial_volatility), stddev), rtol=0.1, atol=0.1)"
        ]
    },
    {
        "func_name": "test_drift",
        "original": "@parameterized.named_parameters(('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('correlated_process', 0.5, 1.0, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_drift(self, beta, volvol, rho, time_step):\n    \"\"\"Tests E[F(t)] == F_0.\"\"\"\n    dtype = tf.float64\n    times = [0.1, 1.0]\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 0.1)\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        mean = np.mean(paths[:, i, 0])\n        self.assertAllClose(mean, initial_forward, rtol=0.1, atol=0.1)",
        "mutated": [
            "@parameterized.named_parameters(('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('correlated_process', 0.5, 1.0, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_drift(self, beta, volvol, rho, time_step):\n    if False:\n        i = 10\n    'Tests E[F(t)] == F_0.'\n    dtype = tf.float64\n    times = [0.1, 1.0]\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 0.1)\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        mean = np.mean(paths[:, i, 0])\n        self.assertAllClose(mean, initial_forward, rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters(('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('correlated_process', 0.5, 1.0, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_drift(self, beta, volvol, rho, time_step):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests E[F(t)] == F_0.'\n    dtype = tf.float64\n    times = [0.1, 1.0]\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 0.1)\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        mean = np.mean(paths[:, i, 0])\n        self.assertAllClose(mean, initial_forward, rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters(('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('correlated_process', 0.5, 1.0, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_drift(self, beta, volvol, rho, time_step):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests E[F(t)] == F_0.'\n    dtype = tf.float64\n    times = [0.1, 1.0]\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 0.1)\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        mean = np.mean(paths[:, i, 0])\n        self.assertAllClose(mean, initial_forward, rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters(('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('correlated_process', 0.5, 1.0, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_drift(self, beta, volvol, rho, time_step):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests E[F(t)] == F_0.'\n    dtype = tf.float64\n    times = [0.1, 1.0]\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 0.1)\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        mean = np.mean(paths[:, i, 0])\n        self.assertAllClose(mean, initial_forward, rtol=0.1, atol=0.1)",
            "@parameterized.named_parameters(('non_zero_beta', 0.5, 1.0, 0.0, 0.1), ('correlated_process', 0.5, 1.0, 0.5, 0.1), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01))\ndef test_drift(self, beta, volvol, rho, time_step):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests E[F(t)] == F_0.'\n    dtype = tf.float64\n    times = [0.1, 1.0]\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 0.1)\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    for i in range(len(times)):\n        mean = np.mean(paths[:, i, 0])\n        self.assertAllClose(mean, initial_forward, rtol=0.1, atol=0.1)"
        ]
    },
    {
        "func_name": "test_sabr_model_validate_raises_error",
        "original": "@parameterized.named_parameters(('beta_too_small', -1, 1, 0, [1.0]), ('beta_too_large', 1.1, 1, 0, [0.5]), ('negative_volvol', 0.5, -1, 0, [1.0]), ('rho_too_small', 0.5, 1, -2, [1.0]), ('rho_too_large', 0.5, 1, 2, [0.5]), ('times_not_increasing', 0.5, 1, 0, [2.0, 1.0]))\ndef test_sabr_model_validate_raises_error(self, beta, volvol, rho, times):\n    \"\"\"Test that the SABR model raises errors appropriately.\"\"\"\n    dtype = np.float64\n    time_step = 0.1\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 1.0)\n    test_seed = 123\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, validate_args=True)\n        paths = self.evaluate(paths)",
        "mutated": [
            "@parameterized.named_parameters(('beta_too_small', -1, 1, 0, [1.0]), ('beta_too_large', 1.1, 1, 0, [0.5]), ('negative_volvol', 0.5, -1, 0, [1.0]), ('rho_too_small', 0.5, 1, -2, [1.0]), ('rho_too_large', 0.5, 1, 2, [0.5]), ('times_not_increasing', 0.5, 1, 0, [2.0, 1.0]))\ndef test_sabr_model_validate_raises_error(self, beta, volvol, rho, times):\n    if False:\n        i = 10\n    'Test that the SABR model raises errors appropriately.'\n    dtype = np.float64\n    time_step = 0.1\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 1.0)\n    test_seed = 123\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, validate_args=True)\n        paths = self.evaluate(paths)",
            "@parameterized.named_parameters(('beta_too_small', -1, 1, 0, [1.0]), ('beta_too_large', 1.1, 1, 0, [0.5]), ('negative_volvol', 0.5, -1, 0, [1.0]), ('rho_too_small', 0.5, 1, -2, [1.0]), ('rho_too_large', 0.5, 1, 2, [0.5]), ('times_not_increasing', 0.5, 1, 0, [2.0, 1.0]))\ndef test_sabr_model_validate_raises_error(self, beta, volvol, rho, times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test that the SABR model raises errors appropriately.'\n    dtype = np.float64\n    time_step = 0.1\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 1.0)\n    test_seed = 123\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, validate_args=True)\n        paths = self.evaluate(paths)",
            "@parameterized.named_parameters(('beta_too_small', -1, 1, 0, [1.0]), ('beta_too_large', 1.1, 1, 0, [0.5]), ('negative_volvol', 0.5, -1, 0, [1.0]), ('rho_too_small', 0.5, 1, -2, [1.0]), ('rho_too_large', 0.5, 1, 2, [0.5]), ('times_not_increasing', 0.5, 1, 0, [2.0, 1.0]))\ndef test_sabr_model_validate_raises_error(self, beta, volvol, rho, times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test that the SABR model raises errors appropriately.'\n    dtype = np.float64\n    time_step = 0.1\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 1.0)\n    test_seed = 123\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, validate_args=True)\n        paths = self.evaluate(paths)",
            "@parameterized.named_parameters(('beta_too_small', -1, 1, 0, [1.0]), ('beta_too_large', 1.1, 1, 0, [0.5]), ('negative_volvol', 0.5, -1, 0, [1.0]), ('rho_too_small', 0.5, 1, -2, [1.0]), ('rho_too_large', 0.5, 1, 2, [0.5]), ('times_not_increasing', 0.5, 1, 0, [2.0, 1.0]))\ndef test_sabr_model_validate_raises_error(self, beta, volvol, rho, times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test that the SABR model raises errors appropriately.'\n    dtype = np.float64\n    time_step = 0.1\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 1.0)\n    test_seed = 123\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, validate_args=True)\n        paths = self.evaluate(paths)",
            "@parameterized.named_parameters(('beta_too_small', -1, 1, 0, [1.0]), ('beta_too_large', 1.1, 1, 0, [0.5]), ('negative_volvol', 0.5, -1, 0, [1.0]), ('rho_too_small', 0.5, 1, -2, [1.0]), ('rho_too_large', 0.5, 1, 2, [0.5]), ('times_not_increasing', 0.5, 1, 0, [2.0, 1.0]))\ndef test_sabr_model_validate_raises_error(self, beta, volvol, rho, times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test that the SABR model raises errors appropriately.'\n    dtype = np.float64\n    time_step = 0.1\n    num_samples = 10\n    (initial_forward, initial_volatility) = (1.0, 1.0)\n    test_seed = 123\n    with self.assertRaises(tf.errors.InvalidArgumentError):\n        process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, validate_args=True)\n        paths = self.evaluate(paths)"
        ]
    },
    {
        "func_name": "test_sabr_model_absorbing_boundary",
        "original": "def test_sabr_model_absorbing_boundary(self):\n    \"\"\"Test that the vol function gets zeroed out for absorbing boundary.\"\"\"\n    process = SabrModel(beta=lambda *args: tf.constant(0.5, dtype=tf.float64), volvol=1.0, rho=0.0, dtype=tf.float64, enable_unbiased_sampling=True)\n    vol_matrix = process.volatility_fn()(t=0.0, x=tf.constant([0.0, 1.0], dtype=tf.float64))\n    self.assertAllEqual(vol_matrix, tf.zeros([2, 2], dtype=tf.float64))",
        "mutated": [
            "def test_sabr_model_absorbing_boundary(self):\n    if False:\n        i = 10\n    'Test that the vol function gets zeroed out for absorbing boundary.'\n    process = SabrModel(beta=lambda *args: tf.constant(0.5, dtype=tf.float64), volvol=1.0, rho=0.0, dtype=tf.float64, enable_unbiased_sampling=True)\n    vol_matrix = process.volatility_fn()(t=0.0, x=tf.constant([0.0, 1.0], dtype=tf.float64))\n    self.assertAllEqual(vol_matrix, tf.zeros([2, 2], dtype=tf.float64))",
            "def test_sabr_model_absorbing_boundary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test that the vol function gets zeroed out for absorbing boundary.'\n    process = SabrModel(beta=lambda *args: tf.constant(0.5, dtype=tf.float64), volvol=1.0, rho=0.0, dtype=tf.float64, enable_unbiased_sampling=True)\n    vol_matrix = process.volatility_fn()(t=0.0, x=tf.constant([0.0, 1.0], dtype=tf.float64))\n    self.assertAllEqual(vol_matrix, tf.zeros([2, 2], dtype=tf.float64))",
            "def test_sabr_model_absorbing_boundary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test that the vol function gets zeroed out for absorbing boundary.'\n    process = SabrModel(beta=lambda *args: tf.constant(0.5, dtype=tf.float64), volvol=1.0, rho=0.0, dtype=tf.float64, enable_unbiased_sampling=True)\n    vol_matrix = process.volatility_fn()(t=0.0, x=tf.constant([0.0, 1.0], dtype=tf.float64))\n    self.assertAllEqual(vol_matrix, tf.zeros([2, 2], dtype=tf.float64))",
            "def test_sabr_model_absorbing_boundary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test that the vol function gets zeroed out for absorbing boundary.'\n    process = SabrModel(beta=lambda *args: tf.constant(0.5, dtype=tf.float64), volvol=1.0, rho=0.0, dtype=tf.float64, enable_unbiased_sampling=True)\n    vol_matrix = process.volatility_fn()(t=0.0, x=tf.constant([0.0, 1.0], dtype=tf.float64))\n    self.assertAllEqual(vol_matrix, tf.zeros([2, 2], dtype=tf.float64))",
            "def test_sabr_model_absorbing_boundary(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test that the vol function gets zeroed out for absorbing boundary.'\n    process = SabrModel(beta=lambda *args: tf.constant(0.5, dtype=tf.float64), volvol=1.0, rho=0.0, dtype=tf.float64, enable_unbiased_sampling=True)\n    vol_matrix = process.volatility_fn()(t=0.0, x=tf.constant([0.0, 1.0], dtype=tf.float64))\n    self.assertAllEqual(vol_matrix, tf.zeros([2, 2], dtype=tf.float64))"
        ]
    },
    {
        "func_name": "_vol_fn",
        "original": "def _vol_fn(t, x):\n    \"\"\"The volatility function for the SABR model.\"\"\"\n    del t\n    f = x[..., 0]\n    v = x[..., 1]\n    fb = f ** beta\n    m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n    m12 = v * fb * rho\n    m21 = tf.zeros_like(m11)\n    m22 = volvol * v\n    mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n    mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n    should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n    vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n    return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)",
        "mutated": [
            "def _vol_fn(t, x):\n    if False:\n        i = 10\n    'The volatility function for the SABR model.'\n    del t\n    f = x[..., 0]\n    v = x[..., 1]\n    fb = f ** beta\n    m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n    m12 = v * fb * rho\n    m21 = tf.zeros_like(m11)\n    m22 = volvol * v\n    mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n    mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n    should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n    vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n    return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)",
            "def _vol_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'The volatility function for the SABR model.'\n    del t\n    f = x[..., 0]\n    v = x[..., 1]\n    fb = f ** beta\n    m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n    m12 = v * fb * rho\n    m21 = tf.zeros_like(m11)\n    m22 = volvol * v\n    mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n    mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n    should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n    vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n    return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)",
            "def _vol_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'The volatility function for the SABR model.'\n    del t\n    f = x[..., 0]\n    v = x[..., 1]\n    fb = f ** beta\n    m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n    m12 = v * fb * rho\n    m21 = tf.zeros_like(m11)\n    m22 = volvol * v\n    mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n    mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n    should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n    vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n    return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)",
            "def _vol_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'The volatility function for the SABR model.'\n    del t\n    f = x[..., 0]\n    v = x[..., 1]\n    fb = f ** beta\n    m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n    m12 = v * fb * rho\n    m21 = tf.zeros_like(m11)\n    m22 = volvol * v\n    mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n    mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n    should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n    vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n    return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)",
            "def _vol_fn(t, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'The volatility function for the SABR model.'\n    del t\n    f = x[..., 0]\n    v = x[..., 1]\n    fb = f ** beta\n    m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n    m12 = v * fb * rho\n    m21 = tf.zeros_like(m11)\n    m22 = volvol * v\n    mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n    mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n    should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n    vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n    return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)"
        ]
    },
    {
        "func_name": "test_pricing_european_option",
        "original": "@parameterized.named_parameters(('initial_test_put', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put2', 0.5, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put3', 0.0, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_call', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12, False), ('reference_1_test_4', 0.4, 0.8, -0.6, 0.01, 0.07, [0.07], 0.4, False), ('ir_test_put1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 0.75), ('ir_test_put2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 2.51), ('ir_test_call1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 0.75, False), ('ir_test_call2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 2.51, False))\ndef test_pricing_european_option(self, beta, volvol, rho, time_step, initial_forward, strikes, initial_volatility, put_option=True):\n    \"\"\"Test that the SABR model computes the same price as the Euler method.\"\"\"\n    dtype = np.float64\n    times = [0.5]\n    num_samples = 10000\n    test_seed = [123, 124]\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    if put_option:\n        option_fn = lambda samples, strike: strike - samples\n    else:\n        option_fn = lambda samples, strike: samples - strike\n    drift_fn = lambda _, x: tf.zeros_like(x)\n\n    def _vol_fn(t, x):\n        \"\"\"The volatility function for the SABR model.\"\"\"\n        del t\n        f = x[..., 0]\n        v = x[..., 1]\n        fb = f ** beta\n        m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n        m12 = v * fb * rho\n        m21 = tf.zeros_like(m11)\n        m22 = volvol * v\n        mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n        mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n        should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n        vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n        return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)\n    euler_paths = euler_sampling.sample(dim=2, drift_fn=drift_fn, volatility_fn=_vol_fn, times=times, time_step=time_step, num_samples=num_samples, initial_state=[initial_forward, initial_volatility], random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=test_seed, dtype=dtype)\n    euler_paths = self.evaluate(euler_paths)\n    euler_samples = euler_paths[..., 0]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step * 10, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    samples = paths[..., 0]\n    for strike in strikes:\n        (euler_mean, euler_price) = (np.average(euler_samples), np.average(np.maximum(option_fn(euler_samples, strike), 0)))\n        (mean, price) = (np.average(samples), np.average(np.maximum(option_fn(samples, strike), 0)))\n        self.assertAllClose([euler_mean, euler_price], [mean, price], rtol=0.05, atol=0.05)",
        "mutated": [
            "@parameterized.named_parameters(('initial_test_put', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put2', 0.5, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put3', 0.0, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_call', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12, False), ('reference_1_test_4', 0.4, 0.8, -0.6, 0.01, 0.07, [0.07], 0.4, False), ('ir_test_put1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 0.75), ('ir_test_put2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 2.51), ('ir_test_call1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 0.75, False), ('ir_test_call2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 2.51, False))\ndef test_pricing_european_option(self, beta, volvol, rho, time_step, initial_forward, strikes, initial_volatility, put_option=True):\n    if False:\n        i = 10\n    'Test that the SABR model computes the same price as the Euler method.'\n    dtype = np.float64\n    times = [0.5]\n    num_samples = 10000\n    test_seed = [123, 124]\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    if put_option:\n        option_fn = lambda samples, strike: strike - samples\n    else:\n        option_fn = lambda samples, strike: samples - strike\n    drift_fn = lambda _, x: tf.zeros_like(x)\n\n    def _vol_fn(t, x):\n        \"\"\"The volatility function for the SABR model.\"\"\"\n        del t\n        f = x[..., 0]\n        v = x[..., 1]\n        fb = f ** beta\n        m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n        m12 = v * fb * rho\n        m21 = tf.zeros_like(m11)\n        m22 = volvol * v\n        mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n        mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n        should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n        vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n        return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)\n    euler_paths = euler_sampling.sample(dim=2, drift_fn=drift_fn, volatility_fn=_vol_fn, times=times, time_step=time_step, num_samples=num_samples, initial_state=[initial_forward, initial_volatility], random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=test_seed, dtype=dtype)\n    euler_paths = self.evaluate(euler_paths)\n    euler_samples = euler_paths[..., 0]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step * 10, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    samples = paths[..., 0]\n    for strike in strikes:\n        (euler_mean, euler_price) = (np.average(euler_samples), np.average(np.maximum(option_fn(euler_samples, strike), 0)))\n        (mean, price) = (np.average(samples), np.average(np.maximum(option_fn(samples, strike), 0)))\n        self.assertAllClose([euler_mean, euler_price], [mean, price], rtol=0.05, atol=0.05)",
            "@parameterized.named_parameters(('initial_test_put', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put2', 0.5, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put3', 0.0, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_call', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12, False), ('reference_1_test_4', 0.4, 0.8, -0.6, 0.01, 0.07, [0.07], 0.4, False), ('ir_test_put1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 0.75), ('ir_test_put2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 2.51), ('ir_test_call1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 0.75, False), ('ir_test_call2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 2.51, False))\ndef test_pricing_european_option(self, beta, volvol, rho, time_step, initial_forward, strikes, initial_volatility, put_option=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test that the SABR model computes the same price as the Euler method.'\n    dtype = np.float64\n    times = [0.5]\n    num_samples = 10000\n    test_seed = [123, 124]\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    if put_option:\n        option_fn = lambda samples, strike: strike - samples\n    else:\n        option_fn = lambda samples, strike: samples - strike\n    drift_fn = lambda _, x: tf.zeros_like(x)\n\n    def _vol_fn(t, x):\n        \"\"\"The volatility function for the SABR model.\"\"\"\n        del t\n        f = x[..., 0]\n        v = x[..., 1]\n        fb = f ** beta\n        m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n        m12 = v * fb * rho\n        m21 = tf.zeros_like(m11)\n        m22 = volvol * v\n        mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n        mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n        should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n        vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n        return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)\n    euler_paths = euler_sampling.sample(dim=2, drift_fn=drift_fn, volatility_fn=_vol_fn, times=times, time_step=time_step, num_samples=num_samples, initial_state=[initial_forward, initial_volatility], random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=test_seed, dtype=dtype)\n    euler_paths = self.evaluate(euler_paths)\n    euler_samples = euler_paths[..., 0]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step * 10, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    samples = paths[..., 0]\n    for strike in strikes:\n        (euler_mean, euler_price) = (np.average(euler_samples), np.average(np.maximum(option_fn(euler_samples, strike), 0)))\n        (mean, price) = (np.average(samples), np.average(np.maximum(option_fn(samples, strike), 0)))\n        self.assertAllClose([euler_mean, euler_price], [mean, price], rtol=0.05, atol=0.05)",
            "@parameterized.named_parameters(('initial_test_put', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put2', 0.5, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put3', 0.0, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_call', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12, False), ('reference_1_test_4', 0.4, 0.8, -0.6, 0.01, 0.07, [0.07], 0.4, False), ('ir_test_put1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 0.75), ('ir_test_put2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 2.51), ('ir_test_call1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 0.75, False), ('ir_test_call2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 2.51, False))\ndef test_pricing_european_option(self, beta, volvol, rho, time_step, initial_forward, strikes, initial_volatility, put_option=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test that the SABR model computes the same price as the Euler method.'\n    dtype = np.float64\n    times = [0.5]\n    num_samples = 10000\n    test_seed = [123, 124]\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    if put_option:\n        option_fn = lambda samples, strike: strike - samples\n    else:\n        option_fn = lambda samples, strike: samples - strike\n    drift_fn = lambda _, x: tf.zeros_like(x)\n\n    def _vol_fn(t, x):\n        \"\"\"The volatility function for the SABR model.\"\"\"\n        del t\n        f = x[..., 0]\n        v = x[..., 1]\n        fb = f ** beta\n        m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n        m12 = v * fb * rho\n        m21 = tf.zeros_like(m11)\n        m22 = volvol * v\n        mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n        mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n        should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n        vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n        return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)\n    euler_paths = euler_sampling.sample(dim=2, drift_fn=drift_fn, volatility_fn=_vol_fn, times=times, time_step=time_step, num_samples=num_samples, initial_state=[initial_forward, initial_volatility], random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=test_seed, dtype=dtype)\n    euler_paths = self.evaluate(euler_paths)\n    euler_samples = euler_paths[..., 0]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step * 10, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    samples = paths[..., 0]\n    for strike in strikes:\n        (euler_mean, euler_price) = (np.average(euler_samples), np.average(np.maximum(option_fn(euler_samples, strike), 0)))\n        (mean, price) = (np.average(samples), np.average(np.maximum(option_fn(samples, strike), 0)))\n        self.assertAllClose([euler_mean, euler_price], [mean, price], rtol=0.05, atol=0.05)",
            "@parameterized.named_parameters(('initial_test_put', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put2', 0.5, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put3', 0.0, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_call', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12, False), ('reference_1_test_4', 0.4, 0.8, -0.6, 0.01, 0.07, [0.07], 0.4, False), ('ir_test_put1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 0.75), ('ir_test_put2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 2.51), ('ir_test_call1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 0.75, False), ('ir_test_call2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 2.51, False))\ndef test_pricing_european_option(self, beta, volvol, rho, time_step, initial_forward, strikes, initial_volatility, put_option=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test that the SABR model computes the same price as the Euler method.'\n    dtype = np.float64\n    times = [0.5]\n    num_samples = 10000\n    test_seed = [123, 124]\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    if put_option:\n        option_fn = lambda samples, strike: strike - samples\n    else:\n        option_fn = lambda samples, strike: samples - strike\n    drift_fn = lambda _, x: tf.zeros_like(x)\n\n    def _vol_fn(t, x):\n        \"\"\"The volatility function for the SABR model.\"\"\"\n        del t\n        f = x[..., 0]\n        v = x[..., 1]\n        fb = f ** beta\n        m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n        m12 = v * fb * rho\n        m21 = tf.zeros_like(m11)\n        m22 = volvol * v\n        mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n        mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n        should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n        vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n        return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)\n    euler_paths = euler_sampling.sample(dim=2, drift_fn=drift_fn, volatility_fn=_vol_fn, times=times, time_step=time_step, num_samples=num_samples, initial_state=[initial_forward, initial_volatility], random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=test_seed, dtype=dtype)\n    euler_paths = self.evaluate(euler_paths)\n    euler_samples = euler_paths[..., 0]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step * 10, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    samples = paths[..., 0]\n    for strike in strikes:\n        (euler_mean, euler_price) = (np.average(euler_samples), np.average(np.maximum(option_fn(euler_samples, strike), 0)))\n        (mean, price) = (np.average(samples), np.average(np.maximum(option_fn(samples, strike), 0)))\n        self.assertAllClose([euler_mean, euler_price], [mean, price], rtol=0.05, atol=0.05)",
            "@parameterized.named_parameters(('initial_test_put', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put2', 0.5, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_put3', 0.0, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12), ('initial_test_call', 0.8, 1.0, 0.2, 0.01, 100.0, [100.0], 0.12, False), ('reference_1_test_4', 0.4, 0.8, -0.6, 0.01, 0.07, [0.07], 0.4, False), ('ir_test_put1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 0.75), ('ir_test_put2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.009, 0.005], 2.51), ('ir_test_call1', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 0.75, False), ('ir_test_call2', 0.8, 0.5, 0.2, 0.01, 0.01, [0.01, 0.015, 0.02], 2.51, False))\ndef test_pricing_european_option(self, beta, volvol, rho, time_step, initial_forward, strikes, initial_volatility, put_option=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test that the SABR model computes the same price as the Euler method.'\n    dtype = np.float64\n    times = [0.5]\n    num_samples = 10000\n    test_seed = [123, 124]\n    beta = tf.convert_to_tensor(beta, dtype=dtype)\n    volvol = tf.convert_to_tensor(volvol, dtype=dtype)\n    rho = tf.convert_to_tensor(rho, dtype=dtype)\n    if put_option:\n        option_fn = lambda samples, strike: strike - samples\n    else:\n        option_fn = lambda samples, strike: samples - strike\n    drift_fn = lambda _, x: tf.zeros_like(x)\n\n    def _vol_fn(t, x):\n        \"\"\"The volatility function for the SABR model.\"\"\"\n        del t\n        f = x[..., 0]\n        v = x[..., 1]\n        fb = f ** beta\n        m11 = v * fb * tf.math.sqrt(1 - tf.square(rho))\n        m12 = v * fb * rho\n        m21 = tf.zeros_like(m11)\n        m22 = volvol * v\n        mc1 = tf.concat([tf.expand_dims(m11, -1), tf.expand_dims(m21, -1)], -1)\n        mc2 = tf.concat([tf.expand_dims(m12, -1), tf.expand_dims(m22, -1)], -1)\n        should_be_zero = tf.expand_dims(tf.expand_dims((beta != 0) & (f <= 0.0), -1), -1)\n        vol_matrix = tf.concat([tf.expand_dims(mc1, -1), tf.expand_dims(mc2, -1)], -1)\n        return tf.where(should_be_zero, tf.zeros_like(vol_matrix), vol_matrix)\n    euler_paths = euler_sampling.sample(dim=2, drift_fn=drift_fn, volatility_fn=_vol_fn, times=times, time_step=time_step, num_samples=num_samples, initial_state=[initial_forward, initial_volatility], random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC, seed=test_seed, dtype=dtype)\n    euler_paths = self.evaluate(euler_paths)\n    euler_samples = euler_paths[..., 0]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step * 10, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    samples = paths[..., 0]\n    for strike in strikes:\n        (euler_mean, euler_price) = (np.average(euler_samples), np.average(np.maximum(option_fn(euler_samples, strike), 0)))\n        (mean, price) = (np.average(samples), np.average(np.maximum(option_fn(samples, strike), 0)))\n        self.assertAllClose([euler_mean, euler_price], [mean, price], rtol=0.05, atol=0.05)"
        ]
    },
    {
        "func_name": "test_relative_error",
        "original": "def test_relative_error(self):\n    \"\"\"Replicate tests from reference [1] test case 4.\"\"\"\n    dtype = np.float64\n    num_samples = 1000\n    test_seed = [123, 124]\n    initial_forward = tf.constant(0.07, dtype=dtype)\n    initial_volatility = tf.constant(0.4, dtype=dtype)\n    volvol = tf.constant(0.8, dtype=dtype)\n    beta = tf.constant(0.4, dtype=dtype)\n    rho = tf.constant(-0.6, dtype=dtype)\n    times = [1.0]\n    timesteps = [0.0625, 0.03125]\n    strike = 0.4\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    process_table = []\n    for ts in timesteps:\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=ts, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n        paths = self.evaluate(paths)\n        samples = paths[..., 0]\n        price = np.average(np.maximum(samples - strike, 0))\n        process_table.append(price)\n    euler_error = 0.0001681610489796333\n    process_error = 0\n    for i in range(0, len(timesteps) - 1):\n        process_error += np.abs(process_table[i] - process_table[i + 1])\n    self.assertLessEqual(process_error, euler_error)",
        "mutated": [
            "def test_relative_error(self):\n    if False:\n        i = 10\n    'Replicate tests from reference [1] test case 4.'\n    dtype = np.float64\n    num_samples = 1000\n    test_seed = [123, 124]\n    initial_forward = tf.constant(0.07, dtype=dtype)\n    initial_volatility = tf.constant(0.4, dtype=dtype)\n    volvol = tf.constant(0.8, dtype=dtype)\n    beta = tf.constant(0.4, dtype=dtype)\n    rho = tf.constant(-0.6, dtype=dtype)\n    times = [1.0]\n    timesteps = [0.0625, 0.03125]\n    strike = 0.4\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    process_table = []\n    for ts in timesteps:\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=ts, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n        paths = self.evaluate(paths)\n        samples = paths[..., 0]\n        price = np.average(np.maximum(samples - strike, 0))\n        process_table.append(price)\n    euler_error = 0.0001681610489796333\n    process_error = 0\n    for i in range(0, len(timesteps) - 1):\n        process_error += np.abs(process_table[i] - process_table[i + 1])\n    self.assertLessEqual(process_error, euler_error)",
            "def test_relative_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Replicate tests from reference [1] test case 4.'\n    dtype = np.float64\n    num_samples = 1000\n    test_seed = [123, 124]\n    initial_forward = tf.constant(0.07, dtype=dtype)\n    initial_volatility = tf.constant(0.4, dtype=dtype)\n    volvol = tf.constant(0.8, dtype=dtype)\n    beta = tf.constant(0.4, dtype=dtype)\n    rho = tf.constant(-0.6, dtype=dtype)\n    times = [1.0]\n    timesteps = [0.0625, 0.03125]\n    strike = 0.4\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    process_table = []\n    for ts in timesteps:\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=ts, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n        paths = self.evaluate(paths)\n        samples = paths[..., 0]\n        price = np.average(np.maximum(samples - strike, 0))\n        process_table.append(price)\n    euler_error = 0.0001681610489796333\n    process_error = 0\n    for i in range(0, len(timesteps) - 1):\n        process_error += np.abs(process_table[i] - process_table[i + 1])\n    self.assertLessEqual(process_error, euler_error)",
            "def test_relative_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Replicate tests from reference [1] test case 4.'\n    dtype = np.float64\n    num_samples = 1000\n    test_seed = [123, 124]\n    initial_forward = tf.constant(0.07, dtype=dtype)\n    initial_volatility = tf.constant(0.4, dtype=dtype)\n    volvol = tf.constant(0.8, dtype=dtype)\n    beta = tf.constant(0.4, dtype=dtype)\n    rho = tf.constant(-0.6, dtype=dtype)\n    times = [1.0]\n    timesteps = [0.0625, 0.03125]\n    strike = 0.4\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    process_table = []\n    for ts in timesteps:\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=ts, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n        paths = self.evaluate(paths)\n        samples = paths[..., 0]\n        price = np.average(np.maximum(samples - strike, 0))\n        process_table.append(price)\n    euler_error = 0.0001681610489796333\n    process_error = 0\n    for i in range(0, len(timesteps) - 1):\n        process_error += np.abs(process_table[i] - process_table[i + 1])\n    self.assertLessEqual(process_error, euler_error)",
            "def test_relative_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Replicate tests from reference [1] test case 4.'\n    dtype = np.float64\n    num_samples = 1000\n    test_seed = [123, 124]\n    initial_forward = tf.constant(0.07, dtype=dtype)\n    initial_volatility = tf.constant(0.4, dtype=dtype)\n    volvol = tf.constant(0.8, dtype=dtype)\n    beta = tf.constant(0.4, dtype=dtype)\n    rho = tf.constant(-0.6, dtype=dtype)\n    times = [1.0]\n    timesteps = [0.0625, 0.03125]\n    strike = 0.4\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    process_table = []\n    for ts in timesteps:\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=ts, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n        paths = self.evaluate(paths)\n        samples = paths[..., 0]\n        price = np.average(np.maximum(samples - strike, 0))\n        process_table.append(price)\n    euler_error = 0.0001681610489796333\n    process_error = 0\n    for i in range(0, len(timesteps) - 1):\n        process_error += np.abs(process_table[i] - process_table[i + 1])\n    self.assertLessEqual(process_error, euler_error)",
            "def test_relative_error(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Replicate tests from reference [1] test case 4.'\n    dtype = np.float64\n    num_samples = 1000\n    test_seed = [123, 124]\n    initial_forward = tf.constant(0.07, dtype=dtype)\n    initial_volatility = tf.constant(0.4, dtype=dtype)\n    volvol = tf.constant(0.8, dtype=dtype)\n    beta = tf.constant(0.4, dtype=dtype)\n    rho = tf.constant(-0.6, dtype=dtype)\n    times = [1.0]\n    timesteps = [0.0625, 0.03125]\n    strike = 0.4\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, enable_unbiased_sampling=True)\n    process_table = []\n    for ts in timesteps:\n        paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=ts, num_samples=num_samples, seed=test_seed, validate_args=True, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n        paths = self.evaluate(paths)\n        samples = paths[..., 0]\n        price = np.average(np.maximum(samples - strike, 0))\n        process_table.append(price)\n    euler_error = 0.0001681610489796333\n    process_error = 0\n    for i in range(0, len(timesteps) - 1):\n        process_error += np.abs(process_table[i] - process_table[i + 1])\n    self.assertLessEqual(process_error, euler_error)"
        ]
    },
    {
        "func_name": "test_forward_obeys_lower_bound",
        "original": "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1, 1.0, 0.1, True), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1, 1.0, 0.1, True), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0, True), ('correlated_process', 0.5, 1, 0.5, 0.1, 1.0, 0.0, True), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01, 1.0, 0.0, True), ('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, False))\ndef test_forward_obeys_lower_bound(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    \"\"\"Tests that the forwards obey the lower bound.\"\"\"\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    for i in range(len(times)):\n        forwards_slice = paths[:, i, forwards_axis]\n        self.assertTrue(np.all(forwards_slice >= -shift))",
        "mutated": [
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1, 1.0, 0.1, True), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1, 1.0, 0.1, True), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0, True), ('correlated_process', 0.5, 1, 0.5, 0.1, 1.0, 0.0, True), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01, 1.0, 0.0, True), ('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, False))\ndef test_forward_obeys_lower_bound(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n    'Tests that the forwards obey the lower bound.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    for i in range(len(times)):\n        forwards_slice = paths[:, i, forwards_axis]\n        self.assertTrue(np.all(forwards_slice >= -shift))",
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1, 1.0, 0.1, True), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1, 1.0, 0.1, True), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0, True), ('correlated_process', 0.5, 1, 0.5, 0.1, 1.0, 0.0, True), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01, 1.0, 0.0, True), ('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, False))\ndef test_forward_obeys_lower_bound(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that the forwards obey the lower bound.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    for i in range(len(times)):\n        forwards_slice = paths[:, i, forwards_axis]\n        self.assertTrue(np.all(forwards_slice >= -shift))",
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1, 1.0, 0.1, True), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1, 1.0, 0.1, True), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0, True), ('correlated_process', 0.5, 1, 0.5, 0.1, 1.0, 0.0, True), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01, 1.0, 0.0, True), ('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, False))\ndef test_forward_obeys_lower_bound(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that the forwards obey the lower bound.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    for i in range(len(times)):\n        forwards_slice = paths[:, i, forwards_axis]\n        self.assertTrue(np.all(forwards_slice >= -shift))",
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1, 1.0, 0.1, True), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1, 1.0, 0.1, True), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0, True), ('correlated_process', 0.5, 1, 0.5, 0.1, 1.0, 0.0, True), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01, 1.0, 0.0, True), ('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, False))\ndef test_forward_obeys_lower_bound(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that the forwards obey the lower bound.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    for i in range(len(times)):\n        forwards_slice = paths[:, i, forwards_axis]\n        self.assertTrue(np.all(forwards_slice >= -shift))",
            "@parameterized.named_parameters(('zero_beta', 0.0, 2.0, 0.0, 0.1, 1.0, 0.1, True), ('non_zero_beta', 0.5, 1.0, 0.0, 0.1, 1.0, 0.1, True), ('one_beta', 1.0, 0.5, 0.0, 0.1, 1.0, 1.0, True), ('correlated_process', 0.5, 1, 0.5, 0.1, 1.0, 0.0, True), ('fallback_to_euler', lambda *args: tf.constant(0.5, dtype=tf.float64), 1, 0.5, 0.01, 1.0, 0.0, True), ('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -2.0, 5.0, False))\ndef test_forward_obeys_lower_bound(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that the forwards obey the lower bound.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    for i in range(len(times)):\n        forwards_slice = paths[:, i, forwards_axis]\n        self.assertTrue(np.all(forwards_slice >= -shift))"
        ]
    },
    {
        "func_name": "test_negative_forward_rates_okay",
        "original": "@parameterized.named_parameters(('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, False))\ndef test_negative_forward_rates_okay(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    \"\"\"Tests that the forwards can potentially be negative.\"\"\"\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    forwards_slices = paths[:, :, forwards_axis]\n    self.assertTrue(np.any(forwards_slices < 0))",
        "mutated": [
            "@parameterized.named_parameters(('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, False))\ndef test_negative_forward_rates_okay(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n    'Tests that the forwards can potentially be negative.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    forwards_slices = paths[:, :, forwards_axis]\n    self.assertTrue(np.any(forwards_slices < 0))",
            "@parameterized.named_parameters(('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, False))\ndef test_negative_forward_rates_okay(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that the forwards can potentially be negative.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    forwards_slices = paths[:, :, forwards_axis]\n    self.assertTrue(np.any(forwards_slices < 0))",
            "@parameterized.named_parameters(('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, False))\ndef test_negative_forward_rates_okay(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that the forwards can potentially be negative.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    forwards_slices = paths[:, :, forwards_axis]\n    self.assertTrue(np.any(forwards_slices < 0))",
            "@parameterized.named_parameters(('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, False))\ndef test_negative_forward_rates_okay(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that the forwards can potentially be negative.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    forwards_slices = paths[:, :, forwards_axis]\n    self.assertTrue(np.any(forwards_slices < 0))",
            "@parameterized.named_parameters(('nonzero_shift_unbiased_sampling_true', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, True), ('nonzero_shift_unbiased_sampling_false', 0.5, 1.0, 0.0, 0.1, -1.0, 5.0, False))\ndef test_negative_forward_rates_okay(self, beta, volvol, rho, time_step, initial_forward, shift, enabled_unbiased_sampling, initial_volatility=0.1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that the forwards can potentially be negative.'\n    dtype = tf.float64\n    times = [0.1, 0.3, 0.5]\n    num_samples = 1000\n    test_seed = [123, 124]\n    process = SabrModel(beta=beta, volvol=volvol, rho=rho, dtype=dtype, shift=shift, enable_unbiased_sampling=enabled_unbiased_sampling)\n    paths = process.sample_paths(initial_forward=initial_forward, initial_volatility=initial_volatility, times=times, time_step=time_step, num_samples=num_samples, seed=test_seed, random_type=tff.math.random.RandomType.STATELESS_ANTITHETIC)\n    paths = self.evaluate(paths)\n    forwards_axis = 0\n    forwards_slices = paths[:, :, forwards_axis]\n    self.assertTrue(np.any(forwards_slices < 0))"
        ]
    }
]