[
    {
        "func_name": "construct_grids",
        "original": "def construct_grids(batch):\n    \"\"\"Construct the map grid from the batch object\n\n    Parameters\n    ----------\n    batch : Batch object\n        The object returned by :func:`fetch_species_distributions`\n\n    Returns\n    -------\n    (xgrid, ygrid) : 1-D arrays\n        The grid corresponding to the values in batch.coverages\n    \"\"\"\n    xmin = batch.x_left_lower_corner + batch.grid_size\n    xmax = xmin + batch.Nx * batch.grid_size\n    ymin = batch.y_left_lower_corner + batch.grid_size\n    ymax = ymin + batch.Ny * batch.grid_size\n    xgrid = np.arange(xmin, xmax, batch.grid_size)\n    ygrid = np.arange(ymin, ymax, batch.grid_size)\n    return (xgrid, ygrid)",
        "mutated": [
            "def construct_grids(batch):\n    if False:\n        i = 10\n    'Construct the map grid from the batch object\\n\\n    Parameters\\n    ----------\\n    batch : Batch object\\n        The object returned by :func:`fetch_species_distributions`\\n\\n    Returns\\n    -------\\n    (xgrid, ygrid) : 1-D arrays\\n        The grid corresponding to the values in batch.coverages\\n    '\n    xmin = batch.x_left_lower_corner + batch.grid_size\n    xmax = xmin + batch.Nx * batch.grid_size\n    ymin = batch.y_left_lower_corner + batch.grid_size\n    ymax = ymin + batch.Ny * batch.grid_size\n    xgrid = np.arange(xmin, xmax, batch.grid_size)\n    ygrid = np.arange(ymin, ymax, batch.grid_size)\n    return (xgrid, ygrid)",
            "def construct_grids(batch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Construct the map grid from the batch object\\n\\n    Parameters\\n    ----------\\n    batch : Batch object\\n        The object returned by :func:`fetch_species_distributions`\\n\\n    Returns\\n    -------\\n    (xgrid, ygrid) : 1-D arrays\\n        The grid corresponding to the values in batch.coverages\\n    '\n    xmin = batch.x_left_lower_corner + batch.grid_size\n    xmax = xmin + batch.Nx * batch.grid_size\n    ymin = batch.y_left_lower_corner + batch.grid_size\n    ymax = ymin + batch.Ny * batch.grid_size\n    xgrid = np.arange(xmin, xmax, batch.grid_size)\n    ygrid = np.arange(ymin, ymax, batch.grid_size)\n    return (xgrid, ygrid)",
            "def construct_grids(batch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Construct the map grid from the batch object\\n\\n    Parameters\\n    ----------\\n    batch : Batch object\\n        The object returned by :func:`fetch_species_distributions`\\n\\n    Returns\\n    -------\\n    (xgrid, ygrid) : 1-D arrays\\n        The grid corresponding to the values in batch.coverages\\n    '\n    xmin = batch.x_left_lower_corner + batch.grid_size\n    xmax = xmin + batch.Nx * batch.grid_size\n    ymin = batch.y_left_lower_corner + batch.grid_size\n    ymax = ymin + batch.Ny * batch.grid_size\n    xgrid = np.arange(xmin, xmax, batch.grid_size)\n    ygrid = np.arange(ymin, ymax, batch.grid_size)\n    return (xgrid, ygrid)",
            "def construct_grids(batch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Construct the map grid from the batch object\\n\\n    Parameters\\n    ----------\\n    batch : Batch object\\n        The object returned by :func:`fetch_species_distributions`\\n\\n    Returns\\n    -------\\n    (xgrid, ygrid) : 1-D arrays\\n        The grid corresponding to the values in batch.coverages\\n    '\n    xmin = batch.x_left_lower_corner + batch.grid_size\n    xmax = xmin + batch.Nx * batch.grid_size\n    ymin = batch.y_left_lower_corner + batch.grid_size\n    ymax = ymin + batch.Ny * batch.grid_size\n    xgrid = np.arange(xmin, xmax, batch.grid_size)\n    ygrid = np.arange(ymin, ymax, batch.grid_size)\n    return (xgrid, ygrid)",
            "def construct_grids(batch):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Construct the map grid from the batch object\\n\\n    Parameters\\n    ----------\\n    batch : Batch object\\n        The object returned by :func:`fetch_species_distributions`\\n\\n    Returns\\n    -------\\n    (xgrid, ygrid) : 1-D arrays\\n        The grid corresponding to the values in batch.coverages\\n    '\n    xmin = batch.x_left_lower_corner + batch.grid_size\n    xmax = xmin + batch.Nx * batch.grid_size\n    ymin = batch.y_left_lower_corner + batch.grid_size\n    ymax = ymin + batch.Ny * batch.grid_size\n    xgrid = np.arange(xmin, xmax, batch.grid_size)\n    ygrid = np.arange(ymin, ymax, batch.grid_size)\n    return (xgrid, ygrid)"
        ]
    },
    {
        "func_name": "create_species_bunch",
        "original": "def create_species_bunch(species_name, train, test, coverages, xgrid, ygrid):\n    \"\"\"Create a bunch with information about a particular organism\n\n    This will use the test/train record arrays to extract the\n    data specific to the given species name.\n    \"\"\"\n    bunch = Bunch(name=' '.join(species_name.split('_')[:2]))\n    species_name = species_name.encode('ascii')\n    points = dict(test=test, train=train)\n    for (label, pts) in points.items():\n        pts = pts[pts['species'] == species_name]\n        bunch['pts_%s' % label] = pts\n        ix = np.searchsorted(xgrid, pts['dd long'])\n        iy = np.searchsorted(ygrid, pts['dd lat'])\n        bunch['cov_%s' % label] = coverages[:, -iy, ix].T\n    return bunch",
        "mutated": [
            "def create_species_bunch(species_name, train, test, coverages, xgrid, ygrid):\n    if False:\n        i = 10\n    'Create a bunch with information about a particular organism\\n\\n    This will use the test/train record arrays to extract the\\n    data specific to the given species name.\\n    '\n    bunch = Bunch(name=' '.join(species_name.split('_')[:2]))\n    species_name = species_name.encode('ascii')\n    points = dict(test=test, train=train)\n    for (label, pts) in points.items():\n        pts = pts[pts['species'] == species_name]\n        bunch['pts_%s' % label] = pts\n        ix = np.searchsorted(xgrid, pts['dd long'])\n        iy = np.searchsorted(ygrid, pts['dd lat'])\n        bunch['cov_%s' % label] = coverages[:, -iy, ix].T\n    return bunch",
            "def create_species_bunch(species_name, train, test, coverages, xgrid, ygrid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create a bunch with information about a particular organism\\n\\n    This will use the test/train record arrays to extract the\\n    data specific to the given species name.\\n    '\n    bunch = Bunch(name=' '.join(species_name.split('_')[:2]))\n    species_name = species_name.encode('ascii')\n    points = dict(test=test, train=train)\n    for (label, pts) in points.items():\n        pts = pts[pts['species'] == species_name]\n        bunch['pts_%s' % label] = pts\n        ix = np.searchsorted(xgrid, pts['dd long'])\n        iy = np.searchsorted(ygrid, pts['dd lat'])\n        bunch['cov_%s' % label] = coverages[:, -iy, ix].T\n    return bunch",
            "def create_species_bunch(species_name, train, test, coverages, xgrid, ygrid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create a bunch with information about a particular organism\\n\\n    This will use the test/train record arrays to extract the\\n    data specific to the given species name.\\n    '\n    bunch = Bunch(name=' '.join(species_name.split('_')[:2]))\n    species_name = species_name.encode('ascii')\n    points = dict(test=test, train=train)\n    for (label, pts) in points.items():\n        pts = pts[pts['species'] == species_name]\n        bunch['pts_%s' % label] = pts\n        ix = np.searchsorted(xgrid, pts['dd long'])\n        iy = np.searchsorted(ygrid, pts['dd lat'])\n        bunch['cov_%s' % label] = coverages[:, -iy, ix].T\n    return bunch",
            "def create_species_bunch(species_name, train, test, coverages, xgrid, ygrid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create a bunch with information about a particular organism\\n\\n    This will use the test/train record arrays to extract the\\n    data specific to the given species name.\\n    '\n    bunch = Bunch(name=' '.join(species_name.split('_')[:2]))\n    species_name = species_name.encode('ascii')\n    points = dict(test=test, train=train)\n    for (label, pts) in points.items():\n        pts = pts[pts['species'] == species_name]\n        bunch['pts_%s' % label] = pts\n        ix = np.searchsorted(xgrid, pts['dd long'])\n        iy = np.searchsorted(ygrid, pts['dd lat'])\n        bunch['cov_%s' % label] = coverages[:, -iy, ix].T\n    return bunch",
            "def create_species_bunch(species_name, train, test, coverages, xgrid, ygrid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create a bunch with information about a particular organism\\n\\n    This will use the test/train record arrays to extract the\\n    data specific to the given species name.\\n    '\n    bunch = Bunch(name=' '.join(species_name.split('_')[:2]))\n    species_name = species_name.encode('ascii')\n    points = dict(test=test, train=train)\n    for (label, pts) in points.items():\n        pts = pts[pts['species'] == species_name]\n        bunch['pts_%s' % label] = pts\n        ix = np.searchsorted(xgrid, pts['dd long'])\n        iy = np.searchsorted(ygrid, pts['dd lat'])\n        bunch['cov_%s' % label] = coverages[:, -iy, ix].T\n    return bunch"
        ]
    },
    {
        "func_name": "plot_species_distribution",
        "original": "def plot_species_distribution(species=('bradypus_variegatus_0', 'microryzomys_minutus_0')):\n    \"\"\"\n    Plot the species distribution.\n    \"\"\"\n    if len(species) > 2:\n        print('Note: when more than two species are provided, only the first two will be used')\n    t0 = time()\n    data = fetch_species_distributions()\n    (xgrid, ygrid) = construct_grids(data)\n    (X, Y) = np.meshgrid(xgrid, ygrid[::-1])\n    BV_bunch = create_species_bunch(species[0], data.train, data.test, data.coverages, xgrid, ygrid)\n    MM_bunch = create_species_bunch(species[1], data.train, data.test, data.coverages, xgrid, ygrid)\n    np.random.seed(13)\n    background_points = np.c_[np.random.randint(low=0, high=data.Ny, size=10000), np.random.randint(low=0, high=data.Nx, size=10000)].T\n    land_reference = data.coverages[6]\n    for (i, species) in enumerate([BV_bunch, MM_bunch]):\n        print('_' * 80)\n        print(\"Modeling distribution of species '%s'\" % species.name)\n        mean = species.cov_train.mean(axis=0)\n        std = species.cov_train.std(axis=0)\n        train_cover_std = (species.cov_train - mean) / std\n        print(' - fit OneClassSVM ... ', end='')\n        clf = svm.OneClassSVM(nu=0.1, kernel='rbf', gamma=0.5)\n        clf.fit(train_cover_std)\n        print('done.')\n        plt.subplot(1, 2, i + 1)\n        if basemap:\n            print(' - plot coastlines using basemap')\n            m = Basemap(projection='cyl', llcrnrlat=Y.min(), urcrnrlat=Y.max(), llcrnrlon=X.min(), urcrnrlon=X.max(), resolution='c')\n            m.drawcoastlines()\n            m.drawcountries()\n        else:\n            print(' - plot coastlines from coverage')\n            plt.contour(X, Y, land_reference, levels=[-9998], colors='k', linestyles='solid')\n            plt.xticks([])\n            plt.yticks([])\n        print(' - predict species distribution')\n        Z = np.ones((data.Ny, data.Nx), dtype=np.float64)\n        idx = np.where(land_reference > -9999)\n        coverages_land = data.coverages[:, idx[0], idx[1]].T\n        pred = clf.decision_function((coverages_land - mean) / std)\n        Z *= pred.min()\n        Z[idx[0], idx[1]] = pred\n        levels = np.linspace(Z.min(), Z.max(), 25)\n        Z[land_reference == -9999] = -9999\n        plt.contourf(X, Y, Z, levels=levels, cmap=plt.cm.Reds)\n        plt.colorbar(format='%.2f')\n        plt.scatter(species.pts_train['dd long'], species.pts_train['dd lat'], s=2 ** 2, c='black', marker='^', label='train')\n        plt.scatter(species.pts_test['dd long'], species.pts_test['dd lat'], s=2 ** 2, c='black', marker='x', label='test')\n        plt.legend()\n        plt.title(species.name)\n        plt.axis('equal')\n        pred_background = Z[background_points[0], background_points[1]]\n        pred_test = clf.decision_function((species.cov_test - mean) / std)\n        scores = np.r_[pred_test, pred_background]\n        y = np.r_[np.ones(pred_test.shape), np.zeros(pred_background.shape)]\n        (fpr, tpr, thresholds) = metrics.roc_curve(y, scores)\n        roc_auc = metrics.auc(fpr, tpr)\n        plt.text(-35, -70, 'AUC: %.3f' % roc_auc, ha='right')\n        print('\\n Area under the ROC curve : %f' % roc_auc)\n    print('\\ntime elapsed: %.2fs' % (time() - t0))",
        "mutated": [
            "def plot_species_distribution(species=('bradypus_variegatus_0', 'microryzomys_minutus_0')):\n    if False:\n        i = 10\n    '\\n    Plot the species distribution.\\n    '\n    if len(species) > 2:\n        print('Note: when more than two species are provided, only the first two will be used')\n    t0 = time()\n    data = fetch_species_distributions()\n    (xgrid, ygrid) = construct_grids(data)\n    (X, Y) = np.meshgrid(xgrid, ygrid[::-1])\n    BV_bunch = create_species_bunch(species[0], data.train, data.test, data.coverages, xgrid, ygrid)\n    MM_bunch = create_species_bunch(species[1], data.train, data.test, data.coverages, xgrid, ygrid)\n    np.random.seed(13)\n    background_points = np.c_[np.random.randint(low=0, high=data.Ny, size=10000), np.random.randint(low=0, high=data.Nx, size=10000)].T\n    land_reference = data.coverages[6]\n    for (i, species) in enumerate([BV_bunch, MM_bunch]):\n        print('_' * 80)\n        print(\"Modeling distribution of species '%s'\" % species.name)\n        mean = species.cov_train.mean(axis=0)\n        std = species.cov_train.std(axis=0)\n        train_cover_std = (species.cov_train - mean) / std\n        print(' - fit OneClassSVM ... ', end='')\n        clf = svm.OneClassSVM(nu=0.1, kernel='rbf', gamma=0.5)\n        clf.fit(train_cover_std)\n        print('done.')\n        plt.subplot(1, 2, i + 1)\n        if basemap:\n            print(' - plot coastlines using basemap')\n            m = Basemap(projection='cyl', llcrnrlat=Y.min(), urcrnrlat=Y.max(), llcrnrlon=X.min(), urcrnrlon=X.max(), resolution='c')\n            m.drawcoastlines()\n            m.drawcountries()\n        else:\n            print(' - plot coastlines from coverage')\n            plt.contour(X, Y, land_reference, levels=[-9998], colors='k', linestyles='solid')\n            plt.xticks([])\n            plt.yticks([])\n        print(' - predict species distribution')\n        Z = np.ones((data.Ny, data.Nx), dtype=np.float64)\n        idx = np.where(land_reference > -9999)\n        coverages_land = data.coverages[:, idx[0], idx[1]].T\n        pred = clf.decision_function((coverages_land - mean) / std)\n        Z *= pred.min()\n        Z[idx[0], idx[1]] = pred\n        levels = np.linspace(Z.min(), Z.max(), 25)\n        Z[land_reference == -9999] = -9999\n        plt.contourf(X, Y, Z, levels=levels, cmap=plt.cm.Reds)\n        plt.colorbar(format='%.2f')\n        plt.scatter(species.pts_train['dd long'], species.pts_train['dd lat'], s=2 ** 2, c='black', marker='^', label='train')\n        plt.scatter(species.pts_test['dd long'], species.pts_test['dd lat'], s=2 ** 2, c='black', marker='x', label='test')\n        plt.legend()\n        plt.title(species.name)\n        plt.axis('equal')\n        pred_background = Z[background_points[0], background_points[1]]\n        pred_test = clf.decision_function((species.cov_test - mean) / std)\n        scores = np.r_[pred_test, pred_background]\n        y = np.r_[np.ones(pred_test.shape), np.zeros(pred_background.shape)]\n        (fpr, tpr, thresholds) = metrics.roc_curve(y, scores)\n        roc_auc = metrics.auc(fpr, tpr)\n        plt.text(-35, -70, 'AUC: %.3f' % roc_auc, ha='right')\n        print('\\n Area under the ROC curve : %f' % roc_auc)\n    print('\\ntime elapsed: %.2fs' % (time() - t0))",
            "def plot_species_distribution(species=('bradypus_variegatus_0', 'microryzomys_minutus_0')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Plot the species distribution.\\n    '\n    if len(species) > 2:\n        print('Note: when more than two species are provided, only the first two will be used')\n    t0 = time()\n    data = fetch_species_distributions()\n    (xgrid, ygrid) = construct_grids(data)\n    (X, Y) = np.meshgrid(xgrid, ygrid[::-1])\n    BV_bunch = create_species_bunch(species[0], data.train, data.test, data.coverages, xgrid, ygrid)\n    MM_bunch = create_species_bunch(species[1], data.train, data.test, data.coverages, xgrid, ygrid)\n    np.random.seed(13)\n    background_points = np.c_[np.random.randint(low=0, high=data.Ny, size=10000), np.random.randint(low=0, high=data.Nx, size=10000)].T\n    land_reference = data.coverages[6]\n    for (i, species) in enumerate([BV_bunch, MM_bunch]):\n        print('_' * 80)\n        print(\"Modeling distribution of species '%s'\" % species.name)\n        mean = species.cov_train.mean(axis=0)\n        std = species.cov_train.std(axis=0)\n        train_cover_std = (species.cov_train - mean) / std\n        print(' - fit OneClassSVM ... ', end='')\n        clf = svm.OneClassSVM(nu=0.1, kernel='rbf', gamma=0.5)\n        clf.fit(train_cover_std)\n        print('done.')\n        plt.subplot(1, 2, i + 1)\n        if basemap:\n            print(' - plot coastlines using basemap')\n            m = Basemap(projection='cyl', llcrnrlat=Y.min(), urcrnrlat=Y.max(), llcrnrlon=X.min(), urcrnrlon=X.max(), resolution='c')\n            m.drawcoastlines()\n            m.drawcountries()\n        else:\n            print(' - plot coastlines from coverage')\n            plt.contour(X, Y, land_reference, levels=[-9998], colors='k', linestyles='solid')\n            plt.xticks([])\n            plt.yticks([])\n        print(' - predict species distribution')\n        Z = np.ones((data.Ny, data.Nx), dtype=np.float64)\n        idx = np.where(land_reference > -9999)\n        coverages_land = data.coverages[:, idx[0], idx[1]].T\n        pred = clf.decision_function((coverages_land - mean) / std)\n        Z *= pred.min()\n        Z[idx[0], idx[1]] = pred\n        levels = np.linspace(Z.min(), Z.max(), 25)\n        Z[land_reference == -9999] = -9999\n        plt.contourf(X, Y, Z, levels=levels, cmap=plt.cm.Reds)\n        plt.colorbar(format='%.2f')\n        plt.scatter(species.pts_train['dd long'], species.pts_train['dd lat'], s=2 ** 2, c='black', marker='^', label='train')\n        plt.scatter(species.pts_test['dd long'], species.pts_test['dd lat'], s=2 ** 2, c='black', marker='x', label='test')\n        plt.legend()\n        plt.title(species.name)\n        plt.axis('equal')\n        pred_background = Z[background_points[0], background_points[1]]\n        pred_test = clf.decision_function((species.cov_test - mean) / std)\n        scores = np.r_[pred_test, pred_background]\n        y = np.r_[np.ones(pred_test.shape), np.zeros(pred_background.shape)]\n        (fpr, tpr, thresholds) = metrics.roc_curve(y, scores)\n        roc_auc = metrics.auc(fpr, tpr)\n        plt.text(-35, -70, 'AUC: %.3f' % roc_auc, ha='right')\n        print('\\n Area under the ROC curve : %f' % roc_auc)\n    print('\\ntime elapsed: %.2fs' % (time() - t0))",
            "def plot_species_distribution(species=('bradypus_variegatus_0', 'microryzomys_minutus_0')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Plot the species distribution.\\n    '\n    if len(species) > 2:\n        print('Note: when more than two species are provided, only the first two will be used')\n    t0 = time()\n    data = fetch_species_distributions()\n    (xgrid, ygrid) = construct_grids(data)\n    (X, Y) = np.meshgrid(xgrid, ygrid[::-1])\n    BV_bunch = create_species_bunch(species[0], data.train, data.test, data.coverages, xgrid, ygrid)\n    MM_bunch = create_species_bunch(species[1], data.train, data.test, data.coverages, xgrid, ygrid)\n    np.random.seed(13)\n    background_points = np.c_[np.random.randint(low=0, high=data.Ny, size=10000), np.random.randint(low=0, high=data.Nx, size=10000)].T\n    land_reference = data.coverages[6]\n    for (i, species) in enumerate([BV_bunch, MM_bunch]):\n        print('_' * 80)\n        print(\"Modeling distribution of species '%s'\" % species.name)\n        mean = species.cov_train.mean(axis=0)\n        std = species.cov_train.std(axis=0)\n        train_cover_std = (species.cov_train - mean) / std\n        print(' - fit OneClassSVM ... ', end='')\n        clf = svm.OneClassSVM(nu=0.1, kernel='rbf', gamma=0.5)\n        clf.fit(train_cover_std)\n        print('done.')\n        plt.subplot(1, 2, i + 1)\n        if basemap:\n            print(' - plot coastlines using basemap')\n            m = Basemap(projection='cyl', llcrnrlat=Y.min(), urcrnrlat=Y.max(), llcrnrlon=X.min(), urcrnrlon=X.max(), resolution='c')\n            m.drawcoastlines()\n            m.drawcountries()\n        else:\n            print(' - plot coastlines from coverage')\n            plt.contour(X, Y, land_reference, levels=[-9998], colors='k', linestyles='solid')\n            plt.xticks([])\n            plt.yticks([])\n        print(' - predict species distribution')\n        Z = np.ones((data.Ny, data.Nx), dtype=np.float64)\n        idx = np.where(land_reference > -9999)\n        coverages_land = data.coverages[:, idx[0], idx[1]].T\n        pred = clf.decision_function((coverages_land - mean) / std)\n        Z *= pred.min()\n        Z[idx[0], idx[1]] = pred\n        levels = np.linspace(Z.min(), Z.max(), 25)\n        Z[land_reference == -9999] = -9999\n        plt.contourf(X, Y, Z, levels=levels, cmap=plt.cm.Reds)\n        plt.colorbar(format='%.2f')\n        plt.scatter(species.pts_train['dd long'], species.pts_train['dd lat'], s=2 ** 2, c='black', marker='^', label='train')\n        plt.scatter(species.pts_test['dd long'], species.pts_test['dd lat'], s=2 ** 2, c='black', marker='x', label='test')\n        plt.legend()\n        plt.title(species.name)\n        plt.axis('equal')\n        pred_background = Z[background_points[0], background_points[1]]\n        pred_test = clf.decision_function((species.cov_test - mean) / std)\n        scores = np.r_[pred_test, pred_background]\n        y = np.r_[np.ones(pred_test.shape), np.zeros(pred_background.shape)]\n        (fpr, tpr, thresholds) = metrics.roc_curve(y, scores)\n        roc_auc = metrics.auc(fpr, tpr)\n        plt.text(-35, -70, 'AUC: %.3f' % roc_auc, ha='right')\n        print('\\n Area under the ROC curve : %f' % roc_auc)\n    print('\\ntime elapsed: %.2fs' % (time() - t0))",
            "def plot_species_distribution(species=('bradypus_variegatus_0', 'microryzomys_minutus_0')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Plot the species distribution.\\n    '\n    if len(species) > 2:\n        print('Note: when more than two species are provided, only the first two will be used')\n    t0 = time()\n    data = fetch_species_distributions()\n    (xgrid, ygrid) = construct_grids(data)\n    (X, Y) = np.meshgrid(xgrid, ygrid[::-1])\n    BV_bunch = create_species_bunch(species[0], data.train, data.test, data.coverages, xgrid, ygrid)\n    MM_bunch = create_species_bunch(species[1], data.train, data.test, data.coverages, xgrid, ygrid)\n    np.random.seed(13)\n    background_points = np.c_[np.random.randint(low=0, high=data.Ny, size=10000), np.random.randint(low=0, high=data.Nx, size=10000)].T\n    land_reference = data.coverages[6]\n    for (i, species) in enumerate([BV_bunch, MM_bunch]):\n        print('_' * 80)\n        print(\"Modeling distribution of species '%s'\" % species.name)\n        mean = species.cov_train.mean(axis=0)\n        std = species.cov_train.std(axis=0)\n        train_cover_std = (species.cov_train - mean) / std\n        print(' - fit OneClassSVM ... ', end='')\n        clf = svm.OneClassSVM(nu=0.1, kernel='rbf', gamma=0.5)\n        clf.fit(train_cover_std)\n        print('done.')\n        plt.subplot(1, 2, i + 1)\n        if basemap:\n            print(' - plot coastlines using basemap')\n            m = Basemap(projection='cyl', llcrnrlat=Y.min(), urcrnrlat=Y.max(), llcrnrlon=X.min(), urcrnrlon=X.max(), resolution='c')\n            m.drawcoastlines()\n            m.drawcountries()\n        else:\n            print(' - plot coastlines from coverage')\n            plt.contour(X, Y, land_reference, levels=[-9998], colors='k', linestyles='solid')\n            plt.xticks([])\n            plt.yticks([])\n        print(' - predict species distribution')\n        Z = np.ones((data.Ny, data.Nx), dtype=np.float64)\n        idx = np.where(land_reference > -9999)\n        coverages_land = data.coverages[:, idx[0], idx[1]].T\n        pred = clf.decision_function((coverages_land - mean) / std)\n        Z *= pred.min()\n        Z[idx[0], idx[1]] = pred\n        levels = np.linspace(Z.min(), Z.max(), 25)\n        Z[land_reference == -9999] = -9999\n        plt.contourf(X, Y, Z, levels=levels, cmap=plt.cm.Reds)\n        plt.colorbar(format='%.2f')\n        plt.scatter(species.pts_train['dd long'], species.pts_train['dd lat'], s=2 ** 2, c='black', marker='^', label='train')\n        plt.scatter(species.pts_test['dd long'], species.pts_test['dd lat'], s=2 ** 2, c='black', marker='x', label='test')\n        plt.legend()\n        plt.title(species.name)\n        plt.axis('equal')\n        pred_background = Z[background_points[0], background_points[1]]\n        pred_test = clf.decision_function((species.cov_test - mean) / std)\n        scores = np.r_[pred_test, pred_background]\n        y = np.r_[np.ones(pred_test.shape), np.zeros(pred_background.shape)]\n        (fpr, tpr, thresholds) = metrics.roc_curve(y, scores)\n        roc_auc = metrics.auc(fpr, tpr)\n        plt.text(-35, -70, 'AUC: %.3f' % roc_auc, ha='right')\n        print('\\n Area under the ROC curve : %f' % roc_auc)\n    print('\\ntime elapsed: %.2fs' % (time() - t0))",
            "def plot_species_distribution(species=('bradypus_variegatus_0', 'microryzomys_minutus_0')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Plot the species distribution.\\n    '\n    if len(species) > 2:\n        print('Note: when more than two species are provided, only the first two will be used')\n    t0 = time()\n    data = fetch_species_distributions()\n    (xgrid, ygrid) = construct_grids(data)\n    (X, Y) = np.meshgrid(xgrid, ygrid[::-1])\n    BV_bunch = create_species_bunch(species[0], data.train, data.test, data.coverages, xgrid, ygrid)\n    MM_bunch = create_species_bunch(species[1], data.train, data.test, data.coverages, xgrid, ygrid)\n    np.random.seed(13)\n    background_points = np.c_[np.random.randint(low=0, high=data.Ny, size=10000), np.random.randint(low=0, high=data.Nx, size=10000)].T\n    land_reference = data.coverages[6]\n    for (i, species) in enumerate([BV_bunch, MM_bunch]):\n        print('_' * 80)\n        print(\"Modeling distribution of species '%s'\" % species.name)\n        mean = species.cov_train.mean(axis=0)\n        std = species.cov_train.std(axis=0)\n        train_cover_std = (species.cov_train - mean) / std\n        print(' - fit OneClassSVM ... ', end='')\n        clf = svm.OneClassSVM(nu=0.1, kernel='rbf', gamma=0.5)\n        clf.fit(train_cover_std)\n        print('done.')\n        plt.subplot(1, 2, i + 1)\n        if basemap:\n            print(' - plot coastlines using basemap')\n            m = Basemap(projection='cyl', llcrnrlat=Y.min(), urcrnrlat=Y.max(), llcrnrlon=X.min(), urcrnrlon=X.max(), resolution='c')\n            m.drawcoastlines()\n            m.drawcountries()\n        else:\n            print(' - plot coastlines from coverage')\n            plt.contour(X, Y, land_reference, levels=[-9998], colors='k', linestyles='solid')\n            plt.xticks([])\n            plt.yticks([])\n        print(' - predict species distribution')\n        Z = np.ones((data.Ny, data.Nx), dtype=np.float64)\n        idx = np.where(land_reference > -9999)\n        coverages_land = data.coverages[:, idx[0], idx[1]].T\n        pred = clf.decision_function((coverages_land - mean) / std)\n        Z *= pred.min()\n        Z[idx[0], idx[1]] = pred\n        levels = np.linspace(Z.min(), Z.max(), 25)\n        Z[land_reference == -9999] = -9999\n        plt.contourf(X, Y, Z, levels=levels, cmap=plt.cm.Reds)\n        plt.colorbar(format='%.2f')\n        plt.scatter(species.pts_train['dd long'], species.pts_train['dd lat'], s=2 ** 2, c='black', marker='^', label='train')\n        plt.scatter(species.pts_test['dd long'], species.pts_test['dd lat'], s=2 ** 2, c='black', marker='x', label='test')\n        plt.legend()\n        plt.title(species.name)\n        plt.axis('equal')\n        pred_background = Z[background_points[0], background_points[1]]\n        pred_test = clf.decision_function((species.cov_test - mean) / std)\n        scores = np.r_[pred_test, pred_background]\n        y = np.r_[np.ones(pred_test.shape), np.zeros(pred_background.shape)]\n        (fpr, tpr, thresholds) = metrics.roc_curve(y, scores)\n        roc_auc = metrics.auc(fpr, tpr)\n        plt.text(-35, -70, 'AUC: %.3f' % roc_auc, ha='right')\n        print('\\n Area under the ROC curve : %f' % roc_auc)\n    print('\\ntime elapsed: %.2fs' % (time() - t0))"
        ]
    }
]