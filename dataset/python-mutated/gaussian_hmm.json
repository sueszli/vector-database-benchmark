[
    {
        "func_name": "__init__",
        "original": "def __init__(self, initial_proba, transition_proba, means, covs):\n    \"\"\"\n        construct hidden markov model with Gaussian emission model\n\n        Parameters\n        ----------\n        initial_proba : (n_hidden,) np.ndarray or None\n            probability of initial states\n        transition_proba : (n_hidden, n_hidden) np.ndarray or None\n            transition probability matrix\n            (i, j) component denotes the transition probability from i-th to j-th hidden state\n        means : (n_hidden, ndim) np.ndarray\n            mean of each gaussian component\n        covs : (n_hidden, ndim, ndim) np.ndarray\n            covariance matrix of each gaussian component\n\n        Attributes\n        ----------\n        ndim : int\n            dimensionality of observation space\n        n_hidden : int\n            number of hidden states\n        \"\"\"\n    assert initial_proba.size == transition_proba.shape[0] == transition_proba.shape[1] == means.shape[0] == covs.shape[0]\n    assert means.shape[1] == covs.shape[1] == covs.shape[2]\n    super().__init__(initial_proba, transition_proba)\n    self.ndim = means.shape[1]\n    self.means = means\n    self.covs = covs\n    self.precisions = np.linalg.inv(self.covs)\n    self.gaussians = [MultivariateGaussian(m, cov) for (m, cov) in zip(means, covs)]",
        "mutated": [
            "def __init__(self, initial_proba, transition_proba, means, covs):\n    if False:\n        i = 10\n    '\\n        construct hidden markov model with Gaussian emission model\\n\\n        Parameters\\n        ----------\\n        initial_proba : (n_hidden,) np.ndarray or None\\n            probability of initial states\\n        transition_proba : (n_hidden, n_hidden) np.ndarray or None\\n            transition probability matrix\\n            (i, j) component denotes the transition probability from i-th to j-th hidden state\\n        means : (n_hidden, ndim) np.ndarray\\n            mean of each gaussian component\\n        covs : (n_hidden, ndim, ndim) np.ndarray\\n            covariance matrix of each gaussian component\\n\\n        Attributes\\n        ----------\\n        ndim : int\\n            dimensionality of observation space\\n        n_hidden : int\\n            number of hidden states\\n        '\n    assert initial_proba.size == transition_proba.shape[0] == transition_proba.shape[1] == means.shape[0] == covs.shape[0]\n    assert means.shape[1] == covs.shape[1] == covs.shape[2]\n    super().__init__(initial_proba, transition_proba)\n    self.ndim = means.shape[1]\n    self.means = means\n    self.covs = covs\n    self.precisions = np.linalg.inv(self.covs)\n    self.gaussians = [MultivariateGaussian(m, cov) for (m, cov) in zip(means, covs)]",
            "def __init__(self, initial_proba, transition_proba, means, covs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        construct hidden markov model with Gaussian emission model\\n\\n        Parameters\\n        ----------\\n        initial_proba : (n_hidden,) np.ndarray or None\\n            probability of initial states\\n        transition_proba : (n_hidden, n_hidden) np.ndarray or None\\n            transition probability matrix\\n            (i, j) component denotes the transition probability from i-th to j-th hidden state\\n        means : (n_hidden, ndim) np.ndarray\\n            mean of each gaussian component\\n        covs : (n_hidden, ndim, ndim) np.ndarray\\n            covariance matrix of each gaussian component\\n\\n        Attributes\\n        ----------\\n        ndim : int\\n            dimensionality of observation space\\n        n_hidden : int\\n            number of hidden states\\n        '\n    assert initial_proba.size == transition_proba.shape[0] == transition_proba.shape[1] == means.shape[0] == covs.shape[0]\n    assert means.shape[1] == covs.shape[1] == covs.shape[2]\n    super().__init__(initial_proba, transition_proba)\n    self.ndim = means.shape[1]\n    self.means = means\n    self.covs = covs\n    self.precisions = np.linalg.inv(self.covs)\n    self.gaussians = [MultivariateGaussian(m, cov) for (m, cov) in zip(means, covs)]",
            "def __init__(self, initial_proba, transition_proba, means, covs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        construct hidden markov model with Gaussian emission model\\n\\n        Parameters\\n        ----------\\n        initial_proba : (n_hidden,) np.ndarray or None\\n            probability of initial states\\n        transition_proba : (n_hidden, n_hidden) np.ndarray or None\\n            transition probability matrix\\n            (i, j) component denotes the transition probability from i-th to j-th hidden state\\n        means : (n_hidden, ndim) np.ndarray\\n            mean of each gaussian component\\n        covs : (n_hidden, ndim, ndim) np.ndarray\\n            covariance matrix of each gaussian component\\n\\n        Attributes\\n        ----------\\n        ndim : int\\n            dimensionality of observation space\\n        n_hidden : int\\n            number of hidden states\\n        '\n    assert initial_proba.size == transition_proba.shape[0] == transition_proba.shape[1] == means.shape[0] == covs.shape[0]\n    assert means.shape[1] == covs.shape[1] == covs.shape[2]\n    super().__init__(initial_proba, transition_proba)\n    self.ndim = means.shape[1]\n    self.means = means\n    self.covs = covs\n    self.precisions = np.linalg.inv(self.covs)\n    self.gaussians = [MultivariateGaussian(m, cov) for (m, cov) in zip(means, covs)]",
            "def __init__(self, initial_proba, transition_proba, means, covs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        construct hidden markov model with Gaussian emission model\\n\\n        Parameters\\n        ----------\\n        initial_proba : (n_hidden,) np.ndarray or None\\n            probability of initial states\\n        transition_proba : (n_hidden, n_hidden) np.ndarray or None\\n            transition probability matrix\\n            (i, j) component denotes the transition probability from i-th to j-th hidden state\\n        means : (n_hidden, ndim) np.ndarray\\n            mean of each gaussian component\\n        covs : (n_hidden, ndim, ndim) np.ndarray\\n            covariance matrix of each gaussian component\\n\\n        Attributes\\n        ----------\\n        ndim : int\\n            dimensionality of observation space\\n        n_hidden : int\\n            number of hidden states\\n        '\n    assert initial_proba.size == transition_proba.shape[0] == transition_proba.shape[1] == means.shape[0] == covs.shape[0]\n    assert means.shape[1] == covs.shape[1] == covs.shape[2]\n    super().__init__(initial_proba, transition_proba)\n    self.ndim = means.shape[1]\n    self.means = means\n    self.covs = covs\n    self.precisions = np.linalg.inv(self.covs)\n    self.gaussians = [MultivariateGaussian(m, cov) for (m, cov) in zip(means, covs)]",
            "def __init__(self, initial_proba, transition_proba, means, covs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        construct hidden markov model with Gaussian emission model\\n\\n        Parameters\\n        ----------\\n        initial_proba : (n_hidden,) np.ndarray or None\\n            probability of initial states\\n        transition_proba : (n_hidden, n_hidden) np.ndarray or None\\n            transition probability matrix\\n            (i, j) component denotes the transition probability from i-th to j-th hidden state\\n        means : (n_hidden, ndim) np.ndarray\\n            mean of each gaussian component\\n        covs : (n_hidden, ndim, ndim) np.ndarray\\n            covariance matrix of each gaussian component\\n\\n        Attributes\\n        ----------\\n        ndim : int\\n            dimensionality of observation space\\n        n_hidden : int\\n            number of hidden states\\n        '\n    assert initial_proba.size == transition_proba.shape[0] == transition_proba.shape[1] == means.shape[0] == covs.shape[0]\n    assert means.shape[1] == covs.shape[1] == covs.shape[2]\n    super().__init__(initial_proba, transition_proba)\n    self.ndim = means.shape[1]\n    self.means = means\n    self.covs = covs\n    self.precisions = np.linalg.inv(self.covs)\n    self.gaussians = [MultivariateGaussian(m, cov) for (m, cov) in zip(means, covs)]"
        ]
    },
    {
        "func_name": "draw",
        "original": "def draw(self, n=100):\n    \"\"\"\n        draw random sequence from this model\n\n        Parameters\n        ----------\n        n : int\n            length of the random sequence\n\n        Returns\n        -------\n        seq : (n, ndim) np.ndarray\n            generated random sequence\n        \"\"\"\n    hidden_state = np.random.choice(self.n_hidden, p=self.initial_proba)\n    seq = []\n    while len(seq) < n:\n        seq.extend(self.gaussians[hidden_state].draw())\n        hidden_state = np.random.choice(self.n_hidden, p=self.transition_proba[hidden_state])\n    return np.asarray(seq)",
        "mutated": [
            "def draw(self, n=100):\n    if False:\n        i = 10\n    '\\n        draw random sequence from this model\\n\\n        Parameters\\n        ----------\\n        n : int\\n            length of the random sequence\\n\\n        Returns\\n        -------\\n        seq : (n, ndim) np.ndarray\\n            generated random sequence\\n        '\n    hidden_state = np.random.choice(self.n_hidden, p=self.initial_proba)\n    seq = []\n    while len(seq) < n:\n        seq.extend(self.gaussians[hidden_state].draw())\n        hidden_state = np.random.choice(self.n_hidden, p=self.transition_proba[hidden_state])\n    return np.asarray(seq)",
            "def draw(self, n=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        draw random sequence from this model\\n\\n        Parameters\\n        ----------\\n        n : int\\n            length of the random sequence\\n\\n        Returns\\n        -------\\n        seq : (n, ndim) np.ndarray\\n            generated random sequence\\n        '\n    hidden_state = np.random.choice(self.n_hidden, p=self.initial_proba)\n    seq = []\n    while len(seq) < n:\n        seq.extend(self.gaussians[hidden_state].draw())\n        hidden_state = np.random.choice(self.n_hidden, p=self.transition_proba[hidden_state])\n    return np.asarray(seq)",
            "def draw(self, n=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        draw random sequence from this model\\n\\n        Parameters\\n        ----------\\n        n : int\\n            length of the random sequence\\n\\n        Returns\\n        -------\\n        seq : (n, ndim) np.ndarray\\n            generated random sequence\\n        '\n    hidden_state = np.random.choice(self.n_hidden, p=self.initial_proba)\n    seq = []\n    while len(seq) < n:\n        seq.extend(self.gaussians[hidden_state].draw())\n        hidden_state = np.random.choice(self.n_hidden, p=self.transition_proba[hidden_state])\n    return np.asarray(seq)",
            "def draw(self, n=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        draw random sequence from this model\\n\\n        Parameters\\n        ----------\\n        n : int\\n            length of the random sequence\\n\\n        Returns\\n        -------\\n        seq : (n, ndim) np.ndarray\\n            generated random sequence\\n        '\n    hidden_state = np.random.choice(self.n_hidden, p=self.initial_proba)\n    seq = []\n    while len(seq) < n:\n        seq.extend(self.gaussians[hidden_state].draw())\n        hidden_state = np.random.choice(self.n_hidden, p=self.transition_proba[hidden_state])\n    return np.asarray(seq)",
            "def draw(self, n=100):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        draw random sequence from this model\\n\\n        Parameters\\n        ----------\\n        n : int\\n            length of the random sequence\\n\\n        Returns\\n        -------\\n        seq : (n, ndim) np.ndarray\\n            generated random sequence\\n        '\n    hidden_state = np.random.choice(self.n_hidden, p=self.initial_proba)\n    seq = []\n    while len(seq) < n:\n        seq.extend(self.gaussians[hidden_state].draw())\n        hidden_state = np.random.choice(self.n_hidden, p=self.transition_proba[hidden_state])\n    return np.asarray(seq)"
        ]
    },
    {
        "func_name": "likelihood",
        "original": "def likelihood(self, X):\n    diff = X[:, None, :] - self.means\n    exponents = np.sum(np.einsum('nki,kij->nkj', diff, self.precisions) * diff, axis=-1)\n    return np.exp(-0.5 * exponents) / np.sqrt(np.linalg.det(self.covs) * (2 * np.pi) ** self.ndim)",
        "mutated": [
            "def likelihood(self, X):\n    if False:\n        i = 10\n    diff = X[:, None, :] - self.means\n    exponents = np.sum(np.einsum('nki,kij->nkj', diff, self.precisions) * diff, axis=-1)\n    return np.exp(-0.5 * exponents) / np.sqrt(np.linalg.det(self.covs) * (2 * np.pi) ** self.ndim)",
            "def likelihood(self, X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    diff = X[:, None, :] - self.means\n    exponents = np.sum(np.einsum('nki,kij->nkj', diff, self.precisions) * diff, axis=-1)\n    return np.exp(-0.5 * exponents) / np.sqrt(np.linalg.det(self.covs) * (2 * np.pi) ** self.ndim)",
            "def likelihood(self, X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    diff = X[:, None, :] - self.means\n    exponents = np.sum(np.einsum('nki,kij->nkj', diff, self.precisions) * diff, axis=-1)\n    return np.exp(-0.5 * exponents) / np.sqrt(np.linalg.det(self.covs) * (2 * np.pi) ** self.ndim)",
            "def likelihood(self, X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    diff = X[:, None, :] - self.means\n    exponents = np.sum(np.einsum('nki,kij->nkj', diff, self.precisions) * diff, axis=-1)\n    return np.exp(-0.5 * exponents) / np.sqrt(np.linalg.det(self.covs) * (2 * np.pi) ** self.ndim)",
            "def likelihood(self, X):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    diff = X[:, None, :] - self.means\n    exponents = np.sum(np.einsum('nki,kij->nkj', diff, self.precisions) * diff, axis=-1)\n    return np.exp(-0.5 * exponents) / np.sqrt(np.linalg.det(self.covs) * (2 * np.pi) ** self.ndim)"
        ]
    },
    {
        "func_name": "maximize",
        "original": "def maximize(self, seq, p_hidden, p_transition):\n    self.initial_proba = p_hidden[0] / np.sum(p_hidden[0])\n    self.transition_proba = np.sum(p_transition, axis=0) / np.sum(p_transition, axis=(0, 2))\n    Nk = np.sum(p_hidden, axis=0)\n    self.means = (seq.T @ p_hidden / Nk).T\n    diffs = seq[:, None, :] - self.means\n    self.covs = np.einsum('nki,nkj->kij', diffs, diffs * p_hidden[:, :, None]) / Nk[:, None, None]",
        "mutated": [
            "def maximize(self, seq, p_hidden, p_transition):\n    if False:\n        i = 10\n    self.initial_proba = p_hidden[0] / np.sum(p_hidden[0])\n    self.transition_proba = np.sum(p_transition, axis=0) / np.sum(p_transition, axis=(0, 2))\n    Nk = np.sum(p_hidden, axis=0)\n    self.means = (seq.T @ p_hidden / Nk).T\n    diffs = seq[:, None, :] - self.means\n    self.covs = np.einsum('nki,nkj->kij', diffs, diffs * p_hidden[:, :, None]) / Nk[:, None, None]",
            "def maximize(self, seq, p_hidden, p_transition):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.initial_proba = p_hidden[0] / np.sum(p_hidden[0])\n    self.transition_proba = np.sum(p_transition, axis=0) / np.sum(p_transition, axis=(0, 2))\n    Nk = np.sum(p_hidden, axis=0)\n    self.means = (seq.T @ p_hidden / Nk).T\n    diffs = seq[:, None, :] - self.means\n    self.covs = np.einsum('nki,nkj->kij', diffs, diffs * p_hidden[:, :, None]) / Nk[:, None, None]",
            "def maximize(self, seq, p_hidden, p_transition):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.initial_proba = p_hidden[0] / np.sum(p_hidden[0])\n    self.transition_proba = np.sum(p_transition, axis=0) / np.sum(p_transition, axis=(0, 2))\n    Nk = np.sum(p_hidden, axis=0)\n    self.means = (seq.T @ p_hidden / Nk).T\n    diffs = seq[:, None, :] - self.means\n    self.covs = np.einsum('nki,nkj->kij', diffs, diffs * p_hidden[:, :, None]) / Nk[:, None, None]",
            "def maximize(self, seq, p_hidden, p_transition):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.initial_proba = p_hidden[0] / np.sum(p_hidden[0])\n    self.transition_proba = np.sum(p_transition, axis=0) / np.sum(p_transition, axis=(0, 2))\n    Nk = np.sum(p_hidden, axis=0)\n    self.means = (seq.T @ p_hidden / Nk).T\n    diffs = seq[:, None, :] - self.means\n    self.covs = np.einsum('nki,nkj->kij', diffs, diffs * p_hidden[:, :, None]) / Nk[:, None, None]",
            "def maximize(self, seq, p_hidden, p_transition):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.initial_proba = p_hidden[0] / np.sum(p_hidden[0])\n    self.transition_proba = np.sum(p_transition, axis=0) / np.sum(p_transition, axis=(0, 2))\n    Nk = np.sum(p_hidden, axis=0)\n    self.means = (seq.T @ p_hidden / Nk).T\n    diffs = seq[:, None, :] - self.means\n    self.covs = np.einsum('nki,nkj->kij', diffs, diffs * p_hidden[:, :, None]) / Nk[:, None, None]"
        ]
    }
]