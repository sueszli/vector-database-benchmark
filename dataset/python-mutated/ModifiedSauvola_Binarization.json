[
    {
        "func_name": "SauvolaModBinarization",
        "original": "def SauvolaModBinarization(image, n1=51, n2=51, k1=0.3, k2=0.3, default=True):\n    \"\"\"\n\t Binarization using Sauvola's algorithm\n\t\t@name : SauvolaModBinarization\n\t parameters\n\t\t@param image (numpy array of shape (3/1) of type np.uint8): color or gray scale image\n\t optional parameters\n\t\t@param n1 (int) : window size for running sauvola during the first pass\n\t\t@param n2 (int): window size for running sauvola during the second pass\n\t\t@param k1 (float): k value corresponding to sauvola during the first pass\n\t\t@param k2 (float): k value corresponding to sauvola during the second pass\n\t\t@param default (bool) : bollean variable to set the above parameter as default. \n\n\t\t\t@param default is set to True : thus default values of the above optional parameters (n1,n2,k1,k2) are set to\n\t\t\t\tn1 = 5 % of min(image height, image width)\n\t\t\t\tn2 = 10 % of min(image height, image width)\n\t\t\t\tk1 = 0.5\n\t\t\t\tk2 = 0.5\n\t\tReturns\n\t\t\t@return A binary image of same size as @param image\n\t\t\n\t\t@cite https://drive.google.com/file/d/1D3CyI5vtodPJeZaD2UV5wdcaIMtkBbdZ/view?usp=sharing\n    \"\"\"\n    if default:\n        n1 = int(0.05 * min(image.shape[0], image.shape[1]))\n        if n1 % 2 == 0:\n            n1 = n1 + 1\n        n2 = int(0.1 * min(image.shape[0], image.shape[1]))\n        if n2 % 2 == 0:\n            n2 = n2 + 1\n        k1 = 0.5\n        k2 = 0.5\n    if image.ndim == 3:\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = np.copy(image)\n    T1 = threshold_sauvola(gray, window_size=n1, k=k1)\n    max_val = np.amax(gray)\n    min_val = np.amin(gray)\n    C = np.copy(T1)\n    C = C.astype(np.float32)\n    C[gray > T1] = (gray[gray > T1] - T1[gray > T1]) / (max_val - T1[gray > T1])\n    C[gray <= T1] = 0\n    C = C * 255.0\n    new_in = np.copy(C.astype(np.uint8))\n    T2 = threshold_sauvola(new_in, window_size=n2, k=k2)\n    binary = np.copy(gray)\n    binary[new_in <= T2] = 0\n    binary[new_in > T2] = 255\n    return binary",
        "mutated": [
            "def SauvolaModBinarization(image, n1=51, n2=51, k1=0.3, k2=0.3, default=True):\n    if False:\n        i = 10\n    \"\\n\\t Binarization using Sauvola's algorithm\\n\\t\\t@name : SauvolaModBinarization\\n\\t parameters\\n\\t\\t@param image (numpy array of shape (3/1) of type np.uint8): color or gray scale image\\n\\t optional parameters\\n\\t\\t@param n1 (int) : window size for running sauvola during the first pass\\n\\t\\t@param n2 (int): window size for running sauvola during the second pass\\n\\t\\t@param k1 (float): k value corresponding to sauvola during the first pass\\n\\t\\t@param k2 (float): k value corresponding to sauvola during the second pass\\n\\t\\t@param default (bool) : bollean variable to set the above parameter as default. \\n\\n\\t\\t\\t@param default is set to True : thus default values of the above optional parameters (n1,n2,k1,k2) are set to\\n\\t\\t\\t\\tn1 = 5 % of min(image height, image width)\\n\\t\\t\\t\\tn2 = 10 % of min(image height, image width)\\n\\t\\t\\t\\tk1 = 0.5\\n\\t\\t\\t\\tk2 = 0.5\\n\\t\\tReturns\\n\\t\\t\\t@return A binary image of same size as @param image\\n\\t\\t\\n\\t\\t@cite https://drive.google.com/file/d/1D3CyI5vtodPJeZaD2UV5wdcaIMtkBbdZ/view?usp=sharing\\n    \"\n    if default:\n        n1 = int(0.05 * min(image.shape[0], image.shape[1]))\n        if n1 % 2 == 0:\n            n1 = n1 + 1\n        n2 = int(0.1 * min(image.shape[0], image.shape[1]))\n        if n2 % 2 == 0:\n            n2 = n2 + 1\n        k1 = 0.5\n        k2 = 0.5\n    if image.ndim == 3:\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = np.copy(image)\n    T1 = threshold_sauvola(gray, window_size=n1, k=k1)\n    max_val = np.amax(gray)\n    min_val = np.amin(gray)\n    C = np.copy(T1)\n    C = C.astype(np.float32)\n    C[gray > T1] = (gray[gray > T1] - T1[gray > T1]) / (max_val - T1[gray > T1])\n    C[gray <= T1] = 0\n    C = C * 255.0\n    new_in = np.copy(C.astype(np.uint8))\n    T2 = threshold_sauvola(new_in, window_size=n2, k=k2)\n    binary = np.copy(gray)\n    binary[new_in <= T2] = 0\n    binary[new_in > T2] = 255\n    return binary",
            "def SauvolaModBinarization(image, n1=51, n2=51, k1=0.3, k2=0.3, default=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n\\t Binarization using Sauvola's algorithm\\n\\t\\t@name : SauvolaModBinarization\\n\\t parameters\\n\\t\\t@param image (numpy array of shape (3/1) of type np.uint8): color or gray scale image\\n\\t optional parameters\\n\\t\\t@param n1 (int) : window size for running sauvola during the first pass\\n\\t\\t@param n2 (int): window size for running sauvola during the second pass\\n\\t\\t@param k1 (float): k value corresponding to sauvola during the first pass\\n\\t\\t@param k2 (float): k value corresponding to sauvola during the second pass\\n\\t\\t@param default (bool) : bollean variable to set the above parameter as default. \\n\\n\\t\\t\\t@param default is set to True : thus default values of the above optional parameters (n1,n2,k1,k2) are set to\\n\\t\\t\\t\\tn1 = 5 % of min(image height, image width)\\n\\t\\t\\t\\tn2 = 10 % of min(image height, image width)\\n\\t\\t\\t\\tk1 = 0.5\\n\\t\\t\\t\\tk2 = 0.5\\n\\t\\tReturns\\n\\t\\t\\t@return A binary image of same size as @param image\\n\\t\\t\\n\\t\\t@cite https://drive.google.com/file/d/1D3CyI5vtodPJeZaD2UV5wdcaIMtkBbdZ/view?usp=sharing\\n    \"\n    if default:\n        n1 = int(0.05 * min(image.shape[0], image.shape[1]))\n        if n1 % 2 == 0:\n            n1 = n1 + 1\n        n2 = int(0.1 * min(image.shape[0], image.shape[1]))\n        if n2 % 2 == 0:\n            n2 = n2 + 1\n        k1 = 0.5\n        k2 = 0.5\n    if image.ndim == 3:\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = np.copy(image)\n    T1 = threshold_sauvola(gray, window_size=n1, k=k1)\n    max_val = np.amax(gray)\n    min_val = np.amin(gray)\n    C = np.copy(T1)\n    C = C.astype(np.float32)\n    C[gray > T1] = (gray[gray > T1] - T1[gray > T1]) / (max_val - T1[gray > T1])\n    C[gray <= T1] = 0\n    C = C * 255.0\n    new_in = np.copy(C.astype(np.uint8))\n    T2 = threshold_sauvola(new_in, window_size=n2, k=k2)\n    binary = np.copy(gray)\n    binary[new_in <= T2] = 0\n    binary[new_in > T2] = 255\n    return binary",
            "def SauvolaModBinarization(image, n1=51, n2=51, k1=0.3, k2=0.3, default=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n\\t Binarization using Sauvola's algorithm\\n\\t\\t@name : SauvolaModBinarization\\n\\t parameters\\n\\t\\t@param image (numpy array of shape (3/1) of type np.uint8): color or gray scale image\\n\\t optional parameters\\n\\t\\t@param n1 (int) : window size for running sauvola during the first pass\\n\\t\\t@param n2 (int): window size for running sauvola during the second pass\\n\\t\\t@param k1 (float): k value corresponding to sauvola during the first pass\\n\\t\\t@param k2 (float): k value corresponding to sauvola during the second pass\\n\\t\\t@param default (bool) : bollean variable to set the above parameter as default. \\n\\n\\t\\t\\t@param default is set to True : thus default values of the above optional parameters (n1,n2,k1,k2) are set to\\n\\t\\t\\t\\tn1 = 5 % of min(image height, image width)\\n\\t\\t\\t\\tn2 = 10 % of min(image height, image width)\\n\\t\\t\\t\\tk1 = 0.5\\n\\t\\t\\t\\tk2 = 0.5\\n\\t\\tReturns\\n\\t\\t\\t@return A binary image of same size as @param image\\n\\t\\t\\n\\t\\t@cite https://drive.google.com/file/d/1D3CyI5vtodPJeZaD2UV5wdcaIMtkBbdZ/view?usp=sharing\\n    \"\n    if default:\n        n1 = int(0.05 * min(image.shape[0], image.shape[1]))\n        if n1 % 2 == 0:\n            n1 = n1 + 1\n        n2 = int(0.1 * min(image.shape[0], image.shape[1]))\n        if n2 % 2 == 0:\n            n2 = n2 + 1\n        k1 = 0.5\n        k2 = 0.5\n    if image.ndim == 3:\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = np.copy(image)\n    T1 = threshold_sauvola(gray, window_size=n1, k=k1)\n    max_val = np.amax(gray)\n    min_val = np.amin(gray)\n    C = np.copy(T1)\n    C = C.astype(np.float32)\n    C[gray > T1] = (gray[gray > T1] - T1[gray > T1]) / (max_val - T1[gray > T1])\n    C[gray <= T1] = 0\n    C = C * 255.0\n    new_in = np.copy(C.astype(np.uint8))\n    T2 = threshold_sauvola(new_in, window_size=n2, k=k2)\n    binary = np.copy(gray)\n    binary[new_in <= T2] = 0\n    binary[new_in > T2] = 255\n    return binary",
            "def SauvolaModBinarization(image, n1=51, n2=51, k1=0.3, k2=0.3, default=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n\\t Binarization using Sauvola's algorithm\\n\\t\\t@name : SauvolaModBinarization\\n\\t parameters\\n\\t\\t@param image (numpy array of shape (3/1) of type np.uint8): color or gray scale image\\n\\t optional parameters\\n\\t\\t@param n1 (int) : window size for running sauvola during the first pass\\n\\t\\t@param n2 (int): window size for running sauvola during the second pass\\n\\t\\t@param k1 (float): k value corresponding to sauvola during the first pass\\n\\t\\t@param k2 (float): k value corresponding to sauvola during the second pass\\n\\t\\t@param default (bool) : bollean variable to set the above parameter as default. \\n\\n\\t\\t\\t@param default is set to True : thus default values of the above optional parameters (n1,n2,k1,k2) are set to\\n\\t\\t\\t\\tn1 = 5 % of min(image height, image width)\\n\\t\\t\\t\\tn2 = 10 % of min(image height, image width)\\n\\t\\t\\t\\tk1 = 0.5\\n\\t\\t\\t\\tk2 = 0.5\\n\\t\\tReturns\\n\\t\\t\\t@return A binary image of same size as @param image\\n\\t\\t\\n\\t\\t@cite https://drive.google.com/file/d/1D3CyI5vtodPJeZaD2UV5wdcaIMtkBbdZ/view?usp=sharing\\n    \"\n    if default:\n        n1 = int(0.05 * min(image.shape[0], image.shape[1]))\n        if n1 % 2 == 0:\n            n1 = n1 + 1\n        n2 = int(0.1 * min(image.shape[0], image.shape[1]))\n        if n2 % 2 == 0:\n            n2 = n2 + 1\n        k1 = 0.5\n        k2 = 0.5\n    if image.ndim == 3:\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = np.copy(image)\n    T1 = threshold_sauvola(gray, window_size=n1, k=k1)\n    max_val = np.amax(gray)\n    min_val = np.amin(gray)\n    C = np.copy(T1)\n    C = C.astype(np.float32)\n    C[gray > T1] = (gray[gray > T1] - T1[gray > T1]) / (max_val - T1[gray > T1])\n    C[gray <= T1] = 0\n    C = C * 255.0\n    new_in = np.copy(C.astype(np.uint8))\n    T2 = threshold_sauvola(new_in, window_size=n2, k=k2)\n    binary = np.copy(gray)\n    binary[new_in <= T2] = 0\n    binary[new_in > T2] = 255\n    return binary",
            "def SauvolaModBinarization(image, n1=51, n2=51, k1=0.3, k2=0.3, default=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n\\t Binarization using Sauvola's algorithm\\n\\t\\t@name : SauvolaModBinarization\\n\\t parameters\\n\\t\\t@param image (numpy array of shape (3/1) of type np.uint8): color or gray scale image\\n\\t optional parameters\\n\\t\\t@param n1 (int) : window size for running sauvola during the first pass\\n\\t\\t@param n2 (int): window size for running sauvola during the second pass\\n\\t\\t@param k1 (float): k value corresponding to sauvola during the first pass\\n\\t\\t@param k2 (float): k value corresponding to sauvola during the second pass\\n\\t\\t@param default (bool) : bollean variable to set the above parameter as default. \\n\\n\\t\\t\\t@param default is set to True : thus default values of the above optional parameters (n1,n2,k1,k2) are set to\\n\\t\\t\\t\\tn1 = 5 % of min(image height, image width)\\n\\t\\t\\t\\tn2 = 10 % of min(image height, image width)\\n\\t\\t\\t\\tk1 = 0.5\\n\\t\\t\\t\\tk2 = 0.5\\n\\t\\tReturns\\n\\t\\t\\t@return A binary image of same size as @param image\\n\\t\\t\\n\\t\\t@cite https://drive.google.com/file/d/1D3CyI5vtodPJeZaD2UV5wdcaIMtkBbdZ/view?usp=sharing\\n    \"\n    if default:\n        n1 = int(0.05 * min(image.shape[0], image.shape[1]))\n        if n1 % 2 == 0:\n            n1 = n1 + 1\n        n2 = int(0.1 * min(image.shape[0], image.shape[1]))\n        if n2 % 2 == 0:\n            n2 = n2 + 1\n        k1 = 0.5\n        k2 = 0.5\n    if image.ndim == 3:\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = np.copy(image)\n    T1 = threshold_sauvola(gray, window_size=n1, k=k1)\n    max_val = np.amax(gray)\n    min_val = np.amin(gray)\n    C = np.copy(T1)\n    C = C.astype(np.float32)\n    C[gray > T1] = (gray[gray > T1] - T1[gray > T1]) / (max_val - T1[gray > T1])\n    C[gray <= T1] = 0\n    C = C * 255.0\n    new_in = np.copy(C.astype(np.uint8))\n    T2 = threshold_sauvola(new_in, window_size=n2, k=k2)\n    binary = np.copy(gray)\n    binary[new_in <= T2] = 0\n    binary[new_in > T2] = 255\n    return binary"
        ]
    }
]