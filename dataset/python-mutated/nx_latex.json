[
    {
        "func_name": "to_latex_raw",
        "original": "@nx.utils.not_implemented_for('multigraph')\ndef to_latex_raw(G, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='label', default_edge_options='', edge_options='edge_options', edge_label='label', edge_label_options='edge_label_options'):\n    \"\"\"Return a string of the LaTeX/TikZ code to draw `G`\n\n    This function produces just the code for the tikzpicture\n    without any enclosing environment.\n\n    Parameters\n    ==========\n    G : NetworkX graph\n        The NetworkX graph to be drawn\n    pos : string or dict (default \"pos\")\n        The name of the node attribute on `G` that holds the position of each node.\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n        They can also be strings to denote positions in TikZ style, such as (x, y)\n        or (angle:radius).\n        If a dict, it should be keyed by node to a position.\n        If an empty dict, a circular layout is computed by TikZ.\n    tikz_options : string\n        The tikzpicture options description defining the options for the picture.\n        Often large scale options like `[scale=2]`.\n    default_node_options : string\n        The draw options for a path of nodes. Individual node options override these.\n    node_options : string or dict\n        The name of the node attribute on `G` that holds the options for each node.\n        Or a dict keyed by node to a string holding the options for that node.\n    node_label : string or dict\n        The name of the node attribute on `G` that holds the node label (text)\n        displayed for each node. If the attribute is \"\" or not present, the node\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n        Or a dict keyed by node to a string holding the label for that node.\n    default_edge_options : string\n        The options for the scope drawing all edges. The default is \"[-]\" for\n        undirected graphs and \"[->]\" for directed graphs.\n    edge_options : string or dict\n        The name of the edge attribute on `G` that holds the options for each edge.\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\n        Or a dict keyed by edge to a string holding the options for that edge.\n    edge_label : string or dict\n        The name of the edge attribute on `G` that holds the edge label (text)\n        displayed for each edge. If the attribute is \"\" or not present, no edge\n        label is drawn.\n        Or a dict keyed by edge to a string holding the label for that edge.\n    edge_label_options : string or dict\n        The name of the edge attribute on `G` that holds the label options for\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\n        Or a dict keyed by edge to a string holding the label options for that edge.\n\n    Returns\n    =======\n    latex_code : string\n       The text string which draws the desired graph(s) when compiled by LaTeX.\n\n    See Also\n    ========\n    to_latex\n    write_latex\n    \"\"\"\n    i4 = '\\n    '\n    i8 = '\\n        '\n    if not isinstance(pos, dict):\n        pos = nx.get_node_attributes(G, pos)\n    if not pos:\n        pos = {n: f'({round(360.0 * i / len(G), 3)}:2)' for (i, n) in enumerate(G)}\n    for node in G:\n        if node not in pos:\n            raise nx.NetworkXError(f'node {node} has no specified pos {pos}')\n        posnode = pos[node]\n        if not isinstance(posnode, str):\n            try:\n                (posx, posy) = posnode\n                pos[node] = f'({round(posx, 3)}, {round(posy, 3)})'\n            except (TypeError, ValueError):\n                msg = f'position pos[{node}] is not 2-tuple or a string: {posnode}'\n                raise nx.NetworkXError(msg)\n    if not isinstance(node_options, dict):\n        node_options = nx.get_node_attributes(G, node_options)\n    if not isinstance(node_label, dict):\n        node_label = nx.get_node_attributes(G, node_label)\n    if not isinstance(edge_options, dict):\n        edge_options = nx.get_edge_attributes(G, edge_options)\n    if not isinstance(edge_label, dict):\n        edge_label = nx.get_edge_attributes(G, edge_label)\n    if not isinstance(edge_label_options, dict):\n        edge_label_options = nx.get_edge_attributes(G, edge_label_options)\n    topts = '' if tikz_options == '' else f\"[{tikz_options.strip('[]')}]\"\n    defn = '' if default_node_options == '' else f\"[{default_node_options.strip('[]')}]\"\n    linestyle = f\"{('->' if G.is_directed() else '-')}\"\n    if default_edge_options == '':\n        defe = '[' + linestyle + ']'\n    elif '-' in default_edge_options:\n        defe = default_edge_options\n    else:\n        defe = f\"[{linestyle},{default_edge_options.strip('[]')}]\"\n    result = '  \\\\begin{tikzpicture}' + topts\n    result += i4 + '  \\\\draw' + defn\n    for n in G:\n        nopts = f\"[{node_options[n].strip('[]')}]\" if n in node_options else ''\n        ntext = f'{{{node_label[n]}}}' if n in node_label else f'{{{n}}}'\n        result += i8 + f'{pos[n]} node{nopts} ({n}){ntext}'\n    result += ';\\n'\n    result += '      \\\\begin{scope}' + defe\n    for edge in G.edges:\n        (u, v) = edge[:2]\n        e_opts = f'{edge_options[edge]}'.strip('[]') if edge in edge_options else ''\n        if u == v and 'loop' not in e_opts:\n            e_opts = 'loop,' + e_opts\n        e_opts = f'[{e_opts}]' if e_opts != '' else ''\n        els = edge_label_options[edge] if edge in edge_label_options else ''\n        els = f\"[{els.strip('[]')}]\"\n        e_label = f' node{els} {{{edge_label[edge]}}}' if edge in edge_label else ''\n        result += i8 + f'\\\\draw{e_opts} ({u}) to{e_label} ({v});'\n    result += '\\n      \\\\end{scope}\\n    \\\\end{tikzpicture}\\n'\n    return result",
        "mutated": [
            "@nx.utils.not_implemented_for('multigraph')\ndef to_latex_raw(G, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='label', default_edge_options='', edge_options='edge_options', edge_label='label', edge_label_options='edge_label_options'):\n    if False:\n        i = 10\n    'Return a string of the LaTeX/TikZ code to draw `G`\\n\\n    This function produces just the code for the tikzpicture\\n    without any enclosing environment.\\n\\n    Parameters\\n    ==========\\n    G : NetworkX graph\\n        The NetworkX graph to be drawn\\n    pos : string or dict (default \"pos\")\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n       The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    to_latex\\n    write_latex\\n    '\n    i4 = '\\n    '\n    i8 = '\\n        '\n    if not isinstance(pos, dict):\n        pos = nx.get_node_attributes(G, pos)\n    if not pos:\n        pos = {n: f'({round(360.0 * i / len(G), 3)}:2)' for (i, n) in enumerate(G)}\n    for node in G:\n        if node not in pos:\n            raise nx.NetworkXError(f'node {node} has no specified pos {pos}')\n        posnode = pos[node]\n        if not isinstance(posnode, str):\n            try:\n                (posx, posy) = posnode\n                pos[node] = f'({round(posx, 3)}, {round(posy, 3)})'\n            except (TypeError, ValueError):\n                msg = f'position pos[{node}] is not 2-tuple or a string: {posnode}'\n                raise nx.NetworkXError(msg)\n    if not isinstance(node_options, dict):\n        node_options = nx.get_node_attributes(G, node_options)\n    if not isinstance(node_label, dict):\n        node_label = nx.get_node_attributes(G, node_label)\n    if not isinstance(edge_options, dict):\n        edge_options = nx.get_edge_attributes(G, edge_options)\n    if not isinstance(edge_label, dict):\n        edge_label = nx.get_edge_attributes(G, edge_label)\n    if not isinstance(edge_label_options, dict):\n        edge_label_options = nx.get_edge_attributes(G, edge_label_options)\n    topts = '' if tikz_options == '' else f\"[{tikz_options.strip('[]')}]\"\n    defn = '' if default_node_options == '' else f\"[{default_node_options.strip('[]')}]\"\n    linestyle = f\"{('->' if G.is_directed() else '-')}\"\n    if default_edge_options == '':\n        defe = '[' + linestyle + ']'\n    elif '-' in default_edge_options:\n        defe = default_edge_options\n    else:\n        defe = f\"[{linestyle},{default_edge_options.strip('[]')}]\"\n    result = '  \\\\begin{tikzpicture}' + topts\n    result += i4 + '  \\\\draw' + defn\n    for n in G:\n        nopts = f\"[{node_options[n].strip('[]')}]\" if n in node_options else ''\n        ntext = f'{{{node_label[n]}}}' if n in node_label else f'{{{n}}}'\n        result += i8 + f'{pos[n]} node{nopts} ({n}){ntext}'\n    result += ';\\n'\n    result += '      \\\\begin{scope}' + defe\n    for edge in G.edges:\n        (u, v) = edge[:2]\n        e_opts = f'{edge_options[edge]}'.strip('[]') if edge in edge_options else ''\n        if u == v and 'loop' not in e_opts:\n            e_opts = 'loop,' + e_opts\n        e_opts = f'[{e_opts}]' if e_opts != '' else ''\n        els = edge_label_options[edge] if edge in edge_label_options else ''\n        els = f\"[{els.strip('[]')}]\"\n        e_label = f' node{els} {{{edge_label[edge]}}}' if edge in edge_label else ''\n        result += i8 + f'\\\\draw{e_opts} ({u}) to{e_label} ({v});'\n    result += '\\n      \\\\end{scope}\\n    \\\\end{tikzpicture}\\n'\n    return result",
            "@nx.utils.not_implemented_for('multigraph')\ndef to_latex_raw(G, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='label', default_edge_options='', edge_options='edge_options', edge_label='label', edge_label_options='edge_label_options'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return a string of the LaTeX/TikZ code to draw `G`\\n\\n    This function produces just the code for the tikzpicture\\n    without any enclosing environment.\\n\\n    Parameters\\n    ==========\\n    G : NetworkX graph\\n        The NetworkX graph to be drawn\\n    pos : string or dict (default \"pos\")\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n       The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    to_latex\\n    write_latex\\n    '\n    i4 = '\\n    '\n    i8 = '\\n        '\n    if not isinstance(pos, dict):\n        pos = nx.get_node_attributes(G, pos)\n    if not pos:\n        pos = {n: f'({round(360.0 * i / len(G), 3)}:2)' for (i, n) in enumerate(G)}\n    for node in G:\n        if node not in pos:\n            raise nx.NetworkXError(f'node {node} has no specified pos {pos}')\n        posnode = pos[node]\n        if not isinstance(posnode, str):\n            try:\n                (posx, posy) = posnode\n                pos[node] = f'({round(posx, 3)}, {round(posy, 3)})'\n            except (TypeError, ValueError):\n                msg = f'position pos[{node}] is not 2-tuple or a string: {posnode}'\n                raise nx.NetworkXError(msg)\n    if not isinstance(node_options, dict):\n        node_options = nx.get_node_attributes(G, node_options)\n    if not isinstance(node_label, dict):\n        node_label = nx.get_node_attributes(G, node_label)\n    if not isinstance(edge_options, dict):\n        edge_options = nx.get_edge_attributes(G, edge_options)\n    if not isinstance(edge_label, dict):\n        edge_label = nx.get_edge_attributes(G, edge_label)\n    if not isinstance(edge_label_options, dict):\n        edge_label_options = nx.get_edge_attributes(G, edge_label_options)\n    topts = '' if tikz_options == '' else f\"[{tikz_options.strip('[]')}]\"\n    defn = '' if default_node_options == '' else f\"[{default_node_options.strip('[]')}]\"\n    linestyle = f\"{('->' if G.is_directed() else '-')}\"\n    if default_edge_options == '':\n        defe = '[' + linestyle + ']'\n    elif '-' in default_edge_options:\n        defe = default_edge_options\n    else:\n        defe = f\"[{linestyle},{default_edge_options.strip('[]')}]\"\n    result = '  \\\\begin{tikzpicture}' + topts\n    result += i4 + '  \\\\draw' + defn\n    for n in G:\n        nopts = f\"[{node_options[n].strip('[]')}]\" if n in node_options else ''\n        ntext = f'{{{node_label[n]}}}' if n in node_label else f'{{{n}}}'\n        result += i8 + f'{pos[n]} node{nopts} ({n}){ntext}'\n    result += ';\\n'\n    result += '      \\\\begin{scope}' + defe\n    for edge in G.edges:\n        (u, v) = edge[:2]\n        e_opts = f'{edge_options[edge]}'.strip('[]') if edge in edge_options else ''\n        if u == v and 'loop' not in e_opts:\n            e_opts = 'loop,' + e_opts\n        e_opts = f'[{e_opts}]' if e_opts != '' else ''\n        els = edge_label_options[edge] if edge in edge_label_options else ''\n        els = f\"[{els.strip('[]')}]\"\n        e_label = f' node{els} {{{edge_label[edge]}}}' if edge in edge_label else ''\n        result += i8 + f'\\\\draw{e_opts} ({u}) to{e_label} ({v});'\n    result += '\\n      \\\\end{scope}\\n    \\\\end{tikzpicture}\\n'\n    return result",
            "@nx.utils.not_implemented_for('multigraph')\ndef to_latex_raw(G, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='label', default_edge_options='', edge_options='edge_options', edge_label='label', edge_label_options='edge_label_options'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return a string of the LaTeX/TikZ code to draw `G`\\n\\n    This function produces just the code for the tikzpicture\\n    without any enclosing environment.\\n\\n    Parameters\\n    ==========\\n    G : NetworkX graph\\n        The NetworkX graph to be drawn\\n    pos : string or dict (default \"pos\")\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n       The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    to_latex\\n    write_latex\\n    '\n    i4 = '\\n    '\n    i8 = '\\n        '\n    if not isinstance(pos, dict):\n        pos = nx.get_node_attributes(G, pos)\n    if not pos:\n        pos = {n: f'({round(360.0 * i / len(G), 3)}:2)' for (i, n) in enumerate(G)}\n    for node in G:\n        if node not in pos:\n            raise nx.NetworkXError(f'node {node} has no specified pos {pos}')\n        posnode = pos[node]\n        if not isinstance(posnode, str):\n            try:\n                (posx, posy) = posnode\n                pos[node] = f'({round(posx, 3)}, {round(posy, 3)})'\n            except (TypeError, ValueError):\n                msg = f'position pos[{node}] is not 2-tuple or a string: {posnode}'\n                raise nx.NetworkXError(msg)\n    if not isinstance(node_options, dict):\n        node_options = nx.get_node_attributes(G, node_options)\n    if not isinstance(node_label, dict):\n        node_label = nx.get_node_attributes(G, node_label)\n    if not isinstance(edge_options, dict):\n        edge_options = nx.get_edge_attributes(G, edge_options)\n    if not isinstance(edge_label, dict):\n        edge_label = nx.get_edge_attributes(G, edge_label)\n    if not isinstance(edge_label_options, dict):\n        edge_label_options = nx.get_edge_attributes(G, edge_label_options)\n    topts = '' if tikz_options == '' else f\"[{tikz_options.strip('[]')}]\"\n    defn = '' if default_node_options == '' else f\"[{default_node_options.strip('[]')}]\"\n    linestyle = f\"{('->' if G.is_directed() else '-')}\"\n    if default_edge_options == '':\n        defe = '[' + linestyle + ']'\n    elif '-' in default_edge_options:\n        defe = default_edge_options\n    else:\n        defe = f\"[{linestyle},{default_edge_options.strip('[]')}]\"\n    result = '  \\\\begin{tikzpicture}' + topts\n    result += i4 + '  \\\\draw' + defn\n    for n in G:\n        nopts = f\"[{node_options[n].strip('[]')}]\" if n in node_options else ''\n        ntext = f'{{{node_label[n]}}}' if n in node_label else f'{{{n}}}'\n        result += i8 + f'{pos[n]} node{nopts} ({n}){ntext}'\n    result += ';\\n'\n    result += '      \\\\begin{scope}' + defe\n    for edge in G.edges:\n        (u, v) = edge[:2]\n        e_opts = f'{edge_options[edge]}'.strip('[]') if edge in edge_options else ''\n        if u == v and 'loop' not in e_opts:\n            e_opts = 'loop,' + e_opts\n        e_opts = f'[{e_opts}]' if e_opts != '' else ''\n        els = edge_label_options[edge] if edge in edge_label_options else ''\n        els = f\"[{els.strip('[]')}]\"\n        e_label = f' node{els} {{{edge_label[edge]}}}' if edge in edge_label else ''\n        result += i8 + f'\\\\draw{e_opts} ({u}) to{e_label} ({v});'\n    result += '\\n      \\\\end{scope}\\n    \\\\end{tikzpicture}\\n'\n    return result",
            "@nx.utils.not_implemented_for('multigraph')\ndef to_latex_raw(G, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='label', default_edge_options='', edge_options='edge_options', edge_label='label', edge_label_options='edge_label_options'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return a string of the LaTeX/TikZ code to draw `G`\\n\\n    This function produces just the code for the tikzpicture\\n    without any enclosing environment.\\n\\n    Parameters\\n    ==========\\n    G : NetworkX graph\\n        The NetworkX graph to be drawn\\n    pos : string or dict (default \"pos\")\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n       The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    to_latex\\n    write_latex\\n    '\n    i4 = '\\n    '\n    i8 = '\\n        '\n    if not isinstance(pos, dict):\n        pos = nx.get_node_attributes(G, pos)\n    if not pos:\n        pos = {n: f'({round(360.0 * i / len(G), 3)}:2)' for (i, n) in enumerate(G)}\n    for node in G:\n        if node not in pos:\n            raise nx.NetworkXError(f'node {node} has no specified pos {pos}')\n        posnode = pos[node]\n        if not isinstance(posnode, str):\n            try:\n                (posx, posy) = posnode\n                pos[node] = f'({round(posx, 3)}, {round(posy, 3)})'\n            except (TypeError, ValueError):\n                msg = f'position pos[{node}] is not 2-tuple or a string: {posnode}'\n                raise nx.NetworkXError(msg)\n    if not isinstance(node_options, dict):\n        node_options = nx.get_node_attributes(G, node_options)\n    if not isinstance(node_label, dict):\n        node_label = nx.get_node_attributes(G, node_label)\n    if not isinstance(edge_options, dict):\n        edge_options = nx.get_edge_attributes(G, edge_options)\n    if not isinstance(edge_label, dict):\n        edge_label = nx.get_edge_attributes(G, edge_label)\n    if not isinstance(edge_label_options, dict):\n        edge_label_options = nx.get_edge_attributes(G, edge_label_options)\n    topts = '' if tikz_options == '' else f\"[{tikz_options.strip('[]')}]\"\n    defn = '' if default_node_options == '' else f\"[{default_node_options.strip('[]')}]\"\n    linestyle = f\"{('->' if G.is_directed() else '-')}\"\n    if default_edge_options == '':\n        defe = '[' + linestyle + ']'\n    elif '-' in default_edge_options:\n        defe = default_edge_options\n    else:\n        defe = f\"[{linestyle},{default_edge_options.strip('[]')}]\"\n    result = '  \\\\begin{tikzpicture}' + topts\n    result += i4 + '  \\\\draw' + defn\n    for n in G:\n        nopts = f\"[{node_options[n].strip('[]')}]\" if n in node_options else ''\n        ntext = f'{{{node_label[n]}}}' if n in node_label else f'{{{n}}}'\n        result += i8 + f'{pos[n]} node{nopts} ({n}){ntext}'\n    result += ';\\n'\n    result += '      \\\\begin{scope}' + defe\n    for edge in G.edges:\n        (u, v) = edge[:2]\n        e_opts = f'{edge_options[edge]}'.strip('[]') if edge in edge_options else ''\n        if u == v and 'loop' not in e_opts:\n            e_opts = 'loop,' + e_opts\n        e_opts = f'[{e_opts}]' if e_opts != '' else ''\n        els = edge_label_options[edge] if edge in edge_label_options else ''\n        els = f\"[{els.strip('[]')}]\"\n        e_label = f' node{els} {{{edge_label[edge]}}}' if edge in edge_label else ''\n        result += i8 + f'\\\\draw{e_opts} ({u}) to{e_label} ({v});'\n    result += '\\n      \\\\end{scope}\\n    \\\\end{tikzpicture}\\n'\n    return result",
            "@nx.utils.not_implemented_for('multigraph')\ndef to_latex_raw(G, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='label', default_edge_options='', edge_options='edge_options', edge_label='label', edge_label_options='edge_label_options'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return a string of the LaTeX/TikZ code to draw `G`\\n\\n    This function produces just the code for the tikzpicture\\n    without any enclosing environment.\\n\\n    Parameters\\n    ==========\\n    G : NetworkX graph\\n        The NetworkX graph to be drawn\\n    pos : string or dict (default \"pos\")\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n       The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    to_latex\\n    write_latex\\n    '\n    i4 = '\\n    '\n    i8 = '\\n        '\n    if not isinstance(pos, dict):\n        pos = nx.get_node_attributes(G, pos)\n    if not pos:\n        pos = {n: f'({round(360.0 * i / len(G), 3)}:2)' for (i, n) in enumerate(G)}\n    for node in G:\n        if node not in pos:\n            raise nx.NetworkXError(f'node {node} has no specified pos {pos}')\n        posnode = pos[node]\n        if not isinstance(posnode, str):\n            try:\n                (posx, posy) = posnode\n                pos[node] = f'({round(posx, 3)}, {round(posy, 3)})'\n            except (TypeError, ValueError):\n                msg = f'position pos[{node}] is not 2-tuple or a string: {posnode}'\n                raise nx.NetworkXError(msg)\n    if not isinstance(node_options, dict):\n        node_options = nx.get_node_attributes(G, node_options)\n    if not isinstance(node_label, dict):\n        node_label = nx.get_node_attributes(G, node_label)\n    if not isinstance(edge_options, dict):\n        edge_options = nx.get_edge_attributes(G, edge_options)\n    if not isinstance(edge_label, dict):\n        edge_label = nx.get_edge_attributes(G, edge_label)\n    if not isinstance(edge_label_options, dict):\n        edge_label_options = nx.get_edge_attributes(G, edge_label_options)\n    topts = '' if tikz_options == '' else f\"[{tikz_options.strip('[]')}]\"\n    defn = '' if default_node_options == '' else f\"[{default_node_options.strip('[]')}]\"\n    linestyle = f\"{('->' if G.is_directed() else '-')}\"\n    if default_edge_options == '':\n        defe = '[' + linestyle + ']'\n    elif '-' in default_edge_options:\n        defe = default_edge_options\n    else:\n        defe = f\"[{linestyle},{default_edge_options.strip('[]')}]\"\n    result = '  \\\\begin{tikzpicture}' + topts\n    result += i4 + '  \\\\draw' + defn\n    for n in G:\n        nopts = f\"[{node_options[n].strip('[]')}]\" if n in node_options else ''\n        ntext = f'{{{node_label[n]}}}' if n in node_label else f'{{{n}}}'\n        result += i8 + f'{pos[n]} node{nopts} ({n}){ntext}'\n    result += ';\\n'\n    result += '      \\\\begin{scope}' + defe\n    for edge in G.edges:\n        (u, v) = edge[:2]\n        e_opts = f'{edge_options[edge]}'.strip('[]') if edge in edge_options else ''\n        if u == v and 'loop' not in e_opts:\n            e_opts = 'loop,' + e_opts\n        e_opts = f'[{e_opts}]' if e_opts != '' else ''\n        els = edge_label_options[edge] if edge in edge_label_options else ''\n        els = f\"[{els.strip('[]')}]\"\n        e_label = f' node{els} {{{edge_label[edge]}}}' if edge in edge_label else ''\n        result += i8 + f'\\\\draw{e_opts} ({u}) to{e_label} ({v});'\n    result += '\\n      \\\\end{scope}\\n    \\\\end{tikzpicture}\\n'\n    return result"
        ]
    },
    {
        "func_name": "to_latex",
        "original": "def to_latex(Gbunch, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='node_label', default_edge_options='', edge_options='edge_options', edge_label='edge_label', edge_label_options='edge_label_options', caption='', latex_label='', sub_captions=None, sub_labels=None, n_rows=1, as_document=True, document_wrapper=_DOC_WRAPPER_TIKZ, figure_wrapper=_FIG_WRAPPER, subfigure_wrapper=_SUBFIG_WRAPPER):\n    \"\"\"Return latex code to draw the graph(s) in `Gbunch`\n\n    The TikZ drawing utility in LaTeX is used to draw the graph(s).\n    If `Gbunch` is a graph, it is drawn in a figure environment.\n    If `Gbunch` is an iterable of graphs, each is drawn in a subfigure environment\n    within a single figure environment.\n\n    If `as_document` is True, the figure is wrapped inside a document environment\n    so that the resulting string is ready to be compiled by LaTeX. Otherwise,\n    the string is ready for inclusion in a larger tex document using ``\\\\include``\n    or ``\\\\input`` statements.\n\n    Parameters\n    ==========\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\n        The NetworkX graph to be drawn or an iterable of graphs\n        to be drawn inside subfigures of a single figure.\n    pos : string or list of strings\n        The name of the node attribute on `G` that holds the position of each node.\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n        They can also be strings to denote positions in TikZ style, such as (x, y)\n        or (angle:radius).\n        If a dict, it should be keyed by node to a position.\n        If an empty dict, a circular layout is computed by TikZ.\n        If you are drawing many graphs in subfigures, use a list of position dicts.\n    tikz_options : string\n        The tikzpicture options description defining the options for the picture.\n        Often large scale options like `[scale=2]`.\n    default_node_options : string\n        The draw options for a path of nodes. Individual node options override these.\n    node_options : string or dict\n        The name of the node attribute on `G` that holds the options for each node.\n        Or a dict keyed by node to a string holding the options for that node.\n    node_label : string or dict\n        The name of the node attribute on `G` that holds the node label (text)\n        displayed for each node. If the attribute is \"\" or not present, the node\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n        Or a dict keyed by node to a string holding the label for that node.\n    default_edge_options : string\n        The options for the scope drawing all edges. The default is \"[-]\" for\n        undirected graphs and \"[->]\" for directed graphs.\n    edge_options : string or dict\n        The name of the edge attribute on `G` that holds the options for each edge.\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\n        Or a dict keyed by edge to a string holding the options for that edge.\n    edge_label : string or dict\n        The name of the edge attribute on `G` that holds the edge label (text)\n        displayed for each edge. If the attribute is \"\" or not present, no edge\n        label is drawn.\n        Or a dict keyed by edge to a string holding the label for that edge.\n    edge_label_options : string or dict\n        The name of the edge attribute on `G` that holds the label options for\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\n        Or a dict keyed by edge to a string holding the label options for that edge.\n    caption : string\n        The caption string for the figure environment\n    latex_label : string\n        The latex label used for the figure for easy referral from the main text\n    sub_captions : list of strings\n        The sub_caption string for each subfigure in the figure\n    sub_latex_labels : list of strings\n        The latex label for each subfigure in the figure\n    n_rows : int\n        The number of rows of subfigures to arrange for multiple graphs\n    as_document : bool\n        Whether to wrap the latex code in a document environment for compiling\n    document_wrapper : formatted text string with variable ``content``.\n        This text is called to evaluate the content embedded in a document\n        environment with a preamble setting up TikZ.\n    figure_wrapper : formatted text string\n        This text is evaluated with variables ``content``, ``caption`` and ``label``.\n        It wraps the content and if a caption is provided, adds the latex code for\n        that caption, and if a label is provided, adds the latex code for a label.\n    subfigure_wrapper : formatted text string\n        This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\n        It wraps the content and if a caption is provided, adds the latex code for\n        that caption, and if a label is provided, adds the latex code for a label.\n        The size is the vertical size of each row of subfigures as a fraction.\n\n    Returns\n    =======\n    latex_code : string\n        The text string which draws the desired graph(s) when compiled by LaTeX.\n\n    See Also\n    ========\n    write_latex\n    to_latex_raw\n    \"\"\"\n    if hasattr(Gbunch, 'adj'):\n        raw = to_latex_raw(Gbunch, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n    else:\n        sbf = subfigure_wrapper\n        size = 1 / n_rows\n        N = len(Gbunch)\n        if isinstance(pos, str | dict):\n            pos = [pos] * N\n        if sub_captions is None:\n            sub_captions = [''] * N\n        if sub_labels is None:\n            sub_labels = [''] * N\n        if not len(Gbunch) == len(pos) == len(sub_captions) == len(sub_labels):\n            raise nx.NetworkXError('length of Gbunch, sub_captions and sub_figures must agree')\n        raw = ''\n        for (G, pos, subcap, sublbl) in zip(Gbunch, pos, sub_captions, sub_labels):\n            subraw = to_latex_raw(G, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n            cap = f'    \\\\caption{{{subcap}}}' if subcap else ''\n            lbl = f'\\\\label{{{sublbl}}}' if sublbl else ''\n            raw += sbf.format(size=size, content=subraw, caption=cap, label=lbl)\n            raw += '\\n'\n    raw = raw[:-1]\n    cap = f'\\n  \\\\caption{{{caption}}}' if caption else ''\n    lbl = f'\\\\label{{{latex_label}}}' if latex_label else ''\n    fig = figure_wrapper.format(content=raw, caption=cap, label=lbl)\n    if as_document:\n        return document_wrapper.format(content=fig)\n    return fig",
        "mutated": [
            "def to_latex(Gbunch, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='node_label', default_edge_options='', edge_options='edge_options', edge_label='edge_label', edge_label_options='edge_label_options', caption='', latex_label='', sub_captions=None, sub_labels=None, n_rows=1, as_document=True, document_wrapper=_DOC_WRAPPER_TIKZ, figure_wrapper=_FIG_WRAPPER, subfigure_wrapper=_SUBFIG_WRAPPER):\n    if False:\n        i = 10\n    'Return latex code to draw the graph(s) in `Gbunch`\\n\\n    The TikZ drawing utility in LaTeX is used to draw the graph(s).\\n    If `Gbunch` is a graph, it is drawn in a figure environment.\\n    If `Gbunch` is an iterable of graphs, each is drawn in a subfigure environment\\n    within a single figure environment.\\n\\n    If `as_document` is True, the figure is wrapped inside a document environment\\n    so that the resulting string is ready to be compiled by LaTeX. Otherwise,\\n    the string is ready for inclusion in a larger tex document using ``\\\\include``\\n    or ``\\\\input`` statements.\\n\\n    Parameters\\n    ==========\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        The NetworkX graph to be drawn or an iterable of graphs\\n        to be drawn inside subfigures of a single figure.\\n    pos : string or list of strings\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n        If you are drawing many graphs in subfigures, use a list of position dicts.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n    caption : string\\n        The caption string for the figure environment\\n    latex_label : string\\n        The latex label used for the figure for easy referral from the main text\\n    sub_captions : list of strings\\n        The sub_caption string for each subfigure in the figure\\n    sub_latex_labels : list of strings\\n        The latex label for each subfigure in the figure\\n    n_rows : int\\n        The number of rows of subfigures to arrange for multiple graphs\\n    as_document : bool\\n        Whether to wrap the latex code in a document environment for compiling\\n    document_wrapper : formatted text string with variable ``content``.\\n        This text is called to evaluate the content embedded in a document\\n        environment with a preamble setting up TikZ.\\n    figure_wrapper : formatted text string\\n        This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n    subfigure_wrapper : formatted text string\\n        This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n        The size is the vertical size of each row of subfigures as a fraction.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n        The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    write_latex\\n    to_latex_raw\\n    '\n    if hasattr(Gbunch, 'adj'):\n        raw = to_latex_raw(Gbunch, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n    else:\n        sbf = subfigure_wrapper\n        size = 1 / n_rows\n        N = len(Gbunch)\n        if isinstance(pos, str | dict):\n            pos = [pos] * N\n        if sub_captions is None:\n            sub_captions = [''] * N\n        if sub_labels is None:\n            sub_labels = [''] * N\n        if not len(Gbunch) == len(pos) == len(sub_captions) == len(sub_labels):\n            raise nx.NetworkXError('length of Gbunch, sub_captions and sub_figures must agree')\n        raw = ''\n        for (G, pos, subcap, sublbl) in zip(Gbunch, pos, sub_captions, sub_labels):\n            subraw = to_latex_raw(G, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n            cap = f'    \\\\caption{{{subcap}}}' if subcap else ''\n            lbl = f'\\\\label{{{sublbl}}}' if sublbl else ''\n            raw += sbf.format(size=size, content=subraw, caption=cap, label=lbl)\n            raw += '\\n'\n    raw = raw[:-1]\n    cap = f'\\n  \\\\caption{{{caption}}}' if caption else ''\n    lbl = f'\\\\label{{{latex_label}}}' if latex_label else ''\n    fig = figure_wrapper.format(content=raw, caption=cap, label=lbl)\n    if as_document:\n        return document_wrapper.format(content=fig)\n    return fig",
            "def to_latex(Gbunch, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='node_label', default_edge_options='', edge_options='edge_options', edge_label='edge_label', edge_label_options='edge_label_options', caption='', latex_label='', sub_captions=None, sub_labels=None, n_rows=1, as_document=True, document_wrapper=_DOC_WRAPPER_TIKZ, figure_wrapper=_FIG_WRAPPER, subfigure_wrapper=_SUBFIG_WRAPPER):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return latex code to draw the graph(s) in `Gbunch`\\n\\n    The TikZ drawing utility in LaTeX is used to draw the graph(s).\\n    If `Gbunch` is a graph, it is drawn in a figure environment.\\n    If `Gbunch` is an iterable of graphs, each is drawn in a subfigure environment\\n    within a single figure environment.\\n\\n    If `as_document` is True, the figure is wrapped inside a document environment\\n    so that the resulting string is ready to be compiled by LaTeX. Otherwise,\\n    the string is ready for inclusion in a larger tex document using ``\\\\include``\\n    or ``\\\\input`` statements.\\n\\n    Parameters\\n    ==========\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        The NetworkX graph to be drawn or an iterable of graphs\\n        to be drawn inside subfigures of a single figure.\\n    pos : string or list of strings\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n        If you are drawing many graphs in subfigures, use a list of position dicts.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n    caption : string\\n        The caption string for the figure environment\\n    latex_label : string\\n        The latex label used for the figure for easy referral from the main text\\n    sub_captions : list of strings\\n        The sub_caption string for each subfigure in the figure\\n    sub_latex_labels : list of strings\\n        The latex label for each subfigure in the figure\\n    n_rows : int\\n        The number of rows of subfigures to arrange for multiple graphs\\n    as_document : bool\\n        Whether to wrap the latex code in a document environment for compiling\\n    document_wrapper : formatted text string with variable ``content``.\\n        This text is called to evaluate the content embedded in a document\\n        environment with a preamble setting up TikZ.\\n    figure_wrapper : formatted text string\\n        This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n    subfigure_wrapper : formatted text string\\n        This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n        The size is the vertical size of each row of subfigures as a fraction.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n        The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    write_latex\\n    to_latex_raw\\n    '\n    if hasattr(Gbunch, 'adj'):\n        raw = to_latex_raw(Gbunch, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n    else:\n        sbf = subfigure_wrapper\n        size = 1 / n_rows\n        N = len(Gbunch)\n        if isinstance(pos, str | dict):\n            pos = [pos] * N\n        if sub_captions is None:\n            sub_captions = [''] * N\n        if sub_labels is None:\n            sub_labels = [''] * N\n        if not len(Gbunch) == len(pos) == len(sub_captions) == len(sub_labels):\n            raise nx.NetworkXError('length of Gbunch, sub_captions and sub_figures must agree')\n        raw = ''\n        for (G, pos, subcap, sublbl) in zip(Gbunch, pos, sub_captions, sub_labels):\n            subraw = to_latex_raw(G, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n            cap = f'    \\\\caption{{{subcap}}}' if subcap else ''\n            lbl = f'\\\\label{{{sublbl}}}' if sublbl else ''\n            raw += sbf.format(size=size, content=subraw, caption=cap, label=lbl)\n            raw += '\\n'\n    raw = raw[:-1]\n    cap = f'\\n  \\\\caption{{{caption}}}' if caption else ''\n    lbl = f'\\\\label{{{latex_label}}}' if latex_label else ''\n    fig = figure_wrapper.format(content=raw, caption=cap, label=lbl)\n    if as_document:\n        return document_wrapper.format(content=fig)\n    return fig",
            "def to_latex(Gbunch, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='node_label', default_edge_options='', edge_options='edge_options', edge_label='edge_label', edge_label_options='edge_label_options', caption='', latex_label='', sub_captions=None, sub_labels=None, n_rows=1, as_document=True, document_wrapper=_DOC_WRAPPER_TIKZ, figure_wrapper=_FIG_WRAPPER, subfigure_wrapper=_SUBFIG_WRAPPER):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return latex code to draw the graph(s) in `Gbunch`\\n\\n    The TikZ drawing utility in LaTeX is used to draw the graph(s).\\n    If `Gbunch` is a graph, it is drawn in a figure environment.\\n    If `Gbunch` is an iterable of graphs, each is drawn in a subfigure environment\\n    within a single figure environment.\\n\\n    If `as_document` is True, the figure is wrapped inside a document environment\\n    so that the resulting string is ready to be compiled by LaTeX. Otherwise,\\n    the string is ready for inclusion in a larger tex document using ``\\\\include``\\n    or ``\\\\input`` statements.\\n\\n    Parameters\\n    ==========\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        The NetworkX graph to be drawn or an iterable of graphs\\n        to be drawn inside subfigures of a single figure.\\n    pos : string or list of strings\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n        If you are drawing many graphs in subfigures, use a list of position dicts.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n    caption : string\\n        The caption string for the figure environment\\n    latex_label : string\\n        The latex label used for the figure for easy referral from the main text\\n    sub_captions : list of strings\\n        The sub_caption string for each subfigure in the figure\\n    sub_latex_labels : list of strings\\n        The latex label for each subfigure in the figure\\n    n_rows : int\\n        The number of rows of subfigures to arrange for multiple graphs\\n    as_document : bool\\n        Whether to wrap the latex code in a document environment for compiling\\n    document_wrapper : formatted text string with variable ``content``.\\n        This text is called to evaluate the content embedded in a document\\n        environment with a preamble setting up TikZ.\\n    figure_wrapper : formatted text string\\n        This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n    subfigure_wrapper : formatted text string\\n        This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n        The size is the vertical size of each row of subfigures as a fraction.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n        The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    write_latex\\n    to_latex_raw\\n    '\n    if hasattr(Gbunch, 'adj'):\n        raw = to_latex_raw(Gbunch, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n    else:\n        sbf = subfigure_wrapper\n        size = 1 / n_rows\n        N = len(Gbunch)\n        if isinstance(pos, str | dict):\n            pos = [pos] * N\n        if sub_captions is None:\n            sub_captions = [''] * N\n        if sub_labels is None:\n            sub_labels = [''] * N\n        if not len(Gbunch) == len(pos) == len(sub_captions) == len(sub_labels):\n            raise nx.NetworkXError('length of Gbunch, sub_captions and sub_figures must agree')\n        raw = ''\n        for (G, pos, subcap, sublbl) in zip(Gbunch, pos, sub_captions, sub_labels):\n            subraw = to_latex_raw(G, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n            cap = f'    \\\\caption{{{subcap}}}' if subcap else ''\n            lbl = f'\\\\label{{{sublbl}}}' if sublbl else ''\n            raw += sbf.format(size=size, content=subraw, caption=cap, label=lbl)\n            raw += '\\n'\n    raw = raw[:-1]\n    cap = f'\\n  \\\\caption{{{caption}}}' if caption else ''\n    lbl = f'\\\\label{{{latex_label}}}' if latex_label else ''\n    fig = figure_wrapper.format(content=raw, caption=cap, label=lbl)\n    if as_document:\n        return document_wrapper.format(content=fig)\n    return fig",
            "def to_latex(Gbunch, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='node_label', default_edge_options='', edge_options='edge_options', edge_label='edge_label', edge_label_options='edge_label_options', caption='', latex_label='', sub_captions=None, sub_labels=None, n_rows=1, as_document=True, document_wrapper=_DOC_WRAPPER_TIKZ, figure_wrapper=_FIG_WRAPPER, subfigure_wrapper=_SUBFIG_WRAPPER):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return latex code to draw the graph(s) in `Gbunch`\\n\\n    The TikZ drawing utility in LaTeX is used to draw the graph(s).\\n    If `Gbunch` is a graph, it is drawn in a figure environment.\\n    If `Gbunch` is an iterable of graphs, each is drawn in a subfigure environment\\n    within a single figure environment.\\n\\n    If `as_document` is True, the figure is wrapped inside a document environment\\n    so that the resulting string is ready to be compiled by LaTeX. Otherwise,\\n    the string is ready for inclusion in a larger tex document using ``\\\\include``\\n    or ``\\\\input`` statements.\\n\\n    Parameters\\n    ==========\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        The NetworkX graph to be drawn or an iterable of graphs\\n        to be drawn inside subfigures of a single figure.\\n    pos : string or list of strings\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n        If you are drawing many graphs in subfigures, use a list of position dicts.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n    caption : string\\n        The caption string for the figure environment\\n    latex_label : string\\n        The latex label used for the figure for easy referral from the main text\\n    sub_captions : list of strings\\n        The sub_caption string for each subfigure in the figure\\n    sub_latex_labels : list of strings\\n        The latex label for each subfigure in the figure\\n    n_rows : int\\n        The number of rows of subfigures to arrange for multiple graphs\\n    as_document : bool\\n        Whether to wrap the latex code in a document environment for compiling\\n    document_wrapper : formatted text string with variable ``content``.\\n        This text is called to evaluate the content embedded in a document\\n        environment with a preamble setting up TikZ.\\n    figure_wrapper : formatted text string\\n        This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n    subfigure_wrapper : formatted text string\\n        This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n        The size is the vertical size of each row of subfigures as a fraction.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n        The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    write_latex\\n    to_latex_raw\\n    '\n    if hasattr(Gbunch, 'adj'):\n        raw = to_latex_raw(Gbunch, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n    else:\n        sbf = subfigure_wrapper\n        size = 1 / n_rows\n        N = len(Gbunch)\n        if isinstance(pos, str | dict):\n            pos = [pos] * N\n        if sub_captions is None:\n            sub_captions = [''] * N\n        if sub_labels is None:\n            sub_labels = [''] * N\n        if not len(Gbunch) == len(pos) == len(sub_captions) == len(sub_labels):\n            raise nx.NetworkXError('length of Gbunch, sub_captions and sub_figures must agree')\n        raw = ''\n        for (G, pos, subcap, sublbl) in zip(Gbunch, pos, sub_captions, sub_labels):\n            subraw = to_latex_raw(G, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n            cap = f'    \\\\caption{{{subcap}}}' if subcap else ''\n            lbl = f'\\\\label{{{sublbl}}}' if sublbl else ''\n            raw += sbf.format(size=size, content=subraw, caption=cap, label=lbl)\n            raw += '\\n'\n    raw = raw[:-1]\n    cap = f'\\n  \\\\caption{{{caption}}}' if caption else ''\n    lbl = f'\\\\label{{{latex_label}}}' if latex_label else ''\n    fig = figure_wrapper.format(content=raw, caption=cap, label=lbl)\n    if as_document:\n        return document_wrapper.format(content=fig)\n    return fig",
            "def to_latex(Gbunch, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='node_label', default_edge_options='', edge_options='edge_options', edge_label='edge_label', edge_label_options='edge_label_options', caption='', latex_label='', sub_captions=None, sub_labels=None, n_rows=1, as_document=True, document_wrapper=_DOC_WRAPPER_TIKZ, figure_wrapper=_FIG_WRAPPER, subfigure_wrapper=_SUBFIG_WRAPPER):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return latex code to draw the graph(s) in `Gbunch`\\n\\n    The TikZ drawing utility in LaTeX is used to draw the graph(s).\\n    If `Gbunch` is a graph, it is drawn in a figure environment.\\n    If `Gbunch` is an iterable of graphs, each is drawn in a subfigure environment\\n    within a single figure environment.\\n\\n    If `as_document` is True, the figure is wrapped inside a document environment\\n    so that the resulting string is ready to be compiled by LaTeX. Otherwise,\\n    the string is ready for inclusion in a larger tex document using ``\\\\include``\\n    or ``\\\\input`` statements.\\n\\n    Parameters\\n    ==========\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        The NetworkX graph to be drawn or an iterable of graphs\\n        to be drawn inside subfigures of a single figure.\\n    pos : string or list of strings\\n        The name of the node attribute on `G` that holds the position of each node.\\n        Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n        They can also be strings to denote positions in TikZ style, such as (x, y)\\n        or (angle:radius).\\n        If a dict, it should be keyed by node to a position.\\n        If an empty dict, a circular layout is computed by TikZ.\\n        If you are drawing many graphs in subfigures, use a list of position dicts.\\n    tikz_options : string\\n        The tikzpicture options description defining the options for the picture.\\n        Often large scale options like `[scale=2]`.\\n    default_node_options : string\\n        The draw options for a path of nodes. Individual node options override these.\\n    node_options : string or dict\\n        The name of the node attribute on `G` that holds the options for each node.\\n        Or a dict keyed by node to a string holding the options for that node.\\n    node_label : string or dict\\n        The name of the node attribute on `G` that holds the node label (text)\\n        displayed for each node. If the attribute is \"\" or not present, the node\\n        itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n        Or a dict keyed by node to a string holding the label for that node.\\n    default_edge_options : string\\n        The options for the scope drawing all edges. The default is \"[-]\" for\\n        undirected graphs and \"[->]\" for directed graphs.\\n    edge_options : string or dict\\n        The name of the edge attribute on `G` that holds the options for each edge.\\n        If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n        \"loop,\" is added to the options for the self-loop edge. Hence you can\\n        use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n        Or a dict keyed by edge to a string holding the options for that edge.\\n    edge_label : string or dict\\n        The name of the edge attribute on `G` that holds the edge label (text)\\n        displayed for each edge. If the attribute is \"\" or not present, no edge\\n        label is drawn.\\n        Or a dict keyed by edge to a string holding the label for that edge.\\n    edge_label_options : string or dict\\n        The name of the edge attribute on `G` that holds the label options for\\n        each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n        Or a dict keyed by edge to a string holding the label options for that edge.\\n    caption : string\\n        The caption string for the figure environment\\n    latex_label : string\\n        The latex label used for the figure for easy referral from the main text\\n    sub_captions : list of strings\\n        The sub_caption string for each subfigure in the figure\\n    sub_latex_labels : list of strings\\n        The latex label for each subfigure in the figure\\n    n_rows : int\\n        The number of rows of subfigures to arrange for multiple graphs\\n    as_document : bool\\n        Whether to wrap the latex code in a document environment for compiling\\n    document_wrapper : formatted text string with variable ``content``.\\n        This text is called to evaluate the content embedded in a document\\n        environment with a preamble setting up TikZ.\\n    figure_wrapper : formatted text string\\n        This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n    subfigure_wrapper : formatted text string\\n        This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n        It wraps the content and if a caption is provided, adds the latex code for\\n        that caption, and if a label is provided, adds the latex code for a label.\\n        The size is the vertical size of each row of subfigures as a fraction.\\n\\n    Returns\\n    =======\\n    latex_code : string\\n        The text string which draws the desired graph(s) when compiled by LaTeX.\\n\\n    See Also\\n    ========\\n    write_latex\\n    to_latex_raw\\n    '\n    if hasattr(Gbunch, 'adj'):\n        raw = to_latex_raw(Gbunch, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n    else:\n        sbf = subfigure_wrapper\n        size = 1 / n_rows\n        N = len(Gbunch)\n        if isinstance(pos, str | dict):\n            pos = [pos] * N\n        if sub_captions is None:\n            sub_captions = [''] * N\n        if sub_labels is None:\n            sub_labels = [''] * N\n        if not len(Gbunch) == len(pos) == len(sub_captions) == len(sub_labels):\n            raise nx.NetworkXError('length of Gbunch, sub_captions and sub_figures must agree')\n        raw = ''\n        for (G, pos, subcap, sublbl) in zip(Gbunch, pos, sub_captions, sub_labels):\n            subraw = to_latex_raw(G, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n            cap = f'    \\\\caption{{{subcap}}}' if subcap else ''\n            lbl = f'\\\\label{{{sublbl}}}' if sublbl else ''\n            raw += sbf.format(size=size, content=subraw, caption=cap, label=lbl)\n            raw += '\\n'\n    raw = raw[:-1]\n    cap = f'\\n  \\\\caption{{{caption}}}' if caption else ''\n    lbl = f'\\\\label{{{latex_label}}}' if latex_label else ''\n    fig = figure_wrapper.format(content=raw, caption=cap, label=lbl)\n    if as_document:\n        return document_wrapper.format(content=fig)\n    return fig"
        ]
    },
    {
        "func_name": "write_latex",
        "original": "@nx.utils.open_file(1, mode='w')\ndef write_latex(Gbunch, path, **options):\n    \"\"\"Write the latex code to draw the graph(s) onto `path`.\n\n    This convenience function creates the latex drawing code as a string\n    and writes that to a file ready to be compiled when `as_document` is True\n    or ready to be ``import`` ed or ``include`` ed into your main LaTeX document.\n\n    The `path` argument can be a string filename or a file handle to write to.\n\n    Parameters\n    ----------\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\n        If Gbunch is a graph, it is drawn in a figure environment.\n        If Gbunch is an iterable of graphs, each is drawn in a subfigure\n        environment within a single figure environment.\n    path : filename\n        Filename or file handle to write to\n    options : dict\n        By default, TikZ is used with options: (others are ignored)::\n\n            pos : string or dict or list\n                The name of the node attribute on `G` that holds the position of each node.\n                Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n                They can also be strings to denote positions in TikZ style, such as (x, y)\n                or (angle:radius).\n                If a dict, it should be keyed by node to a position.\n                If an empty dict, a circular layout is computed by TikZ.\n                If you are drawing many graphs in subfigures, use a list of position dicts.\n            tikz_options : string\n                The tikzpicture options description defining the options for the picture.\n                Often large scale options like `[scale=2]`.\n            default_node_options : string\n                The draw options for a path of nodes. Individual node options override these.\n            node_options : string or dict\n                The name of the node attribute on `G` that holds the options for each node.\n                Or a dict keyed by node to a string holding the options for that node.\n            node_label : string or dict\n                The name of the node attribute on `G` that holds the node label (text)\n                displayed for each node. If the attribute is \"\" or not present, the node\n                itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n                Or a dict keyed by node to a string holding the label for that node.\n            default_edge_options : string\n                The options for the scope drawing all edges. The default is \"[-]\" for\n                undirected graphs and \"[->]\" for directed graphs.\n            edge_options : string or dict\n                The name of the edge attribute on `G` that holds the options for each edge.\n                If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n                \"loop,\" is added to the options for the self-loop edge. Hence you can\n                use \"[loop above]\" explicitly, but the default is \"[loop]\".\n                Or a dict keyed by edge to a string holding the options for that edge.\n            edge_label : string or dict\n                The name of the edge attribute on `G` that holds the edge label (text)\n                displayed for each edge. If the attribute is \"\" or not present, no edge\n                label is drawn.\n                Or a dict keyed by edge to a string holding the label for that edge.\n            edge_label_options : string or dict\n                The name of the edge attribute on `G` that holds the label options for\n                each edge. For example, \"[sloped,above,blue]\". The default is no options.\n                Or a dict keyed by edge to a string holding the label options for that edge.\n            caption : string\n                The caption string for the figure environment\n            latex_label : string\n                The latex label used for the figure for easy referral from the main text\n            sub_captions : list of strings\n                The sub_caption string for each subfigure in the figure\n            sub_latex_labels : list of strings\n                The latex label for each subfigure in the figure\n            n_rows : int\n                The number of rows of subfigures to arrange for multiple graphs\n            as_document : bool\n                Whether to wrap the latex code in a document environment for compiling\n            document_wrapper : formatted text string with variable ``content``.\n                This text is called to evaluate the content embedded in a document\n                environment with a preamble setting up the TikZ syntax.\n            figure_wrapper : formatted text string\n                This text is evaluated with variables ``content``, ``caption`` and ``label``.\n                It wraps the content and if a caption is provided, adds the latex code for\n                that caption, and if a label is provided, adds the latex code for a label.\n            subfigure_wrapper : formatted text string\n                This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\n                It wraps the content and if a caption is provided, adds the latex code for\n                that caption, and if a label is provided, adds the latex code for a label.\n                The size is the vertical size of each row of subfigures as a fraction.\n\n    See Also\n    ========\n    to_latex\n    \"\"\"\n    path.write(to_latex(Gbunch, **options))",
        "mutated": [
            "@nx.utils.open_file(1, mode='w')\ndef write_latex(Gbunch, path, **options):\n    if False:\n        i = 10\n    'Write the latex code to draw the graph(s) onto `path`.\\n\\n    This convenience function creates the latex drawing code as a string\\n    and writes that to a file ready to be compiled when `as_document` is True\\n    or ready to be ``import`` ed or ``include`` ed into your main LaTeX document.\\n\\n    The `path` argument can be a string filename or a file handle to write to.\\n\\n    Parameters\\n    ----------\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        If Gbunch is a graph, it is drawn in a figure environment.\\n        If Gbunch is an iterable of graphs, each is drawn in a subfigure\\n        environment within a single figure environment.\\n    path : filename\\n        Filename or file handle to write to\\n    options : dict\\n        By default, TikZ is used with options: (others are ignored)::\\n\\n            pos : string or dict or list\\n                The name of the node attribute on `G` that holds the position of each node.\\n                Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n                They can also be strings to denote positions in TikZ style, such as (x, y)\\n                or (angle:radius).\\n                If a dict, it should be keyed by node to a position.\\n                If an empty dict, a circular layout is computed by TikZ.\\n                If you are drawing many graphs in subfigures, use a list of position dicts.\\n            tikz_options : string\\n                The tikzpicture options description defining the options for the picture.\\n                Often large scale options like `[scale=2]`.\\n            default_node_options : string\\n                The draw options for a path of nodes. Individual node options override these.\\n            node_options : string or dict\\n                The name of the node attribute on `G` that holds the options for each node.\\n                Or a dict keyed by node to a string holding the options for that node.\\n            node_label : string or dict\\n                The name of the node attribute on `G` that holds the node label (text)\\n                displayed for each node. If the attribute is \"\" or not present, the node\\n                itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n                Or a dict keyed by node to a string holding the label for that node.\\n            default_edge_options : string\\n                The options for the scope drawing all edges. The default is \"[-]\" for\\n                undirected graphs and \"[->]\" for directed graphs.\\n            edge_options : string or dict\\n                The name of the edge attribute on `G` that holds the options for each edge.\\n                If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n                \"loop,\" is added to the options for the self-loop edge. Hence you can\\n                use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n                Or a dict keyed by edge to a string holding the options for that edge.\\n            edge_label : string or dict\\n                The name of the edge attribute on `G` that holds the edge label (text)\\n                displayed for each edge. If the attribute is \"\" or not present, no edge\\n                label is drawn.\\n                Or a dict keyed by edge to a string holding the label for that edge.\\n            edge_label_options : string or dict\\n                The name of the edge attribute on `G` that holds the label options for\\n                each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n                Or a dict keyed by edge to a string holding the label options for that edge.\\n            caption : string\\n                The caption string for the figure environment\\n            latex_label : string\\n                The latex label used for the figure for easy referral from the main text\\n            sub_captions : list of strings\\n                The sub_caption string for each subfigure in the figure\\n            sub_latex_labels : list of strings\\n                The latex label for each subfigure in the figure\\n            n_rows : int\\n                The number of rows of subfigures to arrange for multiple graphs\\n            as_document : bool\\n                Whether to wrap the latex code in a document environment for compiling\\n            document_wrapper : formatted text string with variable ``content``.\\n                This text is called to evaluate the content embedded in a document\\n                environment with a preamble setting up the TikZ syntax.\\n            figure_wrapper : formatted text string\\n                This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n            subfigure_wrapper : formatted text string\\n                This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n                The size is the vertical size of each row of subfigures as a fraction.\\n\\n    See Also\\n    ========\\n    to_latex\\n    '\n    path.write(to_latex(Gbunch, **options))",
            "@nx.utils.open_file(1, mode='w')\ndef write_latex(Gbunch, path, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Write the latex code to draw the graph(s) onto `path`.\\n\\n    This convenience function creates the latex drawing code as a string\\n    and writes that to a file ready to be compiled when `as_document` is True\\n    or ready to be ``import`` ed or ``include`` ed into your main LaTeX document.\\n\\n    The `path` argument can be a string filename or a file handle to write to.\\n\\n    Parameters\\n    ----------\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        If Gbunch is a graph, it is drawn in a figure environment.\\n        If Gbunch is an iterable of graphs, each is drawn in a subfigure\\n        environment within a single figure environment.\\n    path : filename\\n        Filename or file handle to write to\\n    options : dict\\n        By default, TikZ is used with options: (others are ignored)::\\n\\n            pos : string or dict or list\\n                The name of the node attribute on `G` that holds the position of each node.\\n                Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n                They can also be strings to denote positions in TikZ style, such as (x, y)\\n                or (angle:radius).\\n                If a dict, it should be keyed by node to a position.\\n                If an empty dict, a circular layout is computed by TikZ.\\n                If you are drawing many graphs in subfigures, use a list of position dicts.\\n            tikz_options : string\\n                The tikzpicture options description defining the options for the picture.\\n                Often large scale options like `[scale=2]`.\\n            default_node_options : string\\n                The draw options for a path of nodes. Individual node options override these.\\n            node_options : string or dict\\n                The name of the node attribute on `G` that holds the options for each node.\\n                Or a dict keyed by node to a string holding the options for that node.\\n            node_label : string or dict\\n                The name of the node attribute on `G` that holds the node label (text)\\n                displayed for each node. If the attribute is \"\" or not present, the node\\n                itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n                Or a dict keyed by node to a string holding the label for that node.\\n            default_edge_options : string\\n                The options for the scope drawing all edges. The default is \"[-]\" for\\n                undirected graphs and \"[->]\" for directed graphs.\\n            edge_options : string or dict\\n                The name of the edge attribute on `G` that holds the options for each edge.\\n                If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n                \"loop,\" is added to the options for the self-loop edge. Hence you can\\n                use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n                Or a dict keyed by edge to a string holding the options for that edge.\\n            edge_label : string or dict\\n                The name of the edge attribute on `G` that holds the edge label (text)\\n                displayed for each edge. If the attribute is \"\" or not present, no edge\\n                label is drawn.\\n                Or a dict keyed by edge to a string holding the label for that edge.\\n            edge_label_options : string or dict\\n                The name of the edge attribute on `G` that holds the label options for\\n                each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n                Or a dict keyed by edge to a string holding the label options for that edge.\\n            caption : string\\n                The caption string for the figure environment\\n            latex_label : string\\n                The latex label used for the figure for easy referral from the main text\\n            sub_captions : list of strings\\n                The sub_caption string for each subfigure in the figure\\n            sub_latex_labels : list of strings\\n                The latex label for each subfigure in the figure\\n            n_rows : int\\n                The number of rows of subfigures to arrange for multiple graphs\\n            as_document : bool\\n                Whether to wrap the latex code in a document environment for compiling\\n            document_wrapper : formatted text string with variable ``content``.\\n                This text is called to evaluate the content embedded in a document\\n                environment with a preamble setting up the TikZ syntax.\\n            figure_wrapper : formatted text string\\n                This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n            subfigure_wrapper : formatted text string\\n                This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n                The size is the vertical size of each row of subfigures as a fraction.\\n\\n    See Also\\n    ========\\n    to_latex\\n    '\n    path.write(to_latex(Gbunch, **options))",
            "@nx.utils.open_file(1, mode='w')\ndef write_latex(Gbunch, path, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Write the latex code to draw the graph(s) onto `path`.\\n\\n    This convenience function creates the latex drawing code as a string\\n    and writes that to a file ready to be compiled when `as_document` is True\\n    or ready to be ``import`` ed or ``include`` ed into your main LaTeX document.\\n\\n    The `path` argument can be a string filename or a file handle to write to.\\n\\n    Parameters\\n    ----------\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        If Gbunch is a graph, it is drawn in a figure environment.\\n        If Gbunch is an iterable of graphs, each is drawn in a subfigure\\n        environment within a single figure environment.\\n    path : filename\\n        Filename or file handle to write to\\n    options : dict\\n        By default, TikZ is used with options: (others are ignored)::\\n\\n            pos : string or dict or list\\n                The name of the node attribute on `G` that holds the position of each node.\\n                Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n                They can also be strings to denote positions in TikZ style, such as (x, y)\\n                or (angle:radius).\\n                If a dict, it should be keyed by node to a position.\\n                If an empty dict, a circular layout is computed by TikZ.\\n                If you are drawing many graphs in subfigures, use a list of position dicts.\\n            tikz_options : string\\n                The tikzpicture options description defining the options for the picture.\\n                Often large scale options like `[scale=2]`.\\n            default_node_options : string\\n                The draw options for a path of nodes. Individual node options override these.\\n            node_options : string or dict\\n                The name of the node attribute on `G` that holds the options for each node.\\n                Or a dict keyed by node to a string holding the options for that node.\\n            node_label : string or dict\\n                The name of the node attribute on `G` that holds the node label (text)\\n                displayed for each node. If the attribute is \"\" or not present, the node\\n                itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n                Or a dict keyed by node to a string holding the label for that node.\\n            default_edge_options : string\\n                The options for the scope drawing all edges. The default is \"[-]\" for\\n                undirected graphs and \"[->]\" for directed graphs.\\n            edge_options : string or dict\\n                The name of the edge attribute on `G` that holds the options for each edge.\\n                If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n                \"loop,\" is added to the options for the self-loop edge. Hence you can\\n                use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n                Or a dict keyed by edge to a string holding the options for that edge.\\n            edge_label : string or dict\\n                The name of the edge attribute on `G` that holds the edge label (text)\\n                displayed for each edge. If the attribute is \"\" or not present, no edge\\n                label is drawn.\\n                Or a dict keyed by edge to a string holding the label for that edge.\\n            edge_label_options : string or dict\\n                The name of the edge attribute on `G` that holds the label options for\\n                each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n                Or a dict keyed by edge to a string holding the label options for that edge.\\n            caption : string\\n                The caption string for the figure environment\\n            latex_label : string\\n                The latex label used for the figure for easy referral from the main text\\n            sub_captions : list of strings\\n                The sub_caption string for each subfigure in the figure\\n            sub_latex_labels : list of strings\\n                The latex label for each subfigure in the figure\\n            n_rows : int\\n                The number of rows of subfigures to arrange for multiple graphs\\n            as_document : bool\\n                Whether to wrap the latex code in a document environment for compiling\\n            document_wrapper : formatted text string with variable ``content``.\\n                This text is called to evaluate the content embedded in a document\\n                environment with a preamble setting up the TikZ syntax.\\n            figure_wrapper : formatted text string\\n                This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n            subfigure_wrapper : formatted text string\\n                This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n                The size is the vertical size of each row of subfigures as a fraction.\\n\\n    See Also\\n    ========\\n    to_latex\\n    '\n    path.write(to_latex(Gbunch, **options))",
            "@nx.utils.open_file(1, mode='w')\ndef write_latex(Gbunch, path, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Write the latex code to draw the graph(s) onto `path`.\\n\\n    This convenience function creates the latex drawing code as a string\\n    and writes that to a file ready to be compiled when `as_document` is True\\n    or ready to be ``import`` ed or ``include`` ed into your main LaTeX document.\\n\\n    The `path` argument can be a string filename or a file handle to write to.\\n\\n    Parameters\\n    ----------\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        If Gbunch is a graph, it is drawn in a figure environment.\\n        If Gbunch is an iterable of graphs, each is drawn in a subfigure\\n        environment within a single figure environment.\\n    path : filename\\n        Filename or file handle to write to\\n    options : dict\\n        By default, TikZ is used with options: (others are ignored)::\\n\\n            pos : string or dict or list\\n                The name of the node attribute on `G` that holds the position of each node.\\n                Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n                They can also be strings to denote positions in TikZ style, such as (x, y)\\n                or (angle:radius).\\n                If a dict, it should be keyed by node to a position.\\n                If an empty dict, a circular layout is computed by TikZ.\\n                If you are drawing many graphs in subfigures, use a list of position dicts.\\n            tikz_options : string\\n                The tikzpicture options description defining the options for the picture.\\n                Often large scale options like `[scale=2]`.\\n            default_node_options : string\\n                The draw options for a path of nodes. Individual node options override these.\\n            node_options : string or dict\\n                The name of the node attribute on `G` that holds the options for each node.\\n                Or a dict keyed by node to a string holding the options for that node.\\n            node_label : string or dict\\n                The name of the node attribute on `G` that holds the node label (text)\\n                displayed for each node. If the attribute is \"\" or not present, the node\\n                itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n                Or a dict keyed by node to a string holding the label for that node.\\n            default_edge_options : string\\n                The options for the scope drawing all edges. The default is \"[-]\" for\\n                undirected graphs and \"[->]\" for directed graphs.\\n            edge_options : string or dict\\n                The name of the edge attribute on `G` that holds the options for each edge.\\n                If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n                \"loop,\" is added to the options for the self-loop edge. Hence you can\\n                use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n                Or a dict keyed by edge to a string holding the options for that edge.\\n            edge_label : string or dict\\n                The name of the edge attribute on `G` that holds the edge label (text)\\n                displayed for each edge. If the attribute is \"\" or not present, no edge\\n                label is drawn.\\n                Or a dict keyed by edge to a string holding the label for that edge.\\n            edge_label_options : string or dict\\n                The name of the edge attribute on `G` that holds the label options for\\n                each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n                Or a dict keyed by edge to a string holding the label options for that edge.\\n            caption : string\\n                The caption string for the figure environment\\n            latex_label : string\\n                The latex label used for the figure for easy referral from the main text\\n            sub_captions : list of strings\\n                The sub_caption string for each subfigure in the figure\\n            sub_latex_labels : list of strings\\n                The latex label for each subfigure in the figure\\n            n_rows : int\\n                The number of rows of subfigures to arrange for multiple graphs\\n            as_document : bool\\n                Whether to wrap the latex code in a document environment for compiling\\n            document_wrapper : formatted text string with variable ``content``.\\n                This text is called to evaluate the content embedded in a document\\n                environment with a preamble setting up the TikZ syntax.\\n            figure_wrapper : formatted text string\\n                This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n            subfigure_wrapper : formatted text string\\n                This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n                The size is the vertical size of each row of subfigures as a fraction.\\n\\n    See Also\\n    ========\\n    to_latex\\n    '\n    path.write(to_latex(Gbunch, **options))",
            "@nx.utils.open_file(1, mode='w')\ndef write_latex(Gbunch, path, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Write the latex code to draw the graph(s) onto `path`.\\n\\n    This convenience function creates the latex drawing code as a string\\n    and writes that to a file ready to be compiled when `as_document` is True\\n    or ready to be ``import`` ed or ``include`` ed into your main LaTeX document.\\n\\n    The `path` argument can be a string filename or a file handle to write to.\\n\\n    Parameters\\n    ----------\\n    Gbunch : NetworkX graph or iterable of NetworkX graphs\\n        If Gbunch is a graph, it is drawn in a figure environment.\\n        If Gbunch is an iterable of graphs, each is drawn in a subfigure\\n        environment within a single figure environment.\\n    path : filename\\n        Filename or file handle to write to\\n    options : dict\\n        By default, TikZ is used with options: (others are ignored)::\\n\\n            pos : string or dict or list\\n                The name of the node attribute on `G` that holds the position of each node.\\n                Positions can be sequences of length 2 with numbers for (x,y) coordinates.\\n                They can also be strings to denote positions in TikZ style, such as (x, y)\\n                or (angle:radius).\\n                If a dict, it should be keyed by node to a position.\\n                If an empty dict, a circular layout is computed by TikZ.\\n                If you are drawing many graphs in subfigures, use a list of position dicts.\\n            tikz_options : string\\n                The tikzpicture options description defining the options for the picture.\\n                Often large scale options like `[scale=2]`.\\n            default_node_options : string\\n                The draw options for a path of nodes. Individual node options override these.\\n            node_options : string or dict\\n                The name of the node attribute on `G` that holds the options for each node.\\n                Or a dict keyed by node to a string holding the options for that node.\\n            node_label : string or dict\\n                The name of the node attribute on `G` that holds the node label (text)\\n                displayed for each node. If the attribute is \"\" or not present, the node\\n                itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\\n                Or a dict keyed by node to a string holding the label for that node.\\n            default_edge_options : string\\n                The options for the scope drawing all edges. The default is \"[-]\" for\\n                undirected graphs and \"[->]\" for directed graphs.\\n            edge_options : string or dict\\n                The name of the edge attribute on `G` that holds the options for each edge.\\n                If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\\n                \"loop,\" is added to the options for the self-loop edge. Hence you can\\n                use \"[loop above]\" explicitly, but the default is \"[loop]\".\\n                Or a dict keyed by edge to a string holding the options for that edge.\\n            edge_label : string or dict\\n                The name of the edge attribute on `G` that holds the edge label (text)\\n                displayed for each edge. If the attribute is \"\" or not present, no edge\\n                label is drawn.\\n                Or a dict keyed by edge to a string holding the label for that edge.\\n            edge_label_options : string or dict\\n                The name of the edge attribute on `G` that holds the label options for\\n                each edge. For example, \"[sloped,above,blue]\". The default is no options.\\n                Or a dict keyed by edge to a string holding the label options for that edge.\\n            caption : string\\n                The caption string for the figure environment\\n            latex_label : string\\n                The latex label used for the figure for easy referral from the main text\\n            sub_captions : list of strings\\n                The sub_caption string for each subfigure in the figure\\n            sub_latex_labels : list of strings\\n                The latex label for each subfigure in the figure\\n            n_rows : int\\n                The number of rows of subfigures to arrange for multiple graphs\\n            as_document : bool\\n                Whether to wrap the latex code in a document environment for compiling\\n            document_wrapper : formatted text string with variable ``content``.\\n                This text is called to evaluate the content embedded in a document\\n                environment with a preamble setting up the TikZ syntax.\\n            figure_wrapper : formatted text string\\n                This text is evaluated with variables ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n            subfigure_wrapper : formatted text string\\n                This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\\n                It wraps the content and if a caption is provided, adds the latex code for\\n                that caption, and if a label is provided, adds the latex code for a label.\\n                The size is the vertical size of each row of subfigures as a fraction.\\n\\n    See Also\\n    ========\\n    to_latex\\n    '\n    path.write(to_latex(Gbunch, **options))"
        ]
    }
]