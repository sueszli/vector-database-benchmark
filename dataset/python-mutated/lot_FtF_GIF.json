[
    {
        "func_name": "map_faults",
        "original": "def map_faults(Run_name, Model_list, scenarios_names_list, ScL_complet_list, BG_hyp_list, sample_list, b_value_list, MFD_type_list, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, File_bg, FileName_Prop, File_geom, plot_sr_use, visual_FtF, sub_area_file):\n    nb_on_maps = False\n    use_basemap = False\n    available_sets = read_input.extract_sc_input('input/' + Run_name + '/ruptures.txt')\n    for Model in Model_list:\n        if not '.geojson' in FileName_Prop:\n            Prop = np.genfromtxt(FileName_Prop, dtype=['U100', 'U100', 'f8', 'U100', 'U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'U100', 'f8'], skip_header=1)\n            Column_model_name = list(map(lambda i: Prop[i][0], range(len(Prop))))\n            Column_fault_name = list(map(lambda i: Prop[i][1], range(len(Prop))))\n            index_model = np.where(np.array(Column_model_name) == Model)[0]\n            Prop = np.take(Prop, index_model)\n            faults_names = np.array(Column_fault_name[index_model[0]:index_model[-1] + 1])\n            faults_names = list(faults_names)\n        else:\n            with open(FileName_Prop) as f:\n                gj = geojson.load(f)\n            faults = gj['features']\n            faults_names = []\n            for fi in range(len(faults)):\n                if faults[fi]['properties']['model'] == Model:\n                    faults_names.append(str(faults[fi]['properties']['si']))\n        geom_scenar = Geometry_scenario.Geom_scenar(faults_names, File_geom, Model)\n        faults_lon = geom_scenar.faults_lon\n        faults_lat = geom_scenar.faults_lat\n        (Column_Fault_name, Depths) = geom.FaultGeometry(Model, File_geom)\n        (Lon_bg, Lat_bg) = bg.geom(Model, File_bg)\n        fault_geom = {}\n        index_fault = 0\n        for Fault_name in faults_names:\n            lons = faults_lon[index_fault]\n            lats = faults_lat[index_fault]\n            i_d = np.where(np.array(Column_Fault_name) == Fault_name)\n            depth = list(map(lambda i: Depths[i], i_d[0]))\n            (dip, oriented, upper_sismo_depth, lower_sismo_depth) = geom.FaultProperties(FileName_Prop, Fault_name, Model)\n            if depth[0] == 'sf':\n                (trace_lon, trace_lat, plot_trace, polygon) = geom.get_sf_polygon(lons, lats, upper_sismo_depth, lower_sismo_depth, dip, oriented)\n            else:\n                (trace_lon, trace_lat) = ([], [])\n                plot_trace = False\n                (lon_top, lon_bottom, lat_top, lat_bottom) = ([], [], [], [])\n                for (lon_i, lat_i, d_i) in zip(lons, lats, depth):\n                    if d_i == min(depth):\n                        lon_top.append(lon_i)\n                        lat_top.append(lat_i)\n                    if d_i == max(depth):\n                        lon_bottom.append(lon_i)\n                        lat_bottom.append(lat_i)\n                poly_lons = np.concatenate([lon_top, np.array(list(reversed(lon_bottom)))])\n                poly_lats = np.concatenate([lat_top, np.array(list(reversed(lat_bottom)))])\n                polygon = [poly_lons, poly_lats]\n            fault_geom.update({index_fault: {'name': Fault_name, 'trace_lon': trace_lon, 'trace_lat': trace_lat, 'plot_trace': plot_trace, 'polygon': polygon}})\n            index_fault += 1\n        '########################\\n        Print the faults activated for each scenario\\n        #########################'\n        if visual_FtF == True and use_basemap == True:\n            for scenario_set in scenarios_names_list:\n                file_names = []\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                log_Mmax_file = str(Run_name) + '/' + str(Model) + '/Log/Mmax_sample_' + str(ScL_complet_list[0]) + '_' + scenario_set + '_1.txt'\n                (sources_names, sources_Mmax, sources_Lengths, sources_Areas) = Read_file.read_file_Mmax_log(log_Mmax_file)\n                rupture_set = available_sets['sc_' + scenario_set]\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                index_rupt = 0\n                for rupt in rupture_set:\n                    if len(Lon_bg) != 0:\n                        maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n                    m1 = copy.copy(m)\n                    fault_colors = []\n                    for fault in faults_names:\n                        if fault in rupt:\n                            fault_colors.append('r')\n                        else:\n                            fault_colors.append('k')\n                    title = str()\n                    i = 0\n                    for fault in rupt:\n                        title += ' ' + str(fault)\n                        i += 1\n                        if i == 6:\n                            title += '\\n'\n                            i = 0\n                    Mmax = sources_Mmax[len(faults_names) + index_rupt]\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set + '/' + str(index_rupt) + '.png'\n                    maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, Mmax=Mmax)\n                    index_rupt += 1\n        '########################\\n        Print the map of the model\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='h')\n            if len(Lon_bg) != 0:\n                maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n            fault_colors = ['k' for fault in faults_names]\n            title = 'Map of the model : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map.png'\n            m.drawcoastlines(linewidth=0.1)\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model_sub_area in Model_list:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        maps_utils.draw_screen_poly(sub_area_lon_i, sub_area_lat_i, m, 'k', 0.01, 0.1, 'k')\n                        (x, y) = m(sub_area_lon_i, sub_area_lat_i)\n                        m.plot(x, y, linewidth=0.2, color='k', linestyle='dotted')\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=400, use_arcgis=True)\n        '########################\\n        Print the sliprate map\\n        #########################'\n        mean_param = np.genfromtxt(Run_name + '/analysis/txt_files/mean_parameters_faults.txt', dtype=['U100', 'U100', 'U1000', 'f8', 'f8'], delimiter='\\t')\n        model_mean_param = list(map(lambda i: mean_param[i][0], range(len(mean_param))))\n        set_mean_param = list(map(lambda i: mean_param[i][1], range(len(mean_param))))\n        fault_name_mean_param = list(map(lambda i: mean_param[i][2], range(len(mean_param))))\n        sr_mean = list(map(lambda i: mean_param[i][3], range(len(mean_param))))\n        Mmax_mean = list(map(lambda i: mean_param[i][4], range(len(mean_param))))\n        index_model = np.where(np.array(model_mean_param) == Model)[0]\n        set_mean_param_model = np.take(set_mean_param, index_model)\n        fault_name_mean_param_model = np.take(fault_name_mean_param, index_model)\n        sr_mean_model = np.take(sr_mean, index_model)\n        Mmax_mean_model = np.take(Mmax_mean, index_model)\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n            title = 'Slip rate : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_sliprate.png'\n        fault_colors = []\n        for fault in faults_names:\n            index_fault = np.where(np.array(fault_name_mean_param_model) == fault)[0][0]\n            sr = sr_mean_model[index_fault]\n            cmap = matplotlib.cm.get_cmap('rainbow')\n            rgba = cmap(float(sr) / max(sr_mean))\n            fault_colors.append(rgba)\n        if use_basemap == True:\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the  Mmax map\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            if use_basemap == True:\n                m1 = copy.copy(m)\n                title = 'Slip rate : ' + Model + ' ' + scenario_set\n                figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_Mmax_' + scenario_set + '.png'\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            sr_mean_set = np.take(sr_mean_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            fault_colors = []\n            for fault in faults_names:\n                index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                Mmax = Mmax_mean_set[index_fault]\n                cmap = matplotlib.cm.get_cmap('rainbow')\n                rgba = cmap((float(Mmax) - min(Mmax_mean)) / (max(Mmax_mean) - min(Mmax_mean)))\n                fault_colors.append(rgba)\n            if use_basemap == True:\n                maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the NMS\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            for MFD_type in MFD_type_list:\n                if use_basemap == True:\n                    title = 'NMS : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_NMS_' + MFD_type + '_' + str(scenario_set) + '.png'\n                slip_rep_data = np.genfromtxt(Run_name + '/analysis/txt_files/slip_rep_on_faults_mean_' + str(Model) + '_' + MFD_type + '_' + str(scenario_set) + '.txt', dtype=['U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8'], delimiter='\\t')\n                fault_name_rep = list(map(lambda i: slip_rep_data[i][0], range(len(slip_rep_data))))\n                p_NMS = list(map(lambda i: slip_rep_data[i][14], range(len(slip_rep_data))))\n                if use_basemap == True:\n                    m1 = copy.copy(m)\n                if use_basemap == True:\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        if NMS_i >= 50.0:\n                            NMS_i = 50.0\n                        rgba = cmap(float(NMS_i * 2.0) / 100.0)\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Print the seismic sliprate\\n                #########################'\n                if use_basemap == True:\n                    m2 = copy.copy(m)\n                    title = 'Seismic slip rate : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_seismicsliprate_' + MFD_type + '_' + str(scenario_set) + '.png'\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                        sr = sr_mean[index_fault]\n                        sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        rgba = cmap(sr_seismic_i / max(sr_mean))\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m2, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Build the geojson file\\n                #########################'\n                features = []\n                id = 0\n                for fault in faults_names:\n                    index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                    NMS_i = p_NMS[index_fault]\n                    index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                    sr = sr_mean[index_fault]\n                    sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                    index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                    Mmax = Mmax_mean_set[index_fault]\n                    trace = []\n                    for (lon_i, lat_i) in zip(fault_geom[id]['trace_lon'], fault_geom[id]['trace_lat']):\n                        trace.append([lon_i, lat_i])\n                    trace = LineString(trace)\n                    features.append(Feature(geometry=trace, properties={'id': id, 'name': fault, 'Mmax': Mmax, 'sliprate': sr, 'NMS': NMS_i, 'sr_seismic': sr_seismic_i}))\n                    id += 1\n                feature_collection = FeatureCollection(features)\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                with open(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + MFD_type + '_' + str(scenario_set) + '.geojson', 'w') as f:\n                    dump(feature_collection, f)",
        "mutated": [
            "def map_faults(Run_name, Model_list, scenarios_names_list, ScL_complet_list, BG_hyp_list, sample_list, b_value_list, MFD_type_list, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, File_bg, FileName_Prop, File_geom, plot_sr_use, visual_FtF, sub_area_file):\n    if False:\n        i = 10\n    nb_on_maps = False\n    use_basemap = False\n    available_sets = read_input.extract_sc_input('input/' + Run_name + '/ruptures.txt')\n    for Model in Model_list:\n        if not '.geojson' in FileName_Prop:\n            Prop = np.genfromtxt(FileName_Prop, dtype=['U100', 'U100', 'f8', 'U100', 'U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'U100', 'f8'], skip_header=1)\n            Column_model_name = list(map(lambda i: Prop[i][0], range(len(Prop))))\n            Column_fault_name = list(map(lambda i: Prop[i][1], range(len(Prop))))\n            index_model = np.where(np.array(Column_model_name) == Model)[0]\n            Prop = np.take(Prop, index_model)\n            faults_names = np.array(Column_fault_name[index_model[0]:index_model[-1] + 1])\n            faults_names = list(faults_names)\n        else:\n            with open(FileName_Prop) as f:\n                gj = geojson.load(f)\n            faults = gj['features']\n            faults_names = []\n            for fi in range(len(faults)):\n                if faults[fi]['properties']['model'] == Model:\n                    faults_names.append(str(faults[fi]['properties']['si']))\n        geom_scenar = Geometry_scenario.Geom_scenar(faults_names, File_geom, Model)\n        faults_lon = geom_scenar.faults_lon\n        faults_lat = geom_scenar.faults_lat\n        (Column_Fault_name, Depths) = geom.FaultGeometry(Model, File_geom)\n        (Lon_bg, Lat_bg) = bg.geom(Model, File_bg)\n        fault_geom = {}\n        index_fault = 0\n        for Fault_name in faults_names:\n            lons = faults_lon[index_fault]\n            lats = faults_lat[index_fault]\n            i_d = np.where(np.array(Column_Fault_name) == Fault_name)\n            depth = list(map(lambda i: Depths[i], i_d[0]))\n            (dip, oriented, upper_sismo_depth, lower_sismo_depth) = geom.FaultProperties(FileName_Prop, Fault_name, Model)\n            if depth[0] == 'sf':\n                (trace_lon, trace_lat, plot_trace, polygon) = geom.get_sf_polygon(lons, lats, upper_sismo_depth, lower_sismo_depth, dip, oriented)\n            else:\n                (trace_lon, trace_lat) = ([], [])\n                plot_trace = False\n                (lon_top, lon_bottom, lat_top, lat_bottom) = ([], [], [], [])\n                for (lon_i, lat_i, d_i) in zip(lons, lats, depth):\n                    if d_i == min(depth):\n                        lon_top.append(lon_i)\n                        lat_top.append(lat_i)\n                    if d_i == max(depth):\n                        lon_bottom.append(lon_i)\n                        lat_bottom.append(lat_i)\n                poly_lons = np.concatenate([lon_top, np.array(list(reversed(lon_bottom)))])\n                poly_lats = np.concatenate([lat_top, np.array(list(reversed(lat_bottom)))])\n                polygon = [poly_lons, poly_lats]\n            fault_geom.update({index_fault: {'name': Fault_name, 'trace_lon': trace_lon, 'trace_lat': trace_lat, 'plot_trace': plot_trace, 'polygon': polygon}})\n            index_fault += 1\n        '########################\\n        Print the faults activated for each scenario\\n        #########################'\n        if visual_FtF == True and use_basemap == True:\n            for scenario_set in scenarios_names_list:\n                file_names = []\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                log_Mmax_file = str(Run_name) + '/' + str(Model) + '/Log/Mmax_sample_' + str(ScL_complet_list[0]) + '_' + scenario_set + '_1.txt'\n                (sources_names, sources_Mmax, sources_Lengths, sources_Areas) = Read_file.read_file_Mmax_log(log_Mmax_file)\n                rupture_set = available_sets['sc_' + scenario_set]\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                index_rupt = 0\n                for rupt in rupture_set:\n                    if len(Lon_bg) != 0:\n                        maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n                    m1 = copy.copy(m)\n                    fault_colors = []\n                    for fault in faults_names:\n                        if fault in rupt:\n                            fault_colors.append('r')\n                        else:\n                            fault_colors.append('k')\n                    title = str()\n                    i = 0\n                    for fault in rupt:\n                        title += ' ' + str(fault)\n                        i += 1\n                        if i == 6:\n                            title += '\\n'\n                            i = 0\n                    Mmax = sources_Mmax[len(faults_names) + index_rupt]\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set + '/' + str(index_rupt) + '.png'\n                    maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, Mmax=Mmax)\n                    index_rupt += 1\n        '########################\\n        Print the map of the model\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='h')\n            if len(Lon_bg) != 0:\n                maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n            fault_colors = ['k' for fault in faults_names]\n            title = 'Map of the model : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map.png'\n            m.drawcoastlines(linewidth=0.1)\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model_sub_area in Model_list:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        maps_utils.draw_screen_poly(sub_area_lon_i, sub_area_lat_i, m, 'k', 0.01, 0.1, 'k')\n                        (x, y) = m(sub_area_lon_i, sub_area_lat_i)\n                        m.plot(x, y, linewidth=0.2, color='k', linestyle='dotted')\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=400, use_arcgis=True)\n        '########################\\n        Print the sliprate map\\n        #########################'\n        mean_param = np.genfromtxt(Run_name + '/analysis/txt_files/mean_parameters_faults.txt', dtype=['U100', 'U100', 'U1000', 'f8', 'f8'], delimiter='\\t')\n        model_mean_param = list(map(lambda i: mean_param[i][0], range(len(mean_param))))\n        set_mean_param = list(map(lambda i: mean_param[i][1], range(len(mean_param))))\n        fault_name_mean_param = list(map(lambda i: mean_param[i][2], range(len(mean_param))))\n        sr_mean = list(map(lambda i: mean_param[i][3], range(len(mean_param))))\n        Mmax_mean = list(map(lambda i: mean_param[i][4], range(len(mean_param))))\n        index_model = np.where(np.array(model_mean_param) == Model)[0]\n        set_mean_param_model = np.take(set_mean_param, index_model)\n        fault_name_mean_param_model = np.take(fault_name_mean_param, index_model)\n        sr_mean_model = np.take(sr_mean, index_model)\n        Mmax_mean_model = np.take(Mmax_mean, index_model)\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n            title = 'Slip rate : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_sliprate.png'\n        fault_colors = []\n        for fault in faults_names:\n            index_fault = np.where(np.array(fault_name_mean_param_model) == fault)[0][0]\n            sr = sr_mean_model[index_fault]\n            cmap = matplotlib.cm.get_cmap('rainbow')\n            rgba = cmap(float(sr) / max(sr_mean))\n            fault_colors.append(rgba)\n        if use_basemap == True:\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the  Mmax map\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            if use_basemap == True:\n                m1 = copy.copy(m)\n                title = 'Slip rate : ' + Model + ' ' + scenario_set\n                figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_Mmax_' + scenario_set + '.png'\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            sr_mean_set = np.take(sr_mean_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            fault_colors = []\n            for fault in faults_names:\n                index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                Mmax = Mmax_mean_set[index_fault]\n                cmap = matplotlib.cm.get_cmap('rainbow')\n                rgba = cmap((float(Mmax) - min(Mmax_mean)) / (max(Mmax_mean) - min(Mmax_mean)))\n                fault_colors.append(rgba)\n            if use_basemap == True:\n                maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the NMS\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            for MFD_type in MFD_type_list:\n                if use_basemap == True:\n                    title = 'NMS : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_NMS_' + MFD_type + '_' + str(scenario_set) + '.png'\n                slip_rep_data = np.genfromtxt(Run_name + '/analysis/txt_files/slip_rep_on_faults_mean_' + str(Model) + '_' + MFD_type + '_' + str(scenario_set) + '.txt', dtype=['U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8'], delimiter='\\t')\n                fault_name_rep = list(map(lambda i: slip_rep_data[i][0], range(len(slip_rep_data))))\n                p_NMS = list(map(lambda i: slip_rep_data[i][14], range(len(slip_rep_data))))\n                if use_basemap == True:\n                    m1 = copy.copy(m)\n                if use_basemap == True:\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        if NMS_i >= 50.0:\n                            NMS_i = 50.0\n                        rgba = cmap(float(NMS_i * 2.0) / 100.0)\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Print the seismic sliprate\\n                #########################'\n                if use_basemap == True:\n                    m2 = copy.copy(m)\n                    title = 'Seismic slip rate : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_seismicsliprate_' + MFD_type + '_' + str(scenario_set) + '.png'\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                        sr = sr_mean[index_fault]\n                        sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        rgba = cmap(sr_seismic_i / max(sr_mean))\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m2, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Build the geojson file\\n                #########################'\n                features = []\n                id = 0\n                for fault in faults_names:\n                    index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                    NMS_i = p_NMS[index_fault]\n                    index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                    sr = sr_mean[index_fault]\n                    sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                    index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                    Mmax = Mmax_mean_set[index_fault]\n                    trace = []\n                    for (lon_i, lat_i) in zip(fault_geom[id]['trace_lon'], fault_geom[id]['trace_lat']):\n                        trace.append([lon_i, lat_i])\n                    trace = LineString(trace)\n                    features.append(Feature(geometry=trace, properties={'id': id, 'name': fault, 'Mmax': Mmax, 'sliprate': sr, 'NMS': NMS_i, 'sr_seismic': sr_seismic_i}))\n                    id += 1\n                feature_collection = FeatureCollection(features)\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                with open(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + MFD_type + '_' + str(scenario_set) + '.geojson', 'w') as f:\n                    dump(feature_collection, f)",
            "def map_faults(Run_name, Model_list, scenarios_names_list, ScL_complet_list, BG_hyp_list, sample_list, b_value_list, MFD_type_list, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, File_bg, FileName_Prop, File_geom, plot_sr_use, visual_FtF, sub_area_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nb_on_maps = False\n    use_basemap = False\n    available_sets = read_input.extract_sc_input('input/' + Run_name + '/ruptures.txt')\n    for Model in Model_list:\n        if not '.geojson' in FileName_Prop:\n            Prop = np.genfromtxt(FileName_Prop, dtype=['U100', 'U100', 'f8', 'U100', 'U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'U100', 'f8'], skip_header=1)\n            Column_model_name = list(map(lambda i: Prop[i][0], range(len(Prop))))\n            Column_fault_name = list(map(lambda i: Prop[i][1], range(len(Prop))))\n            index_model = np.where(np.array(Column_model_name) == Model)[0]\n            Prop = np.take(Prop, index_model)\n            faults_names = np.array(Column_fault_name[index_model[0]:index_model[-1] + 1])\n            faults_names = list(faults_names)\n        else:\n            with open(FileName_Prop) as f:\n                gj = geojson.load(f)\n            faults = gj['features']\n            faults_names = []\n            for fi in range(len(faults)):\n                if faults[fi]['properties']['model'] == Model:\n                    faults_names.append(str(faults[fi]['properties']['si']))\n        geom_scenar = Geometry_scenario.Geom_scenar(faults_names, File_geom, Model)\n        faults_lon = geom_scenar.faults_lon\n        faults_lat = geom_scenar.faults_lat\n        (Column_Fault_name, Depths) = geom.FaultGeometry(Model, File_geom)\n        (Lon_bg, Lat_bg) = bg.geom(Model, File_bg)\n        fault_geom = {}\n        index_fault = 0\n        for Fault_name in faults_names:\n            lons = faults_lon[index_fault]\n            lats = faults_lat[index_fault]\n            i_d = np.where(np.array(Column_Fault_name) == Fault_name)\n            depth = list(map(lambda i: Depths[i], i_d[0]))\n            (dip, oriented, upper_sismo_depth, lower_sismo_depth) = geom.FaultProperties(FileName_Prop, Fault_name, Model)\n            if depth[0] == 'sf':\n                (trace_lon, trace_lat, plot_trace, polygon) = geom.get_sf_polygon(lons, lats, upper_sismo_depth, lower_sismo_depth, dip, oriented)\n            else:\n                (trace_lon, trace_lat) = ([], [])\n                plot_trace = False\n                (lon_top, lon_bottom, lat_top, lat_bottom) = ([], [], [], [])\n                for (lon_i, lat_i, d_i) in zip(lons, lats, depth):\n                    if d_i == min(depth):\n                        lon_top.append(lon_i)\n                        lat_top.append(lat_i)\n                    if d_i == max(depth):\n                        lon_bottom.append(lon_i)\n                        lat_bottom.append(lat_i)\n                poly_lons = np.concatenate([lon_top, np.array(list(reversed(lon_bottom)))])\n                poly_lats = np.concatenate([lat_top, np.array(list(reversed(lat_bottom)))])\n                polygon = [poly_lons, poly_lats]\n            fault_geom.update({index_fault: {'name': Fault_name, 'trace_lon': trace_lon, 'trace_lat': trace_lat, 'plot_trace': plot_trace, 'polygon': polygon}})\n            index_fault += 1\n        '########################\\n        Print the faults activated for each scenario\\n        #########################'\n        if visual_FtF == True and use_basemap == True:\n            for scenario_set in scenarios_names_list:\n                file_names = []\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                log_Mmax_file = str(Run_name) + '/' + str(Model) + '/Log/Mmax_sample_' + str(ScL_complet_list[0]) + '_' + scenario_set + '_1.txt'\n                (sources_names, sources_Mmax, sources_Lengths, sources_Areas) = Read_file.read_file_Mmax_log(log_Mmax_file)\n                rupture_set = available_sets['sc_' + scenario_set]\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                index_rupt = 0\n                for rupt in rupture_set:\n                    if len(Lon_bg) != 0:\n                        maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n                    m1 = copy.copy(m)\n                    fault_colors = []\n                    for fault in faults_names:\n                        if fault in rupt:\n                            fault_colors.append('r')\n                        else:\n                            fault_colors.append('k')\n                    title = str()\n                    i = 0\n                    for fault in rupt:\n                        title += ' ' + str(fault)\n                        i += 1\n                        if i == 6:\n                            title += '\\n'\n                            i = 0\n                    Mmax = sources_Mmax[len(faults_names) + index_rupt]\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set + '/' + str(index_rupt) + '.png'\n                    maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, Mmax=Mmax)\n                    index_rupt += 1\n        '########################\\n        Print the map of the model\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='h')\n            if len(Lon_bg) != 0:\n                maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n            fault_colors = ['k' for fault in faults_names]\n            title = 'Map of the model : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map.png'\n            m.drawcoastlines(linewidth=0.1)\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model_sub_area in Model_list:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        maps_utils.draw_screen_poly(sub_area_lon_i, sub_area_lat_i, m, 'k', 0.01, 0.1, 'k')\n                        (x, y) = m(sub_area_lon_i, sub_area_lat_i)\n                        m.plot(x, y, linewidth=0.2, color='k', linestyle='dotted')\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=400, use_arcgis=True)\n        '########################\\n        Print the sliprate map\\n        #########################'\n        mean_param = np.genfromtxt(Run_name + '/analysis/txt_files/mean_parameters_faults.txt', dtype=['U100', 'U100', 'U1000', 'f8', 'f8'], delimiter='\\t')\n        model_mean_param = list(map(lambda i: mean_param[i][0], range(len(mean_param))))\n        set_mean_param = list(map(lambda i: mean_param[i][1], range(len(mean_param))))\n        fault_name_mean_param = list(map(lambda i: mean_param[i][2], range(len(mean_param))))\n        sr_mean = list(map(lambda i: mean_param[i][3], range(len(mean_param))))\n        Mmax_mean = list(map(lambda i: mean_param[i][4], range(len(mean_param))))\n        index_model = np.where(np.array(model_mean_param) == Model)[0]\n        set_mean_param_model = np.take(set_mean_param, index_model)\n        fault_name_mean_param_model = np.take(fault_name_mean_param, index_model)\n        sr_mean_model = np.take(sr_mean, index_model)\n        Mmax_mean_model = np.take(Mmax_mean, index_model)\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n            title = 'Slip rate : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_sliprate.png'\n        fault_colors = []\n        for fault in faults_names:\n            index_fault = np.where(np.array(fault_name_mean_param_model) == fault)[0][0]\n            sr = sr_mean_model[index_fault]\n            cmap = matplotlib.cm.get_cmap('rainbow')\n            rgba = cmap(float(sr) / max(sr_mean))\n            fault_colors.append(rgba)\n        if use_basemap == True:\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the  Mmax map\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            if use_basemap == True:\n                m1 = copy.copy(m)\n                title = 'Slip rate : ' + Model + ' ' + scenario_set\n                figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_Mmax_' + scenario_set + '.png'\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            sr_mean_set = np.take(sr_mean_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            fault_colors = []\n            for fault in faults_names:\n                index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                Mmax = Mmax_mean_set[index_fault]\n                cmap = matplotlib.cm.get_cmap('rainbow')\n                rgba = cmap((float(Mmax) - min(Mmax_mean)) / (max(Mmax_mean) - min(Mmax_mean)))\n                fault_colors.append(rgba)\n            if use_basemap == True:\n                maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the NMS\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            for MFD_type in MFD_type_list:\n                if use_basemap == True:\n                    title = 'NMS : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_NMS_' + MFD_type + '_' + str(scenario_set) + '.png'\n                slip_rep_data = np.genfromtxt(Run_name + '/analysis/txt_files/slip_rep_on_faults_mean_' + str(Model) + '_' + MFD_type + '_' + str(scenario_set) + '.txt', dtype=['U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8'], delimiter='\\t')\n                fault_name_rep = list(map(lambda i: slip_rep_data[i][0], range(len(slip_rep_data))))\n                p_NMS = list(map(lambda i: slip_rep_data[i][14], range(len(slip_rep_data))))\n                if use_basemap == True:\n                    m1 = copy.copy(m)\n                if use_basemap == True:\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        if NMS_i >= 50.0:\n                            NMS_i = 50.0\n                        rgba = cmap(float(NMS_i * 2.0) / 100.0)\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Print the seismic sliprate\\n                #########################'\n                if use_basemap == True:\n                    m2 = copy.copy(m)\n                    title = 'Seismic slip rate : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_seismicsliprate_' + MFD_type + '_' + str(scenario_set) + '.png'\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                        sr = sr_mean[index_fault]\n                        sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        rgba = cmap(sr_seismic_i / max(sr_mean))\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m2, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Build the geojson file\\n                #########################'\n                features = []\n                id = 0\n                for fault in faults_names:\n                    index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                    NMS_i = p_NMS[index_fault]\n                    index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                    sr = sr_mean[index_fault]\n                    sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                    index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                    Mmax = Mmax_mean_set[index_fault]\n                    trace = []\n                    for (lon_i, lat_i) in zip(fault_geom[id]['trace_lon'], fault_geom[id]['trace_lat']):\n                        trace.append([lon_i, lat_i])\n                    trace = LineString(trace)\n                    features.append(Feature(geometry=trace, properties={'id': id, 'name': fault, 'Mmax': Mmax, 'sliprate': sr, 'NMS': NMS_i, 'sr_seismic': sr_seismic_i}))\n                    id += 1\n                feature_collection = FeatureCollection(features)\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                with open(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + MFD_type + '_' + str(scenario_set) + '.geojson', 'w') as f:\n                    dump(feature_collection, f)",
            "def map_faults(Run_name, Model_list, scenarios_names_list, ScL_complet_list, BG_hyp_list, sample_list, b_value_list, MFD_type_list, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, File_bg, FileName_Prop, File_geom, plot_sr_use, visual_FtF, sub_area_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nb_on_maps = False\n    use_basemap = False\n    available_sets = read_input.extract_sc_input('input/' + Run_name + '/ruptures.txt')\n    for Model in Model_list:\n        if not '.geojson' in FileName_Prop:\n            Prop = np.genfromtxt(FileName_Prop, dtype=['U100', 'U100', 'f8', 'U100', 'U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'U100', 'f8'], skip_header=1)\n            Column_model_name = list(map(lambda i: Prop[i][0], range(len(Prop))))\n            Column_fault_name = list(map(lambda i: Prop[i][1], range(len(Prop))))\n            index_model = np.where(np.array(Column_model_name) == Model)[0]\n            Prop = np.take(Prop, index_model)\n            faults_names = np.array(Column_fault_name[index_model[0]:index_model[-1] + 1])\n            faults_names = list(faults_names)\n        else:\n            with open(FileName_Prop) as f:\n                gj = geojson.load(f)\n            faults = gj['features']\n            faults_names = []\n            for fi in range(len(faults)):\n                if faults[fi]['properties']['model'] == Model:\n                    faults_names.append(str(faults[fi]['properties']['si']))\n        geom_scenar = Geometry_scenario.Geom_scenar(faults_names, File_geom, Model)\n        faults_lon = geom_scenar.faults_lon\n        faults_lat = geom_scenar.faults_lat\n        (Column_Fault_name, Depths) = geom.FaultGeometry(Model, File_geom)\n        (Lon_bg, Lat_bg) = bg.geom(Model, File_bg)\n        fault_geom = {}\n        index_fault = 0\n        for Fault_name in faults_names:\n            lons = faults_lon[index_fault]\n            lats = faults_lat[index_fault]\n            i_d = np.where(np.array(Column_Fault_name) == Fault_name)\n            depth = list(map(lambda i: Depths[i], i_d[0]))\n            (dip, oriented, upper_sismo_depth, lower_sismo_depth) = geom.FaultProperties(FileName_Prop, Fault_name, Model)\n            if depth[0] == 'sf':\n                (trace_lon, trace_lat, plot_trace, polygon) = geom.get_sf_polygon(lons, lats, upper_sismo_depth, lower_sismo_depth, dip, oriented)\n            else:\n                (trace_lon, trace_lat) = ([], [])\n                plot_trace = False\n                (lon_top, lon_bottom, lat_top, lat_bottom) = ([], [], [], [])\n                for (lon_i, lat_i, d_i) in zip(lons, lats, depth):\n                    if d_i == min(depth):\n                        lon_top.append(lon_i)\n                        lat_top.append(lat_i)\n                    if d_i == max(depth):\n                        lon_bottom.append(lon_i)\n                        lat_bottom.append(lat_i)\n                poly_lons = np.concatenate([lon_top, np.array(list(reversed(lon_bottom)))])\n                poly_lats = np.concatenate([lat_top, np.array(list(reversed(lat_bottom)))])\n                polygon = [poly_lons, poly_lats]\n            fault_geom.update({index_fault: {'name': Fault_name, 'trace_lon': trace_lon, 'trace_lat': trace_lat, 'plot_trace': plot_trace, 'polygon': polygon}})\n            index_fault += 1\n        '########################\\n        Print the faults activated for each scenario\\n        #########################'\n        if visual_FtF == True and use_basemap == True:\n            for scenario_set in scenarios_names_list:\n                file_names = []\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                log_Mmax_file = str(Run_name) + '/' + str(Model) + '/Log/Mmax_sample_' + str(ScL_complet_list[0]) + '_' + scenario_set + '_1.txt'\n                (sources_names, sources_Mmax, sources_Lengths, sources_Areas) = Read_file.read_file_Mmax_log(log_Mmax_file)\n                rupture_set = available_sets['sc_' + scenario_set]\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                index_rupt = 0\n                for rupt in rupture_set:\n                    if len(Lon_bg) != 0:\n                        maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n                    m1 = copy.copy(m)\n                    fault_colors = []\n                    for fault in faults_names:\n                        if fault in rupt:\n                            fault_colors.append('r')\n                        else:\n                            fault_colors.append('k')\n                    title = str()\n                    i = 0\n                    for fault in rupt:\n                        title += ' ' + str(fault)\n                        i += 1\n                        if i == 6:\n                            title += '\\n'\n                            i = 0\n                    Mmax = sources_Mmax[len(faults_names) + index_rupt]\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set + '/' + str(index_rupt) + '.png'\n                    maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, Mmax=Mmax)\n                    index_rupt += 1\n        '########################\\n        Print the map of the model\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='h')\n            if len(Lon_bg) != 0:\n                maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n            fault_colors = ['k' for fault in faults_names]\n            title = 'Map of the model : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map.png'\n            m.drawcoastlines(linewidth=0.1)\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model_sub_area in Model_list:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        maps_utils.draw_screen_poly(sub_area_lon_i, sub_area_lat_i, m, 'k', 0.01, 0.1, 'k')\n                        (x, y) = m(sub_area_lon_i, sub_area_lat_i)\n                        m.plot(x, y, linewidth=0.2, color='k', linestyle='dotted')\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=400, use_arcgis=True)\n        '########################\\n        Print the sliprate map\\n        #########################'\n        mean_param = np.genfromtxt(Run_name + '/analysis/txt_files/mean_parameters_faults.txt', dtype=['U100', 'U100', 'U1000', 'f8', 'f8'], delimiter='\\t')\n        model_mean_param = list(map(lambda i: mean_param[i][0], range(len(mean_param))))\n        set_mean_param = list(map(lambda i: mean_param[i][1], range(len(mean_param))))\n        fault_name_mean_param = list(map(lambda i: mean_param[i][2], range(len(mean_param))))\n        sr_mean = list(map(lambda i: mean_param[i][3], range(len(mean_param))))\n        Mmax_mean = list(map(lambda i: mean_param[i][4], range(len(mean_param))))\n        index_model = np.where(np.array(model_mean_param) == Model)[0]\n        set_mean_param_model = np.take(set_mean_param, index_model)\n        fault_name_mean_param_model = np.take(fault_name_mean_param, index_model)\n        sr_mean_model = np.take(sr_mean, index_model)\n        Mmax_mean_model = np.take(Mmax_mean, index_model)\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n            title = 'Slip rate : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_sliprate.png'\n        fault_colors = []\n        for fault in faults_names:\n            index_fault = np.where(np.array(fault_name_mean_param_model) == fault)[0][0]\n            sr = sr_mean_model[index_fault]\n            cmap = matplotlib.cm.get_cmap('rainbow')\n            rgba = cmap(float(sr) / max(sr_mean))\n            fault_colors.append(rgba)\n        if use_basemap == True:\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the  Mmax map\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            if use_basemap == True:\n                m1 = copy.copy(m)\n                title = 'Slip rate : ' + Model + ' ' + scenario_set\n                figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_Mmax_' + scenario_set + '.png'\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            sr_mean_set = np.take(sr_mean_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            fault_colors = []\n            for fault in faults_names:\n                index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                Mmax = Mmax_mean_set[index_fault]\n                cmap = matplotlib.cm.get_cmap('rainbow')\n                rgba = cmap((float(Mmax) - min(Mmax_mean)) / (max(Mmax_mean) - min(Mmax_mean)))\n                fault_colors.append(rgba)\n            if use_basemap == True:\n                maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the NMS\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            for MFD_type in MFD_type_list:\n                if use_basemap == True:\n                    title = 'NMS : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_NMS_' + MFD_type + '_' + str(scenario_set) + '.png'\n                slip_rep_data = np.genfromtxt(Run_name + '/analysis/txt_files/slip_rep_on_faults_mean_' + str(Model) + '_' + MFD_type + '_' + str(scenario_set) + '.txt', dtype=['U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8'], delimiter='\\t')\n                fault_name_rep = list(map(lambda i: slip_rep_data[i][0], range(len(slip_rep_data))))\n                p_NMS = list(map(lambda i: slip_rep_data[i][14], range(len(slip_rep_data))))\n                if use_basemap == True:\n                    m1 = copy.copy(m)\n                if use_basemap == True:\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        if NMS_i >= 50.0:\n                            NMS_i = 50.0\n                        rgba = cmap(float(NMS_i * 2.0) / 100.0)\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Print the seismic sliprate\\n                #########################'\n                if use_basemap == True:\n                    m2 = copy.copy(m)\n                    title = 'Seismic slip rate : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_seismicsliprate_' + MFD_type + '_' + str(scenario_set) + '.png'\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                        sr = sr_mean[index_fault]\n                        sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        rgba = cmap(sr_seismic_i / max(sr_mean))\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m2, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Build the geojson file\\n                #########################'\n                features = []\n                id = 0\n                for fault in faults_names:\n                    index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                    NMS_i = p_NMS[index_fault]\n                    index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                    sr = sr_mean[index_fault]\n                    sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                    index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                    Mmax = Mmax_mean_set[index_fault]\n                    trace = []\n                    for (lon_i, lat_i) in zip(fault_geom[id]['trace_lon'], fault_geom[id]['trace_lat']):\n                        trace.append([lon_i, lat_i])\n                    trace = LineString(trace)\n                    features.append(Feature(geometry=trace, properties={'id': id, 'name': fault, 'Mmax': Mmax, 'sliprate': sr, 'NMS': NMS_i, 'sr_seismic': sr_seismic_i}))\n                    id += 1\n                feature_collection = FeatureCollection(features)\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                with open(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + MFD_type + '_' + str(scenario_set) + '.geojson', 'w') as f:\n                    dump(feature_collection, f)",
            "def map_faults(Run_name, Model_list, scenarios_names_list, ScL_complet_list, BG_hyp_list, sample_list, b_value_list, MFD_type_list, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, File_bg, FileName_Prop, File_geom, plot_sr_use, visual_FtF, sub_area_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nb_on_maps = False\n    use_basemap = False\n    available_sets = read_input.extract_sc_input('input/' + Run_name + '/ruptures.txt')\n    for Model in Model_list:\n        if not '.geojson' in FileName_Prop:\n            Prop = np.genfromtxt(FileName_Prop, dtype=['U100', 'U100', 'f8', 'U100', 'U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'U100', 'f8'], skip_header=1)\n            Column_model_name = list(map(lambda i: Prop[i][0], range(len(Prop))))\n            Column_fault_name = list(map(lambda i: Prop[i][1], range(len(Prop))))\n            index_model = np.where(np.array(Column_model_name) == Model)[0]\n            Prop = np.take(Prop, index_model)\n            faults_names = np.array(Column_fault_name[index_model[0]:index_model[-1] + 1])\n            faults_names = list(faults_names)\n        else:\n            with open(FileName_Prop) as f:\n                gj = geojson.load(f)\n            faults = gj['features']\n            faults_names = []\n            for fi in range(len(faults)):\n                if faults[fi]['properties']['model'] == Model:\n                    faults_names.append(str(faults[fi]['properties']['si']))\n        geom_scenar = Geometry_scenario.Geom_scenar(faults_names, File_geom, Model)\n        faults_lon = geom_scenar.faults_lon\n        faults_lat = geom_scenar.faults_lat\n        (Column_Fault_name, Depths) = geom.FaultGeometry(Model, File_geom)\n        (Lon_bg, Lat_bg) = bg.geom(Model, File_bg)\n        fault_geom = {}\n        index_fault = 0\n        for Fault_name in faults_names:\n            lons = faults_lon[index_fault]\n            lats = faults_lat[index_fault]\n            i_d = np.where(np.array(Column_Fault_name) == Fault_name)\n            depth = list(map(lambda i: Depths[i], i_d[0]))\n            (dip, oriented, upper_sismo_depth, lower_sismo_depth) = geom.FaultProperties(FileName_Prop, Fault_name, Model)\n            if depth[0] == 'sf':\n                (trace_lon, trace_lat, plot_trace, polygon) = geom.get_sf_polygon(lons, lats, upper_sismo_depth, lower_sismo_depth, dip, oriented)\n            else:\n                (trace_lon, trace_lat) = ([], [])\n                plot_trace = False\n                (lon_top, lon_bottom, lat_top, lat_bottom) = ([], [], [], [])\n                for (lon_i, lat_i, d_i) in zip(lons, lats, depth):\n                    if d_i == min(depth):\n                        lon_top.append(lon_i)\n                        lat_top.append(lat_i)\n                    if d_i == max(depth):\n                        lon_bottom.append(lon_i)\n                        lat_bottom.append(lat_i)\n                poly_lons = np.concatenate([lon_top, np.array(list(reversed(lon_bottom)))])\n                poly_lats = np.concatenate([lat_top, np.array(list(reversed(lat_bottom)))])\n                polygon = [poly_lons, poly_lats]\n            fault_geom.update({index_fault: {'name': Fault_name, 'trace_lon': trace_lon, 'trace_lat': trace_lat, 'plot_trace': plot_trace, 'polygon': polygon}})\n            index_fault += 1\n        '########################\\n        Print the faults activated for each scenario\\n        #########################'\n        if visual_FtF == True and use_basemap == True:\n            for scenario_set in scenarios_names_list:\n                file_names = []\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                log_Mmax_file = str(Run_name) + '/' + str(Model) + '/Log/Mmax_sample_' + str(ScL_complet_list[0]) + '_' + scenario_set + '_1.txt'\n                (sources_names, sources_Mmax, sources_Lengths, sources_Areas) = Read_file.read_file_Mmax_log(log_Mmax_file)\n                rupture_set = available_sets['sc_' + scenario_set]\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                index_rupt = 0\n                for rupt in rupture_set:\n                    if len(Lon_bg) != 0:\n                        maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n                    m1 = copy.copy(m)\n                    fault_colors = []\n                    for fault in faults_names:\n                        if fault in rupt:\n                            fault_colors.append('r')\n                        else:\n                            fault_colors.append('k')\n                    title = str()\n                    i = 0\n                    for fault in rupt:\n                        title += ' ' + str(fault)\n                        i += 1\n                        if i == 6:\n                            title += '\\n'\n                            i = 0\n                    Mmax = sources_Mmax[len(faults_names) + index_rupt]\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set + '/' + str(index_rupt) + '.png'\n                    maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, Mmax=Mmax)\n                    index_rupt += 1\n        '########################\\n        Print the map of the model\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='h')\n            if len(Lon_bg) != 0:\n                maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n            fault_colors = ['k' for fault in faults_names]\n            title = 'Map of the model : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map.png'\n            m.drawcoastlines(linewidth=0.1)\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model_sub_area in Model_list:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        maps_utils.draw_screen_poly(sub_area_lon_i, sub_area_lat_i, m, 'k', 0.01, 0.1, 'k')\n                        (x, y) = m(sub_area_lon_i, sub_area_lat_i)\n                        m.plot(x, y, linewidth=0.2, color='k', linestyle='dotted')\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=400, use_arcgis=True)\n        '########################\\n        Print the sliprate map\\n        #########################'\n        mean_param = np.genfromtxt(Run_name + '/analysis/txt_files/mean_parameters_faults.txt', dtype=['U100', 'U100', 'U1000', 'f8', 'f8'], delimiter='\\t')\n        model_mean_param = list(map(lambda i: mean_param[i][0], range(len(mean_param))))\n        set_mean_param = list(map(lambda i: mean_param[i][1], range(len(mean_param))))\n        fault_name_mean_param = list(map(lambda i: mean_param[i][2], range(len(mean_param))))\n        sr_mean = list(map(lambda i: mean_param[i][3], range(len(mean_param))))\n        Mmax_mean = list(map(lambda i: mean_param[i][4], range(len(mean_param))))\n        index_model = np.where(np.array(model_mean_param) == Model)[0]\n        set_mean_param_model = np.take(set_mean_param, index_model)\n        fault_name_mean_param_model = np.take(fault_name_mean_param, index_model)\n        sr_mean_model = np.take(sr_mean, index_model)\n        Mmax_mean_model = np.take(Mmax_mean, index_model)\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n            title = 'Slip rate : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_sliprate.png'\n        fault_colors = []\n        for fault in faults_names:\n            index_fault = np.where(np.array(fault_name_mean_param_model) == fault)[0][0]\n            sr = sr_mean_model[index_fault]\n            cmap = matplotlib.cm.get_cmap('rainbow')\n            rgba = cmap(float(sr) / max(sr_mean))\n            fault_colors.append(rgba)\n        if use_basemap == True:\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the  Mmax map\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            if use_basemap == True:\n                m1 = copy.copy(m)\n                title = 'Slip rate : ' + Model + ' ' + scenario_set\n                figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_Mmax_' + scenario_set + '.png'\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            sr_mean_set = np.take(sr_mean_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            fault_colors = []\n            for fault in faults_names:\n                index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                Mmax = Mmax_mean_set[index_fault]\n                cmap = matplotlib.cm.get_cmap('rainbow')\n                rgba = cmap((float(Mmax) - min(Mmax_mean)) / (max(Mmax_mean) - min(Mmax_mean)))\n                fault_colors.append(rgba)\n            if use_basemap == True:\n                maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the NMS\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            for MFD_type in MFD_type_list:\n                if use_basemap == True:\n                    title = 'NMS : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_NMS_' + MFD_type + '_' + str(scenario_set) + '.png'\n                slip_rep_data = np.genfromtxt(Run_name + '/analysis/txt_files/slip_rep_on_faults_mean_' + str(Model) + '_' + MFD_type + '_' + str(scenario_set) + '.txt', dtype=['U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8'], delimiter='\\t')\n                fault_name_rep = list(map(lambda i: slip_rep_data[i][0], range(len(slip_rep_data))))\n                p_NMS = list(map(lambda i: slip_rep_data[i][14], range(len(slip_rep_data))))\n                if use_basemap == True:\n                    m1 = copy.copy(m)\n                if use_basemap == True:\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        if NMS_i >= 50.0:\n                            NMS_i = 50.0\n                        rgba = cmap(float(NMS_i * 2.0) / 100.0)\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Print the seismic sliprate\\n                #########################'\n                if use_basemap == True:\n                    m2 = copy.copy(m)\n                    title = 'Seismic slip rate : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_seismicsliprate_' + MFD_type + '_' + str(scenario_set) + '.png'\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                        sr = sr_mean[index_fault]\n                        sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        rgba = cmap(sr_seismic_i / max(sr_mean))\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m2, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Build the geojson file\\n                #########################'\n                features = []\n                id = 0\n                for fault in faults_names:\n                    index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                    NMS_i = p_NMS[index_fault]\n                    index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                    sr = sr_mean[index_fault]\n                    sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                    index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                    Mmax = Mmax_mean_set[index_fault]\n                    trace = []\n                    for (lon_i, lat_i) in zip(fault_geom[id]['trace_lon'], fault_geom[id]['trace_lat']):\n                        trace.append([lon_i, lat_i])\n                    trace = LineString(trace)\n                    features.append(Feature(geometry=trace, properties={'id': id, 'name': fault, 'Mmax': Mmax, 'sliprate': sr, 'NMS': NMS_i, 'sr_seismic': sr_seismic_i}))\n                    id += 1\n                feature_collection = FeatureCollection(features)\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                with open(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + MFD_type + '_' + str(scenario_set) + '.geojson', 'w') as f:\n                    dump(feature_collection, f)",
            "def map_faults(Run_name, Model_list, scenarios_names_list, ScL_complet_list, BG_hyp_list, sample_list, b_value_list, MFD_type_list, llcrnrlon, llcrnrlat, urcrnrlon, urcrnrlat, File_bg, FileName_Prop, File_geom, plot_sr_use, visual_FtF, sub_area_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nb_on_maps = False\n    use_basemap = False\n    available_sets = read_input.extract_sc_input('input/' + Run_name + '/ruptures.txt')\n    for Model in Model_list:\n        if not '.geojson' in FileName_Prop:\n            Prop = np.genfromtxt(FileName_Prop, dtype=['U100', 'U100', 'f8', 'U100', 'U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'U100', 'f8'], skip_header=1)\n            Column_model_name = list(map(lambda i: Prop[i][0], range(len(Prop))))\n            Column_fault_name = list(map(lambda i: Prop[i][1], range(len(Prop))))\n            index_model = np.where(np.array(Column_model_name) == Model)[0]\n            Prop = np.take(Prop, index_model)\n            faults_names = np.array(Column_fault_name[index_model[0]:index_model[-1] + 1])\n            faults_names = list(faults_names)\n        else:\n            with open(FileName_Prop) as f:\n                gj = geojson.load(f)\n            faults = gj['features']\n            faults_names = []\n            for fi in range(len(faults)):\n                if faults[fi]['properties']['model'] == Model:\n                    faults_names.append(str(faults[fi]['properties']['si']))\n        geom_scenar = Geometry_scenario.Geom_scenar(faults_names, File_geom, Model)\n        faults_lon = geom_scenar.faults_lon\n        faults_lat = geom_scenar.faults_lat\n        (Column_Fault_name, Depths) = geom.FaultGeometry(Model, File_geom)\n        (Lon_bg, Lat_bg) = bg.geom(Model, File_bg)\n        fault_geom = {}\n        index_fault = 0\n        for Fault_name in faults_names:\n            lons = faults_lon[index_fault]\n            lats = faults_lat[index_fault]\n            i_d = np.where(np.array(Column_Fault_name) == Fault_name)\n            depth = list(map(lambda i: Depths[i], i_d[0]))\n            (dip, oriented, upper_sismo_depth, lower_sismo_depth) = geom.FaultProperties(FileName_Prop, Fault_name, Model)\n            if depth[0] == 'sf':\n                (trace_lon, trace_lat, plot_trace, polygon) = geom.get_sf_polygon(lons, lats, upper_sismo_depth, lower_sismo_depth, dip, oriented)\n            else:\n                (trace_lon, trace_lat) = ([], [])\n                plot_trace = False\n                (lon_top, lon_bottom, lat_top, lat_bottom) = ([], [], [], [])\n                for (lon_i, lat_i, d_i) in zip(lons, lats, depth):\n                    if d_i == min(depth):\n                        lon_top.append(lon_i)\n                        lat_top.append(lat_i)\n                    if d_i == max(depth):\n                        lon_bottom.append(lon_i)\n                        lat_bottom.append(lat_i)\n                poly_lons = np.concatenate([lon_top, np.array(list(reversed(lon_bottom)))])\n                poly_lats = np.concatenate([lat_top, np.array(list(reversed(lat_bottom)))])\n                polygon = [poly_lons, poly_lats]\n            fault_geom.update({index_fault: {'name': Fault_name, 'trace_lon': trace_lon, 'trace_lat': trace_lat, 'plot_trace': plot_trace, 'polygon': polygon}})\n            index_fault += 1\n        '########################\\n        Print the faults activated for each scenario\\n        #########################'\n        if visual_FtF == True and use_basemap == True:\n            for scenario_set in scenarios_names_list:\n                file_names = []\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                log_Mmax_file = str(Run_name) + '/' + str(Model) + '/Log/Mmax_sample_' + str(ScL_complet_list[0]) + '_' + scenario_set + '_1.txt'\n                (sources_names, sources_Mmax, sources_Lengths, sources_Areas) = Read_file.read_file_Mmax_log(log_Mmax_file)\n                rupture_set = available_sets['sc_' + scenario_set]\n                m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n                index_rupt = 0\n                for rupt in rupture_set:\n                    if len(Lon_bg) != 0:\n                        maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n                    m1 = copy.copy(m)\n                    fault_colors = []\n                    for fault in faults_names:\n                        if fault in rupt:\n                            fault_colors.append('r')\n                        else:\n                            fault_colors.append('k')\n                    title = str()\n                    i = 0\n                    for fault in rupt:\n                        title += ' ' + str(fault)\n                        i += 1\n                        if i == 6:\n                            title += '\\n'\n                            i = 0\n                    Mmax = sources_Mmax[len(faults_names) + index_rupt]\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set + '/' + str(index_rupt) + '.png'\n                    maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, Mmax=Mmax)\n                    index_rupt += 1\n        '########################\\n        Print the map of the model\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='h')\n            if len(Lon_bg) != 0:\n                maps_utils.draw_screen_poly(Lon_bg, Lat_bg, m, 'g', 0.2, 0.5, 'k')\n            fault_colors = ['k' for fault in faults_names]\n            title = 'Map of the model : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map.png'\n            m.drawcoastlines(linewidth=0.1)\n            if os.path.exists(sub_area_file):\n                read_sub_area_file = open(sub_area_file, 'rU')\n                lines_sub_area = read_sub_area_file.readlines()\n                sub_area_names = []\n                sub_area_coord = []\n                for line in lines_sub_area:\n                    model_sub_area = line.split('\\t')[0]\n                    if model_sub_area in Model_list:\n                        sub_area_names.append(line.split('\\t')[1])\n                        sub_area_coord.append(line.split('\\t')[2:])\n                        sub_area_lon_i = []\n                        sub_area_lat_i = []\n                        for sub_area_coord_i in line.split('\\t')[2:]:\n                            if not '\\n' in sub_area_coord_i.split(','):\n                                if not '' in sub_area_coord_i.split(','):\n                                    sub_area_lon_i.append(float(sub_area_coord_i.split(',')[1]))\n                                    sub_area_lat_i.append(float(sub_area_coord_i.split(',')[0]))\n                        maps_utils.draw_screen_poly(sub_area_lon_i, sub_area_lat_i, m, 'k', 0.01, 0.1, 'k')\n                        (x, y) = m(sub_area_lon_i, sub_area_lat_i)\n                        m.plot(x, y, linewidth=0.2, color='k', linestyle='dotted')\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=400, use_arcgis=True)\n        '########################\\n        Print the sliprate map\\n        #########################'\n        mean_param = np.genfromtxt(Run_name + '/analysis/txt_files/mean_parameters_faults.txt', dtype=['U100', 'U100', 'U1000', 'f8', 'f8'], delimiter='\\t')\n        model_mean_param = list(map(lambda i: mean_param[i][0], range(len(mean_param))))\n        set_mean_param = list(map(lambda i: mean_param[i][1], range(len(mean_param))))\n        fault_name_mean_param = list(map(lambda i: mean_param[i][2], range(len(mean_param))))\n        sr_mean = list(map(lambda i: mean_param[i][3], range(len(mean_param))))\n        Mmax_mean = list(map(lambda i: mean_param[i][4], range(len(mean_param))))\n        index_model = np.where(np.array(model_mean_param) == Model)[0]\n        set_mean_param_model = np.take(set_mean_param, index_model)\n        fault_name_mean_param_model = np.take(fault_name_mean_param, index_model)\n        sr_mean_model = np.take(sr_mean, index_model)\n        Mmax_mean_model = np.take(Mmax_mean, index_model)\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n            title = 'Slip rate : ' + Model\n            figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_sliprate.png'\n        fault_colors = []\n        for fault in faults_names:\n            index_fault = np.where(np.array(fault_name_mean_param_model) == fault)[0][0]\n            sr = sr_mean_model[index_fault]\n            cmap = matplotlib.cm.get_cmap('rainbow')\n            rgba = cmap(float(sr) / max(sr_mean))\n            fault_colors.append(rgba)\n        if use_basemap == True:\n            maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the  Mmax map\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            if use_basemap == True:\n                m1 = copy.copy(m)\n                title = 'Slip rate : ' + Model + ' ' + scenario_set\n                figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_Mmax_' + scenario_set + '.png'\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            sr_mean_set = np.take(sr_mean_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            fault_colors = []\n            for fault in faults_names:\n                index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                Mmax = Mmax_mean_set[index_fault]\n                cmap = matplotlib.cm.get_cmap('rainbow')\n                rgba = cmap((float(Mmax) - min(Mmax_mean)) / (max(Mmax_mean) - min(Mmax_mean)))\n                fault_colors.append(rgba)\n            if use_basemap == True:\n                maps_utils.make_fault_map(m1, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n        '########################\\n        Print the NMS\\n        #########################'\n        if use_basemap == True:\n            m = Basemap(projection='mill', llcrnrlon=llcrnrlon, llcrnrlat=llcrnrlat, urcrnrlon=urcrnrlon, urcrnrlat=urcrnrlat, resolution='i')\n        for scenario_set in scenarios_names_list:\n            index_set = np.where(np.array(set_mean_param_model) == scenario_set)[0]\n            fault_name_mean_param_set = np.take(fault_name_mean_param_model, index_set)\n            Mmax_mean_set = np.take(Mmax_mean_model, index_set)\n            for MFD_type in MFD_type_list:\n                if use_basemap == True:\n                    title = 'NMS : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_NMS_' + MFD_type + '_' + str(scenario_set) + '.png'\n                slip_rep_data = np.genfromtxt(Run_name + '/analysis/txt_files/slip_rep_on_faults_mean_' + str(Model) + '_' + MFD_type + '_' + str(scenario_set) + '.txt', dtype=['U100', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8'], delimiter='\\t')\n                fault_name_rep = list(map(lambda i: slip_rep_data[i][0], range(len(slip_rep_data))))\n                p_NMS = list(map(lambda i: slip_rep_data[i][14], range(len(slip_rep_data))))\n                if use_basemap == True:\n                    m1 = copy.copy(m)\n                if use_basemap == True:\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        if NMS_i >= 50.0:\n                            NMS_i = 50.0\n                        rgba = cmap(float(NMS_i * 2.0) / 100.0)\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Print the seismic sliprate\\n                #########################'\n                if use_basemap == True:\n                    m2 = copy.copy(m)\n                    title = 'Seismic slip rate : ' + Model + ' ' + MFD_type + ' ' + scenario_set\n                    figpath = str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + 'map_seismicsliprate_' + MFD_type + '_' + str(scenario_set) + '.png'\n                    fault_colors = []\n                    for fault in faults_names:\n                        index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                        NMS_i = p_NMS[index_fault]\n                        index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                        sr = sr_mean[index_fault]\n                        sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                        cmap = matplotlib.cm.get_cmap('rainbow')\n                        rgba = cmap(sr_seismic_i / max(sr_mean))\n                        fault_colors.append(rgba)\n                        maps_utils.make_fault_map(m2, fault_geom, fault_colors, figpath, title, dpi=180, use_arcgis=False)\n                '########################\\n                Build the geojson file\\n                #########################'\n                features = []\n                id = 0\n                for fault in faults_names:\n                    index_fault = np.where(np.array(fault_name_rep) == fault)[0][0]\n                    NMS_i = p_NMS[index_fault]\n                    index_fault = np.where(np.array(fault_name_mean_param) == fault)[0][0]\n                    sr = sr_mean[index_fault]\n                    sr_seismic_i = sr * (1.0 - float(NMS_i) / 100.0)\n                    index_fault = np.where(np.array(fault_name_mean_param_set) == fault)[0][0]\n                    Mmax = Mmax_mean_set[index_fault]\n                    trace = []\n                    for (lon_i, lat_i) in zip(fault_geom[id]['trace_lon'], fault_geom[id]['trace_lat']):\n                        trace.append([lon_i, lat_i])\n                    trace = LineString(trace)\n                    features.append(Feature(geometry=trace, properties={'id': id, 'name': fault, 'Mmax': Mmax, 'sliprate': sr, 'NMS': NMS_i, 'sr_seismic': sr_seismic_i}))\n                    id += 1\n                feature_collection = FeatureCollection(features)\n                if not os.path.exists(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set):\n                    os.makedirs(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + scenario_set)\n                with open(str(Run_name) + '/analysis/figures/FtF/' + Model + '/' + MFD_type + '_' + str(scenario_set) + '.geojson', 'w') as f:\n                    dump(feature_collection, f)"
        ]
    }
]