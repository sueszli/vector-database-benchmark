[
    {
        "func_name": "getInstance",
        "original": "@classmethod\ndef getInstance(cls):\n    \"\"\"This class is a singleton.\"\"\"\n    if not cls.__instance:\n        cls.__instance = IntentManager()\n    return cls.__instance",
        "mutated": [
            "@classmethod\ndef getInstance(cls):\n    if False:\n        i = 10\n    'This class is a singleton.'\n    if not cls.__instance:\n        cls.__instance = IntentManager()\n    return cls.__instance",
            "@classmethod\ndef getInstance(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'This class is a singleton.'\n    if not cls.__instance:\n        cls.__instance = IntentManager()\n    return cls.__instance",
            "@classmethod\ndef getInstance(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'This class is a singleton.'\n    if not cls.__instance:\n        cls.__instance = IntentManager()\n    return cls.__instance",
            "@classmethod\ndef getInstance(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'This class is a singleton.'\n    if not cls.__instance:\n        cls.__instance = IntentManager()\n    return cls.__instance",
            "@classmethod\ndef getInstance(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'This class is a singleton.'\n    if not cls.__instance:\n        cls.__instance = IntentManager()\n    return cls.__instance"
        ]
    },
    {
        "func_name": "intentMetadatas",
        "original": "def intentMetadatas(self, definition_id: str, nozzle_name: str, material_base_file: str) -> List[Dict[str, Any]]:\n    \"\"\"Gets the metadata dictionaries of all intent profiles for a given\n\n        configuration.\n\n        :param definition_id: ID of the printer.\n        :param nozzle_name: Name of the nozzle.\n        :param material_base_file: The base_file of the material.\n        :return: A list of metadata dictionaries matching the search criteria, or\n            an empty list if nothing was found.\n        \"\"\"\n    intent_metadatas = []\n    try:\n        materials = ContainerTree.getInstance().machines[definition_id].variants[nozzle_name].materials\n    except KeyError:\n        Logger.log('w', 'Unable to find the machine %s or the variant %s', definition_id, nozzle_name)\n        materials = {}\n    if material_base_file not in materials:\n        return intent_metadatas\n    material_node = materials[material_base_file]\n    for quality_node in material_node.qualities.values():\n        for intent_node in quality_node.intents.values():\n            intent_metadatas.append(intent_node.getMetadata())\n    return intent_metadatas",
        "mutated": [
            "def intentMetadatas(self, definition_id: str, nozzle_name: str, material_base_file: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n    'Gets the metadata dictionaries of all intent profiles for a given\\n\\n        configuration.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_base_file: The base_file of the material.\\n        :return: A list of metadata dictionaries matching the search criteria, or\\n            an empty list if nothing was found.\\n        '\n    intent_metadatas = []\n    try:\n        materials = ContainerTree.getInstance().machines[definition_id].variants[nozzle_name].materials\n    except KeyError:\n        Logger.log('w', 'Unable to find the machine %s or the variant %s', definition_id, nozzle_name)\n        materials = {}\n    if material_base_file not in materials:\n        return intent_metadatas\n    material_node = materials[material_base_file]\n    for quality_node in material_node.qualities.values():\n        for intent_node in quality_node.intents.values():\n            intent_metadatas.append(intent_node.getMetadata())\n    return intent_metadatas",
            "def intentMetadatas(self, definition_id: str, nozzle_name: str, material_base_file: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Gets the metadata dictionaries of all intent profiles for a given\\n\\n        configuration.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_base_file: The base_file of the material.\\n        :return: A list of metadata dictionaries matching the search criteria, or\\n            an empty list if nothing was found.\\n        '\n    intent_metadatas = []\n    try:\n        materials = ContainerTree.getInstance().machines[definition_id].variants[nozzle_name].materials\n    except KeyError:\n        Logger.log('w', 'Unable to find the machine %s or the variant %s', definition_id, nozzle_name)\n        materials = {}\n    if material_base_file not in materials:\n        return intent_metadatas\n    material_node = materials[material_base_file]\n    for quality_node in material_node.qualities.values():\n        for intent_node in quality_node.intents.values():\n            intent_metadatas.append(intent_node.getMetadata())\n    return intent_metadatas",
            "def intentMetadatas(self, definition_id: str, nozzle_name: str, material_base_file: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Gets the metadata dictionaries of all intent profiles for a given\\n\\n        configuration.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_base_file: The base_file of the material.\\n        :return: A list of metadata dictionaries matching the search criteria, or\\n            an empty list if nothing was found.\\n        '\n    intent_metadatas = []\n    try:\n        materials = ContainerTree.getInstance().machines[definition_id].variants[nozzle_name].materials\n    except KeyError:\n        Logger.log('w', 'Unable to find the machine %s or the variant %s', definition_id, nozzle_name)\n        materials = {}\n    if material_base_file not in materials:\n        return intent_metadatas\n    material_node = materials[material_base_file]\n    for quality_node in material_node.qualities.values():\n        for intent_node in quality_node.intents.values():\n            intent_metadatas.append(intent_node.getMetadata())\n    return intent_metadatas",
            "def intentMetadatas(self, definition_id: str, nozzle_name: str, material_base_file: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Gets the metadata dictionaries of all intent profiles for a given\\n\\n        configuration.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_base_file: The base_file of the material.\\n        :return: A list of metadata dictionaries matching the search criteria, or\\n            an empty list if nothing was found.\\n        '\n    intent_metadatas = []\n    try:\n        materials = ContainerTree.getInstance().machines[definition_id].variants[nozzle_name].materials\n    except KeyError:\n        Logger.log('w', 'Unable to find the machine %s or the variant %s', definition_id, nozzle_name)\n        materials = {}\n    if material_base_file not in materials:\n        return intent_metadatas\n    material_node = materials[material_base_file]\n    for quality_node in material_node.qualities.values():\n        for intent_node in quality_node.intents.values():\n            intent_metadatas.append(intent_node.getMetadata())\n    return intent_metadatas",
            "def intentMetadatas(self, definition_id: str, nozzle_name: str, material_base_file: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Gets the metadata dictionaries of all intent profiles for a given\\n\\n        configuration.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_base_file: The base_file of the material.\\n        :return: A list of metadata dictionaries matching the search criteria, or\\n            an empty list if nothing was found.\\n        '\n    intent_metadatas = []\n    try:\n        materials = ContainerTree.getInstance().machines[definition_id].variants[nozzle_name].materials\n    except KeyError:\n        Logger.log('w', 'Unable to find the machine %s or the variant %s', definition_id, nozzle_name)\n        materials = {}\n    if material_base_file not in materials:\n        return intent_metadatas\n    material_node = materials[material_base_file]\n    for quality_node in material_node.qualities.values():\n        for intent_node in quality_node.intents.values():\n            intent_metadatas.append(intent_node.getMetadata())\n    return intent_metadatas"
        ]
    },
    {
        "func_name": "intentCategories",
        "original": "def intentCategories(self, definition_id: str, nozzle_id: str, material_id: str) -> List[str]:\n    \"\"\"Collects and returns all intent categories available for the given\n\n        parameters. Note that the 'default' category is always available.\n\n        :param definition_id: ID of the printer.\n        :param nozzle_name: Name of the nozzle.\n        :param material_id: ID of the material.\n        :return: A set of intent category names.\n        \"\"\"\n    categories = set()\n    for intent in self.intentMetadatas(definition_id, nozzle_id, material_id):\n        categories.add(intent['intent_category'])\n    categories.add('default')\n    return list(categories)",
        "mutated": [
            "def intentCategories(self, definition_id: str, nozzle_id: str, material_id: str) -> List[str]:\n    if False:\n        i = 10\n    \"Collects and returns all intent categories available for the given\\n\\n        parameters. Note that the 'default' category is always available.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_id: ID of the material.\\n        :return: A set of intent category names.\\n        \"\n    categories = set()\n    for intent in self.intentMetadatas(definition_id, nozzle_id, material_id):\n        categories.add(intent['intent_category'])\n    categories.add('default')\n    return list(categories)",
            "def intentCategories(self, definition_id: str, nozzle_id: str, material_id: str) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Collects and returns all intent categories available for the given\\n\\n        parameters. Note that the 'default' category is always available.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_id: ID of the material.\\n        :return: A set of intent category names.\\n        \"\n    categories = set()\n    for intent in self.intentMetadatas(definition_id, nozzle_id, material_id):\n        categories.add(intent['intent_category'])\n    categories.add('default')\n    return list(categories)",
            "def intentCategories(self, definition_id: str, nozzle_id: str, material_id: str) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Collects and returns all intent categories available for the given\\n\\n        parameters. Note that the 'default' category is always available.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_id: ID of the material.\\n        :return: A set of intent category names.\\n        \"\n    categories = set()\n    for intent in self.intentMetadatas(definition_id, nozzle_id, material_id):\n        categories.add(intent['intent_category'])\n    categories.add('default')\n    return list(categories)",
            "def intentCategories(self, definition_id: str, nozzle_id: str, material_id: str) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Collects and returns all intent categories available for the given\\n\\n        parameters. Note that the 'default' category is always available.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_id: ID of the material.\\n        :return: A set of intent category names.\\n        \"\n    categories = set()\n    for intent in self.intentMetadatas(definition_id, nozzle_id, material_id):\n        categories.add(intent['intent_category'])\n    categories.add('default')\n    return list(categories)",
            "def intentCategories(self, definition_id: str, nozzle_id: str, material_id: str) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Collects and returns all intent categories available for the given\\n\\n        parameters. Note that the 'default' category is always available.\\n\\n        :param definition_id: ID of the printer.\\n        :param nozzle_name: Name of the nozzle.\\n        :param material_id: ID of the material.\\n        :return: A set of intent category names.\\n        \"\n    categories = set()\n    for intent in self.intentMetadatas(definition_id, nozzle_id, material_id):\n        categories.add(intent['intent_category'])\n    categories.add('default')\n    return list(categories)"
        ]
    },
    {
        "func_name": "getCurrentAvailableIntents",
        "original": "def getCurrentAvailableIntents(self) -> List[Tuple[str, str]]:\n    \"\"\"List of intents to be displayed in the interface.\n\n        For the interface this will have to be broken up into the different\n        intent categories. That is up to the model there.\n\n        :return: A list of tuples of intent_category and quality_type. The actual\n            instance may vary per extruder.\n        \"\"\"\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return [('default', 'normal')]\n    quality_groups = ContainerTree.getInstance().getCurrentQualityGroups()\n    available_quality_types = {quality_group.quality_type for quality_group in quality_groups.values() if quality_group.node_for_global is not None}\n    final_intent_ids = set()\n    current_definition_id = global_stack.definition.getId()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_ids |= {metadata['id'] for metadata in self.intentMetadatas(current_definition_id, nozzle_name, material_id) if metadata.get('quality_type') in available_quality_types}\n    result = set()\n    for intent_id in final_intent_ids:\n        intent_metadata = application.getContainerRegistry().findContainersMetadata(id=intent_id)[0]\n        result.add((intent_metadata['intent_category'], intent_metadata['quality_type']))\n    return list(result)",
        "mutated": [
            "def getCurrentAvailableIntents(self) -> List[Tuple[str, str]]:\n    if False:\n        i = 10\n    'List of intents to be displayed in the interface.\\n\\n        For the interface this will have to be broken up into the different\\n        intent categories. That is up to the model there.\\n\\n        :return: A list of tuples of intent_category and quality_type. The actual\\n            instance may vary per extruder.\\n        '\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return [('default', 'normal')]\n    quality_groups = ContainerTree.getInstance().getCurrentQualityGroups()\n    available_quality_types = {quality_group.quality_type for quality_group in quality_groups.values() if quality_group.node_for_global is not None}\n    final_intent_ids = set()\n    current_definition_id = global_stack.definition.getId()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_ids |= {metadata['id'] for metadata in self.intentMetadatas(current_definition_id, nozzle_name, material_id) if metadata.get('quality_type') in available_quality_types}\n    result = set()\n    for intent_id in final_intent_ids:\n        intent_metadata = application.getContainerRegistry().findContainersMetadata(id=intent_id)[0]\n        result.add((intent_metadata['intent_category'], intent_metadata['quality_type']))\n    return list(result)",
            "def getCurrentAvailableIntents(self) -> List[Tuple[str, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'List of intents to be displayed in the interface.\\n\\n        For the interface this will have to be broken up into the different\\n        intent categories. That is up to the model there.\\n\\n        :return: A list of tuples of intent_category and quality_type. The actual\\n            instance may vary per extruder.\\n        '\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return [('default', 'normal')]\n    quality_groups = ContainerTree.getInstance().getCurrentQualityGroups()\n    available_quality_types = {quality_group.quality_type for quality_group in quality_groups.values() if quality_group.node_for_global is not None}\n    final_intent_ids = set()\n    current_definition_id = global_stack.definition.getId()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_ids |= {metadata['id'] for metadata in self.intentMetadatas(current_definition_id, nozzle_name, material_id) if metadata.get('quality_type') in available_quality_types}\n    result = set()\n    for intent_id in final_intent_ids:\n        intent_metadata = application.getContainerRegistry().findContainersMetadata(id=intent_id)[0]\n        result.add((intent_metadata['intent_category'], intent_metadata['quality_type']))\n    return list(result)",
            "def getCurrentAvailableIntents(self) -> List[Tuple[str, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'List of intents to be displayed in the interface.\\n\\n        For the interface this will have to be broken up into the different\\n        intent categories. That is up to the model there.\\n\\n        :return: A list of tuples of intent_category and quality_type. The actual\\n            instance may vary per extruder.\\n        '\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return [('default', 'normal')]\n    quality_groups = ContainerTree.getInstance().getCurrentQualityGroups()\n    available_quality_types = {quality_group.quality_type for quality_group in quality_groups.values() if quality_group.node_for_global is not None}\n    final_intent_ids = set()\n    current_definition_id = global_stack.definition.getId()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_ids |= {metadata['id'] for metadata in self.intentMetadatas(current_definition_id, nozzle_name, material_id) if metadata.get('quality_type') in available_quality_types}\n    result = set()\n    for intent_id in final_intent_ids:\n        intent_metadata = application.getContainerRegistry().findContainersMetadata(id=intent_id)[0]\n        result.add((intent_metadata['intent_category'], intent_metadata['quality_type']))\n    return list(result)",
            "def getCurrentAvailableIntents(self) -> List[Tuple[str, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'List of intents to be displayed in the interface.\\n\\n        For the interface this will have to be broken up into the different\\n        intent categories. That is up to the model there.\\n\\n        :return: A list of tuples of intent_category and quality_type. The actual\\n            instance may vary per extruder.\\n        '\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return [('default', 'normal')]\n    quality_groups = ContainerTree.getInstance().getCurrentQualityGroups()\n    available_quality_types = {quality_group.quality_type for quality_group in quality_groups.values() if quality_group.node_for_global is not None}\n    final_intent_ids = set()\n    current_definition_id = global_stack.definition.getId()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_ids |= {metadata['id'] for metadata in self.intentMetadatas(current_definition_id, nozzle_name, material_id) if metadata.get('quality_type') in available_quality_types}\n    result = set()\n    for intent_id in final_intent_ids:\n        intent_metadata = application.getContainerRegistry().findContainersMetadata(id=intent_id)[0]\n        result.add((intent_metadata['intent_category'], intent_metadata['quality_type']))\n    return list(result)",
            "def getCurrentAvailableIntents(self) -> List[Tuple[str, str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'List of intents to be displayed in the interface.\\n\\n        For the interface this will have to be broken up into the different\\n        intent categories. That is up to the model there.\\n\\n        :return: A list of tuples of intent_category and quality_type. The actual\\n            instance may vary per extruder.\\n        '\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return [('default', 'normal')]\n    quality_groups = ContainerTree.getInstance().getCurrentQualityGroups()\n    available_quality_types = {quality_group.quality_type for quality_group in quality_groups.values() if quality_group.node_for_global is not None}\n    final_intent_ids = set()\n    current_definition_id = global_stack.definition.getId()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_ids |= {metadata['id'] for metadata in self.intentMetadatas(current_definition_id, nozzle_name, material_id) if metadata.get('quality_type') in available_quality_types}\n    result = set()\n    for intent_id in final_intent_ids:\n        intent_metadata = application.getContainerRegistry().findContainersMetadata(id=intent_id)[0]\n        result.add((intent_metadata['intent_category'], intent_metadata['quality_type']))\n    return list(result)"
        ]
    },
    {
        "func_name": "currentAvailableIntentCategories",
        "original": "def currentAvailableIntentCategories(self) -> List[str]:\n    \"\"\"List of intent categories available in either of the extruders.\n\n        This is purposefully inconsistent with the way that the quality types\n        are listed. The quality types will show all quality types available in\n        the printer using any configuration. This will only list the intent\n        categories that are available using the current configuration (but the\n        union over the extruders).\n        :return: List of all categories in the current configurations of all\n            extruders.\n        \"\"\"\n    global_stack = cura.CuraApplication.CuraApplication.getInstance().getGlobalContainerStack()\n    if global_stack is None:\n        return ['default']\n    current_definition_id = global_stack.definition.getId()\n    final_intent_categories = set()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_categories.update(self.intentCategories(current_definition_id, nozzle_name, material_id))\n    return list(final_intent_categories)",
        "mutated": [
            "def currentAvailableIntentCategories(self) -> List[str]:\n    if False:\n        i = 10\n    'List of intent categories available in either of the extruders.\\n\\n        This is purposefully inconsistent with the way that the quality types\\n        are listed. The quality types will show all quality types available in\\n        the printer using any configuration. This will only list the intent\\n        categories that are available using the current configuration (but the\\n        union over the extruders).\\n        :return: List of all categories in the current configurations of all\\n            extruders.\\n        '\n    global_stack = cura.CuraApplication.CuraApplication.getInstance().getGlobalContainerStack()\n    if global_stack is None:\n        return ['default']\n    current_definition_id = global_stack.definition.getId()\n    final_intent_categories = set()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_categories.update(self.intentCategories(current_definition_id, nozzle_name, material_id))\n    return list(final_intent_categories)",
            "def currentAvailableIntentCategories(self) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'List of intent categories available in either of the extruders.\\n\\n        This is purposefully inconsistent with the way that the quality types\\n        are listed. The quality types will show all quality types available in\\n        the printer using any configuration. This will only list the intent\\n        categories that are available using the current configuration (but the\\n        union over the extruders).\\n        :return: List of all categories in the current configurations of all\\n            extruders.\\n        '\n    global_stack = cura.CuraApplication.CuraApplication.getInstance().getGlobalContainerStack()\n    if global_stack is None:\n        return ['default']\n    current_definition_id = global_stack.definition.getId()\n    final_intent_categories = set()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_categories.update(self.intentCategories(current_definition_id, nozzle_name, material_id))\n    return list(final_intent_categories)",
            "def currentAvailableIntentCategories(self) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'List of intent categories available in either of the extruders.\\n\\n        This is purposefully inconsistent with the way that the quality types\\n        are listed. The quality types will show all quality types available in\\n        the printer using any configuration. This will only list the intent\\n        categories that are available using the current configuration (but the\\n        union over the extruders).\\n        :return: List of all categories in the current configurations of all\\n            extruders.\\n        '\n    global_stack = cura.CuraApplication.CuraApplication.getInstance().getGlobalContainerStack()\n    if global_stack is None:\n        return ['default']\n    current_definition_id = global_stack.definition.getId()\n    final_intent_categories = set()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_categories.update(self.intentCategories(current_definition_id, nozzle_name, material_id))\n    return list(final_intent_categories)",
            "def currentAvailableIntentCategories(self) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'List of intent categories available in either of the extruders.\\n\\n        This is purposefully inconsistent with the way that the quality types\\n        are listed. The quality types will show all quality types available in\\n        the printer using any configuration. This will only list the intent\\n        categories that are available using the current configuration (but the\\n        union over the extruders).\\n        :return: List of all categories in the current configurations of all\\n            extruders.\\n        '\n    global_stack = cura.CuraApplication.CuraApplication.getInstance().getGlobalContainerStack()\n    if global_stack is None:\n        return ['default']\n    current_definition_id = global_stack.definition.getId()\n    final_intent_categories = set()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_categories.update(self.intentCategories(current_definition_id, nozzle_name, material_id))\n    return list(final_intent_categories)",
            "def currentAvailableIntentCategories(self) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'List of intent categories available in either of the extruders.\\n\\n        This is purposefully inconsistent with the way that the quality types\\n        are listed. The quality types will show all quality types available in\\n        the printer using any configuration. This will only list the intent\\n        categories that are available using the current configuration (but the\\n        union over the extruders).\\n        :return: List of all categories in the current configurations of all\\n            extruders.\\n        '\n    global_stack = cura.CuraApplication.CuraApplication.getInstance().getGlobalContainerStack()\n    if global_stack is None:\n        return ['default']\n    current_definition_id = global_stack.definition.getId()\n    final_intent_categories = set()\n    for extruder_stack in global_stack.extruderList:\n        if not extruder_stack.isEnabled:\n            continue\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        final_intent_categories.update(self.intentCategories(current_definition_id, nozzle_name, material_id))\n    return list(final_intent_categories)"
        ]
    },
    {
        "func_name": "getDefaultIntent",
        "original": "def getDefaultIntent(self) -> 'InstanceContainer':\n    \"\"\"The intent that gets selected by default when no intent is available for\n\n        the configuration, an extruder can't match the intent that the user\n        selects, or just when creating a new printer.\n        \"\"\"\n    return empty_intent_container",
        "mutated": [
            "def getDefaultIntent(self) -> 'InstanceContainer':\n    if False:\n        i = 10\n    \"The intent that gets selected by default when no intent is available for\\n\\n        the configuration, an extruder can't match the intent that the user\\n        selects, or just when creating a new printer.\\n        \"\n    return empty_intent_container",
            "def getDefaultIntent(self) -> 'InstanceContainer':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"The intent that gets selected by default when no intent is available for\\n\\n        the configuration, an extruder can't match the intent that the user\\n        selects, or just when creating a new printer.\\n        \"\n    return empty_intent_container",
            "def getDefaultIntent(self) -> 'InstanceContainer':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"The intent that gets selected by default when no intent is available for\\n\\n        the configuration, an extruder can't match the intent that the user\\n        selects, or just when creating a new printer.\\n        \"\n    return empty_intent_container",
            "def getDefaultIntent(self) -> 'InstanceContainer':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"The intent that gets selected by default when no intent is available for\\n\\n        the configuration, an extruder can't match the intent that the user\\n        selects, or just when creating a new printer.\\n        \"\n    return empty_intent_container",
            "def getDefaultIntent(self) -> 'InstanceContainer':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"The intent that gets selected by default when no intent is available for\\n\\n        the configuration, an extruder can't match the intent that the user\\n        selects, or just when creating a new printer.\\n        \"\n    return empty_intent_container"
        ]
    },
    {
        "func_name": "currentIntentCategory",
        "original": "@pyqtProperty(str, notify=intentCategoryChanged)\ndef currentIntentCategory(self) -> str:\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    active_extruder_stack = application.getMachineManager().activeStack\n    if active_extruder_stack is None:\n        return ''\n    return active_extruder_stack.intent.getMetaDataEntry('intent_category', '')",
        "mutated": [
            "@pyqtProperty(str, notify=intentCategoryChanged)\ndef currentIntentCategory(self) -> str:\n    if False:\n        i = 10\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    active_extruder_stack = application.getMachineManager().activeStack\n    if active_extruder_stack is None:\n        return ''\n    return active_extruder_stack.intent.getMetaDataEntry('intent_category', '')",
            "@pyqtProperty(str, notify=intentCategoryChanged)\ndef currentIntentCategory(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    active_extruder_stack = application.getMachineManager().activeStack\n    if active_extruder_stack is None:\n        return ''\n    return active_extruder_stack.intent.getMetaDataEntry('intent_category', '')",
            "@pyqtProperty(str, notify=intentCategoryChanged)\ndef currentIntentCategory(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    active_extruder_stack = application.getMachineManager().activeStack\n    if active_extruder_stack is None:\n        return ''\n    return active_extruder_stack.intent.getMetaDataEntry('intent_category', '')",
            "@pyqtProperty(str, notify=intentCategoryChanged)\ndef currentIntentCategory(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    active_extruder_stack = application.getMachineManager().activeStack\n    if active_extruder_stack is None:\n        return ''\n    return active_extruder_stack.intent.getMetaDataEntry('intent_category', '')",
            "@pyqtProperty(str, notify=intentCategoryChanged)\ndef currentIntentCategory(self) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    active_extruder_stack = application.getMachineManager().activeStack\n    if active_extruder_stack is None:\n        return ''\n    return active_extruder_stack.intent.getMetaDataEntry('intent_category', '')"
        ]
    },
    {
        "func_name": "selectIntent",
        "original": "@pyqtSlot(str, str)\ndef selectIntent(self, intent_category: str, quality_type: str) -> None:\n    \"\"\"Apply intent on the stacks.\"\"\"\n    Logger.log('i', 'Attempting to set intent_category to [%s] and quality type to [%s]', intent_category, quality_type)\n    old_intent_category = self.currentIntentCategory\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return\n    current_definition_id = global_stack.definition.getId()\n    machine_node = ContainerTree.getInstance().machines[current_definition_id]\n    for extruder_stack in global_stack.extruderList:\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        material_node = machine_node.variants[nozzle_name].materials[material_id]\n        quality_node = None\n        for q_node in material_node.qualities.values():\n            if q_node.quality_type == quality_type:\n                quality_node = q_node\n        if quality_node is None:\n            Logger.log('w', 'Unable to find quality_type [%s] for extruder [%s]', quality_type, extruder_stack.getId())\n            continue\n        intent_id = None\n        for (id, intent_node) in quality_node.intents.items():\n            if intent_node.intent_category == intent_category:\n                intent_id = id\n        intent = application.getContainerRegistry().findContainers(id=intent_id)\n        if intent:\n            extruder_stack.intent = intent[0]\n        else:\n            extruder_stack.intent = self.getDefaultIntent()\n    application.getMachineManager().setQualityGroupByQualityType(quality_type)\n    if old_intent_category != intent_category:\n        self.intentCategoryChanged.emit()\n        self.intentCategoryChangedSignal.emit()",
        "mutated": [
            "@pyqtSlot(str, str)\ndef selectIntent(self, intent_category: str, quality_type: str) -> None:\n    if False:\n        i = 10\n    'Apply intent on the stacks.'\n    Logger.log('i', 'Attempting to set intent_category to [%s] and quality type to [%s]', intent_category, quality_type)\n    old_intent_category = self.currentIntentCategory\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return\n    current_definition_id = global_stack.definition.getId()\n    machine_node = ContainerTree.getInstance().machines[current_definition_id]\n    for extruder_stack in global_stack.extruderList:\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        material_node = machine_node.variants[nozzle_name].materials[material_id]\n        quality_node = None\n        for q_node in material_node.qualities.values():\n            if q_node.quality_type == quality_type:\n                quality_node = q_node\n        if quality_node is None:\n            Logger.log('w', 'Unable to find quality_type [%s] for extruder [%s]', quality_type, extruder_stack.getId())\n            continue\n        intent_id = None\n        for (id, intent_node) in quality_node.intents.items():\n            if intent_node.intent_category == intent_category:\n                intent_id = id\n        intent = application.getContainerRegistry().findContainers(id=intent_id)\n        if intent:\n            extruder_stack.intent = intent[0]\n        else:\n            extruder_stack.intent = self.getDefaultIntent()\n    application.getMachineManager().setQualityGroupByQualityType(quality_type)\n    if old_intent_category != intent_category:\n        self.intentCategoryChanged.emit()\n        self.intentCategoryChangedSignal.emit()",
            "@pyqtSlot(str, str)\ndef selectIntent(self, intent_category: str, quality_type: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Apply intent on the stacks.'\n    Logger.log('i', 'Attempting to set intent_category to [%s] and quality type to [%s]', intent_category, quality_type)\n    old_intent_category = self.currentIntentCategory\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return\n    current_definition_id = global_stack.definition.getId()\n    machine_node = ContainerTree.getInstance().machines[current_definition_id]\n    for extruder_stack in global_stack.extruderList:\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        material_node = machine_node.variants[nozzle_name].materials[material_id]\n        quality_node = None\n        for q_node in material_node.qualities.values():\n            if q_node.quality_type == quality_type:\n                quality_node = q_node\n        if quality_node is None:\n            Logger.log('w', 'Unable to find quality_type [%s] for extruder [%s]', quality_type, extruder_stack.getId())\n            continue\n        intent_id = None\n        for (id, intent_node) in quality_node.intents.items():\n            if intent_node.intent_category == intent_category:\n                intent_id = id\n        intent = application.getContainerRegistry().findContainers(id=intent_id)\n        if intent:\n            extruder_stack.intent = intent[0]\n        else:\n            extruder_stack.intent = self.getDefaultIntent()\n    application.getMachineManager().setQualityGroupByQualityType(quality_type)\n    if old_intent_category != intent_category:\n        self.intentCategoryChanged.emit()\n        self.intentCategoryChangedSignal.emit()",
            "@pyqtSlot(str, str)\ndef selectIntent(self, intent_category: str, quality_type: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Apply intent on the stacks.'\n    Logger.log('i', 'Attempting to set intent_category to [%s] and quality type to [%s]', intent_category, quality_type)\n    old_intent_category = self.currentIntentCategory\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return\n    current_definition_id = global_stack.definition.getId()\n    machine_node = ContainerTree.getInstance().machines[current_definition_id]\n    for extruder_stack in global_stack.extruderList:\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        material_node = machine_node.variants[nozzle_name].materials[material_id]\n        quality_node = None\n        for q_node in material_node.qualities.values():\n            if q_node.quality_type == quality_type:\n                quality_node = q_node\n        if quality_node is None:\n            Logger.log('w', 'Unable to find quality_type [%s] for extruder [%s]', quality_type, extruder_stack.getId())\n            continue\n        intent_id = None\n        for (id, intent_node) in quality_node.intents.items():\n            if intent_node.intent_category == intent_category:\n                intent_id = id\n        intent = application.getContainerRegistry().findContainers(id=intent_id)\n        if intent:\n            extruder_stack.intent = intent[0]\n        else:\n            extruder_stack.intent = self.getDefaultIntent()\n    application.getMachineManager().setQualityGroupByQualityType(quality_type)\n    if old_intent_category != intent_category:\n        self.intentCategoryChanged.emit()\n        self.intentCategoryChangedSignal.emit()",
            "@pyqtSlot(str, str)\ndef selectIntent(self, intent_category: str, quality_type: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Apply intent on the stacks.'\n    Logger.log('i', 'Attempting to set intent_category to [%s] and quality type to [%s]', intent_category, quality_type)\n    old_intent_category = self.currentIntentCategory\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return\n    current_definition_id = global_stack.definition.getId()\n    machine_node = ContainerTree.getInstance().machines[current_definition_id]\n    for extruder_stack in global_stack.extruderList:\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        material_node = machine_node.variants[nozzle_name].materials[material_id]\n        quality_node = None\n        for q_node in material_node.qualities.values():\n            if q_node.quality_type == quality_type:\n                quality_node = q_node\n        if quality_node is None:\n            Logger.log('w', 'Unable to find quality_type [%s] for extruder [%s]', quality_type, extruder_stack.getId())\n            continue\n        intent_id = None\n        for (id, intent_node) in quality_node.intents.items():\n            if intent_node.intent_category == intent_category:\n                intent_id = id\n        intent = application.getContainerRegistry().findContainers(id=intent_id)\n        if intent:\n            extruder_stack.intent = intent[0]\n        else:\n            extruder_stack.intent = self.getDefaultIntent()\n    application.getMachineManager().setQualityGroupByQualityType(quality_type)\n    if old_intent_category != intent_category:\n        self.intentCategoryChanged.emit()\n        self.intentCategoryChangedSignal.emit()",
            "@pyqtSlot(str, str)\ndef selectIntent(self, intent_category: str, quality_type: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Apply intent on the stacks.'\n    Logger.log('i', 'Attempting to set intent_category to [%s] and quality type to [%s]', intent_category, quality_type)\n    old_intent_category = self.currentIntentCategory\n    application = cura.CuraApplication.CuraApplication.getInstance()\n    global_stack = application.getGlobalContainerStack()\n    if global_stack is None:\n        return\n    current_definition_id = global_stack.definition.getId()\n    machine_node = ContainerTree.getInstance().machines[current_definition_id]\n    for extruder_stack in global_stack.extruderList:\n        nozzle_name = extruder_stack.variant.getMetaDataEntry('name')\n        material_id = extruder_stack.material.getMetaDataEntry('base_file')\n        material_node = machine_node.variants[nozzle_name].materials[material_id]\n        quality_node = None\n        for q_node in material_node.qualities.values():\n            if q_node.quality_type == quality_type:\n                quality_node = q_node\n        if quality_node is None:\n            Logger.log('w', 'Unable to find quality_type [%s] for extruder [%s]', quality_type, extruder_stack.getId())\n            continue\n        intent_id = None\n        for (id, intent_node) in quality_node.intents.items():\n            if intent_node.intent_category == intent_category:\n                intent_id = id\n        intent = application.getContainerRegistry().findContainers(id=intent_id)\n        if intent:\n            extruder_stack.intent = intent[0]\n        else:\n            extruder_stack.intent = self.getDefaultIntent()\n    application.getMachineManager().setQualityGroupByQualityType(quality_type)\n    if old_intent_category != intent_category:\n        self.intentCategoryChanged.emit()\n        self.intentCategoryChangedSignal.emit()"
        ]
    }
]