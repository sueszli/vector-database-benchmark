[
    {
        "func_name": "got",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.LINUX)\n@pwndbg.commands.OnlyWhenRunning\ndef got(path_filter, all_, accept_readonly, symbol_filter) -> None:\n    if pwndbg.gdblib.qemu.is_qemu_usermode():\n        print('QEMU target detected - the result might not be accurate when checking if the entry is writable and getting the information for libraries/objfiles')\n        print()\n    if path_filter:\n        print('Filtering by lib/objfile path: ' + message.hint(path_filter))\n    if symbol_filter:\n        print('Filtering by symbol name: ' + message.hint(symbol_filter))\n    if not accept_readonly:\n        print('Filtering out read-only entries (display them with -r or --show-readonly)')\n    if path_filter or not accept_readonly or symbol_filter:\n        print()\n    if not path_filter:\n        first_print = False\n        _got(pwndbg.gdblib.proc.exe, accept_readonly, symbol_filter)\n    else:\n        first_print = True\n    if not all_ and (not path_filter):\n        return\n    paths = pwndbg.gdblib.info.sharedlibrary_paths()\n    for path in paths:\n        if path_filter not in path:\n            continue\n        if not first_print:\n            print()\n        first_print = False\n        _got(path, accept_readonly, symbol_filter)\n    if first_print and path_filter:\n        print(message.error('No shared library matching the path filter found.'))\n        if paths:\n            print(message.notice('Available shared libraries:'))\n            for path in paths:\n                print('    ' + path)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.LINUX)\n@pwndbg.commands.OnlyWhenRunning\ndef got(path_filter, all_, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n    if pwndbg.gdblib.qemu.is_qemu_usermode():\n        print('QEMU target detected - the result might not be accurate when checking if the entry is writable and getting the information for libraries/objfiles')\n        print()\n    if path_filter:\n        print('Filtering by lib/objfile path: ' + message.hint(path_filter))\n    if symbol_filter:\n        print('Filtering by symbol name: ' + message.hint(symbol_filter))\n    if not accept_readonly:\n        print('Filtering out read-only entries (display them with -r or --show-readonly)')\n    if path_filter or not accept_readonly or symbol_filter:\n        print()\n    if not path_filter:\n        first_print = False\n        _got(pwndbg.gdblib.proc.exe, accept_readonly, symbol_filter)\n    else:\n        first_print = True\n    if not all_ and (not path_filter):\n        return\n    paths = pwndbg.gdblib.info.sharedlibrary_paths()\n    for path in paths:\n        if path_filter not in path:\n            continue\n        if not first_print:\n            print()\n        first_print = False\n        _got(path, accept_readonly, symbol_filter)\n    if first_print and path_filter:\n        print(message.error('No shared library matching the path filter found.'))\n        if paths:\n            print(message.notice('Available shared libraries:'))\n            for path in paths:\n                print('    ' + path)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.LINUX)\n@pwndbg.commands.OnlyWhenRunning\ndef got(path_filter, all_, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if pwndbg.gdblib.qemu.is_qemu_usermode():\n        print('QEMU target detected - the result might not be accurate when checking if the entry is writable and getting the information for libraries/objfiles')\n        print()\n    if path_filter:\n        print('Filtering by lib/objfile path: ' + message.hint(path_filter))\n    if symbol_filter:\n        print('Filtering by symbol name: ' + message.hint(symbol_filter))\n    if not accept_readonly:\n        print('Filtering out read-only entries (display them with -r or --show-readonly)')\n    if path_filter or not accept_readonly or symbol_filter:\n        print()\n    if not path_filter:\n        first_print = False\n        _got(pwndbg.gdblib.proc.exe, accept_readonly, symbol_filter)\n    else:\n        first_print = True\n    if not all_ and (not path_filter):\n        return\n    paths = pwndbg.gdblib.info.sharedlibrary_paths()\n    for path in paths:\n        if path_filter not in path:\n            continue\n        if not first_print:\n            print()\n        first_print = False\n        _got(path, accept_readonly, symbol_filter)\n    if first_print and path_filter:\n        print(message.error('No shared library matching the path filter found.'))\n        if paths:\n            print(message.notice('Available shared libraries:'))\n            for path in paths:\n                print('    ' + path)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.LINUX)\n@pwndbg.commands.OnlyWhenRunning\ndef got(path_filter, all_, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if pwndbg.gdblib.qemu.is_qemu_usermode():\n        print('QEMU target detected - the result might not be accurate when checking if the entry is writable and getting the information for libraries/objfiles')\n        print()\n    if path_filter:\n        print('Filtering by lib/objfile path: ' + message.hint(path_filter))\n    if symbol_filter:\n        print('Filtering by symbol name: ' + message.hint(symbol_filter))\n    if not accept_readonly:\n        print('Filtering out read-only entries (display them with -r or --show-readonly)')\n    if path_filter or not accept_readonly or symbol_filter:\n        print()\n    if not path_filter:\n        first_print = False\n        _got(pwndbg.gdblib.proc.exe, accept_readonly, symbol_filter)\n    else:\n        first_print = True\n    if not all_ and (not path_filter):\n        return\n    paths = pwndbg.gdblib.info.sharedlibrary_paths()\n    for path in paths:\n        if path_filter not in path:\n            continue\n        if not first_print:\n            print()\n        first_print = False\n        _got(path, accept_readonly, symbol_filter)\n    if first_print and path_filter:\n        print(message.error('No shared library matching the path filter found.'))\n        if paths:\n            print(message.notice('Available shared libraries:'))\n            for path in paths:\n                print('    ' + path)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.LINUX)\n@pwndbg.commands.OnlyWhenRunning\ndef got(path_filter, all_, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if pwndbg.gdblib.qemu.is_qemu_usermode():\n        print('QEMU target detected - the result might not be accurate when checking if the entry is writable and getting the information for libraries/objfiles')\n        print()\n    if path_filter:\n        print('Filtering by lib/objfile path: ' + message.hint(path_filter))\n    if symbol_filter:\n        print('Filtering by symbol name: ' + message.hint(symbol_filter))\n    if not accept_readonly:\n        print('Filtering out read-only entries (display them with -r or --show-readonly)')\n    if path_filter or not accept_readonly or symbol_filter:\n        print()\n    if not path_filter:\n        first_print = False\n        _got(pwndbg.gdblib.proc.exe, accept_readonly, symbol_filter)\n    else:\n        first_print = True\n    if not all_ and (not path_filter):\n        return\n    paths = pwndbg.gdblib.info.sharedlibrary_paths()\n    for path in paths:\n        if path_filter not in path:\n            continue\n        if not first_print:\n            print()\n        first_print = False\n        _got(path, accept_readonly, symbol_filter)\n    if first_print and path_filter:\n        print(message.error('No shared library matching the path filter found.'))\n        if paths:\n            print(message.notice('Available shared libraries:'))\n            for path in paths:\n                print('    ' + path)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.LINUX)\n@pwndbg.commands.OnlyWhenRunning\ndef got(path_filter, all_, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if pwndbg.gdblib.qemu.is_qemu_usermode():\n        print('QEMU target detected - the result might not be accurate when checking if the entry is writable and getting the information for libraries/objfiles')\n        print()\n    if path_filter:\n        print('Filtering by lib/objfile path: ' + message.hint(path_filter))\n    if symbol_filter:\n        print('Filtering by symbol name: ' + message.hint(symbol_filter))\n    if not accept_readonly:\n        print('Filtering out read-only entries (display them with -r or --show-readonly)')\n    if path_filter or not accept_readonly or symbol_filter:\n        print()\n    if not path_filter:\n        first_print = False\n        _got(pwndbg.gdblib.proc.exe, accept_readonly, symbol_filter)\n    else:\n        first_print = True\n    if not all_ and (not path_filter):\n        return\n    paths = pwndbg.gdblib.info.sharedlibrary_paths()\n    for path in paths:\n        if path_filter not in path:\n            continue\n        if not first_print:\n            print()\n        first_print = False\n        _got(path, accept_readonly, symbol_filter)\n    if first_print and path_filter:\n        print(message.error('No shared library matching the path filter found.'))\n        if paths:\n            print(message.notice('Available shared libraries:'))\n            for path in paths:\n                print('    ' + path)"
        ]
    },
    {
        "func_name": "_got",
        "original": "def _got(path, accept_readonly, symbol_filter) -> None:\n    local_path = pwndbg.gdblib.file.get_file(path, try_local_path=True)\n    relro_status = pwndbg.wrappers.checksec.relro_status(local_path)\n    pie_status = pwndbg.wrappers.checksec.pie_status(local_path)\n    got_entry = pwndbg.wrappers.readelf.get_got_entry(local_path)\n    outputs = []\n    if path == pwndbg.gdblib.proc.exe:\n        bin_base_offset = pwndbg.gdblib.proc.binary_base_addr if 'PIE enabled' in pie_status else 0\n    else:\n        text_section_addr = pwndbg.gdblib.info.parsed_sharedlibrary()[path][0]\n        with open(local_path, 'rb') as f:\n            bin_base_offset = text_section_addr - ELFFile(f).get_section_by_name('.text').header['sh_addr']\n    for (category, lines) in got_entry.items():\n        for line in lines:\n            (offset, _, rtype, *rest) = line.split()[:5]\n            if len(rest) == 1:\n                value = rest[0]\n                name = ''\n            else:\n                (value, name) = rest\n            address = int(offset, 16) + bin_base_offset\n            if not accept_readonly and (not pwndbg.gdblib.vmmap.find(address).write):\n                continue\n            if not name and category == RelocationType.IRELATIVE:\n                if pwndbg.gdblib.arch.name == 'i386':\n                    name = '*ABS*'\n                else:\n                    name = f'*ABS*+0x{int(value, 16):x}'\n            if symbol_filter not in name:\n                continue\n            outputs.append({'name': name or '????', 'address': address})\n    outputs.sort(key=lambda x: x['address'])\n    relro_color = message.off\n    if 'Partial' in relro_status:\n        relro_color = message.warn\n    elif 'Full' in relro_status:\n        relro_color = message.on\n    print(f'State of the GOT of {message.notice(path)}:')\n    print(f'GOT protection: {relro_color(relro_status)} | Found {message.hint(len(outputs))} GOT entries passing the filter')\n    for output in outputs:\n        print(f\"[{M.get(output['address'])}] {message.hint(output['name'])} -> {pwndbg.chain.format(pwndbg.gdblib.memory.pvoid(output['address']))}\")",
        "mutated": [
            "def _got(path, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n    local_path = pwndbg.gdblib.file.get_file(path, try_local_path=True)\n    relro_status = pwndbg.wrappers.checksec.relro_status(local_path)\n    pie_status = pwndbg.wrappers.checksec.pie_status(local_path)\n    got_entry = pwndbg.wrappers.readelf.get_got_entry(local_path)\n    outputs = []\n    if path == pwndbg.gdblib.proc.exe:\n        bin_base_offset = pwndbg.gdblib.proc.binary_base_addr if 'PIE enabled' in pie_status else 0\n    else:\n        text_section_addr = pwndbg.gdblib.info.parsed_sharedlibrary()[path][0]\n        with open(local_path, 'rb') as f:\n            bin_base_offset = text_section_addr - ELFFile(f).get_section_by_name('.text').header['sh_addr']\n    for (category, lines) in got_entry.items():\n        for line in lines:\n            (offset, _, rtype, *rest) = line.split()[:5]\n            if len(rest) == 1:\n                value = rest[0]\n                name = ''\n            else:\n                (value, name) = rest\n            address = int(offset, 16) + bin_base_offset\n            if not accept_readonly and (not pwndbg.gdblib.vmmap.find(address).write):\n                continue\n            if not name and category == RelocationType.IRELATIVE:\n                if pwndbg.gdblib.arch.name == 'i386':\n                    name = '*ABS*'\n                else:\n                    name = f'*ABS*+0x{int(value, 16):x}'\n            if symbol_filter not in name:\n                continue\n            outputs.append({'name': name or '????', 'address': address})\n    outputs.sort(key=lambda x: x['address'])\n    relro_color = message.off\n    if 'Partial' in relro_status:\n        relro_color = message.warn\n    elif 'Full' in relro_status:\n        relro_color = message.on\n    print(f'State of the GOT of {message.notice(path)}:')\n    print(f'GOT protection: {relro_color(relro_status)} | Found {message.hint(len(outputs))} GOT entries passing the filter')\n    for output in outputs:\n        print(f\"[{M.get(output['address'])}] {message.hint(output['name'])} -> {pwndbg.chain.format(pwndbg.gdblib.memory.pvoid(output['address']))}\")",
            "def _got(path, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    local_path = pwndbg.gdblib.file.get_file(path, try_local_path=True)\n    relro_status = pwndbg.wrappers.checksec.relro_status(local_path)\n    pie_status = pwndbg.wrappers.checksec.pie_status(local_path)\n    got_entry = pwndbg.wrappers.readelf.get_got_entry(local_path)\n    outputs = []\n    if path == pwndbg.gdblib.proc.exe:\n        bin_base_offset = pwndbg.gdblib.proc.binary_base_addr if 'PIE enabled' in pie_status else 0\n    else:\n        text_section_addr = pwndbg.gdblib.info.parsed_sharedlibrary()[path][0]\n        with open(local_path, 'rb') as f:\n            bin_base_offset = text_section_addr - ELFFile(f).get_section_by_name('.text').header['sh_addr']\n    for (category, lines) in got_entry.items():\n        for line in lines:\n            (offset, _, rtype, *rest) = line.split()[:5]\n            if len(rest) == 1:\n                value = rest[0]\n                name = ''\n            else:\n                (value, name) = rest\n            address = int(offset, 16) + bin_base_offset\n            if not accept_readonly and (not pwndbg.gdblib.vmmap.find(address).write):\n                continue\n            if not name and category == RelocationType.IRELATIVE:\n                if pwndbg.gdblib.arch.name == 'i386':\n                    name = '*ABS*'\n                else:\n                    name = f'*ABS*+0x{int(value, 16):x}'\n            if symbol_filter not in name:\n                continue\n            outputs.append({'name': name or '????', 'address': address})\n    outputs.sort(key=lambda x: x['address'])\n    relro_color = message.off\n    if 'Partial' in relro_status:\n        relro_color = message.warn\n    elif 'Full' in relro_status:\n        relro_color = message.on\n    print(f'State of the GOT of {message.notice(path)}:')\n    print(f'GOT protection: {relro_color(relro_status)} | Found {message.hint(len(outputs))} GOT entries passing the filter')\n    for output in outputs:\n        print(f\"[{M.get(output['address'])}] {message.hint(output['name'])} -> {pwndbg.chain.format(pwndbg.gdblib.memory.pvoid(output['address']))}\")",
            "def _got(path, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    local_path = pwndbg.gdblib.file.get_file(path, try_local_path=True)\n    relro_status = pwndbg.wrappers.checksec.relro_status(local_path)\n    pie_status = pwndbg.wrappers.checksec.pie_status(local_path)\n    got_entry = pwndbg.wrappers.readelf.get_got_entry(local_path)\n    outputs = []\n    if path == pwndbg.gdblib.proc.exe:\n        bin_base_offset = pwndbg.gdblib.proc.binary_base_addr if 'PIE enabled' in pie_status else 0\n    else:\n        text_section_addr = pwndbg.gdblib.info.parsed_sharedlibrary()[path][0]\n        with open(local_path, 'rb') as f:\n            bin_base_offset = text_section_addr - ELFFile(f).get_section_by_name('.text').header['sh_addr']\n    for (category, lines) in got_entry.items():\n        for line in lines:\n            (offset, _, rtype, *rest) = line.split()[:5]\n            if len(rest) == 1:\n                value = rest[0]\n                name = ''\n            else:\n                (value, name) = rest\n            address = int(offset, 16) + bin_base_offset\n            if not accept_readonly and (not pwndbg.gdblib.vmmap.find(address).write):\n                continue\n            if not name and category == RelocationType.IRELATIVE:\n                if pwndbg.gdblib.arch.name == 'i386':\n                    name = '*ABS*'\n                else:\n                    name = f'*ABS*+0x{int(value, 16):x}'\n            if symbol_filter not in name:\n                continue\n            outputs.append({'name': name or '????', 'address': address})\n    outputs.sort(key=lambda x: x['address'])\n    relro_color = message.off\n    if 'Partial' in relro_status:\n        relro_color = message.warn\n    elif 'Full' in relro_status:\n        relro_color = message.on\n    print(f'State of the GOT of {message.notice(path)}:')\n    print(f'GOT protection: {relro_color(relro_status)} | Found {message.hint(len(outputs))} GOT entries passing the filter')\n    for output in outputs:\n        print(f\"[{M.get(output['address'])}] {message.hint(output['name'])} -> {pwndbg.chain.format(pwndbg.gdblib.memory.pvoid(output['address']))}\")",
            "def _got(path, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    local_path = pwndbg.gdblib.file.get_file(path, try_local_path=True)\n    relro_status = pwndbg.wrappers.checksec.relro_status(local_path)\n    pie_status = pwndbg.wrappers.checksec.pie_status(local_path)\n    got_entry = pwndbg.wrappers.readelf.get_got_entry(local_path)\n    outputs = []\n    if path == pwndbg.gdblib.proc.exe:\n        bin_base_offset = pwndbg.gdblib.proc.binary_base_addr if 'PIE enabled' in pie_status else 0\n    else:\n        text_section_addr = pwndbg.gdblib.info.parsed_sharedlibrary()[path][0]\n        with open(local_path, 'rb') as f:\n            bin_base_offset = text_section_addr - ELFFile(f).get_section_by_name('.text').header['sh_addr']\n    for (category, lines) in got_entry.items():\n        for line in lines:\n            (offset, _, rtype, *rest) = line.split()[:5]\n            if len(rest) == 1:\n                value = rest[0]\n                name = ''\n            else:\n                (value, name) = rest\n            address = int(offset, 16) + bin_base_offset\n            if not accept_readonly and (not pwndbg.gdblib.vmmap.find(address).write):\n                continue\n            if not name and category == RelocationType.IRELATIVE:\n                if pwndbg.gdblib.arch.name == 'i386':\n                    name = '*ABS*'\n                else:\n                    name = f'*ABS*+0x{int(value, 16):x}'\n            if symbol_filter not in name:\n                continue\n            outputs.append({'name': name or '????', 'address': address})\n    outputs.sort(key=lambda x: x['address'])\n    relro_color = message.off\n    if 'Partial' in relro_status:\n        relro_color = message.warn\n    elif 'Full' in relro_status:\n        relro_color = message.on\n    print(f'State of the GOT of {message.notice(path)}:')\n    print(f'GOT protection: {relro_color(relro_status)} | Found {message.hint(len(outputs))} GOT entries passing the filter')\n    for output in outputs:\n        print(f\"[{M.get(output['address'])}] {message.hint(output['name'])} -> {pwndbg.chain.format(pwndbg.gdblib.memory.pvoid(output['address']))}\")",
            "def _got(path, accept_readonly, symbol_filter) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    local_path = pwndbg.gdblib.file.get_file(path, try_local_path=True)\n    relro_status = pwndbg.wrappers.checksec.relro_status(local_path)\n    pie_status = pwndbg.wrappers.checksec.pie_status(local_path)\n    got_entry = pwndbg.wrappers.readelf.get_got_entry(local_path)\n    outputs = []\n    if path == pwndbg.gdblib.proc.exe:\n        bin_base_offset = pwndbg.gdblib.proc.binary_base_addr if 'PIE enabled' in pie_status else 0\n    else:\n        text_section_addr = pwndbg.gdblib.info.parsed_sharedlibrary()[path][0]\n        with open(local_path, 'rb') as f:\n            bin_base_offset = text_section_addr - ELFFile(f).get_section_by_name('.text').header['sh_addr']\n    for (category, lines) in got_entry.items():\n        for line in lines:\n            (offset, _, rtype, *rest) = line.split()[:5]\n            if len(rest) == 1:\n                value = rest[0]\n                name = ''\n            else:\n                (value, name) = rest\n            address = int(offset, 16) + bin_base_offset\n            if not accept_readonly and (not pwndbg.gdblib.vmmap.find(address).write):\n                continue\n            if not name and category == RelocationType.IRELATIVE:\n                if pwndbg.gdblib.arch.name == 'i386':\n                    name = '*ABS*'\n                else:\n                    name = f'*ABS*+0x{int(value, 16):x}'\n            if symbol_filter not in name:\n                continue\n            outputs.append({'name': name or '????', 'address': address})\n    outputs.sort(key=lambda x: x['address'])\n    relro_color = message.off\n    if 'Partial' in relro_status:\n        relro_color = message.warn\n    elif 'Full' in relro_status:\n        relro_color = message.on\n    print(f'State of the GOT of {message.notice(path)}:')\n    print(f'GOT protection: {relro_color(relro_status)} | Found {message.hint(len(outputs))} GOT entries passing the filter')\n    for output in outputs:\n        print(f\"[{M.get(output['address'])}] {message.hint(output['name'])} -> {pwndbg.chain.format(pwndbg.gdblib.memory.pvoid(output['address']))}\")"
        ]
    }
]