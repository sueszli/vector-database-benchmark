[
    {
        "func_name": "test_parse_file_with_no_vuln_has_no_findings",
        "original": "def test_parse_file_with_no_vuln_has_no_findings(self):\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-zero-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(0, len(findings))",
        "mutated": [
            "def test_parse_file_with_no_vuln_has_no_findings(self):\n    if False:\n        i = 10\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-zero-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(0, len(findings))",
            "def test_parse_file_with_no_vuln_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-zero-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(0, len(findings))",
            "def test_parse_file_with_no_vuln_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-zero-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(0, len(findings))",
            "def test_parse_file_with_no_vuln_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-zero-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(0, len(findings))",
            "def test_parse_file_with_no_vuln_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-zero-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(0, len(findings))"
        ]
    },
    {
        "func_name": "test_parse_file_with_one_vuln_has_one_finding",
        "original": "def test_parse_file_with_one_vuln_has_one_finding(self):\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-single-vuln.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('2.11', finding.unique_id_from_tool)\n    self.assertIn('2.11 -', finding.title)\n    self.assertIn('some kind of remediation could be here', finding.mitigation)\n    self.assertIn('Ensure base device size is not changed until needed', finding.description)",
        "mutated": [
            "def test_parse_file_with_one_vuln_has_one_finding(self):\n    if False:\n        i = 10\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-single-vuln.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('2.11', finding.unique_id_from_tool)\n    self.assertIn('2.11 -', finding.title)\n    self.assertIn('some kind of remediation could be here', finding.mitigation)\n    self.assertIn('Ensure base device size is not changed until needed', finding.description)",
            "def test_parse_file_with_one_vuln_has_one_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-single-vuln.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('2.11', finding.unique_id_from_tool)\n    self.assertIn('2.11 -', finding.title)\n    self.assertIn('some kind of remediation could be here', finding.mitigation)\n    self.assertIn('Ensure base device size is not changed until needed', finding.description)",
            "def test_parse_file_with_one_vuln_has_one_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-single-vuln.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('2.11', finding.unique_id_from_tool)\n    self.assertIn('2.11 -', finding.title)\n    self.assertIn('some kind of remediation could be here', finding.mitigation)\n    self.assertIn('Ensure base device size is not changed until needed', finding.description)",
            "def test_parse_file_with_one_vuln_has_one_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-single-vuln.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('2.11', finding.unique_id_from_tool)\n    self.assertIn('2.11 -', finding.title)\n    self.assertIn('some kind of remediation could be here', finding.mitigation)\n    self.assertIn('Ensure base device size is not changed until needed', finding.description)",
            "def test_parse_file_with_one_vuln_has_one_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-single-vuln.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    testfile.close()\n    self.assertEqual(1, len(findings))\n    finding = findings[0]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('2.11', finding.unique_id_from_tool)\n    self.assertIn('2.11 -', finding.title)\n    self.assertIn('some kind of remediation could be here', finding.mitigation)\n    self.assertIn('Ensure base device size is not changed until needed', finding.description)"
        ]
    },
    {
        "func_name": "test_parse_file_with_multiple_vuln_has_multiple_findings",
        "original": "def test_parse_file_with_multiple_vuln_has_multiple_findings(self):\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-many-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertTrue(len(findings) == 50)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'CRITICAL')) == 0)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'HIGH')) == 32)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'LOW')) == 16)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'INFO')) == 2)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('1.1.4', finding.unique_id_from_tool)\n    self.assertIn('1.1.4 -', finding.title)\n    self.assertIn('Ensure auditing is configured for Docker files and directories -/run/containerd (Automated)', finding.description)\n    self.assertIn('Install auditd. Add -a exit,always -F path=/run/containerd -F perm=war -k docker to the /etc/audit/rules.d/audit.rules file. Then restart the audit daemon using command service auditd restart.', finding.mitigation)\n    self.assertIn('Audit can generate large log files. So you need to make sure that they are rotated and archived periodically. Create a separate partition for audit logs to avoid filling up other critical partitions.', finding.mitigation)\n    finding = findings[27]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual('2.18', finding.unique_id_from_tool)\n    self.assertIn('2.18 -', finding.title)\n    self.assertIn('Ensure that experimental features are not implemented in production (Scored)', finding.description)\n    self.assertIn('You should not pass --experimental as a runtime parameter to the Docker daemon on production systems.', finding.mitigation)\n    self.assertIn('mitigation impact: None.', finding.mitigation)\n    finding = findings[39]\n    self.assertEqual('Info', finding.severity)\n    self.assertEqual('4.5', finding.unique_id_from_tool)\n    self.assertIn('4.5 -', finding.title)\n    self.assertIn('Ensure Content trust for Docker is Enabled (Automated)', finding.description)\n    self.assertIn('Add DOCKER_CONTENT_TRUST variable to the /etc/environment file using command echo DOCKER_CONTENT_TRUST=1 | sudo tee -a /etc/environment.', finding.mitigation)\n    self.assertIn('This prevents users from working with tagged images unless they contain a signature.', finding.mitigation)",
        "mutated": [
            "def test_parse_file_with_multiple_vuln_has_multiple_findings(self):\n    if False:\n        i = 10\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-many-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertTrue(len(findings) == 50)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'CRITICAL')) == 0)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'HIGH')) == 32)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'LOW')) == 16)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'INFO')) == 2)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('1.1.4', finding.unique_id_from_tool)\n    self.assertIn('1.1.4 -', finding.title)\n    self.assertIn('Ensure auditing is configured for Docker files and directories -/run/containerd (Automated)', finding.description)\n    self.assertIn('Install auditd. Add -a exit,always -F path=/run/containerd -F perm=war -k docker to the /etc/audit/rules.d/audit.rules file. Then restart the audit daemon using command service auditd restart.', finding.mitigation)\n    self.assertIn('Audit can generate large log files. So you need to make sure that they are rotated and archived periodically. Create a separate partition for audit logs to avoid filling up other critical partitions.', finding.mitigation)\n    finding = findings[27]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual('2.18', finding.unique_id_from_tool)\n    self.assertIn('2.18 -', finding.title)\n    self.assertIn('Ensure that experimental features are not implemented in production (Scored)', finding.description)\n    self.assertIn('You should not pass --experimental as a runtime parameter to the Docker daemon on production systems.', finding.mitigation)\n    self.assertIn('mitigation impact: None.', finding.mitigation)\n    finding = findings[39]\n    self.assertEqual('Info', finding.severity)\n    self.assertEqual('4.5', finding.unique_id_from_tool)\n    self.assertIn('4.5 -', finding.title)\n    self.assertIn('Ensure Content trust for Docker is Enabled (Automated)', finding.description)\n    self.assertIn('Add DOCKER_CONTENT_TRUST variable to the /etc/environment file using command echo DOCKER_CONTENT_TRUST=1 | sudo tee -a /etc/environment.', finding.mitigation)\n    self.assertIn('This prevents users from working with tagged images unless they contain a signature.', finding.mitigation)",
            "def test_parse_file_with_multiple_vuln_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-many-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertTrue(len(findings) == 50)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'CRITICAL')) == 0)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'HIGH')) == 32)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'LOW')) == 16)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'INFO')) == 2)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('1.1.4', finding.unique_id_from_tool)\n    self.assertIn('1.1.4 -', finding.title)\n    self.assertIn('Ensure auditing is configured for Docker files and directories -/run/containerd (Automated)', finding.description)\n    self.assertIn('Install auditd. Add -a exit,always -F path=/run/containerd -F perm=war -k docker to the /etc/audit/rules.d/audit.rules file. Then restart the audit daemon using command service auditd restart.', finding.mitigation)\n    self.assertIn('Audit can generate large log files. So you need to make sure that they are rotated and archived periodically. Create a separate partition for audit logs to avoid filling up other critical partitions.', finding.mitigation)\n    finding = findings[27]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual('2.18', finding.unique_id_from_tool)\n    self.assertIn('2.18 -', finding.title)\n    self.assertIn('Ensure that experimental features are not implemented in production (Scored)', finding.description)\n    self.assertIn('You should not pass --experimental as a runtime parameter to the Docker daemon on production systems.', finding.mitigation)\n    self.assertIn('mitigation impact: None.', finding.mitigation)\n    finding = findings[39]\n    self.assertEqual('Info', finding.severity)\n    self.assertEqual('4.5', finding.unique_id_from_tool)\n    self.assertIn('4.5 -', finding.title)\n    self.assertIn('Ensure Content trust for Docker is Enabled (Automated)', finding.description)\n    self.assertIn('Add DOCKER_CONTENT_TRUST variable to the /etc/environment file using command echo DOCKER_CONTENT_TRUST=1 | sudo tee -a /etc/environment.', finding.mitigation)\n    self.assertIn('This prevents users from working with tagged images unless they contain a signature.', finding.mitigation)",
            "def test_parse_file_with_multiple_vuln_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-many-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertTrue(len(findings) == 50)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'CRITICAL')) == 0)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'HIGH')) == 32)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'LOW')) == 16)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'INFO')) == 2)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('1.1.4', finding.unique_id_from_tool)\n    self.assertIn('1.1.4 -', finding.title)\n    self.assertIn('Ensure auditing is configured for Docker files and directories -/run/containerd (Automated)', finding.description)\n    self.assertIn('Install auditd. Add -a exit,always -F path=/run/containerd -F perm=war -k docker to the /etc/audit/rules.d/audit.rules file. Then restart the audit daemon using command service auditd restart.', finding.mitigation)\n    self.assertIn('Audit can generate large log files. So you need to make sure that they are rotated and archived periodically. Create a separate partition for audit logs to avoid filling up other critical partitions.', finding.mitigation)\n    finding = findings[27]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual('2.18', finding.unique_id_from_tool)\n    self.assertIn('2.18 -', finding.title)\n    self.assertIn('Ensure that experimental features are not implemented in production (Scored)', finding.description)\n    self.assertIn('You should not pass --experimental as a runtime parameter to the Docker daemon on production systems.', finding.mitigation)\n    self.assertIn('mitigation impact: None.', finding.mitigation)\n    finding = findings[39]\n    self.assertEqual('Info', finding.severity)\n    self.assertEqual('4.5', finding.unique_id_from_tool)\n    self.assertIn('4.5 -', finding.title)\n    self.assertIn('Ensure Content trust for Docker is Enabled (Automated)', finding.description)\n    self.assertIn('Add DOCKER_CONTENT_TRUST variable to the /etc/environment file using command echo DOCKER_CONTENT_TRUST=1 | sudo tee -a /etc/environment.', finding.mitigation)\n    self.assertIn('This prevents users from working with tagged images unless they contain a signature.', finding.mitigation)",
            "def test_parse_file_with_multiple_vuln_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-many-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertTrue(len(findings) == 50)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'CRITICAL')) == 0)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'HIGH')) == 32)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'LOW')) == 16)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'INFO')) == 2)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('1.1.4', finding.unique_id_from_tool)\n    self.assertIn('1.1.4 -', finding.title)\n    self.assertIn('Ensure auditing is configured for Docker files and directories -/run/containerd (Automated)', finding.description)\n    self.assertIn('Install auditd. Add -a exit,always -F path=/run/containerd -F perm=war -k docker to the /etc/audit/rules.d/audit.rules file. Then restart the audit daemon using command service auditd restart.', finding.mitigation)\n    self.assertIn('Audit can generate large log files. So you need to make sure that they are rotated and archived periodically. Create a separate partition for audit logs to avoid filling up other critical partitions.', finding.mitigation)\n    finding = findings[27]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual('2.18', finding.unique_id_from_tool)\n    self.assertIn('2.18 -', finding.title)\n    self.assertIn('Ensure that experimental features are not implemented in production (Scored)', finding.description)\n    self.assertIn('You should not pass --experimental as a runtime parameter to the Docker daemon on production systems.', finding.mitigation)\n    self.assertIn('mitigation impact: None.', finding.mitigation)\n    finding = findings[39]\n    self.assertEqual('Info', finding.severity)\n    self.assertEqual('4.5', finding.unique_id_from_tool)\n    self.assertIn('4.5 -', finding.title)\n    self.assertIn('Ensure Content trust for Docker is Enabled (Automated)', finding.description)\n    self.assertIn('Add DOCKER_CONTENT_TRUST variable to the /etc/environment file using command echo DOCKER_CONTENT_TRUST=1 | sudo tee -a /etc/environment.', finding.mitigation)\n    self.assertIn('This prevents users from working with tagged images unless they contain a signature.', finding.mitigation)",
            "def test_parse_file_with_multiple_vuln_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    testfile = open(get_unit_tests_path() + '/scans/dockerbench/docker-bench-report-many-vulns.json')\n    parser = DockerBenchParser()\n    findings = parser.get_findings(testfile, Test())\n    self.assertTrue(len(findings) == 50)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'CRITICAL')) == 0)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'HIGH')) == 32)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'LOW')) == 16)\n    self.assertTrue(sum((1 for f in findings if f.severity.upper() == 'INFO')) == 2)\n    finding = findings[3]\n    self.assertEqual('High', finding.severity)\n    self.assertEqual('1.1.4', finding.unique_id_from_tool)\n    self.assertIn('1.1.4 -', finding.title)\n    self.assertIn('Ensure auditing is configured for Docker files and directories -/run/containerd (Automated)', finding.description)\n    self.assertIn('Install auditd. Add -a exit,always -F path=/run/containerd -F perm=war -k docker to the /etc/audit/rules.d/audit.rules file. Then restart the audit daemon using command service auditd restart.', finding.mitigation)\n    self.assertIn('Audit can generate large log files. So you need to make sure that they are rotated and archived periodically. Create a separate partition for audit logs to avoid filling up other critical partitions.', finding.mitigation)\n    finding = findings[27]\n    self.assertEqual('Low', finding.severity)\n    self.assertEqual('2.18', finding.unique_id_from_tool)\n    self.assertIn('2.18 -', finding.title)\n    self.assertIn('Ensure that experimental features are not implemented in production (Scored)', finding.description)\n    self.assertIn('You should not pass --experimental as a runtime parameter to the Docker daemon on production systems.', finding.mitigation)\n    self.assertIn('mitigation impact: None.', finding.mitigation)\n    finding = findings[39]\n    self.assertEqual('Info', finding.severity)\n    self.assertEqual('4.5', finding.unique_id_from_tool)\n    self.assertIn('4.5 -', finding.title)\n    self.assertIn('Ensure Content trust for Docker is Enabled (Automated)', finding.description)\n    self.assertIn('Add DOCKER_CONTENT_TRUST variable to the /etc/environment file using command echo DOCKER_CONTENT_TRUST=1 | sudo tee -a /etc/environment.', finding.mitigation)\n    self.assertIn('This prevents users from working with tagged images unless they contain a signature.', finding.mitigation)"
        ]
    }
]