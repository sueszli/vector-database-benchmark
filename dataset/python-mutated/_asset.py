"""
Definition of the Asset class to represent JS and CSS assets, and a derived
class used as a container for one or more JSModule classes.
"""
import sys
import types
from urllib.request import urlopen, Request
from . import logger
HEADER = 'Autogenerated code from Flexx. Code Subject to the BSD-2-clause license.'
HEADER = '/* %s */\n\n' % HEADER
url_starts = ('https://', 'http://')

def get_mod_name(ob):
    if False:
        return 10
    " Get the module name of an object (the name of a module object or\n    the name of the module in which the object is defined). Our naming\n    differs slighly from Python's in that the module in ``foo/bar/__init__.py``\n    would be named ``foo.bar.__init__``, which simplifies dependency handling\n    for Flexx. Note that such modules only occur if stuff is actually defined\n    in them.\n    "
    if not isinstance(ob, types.ModuleType):
        ob = sys.modules[ob.__module__]
    name = ob.__name__
    if module_is_package(ob):
        name += '.__init__'
    return name

def module_is_package(module):
    if False:
        while True:
            i = 10
    ' Get whether the given module represents a package.\n    '
    if hasattr(module, '__file__'):
        if module.__file__.rsplit('.', 1)[0].endswith('__init__'):
            return True
    return False

def solve_dependencies(things, warn_missing=False):
    if False:
        while True:
            i = 10
    ' Given a list of things, which each have a ``name`` and ``deps``\n    attribute, return a new list sorted to meet dependencies.\n    '
    assert isinstance(things, (tuple, list))
    names = [thing.name for thing in things]
    thingmap = dict([(n, t) for (n, t) in zip(names, things)])
    for index in range(len(names)):
        seen_names = set()
        while True:
            name = names[index]
            if name in seen_names:
                raise RuntimeError('Detected circular dependency!')
            seen_names.add(name)
            for dep in thingmap[name].deps:
                if dep not in names:
                    if warn_missing:
                        logger.warning('%r has missing dependency %r' % (name, dep))
                else:
                    j = names.index(dep)
                    if j > index:
                        names.insert(index, names.pop(j))
                        break
            else:
                break
    return [thingmap[name] for name in names]

class Asset:
    """ Class to represent an asset (JS or CSS) to be included on the page.
    Users will typically use ``app.assets.add_shared_asset()``, see the
    corresponding docs for details.
    """
    _counter = 0

    def __init__(self, name, source=None):
        if False:
            print('Hello World!')
        Asset._counter += 1
        self.i = Asset._counter
        if not isinstance(name, str):
            raise TypeError('Asset name must be str.')
        if name.startswith(url_starts):
            if source is not None:
                raise TypeError('Remote assets cannot have a source: %s' % name)
            source = name
            name = name.replace('\\', '/').split('/')[-1]
        if not name.lower().endswith(('.js', '.css')):
            raise ValueError('Asset name must end in .js or .css.')
        self._name = name
        self._remote = False
        self._source_str = None
        self._source = source
        if source is None:
            raise TypeError('Asset needs a source.')
        elif isinstance(source, str):
            if source.startswith(url_starts):
                self._remote = True
            elif source.startswith('file://'):
                raise TypeError('Cannot specify an asset using "file://", use http or open the file and use contents.')
            else:
                self._source_str = source
        elif callable(source):
            pass
        else:
            raise TypeError('Asset source must be str or callable.')

    def __repr__(self):
        if False:
            i = 10
            return i + 15
        return '<%s %r at 0x%0x>' % (self.__class__.__name__, self._name, id(self))

    @property
    def name(self):
        if False:
            return 10
        ' The (file) name of this asset.\n        '
        return self._name

    @property
    def source(self):
        if False:
            print('Hello World!')
        ' The source for this asset. Can be str, URL or callable.\n        '
        return self._source

    @property
    def remote(self):
        if False:
            return 10
        ' Whether the asset is remote (client will load it from elsewhere).\n        If True, the source specifies the URL.\n        '
        return self._remote

    def to_html(self, path='{}', link=3):
        if False:
            i = 10
            return i + 15
        " Get HTML element tag to include in the document.\n\n        Parameters:\n            path (str): the path of this asset, in which '{}' can be used as\n                a placeholder for the asset name.\n            link (int): whether to link to this asset:\n\n                * 0: the asset is embedded.\n                * 1: normal assets are embedded, remote assets remain remote.\n                * 2: the asset is linked (and served by our server).\n                * 3: (default) normal assets are linked, remote assets remain remote.\n        "
        path = path.replace('{}', self.name)
        if self.name.lower().endswith('.js'):
            if self.remote and link in (1, 3):
                return "<script src='%s' id='%s'></script>" % (self.source, self.name)
            elif link in (0, 1):
                code = self.to_string()
                s = '\n' if '\n' in code else ''
                return "<script id='%s'>%s%s%s</script>" % (self.name, s, code, s)
            else:
                return "<script src='%s' id='%s'></script>" % (path, self.name)
        elif self.name.lower().endswith('.css'):
            if self.remote and link in (1, 3):
                t = "<link rel='stylesheet' type='text/css' href='%s' id='%s' />"
                return t % (self.source, self.name)
            elif link in (0, 1):
                code = self.to_string()
                s = '\n' if '\n' in code else ''
                return "<style id='%s'>%s%s%s</style>" % (self.name, s, code, s)
            else:
                t = "<link rel='stylesheet' type='text/css' href='%s' id='%s' />"
                return t % (path, self.name)
        else:
            raise NameError('Assets must be .js or .css')

    def to_string(self):
        if False:
            while True:
                i = 10
        ' Get the string code for this asset. Even for remote assets.\n        '
        if self._source_str is None:
            if callable(self._source):
                self._source_str = self._source()
                if not isinstance(self._source_str, str):
                    t = 'Source function of asset %r did not return a str, but a %s.'
                    raise ValueError(t % (self.name, self._source.__class__.__name__))
            elif self._remote:
                self._source_str = self._get_from_url(self._source)
            else:
                raise RuntimeError('This should not happen')
        return self._source_str

    def _get_from_url(self, url):
        if False:
            return 10
        if url.startswith(url_starts):
            req = Request(url, headers={'User-Agent': 'flexx'})
            return urlopen(req, timeout=5.0).read().decode()
        else:
            raise ValueError('_get_from_url() needs a URL string.')

class Bundle(Asset):
    """ A bundle is an asset that represents a collection of Asset objects
    and JSModule objects. In the output, the source for the modules occurs
    after the sources of the assets. Dependency resolution is honoured for
    the modules, and the bundle exposes an aggregate of the dependencies,
    so that bundles can themselves be sorted.
    """

    def __init__(self, name):
        if False:
            for i in range(10):
                print('nop')
        super().__init__(name, '')
        self._assets = []
        self._module_name = name.rsplit('.', 1)[0].split('-')[0]
        self._modules = []
        self._deps = set()
        self._need_sort = False

    def __repr__(self):
        if False:
            while True:
                i = 10
        t = '<%s %r with %i assets and %i modules at 0x%0x>'
        return t % (self.__class__.__name__, self._name, len(self._assets), len(self._modules), id(self))

    def add_asset(self, a):
        if False:
            print('Hello World!')
        ' Add an asset to the bundle. Assets added this way occur before the\n        code for the modules in this bundle.\n        '
        if not isinstance(a, Asset):
            raise TypeError('Bundles.add_asset() needs an Asset, not %s.' % a.__class__.__name__)
        if isinstance(a, Bundle):
            raise TypeError('Bundles can contain assets and modules, but not bundles.')
        self._assets.append(a)

    def add_module(self, m):
        if False:
            print('Hello World!')
        ' Add a module to the bundle. This will (lazily) invoke a\n        sort of the list of modules, and define dependencies to other\n        bundles, so that bundles themselves can be sorted.\n        '
        ext = '.' + self.name.rsplit('.')[-1].lower()
        if not m.name.startswith(self._module_name):
            raise ValueError('Module %s does not belong in bundle %s.' % (m.name, self.name))
        self._modules.append(m)
        self._need_sort = True
        deps = set()
        for dep in m.deps:
            while '.' in dep:
                deps.add(dep)
                dep = dep.rsplit('.', 1)[0]
            deps.add(dep)
        for dep in deps:
            if not (dep.startswith(self._module_name) or self._module_name.startswith(dep + '.')):
                self._deps.add(dep + ext)

    @property
    def assets(self):
        if False:
            while True:
                i = 10
        ' The list of assets in this bundle (excluding modules).\n        '
        return tuple(self._assets)

    @property
    def modules(self):
        if False:
            for i in range(10):
                print('nop')
        ' The list of modules, sorted by name and dependencies.\n        '
        if self._need_sort:
            f = lambda m: m.name
            self._modules = solve_dependencies(sorted(self._modules, key=f))
        return tuple(self._modules)

    @property
    def deps(self):
        if False:
            for i in range(10):
                print('nop')
        ' The set of dependencies for this bundle, expressed in module names.\n        '
        return self._deps

    def to_string(self):
        if False:
            print('Hello World!')
        isjs = self.name.lower().endswith('.js')
        toc = []
        source = []
        for a in self.assets:
            toc.append('- asset ' + a.name)
            source.append('/* ' + (' %s ' % a.name).center(70, '=') + '*/')
            source.append(a.to_string())
        for m in self.modules:
            s = m.get_js() if isjs else m.get_css()
            toc.append('- module ' + m.name)
            source.append('/* ' + (' %s ' % m.name).center(70, '=') + '*/')
            source.append(HEADER)
            source.append(s)
        if len(self.assets + self.modules) > 1:
            source.insert(0, '/* Bundle contents:\n' + '\n'.join(toc) + '\n*/\n')
        return '\n\n'.join(source)