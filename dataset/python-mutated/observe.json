[
    {
        "func_name": "observe",
        "original": "def observe(source_assets: Sequence[SourceAsset], run_config: Any=None, instance: Optional[DagsterInstance]=None, resources: Optional[Mapping[str, object]]=None, partition_key: Optional[str]=None, raise_on_error: bool=True, tags: Optional[Mapping[str, str]]=None) -> 'ExecuteInProcessResult':\n    \"\"\"Executes a single-threaded, in-process run which observes provided source assets.\n\n    By default, will materialize assets to the local filesystem.\n\n    Args:\n        source_assets (Sequence[SourceAsset]):\n            The source assets to materialize.\n        resources (Optional[Mapping[str, object]]):\n            The resources needed for execution. Can provide resource instances\n            directly, or resource definitions. Note that if provided resources\n            conflict with resources directly on assets, an error will be thrown.\n        run_config (Optional[Any]): The run config to use for the run that materializes the assets.\n        partition_key: (Optional[str])\n            The string partition key that specifies the run config to execute. Can only be used\n            to select run config for assets with partitioned config.\n        tags (Optional[Mapping[str, str]]): Tags for the run.\n\n    Returns:\n        ExecuteInProcessResult: The result of the execution.\n    \"\"\"\n    source_assets = check.sequence_param(source_assets, 'assets', of_type=SourceAsset)\n    instance = check.opt_inst_param(instance, 'instance', DagsterInstance)\n    partition_key = check.opt_str_param(partition_key, 'partition_key')\n    resources = check.opt_mapping_param(resources, 'resources', key_type=str)\n    with disable_dagster_warnings():\n        observation_job = build_assets_job('in_process_observation_job', [], source_assets)\n        defs = Definitions(assets=source_assets, jobs=[observation_job], resources=resources)\n        return defs.get_job_def('in_process_observation_job').execute_in_process(run_config=run_config, instance=instance, partition_key=partition_key, raise_on_error=raise_on_error, tags=tags)",
        "mutated": [
            "def observe(source_assets: Sequence[SourceAsset], run_config: Any=None, instance: Optional[DagsterInstance]=None, resources: Optional[Mapping[str, object]]=None, partition_key: Optional[str]=None, raise_on_error: bool=True, tags: Optional[Mapping[str, str]]=None) -> 'ExecuteInProcessResult':\n    if False:\n        i = 10\n    'Executes a single-threaded, in-process run which observes provided source assets.\\n\\n    By default, will materialize assets to the local filesystem.\\n\\n    Args:\\n        source_assets (Sequence[SourceAsset]):\\n            The source assets to materialize.\\n        resources (Optional[Mapping[str, object]]):\\n            The resources needed for execution. Can provide resource instances\\n            directly, or resource definitions. Note that if provided resources\\n            conflict with resources directly on assets, an error will be thrown.\\n        run_config (Optional[Any]): The run config to use for the run that materializes the assets.\\n        partition_key: (Optional[str])\\n            The string partition key that specifies the run config to execute. Can only be used\\n            to select run config for assets with partitioned config.\\n        tags (Optional[Mapping[str, str]]): Tags for the run.\\n\\n    Returns:\\n        ExecuteInProcessResult: The result of the execution.\\n    '\n    source_assets = check.sequence_param(source_assets, 'assets', of_type=SourceAsset)\n    instance = check.opt_inst_param(instance, 'instance', DagsterInstance)\n    partition_key = check.opt_str_param(partition_key, 'partition_key')\n    resources = check.opt_mapping_param(resources, 'resources', key_type=str)\n    with disable_dagster_warnings():\n        observation_job = build_assets_job('in_process_observation_job', [], source_assets)\n        defs = Definitions(assets=source_assets, jobs=[observation_job], resources=resources)\n        return defs.get_job_def('in_process_observation_job').execute_in_process(run_config=run_config, instance=instance, partition_key=partition_key, raise_on_error=raise_on_error, tags=tags)",
            "def observe(source_assets: Sequence[SourceAsset], run_config: Any=None, instance: Optional[DagsterInstance]=None, resources: Optional[Mapping[str, object]]=None, partition_key: Optional[str]=None, raise_on_error: bool=True, tags: Optional[Mapping[str, str]]=None) -> 'ExecuteInProcessResult':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Executes a single-threaded, in-process run which observes provided source assets.\\n\\n    By default, will materialize assets to the local filesystem.\\n\\n    Args:\\n        source_assets (Sequence[SourceAsset]):\\n            The source assets to materialize.\\n        resources (Optional[Mapping[str, object]]):\\n            The resources needed for execution. Can provide resource instances\\n            directly, or resource definitions. Note that if provided resources\\n            conflict with resources directly on assets, an error will be thrown.\\n        run_config (Optional[Any]): The run config to use for the run that materializes the assets.\\n        partition_key: (Optional[str])\\n            The string partition key that specifies the run config to execute. Can only be used\\n            to select run config for assets with partitioned config.\\n        tags (Optional[Mapping[str, str]]): Tags for the run.\\n\\n    Returns:\\n        ExecuteInProcessResult: The result of the execution.\\n    '\n    source_assets = check.sequence_param(source_assets, 'assets', of_type=SourceAsset)\n    instance = check.opt_inst_param(instance, 'instance', DagsterInstance)\n    partition_key = check.opt_str_param(partition_key, 'partition_key')\n    resources = check.opt_mapping_param(resources, 'resources', key_type=str)\n    with disable_dagster_warnings():\n        observation_job = build_assets_job('in_process_observation_job', [], source_assets)\n        defs = Definitions(assets=source_assets, jobs=[observation_job], resources=resources)\n        return defs.get_job_def('in_process_observation_job').execute_in_process(run_config=run_config, instance=instance, partition_key=partition_key, raise_on_error=raise_on_error, tags=tags)",
            "def observe(source_assets: Sequence[SourceAsset], run_config: Any=None, instance: Optional[DagsterInstance]=None, resources: Optional[Mapping[str, object]]=None, partition_key: Optional[str]=None, raise_on_error: bool=True, tags: Optional[Mapping[str, str]]=None) -> 'ExecuteInProcessResult':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Executes a single-threaded, in-process run which observes provided source assets.\\n\\n    By default, will materialize assets to the local filesystem.\\n\\n    Args:\\n        source_assets (Sequence[SourceAsset]):\\n            The source assets to materialize.\\n        resources (Optional[Mapping[str, object]]):\\n            The resources needed for execution. Can provide resource instances\\n            directly, or resource definitions. Note that if provided resources\\n            conflict with resources directly on assets, an error will be thrown.\\n        run_config (Optional[Any]): The run config to use for the run that materializes the assets.\\n        partition_key: (Optional[str])\\n            The string partition key that specifies the run config to execute. Can only be used\\n            to select run config for assets with partitioned config.\\n        tags (Optional[Mapping[str, str]]): Tags for the run.\\n\\n    Returns:\\n        ExecuteInProcessResult: The result of the execution.\\n    '\n    source_assets = check.sequence_param(source_assets, 'assets', of_type=SourceAsset)\n    instance = check.opt_inst_param(instance, 'instance', DagsterInstance)\n    partition_key = check.opt_str_param(partition_key, 'partition_key')\n    resources = check.opt_mapping_param(resources, 'resources', key_type=str)\n    with disable_dagster_warnings():\n        observation_job = build_assets_job('in_process_observation_job', [], source_assets)\n        defs = Definitions(assets=source_assets, jobs=[observation_job], resources=resources)\n        return defs.get_job_def('in_process_observation_job').execute_in_process(run_config=run_config, instance=instance, partition_key=partition_key, raise_on_error=raise_on_error, tags=tags)",
            "def observe(source_assets: Sequence[SourceAsset], run_config: Any=None, instance: Optional[DagsterInstance]=None, resources: Optional[Mapping[str, object]]=None, partition_key: Optional[str]=None, raise_on_error: bool=True, tags: Optional[Mapping[str, str]]=None) -> 'ExecuteInProcessResult':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Executes a single-threaded, in-process run which observes provided source assets.\\n\\n    By default, will materialize assets to the local filesystem.\\n\\n    Args:\\n        source_assets (Sequence[SourceAsset]):\\n            The source assets to materialize.\\n        resources (Optional[Mapping[str, object]]):\\n            The resources needed for execution. Can provide resource instances\\n            directly, or resource definitions. Note that if provided resources\\n            conflict with resources directly on assets, an error will be thrown.\\n        run_config (Optional[Any]): The run config to use for the run that materializes the assets.\\n        partition_key: (Optional[str])\\n            The string partition key that specifies the run config to execute. Can only be used\\n            to select run config for assets with partitioned config.\\n        tags (Optional[Mapping[str, str]]): Tags for the run.\\n\\n    Returns:\\n        ExecuteInProcessResult: The result of the execution.\\n    '\n    source_assets = check.sequence_param(source_assets, 'assets', of_type=SourceAsset)\n    instance = check.opt_inst_param(instance, 'instance', DagsterInstance)\n    partition_key = check.opt_str_param(partition_key, 'partition_key')\n    resources = check.opt_mapping_param(resources, 'resources', key_type=str)\n    with disable_dagster_warnings():\n        observation_job = build_assets_job('in_process_observation_job', [], source_assets)\n        defs = Definitions(assets=source_assets, jobs=[observation_job], resources=resources)\n        return defs.get_job_def('in_process_observation_job').execute_in_process(run_config=run_config, instance=instance, partition_key=partition_key, raise_on_error=raise_on_error, tags=tags)",
            "def observe(source_assets: Sequence[SourceAsset], run_config: Any=None, instance: Optional[DagsterInstance]=None, resources: Optional[Mapping[str, object]]=None, partition_key: Optional[str]=None, raise_on_error: bool=True, tags: Optional[Mapping[str, str]]=None) -> 'ExecuteInProcessResult':\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Executes a single-threaded, in-process run which observes provided source assets.\\n\\n    By default, will materialize assets to the local filesystem.\\n\\n    Args:\\n        source_assets (Sequence[SourceAsset]):\\n            The source assets to materialize.\\n        resources (Optional[Mapping[str, object]]):\\n            The resources needed for execution. Can provide resource instances\\n            directly, or resource definitions. Note that if provided resources\\n            conflict with resources directly on assets, an error will be thrown.\\n        run_config (Optional[Any]): The run config to use for the run that materializes the assets.\\n        partition_key: (Optional[str])\\n            The string partition key that specifies the run config to execute. Can only be used\\n            to select run config for assets with partitioned config.\\n        tags (Optional[Mapping[str, str]]): Tags for the run.\\n\\n    Returns:\\n        ExecuteInProcessResult: The result of the execution.\\n    '\n    source_assets = check.sequence_param(source_assets, 'assets', of_type=SourceAsset)\n    instance = check.opt_inst_param(instance, 'instance', DagsterInstance)\n    partition_key = check.opt_str_param(partition_key, 'partition_key')\n    resources = check.opt_mapping_param(resources, 'resources', key_type=str)\n    with disable_dagster_warnings():\n        observation_job = build_assets_job('in_process_observation_job', [], source_assets)\n        defs = Definitions(assets=source_assets, jobs=[observation_job], resources=resources)\n        return defs.get_job_def('in_process_observation_job').execute_in_process(run_config=run_config, instance=instance, partition_key=partition_key, raise_on_error=raise_on_error, tags=tags)"
        ]
    }
]