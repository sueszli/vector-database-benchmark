[
    {
        "func_name": "test_backtest_position_adjustment",
        "original": "def test_backtest_position_adjustment(default_conf, fee, mocker, testdatadir) -> None:\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch('freqtrade.optimize.backtesting.amount_to_contract_precision', lambda x, *args, **kwargs: round(x, 8))\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3'})\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    backtesting.strategy.position_adjustment_enable = True\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [500.0, 100.0], 'max_stake_amount': [500.0, 100], 'amount': [4806.87657523, 970.63960782], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 0, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.10401764894444211, 0.10302485], 'close_rate': [0.10453904066847439, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [200, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10481985, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000]})\n    pd.testing.assert_frame_equal(results.drop(columns=['orders']), expected)\n    data_pair = processed[pair]\n    assert len(results.iloc[0]['orders']) == 6\n    assert len(results.iloc[1]['orders']) == 2\n    for (_, t) in results.iterrows():\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert ln is not None\n        ln = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln.iloc[0]['high'], 6)",
        "mutated": [
            "def test_backtest_position_adjustment(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch('freqtrade.optimize.backtesting.amount_to_contract_precision', lambda x, *args, **kwargs: round(x, 8))\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3'})\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    backtesting.strategy.position_adjustment_enable = True\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [500.0, 100.0], 'max_stake_amount': [500.0, 100], 'amount': [4806.87657523, 970.63960782], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 0, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.10401764894444211, 0.10302485], 'close_rate': [0.10453904066847439, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [200, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10481985, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000]})\n    pd.testing.assert_frame_equal(results.drop(columns=['orders']), expected)\n    data_pair = processed[pair]\n    assert len(results.iloc[0]['orders']) == 6\n    assert len(results.iloc[1]['orders']) == 2\n    for (_, t) in results.iterrows():\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert ln is not None\n        ln = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln.iloc[0]['high'], 6)",
            "def test_backtest_position_adjustment(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch('freqtrade.optimize.backtesting.amount_to_contract_precision', lambda x, *args, **kwargs: round(x, 8))\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3'})\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    backtesting.strategy.position_adjustment_enable = True\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [500.0, 100.0], 'max_stake_amount': [500.0, 100], 'amount': [4806.87657523, 970.63960782], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 0, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.10401764894444211, 0.10302485], 'close_rate': [0.10453904066847439, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [200, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10481985, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000]})\n    pd.testing.assert_frame_equal(results.drop(columns=['orders']), expected)\n    data_pair = processed[pair]\n    assert len(results.iloc[0]['orders']) == 6\n    assert len(results.iloc[1]['orders']) == 2\n    for (_, t) in results.iterrows():\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert ln is not None\n        ln = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln.iloc[0]['high'], 6)",
            "def test_backtest_position_adjustment(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch('freqtrade.optimize.backtesting.amount_to_contract_precision', lambda x, *args, **kwargs: round(x, 8))\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3'})\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    backtesting.strategy.position_adjustment_enable = True\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [500.0, 100.0], 'max_stake_amount': [500.0, 100], 'amount': [4806.87657523, 970.63960782], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 0, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.10401764894444211, 0.10302485], 'close_rate': [0.10453904066847439, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [200, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10481985, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000]})\n    pd.testing.assert_frame_equal(results.drop(columns=['orders']), expected)\n    data_pair = processed[pair]\n    assert len(results.iloc[0]['orders']) == 6\n    assert len(results.iloc[1]['orders']) == 2\n    for (_, t) in results.iterrows():\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert ln is not None\n        ln = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln.iloc[0]['high'], 6)",
            "def test_backtest_position_adjustment(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch('freqtrade.optimize.backtesting.amount_to_contract_precision', lambda x, *args, **kwargs: round(x, 8))\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3'})\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    backtesting.strategy.position_adjustment_enable = True\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [500.0, 100.0], 'max_stake_amount': [500.0, 100], 'amount': [4806.87657523, 970.63960782], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 0, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.10401764894444211, 0.10302485], 'close_rate': [0.10453904066847439, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [200, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10481985, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000]})\n    pd.testing.assert_frame_equal(results.drop(columns=['orders']), expected)\n    data_pair = processed[pair]\n    assert len(results.iloc[0]['orders']) == 6\n    assert len(results.iloc[1]['orders']) == 2\n    for (_, t) in results.iterrows():\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert ln is not None\n        ln = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln.iloc[0]['high'], 6)",
            "def test_backtest_position_adjustment(default_conf, fee, mocker, testdatadir) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf['use_exit_signal'] = False\n    default_conf['max_open_trades'] = 10\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch('freqtrade.optimize.backtesting.amount_to_contract_precision', lambda x, *args, **kwargs: round(x, 8))\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=1e-05)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3'})\n    backtesting = Backtesting(default_conf)\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'UNITTEST/BTC'\n    timerange = TimeRange('date', None, 1517227800, 0)\n    data = history.load_data(datadir=testdatadir, timeframe='5m', pairs=['UNITTEST/BTC'], timerange=timerange)\n    backtesting.strategy.position_adjustment_enable = True\n    processed = backtesting.strategy.advise_all_indicators(data)\n    (min_date, max_date) = get_timerange(processed)\n    result = backtesting.backtest(processed=deepcopy(processed), start_date=min_date, end_date=max_date)\n    results = result['results']\n    assert not results.empty\n    assert len(results) == 2\n    expected = pd.DataFrame({'pair': [pair, pair], 'stake_amount': [500.0, 100.0], 'max_stake_amount': [500.0, 100], 'amount': [4806.87657523, 970.63960782], 'open_date': pd.to_datetime([dt_utc(2018, 1, 29, 18, 40, 0), dt_utc(2018, 1, 30, 3, 30, 0)], utc=True), 'close_date': pd.to_datetime([dt_utc(2018, 1, 29, 22, 0, 0), dt_utc(2018, 1, 30, 4, 10, 0)], utc=True), 'open_rate': [0.10401764894444211, 0.10302485], 'close_rate': [0.10453904066847439, 0.103541], 'fee_open': [0.0025, 0.0025], 'fee_close': [0.0025, 0.0025], 'trade_duration': [200, 40], 'profit_ratio': [0.0, 0.0], 'profit_abs': [0.0, 0.0], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value], 'initial_stop_loss_abs': [0.0940005, 0.09272236], 'initial_stop_loss_ratio': [-0.1, -0.1], 'stop_loss_abs': [0.0940005, 0.09272236], 'stop_loss_ratio': [-0.1, -0.1], 'min_rate': [0.10370188, 0.10300000000000001], 'max_rate': [0.10481985, 0.1038888], 'is_open': [False, False], 'enter_tag': [None, None], 'leverage': [1.0, 1.0], 'is_short': [False, False], 'open_timestamp': [1517251200000, 1517283000000], 'close_timestamp': [1517265300000, 1517285400000]})\n    pd.testing.assert_frame_equal(results.drop(columns=['orders']), expected)\n    data_pair = processed[pair]\n    assert len(results.iloc[0]['orders']) == 6\n    assert len(results.iloc[1]['orders']) == 2\n    for (_, t) in results.iterrows():\n        ln = data_pair.loc[data_pair['date'] == t['open_date']]\n        assert ln is not None\n        ln = data_pair.loc[data_pair['date'] == t['close_date']]\n        assert round(ln.iloc[0]['open'], 6) == round(t['close_rate'], 6) or round(ln.iloc[0]['low'], 6) < round(t['close_rate'], 6) < round(ln.iloc[0]['high'], 6)"
        ]
    },
    {
        "func_name": "test_backtest_position_adjustment_detailed",
        "original": "@pytest.mark.parametrize('leverage', [1, 2])\ndef test_backtest_position_adjustment_detailed(default_conf, fee, mocker, leverage) -> None:\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=10)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=10)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.1, 0.1))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3', 'trading_mode': 'futures', 'margin_mode': 'isolated'})\n    default_conf['pairlists'] = [{'method': 'StaticPairList', 'allow_inactive': True}]\n    backtesting = Backtesting(default_conf)\n    backtesting._can_short = True\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'XRP/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 2.1, 2.2, 1.9, 2.1, 1, 0, 0, 0, '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=leverage)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    current_time = row[0].to_pydatetime()\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=None)\n    assert pytest.approx(trade.liquidation_price) == (0.10278333 if leverage == 1 else 1.2122249)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-500)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert trade.nr_of_successful_entries == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-99)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)",
        "mutated": [
            "@pytest.mark.parametrize('leverage', [1, 2])\ndef test_backtest_position_adjustment_detailed(default_conf, fee, mocker, leverage) -> None:\n    if False:\n        i = 10\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=10)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=10)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.1, 0.1))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3', 'trading_mode': 'futures', 'margin_mode': 'isolated'})\n    default_conf['pairlists'] = [{'method': 'StaticPairList', 'allow_inactive': True}]\n    backtesting = Backtesting(default_conf)\n    backtesting._can_short = True\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'XRP/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 2.1, 2.2, 1.9, 2.1, 1, 0, 0, 0, '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=leverage)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    current_time = row[0].to_pydatetime()\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=None)\n    assert pytest.approx(trade.liquidation_price) == (0.10278333 if leverage == 1 else 1.2122249)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-500)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert trade.nr_of_successful_entries == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-99)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)",
            "@pytest.mark.parametrize('leverage', [1, 2])\ndef test_backtest_position_adjustment_detailed(default_conf, fee, mocker, leverage) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=10)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=10)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.1, 0.1))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3', 'trading_mode': 'futures', 'margin_mode': 'isolated'})\n    default_conf['pairlists'] = [{'method': 'StaticPairList', 'allow_inactive': True}]\n    backtesting = Backtesting(default_conf)\n    backtesting._can_short = True\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'XRP/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 2.1, 2.2, 1.9, 2.1, 1, 0, 0, 0, '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=leverage)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    current_time = row[0].to_pydatetime()\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=None)\n    assert pytest.approx(trade.liquidation_price) == (0.10278333 if leverage == 1 else 1.2122249)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-500)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert trade.nr_of_successful_entries == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-99)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)",
            "@pytest.mark.parametrize('leverage', [1, 2])\ndef test_backtest_position_adjustment_detailed(default_conf, fee, mocker, leverage) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=10)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=10)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.1, 0.1))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3', 'trading_mode': 'futures', 'margin_mode': 'isolated'})\n    default_conf['pairlists'] = [{'method': 'StaticPairList', 'allow_inactive': True}]\n    backtesting = Backtesting(default_conf)\n    backtesting._can_short = True\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'XRP/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 2.1, 2.2, 1.9, 2.1, 1, 0, 0, 0, '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=leverage)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    current_time = row[0].to_pydatetime()\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=None)\n    assert pytest.approx(trade.liquidation_price) == (0.10278333 if leverage == 1 else 1.2122249)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-500)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert trade.nr_of_successful_entries == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-99)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)",
            "@pytest.mark.parametrize('leverage', [1, 2])\ndef test_backtest_position_adjustment_detailed(default_conf, fee, mocker, leverage) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=10)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=10)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.1, 0.1))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3', 'trading_mode': 'futures', 'margin_mode': 'isolated'})\n    default_conf['pairlists'] = [{'method': 'StaticPairList', 'allow_inactive': True}]\n    backtesting = Backtesting(default_conf)\n    backtesting._can_short = True\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'XRP/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 2.1, 2.2, 1.9, 2.1, 1, 0, 0, 0, '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=leverage)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    current_time = row[0].to_pydatetime()\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=None)\n    assert pytest.approx(trade.liquidation_price) == (0.10278333 if leverage == 1 else 1.2122249)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-500)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert trade.nr_of_successful_entries == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-99)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)",
            "@pytest.mark.parametrize('leverage', [1, 2])\ndef test_backtest_position_adjustment_detailed(default_conf, fee, mocker, leverage) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf['use_exit_signal'] = False\n    mocker.patch(f'{EXMS}.get_fee', fee)\n    mocker.patch(f'{EXMS}.get_min_pair_stake_amount', return_value=10)\n    mocker.patch(f'{EXMS}.get_max_pair_stake_amount', return_value=float('inf'))\n    mocker.patch(f'{EXMS}.get_max_leverage', return_value=10)\n    mocker.patch(f'{EXMS}.get_maintenance_ratio_and_amt', return_value=(0.1, 0.1))\n    patch_exchange(mocker)\n    default_conf.update({'stake_amount': 100.0, 'dry_run_wallet': 1000.0, 'strategy': 'StrategyTestV3', 'trading_mode': 'futures', 'margin_mode': 'isolated'})\n    default_conf['pairlists'] = [{'method': 'StaticPairList', 'allow_inactive': True}]\n    backtesting = Backtesting(default_conf)\n    backtesting._can_short = True\n    backtesting._set_strategy(backtesting.strategylist[0])\n    pair = 'XRP/USDT:USDT'\n    row = [pd.Timestamp(year=2020, month=1, day=1, hour=5, minute=0), 2.1, 2.2, 1.9, 2.1, 1, 0, 0, 0, '', '']\n    backtesting.strategy.leverage = MagicMock(return_value=leverage)\n    trade = backtesting._enter_trade(pair, row=row, direction='long')\n    current_time = row[0].to_pydatetime()\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=None)\n    assert pytest.approx(trade.liquidation_price) == (0.10278333 if leverage == 1 else 1.2122249)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 1\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-500)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 200.0\n    assert pytest.approx(trade.amount) == 95.23809524 * leverage\n    assert len(trade.orders) == 2\n    assert trade.nr_of_successful_entries == 2\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-100)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)\n    backtesting.strategy.adjust_trade_position = MagicMock(return_value=-99)\n    trade = backtesting._get_adjust_trade_entry_for_candle(trade, row, current_time)\n    assert trade\n    assert pytest.approx(trade.stake_amount) == 100.0\n    assert pytest.approx(trade.amount) == 47.61904762 * leverage\n    assert len(trade.orders) == 3\n    assert trade.nr_of_successful_entries == 2\n    assert trade.nr_of_successful_exits == 1\n    assert pytest.approx(trade.liquidation_price) == (0.1038916 if leverage == 1 else 1.2127791)"
        ]
    }
]