[
    {
        "func_name": "error",
        "original": "def error(msg: str) -> None:\n    global errors\n    errors.append(msg)\n    print('ERROR:', msg)",
        "mutated": [
            "def error(msg: str) -> None:\n    if False:\n        i = 10\n    global errors\n    errors.append(msg)\n    print('ERROR:', msg)",
            "def error(msg: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    global errors\n    errors.append(msg)\n    print('ERROR:', msg)",
            "def error(msg: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    global errors\n    errors.append(msg)\n    print('ERROR:', msg)",
            "def error(msg: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    global errors\n    errors.append(msg)\n    print('ERROR:', msg)",
            "def error(msg: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    global errors\n    errors.append(msg)\n    print('ERROR:', msg)"
        ]
    },
    {
        "func_name": "warning",
        "original": "def warning(msg: str) -> None:\n    print('WARNING:', msg)",
        "mutated": [
            "def warning(msg: str) -> None:\n    if False:\n        i = 10\n    print('WARNING:', msg)",
            "def warning(msg: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('WARNING:', msg)",
            "def warning(msg: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('WARNING:', msg)",
            "def warning(msg: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('WARNING:', msg)",
            "def warning(msg: str) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('WARNING:', msg)"
        ]
    },
    {
        "func_name": "parse_requirements",
        "original": "def parse_requirements(fname) -> Iterator[tuple[str, int, int, int | None]]:\n    \"\"\"Load requirements/min-all-deps.yml\n\n    Yield (package name, major version, minor version, [patch version])\n    \"\"\"\n    global errors\n    with open(fname) as fh:\n        contents = yaml.safe_load(fh)\n    for row in contents['dependencies']:\n        if isinstance(row, dict) and list(row) == ['pip']:\n            continue\n        (pkg, eq, version) = row.partition('=')\n        if pkg.rstrip('<>') in IGNORE_DEPS:\n            continue\n        if pkg.endswith('<') or pkg.endswith('>') or eq != '=':\n            error('package should be pinned with exact version: ' + row)\n            continue\n        try:\n            version_tup = tuple((int(x) for x in version.split('.')))\n        except ValueError:\n            raise ValueError('non-numerical version: ' + row)\n        if len(version_tup) == 2:\n            yield (pkg, *version_tup, None)\n        elif len(version_tup) == 3:\n            yield (pkg, *version_tup)\n        else:\n            raise ValueError('expected major.minor or major.minor.patch: ' + row)",
        "mutated": [
            "def parse_requirements(fname) -> Iterator[tuple[str, int, int, int | None]]:\n    if False:\n        i = 10\n    'Load requirements/min-all-deps.yml\\n\\n    Yield (package name, major version, minor version, [patch version])\\n    '\n    global errors\n    with open(fname) as fh:\n        contents = yaml.safe_load(fh)\n    for row in contents['dependencies']:\n        if isinstance(row, dict) and list(row) == ['pip']:\n            continue\n        (pkg, eq, version) = row.partition('=')\n        if pkg.rstrip('<>') in IGNORE_DEPS:\n            continue\n        if pkg.endswith('<') or pkg.endswith('>') or eq != '=':\n            error('package should be pinned with exact version: ' + row)\n            continue\n        try:\n            version_tup = tuple((int(x) for x in version.split('.')))\n        except ValueError:\n            raise ValueError('non-numerical version: ' + row)\n        if len(version_tup) == 2:\n            yield (pkg, *version_tup, None)\n        elif len(version_tup) == 3:\n            yield (pkg, *version_tup)\n        else:\n            raise ValueError('expected major.minor or major.minor.patch: ' + row)",
            "def parse_requirements(fname) -> Iterator[tuple[str, int, int, int | None]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Load requirements/min-all-deps.yml\\n\\n    Yield (package name, major version, minor version, [patch version])\\n    '\n    global errors\n    with open(fname) as fh:\n        contents = yaml.safe_load(fh)\n    for row in contents['dependencies']:\n        if isinstance(row, dict) and list(row) == ['pip']:\n            continue\n        (pkg, eq, version) = row.partition('=')\n        if pkg.rstrip('<>') in IGNORE_DEPS:\n            continue\n        if pkg.endswith('<') or pkg.endswith('>') or eq != '=':\n            error('package should be pinned with exact version: ' + row)\n            continue\n        try:\n            version_tup = tuple((int(x) for x in version.split('.')))\n        except ValueError:\n            raise ValueError('non-numerical version: ' + row)\n        if len(version_tup) == 2:\n            yield (pkg, *version_tup, None)\n        elif len(version_tup) == 3:\n            yield (pkg, *version_tup)\n        else:\n            raise ValueError('expected major.minor or major.minor.patch: ' + row)",
            "def parse_requirements(fname) -> Iterator[tuple[str, int, int, int | None]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Load requirements/min-all-deps.yml\\n\\n    Yield (package name, major version, minor version, [patch version])\\n    '\n    global errors\n    with open(fname) as fh:\n        contents = yaml.safe_load(fh)\n    for row in contents['dependencies']:\n        if isinstance(row, dict) and list(row) == ['pip']:\n            continue\n        (pkg, eq, version) = row.partition('=')\n        if pkg.rstrip('<>') in IGNORE_DEPS:\n            continue\n        if pkg.endswith('<') or pkg.endswith('>') or eq != '=':\n            error('package should be pinned with exact version: ' + row)\n            continue\n        try:\n            version_tup = tuple((int(x) for x in version.split('.')))\n        except ValueError:\n            raise ValueError('non-numerical version: ' + row)\n        if len(version_tup) == 2:\n            yield (pkg, *version_tup, None)\n        elif len(version_tup) == 3:\n            yield (pkg, *version_tup)\n        else:\n            raise ValueError('expected major.minor or major.minor.patch: ' + row)",
            "def parse_requirements(fname) -> Iterator[tuple[str, int, int, int | None]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Load requirements/min-all-deps.yml\\n\\n    Yield (package name, major version, minor version, [patch version])\\n    '\n    global errors\n    with open(fname) as fh:\n        contents = yaml.safe_load(fh)\n    for row in contents['dependencies']:\n        if isinstance(row, dict) and list(row) == ['pip']:\n            continue\n        (pkg, eq, version) = row.partition('=')\n        if pkg.rstrip('<>') in IGNORE_DEPS:\n            continue\n        if pkg.endswith('<') or pkg.endswith('>') or eq != '=':\n            error('package should be pinned with exact version: ' + row)\n            continue\n        try:\n            version_tup = tuple((int(x) for x in version.split('.')))\n        except ValueError:\n            raise ValueError('non-numerical version: ' + row)\n        if len(version_tup) == 2:\n            yield (pkg, *version_tup, None)\n        elif len(version_tup) == 3:\n            yield (pkg, *version_tup)\n        else:\n            raise ValueError('expected major.minor or major.minor.patch: ' + row)",
            "def parse_requirements(fname) -> Iterator[tuple[str, int, int, int | None]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Load requirements/min-all-deps.yml\\n\\n    Yield (package name, major version, minor version, [patch version])\\n    '\n    global errors\n    with open(fname) as fh:\n        contents = yaml.safe_load(fh)\n    for row in contents['dependencies']:\n        if isinstance(row, dict) and list(row) == ['pip']:\n            continue\n        (pkg, eq, version) = row.partition('=')\n        if pkg.rstrip('<>') in IGNORE_DEPS:\n            continue\n        if pkg.endswith('<') or pkg.endswith('>') or eq != '=':\n            error('package should be pinned with exact version: ' + row)\n            continue\n        try:\n            version_tup = tuple((int(x) for x in version.split('.')))\n        except ValueError:\n            raise ValueError('non-numerical version: ' + row)\n        if len(version_tup) == 2:\n            yield (pkg, *version_tup, None)\n        elif len(version_tup) == 3:\n            yield (pkg, *version_tup)\n        else:\n            raise ValueError('expected major.minor or major.minor.patch: ' + row)"
        ]
    },
    {
        "func_name": "metadata",
        "original": "def metadata(entry):\n    version = entry.version\n    time = datetime.fromtimestamp(entry.timestamp)\n    (major, minor) = map(int, version.split('.')[:2])\n    return ((major, minor), time)",
        "mutated": [
            "def metadata(entry):\n    if False:\n        i = 10\n    version = entry.version\n    time = datetime.fromtimestamp(entry.timestamp)\n    (major, minor) = map(int, version.split('.')[:2])\n    return ((major, minor), time)",
            "def metadata(entry):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    version = entry.version\n    time = datetime.fromtimestamp(entry.timestamp)\n    (major, minor) = map(int, version.split('.')[:2])\n    return ((major, minor), time)",
            "def metadata(entry):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    version = entry.version\n    time = datetime.fromtimestamp(entry.timestamp)\n    (major, minor) = map(int, version.split('.')[:2])\n    return ((major, minor), time)",
            "def metadata(entry):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    version = entry.version\n    time = datetime.fromtimestamp(entry.timestamp)\n    (major, minor) = map(int, version.split('.')[:2])\n    return ((major, minor), time)",
            "def metadata(entry):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    version = entry.version\n    time = datetime.fromtimestamp(entry.timestamp)\n    (major, minor) = map(int, version.split('.')[:2])\n    return ((major, minor), time)"
        ]
    },
    {
        "func_name": "query_conda",
        "original": "def query_conda(pkg: str) -> dict[tuple[int, int], datetime]:\n    \"\"\"Query the conda repository for a specific package\n\n    Return map of {(major version, minor version): publication date}\n    \"\"\"\n\n    def metadata(entry):\n        version = entry.version\n        time = datetime.fromtimestamp(entry.timestamp)\n        (major, minor) = map(int, version.split('.')[:2])\n        return ((major, minor), time)\n    raw_data = conda.api.SubdirData.query_all(pkg, channels=CHANNELS)\n    data = sorted((metadata(entry) for entry in raw_data if entry.timestamp != 0))\n    release_dates = {version: [time for (_, time) in group if time is not None] for (version, group) in itertools.groupby(data, key=lambda x: x[0])}\n    out = {version: min(dates) for (version, dates) in release_dates.items() if dates}\n    if pkg == 'python':\n        out.update({(2, 7): datetime(2010, 6, 3), (3, 5): datetime(2015, 9, 13), (3, 6): datetime(2016, 12, 23), (3, 7): datetime(2018, 6, 27), (3, 8): datetime(2019, 10, 14), (3, 9): datetime(2020, 10, 5), (3, 10): datetime(2021, 10, 4), (3, 11): datetime(2022, 10, 24)})\n    return out",
        "mutated": [
            "def query_conda(pkg: str) -> dict[tuple[int, int], datetime]:\n    if False:\n        i = 10\n    'Query the conda repository for a specific package\\n\\n    Return map of {(major version, minor version): publication date}\\n    '\n\n    def metadata(entry):\n        version = entry.version\n        time = datetime.fromtimestamp(entry.timestamp)\n        (major, minor) = map(int, version.split('.')[:2])\n        return ((major, minor), time)\n    raw_data = conda.api.SubdirData.query_all(pkg, channels=CHANNELS)\n    data = sorted((metadata(entry) for entry in raw_data if entry.timestamp != 0))\n    release_dates = {version: [time for (_, time) in group if time is not None] for (version, group) in itertools.groupby(data, key=lambda x: x[0])}\n    out = {version: min(dates) for (version, dates) in release_dates.items() if dates}\n    if pkg == 'python':\n        out.update({(2, 7): datetime(2010, 6, 3), (3, 5): datetime(2015, 9, 13), (3, 6): datetime(2016, 12, 23), (3, 7): datetime(2018, 6, 27), (3, 8): datetime(2019, 10, 14), (3, 9): datetime(2020, 10, 5), (3, 10): datetime(2021, 10, 4), (3, 11): datetime(2022, 10, 24)})\n    return out",
            "def query_conda(pkg: str) -> dict[tuple[int, int], datetime]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Query the conda repository for a specific package\\n\\n    Return map of {(major version, minor version): publication date}\\n    '\n\n    def metadata(entry):\n        version = entry.version\n        time = datetime.fromtimestamp(entry.timestamp)\n        (major, minor) = map(int, version.split('.')[:2])\n        return ((major, minor), time)\n    raw_data = conda.api.SubdirData.query_all(pkg, channels=CHANNELS)\n    data = sorted((metadata(entry) for entry in raw_data if entry.timestamp != 0))\n    release_dates = {version: [time for (_, time) in group if time is not None] for (version, group) in itertools.groupby(data, key=lambda x: x[0])}\n    out = {version: min(dates) for (version, dates) in release_dates.items() if dates}\n    if pkg == 'python':\n        out.update({(2, 7): datetime(2010, 6, 3), (3, 5): datetime(2015, 9, 13), (3, 6): datetime(2016, 12, 23), (3, 7): datetime(2018, 6, 27), (3, 8): datetime(2019, 10, 14), (3, 9): datetime(2020, 10, 5), (3, 10): datetime(2021, 10, 4), (3, 11): datetime(2022, 10, 24)})\n    return out",
            "def query_conda(pkg: str) -> dict[tuple[int, int], datetime]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Query the conda repository for a specific package\\n\\n    Return map of {(major version, minor version): publication date}\\n    '\n\n    def metadata(entry):\n        version = entry.version\n        time = datetime.fromtimestamp(entry.timestamp)\n        (major, minor) = map(int, version.split('.')[:2])\n        return ((major, minor), time)\n    raw_data = conda.api.SubdirData.query_all(pkg, channels=CHANNELS)\n    data = sorted((metadata(entry) for entry in raw_data if entry.timestamp != 0))\n    release_dates = {version: [time for (_, time) in group if time is not None] for (version, group) in itertools.groupby(data, key=lambda x: x[0])}\n    out = {version: min(dates) for (version, dates) in release_dates.items() if dates}\n    if pkg == 'python':\n        out.update({(2, 7): datetime(2010, 6, 3), (3, 5): datetime(2015, 9, 13), (3, 6): datetime(2016, 12, 23), (3, 7): datetime(2018, 6, 27), (3, 8): datetime(2019, 10, 14), (3, 9): datetime(2020, 10, 5), (3, 10): datetime(2021, 10, 4), (3, 11): datetime(2022, 10, 24)})\n    return out",
            "def query_conda(pkg: str) -> dict[tuple[int, int], datetime]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Query the conda repository for a specific package\\n\\n    Return map of {(major version, minor version): publication date}\\n    '\n\n    def metadata(entry):\n        version = entry.version\n        time = datetime.fromtimestamp(entry.timestamp)\n        (major, minor) = map(int, version.split('.')[:2])\n        return ((major, minor), time)\n    raw_data = conda.api.SubdirData.query_all(pkg, channels=CHANNELS)\n    data = sorted((metadata(entry) for entry in raw_data if entry.timestamp != 0))\n    release_dates = {version: [time for (_, time) in group if time is not None] for (version, group) in itertools.groupby(data, key=lambda x: x[0])}\n    out = {version: min(dates) for (version, dates) in release_dates.items() if dates}\n    if pkg == 'python':\n        out.update({(2, 7): datetime(2010, 6, 3), (3, 5): datetime(2015, 9, 13), (3, 6): datetime(2016, 12, 23), (3, 7): datetime(2018, 6, 27), (3, 8): datetime(2019, 10, 14), (3, 9): datetime(2020, 10, 5), (3, 10): datetime(2021, 10, 4), (3, 11): datetime(2022, 10, 24)})\n    return out",
            "def query_conda(pkg: str) -> dict[tuple[int, int], datetime]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Query the conda repository for a specific package\\n\\n    Return map of {(major version, minor version): publication date}\\n    '\n\n    def metadata(entry):\n        version = entry.version\n        time = datetime.fromtimestamp(entry.timestamp)\n        (major, minor) = map(int, version.split('.')[:2])\n        return ((major, minor), time)\n    raw_data = conda.api.SubdirData.query_all(pkg, channels=CHANNELS)\n    data = sorted((metadata(entry) for entry in raw_data if entry.timestamp != 0))\n    release_dates = {version: [time for (_, time) in group if time is not None] for (version, group) in itertools.groupby(data, key=lambda x: x[0])}\n    out = {version: min(dates) for (version, dates) in release_dates.items() if dates}\n    if pkg == 'python':\n        out.update({(2, 7): datetime(2010, 6, 3), (3, 5): datetime(2015, 9, 13), (3, 6): datetime(2016, 12, 23), (3, 7): datetime(2018, 6, 27), (3, 8): datetime(2019, 10, 14), (3, 9): datetime(2020, 10, 5), (3, 10): datetime(2021, 10, 4), (3, 11): datetime(2022, 10, 24)})\n    return out"
        ]
    },
    {
        "func_name": "process_pkg",
        "original": "def process_pkg(pkg: str, req_major: int, req_minor: int, req_patch: int | None) -> tuple[str, str, str, str, str, str]:\n    \"\"\"Compare package version from requirements file to available versions in conda.\n    Return row to build pandas dataframe:\n\n    - package name\n    - major.minor.[patch] version in requirements file\n    - publication date of version in requirements file (YYYY-MM-DD)\n    - major.minor version suggested by policy\n    - publication date of version suggested by policy (YYYY-MM-DD)\n    - status (\"<\", \"=\", \"> (!)\")\n    \"\"\"\n    print('Analyzing %s...' % pkg)\n    versions = query_conda(pkg)\n    try:\n        req_published = versions[req_major, req_minor]\n    except KeyError:\n        error('not found in conda: ' + pkg)\n        return (pkg, fmt_version(req_major, req_minor, req_patch), '-', '-', '-', '(!)')\n    policy_months = POLICY_MONTHS.get(pkg, POLICY_MONTHS_DEFAULT)\n    policy_published = datetime.now() - relativedelta(months=policy_months)\n    filtered_versions = [version for (version, published) in versions.items() if published < policy_published]\n    (policy_major, policy_minor) = max(filtered_versions, default=(req_major, req_minor))\n    try:\n        (policy_major, policy_minor) = POLICY_OVERRIDE[pkg]\n    except KeyError:\n        pass\n    policy_published_actual = versions[policy_major, policy_minor]\n    if (req_major, req_minor) < (policy_major, policy_minor):\n        status = '<'\n    elif (req_major, req_minor) > (policy_major, policy_minor):\n        status = '> (!)'\n        delta = relativedelta(datetime.now(), policy_published_actual).normalized()\n        n_months = delta.years * 12 + delta.months\n        warning(f'Package is too new: {pkg}={policy_major}.{policy_minor} was published on {versions[policy_major, policy_minor]:%Y-%m-%d} which was {n_months} months ago (policy is {policy_months} months)')\n    else:\n        status = '='\n    if req_patch is not None:\n        warning('patch version should not appear in requirements file: ' + pkg)\n        status += ' (w)'\n    return (pkg, fmt_version(req_major, req_minor, req_patch), req_published.strftime('%Y-%m-%d'), fmt_version(policy_major, policy_minor), policy_published_actual.strftime('%Y-%m-%d'), status)",
        "mutated": [
            "def process_pkg(pkg: str, req_major: int, req_minor: int, req_patch: int | None) -> tuple[str, str, str, str, str, str]:\n    if False:\n        i = 10\n    'Compare package version from requirements file to available versions in conda.\\n    Return row to build pandas dataframe:\\n\\n    - package name\\n    - major.minor.[patch] version in requirements file\\n    - publication date of version in requirements file (YYYY-MM-DD)\\n    - major.minor version suggested by policy\\n    - publication date of version suggested by policy (YYYY-MM-DD)\\n    - status (\"<\", \"=\", \"> (!)\")\\n    '\n    print('Analyzing %s...' % pkg)\n    versions = query_conda(pkg)\n    try:\n        req_published = versions[req_major, req_minor]\n    except KeyError:\n        error('not found in conda: ' + pkg)\n        return (pkg, fmt_version(req_major, req_minor, req_patch), '-', '-', '-', '(!)')\n    policy_months = POLICY_MONTHS.get(pkg, POLICY_MONTHS_DEFAULT)\n    policy_published = datetime.now() - relativedelta(months=policy_months)\n    filtered_versions = [version for (version, published) in versions.items() if published < policy_published]\n    (policy_major, policy_minor) = max(filtered_versions, default=(req_major, req_minor))\n    try:\n        (policy_major, policy_minor) = POLICY_OVERRIDE[pkg]\n    except KeyError:\n        pass\n    policy_published_actual = versions[policy_major, policy_minor]\n    if (req_major, req_minor) < (policy_major, policy_minor):\n        status = '<'\n    elif (req_major, req_minor) > (policy_major, policy_minor):\n        status = '> (!)'\n        delta = relativedelta(datetime.now(), policy_published_actual).normalized()\n        n_months = delta.years * 12 + delta.months\n        warning(f'Package is too new: {pkg}={policy_major}.{policy_minor} was published on {versions[policy_major, policy_minor]:%Y-%m-%d} which was {n_months} months ago (policy is {policy_months} months)')\n    else:\n        status = '='\n    if req_patch is not None:\n        warning('patch version should not appear in requirements file: ' + pkg)\n        status += ' (w)'\n    return (pkg, fmt_version(req_major, req_minor, req_patch), req_published.strftime('%Y-%m-%d'), fmt_version(policy_major, policy_minor), policy_published_actual.strftime('%Y-%m-%d'), status)",
            "def process_pkg(pkg: str, req_major: int, req_minor: int, req_patch: int | None) -> tuple[str, str, str, str, str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compare package version from requirements file to available versions in conda.\\n    Return row to build pandas dataframe:\\n\\n    - package name\\n    - major.minor.[patch] version in requirements file\\n    - publication date of version in requirements file (YYYY-MM-DD)\\n    - major.minor version suggested by policy\\n    - publication date of version suggested by policy (YYYY-MM-DD)\\n    - status (\"<\", \"=\", \"> (!)\")\\n    '\n    print('Analyzing %s...' % pkg)\n    versions = query_conda(pkg)\n    try:\n        req_published = versions[req_major, req_minor]\n    except KeyError:\n        error('not found in conda: ' + pkg)\n        return (pkg, fmt_version(req_major, req_minor, req_patch), '-', '-', '-', '(!)')\n    policy_months = POLICY_MONTHS.get(pkg, POLICY_MONTHS_DEFAULT)\n    policy_published = datetime.now() - relativedelta(months=policy_months)\n    filtered_versions = [version for (version, published) in versions.items() if published < policy_published]\n    (policy_major, policy_minor) = max(filtered_versions, default=(req_major, req_minor))\n    try:\n        (policy_major, policy_minor) = POLICY_OVERRIDE[pkg]\n    except KeyError:\n        pass\n    policy_published_actual = versions[policy_major, policy_minor]\n    if (req_major, req_minor) < (policy_major, policy_minor):\n        status = '<'\n    elif (req_major, req_minor) > (policy_major, policy_minor):\n        status = '> (!)'\n        delta = relativedelta(datetime.now(), policy_published_actual).normalized()\n        n_months = delta.years * 12 + delta.months\n        warning(f'Package is too new: {pkg}={policy_major}.{policy_minor} was published on {versions[policy_major, policy_minor]:%Y-%m-%d} which was {n_months} months ago (policy is {policy_months} months)')\n    else:\n        status = '='\n    if req_patch is not None:\n        warning('patch version should not appear in requirements file: ' + pkg)\n        status += ' (w)'\n    return (pkg, fmt_version(req_major, req_minor, req_patch), req_published.strftime('%Y-%m-%d'), fmt_version(policy_major, policy_minor), policy_published_actual.strftime('%Y-%m-%d'), status)",
            "def process_pkg(pkg: str, req_major: int, req_minor: int, req_patch: int | None) -> tuple[str, str, str, str, str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compare package version from requirements file to available versions in conda.\\n    Return row to build pandas dataframe:\\n\\n    - package name\\n    - major.minor.[patch] version in requirements file\\n    - publication date of version in requirements file (YYYY-MM-DD)\\n    - major.minor version suggested by policy\\n    - publication date of version suggested by policy (YYYY-MM-DD)\\n    - status (\"<\", \"=\", \"> (!)\")\\n    '\n    print('Analyzing %s...' % pkg)\n    versions = query_conda(pkg)\n    try:\n        req_published = versions[req_major, req_minor]\n    except KeyError:\n        error('not found in conda: ' + pkg)\n        return (pkg, fmt_version(req_major, req_minor, req_patch), '-', '-', '-', '(!)')\n    policy_months = POLICY_MONTHS.get(pkg, POLICY_MONTHS_DEFAULT)\n    policy_published = datetime.now() - relativedelta(months=policy_months)\n    filtered_versions = [version for (version, published) in versions.items() if published < policy_published]\n    (policy_major, policy_minor) = max(filtered_versions, default=(req_major, req_minor))\n    try:\n        (policy_major, policy_minor) = POLICY_OVERRIDE[pkg]\n    except KeyError:\n        pass\n    policy_published_actual = versions[policy_major, policy_minor]\n    if (req_major, req_minor) < (policy_major, policy_minor):\n        status = '<'\n    elif (req_major, req_minor) > (policy_major, policy_minor):\n        status = '> (!)'\n        delta = relativedelta(datetime.now(), policy_published_actual).normalized()\n        n_months = delta.years * 12 + delta.months\n        warning(f'Package is too new: {pkg}={policy_major}.{policy_minor} was published on {versions[policy_major, policy_minor]:%Y-%m-%d} which was {n_months} months ago (policy is {policy_months} months)')\n    else:\n        status = '='\n    if req_patch is not None:\n        warning('patch version should not appear in requirements file: ' + pkg)\n        status += ' (w)'\n    return (pkg, fmt_version(req_major, req_minor, req_patch), req_published.strftime('%Y-%m-%d'), fmt_version(policy_major, policy_minor), policy_published_actual.strftime('%Y-%m-%d'), status)",
            "def process_pkg(pkg: str, req_major: int, req_minor: int, req_patch: int | None) -> tuple[str, str, str, str, str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compare package version from requirements file to available versions in conda.\\n    Return row to build pandas dataframe:\\n\\n    - package name\\n    - major.minor.[patch] version in requirements file\\n    - publication date of version in requirements file (YYYY-MM-DD)\\n    - major.minor version suggested by policy\\n    - publication date of version suggested by policy (YYYY-MM-DD)\\n    - status (\"<\", \"=\", \"> (!)\")\\n    '\n    print('Analyzing %s...' % pkg)\n    versions = query_conda(pkg)\n    try:\n        req_published = versions[req_major, req_minor]\n    except KeyError:\n        error('not found in conda: ' + pkg)\n        return (pkg, fmt_version(req_major, req_minor, req_patch), '-', '-', '-', '(!)')\n    policy_months = POLICY_MONTHS.get(pkg, POLICY_MONTHS_DEFAULT)\n    policy_published = datetime.now() - relativedelta(months=policy_months)\n    filtered_versions = [version for (version, published) in versions.items() if published < policy_published]\n    (policy_major, policy_minor) = max(filtered_versions, default=(req_major, req_minor))\n    try:\n        (policy_major, policy_minor) = POLICY_OVERRIDE[pkg]\n    except KeyError:\n        pass\n    policy_published_actual = versions[policy_major, policy_minor]\n    if (req_major, req_minor) < (policy_major, policy_minor):\n        status = '<'\n    elif (req_major, req_minor) > (policy_major, policy_minor):\n        status = '> (!)'\n        delta = relativedelta(datetime.now(), policy_published_actual).normalized()\n        n_months = delta.years * 12 + delta.months\n        warning(f'Package is too new: {pkg}={policy_major}.{policy_minor} was published on {versions[policy_major, policy_minor]:%Y-%m-%d} which was {n_months} months ago (policy is {policy_months} months)')\n    else:\n        status = '='\n    if req_patch is not None:\n        warning('patch version should not appear in requirements file: ' + pkg)\n        status += ' (w)'\n    return (pkg, fmt_version(req_major, req_minor, req_patch), req_published.strftime('%Y-%m-%d'), fmt_version(policy_major, policy_minor), policy_published_actual.strftime('%Y-%m-%d'), status)",
            "def process_pkg(pkg: str, req_major: int, req_minor: int, req_patch: int | None) -> tuple[str, str, str, str, str, str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compare package version from requirements file to available versions in conda.\\n    Return row to build pandas dataframe:\\n\\n    - package name\\n    - major.minor.[patch] version in requirements file\\n    - publication date of version in requirements file (YYYY-MM-DD)\\n    - major.minor version suggested by policy\\n    - publication date of version suggested by policy (YYYY-MM-DD)\\n    - status (\"<\", \"=\", \"> (!)\")\\n    '\n    print('Analyzing %s...' % pkg)\n    versions = query_conda(pkg)\n    try:\n        req_published = versions[req_major, req_minor]\n    except KeyError:\n        error('not found in conda: ' + pkg)\n        return (pkg, fmt_version(req_major, req_minor, req_patch), '-', '-', '-', '(!)')\n    policy_months = POLICY_MONTHS.get(pkg, POLICY_MONTHS_DEFAULT)\n    policy_published = datetime.now() - relativedelta(months=policy_months)\n    filtered_versions = [version for (version, published) in versions.items() if published < policy_published]\n    (policy_major, policy_minor) = max(filtered_versions, default=(req_major, req_minor))\n    try:\n        (policy_major, policy_minor) = POLICY_OVERRIDE[pkg]\n    except KeyError:\n        pass\n    policy_published_actual = versions[policy_major, policy_minor]\n    if (req_major, req_minor) < (policy_major, policy_minor):\n        status = '<'\n    elif (req_major, req_minor) > (policy_major, policy_minor):\n        status = '> (!)'\n        delta = relativedelta(datetime.now(), policy_published_actual).normalized()\n        n_months = delta.years * 12 + delta.months\n        warning(f'Package is too new: {pkg}={policy_major}.{policy_minor} was published on {versions[policy_major, policy_minor]:%Y-%m-%d} which was {n_months} months ago (policy is {policy_months} months)')\n    else:\n        status = '='\n    if req_patch is not None:\n        warning('patch version should not appear in requirements file: ' + pkg)\n        status += ' (w)'\n    return (pkg, fmt_version(req_major, req_minor, req_patch), req_published.strftime('%Y-%m-%d'), fmt_version(policy_major, policy_minor), policy_published_actual.strftime('%Y-%m-%d'), status)"
        ]
    },
    {
        "func_name": "fmt_version",
        "original": "def fmt_version(major: int, minor: int, patch: int=None) -> str:\n    if patch is None:\n        return f'{major}.{minor}'\n    else:\n        return f'{major}.{minor}.{patch}'",
        "mutated": [
            "def fmt_version(major: int, minor: int, patch: int=None) -> str:\n    if False:\n        i = 10\n    if patch is None:\n        return f'{major}.{minor}'\n    else:\n        return f'{major}.{minor}.{patch}'",
            "def fmt_version(major: int, minor: int, patch: int=None) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if patch is None:\n        return f'{major}.{minor}'\n    else:\n        return f'{major}.{minor}.{patch}'",
            "def fmt_version(major: int, minor: int, patch: int=None) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if patch is None:\n        return f'{major}.{minor}'\n    else:\n        return f'{major}.{minor}.{patch}'",
            "def fmt_version(major: int, minor: int, patch: int=None) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if patch is None:\n        return f'{major}.{minor}'\n    else:\n        return f'{major}.{minor}.{patch}'",
            "def fmt_version(major: int, minor: int, patch: int=None) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if patch is None:\n        return f'{major}.{minor}'\n    else:\n        return f'{major}.{minor}.{patch}'"
        ]
    },
    {
        "func_name": "main",
        "original": "def main() -> None:\n    fname = sys.argv[1]\n    rows = [process_pkg(pkg, major, minor, patch) for (pkg, major, minor, patch) in parse_requirements(fname)]\n    print('\\nPackage           Required             Policy               Status')\n    print('----------------- -------------------- -------------------- ------')\n    fmt = '{:17} {:7} ({:10}) {:7} ({:10}) {}'\n    for row in rows:\n        print(fmt.format(*row))\n    if errors:\n        print('\\nErrors:')\n        print('-------')\n        for (i, e) in enumerate(errors):\n            print(f'{i + 1}. {e}')\n        sys.exit(1)",
        "mutated": [
            "def main() -> None:\n    if False:\n        i = 10\n    fname = sys.argv[1]\n    rows = [process_pkg(pkg, major, minor, patch) for (pkg, major, minor, patch) in parse_requirements(fname)]\n    print('\\nPackage           Required             Policy               Status')\n    print('----------------- -------------------- -------------------- ------')\n    fmt = '{:17} {:7} ({:10}) {:7} ({:10}) {}'\n    for row in rows:\n        print(fmt.format(*row))\n    if errors:\n        print('\\nErrors:')\n        print('-------')\n        for (i, e) in enumerate(errors):\n            print(f'{i + 1}. {e}')\n        sys.exit(1)",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    fname = sys.argv[1]\n    rows = [process_pkg(pkg, major, minor, patch) for (pkg, major, minor, patch) in parse_requirements(fname)]\n    print('\\nPackage           Required             Policy               Status')\n    print('----------------- -------------------- -------------------- ------')\n    fmt = '{:17} {:7} ({:10}) {:7} ({:10}) {}'\n    for row in rows:\n        print(fmt.format(*row))\n    if errors:\n        print('\\nErrors:')\n        print('-------')\n        for (i, e) in enumerate(errors):\n            print(f'{i + 1}. {e}')\n        sys.exit(1)",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    fname = sys.argv[1]\n    rows = [process_pkg(pkg, major, minor, patch) for (pkg, major, minor, patch) in parse_requirements(fname)]\n    print('\\nPackage           Required             Policy               Status')\n    print('----------------- -------------------- -------------------- ------')\n    fmt = '{:17} {:7} ({:10}) {:7} ({:10}) {}'\n    for row in rows:\n        print(fmt.format(*row))\n    if errors:\n        print('\\nErrors:')\n        print('-------')\n        for (i, e) in enumerate(errors):\n            print(f'{i + 1}. {e}')\n        sys.exit(1)",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    fname = sys.argv[1]\n    rows = [process_pkg(pkg, major, minor, patch) for (pkg, major, minor, patch) in parse_requirements(fname)]\n    print('\\nPackage           Required             Policy               Status')\n    print('----------------- -------------------- -------------------- ------')\n    fmt = '{:17} {:7} ({:10}) {:7} ({:10}) {}'\n    for row in rows:\n        print(fmt.format(*row))\n    if errors:\n        print('\\nErrors:')\n        print('-------')\n        for (i, e) in enumerate(errors):\n            print(f'{i + 1}. {e}')\n        sys.exit(1)",
            "def main() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    fname = sys.argv[1]\n    rows = [process_pkg(pkg, major, minor, patch) for (pkg, major, minor, patch) in parse_requirements(fname)]\n    print('\\nPackage           Required             Policy               Status')\n    print('----------------- -------------------- -------------------- ------')\n    fmt = '{:17} {:7} ({:10}) {:7} ({:10}) {}'\n    for row in rows:\n        print(fmt.format(*row))\n    if errors:\n        print('\\nErrors:')\n        print('-------')\n        for (i, e) in enumerate(errors):\n            print(f'{i + 1}. {e}')\n        sys.exit(1)"
        ]
    }
]