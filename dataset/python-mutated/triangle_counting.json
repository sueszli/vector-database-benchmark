[
    {
        "func_name": "__init__",
        "original": "def __init__(self, model):\n    \"\"\"__init__(self)\"\"\"\n    self.__proxy__ = model",
        "mutated": [
            "def __init__(self, model):\n    if False:\n        i = 10\n    '__init__(self)'\n    self.__proxy__ = model",
            "def __init__(self, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '__init__(self)'\n    self.__proxy__ = model",
            "def __init__(self, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '__init__(self)'\n    self.__proxy__ = model",
            "def __init__(self, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '__init__(self)'\n    self.__proxy__ = model",
            "def __init__(self, model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '__init__(self)'\n    self.__proxy__ = model"
        ]
    },
    {
        "func_name": "_result_fields",
        "original": "def _result_fields(self):\n    ret = super(TriangleCountingModel, self)._result_fields()\n    ret['total number of triangles'] = self.num_triangles\n    ret['vertex triangle count'] = 'SFrame. See m.triangle_count'\n    return ret",
        "mutated": [
            "def _result_fields(self):\n    if False:\n        i = 10\n    ret = super(TriangleCountingModel, self)._result_fields()\n    ret['total number of triangles'] = self.num_triangles\n    ret['vertex triangle count'] = 'SFrame. See m.triangle_count'\n    return ret",
            "def _result_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ret = super(TriangleCountingModel, self)._result_fields()\n    ret['total number of triangles'] = self.num_triangles\n    ret['vertex triangle count'] = 'SFrame. See m.triangle_count'\n    return ret",
            "def _result_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ret = super(TriangleCountingModel, self)._result_fields()\n    ret['total number of triangles'] = self.num_triangles\n    ret['vertex triangle count'] = 'SFrame. See m.triangle_count'\n    return ret",
            "def _result_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ret = super(TriangleCountingModel, self)._result_fields()\n    ret['total number of triangles'] = self.num_triangles\n    ret['vertex triangle count'] = 'SFrame. See m.triangle_count'\n    return ret",
            "def _result_fields(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ret = super(TriangleCountingModel, self)._result_fields()\n    ret['total number of triangles'] = self.num_triangles\n    ret['vertex triangle count'] = 'SFrame. See m.triangle_count'\n    return ret"
        ]
    },
    {
        "func_name": "_get_version",
        "original": "def _get_version(self):\n    return 0",
        "mutated": [
            "def _get_version(self):\n    if False:\n        i = 10\n    return 0",
            "def _get_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 0",
            "def _get_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 0",
            "def _get_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 0",
            "def _get_version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 0"
        ]
    },
    {
        "func_name": "_native_name",
        "original": "@classmethod\ndef _native_name(cls):\n    return 'triangle_count'",
        "mutated": [
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n    return 'triangle_count'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'triangle_count'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'triangle_count'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'triangle_count'",
            "@classmethod\ndef _native_name(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'triangle_count'"
        ]
    },
    {
        "func_name": "_get_native_state",
        "original": "def _get_native_state(self):\n    return {'model': self.__proxy__}",
        "mutated": [
            "def _get_native_state(self):\n    if False:\n        i = 10\n    return {'model': self.__proxy__}",
            "def _get_native_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return {'model': self.__proxy__}",
            "def _get_native_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return {'model': self.__proxy__}",
            "def _get_native_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return {'model': self.__proxy__}",
            "def _get_native_state(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return {'model': self.__proxy__}"
        ]
    },
    {
        "func_name": "_load_version",
        "original": "@classmethod\ndef _load_version(cls, state, version):\n    assert version == 0\n    return cls(state['model'])",
        "mutated": [
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n    assert version == 0\n    return cls(state['model'])",
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert version == 0\n    return cls(state['model'])",
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert version == 0\n    return cls(state['model'])",
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert version == 0\n    return cls(state['model'])",
            "@classmethod\ndef _load_version(cls, state, version):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert version == 0\n    return cls(state['model'])"
        ]
    },
    {
        "func_name": "create",
        "original": "def create(graph, verbose=True):\n    \"\"\"\n    Compute the number of triangles each vertex belongs to, ignoring edge\n    directions. A triangle is a complete subgraph with only three vertices.\n    Return a model object with total number of triangles as well as the triangle\n    counts for each vertex in the graph.\n\n    Parameters\n    ----------\n    graph : SGraph\n        The graph on which to compute triangle counts.\n\n    verbose : bool, optional\n        If True, print progress updates.\n\n    Returns\n    -------\n    out : TriangleCountingModel\n\n    References\n    ----------\n    - T. Schank. (2007) `Algorithmic Aspects of Triangle-Based Network Analysis\n      <http://digbib.ubka.uni-karlsruhe.de/volltexte/documents/4541>`_.\n\n    Examples\n    --------\n    If given an :class:`~turicreate.SGraph` ``g``, we can create a\n    :class:`~turicreate.triangle_counting.TriangleCountingModel` as follows:\n\n    >>> g =\n    >>> turicreate.load_sgraph('http://snap.stanford.edu/data/email-Enron.txt.gz',\n            >>> format='snap') tc = turicreate.triangle_counting.create(g)\n\n    We can obtain the number of triangles that each vertex in the graph ``g``\n    is present in:\n\n    >>> tc_out = tc['triangle_count']  # SFrame\n\n    We can add the new \"triangle_count\" field to the original graph g using:\n\n    >>> g.vertices['triangle_count'] = tc['graph'].vertices['triangle_count']\n\n    Note that the task above does not require a join because the vertex\n    ordering is preserved through ``create()``.\n\n    See Also\n    --------\n    TriangleCountingModel\n    \"\"\"\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.triangle_counting.create({'graph': graph.__proxy__})\n    return TriangleCountingModel(params['model'])",
        "mutated": [
            "def create(graph, verbose=True):\n    if False:\n        i = 10\n    '\\n    Compute the number of triangles each vertex belongs to, ignoring edge\\n    directions. A triangle is a complete subgraph with only three vertices.\\n    Return a model object with total number of triangles as well as the triangle\\n    counts for each vertex in the graph.\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute triangle counts.\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : TriangleCountingModel\\n\\n    References\\n    ----------\\n    - T. Schank. (2007) `Algorithmic Aspects of Triangle-Based Network Analysis\\n      <http://digbib.ubka.uni-karlsruhe.de/volltexte/documents/4541>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create a\\n    :class:`~turicreate.triangle_counting.TriangleCountingModel` as follows:\\n\\n    >>> g =\\n    >>> turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n            >>> format=\\'snap\\') tc = turicreate.triangle_counting.create(g)\\n\\n    We can obtain the number of triangles that each vertex in the graph ``g``\\n    is present in:\\n\\n    >>> tc_out = tc[\\'triangle_count\\']  # SFrame\\n\\n    We can add the new \"triangle_count\" field to the original graph g using:\\n\\n    >>> g.vertices[\\'triangle_count\\'] = tc[\\'graph\\'].vertices[\\'triangle_count\\']\\n\\n    Note that the task above does not require a join because the vertex\\n    ordering is preserved through ``create()``.\\n\\n    See Also\\n    --------\\n    TriangleCountingModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.triangle_counting.create({'graph': graph.__proxy__})\n    return TriangleCountingModel(params['model'])",
            "def create(graph, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute the number of triangles each vertex belongs to, ignoring edge\\n    directions. A triangle is a complete subgraph with only three vertices.\\n    Return a model object with total number of triangles as well as the triangle\\n    counts for each vertex in the graph.\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute triangle counts.\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : TriangleCountingModel\\n\\n    References\\n    ----------\\n    - T. Schank. (2007) `Algorithmic Aspects of Triangle-Based Network Analysis\\n      <http://digbib.ubka.uni-karlsruhe.de/volltexte/documents/4541>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create a\\n    :class:`~turicreate.triangle_counting.TriangleCountingModel` as follows:\\n\\n    >>> g =\\n    >>> turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n            >>> format=\\'snap\\') tc = turicreate.triangle_counting.create(g)\\n\\n    We can obtain the number of triangles that each vertex in the graph ``g``\\n    is present in:\\n\\n    >>> tc_out = tc[\\'triangle_count\\']  # SFrame\\n\\n    We can add the new \"triangle_count\" field to the original graph g using:\\n\\n    >>> g.vertices[\\'triangle_count\\'] = tc[\\'graph\\'].vertices[\\'triangle_count\\']\\n\\n    Note that the task above does not require a join because the vertex\\n    ordering is preserved through ``create()``.\\n\\n    See Also\\n    --------\\n    TriangleCountingModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.triangle_counting.create({'graph': graph.__proxy__})\n    return TriangleCountingModel(params['model'])",
            "def create(graph, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute the number of triangles each vertex belongs to, ignoring edge\\n    directions. A triangle is a complete subgraph with only three vertices.\\n    Return a model object with total number of triangles as well as the triangle\\n    counts for each vertex in the graph.\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute triangle counts.\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : TriangleCountingModel\\n\\n    References\\n    ----------\\n    - T. Schank. (2007) `Algorithmic Aspects of Triangle-Based Network Analysis\\n      <http://digbib.ubka.uni-karlsruhe.de/volltexte/documents/4541>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create a\\n    :class:`~turicreate.triangle_counting.TriangleCountingModel` as follows:\\n\\n    >>> g =\\n    >>> turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n            >>> format=\\'snap\\') tc = turicreate.triangle_counting.create(g)\\n\\n    We can obtain the number of triangles that each vertex in the graph ``g``\\n    is present in:\\n\\n    >>> tc_out = tc[\\'triangle_count\\']  # SFrame\\n\\n    We can add the new \"triangle_count\" field to the original graph g using:\\n\\n    >>> g.vertices[\\'triangle_count\\'] = tc[\\'graph\\'].vertices[\\'triangle_count\\']\\n\\n    Note that the task above does not require a join because the vertex\\n    ordering is preserved through ``create()``.\\n\\n    See Also\\n    --------\\n    TriangleCountingModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.triangle_counting.create({'graph': graph.__proxy__})\n    return TriangleCountingModel(params['model'])",
            "def create(graph, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute the number of triangles each vertex belongs to, ignoring edge\\n    directions. A triangle is a complete subgraph with only three vertices.\\n    Return a model object with total number of triangles as well as the triangle\\n    counts for each vertex in the graph.\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute triangle counts.\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : TriangleCountingModel\\n\\n    References\\n    ----------\\n    - T. Schank. (2007) `Algorithmic Aspects of Triangle-Based Network Analysis\\n      <http://digbib.ubka.uni-karlsruhe.de/volltexte/documents/4541>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create a\\n    :class:`~turicreate.triangle_counting.TriangleCountingModel` as follows:\\n\\n    >>> g =\\n    >>> turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n            >>> format=\\'snap\\') tc = turicreate.triangle_counting.create(g)\\n\\n    We can obtain the number of triangles that each vertex in the graph ``g``\\n    is present in:\\n\\n    >>> tc_out = tc[\\'triangle_count\\']  # SFrame\\n\\n    We can add the new \"triangle_count\" field to the original graph g using:\\n\\n    >>> g.vertices[\\'triangle_count\\'] = tc[\\'graph\\'].vertices[\\'triangle_count\\']\\n\\n    Note that the task above does not require a join because the vertex\\n    ordering is preserved through ``create()``.\\n\\n    See Also\\n    --------\\n    TriangleCountingModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.triangle_counting.create({'graph': graph.__proxy__})\n    return TriangleCountingModel(params['model'])",
            "def create(graph, verbose=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute the number of triangles each vertex belongs to, ignoring edge\\n    directions. A triangle is a complete subgraph with only three vertices.\\n    Return a model object with total number of triangles as well as the triangle\\n    counts for each vertex in the graph.\\n\\n    Parameters\\n    ----------\\n    graph : SGraph\\n        The graph on which to compute triangle counts.\\n\\n    verbose : bool, optional\\n        If True, print progress updates.\\n\\n    Returns\\n    -------\\n    out : TriangleCountingModel\\n\\n    References\\n    ----------\\n    - T. Schank. (2007) `Algorithmic Aspects of Triangle-Based Network Analysis\\n      <http://digbib.ubka.uni-karlsruhe.de/volltexte/documents/4541>`_.\\n\\n    Examples\\n    --------\\n    If given an :class:`~turicreate.SGraph` ``g``, we can create a\\n    :class:`~turicreate.triangle_counting.TriangleCountingModel` as follows:\\n\\n    >>> g =\\n    >>> turicreate.load_sgraph(\\'http://snap.stanford.edu/data/email-Enron.txt.gz\\',\\n            >>> format=\\'snap\\') tc = turicreate.triangle_counting.create(g)\\n\\n    We can obtain the number of triangles that each vertex in the graph ``g``\\n    is present in:\\n\\n    >>> tc_out = tc[\\'triangle_count\\']  # SFrame\\n\\n    We can add the new \"triangle_count\" field to the original graph g using:\\n\\n    >>> g.vertices[\\'triangle_count\\'] = tc[\\'graph\\'].vertices[\\'triangle_count\\']\\n\\n    Note that the task above does not require a join because the vertex\\n    ordering is preserved through ``create()``.\\n\\n    See Also\\n    --------\\n    TriangleCountingModel\\n    '\n    from turicreate._cython.cy_server import QuietProgress\n    if not isinstance(graph, _SGraph):\n        raise TypeError('graph input must be a SGraph object.')\n    with QuietProgress(verbose):\n        params = _tc.extensions._toolkits.graph.triangle_counting.create({'graph': graph.__proxy__})\n    return TriangleCountingModel(params['model'])"
        ]
    }
]