import datetime
import pathlib
import re
from textwrap import dedent
from textwrap import indent
import packaging.version
import platformdirs
import tabulate
import wcwidth
from requests_cache import CachedResponse
from requests_cache import CachedSession
from requests_cache import OriginalResponse
from requests_cache import SQLiteCache
from tqdm import tqdm
FILE_HEAD = '\n.. Note this file is autogenerated by scripts/update-plugin-list.py - usually weekly via github action\n\n.. _plugin-list:\n\nPytest Plugin List\n==================\n\nBelow is an automated compilation of ``pytest``` plugins available on `PyPI <https://pypi.org>`_.\nIt includes PyPI projects whose names begin with "pytest-" and a handful of manually selected projects.\nPackages classified as inactive are excluded.\n\nFor detailed insights into how this list is generated,\nplease refer to `the update script <https://github.com/pytest-dev/pytest/blob/main/scripts/update-plugin-list.py>`_.\n\n.. warning::\n\n   Please be aware that this list is not a curated collection of projects\n   and does not undergo a systematic review process.\n   It serves purely as an informational resource to aid in the discovery of ``pytest`` plugins.\n\n   Do not presume any endorsement from the ``pytest`` project or its developers,\n   and always conduct your own quality assessment before incorporating any of these plugins into your own projects.\n\n\n.. The following conditional uses a different format for this list when\n   creating a PDF, because otherwise the table gets far too wide for the\n   page.\n\n'
DEVELOPMENT_STATUS_CLASSIFIERS = ('Development Status :: 1 - Planning', 'Development Status :: 2 - Pre-Alpha', 'Development Status :: 3 - Alpha', 'Development Status :: 4 - Beta', 'Development Status :: 5 - Production/Stable', 'Development Status :: 6 - Mature', 'Development Status :: 7 - Inactive')
ADDITIONAL_PROJECTS = {'logassert', 'nuts', 'flask_fixture'}

def escape_rst(text: str) -> str:
    if False:
        i = 10
        return i + 15
    'Rudimentary attempt to escape special RST characters to appear as\n    plain text.'
    text = text.replace('*', '\\*').replace('<', '\\<').replace('>', '\\>').replace('`', '\\`')
    text = re.sub('_\\b', '', text)
    return text

def project_response_with_refresh(session: CachedSession, name: str, last_serial: int) -> OriginalResponse | CachedResponse:
    if False:
        print('Hello World!')
    'Get a http cached pypi project\n\n    force refresh in case of last serial mismatch\n    '
    response = session.get(f'https://pypi.org/pypi/{name}/json')
    if int(response.headers.get('X-PyPI-Last-Serial', -1)) != last_serial:
        response = session.get(f'https://pypi.org/pypi/{name}/json', refresh=True)
    return response

def get_session() -> CachedSession:
    if False:
        for i in range(10):
            print('nop')
    'Configures the requests-cache session'
    cache_path = platformdirs.user_cache_path('pytest-plugin-list')
    cache_path.mkdir(exist_ok=True, parents=True)
    cache_file = cache_path.joinpath('http_cache.sqlite3')
    return CachedSession(backend=SQLiteCache(cache_file))

def pytest_plugin_projects_from_pypi(session: CachedSession) -> dict[str, int]:
    if False:
        i = 10
        return i + 15
    response = session.get('https://pypi.org/simple', headers={'Accept': 'application/vnd.pypi.simple.v1+json'}, refresh=True)
    return {name: p['_last-serial'] for p in response.json()['projects'] if (name := p['name']).startswith('pytest-') or name in ADDITIONAL_PROJECTS}

def iter_plugins():
    if False:
        for i in range(10):
            print('nop')
    session = get_session()
    name_2_serial = pytest_plugin_projects_from_pypi(session)
    for (name, last_serial) in tqdm(name_2_serial.items(), smoothing=0):
        response = project_response_with_refresh(session, name, last_serial)
        if response.status_code == 404:
            continue
        response.raise_for_status()
        info = response.json()['info']
        if 'Development Status :: 7 - Inactive' in info['classifiers']:
            continue
        for classifier in DEVELOPMENT_STATUS_CLASSIFIERS:
            if classifier in info['classifiers']:
                status = classifier[22:]
                break
        else:
            status = 'N/A'
        requires = 'N/A'
        if info['requires_dist']:
            for requirement in info['requires_dist']:
                if re.match('pytest(?![-.\\w])', requirement):
                    requires = requirement
                    break

        def version_sort_key(version_string):
            if False:
                while True:
                    i = 10
            '\n            Return the sort key for the given version string\n            returned by the API.\n            '
            try:
                return packaging.version.parse(version_string)
            except packaging.version.InvalidVersion:
                return packaging.version.Version('0.0.0alpha')
        releases = response.json()['releases']
        for release in sorted(releases, key=version_sort_key, reverse=True):
            if releases[release]:
                release_date = datetime.date.fromisoformat(releases[release][-1]['upload_time_iso_8601'].split('T')[0])
                last_release = release_date.strftime('%b %d, %Y')
                break
        name = f":pypi:`{info['name']}`"
        summary = ''
        if info['summary']:
            summary = escape_rst(info['summary'].replace('\n', ''))
        yield {'name': name, 'summary': summary.strip(), 'last release': last_release, 'status': status, 'requires': requires}

def plugin_definitions(plugins):
    if False:
        print('Hello World!')
    'Return RST for the plugin list that fits better on a vertical page.'
    for plugin in plugins:
        yield dedent(f"\n            {plugin['name']}\n               *last release*: {plugin['last release']},\n               *status*: {plugin['status']},\n               *requires*: {plugin['requires']}\n\n               {plugin['summary']}\n            ")

def main():
    if False:
        return 10
    plugins = [*iter_plugins()]
    reference_dir = pathlib.Path('doc', 'en', 'reference')
    plugin_list = reference_dir / 'plugin_list.rst'
    with plugin_list.open('w', encoding='UTF-8') as f:
        f.write(FILE_HEAD)
        f.write(f'This list contains {len(plugins)} plugins.\n\n')
        f.write('.. only:: not latex\n\n')
        wcwidth
        plugin_table = tabulate.tabulate(plugins, headers='keys', tablefmt='rst')
        f.write(indent(plugin_table, '   '))
        f.write('\n\n')
        f.write('.. only:: latex\n\n')
        f.write(indent(''.join(plugin_definitions(plugins)), '  '))
if __name__ == '__main__':
    main()