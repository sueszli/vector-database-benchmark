"""This file contains the implementation for the Serve REST API.

This implementation is in a class generated by a factory method. serve_head.py
and serve_agent.py run the factory method to generate versions of the class
that inherit from the DashboardHeadModule and DashboardAgentModule classes,
respectively.

This means the API will be accessible on both the dashboard head and the
dashboard agent. Any changes here will affect both the head and the agent.
"""
import json
import asyncio
import logging
import dataclasses
from functools import wraps
from typing import Union
import aiohttp
from aiohttp.web import Request, Response
import ray
from ray.exceptions import RayTaskError
from ray.dashboard.modules.version import CURRENT_VERSION, VersionResponse
import ray.dashboard.utils as dashboard_utils
import ray.dashboard.optional_utils as optional_utils
import ray.dashboard.optional_utils as dashboard_optional_utils
from ray._private.pydantic_compat import ValidationError
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

def validate_endpoint(log_deprecation_warning: bool):
    if False:
        print('Hello World!')

    def decorator(func):
        if False:
            for i in range(10):
                print('nop')

        @wraps(func)
        async def check(self, *args, **kwargs):
            try:
                from ray import serve
                if log_deprecation_warning:
                    logger.info("The Serve REST API on the dashboard agent is deprecated. Send requests to the Serve REST API directly to the dashboard instead. If you're using default ports, this means you should send the request to the same route on port 8265 instead of 52365.")
            except ImportError:
                return Response(status=501, text='Serve dependencies are not installed. Please run `pip install "ray[serve]"`.')
            return await func(self, *args, **kwargs)
        return check
    return decorator

def create_serve_rest_api(dashboard_module_superclass: Union[dashboard_utils.DashboardHeadModule, dashboard_utils.DashboardAgentModule], dashboard_route_table: Union[dashboard_optional_utils.DashboardHeadRouteTable, dashboard_optional_utils.DashboardAgentRouteTable], log_deprecation_warning: bool=False):
    if False:
        i = 10
        return i + 15

    class ServeRestApiImpl(dashboard_module_superclass):

        def __init__(self, dashboard_head_or_agent):
            if False:
                return 10
            super().__init__(dashboard_head_or_agent)
            self._controller = None
            self._controller_lock = asyncio.Lock()
            self._controller_start_lock = asyncio.Lock()

        @dashboard_route_table.get('/api/ray/version')
        async def get_version(self, req: Request) -> Response:
            resp = VersionResponse(version=CURRENT_VERSION, ray_version=ray.__version__, ray_commit=ray.__commit__)
            return Response(text=json.dumps(dataclasses.asdict(resp)), content_type='application/json', status=aiohttp.web.HTTPOk.status_code)

        @dashboard_route_table.get('/api/serve/applications/')
        @optional_utils.init_ray_and_catch_exceptions()
        @validate_endpoint(log_deprecation_warning=log_deprecation_warning)
        async def get_serve_instance_details(self, req: Request) -> Response:
            from ray.serve.schema import ServeInstanceDetails
            controller = await self.get_serve_controller()
            if controller is None:
                details = ServeInstanceDetails.get_empty_schema_dict()
            else:
                try:
                    details = await controller.get_serve_instance_details.remote()
                except ray.exceptions.RayTaskError as e:
                    return Response(status=503, text=f'Failed to get a response from the controller. The GCS may be down, please retry later: {e}')
            return Response(text=json.dumps(details), content_type='application/json')

        @dashboard_route_table.delete('/api/serve/applications/')
        @optional_utils.init_ray_and_catch_exceptions()
        async def delete_serve_applications(self, req: Request) -> Response:
            from ray import serve
            if await self.get_serve_controller() is not None:
                serve.shutdown()
            return Response()

        @dashboard_route_table.put('/api/serve/applications/')
        @optional_utils.init_ray_and_catch_exceptions()
        @validate_endpoint(log_deprecation_warning=log_deprecation_warning)
        async def put_all_applications(self, req: Request) -> Response:
            from ray.serve.config import ProxyLocation
            from ray.serve._private.api import serve_start_async
            from ray.serve.schema import ServeDeploySchema
            from ray._private.usage.usage_lib import TagKey, record_extra_usage_tag
            try:
                config: ServeDeploySchema = ServeDeploySchema.parse_obj(await req.json())
            except ValidationError as e:
                return Response(status=400, text=repr(e))
            config_http_options = config.http_options.dict()
            location = ProxyLocation._to_deployment_mode(config.proxy_location)
            full_http_options = dict({'location': location}, **config_http_options)
            grpc_options = config.grpc_options.dict()
            async with self._controller_start_lock:
                client = await serve_start_async(http_options=full_http_options, grpc_options=grpc_options, system_logging_config=config.logging_config)
            self.validate_http_options(client, full_http_options)
            try:
                if config.logging_config:
                    client.update_system_logging_config(config.logging_config)
                client.deploy_apps(config)
                record_extra_usage_tag(TagKey.SERVE_REST_API_VERSION, 'v2')
            except RayTaskError as e:
                return Response(status=400, text=str(e))
            else:
                return Response()

        def validate_http_options(self, client, http_options):
            if False:
                i = 10
                return i + 15
            divergent_http_options = []
            for (option, new_value) in http_options.items():
                prev_value = getattr(client.http_config, option)
                if prev_value != new_value:
                    divergent_http_options.append(option)
            if divergent_http_options:
                logger.warning(f"Serve is already running on this Ray cluster and it's not possible to update its HTTP options without restarting it. Following options are attempted to be updated: {divergent_http_options}.")

        async def get_serve_controller(self):
            """Gets the ServeController to the this cluster's Serve app.

            return: If Serve is running on this Ray cluster, returns a client to
                the Serve controller. If Serve is not running, returns None.
            """
            async with self._controller_lock:
                if self._controller is not None:
                    try:
                        await self._controller.check_alive.remote()
                        return self._controller
                    except ray.exceptions.RayActorError:
                        logger.info('Controller is dead')
                    self._controller = None
                from ray.serve._private.constants import SERVE_CONTROLLER_NAME, SERVE_NAMESPACE
                try:
                    self._controller = ray.get_actor(SERVE_CONTROLLER_NAME, namespace=SERVE_NAMESPACE)
                except Exception as e:
                    logger.debug(f'There is no instance running on this Ray cluster. Please call `serve.start(detached=True) to start one: {e}')
                return self._controller

        async def run(self, server):
            pass

        @staticmethod
        def is_minimal_module():
            if False:
                while True:
                    i = 10
            return False
    return ServeRestApiImpl(dashboard_module_superclass)