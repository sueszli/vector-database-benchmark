[
    {
        "func_name": "initialize",
        "original": "def initialize(algo, eps=1, window_length=5):\n    algo.stocks = STOCKS\n    algo.sids = [algo.symbol(symbol) for symbol in algo.stocks]\n    algo.m = len(algo.stocks)\n    algo.price = {}\n    algo.b_t = np.ones(algo.m) / algo.m\n    algo.last_desired_port = np.ones(algo.m) / algo.m\n    algo.eps = eps\n    algo.init = True\n    algo.days = 0\n    algo.window_length = window_length\n    algo.set_commission(commission.PerShare(cost=0, min_trade_cost=1.0))\n    algo.set_slippage(slippage.VolumeShareSlippage())",
        "mutated": [
            "def initialize(algo, eps=1, window_length=5):\n    if False:\n        i = 10\n    algo.stocks = STOCKS\n    algo.sids = [algo.symbol(symbol) for symbol in algo.stocks]\n    algo.m = len(algo.stocks)\n    algo.price = {}\n    algo.b_t = np.ones(algo.m) / algo.m\n    algo.last_desired_port = np.ones(algo.m) / algo.m\n    algo.eps = eps\n    algo.init = True\n    algo.days = 0\n    algo.window_length = window_length\n    algo.set_commission(commission.PerShare(cost=0, min_trade_cost=1.0))\n    algo.set_slippage(slippage.VolumeShareSlippage())",
            "def initialize(algo, eps=1, window_length=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    algo.stocks = STOCKS\n    algo.sids = [algo.symbol(symbol) for symbol in algo.stocks]\n    algo.m = len(algo.stocks)\n    algo.price = {}\n    algo.b_t = np.ones(algo.m) / algo.m\n    algo.last_desired_port = np.ones(algo.m) / algo.m\n    algo.eps = eps\n    algo.init = True\n    algo.days = 0\n    algo.window_length = window_length\n    algo.set_commission(commission.PerShare(cost=0, min_trade_cost=1.0))\n    algo.set_slippage(slippage.VolumeShareSlippage())",
            "def initialize(algo, eps=1, window_length=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    algo.stocks = STOCKS\n    algo.sids = [algo.symbol(symbol) for symbol in algo.stocks]\n    algo.m = len(algo.stocks)\n    algo.price = {}\n    algo.b_t = np.ones(algo.m) / algo.m\n    algo.last_desired_port = np.ones(algo.m) / algo.m\n    algo.eps = eps\n    algo.init = True\n    algo.days = 0\n    algo.window_length = window_length\n    algo.set_commission(commission.PerShare(cost=0, min_trade_cost=1.0))\n    algo.set_slippage(slippage.VolumeShareSlippage())",
            "def initialize(algo, eps=1, window_length=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    algo.stocks = STOCKS\n    algo.sids = [algo.symbol(symbol) for symbol in algo.stocks]\n    algo.m = len(algo.stocks)\n    algo.price = {}\n    algo.b_t = np.ones(algo.m) / algo.m\n    algo.last_desired_port = np.ones(algo.m) / algo.m\n    algo.eps = eps\n    algo.init = True\n    algo.days = 0\n    algo.window_length = window_length\n    algo.set_commission(commission.PerShare(cost=0, min_trade_cost=1.0))\n    algo.set_slippage(slippage.VolumeShareSlippage())",
            "def initialize(algo, eps=1, window_length=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    algo.stocks = STOCKS\n    algo.sids = [algo.symbol(symbol) for symbol in algo.stocks]\n    algo.m = len(algo.stocks)\n    algo.price = {}\n    algo.b_t = np.ones(algo.m) / algo.m\n    algo.last_desired_port = np.ones(algo.m) / algo.m\n    algo.eps = eps\n    algo.init = True\n    algo.days = 0\n    algo.window_length = window_length\n    algo.set_commission(commission.PerShare(cost=0, min_trade_cost=1.0))\n    algo.set_slippage(slippage.VolumeShareSlippage())"
        ]
    },
    {
        "func_name": "handle_data",
        "original": "def handle_data(algo, data):\n    algo.days += 1\n    if algo.days < algo.window_length:\n        return\n    if algo.init:\n        rebalance_portfolio(algo, data, algo.b_t)\n        algo.init = False\n        return\n    m = algo.m\n    x_tilde = np.zeros(m)\n    mavgs = data.history(algo.sids, 'price', algo.window_length, '1d').mean()\n    for (i, sid) in enumerate(algo.sids):\n        price = data.current(sid, 'price')\n        x_tilde[i] = mavgs[sid] / price\n    x_bar = x_tilde.mean()\n    mark_rel_dev = x_tilde - x_bar\n    exp_return = np.dot(algo.b_t, x_tilde)\n    weight = algo.eps - exp_return\n    variability = np.linalg.norm(mark_rel_dev) ** 2\n    if variability == 0.0:\n        step_size = 0\n    else:\n        step_size = max(0, weight / variability)\n    b = algo.b_t + step_size * mark_rel_dev\n    b_norm = simplex_projection(b)\n    np.testing.assert_almost_equal(b_norm.sum(), 1)\n    rebalance_portfolio(algo, data, b_norm)\n    algo.b_t = b_norm",
        "mutated": [
            "def handle_data(algo, data):\n    if False:\n        i = 10\n    algo.days += 1\n    if algo.days < algo.window_length:\n        return\n    if algo.init:\n        rebalance_portfolio(algo, data, algo.b_t)\n        algo.init = False\n        return\n    m = algo.m\n    x_tilde = np.zeros(m)\n    mavgs = data.history(algo.sids, 'price', algo.window_length, '1d').mean()\n    for (i, sid) in enumerate(algo.sids):\n        price = data.current(sid, 'price')\n        x_tilde[i] = mavgs[sid] / price\n    x_bar = x_tilde.mean()\n    mark_rel_dev = x_tilde - x_bar\n    exp_return = np.dot(algo.b_t, x_tilde)\n    weight = algo.eps - exp_return\n    variability = np.linalg.norm(mark_rel_dev) ** 2\n    if variability == 0.0:\n        step_size = 0\n    else:\n        step_size = max(0, weight / variability)\n    b = algo.b_t + step_size * mark_rel_dev\n    b_norm = simplex_projection(b)\n    np.testing.assert_almost_equal(b_norm.sum(), 1)\n    rebalance_portfolio(algo, data, b_norm)\n    algo.b_t = b_norm",
            "def handle_data(algo, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    algo.days += 1\n    if algo.days < algo.window_length:\n        return\n    if algo.init:\n        rebalance_portfolio(algo, data, algo.b_t)\n        algo.init = False\n        return\n    m = algo.m\n    x_tilde = np.zeros(m)\n    mavgs = data.history(algo.sids, 'price', algo.window_length, '1d').mean()\n    for (i, sid) in enumerate(algo.sids):\n        price = data.current(sid, 'price')\n        x_tilde[i] = mavgs[sid] / price\n    x_bar = x_tilde.mean()\n    mark_rel_dev = x_tilde - x_bar\n    exp_return = np.dot(algo.b_t, x_tilde)\n    weight = algo.eps - exp_return\n    variability = np.linalg.norm(mark_rel_dev) ** 2\n    if variability == 0.0:\n        step_size = 0\n    else:\n        step_size = max(0, weight / variability)\n    b = algo.b_t + step_size * mark_rel_dev\n    b_norm = simplex_projection(b)\n    np.testing.assert_almost_equal(b_norm.sum(), 1)\n    rebalance_portfolio(algo, data, b_norm)\n    algo.b_t = b_norm",
            "def handle_data(algo, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    algo.days += 1\n    if algo.days < algo.window_length:\n        return\n    if algo.init:\n        rebalance_portfolio(algo, data, algo.b_t)\n        algo.init = False\n        return\n    m = algo.m\n    x_tilde = np.zeros(m)\n    mavgs = data.history(algo.sids, 'price', algo.window_length, '1d').mean()\n    for (i, sid) in enumerate(algo.sids):\n        price = data.current(sid, 'price')\n        x_tilde[i] = mavgs[sid] / price\n    x_bar = x_tilde.mean()\n    mark_rel_dev = x_tilde - x_bar\n    exp_return = np.dot(algo.b_t, x_tilde)\n    weight = algo.eps - exp_return\n    variability = np.linalg.norm(mark_rel_dev) ** 2\n    if variability == 0.0:\n        step_size = 0\n    else:\n        step_size = max(0, weight / variability)\n    b = algo.b_t + step_size * mark_rel_dev\n    b_norm = simplex_projection(b)\n    np.testing.assert_almost_equal(b_norm.sum(), 1)\n    rebalance_portfolio(algo, data, b_norm)\n    algo.b_t = b_norm",
            "def handle_data(algo, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    algo.days += 1\n    if algo.days < algo.window_length:\n        return\n    if algo.init:\n        rebalance_portfolio(algo, data, algo.b_t)\n        algo.init = False\n        return\n    m = algo.m\n    x_tilde = np.zeros(m)\n    mavgs = data.history(algo.sids, 'price', algo.window_length, '1d').mean()\n    for (i, sid) in enumerate(algo.sids):\n        price = data.current(sid, 'price')\n        x_tilde[i] = mavgs[sid] / price\n    x_bar = x_tilde.mean()\n    mark_rel_dev = x_tilde - x_bar\n    exp_return = np.dot(algo.b_t, x_tilde)\n    weight = algo.eps - exp_return\n    variability = np.linalg.norm(mark_rel_dev) ** 2\n    if variability == 0.0:\n        step_size = 0\n    else:\n        step_size = max(0, weight / variability)\n    b = algo.b_t + step_size * mark_rel_dev\n    b_norm = simplex_projection(b)\n    np.testing.assert_almost_equal(b_norm.sum(), 1)\n    rebalance_portfolio(algo, data, b_norm)\n    algo.b_t = b_norm",
            "def handle_data(algo, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    algo.days += 1\n    if algo.days < algo.window_length:\n        return\n    if algo.init:\n        rebalance_portfolio(algo, data, algo.b_t)\n        algo.init = False\n        return\n    m = algo.m\n    x_tilde = np.zeros(m)\n    mavgs = data.history(algo.sids, 'price', algo.window_length, '1d').mean()\n    for (i, sid) in enumerate(algo.sids):\n        price = data.current(sid, 'price')\n        x_tilde[i] = mavgs[sid] / price\n    x_bar = x_tilde.mean()\n    mark_rel_dev = x_tilde - x_bar\n    exp_return = np.dot(algo.b_t, x_tilde)\n    weight = algo.eps - exp_return\n    variability = np.linalg.norm(mark_rel_dev) ** 2\n    if variability == 0.0:\n        step_size = 0\n    else:\n        step_size = max(0, weight / variability)\n    b = algo.b_t + step_size * mark_rel_dev\n    b_norm = simplex_projection(b)\n    np.testing.assert_almost_equal(b_norm.sum(), 1)\n    rebalance_portfolio(algo, data, b_norm)\n    algo.b_t = b_norm"
        ]
    },
    {
        "func_name": "rebalance_portfolio",
        "original": "def rebalance_portfolio(algo, data, desired_port):\n    desired_amount = np.zeros_like(desired_port)\n    current_amount = np.zeros_like(desired_port)\n    prices = np.zeros_like(desired_port)\n    if algo.init:\n        positions_value = algo.portfolio.starting_cash\n    else:\n        positions_value = algo.portfolio.positions_value + algo.portfolio.cash\n    for (i, sid) in enumerate(algo.sids):\n        current_amount[i] = algo.portfolio.positions[sid].amount\n        prices[i] = data.current(sid, 'price')\n    desired_amount = np.round(desired_port * positions_value / prices)\n    algo.last_desired_port = desired_port\n    diff_amount = desired_amount - current_amount\n    for (i, sid) in enumerate(algo.sids):\n        algo.order(sid, diff_amount[i])",
        "mutated": [
            "def rebalance_portfolio(algo, data, desired_port):\n    if False:\n        i = 10\n    desired_amount = np.zeros_like(desired_port)\n    current_amount = np.zeros_like(desired_port)\n    prices = np.zeros_like(desired_port)\n    if algo.init:\n        positions_value = algo.portfolio.starting_cash\n    else:\n        positions_value = algo.portfolio.positions_value + algo.portfolio.cash\n    for (i, sid) in enumerate(algo.sids):\n        current_amount[i] = algo.portfolio.positions[sid].amount\n        prices[i] = data.current(sid, 'price')\n    desired_amount = np.round(desired_port * positions_value / prices)\n    algo.last_desired_port = desired_port\n    diff_amount = desired_amount - current_amount\n    for (i, sid) in enumerate(algo.sids):\n        algo.order(sid, diff_amount[i])",
            "def rebalance_portfolio(algo, data, desired_port):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    desired_amount = np.zeros_like(desired_port)\n    current_amount = np.zeros_like(desired_port)\n    prices = np.zeros_like(desired_port)\n    if algo.init:\n        positions_value = algo.portfolio.starting_cash\n    else:\n        positions_value = algo.portfolio.positions_value + algo.portfolio.cash\n    for (i, sid) in enumerate(algo.sids):\n        current_amount[i] = algo.portfolio.positions[sid].amount\n        prices[i] = data.current(sid, 'price')\n    desired_amount = np.round(desired_port * positions_value / prices)\n    algo.last_desired_port = desired_port\n    diff_amount = desired_amount - current_amount\n    for (i, sid) in enumerate(algo.sids):\n        algo.order(sid, diff_amount[i])",
            "def rebalance_portfolio(algo, data, desired_port):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    desired_amount = np.zeros_like(desired_port)\n    current_amount = np.zeros_like(desired_port)\n    prices = np.zeros_like(desired_port)\n    if algo.init:\n        positions_value = algo.portfolio.starting_cash\n    else:\n        positions_value = algo.portfolio.positions_value + algo.portfolio.cash\n    for (i, sid) in enumerate(algo.sids):\n        current_amount[i] = algo.portfolio.positions[sid].amount\n        prices[i] = data.current(sid, 'price')\n    desired_amount = np.round(desired_port * positions_value / prices)\n    algo.last_desired_port = desired_port\n    diff_amount = desired_amount - current_amount\n    for (i, sid) in enumerate(algo.sids):\n        algo.order(sid, diff_amount[i])",
            "def rebalance_portfolio(algo, data, desired_port):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    desired_amount = np.zeros_like(desired_port)\n    current_amount = np.zeros_like(desired_port)\n    prices = np.zeros_like(desired_port)\n    if algo.init:\n        positions_value = algo.portfolio.starting_cash\n    else:\n        positions_value = algo.portfolio.positions_value + algo.portfolio.cash\n    for (i, sid) in enumerate(algo.sids):\n        current_amount[i] = algo.portfolio.positions[sid].amount\n        prices[i] = data.current(sid, 'price')\n    desired_amount = np.round(desired_port * positions_value / prices)\n    algo.last_desired_port = desired_port\n    diff_amount = desired_amount - current_amount\n    for (i, sid) in enumerate(algo.sids):\n        algo.order(sid, diff_amount[i])",
            "def rebalance_portfolio(algo, data, desired_port):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    desired_amount = np.zeros_like(desired_port)\n    current_amount = np.zeros_like(desired_port)\n    prices = np.zeros_like(desired_port)\n    if algo.init:\n        positions_value = algo.portfolio.starting_cash\n    else:\n        positions_value = algo.portfolio.positions_value + algo.portfolio.cash\n    for (i, sid) in enumerate(algo.sids):\n        current_amount[i] = algo.portfolio.positions[sid].amount\n        prices[i] = data.current(sid, 'price')\n    desired_amount = np.round(desired_port * positions_value / prices)\n    algo.last_desired_port = desired_port\n    diff_amount = desired_amount - current_amount\n    for (i, sid) in enumerate(algo.sids):\n        algo.order(sid, diff_amount[i])"
        ]
    },
    {
        "func_name": "simplex_projection",
        "original": "def simplex_projection(v, b=1):\n    \"\"\"Projection vectors to the simplex domain\n\n    Implemented according to the paper: Efficient projections onto the\n    l1-ball for learning in high dimensions, John Duchi, et al. ICML 2008.\n    Implementation Time: 2011 June 17 by Bin@libin AT pmail.ntu.edu.sg\n    Optimization Problem: min_{w}\\\\| w - v \\\\|_{2}^{2}\n    s.t. sum_{i=1}^{m}=z, w_{i}\\\\geq 0\n\n    Input: A vector v \\\\in R^{m}, and a scalar z > 0 (default=1)\n    Output: Projection vector w\n\n    :Example:\n    >>> proj = simplex_projection([.4 ,.3, -.4, .5])\n    >>> proj  # doctest: +NORMALIZE_WHITESPACE\n    array([ 0.33333333, 0.23333333, 0. , 0.43333333])\n    >>> print(proj.sum())\n    1.0\n\n    Original matlab implementation: John Duchi (jduchi@cs.berkeley.edu)\n    Python-port: Copyright 2013 by Thomas Wiecki (thomas.wiecki@gmail.com).\n    \"\"\"\n    v = np.asarray(v)\n    p = len(v)\n    v = (v > 0) * v\n    u = np.sort(v)[::-1]\n    sv = np.cumsum(u)\n    rho = np.where(u > (sv - b) / np.arange(1, p + 1))[0][-1]\n    theta = np.max([0, (sv[rho] - b) / (rho + 1)])\n    w = v - theta\n    w[w < 0] = 0\n    return w",
        "mutated": [
            "def simplex_projection(v, b=1):\n    if False:\n        i = 10\n    'Projection vectors to the simplex domain\\n\\n    Implemented according to the paper: Efficient projections onto the\\n    l1-ball for learning in high dimensions, John Duchi, et al. ICML 2008.\\n    Implementation Time: 2011 June 17 by Bin@libin AT pmail.ntu.edu.sg\\n    Optimization Problem: min_{w}\\\\| w - v \\\\|_{2}^{2}\\n    s.t. sum_{i=1}^{m}=z, w_{i}\\\\geq 0\\n\\n    Input: A vector v \\\\in R^{m}, and a scalar z > 0 (default=1)\\n    Output: Projection vector w\\n\\n    :Example:\\n    >>> proj = simplex_projection([.4 ,.3, -.4, .5])\\n    >>> proj  # doctest: +NORMALIZE_WHITESPACE\\n    array([ 0.33333333, 0.23333333, 0. , 0.43333333])\\n    >>> print(proj.sum())\\n    1.0\\n\\n    Original matlab implementation: John Duchi (jduchi@cs.berkeley.edu)\\n    Python-port: Copyright 2013 by Thomas Wiecki (thomas.wiecki@gmail.com).\\n    '\n    v = np.asarray(v)\n    p = len(v)\n    v = (v > 0) * v\n    u = np.sort(v)[::-1]\n    sv = np.cumsum(u)\n    rho = np.where(u > (sv - b) / np.arange(1, p + 1))[0][-1]\n    theta = np.max([0, (sv[rho] - b) / (rho + 1)])\n    w = v - theta\n    w[w < 0] = 0\n    return w",
            "def simplex_projection(v, b=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Projection vectors to the simplex domain\\n\\n    Implemented according to the paper: Efficient projections onto the\\n    l1-ball for learning in high dimensions, John Duchi, et al. ICML 2008.\\n    Implementation Time: 2011 June 17 by Bin@libin AT pmail.ntu.edu.sg\\n    Optimization Problem: min_{w}\\\\| w - v \\\\|_{2}^{2}\\n    s.t. sum_{i=1}^{m}=z, w_{i}\\\\geq 0\\n\\n    Input: A vector v \\\\in R^{m}, and a scalar z > 0 (default=1)\\n    Output: Projection vector w\\n\\n    :Example:\\n    >>> proj = simplex_projection([.4 ,.3, -.4, .5])\\n    >>> proj  # doctest: +NORMALIZE_WHITESPACE\\n    array([ 0.33333333, 0.23333333, 0. , 0.43333333])\\n    >>> print(proj.sum())\\n    1.0\\n\\n    Original matlab implementation: John Duchi (jduchi@cs.berkeley.edu)\\n    Python-port: Copyright 2013 by Thomas Wiecki (thomas.wiecki@gmail.com).\\n    '\n    v = np.asarray(v)\n    p = len(v)\n    v = (v > 0) * v\n    u = np.sort(v)[::-1]\n    sv = np.cumsum(u)\n    rho = np.where(u > (sv - b) / np.arange(1, p + 1))[0][-1]\n    theta = np.max([0, (sv[rho] - b) / (rho + 1)])\n    w = v - theta\n    w[w < 0] = 0\n    return w",
            "def simplex_projection(v, b=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Projection vectors to the simplex domain\\n\\n    Implemented according to the paper: Efficient projections onto the\\n    l1-ball for learning in high dimensions, John Duchi, et al. ICML 2008.\\n    Implementation Time: 2011 June 17 by Bin@libin AT pmail.ntu.edu.sg\\n    Optimization Problem: min_{w}\\\\| w - v \\\\|_{2}^{2}\\n    s.t. sum_{i=1}^{m}=z, w_{i}\\\\geq 0\\n\\n    Input: A vector v \\\\in R^{m}, and a scalar z > 0 (default=1)\\n    Output: Projection vector w\\n\\n    :Example:\\n    >>> proj = simplex_projection([.4 ,.3, -.4, .5])\\n    >>> proj  # doctest: +NORMALIZE_WHITESPACE\\n    array([ 0.33333333, 0.23333333, 0. , 0.43333333])\\n    >>> print(proj.sum())\\n    1.0\\n\\n    Original matlab implementation: John Duchi (jduchi@cs.berkeley.edu)\\n    Python-port: Copyright 2013 by Thomas Wiecki (thomas.wiecki@gmail.com).\\n    '\n    v = np.asarray(v)\n    p = len(v)\n    v = (v > 0) * v\n    u = np.sort(v)[::-1]\n    sv = np.cumsum(u)\n    rho = np.where(u > (sv - b) / np.arange(1, p + 1))[0][-1]\n    theta = np.max([0, (sv[rho] - b) / (rho + 1)])\n    w = v - theta\n    w[w < 0] = 0\n    return w",
            "def simplex_projection(v, b=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Projection vectors to the simplex domain\\n\\n    Implemented according to the paper: Efficient projections onto the\\n    l1-ball for learning in high dimensions, John Duchi, et al. ICML 2008.\\n    Implementation Time: 2011 June 17 by Bin@libin AT pmail.ntu.edu.sg\\n    Optimization Problem: min_{w}\\\\| w - v \\\\|_{2}^{2}\\n    s.t. sum_{i=1}^{m}=z, w_{i}\\\\geq 0\\n\\n    Input: A vector v \\\\in R^{m}, and a scalar z > 0 (default=1)\\n    Output: Projection vector w\\n\\n    :Example:\\n    >>> proj = simplex_projection([.4 ,.3, -.4, .5])\\n    >>> proj  # doctest: +NORMALIZE_WHITESPACE\\n    array([ 0.33333333, 0.23333333, 0. , 0.43333333])\\n    >>> print(proj.sum())\\n    1.0\\n\\n    Original matlab implementation: John Duchi (jduchi@cs.berkeley.edu)\\n    Python-port: Copyright 2013 by Thomas Wiecki (thomas.wiecki@gmail.com).\\n    '\n    v = np.asarray(v)\n    p = len(v)\n    v = (v > 0) * v\n    u = np.sort(v)[::-1]\n    sv = np.cumsum(u)\n    rho = np.where(u > (sv - b) / np.arange(1, p + 1))[0][-1]\n    theta = np.max([0, (sv[rho] - b) / (rho + 1)])\n    w = v - theta\n    w[w < 0] = 0\n    return w",
            "def simplex_projection(v, b=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Projection vectors to the simplex domain\\n\\n    Implemented according to the paper: Efficient projections onto the\\n    l1-ball for learning in high dimensions, John Duchi, et al. ICML 2008.\\n    Implementation Time: 2011 June 17 by Bin@libin AT pmail.ntu.edu.sg\\n    Optimization Problem: min_{w}\\\\| w - v \\\\|_{2}^{2}\\n    s.t. sum_{i=1}^{m}=z, w_{i}\\\\geq 0\\n\\n    Input: A vector v \\\\in R^{m}, and a scalar z > 0 (default=1)\\n    Output: Projection vector w\\n\\n    :Example:\\n    >>> proj = simplex_projection([.4 ,.3, -.4, .5])\\n    >>> proj  # doctest: +NORMALIZE_WHITESPACE\\n    array([ 0.33333333, 0.23333333, 0. , 0.43333333])\\n    >>> print(proj.sum())\\n    1.0\\n\\n    Original matlab implementation: John Duchi (jduchi@cs.berkeley.edu)\\n    Python-port: Copyright 2013 by Thomas Wiecki (thomas.wiecki@gmail.com).\\n    '\n    v = np.asarray(v)\n    p = len(v)\n    v = (v > 0) * v\n    u = np.sort(v)[::-1]\n    sv = np.cumsum(u)\n    rho = np.where(u > (sv - b) / np.arange(1, p + 1))[0][-1]\n    theta = np.max([0, (sv[rho] - b) / (rho + 1)])\n    w = v - theta\n    w[w < 0] = 0\n    return w"
        ]
    },
    {
        "func_name": "analyze",
        "original": "def analyze(context=None, results=None):\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    results.portfolio_value.plot(ax=ax)\n    ax.set_ylabel('Portfolio value (USD)')\n    plt.show()",
        "mutated": [
            "def analyze(context=None, results=None):\n    if False:\n        i = 10\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    results.portfolio_value.plot(ax=ax)\n    ax.set_ylabel('Portfolio value (USD)')\n    plt.show()",
            "def analyze(context=None, results=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    results.portfolio_value.plot(ax=ax)\n    ax.set_ylabel('Portfolio value (USD)')\n    plt.show()",
            "def analyze(context=None, results=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    results.portfolio_value.plot(ax=ax)\n    ax.set_ylabel('Portfolio value (USD)')\n    plt.show()",
            "def analyze(context=None, results=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    results.portfolio_value.plot(ax=ax)\n    ax.set_ylabel('Portfolio value (USD)')\n    plt.show()",
            "def analyze(context=None, results=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    import matplotlib.pyplot as plt\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    results.portfolio_value.plot(ax=ax)\n    ax.set_ylabel('Portfolio value (USD)')\n    plt.show()"
        ]
    },
    {
        "func_name": "_test_args",
        "original": "def _test_args():\n    \"\"\"Extra arguments to use when zipline's automated tests run this example.\n    \"\"\"\n    import pandas as pd\n    return {'start': pd.Timestamp('2004', tz='utc'), 'end': pd.Timestamp('2008', tz='utc')}",
        "mutated": [
            "def _test_args():\n    if False:\n        i = 10\n    \"Extra arguments to use when zipline's automated tests run this example.\\n    \"\n    import pandas as pd\n    return {'start': pd.Timestamp('2004', tz='utc'), 'end': pd.Timestamp('2008', tz='utc')}",
            "def _test_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Extra arguments to use when zipline's automated tests run this example.\\n    \"\n    import pandas as pd\n    return {'start': pd.Timestamp('2004', tz='utc'), 'end': pd.Timestamp('2008', tz='utc')}",
            "def _test_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Extra arguments to use when zipline's automated tests run this example.\\n    \"\n    import pandas as pd\n    return {'start': pd.Timestamp('2004', tz='utc'), 'end': pd.Timestamp('2008', tz='utc')}",
            "def _test_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Extra arguments to use when zipline's automated tests run this example.\\n    \"\n    import pandas as pd\n    return {'start': pd.Timestamp('2004', tz='utc'), 'end': pd.Timestamp('2008', tz='utc')}",
            "def _test_args():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Extra arguments to use when zipline's automated tests run this example.\\n    \"\n    import pandas as pd\n    return {'start': pd.Timestamp('2004', tz='utc'), 'end': pd.Timestamp('2008', tz='utc')}"
        ]
    }
]