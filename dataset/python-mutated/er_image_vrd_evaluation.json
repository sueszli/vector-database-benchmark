[
    {
        "func_name": "__init__",
        "original": "def __init__(self, matching_iou_threshold=0.5):\n    \"\"\"Initialized PerImageVRDEvaluation by evaluation parameters.\n\n    Args:\n      matching_iou_threshold: A ratio of area intersection to union, which is\n          the threshold to consider whether a detection is true positive or not;\n          in phrase detection subtask.\n    \"\"\"\n    self.matching_iou_threshold = matching_iou_threshold",
        "mutated": [
            "def __init__(self, matching_iou_threshold=0.5):\n    if False:\n        i = 10\n    'Initialized PerImageVRDEvaluation by evaluation parameters.\\n\\n    Args:\\n      matching_iou_threshold: A ratio of area intersection to union, which is\\n          the threshold to consider whether a detection is true positive or not;\\n          in phrase detection subtask.\\n    '\n    self.matching_iou_threshold = matching_iou_threshold",
            "def __init__(self, matching_iou_threshold=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialized PerImageVRDEvaluation by evaluation parameters.\\n\\n    Args:\\n      matching_iou_threshold: A ratio of area intersection to union, which is\\n          the threshold to consider whether a detection is true positive or not;\\n          in phrase detection subtask.\\n    '\n    self.matching_iou_threshold = matching_iou_threshold",
            "def __init__(self, matching_iou_threshold=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialized PerImageVRDEvaluation by evaluation parameters.\\n\\n    Args:\\n      matching_iou_threshold: A ratio of area intersection to union, which is\\n          the threshold to consider whether a detection is true positive or not;\\n          in phrase detection subtask.\\n    '\n    self.matching_iou_threshold = matching_iou_threshold",
            "def __init__(self, matching_iou_threshold=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialized PerImageVRDEvaluation by evaluation parameters.\\n\\n    Args:\\n      matching_iou_threshold: A ratio of area intersection to union, which is\\n          the threshold to consider whether a detection is true positive or not;\\n          in phrase detection subtask.\\n    '\n    self.matching_iou_threshold = matching_iou_threshold",
            "def __init__(self, matching_iou_threshold=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialized PerImageVRDEvaluation by evaluation parameters.\\n\\n    Args:\\n      matching_iou_threshold: A ratio of area intersection to union, which is\\n          the threshold to consider whether a detection is true positive or not;\\n          in phrase detection subtask.\\n    '\n    self.matching_iou_threshold = matching_iou_threshold"
        ]
    },
    {
        "func_name": "compute_detection_tp_fp",
        "original": "def compute_detection_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    \"\"\"Evaluates VRD as being tp, fp from a single image.\n\n    Args:\n      detected_box_tuples: A numpy array of structures with shape [N,],\n          representing N tuples, each tuple containing the same number of named\n          bounding boxes.\n          Each box is of the format [y_min, x_min, y_max, x_max].\n      detected_scores: A float numpy array of shape [N,], representing\n          the confidence scores of the detected N object instances.\n      detected_class_tuples: A numpy array of structures shape [N,],\n          representing the class labels of the corresponding bounding boxes and\n          possibly additional classes.\n      groundtruth_box_tuples: A float numpy array of structures with the shape\n          [M,], representing M tuples, each tuple containing the same number\n          of named bounding boxes.\n          Each box is of the format [y_min, x_min, y_max, x_max].\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\n          representing  the class labels of the corresponding bounding boxes and\n          possibly additional classes.\n\n    Returns:\n      scores: A single numpy array with shape [N,], representing N scores\n          detected with object class, sorted in descentent order.\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\n          True/False positive label, one label per tuple. The labels are sorted\n          so that the order of the labels matches the order of the scores.\n      result_mapping: A numpy array with shape [N,] with original index of each\n          entry.\n    \"\"\"\n    (scores, tp_fp_labels, result_mapping) = self._compute_tp_fp(detected_box_tuples=detected_box_tuples, detected_scores=detected_scores, detected_class_tuples=detected_class_tuples, groundtruth_box_tuples=groundtruth_box_tuples, groundtruth_class_tuples=groundtruth_class_tuples)\n    return (scores, tp_fp_labels, result_mapping)",
        "mutated": [
            "def compute_detection_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n    'Evaluates VRD as being tp, fp from a single image.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    (scores, tp_fp_labels, result_mapping) = self._compute_tp_fp(detected_box_tuples=detected_box_tuples, detected_scores=detected_scores, detected_class_tuples=detected_class_tuples, groundtruth_box_tuples=groundtruth_box_tuples, groundtruth_class_tuples=groundtruth_class_tuples)\n    return (scores, tp_fp_labels, result_mapping)",
            "def compute_detection_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Evaluates VRD as being tp, fp from a single image.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    (scores, tp_fp_labels, result_mapping) = self._compute_tp_fp(detected_box_tuples=detected_box_tuples, detected_scores=detected_scores, detected_class_tuples=detected_class_tuples, groundtruth_box_tuples=groundtruth_box_tuples, groundtruth_class_tuples=groundtruth_class_tuples)\n    return (scores, tp_fp_labels, result_mapping)",
            "def compute_detection_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Evaluates VRD as being tp, fp from a single image.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    (scores, tp_fp_labels, result_mapping) = self._compute_tp_fp(detected_box_tuples=detected_box_tuples, detected_scores=detected_scores, detected_class_tuples=detected_class_tuples, groundtruth_box_tuples=groundtruth_box_tuples, groundtruth_class_tuples=groundtruth_class_tuples)\n    return (scores, tp_fp_labels, result_mapping)",
            "def compute_detection_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Evaluates VRD as being tp, fp from a single image.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    (scores, tp_fp_labels, result_mapping) = self._compute_tp_fp(detected_box_tuples=detected_box_tuples, detected_scores=detected_scores, detected_class_tuples=detected_class_tuples, groundtruth_box_tuples=groundtruth_box_tuples, groundtruth_class_tuples=groundtruth_class_tuples)\n    return (scores, tp_fp_labels, result_mapping)",
            "def compute_detection_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Evaluates VRD as being tp, fp from a single image.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max].\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    (scores, tp_fp_labels, result_mapping) = self._compute_tp_fp(detected_box_tuples=detected_box_tuples, detected_scores=detected_scores, detected_class_tuples=detected_class_tuples, groundtruth_box_tuples=groundtruth_box_tuples, groundtruth_class_tuples=groundtruth_class_tuples)\n    return (scores, tp_fp_labels, result_mapping)"
        ]
    },
    {
        "func_name": "_compute_tp_fp",
        "original": "def _compute_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    \"\"\"Labels as true/false positives detection tuples across all classes.\n\n    Args:\n      detected_box_tuples: A numpy array of structures with shape [N,],\n          representing N tuples, each tuple containing the same number of named\n          bounding boxes.\n          Each box is of the format [y_min, x_min, y_max, x_max]\n      detected_scores: A float numpy array of shape [N,], representing\n          the confidence scores of the detected N object instances.\n      detected_class_tuples: A numpy array of structures shape [N,],\n          representing the class labels of the corresponding bounding boxes and\n          possibly additional classes.\n      groundtruth_box_tuples: A float numpy array of structures with the shape\n          [M,], representing M tuples, each tuple containing the same number\n          of named bounding boxes.\n          Each box is of the format [y_min, x_min, y_max, x_max]\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\n          representing  the class labels of the corresponding bounding boxes and\n          possibly additional classes.\n\n    Returns:\n      scores: A single numpy array with shape [N,], representing N scores\n          detected with object class, sorted in descentent order.\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\n          True/False positive label, one label per tuple. The labels are sorted\n          so that the order of the labels matches the order of the scores.\n      result_mapping: A numpy array with shape [N,] with original index of each\n          entry.\n    \"\"\"\n    unique_gt_tuples = np.unique(np.concatenate((groundtruth_class_tuples, detected_class_tuples)))\n    result_scores = []\n    result_tp_fp_labels = []\n    result_mapping = []\n    for unique_tuple in unique_gt_tuples:\n        detections_selector = detected_class_tuples == unique_tuple\n        gt_selector = groundtruth_class_tuples == unique_tuple\n        selector_mapping = np.where(detections_selector)[0]\n        detection_scores_per_tuple = detected_scores[detections_selector]\n        detection_box_per_tuple = detected_box_tuples[detections_selector]\n        sorted_indices = np.argsort(detection_scores_per_tuple)\n        sorted_indices = sorted_indices[::-1]\n        tp_fp_labels = self._compute_tp_fp_for_single_class(detected_box_tuples=detection_box_per_tuple[sorted_indices], groundtruth_box_tuples=groundtruth_box_tuples[gt_selector])\n        result_scores.append(detection_scores_per_tuple[sorted_indices])\n        result_tp_fp_labels.append(tp_fp_labels)\n        result_mapping.append(selector_mapping[sorted_indices])\n    if result_scores:\n        result_scores = np.concatenate(result_scores)\n        result_tp_fp_labels = np.concatenate(result_tp_fp_labels)\n        result_mapping = np.concatenate(result_mapping)\n    else:\n        result_scores = np.array([], dtype=float)\n        result_tp_fp_labels = np.array([], dtype=bool)\n        result_mapping = np.array([], dtype=int)\n    sorted_indices = np.argsort(result_scores)\n    sorted_indices = sorted_indices[::-1]\n    return (result_scores[sorted_indices], result_tp_fp_labels[sorted_indices], result_mapping[sorted_indices])",
        "mutated": [
            "def _compute_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n    'Labels as true/false positives detection tuples across all classes.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    unique_gt_tuples = np.unique(np.concatenate((groundtruth_class_tuples, detected_class_tuples)))\n    result_scores = []\n    result_tp_fp_labels = []\n    result_mapping = []\n    for unique_tuple in unique_gt_tuples:\n        detections_selector = detected_class_tuples == unique_tuple\n        gt_selector = groundtruth_class_tuples == unique_tuple\n        selector_mapping = np.where(detections_selector)[0]\n        detection_scores_per_tuple = detected_scores[detections_selector]\n        detection_box_per_tuple = detected_box_tuples[detections_selector]\n        sorted_indices = np.argsort(detection_scores_per_tuple)\n        sorted_indices = sorted_indices[::-1]\n        tp_fp_labels = self._compute_tp_fp_for_single_class(detected_box_tuples=detection_box_per_tuple[sorted_indices], groundtruth_box_tuples=groundtruth_box_tuples[gt_selector])\n        result_scores.append(detection_scores_per_tuple[sorted_indices])\n        result_tp_fp_labels.append(tp_fp_labels)\n        result_mapping.append(selector_mapping[sorted_indices])\n    if result_scores:\n        result_scores = np.concatenate(result_scores)\n        result_tp_fp_labels = np.concatenate(result_tp_fp_labels)\n        result_mapping = np.concatenate(result_mapping)\n    else:\n        result_scores = np.array([], dtype=float)\n        result_tp_fp_labels = np.array([], dtype=bool)\n        result_mapping = np.array([], dtype=int)\n    sorted_indices = np.argsort(result_scores)\n    sorted_indices = sorted_indices[::-1]\n    return (result_scores[sorted_indices], result_tp_fp_labels[sorted_indices], result_mapping[sorted_indices])",
            "def _compute_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Labels as true/false positives detection tuples across all classes.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    unique_gt_tuples = np.unique(np.concatenate((groundtruth_class_tuples, detected_class_tuples)))\n    result_scores = []\n    result_tp_fp_labels = []\n    result_mapping = []\n    for unique_tuple in unique_gt_tuples:\n        detections_selector = detected_class_tuples == unique_tuple\n        gt_selector = groundtruth_class_tuples == unique_tuple\n        selector_mapping = np.where(detections_selector)[0]\n        detection_scores_per_tuple = detected_scores[detections_selector]\n        detection_box_per_tuple = detected_box_tuples[detections_selector]\n        sorted_indices = np.argsort(detection_scores_per_tuple)\n        sorted_indices = sorted_indices[::-1]\n        tp_fp_labels = self._compute_tp_fp_for_single_class(detected_box_tuples=detection_box_per_tuple[sorted_indices], groundtruth_box_tuples=groundtruth_box_tuples[gt_selector])\n        result_scores.append(detection_scores_per_tuple[sorted_indices])\n        result_tp_fp_labels.append(tp_fp_labels)\n        result_mapping.append(selector_mapping[sorted_indices])\n    if result_scores:\n        result_scores = np.concatenate(result_scores)\n        result_tp_fp_labels = np.concatenate(result_tp_fp_labels)\n        result_mapping = np.concatenate(result_mapping)\n    else:\n        result_scores = np.array([], dtype=float)\n        result_tp_fp_labels = np.array([], dtype=bool)\n        result_mapping = np.array([], dtype=int)\n    sorted_indices = np.argsort(result_scores)\n    sorted_indices = sorted_indices[::-1]\n    return (result_scores[sorted_indices], result_tp_fp_labels[sorted_indices], result_mapping[sorted_indices])",
            "def _compute_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Labels as true/false positives detection tuples across all classes.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    unique_gt_tuples = np.unique(np.concatenate((groundtruth_class_tuples, detected_class_tuples)))\n    result_scores = []\n    result_tp_fp_labels = []\n    result_mapping = []\n    for unique_tuple in unique_gt_tuples:\n        detections_selector = detected_class_tuples == unique_tuple\n        gt_selector = groundtruth_class_tuples == unique_tuple\n        selector_mapping = np.where(detections_selector)[0]\n        detection_scores_per_tuple = detected_scores[detections_selector]\n        detection_box_per_tuple = detected_box_tuples[detections_selector]\n        sorted_indices = np.argsort(detection_scores_per_tuple)\n        sorted_indices = sorted_indices[::-1]\n        tp_fp_labels = self._compute_tp_fp_for_single_class(detected_box_tuples=detection_box_per_tuple[sorted_indices], groundtruth_box_tuples=groundtruth_box_tuples[gt_selector])\n        result_scores.append(detection_scores_per_tuple[sorted_indices])\n        result_tp_fp_labels.append(tp_fp_labels)\n        result_mapping.append(selector_mapping[sorted_indices])\n    if result_scores:\n        result_scores = np.concatenate(result_scores)\n        result_tp_fp_labels = np.concatenate(result_tp_fp_labels)\n        result_mapping = np.concatenate(result_mapping)\n    else:\n        result_scores = np.array([], dtype=float)\n        result_tp_fp_labels = np.array([], dtype=bool)\n        result_mapping = np.array([], dtype=int)\n    sorted_indices = np.argsort(result_scores)\n    sorted_indices = sorted_indices[::-1]\n    return (result_scores[sorted_indices], result_tp_fp_labels[sorted_indices], result_mapping[sorted_indices])",
            "def _compute_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Labels as true/false positives detection tuples across all classes.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    unique_gt_tuples = np.unique(np.concatenate((groundtruth_class_tuples, detected_class_tuples)))\n    result_scores = []\n    result_tp_fp_labels = []\n    result_mapping = []\n    for unique_tuple in unique_gt_tuples:\n        detections_selector = detected_class_tuples == unique_tuple\n        gt_selector = groundtruth_class_tuples == unique_tuple\n        selector_mapping = np.where(detections_selector)[0]\n        detection_scores_per_tuple = detected_scores[detections_selector]\n        detection_box_per_tuple = detected_box_tuples[detections_selector]\n        sorted_indices = np.argsort(detection_scores_per_tuple)\n        sorted_indices = sorted_indices[::-1]\n        tp_fp_labels = self._compute_tp_fp_for_single_class(detected_box_tuples=detection_box_per_tuple[sorted_indices], groundtruth_box_tuples=groundtruth_box_tuples[gt_selector])\n        result_scores.append(detection_scores_per_tuple[sorted_indices])\n        result_tp_fp_labels.append(tp_fp_labels)\n        result_mapping.append(selector_mapping[sorted_indices])\n    if result_scores:\n        result_scores = np.concatenate(result_scores)\n        result_tp_fp_labels = np.concatenate(result_tp_fp_labels)\n        result_mapping = np.concatenate(result_mapping)\n    else:\n        result_scores = np.array([], dtype=float)\n        result_tp_fp_labels = np.array([], dtype=bool)\n        result_mapping = np.array([], dtype=int)\n    sorted_indices = np.argsort(result_scores)\n    sorted_indices = sorted_indices[::-1]\n    return (result_scores[sorted_indices], result_tp_fp_labels[sorted_indices], result_mapping[sorted_indices])",
            "def _compute_tp_fp(self, detected_box_tuples, detected_scores, detected_class_tuples, groundtruth_box_tuples, groundtruth_class_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Labels as true/false positives detection tuples across all classes.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      detected_scores: A float numpy array of shape [N,], representing\\n          the confidence scores of the detected N object instances.\\n      detected_class_tuples: A numpy array of structures shape [N,],\\n          representing the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_class_tuples: A numpy array of structures shape [M,],\\n          representing  the class labels of the corresponding bounding boxes and\\n          possibly additional classes.\\n\\n    Returns:\\n      scores: A single numpy array with shape [N,], representing N scores\\n          detected with object class, sorted in descentent order.\\n      tp_fp_labels: A single boolean numpy array of shape [N,], representing N\\n          True/False positive label, one label per tuple. The labels are sorted\\n          so that the order of the labels matches the order of the scores.\\n      result_mapping: A numpy array with shape [N,] with original index of each\\n          entry.\\n    '\n    unique_gt_tuples = np.unique(np.concatenate((groundtruth_class_tuples, detected_class_tuples)))\n    result_scores = []\n    result_tp_fp_labels = []\n    result_mapping = []\n    for unique_tuple in unique_gt_tuples:\n        detections_selector = detected_class_tuples == unique_tuple\n        gt_selector = groundtruth_class_tuples == unique_tuple\n        selector_mapping = np.where(detections_selector)[0]\n        detection_scores_per_tuple = detected_scores[detections_selector]\n        detection_box_per_tuple = detected_box_tuples[detections_selector]\n        sorted_indices = np.argsort(detection_scores_per_tuple)\n        sorted_indices = sorted_indices[::-1]\n        tp_fp_labels = self._compute_tp_fp_for_single_class(detected_box_tuples=detection_box_per_tuple[sorted_indices], groundtruth_box_tuples=groundtruth_box_tuples[gt_selector])\n        result_scores.append(detection_scores_per_tuple[sorted_indices])\n        result_tp_fp_labels.append(tp_fp_labels)\n        result_mapping.append(selector_mapping[sorted_indices])\n    if result_scores:\n        result_scores = np.concatenate(result_scores)\n        result_tp_fp_labels = np.concatenate(result_tp_fp_labels)\n        result_mapping = np.concatenate(result_mapping)\n    else:\n        result_scores = np.array([], dtype=float)\n        result_tp_fp_labels = np.array([], dtype=bool)\n        result_mapping = np.array([], dtype=int)\n    sorted_indices = np.argsort(result_scores)\n    sorted_indices = sorted_indices[::-1]\n    return (result_scores[sorted_indices], result_tp_fp_labels[sorted_indices], result_mapping[sorted_indices])"
        ]
    },
    {
        "func_name": "_get_overlaps_and_scores_relation_tuples",
        "original": "def _get_overlaps_and_scores_relation_tuples(self, detected_box_tuples, groundtruth_box_tuples):\n    \"\"\"Computes overlaps and scores between detected and groundtruth tuples.\n\n    Both detections and groundtruth boxes have the same class tuples.\n\n    Args:\n      detected_box_tuples: A numpy array of structures with shape [N,],\n          representing N tuples, each tuple containing the same number of named\n          bounding boxes.\n          Each box is of the format [y_min, x_min, y_max, x_max]\n      groundtruth_box_tuples: A float numpy array of structures with the shape\n          [M,], representing M tuples, each tuple containing the same number\n          of named bounding boxes.\n          Each box is of the format [y_min, x_min, y_max, x_max]\n\n    Returns:\n      result_iou: A float numpy array of size\n        [num_detected_tuples, num_gt_box_tuples].\n    \"\"\"\n    result_iou = np.ones((detected_box_tuples.shape[0], groundtruth_box_tuples.shape[0]), dtype=float)\n    for field in detected_box_tuples.dtype.fields:\n        detected_boxlist_field = np_box_list.BoxList(detected_box_tuples[field])\n        gt_boxlist_field = np_box_list.BoxList(groundtruth_box_tuples[field])\n        iou_field = np_box_list_ops.iou(detected_boxlist_field, gt_boxlist_field)\n        result_iou = np.minimum(iou_field, result_iou)\n    return result_iou",
        "mutated": [
            "def _get_overlaps_and_scores_relation_tuples(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n    'Computes overlaps and scores between detected and groundtruth tuples.\\n\\n    Both detections and groundtruth boxes have the same class tuples.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      result_iou: A float numpy array of size\\n        [num_detected_tuples, num_gt_box_tuples].\\n    '\n    result_iou = np.ones((detected_box_tuples.shape[0], groundtruth_box_tuples.shape[0]), dtype=float)\n    for field in detected_box_tuples.dtype.fields:\n        detected_boxlist_field = np_box_list.BoxList(detected_box_tuples[field])\n        gt_boxlist_field = np_box_list.BoxList(groundtruth_box_tuples[field])\n        iou_field = np_box_list_ops.iou(detected_boxlist_field, gt_boxlist_field)\n        result_iou = np.minimum(iou_field, result_iou)\n    return result_iou",
            "def _get_overlaps_and_scores_relation_tuples(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes overlaps and scores between detected and groundtruth tuples.\\n\\n    Both detections and groundtruth boxes have the same class tuples.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      result_iou: A float numpy array of size\\n        [num_detected_tuples, num_gt_box_tuples].\\n    '\n    result_iou = np.ones((detected_box_tuples.shape[0], groundtruth_box_tuples.shape[0]), dtype=float)\n    for field in detected_box_tuples.dtype.fields:\n        detected_boxlist_field = np_box_list.BoxList(detected_box_tuples[field])\n        gt_boxlist_field = np_box_list.BoxList(groundtruth_box_tuples[field])\n        iou_field = np_box_list_ops.iou(detected_boxlist_field, gt_boxlist_field)\n        result_iou = np.minimum(iou_field, result_iou)\n    return result_iou",
            "def _get_overlaps_and_scores_relation_tuples(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes overlaps and scores between detected and groundtruth tuples.\\n\\n    Both detections and groundtruth boxes have the same class tuples.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      result_iou: A float numpy array of size\\n        [num_detected_tuples, num_gt_box_tuples].\\n    '\n    result_iou = np.ones((detected_box_tuples.shape[0], groundtruth_box_tuples.shape[0]), dtype=float)\n    for field in detected_box_tuples.dtype.fields:\n        detected_boxlist_field = np_box_list.BoxList(detected_box_tuples[field])\n        gt_boxlist_field = np_box_list.BoxList(groundtruth_box_tuples[field])\n        iou_field = np_box_list_ops.iou(detected_boxlist_field, gt_boxlist_field)\n        result_iou = np.minimum(iou_field, result_iou)\n    return result_iou",
            "def _get_overlaps_and_scores_relation_tuples(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes overlaps and scores between detected and groundtruth tuples.\\n\\n    Both detections and groundtruth boxes have the same class tuples.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      result_iou: A float numpy array of size\\n        [num_detected_tuples, num_gt_box_tuples].\\n    '\n    result_iou = np.ones((detected_box_tuples.shape[0], groundtruth_box_tuples.shape[0]), dtype=float)\n    for field in detected_box_tuples.dtype.fields:\n        detected_boxlist_field = np_box_list.BoxList(detected_box_tuples[field])\n        gt_boxlist_field = np_box_list.BoxList(groundtruth_box_tuples[field])\n        iou_field = np_box_list_ops.iou(detected_boxlist_field, gt_boxlist_field)\n        result_iou = np.minimum(iou_field, result_iou)\n    return result_iou",
            "def _get_overlaps_and_scores_relation_tuples(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes overlaps and scores between detected and groundtruth tuples.\\n\\n    Both detections and groundtruth boxes have the same class tuples.\\n\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      result_iou: A float numpy array of size\\n        [num_detected_tuples, num_gt_box_tuples].\\n    '\n    result_iou = np.ones((detected_box_tuples.shape[0], groundtruth_box_tuples.shape[0]), dtype=float)\n    for field in detected_box_tuples.dtype.fields:\n        detected_boxlist_field = np_box_list.BoxList(detected_box_tuples[field])\n        gt_boxlist_field = np_box_list.BoxList(groundtruth_box_tuples[field])\n        iou_field = np_box_list_ops.iou(detected_boxlist_field, gt_boxlist_field)\n        result_iou = np.minimum(iou_field, result_iou)\n    return result_iou"
        ]
    },
    {
        "func_name": "_compute_tp_fp_for_single_class",
        "original": "def _compute_tp_fp_for_single_class(self, detected_box_tuples, groundtruth_box_tuples):\n    \"\"\"Labels boxes detected with the same class from the same image as tp/fp.\n\n    Detection boxes are expected to be already sorted by score.\n    Args:\n      detected_box_tuples: A numpy array of structures with shape [N,],\n          representing N tuples, each tuple containing the same number of named\n          bounding boxes.\n          Each box is of the format [y_min, x_min, y_max, x_max]\n      groundtruth_box_tuples: A float numpy array of structures with the shape\n          [M,], representing M tuples, each tuple containing the same number\n          of named bounding boxes.\n          Each box is of the format [y_min, x_min, y_max, x_max]\n\n    Returns:\n      tp_fp_labels: a boolean numpy array indicating whether a detection is a\n          true positive.\n    \"\"\"\n    if detected_box_tuples.size == 0:\n        return np.array([], dtype=bool)\n    min_iou = self._get_overlaps_and_scores_relation_tuples(detected_box_tuples, groundtruth_box_tuples)\n    num_detected_tuples = detected_box_tuples.shape[0]\n    tp_fp_labels = np.zeros(num_detected_tuples, dtype=bool)\n    if min_iou.shape[1] > 0:\n        max_overlap_gt_ids = np.argmax(min_iou, axis=1)\n        is_gt_tuple_detected = np.zeros(min_iou.shape[1], dtype=bool)\n        for i in range(num_detected_tuples):\n            gt_id = max_overlap_gt_ids[i]\n            if min_iou[i, gt_id] >= self.matching_iou_threshold:\n                if not is_gt_tuple_detected[gt_id]:\n                    tp_fp_labels[i] = True\n                    is_gt_tuple_detected[gt_id] = True\n    return tp_fp_labels",
        "mutated": [
            "def _compute_tp_fp_for_single_class(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n    'Labels boxes detected with the same class from the same image as tp/fp.\\n\\n    Detection boxes are expected to be already sorted by score.\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      tp_fp_labels: a boolean numpy array indicating whether a detection is a\\n          true positive.\\n    '\n    if detected_box_tuples.size == 0:\n        return np.array([], dtype=bool)\n    min_iou = self._get_overlaps_and_scores_relation_tuples(detected_box_tuples, groundtruth_box_tuples)\n    num_detected_tuples = detected_box_tuples.shape[0]\n    tp_fp_labels = np.zeros(num_detected_tuples, dtype=bool)\n    if min_iou.shape[1] > 0:\n        max_overlap_gt_ids = np.argmax(min_iou, axis=1)\n        is_gt_tuple_detected = np.zeros(min_iou.shape[1], dtype=bool)\n        for i in range(num_detected_tuples):\n            gt_id = max_overlap_gt_ids[i]\n            if min_iou[i, gt_id] >= self.matching_iou_threshold:\n                if not is_gt_tuple_detected[gt_id]:\n                    tp_fp_labels[i] = True\n                    is_gt_tuple_detected[gt_id] = True\n    return tp_fp_labels",
            "def _compute_tp_fp_for_single_class(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Labels boxes detected with the same class from the same image as tp/fp.\\n\\n    Detection boxes are expected to be already sorted by score.\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      tp_fp_labels: a boolean numpy array indicating whether a detection is a\\n          true positive.\\n    '\n    if detected_box_tuples.size == 0:\n        return np.array([], dtype=bool)\n    min_iou = self._get_overlaps_and_scores_relation_tuples(detected_box_tuples, groundtruth_box_tuples)\n    num_detected_tuples = detected_box_tuples.shape[0]\n    tp_fp_labels = np.zeros(num_detected_tuples, dtype=bool)\n    if min_iou.shape[1] > 0:\n        max_overlap_gt_ids = np.argmax(min_iou, axis=1)\n        is_gt_tuple_detected = np.zeros(min_iou.shape[1], dtype=bool)\n        for i in range(num_detected_tuples):\n            gt_id = max_overlap_gt_ids[i]\n            if min_iou[i, gt_id] >= self.matching_iou_threshold:\n                if not is_gt_tuple_detected[gt_id]:\n                    tp_fp_labels[i] = True\n                    is_gt_tuple_detected[gt_id] = True\n    return tp_fp_labels",
            "def _compute_tp_fp_for_single_class(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Labels boxes detected with the same class from the same image as tp/fp.\\n\\n    Detection boxes are expected to be already sorted by score.\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      tp_fp_labels: a boolean numpy array indicating whether a detection is a\\n          true positive.\\n    '\n    if detected_box_tuples.size == 0:\n        return np.array([], dtype=bool)\n    min_iou = self._get_overlaps_and_scores_relation_tuples(detected_box_tuples, groundtruth_box_tuples)\n    num_detected_tuples = detected_box_tuples.shape[0]\n    tp_fp_labels = np.zeros(num_detected_tuples, dtype=bool)\n    if min_iou.shape[1] > 0:\n        max_overlap_gt_ids = np.argmax(min_iou, axis=1)\n        is_gt_tuple_detected = np.zeros(min_iou.shape[1], dtype=bool)\n        for i in range(num_detected_tuples):\n            gt_id = max_overlap_gt_ids[i]\n            if min_iou[i, gt_id] >= self.matching_iou_threshold:\n                if not is_gt_tuple_detected[gt_id]:\n                    tp_fp_labels[i] = True\n                    is_gt_tuple_detected[gt_id] = True\n    return tp_fp_labels",
            "def _compute_tp_fp_for_single_class(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Labels boxes detected with the same class from the same image as tp/fp.\\n\\n    Detection boxes are expected to be already sorted by score.\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      tp_fp_labels: a boolean numpy array indicating whether a detection is a\\n          true positive.\\n    '\n    if detected_box_tuples.size == 0:\n        return np.array([], dtype=bool)\n    min_iou = self._get_overlaps_and_scores_relation_tuples(detected_box_tuples, groundtruth_box_tuples)\n    num_detected_tuples = detected_box_tuples.shape[0]\n    tp_fp_labels = np.zeros(num_detected_tuples, dtype=bool)\n    if min_iou.shape[1] > 0:\n        max_overlap_gt_ids = np.argmax(min_iou, axis=1)\n        is_gt_tuple_detected = np.zeros(min_iou.shape[1], dtype=bool)\n        for i in range(num_detected_tuples):\n            gt_id = max_overlap_gt_ids[i]\n            if min_iou[i, gt_id] >= self.matching_iou_threshold:\n                if not is_gt_tuple_detected[gt_id]:\n                    tp_fp_labels[i] = True\n                    is_gt_tuple_detected[gt_id] = True\n    return tp_fp_labels",
            "def _compute_tp_fp_for_single_class(self, detected_box_tuples, groundtruth_box_tuples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Labels boxes detected with the same class from the same image as tp/fp.\\n\\n    Detection boxes are expected to be already sorted by score.\\n    Args:\\n      detected_box_tuples: A numpy array of structures with shape [N,],\\n          representing N tuples, each tuple containing the same number of named\\n          bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n      groundtruth_box_tuples: A float numpy array of structures with the shape\\n          [M,], representing M tuples, each tuple containing the same number\\n          of named bounding boxes.\\n          Each box is of the format [y_min, x_min, y_max, x_max]\\n\\n    Returns:\\n      tp_fp_labels: a boolean numpy array indicating whether a detection is a\\n          true positive.\\n    '\n    if detected_box_tuples.size == 0:\n        return np.array([], dtype=bool)\n    min_iou = self._get_overlaps_and_scores_relation_tuples(detected_box_tuples, groundtruth_box_tuples)\n    num_detected_tuples = detected_box_tuples.shape[0]\n    tp_fp_labels = np.zeros(num_detected_tuples, dtype=bool)\n    if min_iou.shape[1] > 0:\n        max_overlap_gt_ids = np.argmax(min_iou, axis=1)\n        is_gt_tuple_detected = np.zeros(min_iou.shape[1], dtype=bool)\n        for i in range(num_detected_tuples):\n            gt_id = max_overlap_gt_ids[i]\n            if min_iou[i, gt_id] >= self.matching_iou_threshold:\n                if not is_gt_tuple_detected[gt_id]:\n                    tp_fp_labels[i] = True\n                    is_gt_tuple_detected[gt_id] = True\n    return tp_fp_labels"
        ]
    }
]