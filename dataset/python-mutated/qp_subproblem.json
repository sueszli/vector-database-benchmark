[
    {
        "func_name": "eqp_kktfact",
        "original": "def eqp_kktfact(H, c, A, b):\n    \"\"\"Solve equality-constrained quadratic programming (EQP) problem.\n\n    Solve ``min 1/2 x.T H x + x.t c`` subject to ``A x + b = 0``\n    using direct factorization of the KKT system.\n\n    Parameters\n    ----------\n    H : sparse matrix, shape (n, n)\n        Hessian matrix of the EQP problem.\n    c : array_like, shape (n,)\n        Gradient of the quadratic objective function.\n    A : sparse matrix\n        Jacobian matrix of the EQP problem.\n    b : array_like, shape (m,)\n        Right-hand side of the constraint equation.\n\n    Returns\n    -------\n    x : array_like, shape (n,)\n        Solution of the KKT problem.\n    lagrange_multipliers : ndarray, shape (m,)\n        Lagrange multipliers of the KKT problem.\n    \"\"\"\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    kkt_matrix = csc_matrix(bmat([[H, A.T], [A, None]]))\n    kkt_vec = np.hstack([-c, -b])\n    lu = linalg.splu(kkt_matrix)\n    kkt_sol = lu.solve(kkt_vec)\n    x = kkt_sol[:n]\n    lagrange_multipliers = -kkt_sol[n:n + m]\n    return (x, lagrange_multipliers)",
        "mutated": [
            "def eqp_kktfact(H, c, A, b):\n    if False:\n        i = 10\n    'Solve equality-constrained quadratic programming (EQP) problem.\\n\\n    Solve ``min 1/2 x.T H x + x.t c`` subject to ``A x + b = 0``\\n    using direct factorization of the KKT system.\\n\\n    Parameters\\n    ----------\\n    H : sparse matrix, shape (n, n)\\n        Hessian matrix of the EQP problem.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    A : sparse matrix\\n        Jacobian matrix of the EQP problem.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the KKT problem.\\n    lagrange_multipliers : ndarray, shape (m,)\\n        Lagrange multipliers of the KKT problem.\\n    '\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    kkt_matrix = csc_matrix(bmat([[H, A.T], [A, None]]))\n    kkt_vec = np.hstack([-c, -b])\n    lu = linalg.splu(kkt_matrix)\n    kkt_sol = lu.solve(kkt_vec)\n    x = kkt_sol[:n]\n    lagrange_multipliers = -kkt_sol[n:n + m]\n    return (x, lagrange_multipliers)",
            "def eqp_kktfact(H, c, A, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Solve equality-constrained quadratic programming (EQP) problem.\\n\\n    Solve ``min 1/2 x.T H x + x.t c`` subject to ``A x + b = 0``\\n    using direct factorization of the KKT system.\\n\\n    Parameters\\n    ----------\\n    H : sparse matrix, shape (n, n)\\n        Hessian matrix of the EQP problem.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    A : sparse matrix\\n        Jacobian matrix of the EQP problem.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the KKT problem.\\n    lagrange_multipliers : ndarray, shape (m,)\\n        Lagrange multipliers of the KKT problem.\\n    '\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    kkt_matrix = csc_matrix(bmat([[H, A.T], [A, None]]))\n    kkt_vec = np.hstack([-c, -b])\n    lu = linalg.splu(kkt_matrix)\n    kkt_sol = lu.solve(kkt_vec)\n    x = kkt_sol[:n]\n    lagrange_multipliers = -kkt_sol[n:n + m]\n    return (x, lagrange_multipliers)",
            "def eqp_kktfact(H, c, A, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Solve equality-constrained quadratic programming (EQP) problem.\\n\\n    Solve ``min 1/2 x.T H x + x.t c`` subject to ``A x + b = 0``\\n    using direct factorization of the KKT system.\\n\\n    Parameters\\n    ----------\\n    H : sparse matrix, shape (n, n)\\n        Hessian matrix of the EQP problem.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    A : sparse matrix\\n        Jacobian matrix of the EQP problem.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the KKT problem.\\n    lagrange_multipliers : ndarray, shape (m,)\\n        Lagrange multipliers of the KKT problem.\\n    '\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    kkt_matrix = csc_matrix(bmat([[H, A.T], [A, None]]))\n    kkt_vec = np.hstack([-c, -b])\n    lu = linalg.splu(kkt_matrix)\n    kkt_sol = lu.solve(kkt_vec)\n    x = kkt_sol[:n]\n    lagrange_multipliers = -kkt_sol[n:n + m]\n    return (x, lagrange_multipliers)",
            "def eqp_kktfact(H, c, A, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Solve equality-constrained quadratic programming (EQP) problem.\\n\\n    Solve ``min 1/2 x.T H x + x.t c`` subject to ``A x + b = 0``\\n    using direct factorization of the KKT system.\\n\\n    Parameters\\n    ----------\\n    H : sparse matrix, shape (n, n)\\n        Hessian matrix of the EQP problem.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    A : sparse matrix\\n        Jacobian matrix of the EQP problem.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the KKT problem.\\n    lagrange_multipliers : ndarray, shape (m,)\\n        Lagrange multipliers of the KKT problem.\\n    '\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    kkt_matrix = csc_matrix(bmat([[H, A.T], [A, None]]))\n    kkt_vec = np.hstack([-c, -b])\n    lu = linalg.splu(kkt_matrix)\n    kkt_sol = lu.solve(kkt_vec)\n    x = kkt_sol[:n]\n    lagrange_multipliers = -kkt_sol[n:n + m]\n    return (x, lagrange_multipliers)",
            "def eqp_kktfact(H, c, A, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Solve equality-constrained quadratic programming (EQP) problem.\\n\\n    Solve ``min 1/2 x.T H x + x.t c`` subject to ``A x + b = 0``\\n    using direct factorization of the KKT system.\\n\\n    Parameters\\n    ----------\\n    H : sparse matrix, shape (n, n)\\n        Hessian matrix of the EQP problem.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    A : sparse matrix\\n        Jacobian matrix of the EQP problem.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the KKT problem.\\n    lagrange_multipliers : ndarray, shape (m,)\\n        Lagrange multipliers of the KKT problem.\\n    '\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    kkt_matrix = csc_matrix(bmat([[H, A.T], [A, None]]))\n    kkt_vec = np.hstack([-c, -b])\n    lu = linalg.splu(kkt_matrix)\n    kkt_sol = lu.solve(kkt_vec)\n    x = kkt_sol[:n]\n    lagrange_multipliers = -kkt_sol[n:n + m]\n    return (x, lagrange_multipliers)"
        ]
    },
    {
        "func_name": "sphere_intersections",
        "original": "def sphere_intersections(z, d, trust_radius, entire_line=False):\n    \"\"\"Find the intersection between segment (or line) and spherical constraints.\n\n    Find the intersection between the segment (or line) defined by the\n    parametric  equation ``x(t) = z + t*d`` and the ball\n    ``||x|| <= trust_radius``.\n\n    Parameters\n    ----------\n    z : array_like, shape (n,)\n        Initial point.\n    d : array_like, shape (n,)\n        Direction.\n    trust_radius : float\n        Ball radius.\n    entire_line : bool, optional\n        When ``True``, the function returns the intersection between the line\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the ball\n        ``||x|| <= trust_radius``. When ``False``, the function returns the intersection\n        between the segment ``x(t) = z + t*d``, ``0 <= t <= 1``, and the ball.\n\n    Returns\n    -------\n    ta, tb : float\n        The line/segment ``x(t) = z + t*d`` is inside the ball for\n        for ``ta <= t <= tb``.\n    intersect : bool\n        When ``True``, there is a intersection between the line/segment\n        and the sphere. On the other hand, when ``False``, there is no\n        intersection.\n    \"\"\"\n    if norm(d) == 0:\n        return (0, 0, False)\n    if np.isinf(trust_radius):\n        if entire_line:\n            ta = -np.inf\n            tb = np.inf\n        else:\n            ta = 0\n            tb = 1\n        intersect = True\n        return (ta, tb, intersect)\n    a = np.dot(d, d)\n    b = 2 * np.dot(z, d)\n    c = np.dot(z, z) - trust_radius ** 2\n    discriminant = b * b - 4 * a * c\n    if discriminant < 0:\n        intersect = False\n        return (0, 0, intersect)\n    sqrt_discriminant = np.sqrt(discriminant)\n    aux = b + copysign(sqrt_discriminant, b)\n    ta = -aux / (2 * a)\n    tb = -2 * c / aux\n    (ta, tb) = sorted([ta, tb])\n    if entire_line:\n        intersect = True\n    elif tb < 0 or ta > 1:\n        intersect = False\n        ta = 0\n        tb = 0\n    else:\n        intersect = True\n        ta = max(0, ta)\n        tb = min(1, tb)\n    return (ta, tb, intersect)",
        "mutated": [
            "def sphere_intersections(z, d, trust_radius, entire_line=False):\n    if False:\n        i = 10\n    'Find the intersection between segment (or line) and spherical constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the ball\\n    ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the ball\\n        ``||x|| <= trust_radius``. When ``False``, the function returns the intersection\\n        between the segment ``x(t) = z + t*d``, ``0 <= t <= 1``, and the ball.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the ball for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line/segment\\n        and the sphere. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    if norm(d) == 0:\n        return (0, 0, False)\n    if np.isinf(trust_radius):\n        if entire_line:\n            ta = -np.inf\n            tb = np.inf\n        else:\n            ta = 0\n            tb = 1\n        intersect = True\n        return (ta, tb, intersect)\n    a = np.dot(d, d)\n    b = 2 * np.dot(z, d)\n    c = np.dot(z, z) - trust_radius ** 2\n    discriminant = b * b - 4 * a * c\n    if discriminant < 0:\n        intersect = False\n        return (0, 0, intersect)\n    sqrt_discriminant = np.sqrt(discriminant)\n    aux = b + copysign(sqrt_discriminant, b)\n    ta = -aux / (2 * a)\n    tb = -2 * c / aux\n    (ta, tb) = sorted([ta, tb])\n    if entire_line:\n        intersect = True\n    elif tb < 0 or ta > 1:\n        intersect = False\n        ta = 0\n        tb = 0\n    else:\n        intersect = True\n        ta = max(0, ta)\n        tb = min(1, tb)\n    return (ta, tb, intersect)",
            "def sphere_intersections(z, d, trust_radius, entire_line=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find the intersection between segment (or line) and spherical constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the ball\\n    ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the ball\\n        ``||x|| <= trust_radius``. When ``False``, the function returns the intersection\\n        between the segment ``x(t) = z + t*d``, ``0 <= t <= 1``, and the ball.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the ball for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line/segment\\n        and the sphere. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    if norm(d) == 0:\n        return (0, 0, False)\n    if np.isinf(trust_radius):\n        if entire_line:\n            ta = -np.inf\n            tb = np.inf\n        else:\n            ta = 0\n            tb = 1\n        intersect = True\n        return (ta, tb, intersect)\n    a = np.dot(d, d)\n    b = 2 * np.dot(z, d)\n    c = np.dot(z, z) - trust_radius ** 2\n    discriminant = b * b - 4 * a * c\n    if discriminant < 0:\n        intersect = False\n        return (0, 0, intersect)\n    sqrt_discriminant = np.sqrt(discriminant)\n    aux = b + copysign(sqrt_discriminant, b)\n    ta = -aux / (2 * a)\n    tb = -2 * c / aux\n    (ta, tb) = sorted([ta, tb])\n    if entire_line:\n        intersect = True\n    elif tb < 0 or ta > 1:\n        intersect = False\n        ta = 0\n        tb = 0\n    else:\n        intersect = True\n        ta = max(0, ta)\n        tb = min(1, tb)\n    return (ta, tb, intersect)",
            "def sphere_intersections(z, d, trust_radius, entire_line=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find the intersection between segment (or line) and spherical constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the ball\\n    ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the ball\\n        ``||x|| <= trust_radius``. When ``False``, the function returns the intersection\\n        between the segment ``x(t) = z + t*d``, ``0 <= t <= 1``, and the ball.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the ball for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line/segment\\n        and the sphere. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    if norm(d) == 0:\n        return (0, 0, False)\n    if np.isinf(trust_radius):\n        if entire_line:\n            ta = -np.inf\n            tb = np.inf\n        else:\n            ta = 0\n            tb = 1\n        intersect = True\n        return (ta, tb, intersect)\n    a = np.dot(d, d)\n    b = 2 * np.dot(z, d)\n    c = np.dot(z, z) - trust_radius ** 2\n    discriminant = b * b - 4 * a * c\n    if discriminant < 0:\n        intersect = False\n        return (0, 0, intersect)\n    sqrt_discriminant = np.sqrt(discriminant)\n    aux = b + copysign(sqrt_discriminant, b)\n    ta = -aux / (2 * a)\n    tb = -2 * c / aux\n    (ta, tb) = sorted([ta, tb])\n    if entire_line:\n        intersect = True\n    elif tb < 0 or ta > 1:\n        intersect = False\n        ta = 0\n        tb = 0\n    else:\n        intersect = True\n        ta = max(0, ta)\n        tb = min(1, tb)\n    return (ta, tb, intersect)",
            "def sphere_intersections(z, d, trust_radius, entire_line=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find the intersection between segment (or line) and spherical constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the ball\\n    ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the ball\\n        ``||x|| <= trust_radius``. When ``False``, the function returns the intersection\\n        between the segment ``x(t) = z + t*d``, ``0 <= t <= 1``, and the ball.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the ball for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line/segment\\n        and the sphere. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    if norm(d) == 0:\n        return (0, 0, False)\n    if np.isinf(trust_radius):\n        if entire_line:\n            ta = -np.inf\n            tb = np.inf\n        else:\n            ta = 0\n            tb = 1\n        intersect = True\n        return (ta, tb, intersect)\n    a = np.dot(d, d)\n    b = 2 * np.dot(z, d)\n    c = np.dot(z, z) - trust_radius ** 2\n    discriminant = b * b - 4 * a * c\n    if discriminant < 0:\n        intersect = False\n        return (0, 0, intersect)\n    sqrt_discriminant = np.sqrt(discriminant)\n    aux = b + copysign(sqrt_discriminant, b)\n    ta = -aux / (2 * a)\n    tb = -2 * c / aux\n    (ta, tb) = sorted([ta, tb])\n    if entire_line:\n        intersect = True\n    elif tb < 0 or ta > 1:\n        intersect = False\n        ta = 0\n        tb = 0\n    else:\n        intersect = True\n        ta = max(0, ta)\n        tb = min(1, tb)\n    return (ta, tb, intersect)",
            "def sphere_intersections(z, d, trust_radius, entire_line=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find the intersection between segment (or line) and spherical constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the ball\\n    ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the ball\\n        ``||x|| <= trust_radius``. When ``False``, the function returns the intersection\\n        between the segment ``x(t) = z + t*d``, ``0 <= t <= 1``, and the ball.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the ball for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line/segment\\n        and the sphere. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    if norm(d) == 0:\n        return (0, 0, False)\n    if np.isinf(trust_radius):\n        if entire_line:\n            ta = -np.inf\n            tb = np.inf\n        else:\n            ta = 0\n            tb = 1\n        intersect = True\n        return (ta, tb, intersect)\n    a = np.dot(d, d)\n    b = 2 * np.dot(z, d)\n    c = np.dot(z, z) - trust_radius ** 2\n    discriminant = b * b - 4 * a * c\n    if discriminant < 0:\n        intersect = False\n        return (0, 0, intersect)\n    sqrt_discriminant = np.sqrt(discriminant)\n    aux = b + copysign(sqrt_discriminant, b)\n    ta = -aux / (2 * a)\n    tb = -2 * c / aux\n    (ta, tb) = sorted([ta, tb])\n    if entire_line:\n        intersect = True\n    elif tb < 0 or ta > 1:\n        intersect = False\n        ta = 0\n        tb = 0\n    else:\n        intersect = True\n        ta = max(0, ta)\n        tb = min(1, tb)\n    return (ta, tb, intersect)"
        ]
    },
    {
        "func_name": "box_intersections",
        "original": "def box_intersections(z, d, lb, ub, entire_line=False):\n    \"\"\"Find the intersection between segment (or line) and box constraints.\n\n    Find the intersection between the segment (or line) defined by the\n    parametric  equation ``x(t) = z + t*d`` and the rectangular box\n    ``lb <= x <= ub``.\n\n    Parameters\n    ----------\n    z : array_like, shape (n,)\n        Initial point.\n    d : array_like, shape (n,)\n        Direction.\n    lb : array_like, shape (n,)\n        Lower bounds to each one of the components of ``x``. Used\n        to delimit the rectangular box.\n    ub : array_like, shape (n, )\n        Upper bounds to each one of the components of ``x``. Used\n        to delimit the rectangular box.\n    entire_line : bool, optional\n        When ``True``, the function returns the intersection between the line\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the rectangular\n        box. When ``False``, the function returns the intersection between the segment\n        ``x(t) = z + t*d``, ``0 <= t <= 1``, and the rectangular box.\n\n    Returns\n    -------\n    ta, tb : float\n        The line/segment ``x(t) = z + t*d`` is inside the box for\n        for ``ta <= t <= tb``.\n    intersect : bool\n        When ``True``, there is a intersection between the line (or segment)\n        and the rectangular box. On the other hand, when ``False``, there is no\n        intersection.\n    \"\"\"\n    z = np.asarray(z)\n    d = np.asarray(d)\n    lb = np.asarray(lb)\n    ub = np.asarray(ub)\n    if norm(d) == 0:\n        return (0, 0, False)\n    zero_d = d == 0\n    if (z[zero_d] < lb[zero_d]).any() or (z[zero_d] > ub[zero_d]).any():\n        intersect = False\n        return (0, 0, intersect)\n    not_zero_d = np.logical_not(zero_d)\n    z = z[not_zero_d]\n    d = d[not_zero_d]\n    lb = lb[not_zero_d]\n    ub = ub[not_zero_d]\n    t_lb = (lb - z) / d\n    t_ub = (ub - z) / d\n    ta = max(np.minimum(t_lb, t_ub))\n    tb = min(np.maximum(t_lb, t_ub))\n    if ta <= tb:\n        intersect = True\n    else:\n        intersect = False\n    if not entire_line:\n        if tb < 0 or ta > 1:\n            intersect = False\n            ta = 0\n            tb = 0\n        else:\n            ta = max(0, ta)\n            tb = min(1, tb)\n    return (ta, tb, intersect)",
        "mutated": [
            "def box_intersections(z, d, lb, ub, entire_line=False):\n    if False:\n        i = 10\n    'Find the intersection between segment (or line) and box constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the rectangular box\\n    ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the rectangular\\n        box. When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1``, and the rectangular box.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the box for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and the rectangular box. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    z = np.asarray(z)\n    d = np.asarray(d)\n    lb = np.asarray(lb)\n    ub = np.asarray(ub)\n    if norm(d) == 0:\n        return (0, 0, False)\n    zero_d = d == 0\n    if (z[zero_d] < lb[zero_d]).any() or (z[zero_d] > ub[zero_d]).any():\n        intersect = False\n        return (0, 0, intersect)\n    not_zero_d = np.logical_not(zero_d)\n    z = z[not_zero_d]\n    d = d[not_zero_d]\n    lb = lb[not_zero_d]\n    ub = ub[not_zero_d]\n    t_lb = (lb - z) / d\n    t_ub = (ub - z) / d\n    ta = max(np.minimum(t_lb, t_ub))\n    tb = min(np.maximum(t_lb, t_ub))\n    if ta <= tb:\n        intersect = True\n    else:\n        intersect = False\n    if not entire_line:\n        if tb < 0 or ta > 1:\n            intersect = False\n            ta = 0\n            tb = 0\n        else:\n            ta = max(0, ta)\n            tb = min(1, tb)\n    return (ta, tb, intersect)",
            "def box_intersections(z, d, lb, ub, entire_line=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find the intersection between segment (or line) and box constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the rectangular box\\n    ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the rectangular\\n        box. When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1``, and the rectangular box.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the box for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and the rectangular box. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    z = np.asarray(z)\n    d = np.asarray(d)\n    lb = np.asarray(lb)\n    ub = np.asarray(ub)\n    if norm(d) == 0:\n        return (0, 0, False)\n    zero_d = d == 0\n    if (z[zero_d] < lb[zero_d]).any() or (z[zero_d] > ub[zero_d]).any():\n        intersect = False\n        return (0, 0, intersect)\n    not_zero_d = np.logical_not(zero_d)\n    z = z[not_zero_d]\n    d = d[not_zero_d]\n    lb = lb[not_zero_d]\n    ub = ub[not_zero_d]\n    t_lb = (lb - z) / d\n    t_ub = (ub - z) / d\n    ta = max(np.minimum(t_lb, t_ub))\n    tb = min(np.maximum(t_lb, t_ub))\n    if ta <= tb:\n        intersect = True\n    else:\n        intersect = False\n    if not entire_line:\n        if tb < 0 or ta > 1:\n            intersect = False\n            ta = 0\n            tb = 0\n        else:\n            ta = max(0, ta)\n            tb = min(1, tb)\n    return (ta, tb, intersect)",
            "def box_intersections(z, d, lb, ub, entire_line=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find the intersection between segment (or line) and box constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the rectangular box\\n    ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the rectangular\\n        box. When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1``, and the rectangular box.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the box for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and the rectangular box. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    z = np.asarray(z)\n    d = np.asarray(d)\n    lb = np.asarray(lb)\n    ub = np.asarray(ub)\n    if norm(d) == 0:\n        return (0, 0, False)\n    zero_d = d == 0\n    if (z[zero_d] < lb[zero_d]).any() or (z[zero_d] > ub[zero_d]).any():\n        intersect = False\n        return (0, 0, intersect)\n    not_zero_d = np.logical_not(zero_d)\n    z = z[not_zero_d]\n    d = d[not_zero_d]\n    lb = lb[not_zero_d]\n    ub = ub[not_zero_d]\n    t_lb = (lb - z) / d\n    t_ub = (ub - z) / d\n    ta = max(np.minimum(t_lb, t_ub))\n    tb = min(np.maximum(t_lb, t_ub))\n    if ta <= tb:\n        intersect = True\n    else:\n        intersect = False\n    if not entire_line:\n        if tb < 0 or ta > 1:\n            intersect = False\n            ta = 0\n            tb = 0\n        else:\n            ta = max(0, ta)\n            tb = min(1, tb)\n    return (ta, tb, intersect)",
            "def box_intersections(z, d, lb, ub, entire_line=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find the intersection between segment (or line) and box constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the rectangular box\\n    ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the rectangular\\n        box. When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1``, and the rectangular box.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the box for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and the rectangular box. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    z = np.asarray(z)\n    d = np.asarray(d)\n    lb = np.asarray(lb)\n    ub = np.asarray(ub)\n    if norm(d) == 0:\n        return (0, 0, False)\n    zero_d = d == 0\n    if (z[zero_d] < lb[zero_d]).any() or (z[zero_d] > ub[zero_d]).any():\n        intersect = False\n        return (0, 0, intersect)\n    not_zero_d = np.logical_not(zero_d)\n    z = z[not_zero_d]\n    d = d[not_zero_d]\n    lb = lb[not_zero_d]\n    ub = ub[not_zero_d]\n    t_lb = (lb - z) / d\n    t_ub = (ub - z) / d\n    ta = max(np.minimum(t_lb, t_ub))\n    tb = min(np.maximum(t_lb, t_ub))\n    if ta <= tb:\n        intersect = True\n    else:\n        intersect = False\n    if not entire_line:\n        if tb < 0 or ta > 1:\n            intersect = False\n            ta = 0\n            tb = 0\n        else:\n            ta = max(0, ta)\n            tb = min(1, tb)\n    return (ta, tb, intersect)",
            "def box_intersections(z, d, lb, ub, entire_line=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find the intersection between segment (or line) and box constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d`` and the rectangular box\\n    ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the rectangular\\n        box. When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1``, and the rectangular box.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the box for\\n        for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and the rectangular box. On the other hand, when ``False``, there is no\\n        intersection.\\n    '\n    z = np.asarray(z)\n    d = np.asarray(d)\n    lb = np.asarray(lb)\n    ub = np.asarray(ub)\n    if norm(d) == 0:\n        return (0, 0, False)\n    zero_d = d == 0\n    if (z[zero_d] < lb[zero_d]).any() or (z[zero_d] > ub[zero_d]).any():\n        intersect = False\n        return (0, 0, intersect)\n    not_zero_d = np.logical_not(zero_d)\n    z = z[not_zero_d]\n    d = d[not_zero_d]\n    lb = lb[not_zero_d]\n    ub = ub[not_zero_d]\n    t_lb = (lb - z) / d\n    t_ub = (ub - z) / d\n    ta = max(np.minimum(t_lb, t_ub))\n    tb = min(np.maximum(t_lb, t_ub))\n    if ta <= tb:\n        intersect = True\n    else:\n        intersect = False\n    if not entire_line:\n        if tb < 0 or ta > 1:\n            intersect = False\n            ta = 0\n            tb = 0\n        else:\n            ta = max(0, ta)\n            tb = min(1, tb)\n    return (ta, tb, intersect)"
        ]
    },
    {
        "func_name": "box_sphere_intersections",
        "original": "def box_sphere_intersections(z, d, lb, ub, trust_radius, entire_line=False, extra_info=False):\n    \"\"\"Find the intersection between segment (or line) and box/sphere constraints.\n\n    Find the intersection between the segment (or line) defined by the\n    parametric  equation ``x(t) = z + t*d``, the rectangular box\n    ``lb <= x <= ub`` and the ball ``||x|| <= trust_radius``.\n\n    Parameters\n    ----------\n    z : array_like, shape (n,)\n        Initial point.\n    d : array_like, shape (n,)\n        Direction.\n    lb : array_like, shape (n,)\n        Lower bounds to each one of the components of ``x``. Used\n        to delimit the rectangular box.\n    ub : array_like, shape (n, )\n        Upper bounds to each one of the components of ``x``. Used\n        to delimit the rectangular box.\n    trust_radius : float\n        Ball radius.\n    entire_line : bool, optional\n        When ``True``, the function returns the intersection between the line\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the constraints.\n        When ``False``, the function returns the intersection between the segment\n        ``x(t) = z + t*d``, ``0 <= t <= 1`` and the constraints.\n    extra_info : bool, optional\n        When ``True``, the function returns ``intersect_sphere`` and ``intersect_box``.\n\n    Returns\n    -------\n    ta, tb : float\n        The line/segment ``x(t) = z + t*d`` is inside the rectangular box and\n        inside the ball for ``ta <= t <= tb``.\n    intersect : bool\n        When ``True``, there is a intersection between the line (or segment)\n        and both constraints. On the other hand, when ``False``, there is no\n        intersection.\n    sphere_info : dict, optional\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\n        for which the line intercepts the ball. And a boolean value indicating\n        whether the sphere is intersected by the line.\n    box_info : dict, optional\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\n        for which the line intercepts the box. And a boolean value indicating\n        whether the box is intersected by the line.\n    \"\"\"\n    (ta_b, tb_b, intersect_b) = box_intersections(z, d, lb, ub, entire_line)\n    (ta_s, tb_s, intersect_s) = sphere_intersections(z, d, trust_radius, entire_line)\n    ta = np.maximum(ta_b, ta_s)\n    tb = np.minimum(tb_b, tb_s)\n    if intersect_b and intersect_s and (ta <= tb):\n        intersect = True\n    else:\n        intersect = False\n    if extra_info:\n        sphere_info = {'ta': ta_s, 'tb': tb_s, 'intersect': intersect_s}\n        box_info = {'ta': ta_b, 'tb': tb_b, 'intersect': intersect_b}\n        return (ta, tb, intersect, sphere_info, box_info)\n    else:\n        return (ta, tb, intersect)",
        "mutated": [
            "def box_sphere_intersections(z, d, lb, ub, trust_radius, entire_line=False, extra_info=False):\n    if False:\n        i = 10\n    'Find the intersection between segment (or line) and box/sphere constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d``, the rectangular box\\n    ``lb <= x <= ub`` and the ball ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the constraints.\\n        When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1`` and the constraints.\\n    extra_info : bool, optional\\n        When ``True``, the function returns ``intersect_sphere`` and ``intersect_box``.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the rectangular box and\\n        inside the ball for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and both constraints. On the other hand, when ``False``, there is no\\n        intersection.\\n    sphere_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the ball. And a boolean value indicating\\n        whether the sphere is intersected by the line.\\n    box_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the box. And a boolean value indicating\\n        whether the box is intersected by the line.\\n    '\n    (ta_b, tb_b, intersect_b) = box_intersections(z, d, lb, ub, entire_line)\n    (ta_s, tb_s, intersect_s) = sphere_intersections(z, d, trust_radius, entire_line)\n    ta = np.maximum(ta_b, ta_s)\n    tb = np.minimum(tb_b, tb_s)\n    if intersect_b and intersect_s and (ta <= tb):\n        intersect = True\n    else:\n        intersect = False\n    if extra_info:\n        sphere_info = {'ta': ta_s, 'tb': tb_s, 'intersect': intersect_s}\n        box_info = {'ta': ta_b, 'tb': tb_b, 'intersect': intersect_b}\n        return (ta, tb, intersect, sphere_info, box_info)\n    else:\n        return (ta, tb, intersect)",
            "def box_sphere_intersections(z, d, lb, ub, trust_radius, entire_line=False, extra_info=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find the intersection between segment (or line) and box/sphere constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d``, the rectangular box\\n    ``lb <= x <= ub`` and the ball ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the constraints.\\n        When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1`` and the constraints.\\n    extra_info : bool, optional\\n        When ``True``, the function returns ``intersect_sphere`` and ``intersect_box``.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the rectangular box and\\n        inside the ball for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and both constraints. On the other hand, when ``False``, there is no\\n        intersection.\\n    sphere_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the ball. And a boolean value indicating\\n        whether the sphere is intersected by the line.\\n    box_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the box. And a boolean value indicating\\n        whether the box is intersected by the line.\\n    '\n    (ta_b, tb_b, intersect_b) = box_intersections(z, d, lb, ub, entire_line)\n    (ta_s, tb_s, intersect_s) = sphere_intersections(z, d, trust_radius, entire_line)\n    ta = np.maximum(ta_b, ta_s)\n    tb = np.minimum(tb_b, tb_s)\n    if intersect_b and intersect_s and (ta <= tb):\n        intersect = True\n    else:\n        intersect = False\n    if extra_info:\n        sphere_info = {'ta': ta_s, 'tb': tb_s, 'intersect': intersect_s}\n        box_info = {'ta': ta_b, 'tb': tb_b, 'intersect': intersect_b}\n        return (ta, tb, intersect, sphere_info, box_info)\n    else:\n        return (ta, tb, intersect)",
            "def box_sphere_intersections(z, d, lb, ub, trust_radius, entire_line=False, extra_info=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find the intersection between segment (or line) and box/sphere constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d``, the rectangular box\\n    ``lb <= x <= ub`` and the ball ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the constraints.\\n        When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1`` and the constraints.\\n    extra_info : bool, optional\\n        When ``True``, the function returns ``intersect_sphere`` and ``intersect_box``.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the rectangular box and\\n        inside the ball for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and both constraints. On the other hand, when ``False``, there is no\\n        intersection.\\n    sphere_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the ball. And a boolean value indicating\\n        whether the sphere is intersected by the line.\\n    box_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the box. And a boolean value indicating\\n        whether the box is intersected by the line.\\n    '\n    (ta_b, tb_b, intersect_b) = box_intersections(z, d, lb, ub, entire_line)\n    (ta_s, tb_s, intersect_s) = sphere_intersections(z, d, trust_radius, entire_line)\n    ta = np.maximum(ta_b, ta_s)\n    tb = np.minimum(tb_b, tb_s)\n    if intersect_b and intersect_s and (ta <= tb):\n        intersect = True\n    else:\n        intersect = False\n    if extra_info:\n        sphere_info = {'ta': ta_s, 'tb': tb_s, 'intersect': intersect_s}\n        box_info = {'ta': ta_b, 'tb': tb_b, 'intersect': intersect_b}\n        return (ta, tb, intersect, sphere_info, box_info)\n    else:\n        return (ta, tb, intersect)",
            "def box_sphere_intersections(z, d, lb, ub, trust_radius, entire_line=False, extra_info=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find the intersection between segment (or line) and box/sphere constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d``, the rectangular box\\n    ``lb <= x <= ub`` and the ball ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the constraints.\\n        When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1`` and the constraints.\\n    extra_info : bool, optional\\n        When ``True``, the function returns ``intersect_sphere`` and ``intersect_box``.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the rectangular box and\\n        inside the ball for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and both constraints. On the other hand, when ``False``, there is no\\n        intersection.\\n    sphere_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the ball. And a boolean value indicating\\n        whether the sphere is intersected by the line.\\n    box_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the box. And a boolean value indicating\\n        whether the box is intersected by the line.\\n    '\n    (ta_b, tb_b, intersect_b) = box_intersections(z, d, lb, ub, entire_line)\n    (ta_s, tb_s, intersect_s) = sphere_intersections(z, d, trust_radius, entire_line)\n    ta = np.maximum(ta_b, ta_s)\n    tb = np.minimum(tb_b, tb_s)\n    if intersect_b and intersect_s and (ta <= tb):\n        intersect = True\n    else:\n        intersect = False\n    if extra_info:\n        sphere_info = {'ta': ta_s, 'tb': tb_s, 'intersect': intersect_s}\n        box_info = {'ta': ta_b, 'tb': tb_b, 'intersect': intersect_b}\n        return (ta, tb, intersect, sphere_info, box_info)\n    else:\n        return (ta, tb, intersect)",
            "def box_sphere_intersections(z, d, lb, ub, trust_radius, entire_line=False, extra_info=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find the intersection between segment (or line) and box/sphere constraints.\\n\\n    Find the intersection between the segment (or line) defined by the\\n    parametric  equation ``x(t) = z + t*d``, the rectangular box\\n    ``lb <= x <= ub`` and the ball ``||x|| <= trust_radius``.\\n\\n    Parameters\\n    ----------\\n    z : array_like, shape (n,)\\n        Initial point.\\n    d : array_like, shape (n,)\\n        Direction.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``. Used\\n        to delimit the rectangular box.\\n    trust_radius : float\\n        Ball radius.\\n    entire_line : bool, optional\\n        When ``True``, the function returns the intersection between the line\\n        ``x(t) = z + t*d`` (``t`` can assume any value) and the constraints.\\n        When ``False``, the function returns the intersection between the segment\\n        ``x(t) = z + t*d``, ``0 <= t <= 1`` and the constraints.\\n    extra_info : bool, optional\\n        When ``True``, the function returns ``intersect_sphere`` and ``intersect_box``.\\n\\n    Returns\\n    -------\\n    ta, tb : float\\n        The line/segment ``x(t) = z + t*d`` is inside the rectangular box and\\n        inside the ball for ``ta <= t <= tb``.\\n    intersect : bool\\n        When ``True``, there is a intersection between the line (or segment)\\n        and both constraints. On the other hand, when ``False``, there is no\\n        intersection.\\n    sphere_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the ball. And a boolean value indicating\\n        whether the sphere is intersected by the line.\\n    box_info : dict, optional\\n        Dictionary ``{ta, tb, intersect}`` containing the interval ``[ta, tb]``\\n        for which the line intercepts the box. And a boolean value indicating\\n        whether the box is intersected by the line.\\n    '\n    (ta_b, tb_b, intersect_b) = box_intersections(z, d, lb, ub, entire_line)\n    (ta_s, tb_s, intersect_s) = sphere_intersections(z, d, trust_radius, entire_line)\n    ta = np.maximum(ta_b, ta_s)\n    tb = np.minimum(tb_b, tb_s)\n    if intersect_b and intersect_s and (ta <= tb):\n        intersect = True\n    else:\n        intersect = False\n    if extra_info:\n        sphere_info = {'ta': ta_s, 'tb': tb_s, 'intersect': intersect_s}\n        box_info = {'ta': ta_b, 'tb': tb_b, 'intersect': intersect_b}\n        return (ta, tb, intersect, sphere_info, box_info)\n    else:\n        return (ta, tb, intersect)"
        ]
    },
    {
        "func_name": "inside_box_boundaries",
        "original": "def inside_box_boundaries(x, lb, ub):\n    \"\"\"Check if lb <= x <= ub.\"\"\"\n    return (lb <= x).all() and (x <= ub).all()",
        "mutated": [
            "def inside_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n    'Check if lb <= x <= ub.'\n    return (lb <= x).all() and (x <= ub).all()",
            "def inside_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Check if lb <= x <= ub.'\n    return (lb <= x).all() and (x <= ub).all()",
            "def inside_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Check if lb <= x <= ub.'\n    return (lb <= x).all() and (x <= ub).all()",
            "def inside_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Check if lb <= x <= ub.'\n    return (lb <= x).all() and (x <= ub).all()",
            "def inside_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Check if lb <= x <= ub.'\n    return (lb <= x).all() and (x <= ub).all()"
        ]
    },
    {
        "func_name": "reinforce_box_boundaries",
        "original": "def reinforce_box_boundaries(x, lb, ub):\n    \"\"\"Return clipped value of x\"\"\"\n    return np.minimum(np.maximum(x, lb), ub)",
        "mutated": [
            "def reinforce_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n    'Return clipped value of x'\n    return np.minimum(np.maximum(x, lb), ub)",
            "def reinforce_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return clipped value of x'\n    return np.minimum(np.maximum(x, lb), ub)",
            "def reinforce_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return clipped value of x'\n    return np.minimum(np.maximum(x, lb), ub)",
            "def reinforce_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return clipped value of x'\n    return np.minimum(np.maximum(x, lb), ub)",
            "def reinforce_box_boundaries(x, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return clipped value of x'\n    return np.minimum(np.maximum(x, lb), ub)"
        ]
    },
    {
        "func_name": "modified_dogleg",
        "original": "def modified_dogleg(A, Y, b, trust_radius, lb, ub):\n    \"\"\"Approximately  minimize ``1/2*|| A x + b ||^2`` inside trust-region.\n\n    Approximately solve the problem of minimizing ``1/2*|| A x + b ||^2``\n    subject to ``||x|| < Delta`` and ``lb <= x <= ub`` using a modification\n    of the classical dogleg approach.\n\n    Parameters\n    ----------\n    A : LinearOperator (or sparse matrix or ndarray), shape (m, n)\n        Matrix ``A`` in the minimization problem. It should have\n        dimension ``(m, n)`` such that ``m < n``.\n    Y : LinearOperator (or sparse matrix or ndarray), shape (n, m)\n        LinearOperator that apply the projection matrix\n        ``Q = A.T inv(A A.T)`` to the vector. The obtained vector\n        ``y = Q x`` being the minimum norm solution of ``A y = x``.\n    b : array_like, shape (m,)\n        Vector ``b``in the minimization problem.\n    trust_radius: float\n        Trust radius to be considered. Delimits a sphere boundary\n        to the problem.\n    lb : array_like, shape (n,)\n        Lower bounds to each one of the components of ``x``.\n        It is expected that ``lb <= 0``, otherwise the algorithm\n        may fail. If ``lb[i] = -Inf``, the lower\n        bound for the ith component is just ignored.\n    ub : array_like, shape (n, )\n        Upper bounds to each one of the components of ``x``.\n        It is expected that ``ub >= 0``, otherwise the algorithm\n        may fail. If ``ub[i] = Inf``, the upper bound for the ith\n        component is just ignored.\n\n    Returns\n    -------\n    x : array_like, shape (n,)\n        Solution to the problem.\n\n    Notes\n    -----\n    Based on implementations described in pp. 885-886 from [1]_.\n\n    References\n    ----------\n    .. [1] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal.\n           \"An interior point algorithm for large-scale nonlinear\n           programming.\" SIAM Journal on Optimization 9.4 (1999): 877-900.\n    \"\"\"\n    newton_point = -Y.dot(b)\n    if inside_box_boundaries(newton_point, lb, ub) and norm(newton_point) <= trust_radius:\n        x = newton_point\n        return x\n    g = A.T.dot(b)\n    A_g = A.dot(g)\n    cauchy_point = -np.dot(g, g) / np.dot(A_g, A_g) * g\n    origin_point = np.zeros_like(cauchy_point)\n    z = cauchy_point\n    p = newton_point - cauchy_point\n    (_, alpha, intersect) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    if intersect:\n        x1 = z + alpha * p\n    else:\n        z = origin_point\n        p = cauchy_point\n        (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n        x1 = z + alpha * p\n    z = origin_point\n    p = newton_point\n    (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    x2 = z + alpha * p\n    if norm(A.dot(x1) + b) < norm(A.dot(x2) + b):\n        return x1\n    else:\n        return x2",
        "mutated": [
            "def modified_dogleg(A, Y, b, trust_radius, lb, ub):\n    if False:\n        i = 10\n    'Approximately  minimize ``1/2*|| A x + b ||^2`` inside trust-region.\\n\\n    Approximately solve the problem of minimizing ``1/2*|| A x + b ||^2``\\n    subject to ``||x|| < Delta`` and ``lb <= x <= ub`` using a modification\\n    of the classical dogleg approach.\\n\\n    Parameters\\n    ----------\\n    A : LinearOperator (or sparse matrix or ndarray), shape (m, n)\\n        Matrix ``A`` in the minimization problem. It should have\\n        dimension ``(m, n)`` such that ``m < n``.\\n    Y : LinearOperator (or sparse matrix or ndarray), shape (n, m)\\n        LinearOperator that apply the projection matrix\\n        ``Q = A.T inv(A A.T)`` to the vector. The obtained vector\\n        ``y = Q x`` being the minimum norm solution of ``A y = x``.\\n    b : array_like, shape (m,)\\n        Vector ``b``in the minimization problem.\\n    trust_radius: float\\n        Trust radius to be considered. Delimits a sphere boundary\\n        to the problem.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``.\\n        It is expected that ``lb <= 0``, otherwise the algorithm\\n        may fail. If ``lb[i] = -Inf``, the lower\\n        bound for the ith component is just ignored.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``.\\n        It is expected that ``ub >= 0``, otherwise the algorithm\\n        may fail. If ``ub[i] = Inf``, the upper bound for the ith\\n        component is just ignored.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution to the problem.\\n\\n    Notes\\n    -----\\n    Based on implementations described in pp. 885-886 from [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal.\\n           \"An interior point algorithm for large-scale nonlinear\\n           programming.\" SIAM Journal on Optimization 9.4 (1999): 877-900.\\n    '\n    newton_point = -Y.dot(b)\n    if inside_box_boundaries(newton_point, lb, ub) and norm(newton_point) <= trust_radius:\n        x = newton_point\n        return x\n    g = A.T.dot(b)\n    A_g = A.dot(g)\n    cauchy_point = -np.dot(g, g) / np.dot(A_g, A_g) * g\n    origin_point = np.zeros_like(cauchy_point)\n    z = cauchy_point\n    p = newton_point - cauchy_point\n    (_, alpha, intersect) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    if intersect:\n        x1 = z + alpha * p\n    else:\n        z = origin_point\n        p = cauchy_point\n        (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n        x1 = z + alpha * p\n    z = origin_point\n    p = newton_point\n    (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    x2 = z + alpha * p\n    if norm(A.dot(x1) + b) < norm(A.dot(x2) + b):\n        return x1\n    else:\n        return x2",
            "def modified_dogleg(A, Y, b, trust_radius, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Approximately  minimize ``1/2*|| A x + b ||^2`` inside trust-region.\\n\\n    Approximately solve the problem of minimizing ``1/2*|| A x + b ||^2``\\n    subject to ``||x|| < Delta`` and ``lb <= x <= ub`` using a modification\\n    of the classical dogleg approach.\\n\\n    Parameters\\n    ----------\\n    A : LinearOperator (or sparse matrix or ndarray), shape (m, n)\\n        Matrix ``A`` in the minimization problem. It should have\\n        dimension ``(m, n)`` such that ``m < n``.\\n    Y : LinearOperator (or sparse matrix or ndarray), shape (n, m)\\n        LinearOperator that apply the projection matrix\\n        ``Q = A.T inv(A A.T)`` to the vector. The obtained vector\\n        ``y = Q x`` being the minimum norm solution of ``A y = x``.\\n    b : array_like, shape (m,)\\n        Vector ``b``in the minimization problem.\\n    trust_radius: float\\n        Trust radius to be considered. Delimits a sphere boundary\\n        to the problem.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``.\\n        It is expected that ``lb <= 0``, otherwise the algorithm\\n        may fail. If ``lb[i] = -Inf``, the lower\\n        bound for the ith component is just ignored.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``.\\n        It is expected that ``ub >= 0``, otherwise the algorithm\\n        may fail. If ``ub[i] = Inf``, the upper bound for the ith\\n        component is just ignored.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution to the problem.\\n\\n    Notes\\n    -----\\n    Based on implementations described in pp. 885-886 from [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal.\\n           \"An interior point algorithm for large-scale nonlinear\\n           programming.\" SIAM Journal on Optimization 9.4 (1999): 877-900.\\n    '\n    newton_point = -Y.dot(b)\n    if inside_box_boundaries(newton_point, lb, ub) and norm(newton_point) <= trust_radius:\n        x = newton_point\n        return x\n    g = A.T.dot(b)\n    A_g = A.dot(g)\n    cauchy_point = -np.dot(g, g) / np.dot(A_g, A_g) * g\n    origin_point = np.zeros_like(cauchy_point)\n    z = cauchy_point\n    p = newton_point - cauchy_point\n    (_, alpha, intersect) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    if intersect:\n        x1 = z + alpha * p\n    else:\n        z = origin_point\n        p = cauchy_point\n        (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n        x1 = z + alpha * p\n    z = origin_point\n    p = newton_point\n    (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    x2 = z + alpha * p\n    if norm(A.dot(x1) + b) < norm(A.dot(x2) + b):\n        return x1\n    else:\n        return x2",
            "def modified_dogleg(A, Y, b, trust_radius, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Approximately  minimize ``1/2*|| A x + b ||^2`` inside trust-region.\\n\\n    Approximately solve the problem of minimizing ``1/2*|| A x + b ||^2``\\n    subject to ``||x|| < Delta`` and ``lb <= x <= ub`` using a modification\\n    of the classical dogleg approach.\\n\\n    Parameters\\n    ----------\\n    A : LinearOperator (or sparse matrix or ndarray), shape (m, n)\\n        Matrix ``A`` in the minimization problem. It should have\\n        dimension ``(m, n)`` such that ``m < n``.\\n    Y : LinearOperator (or sparse matrix or ndarray), shape (n, m)\\n        LinearOperator that apply the projection matrix\\n        ``Q = A.T inv(A A.T)`` to the vector. The obtained vector\\n        ``y = Q x`` being the minimum norm solution of ``A y = x``.\\n    b : array_like, shape (m,)\\n        Vector ``b``in the minimization problem.\\n    trust_radius: float\\n        Trust radius to be considered. Delimits a sphere boundary\\n        to the problem.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``.\\n        It is expected that ``lb <= 0``, otherwise the algorithm\\n        may fail. If ``lb[i] = -Inf``, the lower\\n        bound for the ith component is just ignored.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``.\\n        It is expected that ``ub >= 0``, otherwise the algorithm\\n        may fail. If ``ub[i] = Inf``, the upper bound for the ith\\n        component is just ignored.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution to the problem.\\n\\n    Notes\\n    -----\\n    Based on implementations described in pp. 885-886 from [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal.\\n           \"An interior point algorithm for large-scale nonlinear\\n           programming.\" SIAM Journal on Optimization 9.4 (1999): 877-900.\\n    '\n    newton_point = -Y.dot(b)\n    if inside_box_boundaries(newton_point, lb, ub) and norm(newton_point) <= trust_radius:\n        x = newton_point\n        return x\n    g = A.T.dot(b)\n    A_g = A.dot(g)\n    cauchy_point = -np.dot(g, g) / np.dot(A_g, A_g) * g\n    origin_point = np.zeros_like(cauchy_point)\n    z = cauchy_point\n    p = newton_point - cauchy_point\n    (_, alpha, intersect) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    if intersect:\n        x1 = z + alpha * p\n    else:\n        z = origin_point\n        p = cauchy_point\n        (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n        x1 = z + alpha * p\n    z = origin_point\n    p = newton_point\n    (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    x2 = z + alpha * p\n    if norm(A.dot(x1) + b) < norm(A.dot(x2) + b):\n        return x1\n    else:\n        return x2",
            "def modified_dogleg(A, Y, b, trust_radius, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Approximately  minimize ``1/2*|| A x + b ||^2`` inside trust-region.\\n\\n    Approximately solve the problem of minimizing ``1/2*|| A x + b ||^2``\\n    subject to ``||x|| < Delta`` and ``lb <= x <= ub`` using a modification\\n    of the classical dogleg approach.\\n\\n    Parameters\\n    ----------\\n    A : LinearOperator (or sparse matrix or ndarray), shape (m, n)\\n        Matrix ``A`` in the minimization problem. It should have\\n        dimension ``(m, n)`` such that ``m < n``.\\n    Y : LinearOperator (or sparse matrix or ndarray), shape (n, m)\\n        LinearOperator that apply the projection matrix\\n        ``Q = A.T inv(A A.T)`` to the vector. The obtained vector\\n        ``y = Q x`` being the minimum norm solution of ``A y = x``.\\n    b : array_like, shape (m,)\\n        Vector ``b``in the minimization problem.\\n    trust_radius: float\\n        Trust radius to be considered. Delimits a sphere boundary\\n        to the problem.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``.\\n        It is expected that ``lb <= 0``, otherwise the algorithm\\n        may fail. If ``lb[i] = -Inf``, the lower\\n        bound for the ith component is just ignored.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``.\\n        It is expected that ``ub >= 0``, otherwise the algorithm\\n        may fail. If ``ub[i] = Inf``, the upper bound for the ith\\n        component is just ignored.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution to the problem.\\n\\n    Notes\\n    -----\\n    Based on implementations described in pp. 885-886 from [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal.\\n           \"An interior point algorithm for large-scale nonlinear\\n           programming.\" SIAM Journal on Optimization 9.4 (1999): 877-900.\\n    '\n    newton_point = -Y.dot(b)\n    if inside_box_boundaries(newton_point, lb, ub) and norm(newton_point) <= trust_radius:\n        x = newton_point\n        return x\n    g = A.T.dot(b)\n    A_g = A.dot(g)\n    cauchy_point = -np.dot(g, g) / np.dot(A_g, A_g) * g\n    origin_point = np.zeros_like(cauchy_point)\n    z = cauchy_point\n    p = newton_point - cauchy_point\n    (_, alpha, intersect) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    if intersect:\n        x1 = z + alpha * p\n    else:\n        z = origin_point\n        p = cauchy_point\n        (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n        x1 = z + alpha * p\n    z = origin_point\n    p = newton_point\n    (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    x2 = z + alpha * p\n    if norm(A.dot(x1) + b) < norm(A.dot(x2) + b):\n        return x1\n    else:\n        return x2",
            "def modified_dogleg(A, Y, b, trust_radius, lb, ub):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Approximately  minimize ``1/2*|| A x + b ||^2`` inside trust-region.\\n\\n    Approximately solve the problem of minimizing ``1/2*|| A x + b ||^2``\\n    subject to ``||x|| < Delta`` and ``lb <= x <= ub`` using a modification\\n    of the classical dogleg approach.\\n\\n    Parameters\\n    ----------\\n    A : LinearOperator (or sparse matrix or ndarray), shape (m, n)\\n        Matrix ``A`` in the minimization problem. It should have\\n        dimension ``(m, n)`` such that ``m < n``.\\n    Y : LinearOperator (or sparse matrix or ndarray), shape (n, m)\\n        LinearOperator that apply the projection matrix\\n        ``Q = A.T inv(A A.T)`` to the vector. The obtained vector\\n        ``y = Q x`` being the minimum norm solution of ``A y = x``.\\n    b : array_like, shape (m,)\\n        Vector ``b``in the minimization problem.\\n    trust_radius: float\\n        Trust radius to be considered. Delimits a sphere boundary\\n        to the problem.\\n    lb : array_like, shape (n,)\\n        Lower bounds to each one of the components of ``x``.\\n        It is expected that ``lb <= 0``, otherwise the algorithm\\n        may fail. If ``lb[i] = -Inf``, the lower\\n        bound for the ith component is just ignored.\\n    ub : array_like, shape (n, )\\n        Upper bounds to each one of the components of ``x``.\\n        It is expected that ``ub >= 0``, otherwise the algorithm\\n        may fail. If ``ub[i] = Inf``, the upper bound for the ith\\n        component is just ignored.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution to the problem.\\n\\n    Notes\\n    -----\\n    Based on implementations described in pp. 885-886 from [1]_.\\n\\n    References\\n    ----------\\n    .. [1] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal.\\n           \"An interior point algorithm for large-scale nonlinear\\n           programming.\" SIAM Journal on Optimization 9.4 (1999): 877-900.\\n    '\n    newton_point = -Y.dot(b)\n    if inside_box_boundaries(newton_point, lb, ub) and norm(newton_point) <= trust_radius:\n        x = newton_point\n        return x\n    g = A.T.dot(b)\n    A_g = A.dot(g)\n    cauchy_point = -np.dot(g, g) / np.dot(A_g, A_g) * g\n    origin_point = np.zeros_like(cauchy_point)\n    z = cauchy_point\n    p = newton_point - cauchy_point\n    (_, alpha, intersect) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    if intersect:\n        x1 = z + alpha * p\n    else:\n        z = origin_point\n        p = cauchy_point\n        (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n        x1 = z + alpha * p\n    z = origin_point\n    p = newton_point\n    (_, alpha, _) = box_sphere_intersections(z, p, lb, ub, trust_radius)\n    x2 = z + alpha * p\n    if norm(A.dot(x1) + b) < norm(A.dot(x2) + b):\n        return x1\n    else:\n        return x2"
        ]
    },
    {
        "func_name": "projected_cg",
        "original": "def projected_cg(H, c, Z, Y, b, trust_radius=np.inf, lb=None, ub=None, tol=None, max_iter=None, max_infeasible_iter=None, return_all=False):\n    \"\"\"Solve EQP problem with projected CG method.\n\n    Solve equality-constrained quadratic programming problem\n    ``min 1/2 x.T H x + x.t c``  subject to ``A x + b = 0`` and,\n    possibly, to trust region constraints ``||x|| < trust_radius``\n    and box constraints ``lb <= x <= ub``.\n\n    Parameters\n    ----------\n    H : LinearOperator (or sparse matrix or ndarray), shape (n, n)\n        Operator for computing ``H v``.\n    c : array_like, shape (n,)\n        Gradient of the quadratic objective function.\n    Z : LinearOperator (or sparse matrix or ndarray), shape (n, n)\n        Operator for projecting ``x`` into the null space of A.\n    Y : LinearOperator,  sparse matrix, ndarray, shape (n, m)\n        Operator that, for a given a vector ``b``, compute smallest\n        norm solution of ``A x + b = 0``.\n    b : array_like, shape (m,)\n        Right-hand side of the constraint equation.\n    trust_radius : float, optional\n        Trust radius to be considered. By default, uses ``trust_radius=inf``,\n        which means no trust radius at all.\n    lb : array_like, shape (n,), optional\n        Lower bounds to each one of the components of ``x``.\n        If ``lb[i] = -Inf`` the lower bound for the i-th\n        component is just ignored (default).\n    ub : array_like, shape (n, ), optional\n        Upper bounds to each one of the components of ``x``.\n        If ``ub[i] = Inf`` the upper bound for the i-th\n        component is just ignored (default).\n    tol : float, optional\n        Tolerance used to interrupt the algorithm.\n    max_iter : int, optional\n        Maximum algorithm iterations. Where ``max_inter <= n-m``.\n        By default, uses ``max_iter = n-m``.\n    max_infeasible_iter : int, optional\n        Maximum infeasible (regarding box constraints) iterations the\n        algorithm is allowed to take.\n        By default, uses ``max_infeasible_iter = n-m``.\n    return_all : bool, optional\n        When ``true``, return the list of all vectors through the iterations.\n\n    Returns\n    -------\n    x : array_like, shape (n,)\n        Solution of the EQP problem.\n    info : Dict\n        Dictionary containing the following:\n\n            - niter : Number of iterations.\n            - stop_cond : Reason for algorithm termination:\n                1. Iteration limit was reached;\n                2. Reached the trust-region boundary;\n                3. Negative curvature detected;\n                4. Tolerance was satisfied.\n            - allvecs : List containing all intermediary vectors (optional).\n            - hits_boundary : True if the proposed step is on the boundary\n              of the trust region.\n\n    Notes\n    -----\n    Implementation of Algorithm 6.2 on [1]_.\n\n    In the absence of spherical and box constraints, for sufficient\n    iterations, the method returns a truly optimal result.\n    In the presence of those constraints, the value returned is only\n    a inexpensive approximation of the optimal value.\n\n    References\n    ----------\n    .. [1] Gould, Nicholas IM, Mary E. Hribar, and Jorge Nocedal.\n           \"On the solution of equality constrained quadratic\n            programming problems arising in optimization.\"\n            SIAM Journal on Scientific Computing 23.4 (2001): 1376-1395.\n    \"\"\"\n    CLOSE_TO_ZERO = 1e-25\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    x = Y.dot(-b)\n    r = Z.dot(H.dot(x) + c)\n    g = Z.dot(r)\n    p = -g\n    if return_all:\n        allvecs = [x]\n    H_p = H.dot(p)\n    rt_g = norm(g) ** 2\n    tr_distance = trust_radius - norm(x)\n    if tr_distance < 0:\n        raise ValueError('Trust region problem does not have a solution.')\n    elif tr_distance < CLOSE_TO_ZERO:\n        info = {'niter': 0, 'stop_cond': 2, 'hits_boundary': True}\n        if return_all:\n            allvecs.append(x)\n            info['allvecs'] = allvecs\n        return (x, info)\n    if tol is None:\n        tol = max(min(0.01 * np.sqrt(rt_g), 0.1 * rt_g), CLOSE_TO_ZERO)\n    if lb is None:\n        lb = np.full(n, -np.inf)\n    if ub is None:\n        ub = np.full(n, np.inf)\n    if max_iter is None:\n        max_iter = n - m\n    max_iter = min(max_iter, n - m)\n    if max_infeasible_iter is None:\n        max_infeasible_iter = n - m\n    hits_boundary = False\n    stop_cond = 1\n    counter = 0\n    last_feasible_x = np.zeros_like(x)\n    k = 0\n    for i in range(max_iter):\n        if rt_g < tol:\n            stop_cond = 4\n            break\n        k += 1\n        pt_H_p = H_p.dot(p)\n        if pt_H_p <= 0:\n            if np.isinf(trust_radius):\n                raise ValueError('Negative curvature not allowed for unrestricted problems.')\n            else:\n                (_, alpha, intersect) = box_sphere_intersections(x, p, lb, ub, trust_radius, entire_line=True)\n                if intersect:\n                    x = x + alpha * p\n                x = reinforce_box_boundaries(x, lb, ub)\n                stop_cond = 3\n                hits_boundary = True\n                break\n        alpha = rt_g / pt_H_p\n        x_next = x + alpha * p\n        if np.linalg.norm(x_next) >= trust_radius:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                x = x + theta * alpha * p\n            x = reinforce_box_boundaries(x, lb, ub)\n            stop_cond = 2\n            hits_boundary = True\n            break\n        if inside_box_boundaries(x_next, lb, ub):\n            counter = 0\n        else:\n            counter += 1\n        if counter > 0:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                last_feasible_x = x + theta * alpha * p\n                last_feasible_x = reinforce_box_boundaries(last_feasible_x, lb, ub)\n                counter = 0\n        if counter > max_infeasible_iter:\n            break\n        if return_all:\n            allvecs.append(x_next)\n        r_next = r + alpha * H_p\n        g_next = Z.dot(r_next)\n        rt_g_next = norm(g_next) ** 2\n        beta = rt_g_next / rt_g\n        p = -g_next + beta * p\n        x = x_next\n        g = g_next\n        r = g_next\n        rt_g = norm(g) ** 2\n        H_p = H.dot(p)\n    if not inside_box_boundaries(x, lb, ub):\n        x = last_feasible_x\n        hits_boundary = True\n    info = {'niter': k, 'stop_cond': stop_cond, 'hits_boundary': hits_boundary}\n    if return_all:\n        info['allvecs'] = allvecs\n    return (x, info)",
        "mutated": [
            "def projected_cg(H, c, Z, Y, b, trust_radius=np.inf, lb=None, ub=None, tol=None, max_iter=None, max_infeasible_iter=None, return_all=False):\n    if False:\n        i = 10\n    'Solve EQP problem with projected CG method.\\n\\n    Solve equality-constrained quadratic programming problem\\n    ``min 1/2 x.T H x + x.t c``  subject to ``A x + b = 0`` and,\\n    possibly, to trust region constraints ``||x|| < trust_radius``\\n    and box constraints ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    H : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for computing ``H v``.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    Z : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for projecting ``x`` into the null space of A.\\n    Y : LinearOperator,  sparse matrix, ndarray, shape (n, m)\\n        Operator that, for a given a vector ``b``, compute smallest\\n        norm solution of ``A x + b = 0``.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n    trust_radius : float, optional\\n        Trust radius to be considered. By default, uses ``trust_radius=inf``,\\n        which means no trust radius at all.\\n    lb : array_like, shape (n,), optional\\n        Lower bounds to each one of the components of ``x``.\\n        If ``lb[i] = -Inf`` the lower bound for the i-th\\n        component is just ignored (default).\\n    ub : array_like, shape (n, ), optional\\n        Upper bounds to each one of the components of ``x``.\\n        If ``ub[i] = Inf`` the upper bound for the i-th\\n        component is just ignored (default).\\n    tol : float, optional\\n        Tolerance used to interrupt the algorithm.\\n    max_iter : int, optional\\n        Maximum algorithm iterations. Where ``max_inter <= n-m``.\\n        By default, uses ``max_iter = n-m``.\\n    max_infeasible_iter : int, optional\\n        Maximum infeasible (regarding box constraints) iterations the\\n        algorithm is allowed to take.\\n        By default, uses ``max_infeasible_iter = n-m``.\\n    return_all : bool, optional\\n        When ``true``, return the list of all vectors through the iterations.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the EQP problem.\\n    info : Dict\\n        Dictionary containing the following:\\n\\n            - niter : Number of iterations.\\n            - stop_cond : Reason for algorithm termination:\\n                1. Iteration limit was reached;\\n                2. Reached the trust-region boundary;\\n                3. Negative curvature detected;\\n                4. Tolerance was satisfied.\\n            - allvecs : List containing all intermediary vectors (optional).\\n            - hits_boundary : True if the proposed step is on the boundary\\n              of the trust region.\\n\\n    Notes\\n    -----\\n    Implementation of Algorithm 6.2 on [1]_.\\n\\n    In the absence of spherical and box constraints, for sufficient\\n    iterations, the method returns a truly optimal result.\\n    In the presence of those constraints, the value returned is only\\n    a inexpensive approximation of the optimal value.\\n\\n    References\\n    ----------\\n    .. [1] Gould, Nicholas IM, Mary E. Hribar, and Jorge Nocedal.\\n           \"On the solution of equality constrained quadratic\\n            programming problems arising in optimization.\"\\n            SIAM Journal on Scientific Computing 23.4 (2001): 1376-1395.\\n    '\n    CLOSE_TO_ZERO = 1e-25\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    x = Y.dot(-b)\n    r = Z.dot(H.dot(x) + c)\n    g = Z.dot(r)\n    p = -g\n    if return_all:\n        allvecs = [x]\n    H_p = H.dot(p)\n    rt_g = norm(g) ** 2\n    tr_distance = trust_radius - norm(x)\n    if tr_distance < 0:\n        raise ValueError('Trust region problem does not have a solution.')\n    elif tr_distance < CLOSE_TO_ZERO:\n        info = {'niter': 0, 'stop_cond': 2, 'hits_boundary': True}\n        if return_all:\n            allvecs.append(x)\n            info['allvecs'] = allvecs\n        return (x, info)\n    if tol is None:\n        tol = max(min(0.01 * np.sqrt(rt_g), 0.1 * rt_g), CLOSE_TO_ZERO)\n    if lb is None:\n        lb = np.full(n, -np.inf)\n    if ub is None:\n        ub = np.full(n, np.inf)\n    if max_iter is None:\n        max_iter = n - m\n    max_iter = min(max_iter, n - m)\n    if max_infeasible_iter is None:\n        max_infeasible_iter = n - m\n    hits_boundary = False\n    stop_cond = 1\n    counter = 0\n    last_feasible_x = np.zeros_like(x)\n    k = 0\n    for i in range(max_iter):\n        if rt_g < tol:\n            stop_cond = 4\n            break\n        k += 1\n        pt_H_p = H_p.dot(p)\n        if pt_H_p <= 0:\n            if np.isinf(trust_radius):\n                raise ValueError('Negative curvature not allowed for unrestricted problems.')\n            else:\n                (_, alpha, intersect) = box_sphere_intersections(x, p, lb, ub, trust_radius, entire_line=True)\n                if intersect:\n                    x = x + alpha * p\n                x = reinforce_box_boundaries(x, lb, ub)\n                stop_cond = 3\n                hits_boundary = True\n                break\n        alpha = rt_g / pt_H_p\n        x_next = x + alpha * p\n        if np.linalg.norm(x_next) >= trust_radius:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                x = x + theta * alpha * p\n            x = reinforce_box_boundaries(x, lb, ub)\n            stop_cond = 2\n            hits_boundary = True\n            break\n        if inside_box_boundaries(x_next, lb, ub):\n            counter = 0\n        else:\n            counter += 1\n        if counter > 0:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                last_feasible_x = x + theta * alpha * p\n                last_feasible_x = reinforce_box_boundaries(last_feasible_x, lb, ub)\n                counter = 0\n        if counter > max_infeasible_iter:\n            break\n        if return_all:\n            allvecs.append(x_next)\n        r_next = r + alpha * H_p\n        g_next = Z.dot(r_next)\n        rt_g_next = norm(g_next) ** 2\n        beta = rt_g_next / rt_g\n        p = -g_next + beta * p\n        x = x_next\n        g = g_next\n        r = g_next\n        rt_g = norm(g) ** 2\n        H_p = H.dot(p)\n    if not inside_box_boundaries(x, lb, ub):\n        x = last_feasible_x\n        hits_boundary = True\n    info = {'niter': k, 'stop_cond': stop_cond, 'hits_boundary': hits_boundary}\n    if return_all:\n        info['allvecs'] = allvecs\n    return (x, info)",
            "def projected_cg(H, c, Z, Y, b, trust_radius=np.inf, lb=None, ub=None, tol=None, max_iter=None, max_infeasible_iter=None, return_all=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Solve EQP problem with projected CG method.\\n\\n    Solve equality-constrained quadratic programming problem\\n    ``min 1/2 x.T H x + x.t c``  subject to ``A x + b = 0`` and,\\n    possibly, to trust region constraints ``||x|| < trust_radius``\\n    and box constraints ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    H : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for computing ``H v``.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    Z : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for projecting ``x`` into the null space of A.\\n    Y : LinearOperator,  sparse matrix, ndarray, shape (n, m)\\n        Operator that, for a given a vector ``b``, compute smallest\\n        norm solution of ``A x + b = 0``.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n    trust_radius : float, optional\\n        Trust radius to be considered. By default, uses ``trust_radius=inf``,\\n        which means no trust radius at all.\\n    lb : array_like, shape (n,), optional\\n        Lower bounds to each one of the components of ``x``.\\n        If ``lb[i] = -Inf`` the lower bound for the i-th\\n        component is just ignored (default).\\n    ub : array_like, shape (n, ), optional\\n        Upper bounds to each one of the components of ``x``.\\n        If ``ub[i] = Inf`` the upper bound for the i-th\\n        component is just ignored (default).\\n    tol : float, optional\\n        Tolerance used to interrupt the algorithm.\\n    max_iter : int, optional\\n        Maximum algorithm iterations. Where ``max_inter <= n-m``.\\n        By default, uses ``max_iter = n-m``.\\n    max_infeasible_iter : int, optional\\n        Maximum infeasible (regarding box constraints) iterations the\\n        algorithm is allowed to take.\\n        By default, uses ``max_infeasible_iter = n-m``.\\n    return_all : bool, optional\\n        When ``true``, return the list of all vectors through the iterations.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the EQP problem.\\n    info : Dict\\n        Dictionary containing the following:\\n\\n            - niter : Number of iterations.\\n            - stop_cond : Reason for algorithm termination:\\n                1. Iteration limit was reached;\\n                2. Reached the trust-region boundary;\\n                3. Negative curvature detected;\\n                4. Tolerance was satisfied.\\n            - allvecs : List containing all intermediary vectors (optional).\\n            - hits_boundary : True if the proposed step is on the boundary\\n              of the trust region.\\n\\n    Notes\\n    -----\\n    Implementation of Algorithm 6.2 on [1]_.\\n\\n    In the absence of spherical and box constraints, for sufficient\\n    iterations, the method returns a truly optimal result.\\n    In the presence of those constraints, the value returned is only\\n    a inexpensive approximation of the optimal value.\\n\\n    References\\n    ----------\\n    .. [1] Gould, Nicholas IM, Mary E. Hribar, and Jorge Nocedal.\\n           \"On the solution of equality constrained quadratic\\n            programming problems arising in optimization.\"\\n            SIAM Journal on Scientific Computing 23.4 (2001): 1376-1395.\\n    '\n    CLOSE_TO_ZERO = 1e-25\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    x = Y.dot(-b)\n    r = Z.dot(H.dot(x) + c)\n    g = Z.dot(r)\n    p = -g\n    if return_all:\n        allvecs = [x]\n    H_p = H.dot(p)\n    rt_g = norm(g) ** 2\n    tr_distance = trust_radius - norm(x)\n    if tr_distance < 0:\n        raise ValueError('Trust region problem does not have a solution.')\n    elif tr_distance < CLOSE_TO_ZERO:\n        info = {'niter': 0, 'stop_cond': 2, 'hits_boundary': True}\n        if return_all:\n            allvecs.append(x)\n            info['allvecs'] = allvecs\n        return (x, info)\n    if tol is None:\n        tol = max(min(0.01 * np.sqrt(rt_g), 0.1 * rt_g), CLOSE_TO_ZERO)\n    if lb is None:\n        lb = np.full(n, -np.inf)\n    if ub is None:\n        ub = np.full(n, np.inf)\n    if max_iter is None:\n        max_iter = n - m\n    max_iter = min(max_iter, n - m)\n    if max_infeasible_iter is None:\n        max_infeasible_iter = n - m\n    hits_boundary = False\n    stop_cond = 1\n    counter = 0\n    last_feasible_x = np.zeros_like(x)\n    k = 0\n    for i in range(max_iter):\n        if rt_g < tol:\n            stop_cond = 4\n            break\n        k += 1\n        pt_H_p = H_p.dot(p)\n        if pt_H_p <= 0:\n            if np.isinf(trust_radius):\n                raise ValueError('Negative curvature not allowed for unrestricted problems.')\n            else:\n                (_, alpha, intersect) = box_sphere_intersections(x, p, lb, ub, trust_radius, entire_line=True)\n                if intersect:\n                    x = x + alpha * p\n                x = reinforce_box_boundaries(x, lb, ub)\n                stop_cond = 3\n                hits_boundary = True\n                break\n        alpha = rt_g / pt_H_p\n        x_next = x + alpha * p\n        if np.linalg.norm(x_next) >= trust_radius:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                x = x + theta * alpha * p\n            x = reinforce_box_boundaries(x, lb, ub)\n            stop_cond = 2\n            hits_boundary = True\n            break\n        if inside_box_boundaries(x_next, lb, ub):\n            counter = 0\n        else:\n            counter += 1\n        if counter > 0:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                last_feasible_x = x + theta * alpha * p\n                last_feasible_x = reinforce_box_boundaries(last_feasible_x, lb, ub)\n                counter = 0\n        if counter > max_infeasible_iter:\n            break\n        if return_all:\n            allvecs.append(x_next)\n        r_next = r + alpha * H_p\n        g_next = Z.dot(r_next)\n        rt_g_next = norm(g_next) ** 2\n        beta = rt_g_next / rt_g\n        p = -g_next + beta * p\n        x = x_next\n        g = g_next\n        r = g_next\n        rt_g = norm(g) ** 2\n        H_p = H.dot(p)\n    if not inside_box_boundaries(x, lb, ub):\n        x = last_feasible_x\n        hits_boundary = True\n    info = {'niter': k, 'stop_cond': stop_cond, 'hits_boundary': hits_boundary}\n    if return_all:\n        info['allvecs'] = allvecs\n    return (x, info)",
            "def projected_cg(H, c, Z, Y, b, trust_radius=np.inf, lb=None, ub=None, tol=None, max_iter=None, max_infeasible_iter=None, return_all=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Solve EQP problem with projected CG method.\\n\\n    Solve equality-constrained quadratic programming problem\\n    ``min 1/2 x.T H x + x.t c``  subject to ``A x + b = 0`` and,\\n    possibly, to trust region constraints ``||x|| < trust_radius``\\n    and box constraints ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    H : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for computing ``H v``.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    Z : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for projecting ``x`` into the null space of A.\\n    Y : LinearOperator,  sparse matrix, ndarray, shape (n, m)\\n        Operator that, for a given a vector ``b``, compute smallest\\n        norm solution of ``A x + b = 0``.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n    trust_radius : float, optional\\n        Trust radius to be considered. By default, uses ``trust_radius=inf``,\\n        which means no trust radius at all.\\n    lb : array_like, shape (n,), optional\\n        Lower bounds to each one of the components of ``x``.\\n        If ``lb[i] = -Inf`` the lower bound for the i-th\\n        component is just ignored (default).\\n    ub : array_like, shape (n, ), optional\\n        Upper bounds to each one of the components of ``x``.\\n        If ``ub[i] = Inf`` the upper bound for the i-th\\n        component is just ignored (default).\\n    tol : float, optional\\n        Tolerance used to interrupt the algorithm.\\n    max_iter : int, optional\\n        Maximum algorithm iterations. Where ``max_inter <= n-m``.\\n        By default, uses ``max_iter = n-m``.\\n    max_infeasible_iter : int, optional\\n        Maximum infeasible (regarding box constraints) iterations the\\n        algorithm is allowed to take.\\n        By default, uses ``max_infeasible_iter = n-m``.\\n    return_all : bool, optional\\n        When ``true``, return the list of all vectors through the iterations.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the EQP problem.\\n    info : Dict\\n        Dictionary containing the following:\\n\\n            - niter : Number of iterations.\\n            - stop_cond : Reason for algorithm termination:\\n                1. Iteration limit was reached;\\n                2. Reached the trust-region boundary;\\n                3. Negative curvature detected;\\n                4. Tolerance was satisfied.\\n            - allvecs : List containing all intermediary vectors (optional).\\n            - hits_boundary : True if the proposed step is on the boundary\\n              of the trust region.\\n\\n    Notes\\n    -----\\n    Implementation of Algorithm 6.2 on [1]_.\\n\\n    In the absence of spherical and box constraints, for sufficient\\n    iterations, the method returns a truly optimal result.\\n    In the presence of those constraints, the value returned is only\\n    a inexpensive approximation of the optimal value.\\n\\n    References\\n    ----------\\n    .. [1] Gould, Nicholas IM, Mary E. Hribar, and Jorge Nocedal.\\n           \"On the solution of equality constrained quadratic\\n            programming problems arising in optimization.\"\\n            SIAM Journal on Scientific Computing 23.4 (2001): 1376-1395.\\n    '\n    CLOSE_TO_ZERO = 1e-25\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    x = Y.dot(-b)\n    r = Z.dot(H.dot(x) + c)\n    g = Z.dot(r)\n    p = -g\n    if return_all:\n        allvecs = [x]\n    H_p = H.dot(p)\n    rt_g = norm(g) ** 2\n    tr_distance = trust_radius - norm(x)\n    if tr_distance < 0:\n        raise ValueError('Trust region problem does not have a solution.')\n    elif tr_distance < CLOSE_TO_ZERO:\n        info = {'niter': 0, 'stop_cond': 2, 'hits_boundary': True}\n        if return_all:\n            allvecs.append(x)\n            info['allvecs'] = allvecs\n        return (x, info)\n    if tol is None:\n        tol = max(min(0.01 * np.sqrt(rt_g), 0.1 * rt_g), CLOSE_TO_ZERO)\n    if lb is None:\n        lb = np.full(n, -np.inf)\n    if ub is None:\n        ub = np.full(n, np.inf)\n    if max_iter is None:\n        max_iter = n - m\n    max_iter = min(max_iter, n - m)\n    if max_infeasible_iter is None:\n        max_infeasible_iter = n - m\n    hits_boundary = False\n    stop_cond = 1\n    counter = 0\n    last_feasible_x = np.zeros_like(x)\n    k = 0\n    for i in range(max_iter):\n        if rt_g < tol:\n            stop_cond = 4\n            break\n        k += 1\n        pt_H_p = H_p.dot(p)\n        if pt_H_p <= 0:\n            if np.isinf(trust_radius):\n                raise ValueError('Negative curvature not allowed for unrestricted problems.')\n            else:\n                (_, alpha, intersect) = box_sphere_intersections(x, p, lb, ub, trust_radius, entire_line=True)\n                if intersect:\n                    x = x + alpha * p\n                x = reinforce_box_boundaries(x, lb, ub)\n                stop_cond = 3\n                hits_boundary = True\n                break\n        alpha = rt_g / pt_H_p\n        x_next = x + alpha * p\n        if np.linalg.norm(x_next) >= trust_radius:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                x = x + theta * alpha * p\n            x = reinforce_box_boundaries(x, lb, ub)\n            stop_cond = 2\n            hits_boundary = True\n            break\n        if inside_box_boundaries(x_next, lb, ub):\n            counter = 0\n        else:\n            counter += 1\n        if counter > 0:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                last_feasible_x = x + theta * alpha * p\n                last_feasible_x = reinforce_box_boundaries(last_feasible_x, lb, ub)\n                counter = 0\n        if counter > max_infeasible_iter:\n            break\n        if return_all:\n            allvecs.append(x_next)\n        r_next = r + alpha * H_p\n        g_next = Z.dot(r_next)\n        rt_g_next = norm(g_next) ** 2\n        beta = rt_g_next / rt_g\n        p = -g_next + beta * p\n        x = x_next\n        g = g_next\n        r = g_next\n        rt_g = norm(g) ** 2\n        H_p = H.dot(p)\n    if not inside_box_boundaries(x, lb, ub):\n        x = last_feasible_x\n        hits_boundary = True\n    info = {'niter': k, 'stop_cond': stop_cond, 'hits_boundary': hits_boundary}\n    if return_all:\n        info['allvecs'] = allvecs\n    return (x, info)",
            "def projected_cg(H, c, Z, Y, b, trust_radius=np.inf, lb=None, ub=None, tol=None, max_iter=None, max_infeasible_iter=None, return_all=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Solve EQP problem with projected CG method.\\n\\n    Solve equality-constrained quadratic programming problem\\n    ``min 1/2 x.T H x + x.t c``  subject to ``A x + b = 0`` and,\\n    possibly, to trust region constraints ``||x|| < trust_radius``\\n    and box constraints ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    H : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for computing ``H v``.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    Z : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for projecting ``x`` into the null space of A.\\n    Y : LinearOperator,  sparse matrix, ndarray, shape (n, m)\\n        Operator that, for a given a vector ``b``, compute smallest\\n        norm solution of ``A x + b = 0``.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n    trust_radius : float, optional\\n        Trust radius to be considered. By default, uses ``trust_radius=inf``,\\n        which means no trust radius at all.\\n    lb : array_like, shape (n,), optional\\n        Lower bounds to each one of the components of ``x``.\\n        If ``lb[i] = -Inf`` the lower bound for the i-th\\n        component is just ignored (default).\\n    ub : array_like, shape (n, ), optional\\n        Upper bounds to each one of the components of ``x``.\\n        If ``ub[i] = Inf`` the upper bound for the i-th\\n        component is just ignored (default).\\n    tol : float, optional\\n        Tolerance used to interrupt the algorithm.\\n    max_iter : int, optional\\n        Maximum algorithm iterations. Where ``max_inter <= n-m``.\\n        By default, uses ``max_iter = n-m``.\\n    max_infeasible_iter : int, optional\\n        Maximum infeasible (regarding box constraints) iterations the\\n        algorithm is allowed to take.\\n        By default, uses ``max_infeasible_iter = n-m``.\\n    return_all : bool, optional\\n        When ``true``, return the list of all vectors through the iterations.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the EQP problem.\\n    info : Dict\\n        Dictionary containing the following:\\n\\n            - niter : Number of iterations.\\n            - stop_cond : Reason for algorithm termination:\\n                1. Iteration limit was reached;\\n                2. Reached the trust-region boundary;\\n                3. Negative curvature detected;\\n                4. Tolerance was satisfied.\\n            - allvecs : List containing all intermediary vectors (optional).\\n            - hits_boundary : True if the proposed step is on the boundary\\n              of the trust region.\\n\\n    Notes\\n    -----\\n    Implementation of Algorithm 6.2 on [1]_.\\n\\n    In the absence of spherical and box constraints, for sufficient\\n    iterations, the method returns a truly optimal result.\\n    In the presence of those constraints, the value returned is only\\n    a inexpensive approximation of the optimal value.\\n\\n    References\\n    ----------\\n    .. [1] Gould, Nicholas IM, Mary E. Hribar, and Jorge Nocedal.\\n           \"On the solution of equality constrained quadratic\\n            programming problems arising in optimization.\"\\n            SIAM Journal on Scientific Computing 23.4 (2001): 1376-1395.\\n    '\n    CLOSE_TO_ZERO = 1e-25\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    x = Y.dot(-b)\n    r = Z.dot(H.dot(x) + c)\n    g = Z.dot(r)\n    p = -g\n    if return_all:\n        allvecs = [x]\n    H_p = H.dot(p)\n    rt_g = norm(g) ** 2\n    tr_distance = trust_radius - norm(x)\n    if tr_distance < 0:\n        raise ValueError('Trust region problem does not have a solution.')\n    elif tr_distance < CLOSE_TO_ZERO:\n        info = {'niter': 0, 'stop_cond': 2, 'hits_boundary': True}\n        if return_all:\n            allvecs.append(x)\n            info['allvecs'] = allvecs\n        return (x, info)\n    if tol is None:\n        tol = max(min(0.01 * np.sqrt(rt_g), 0.1 * rt_g), CLOSE_TO_ZERO)\n    if lb is None:\n        lb = np.full(n, -np.inf)\n    if ub is None:\n        ub = np.full(n, np.inf)\n    if max_iter is None:\n        max_iter = n - m\n    max_iter = min(max_iter, n - m)\n    if max_infeasible_iter is None:\n        max_infeasible_iter = n - m\n    hits_boundary = False\n    stop_cond = 1\n    counter = 0\n    last_feasible_x = np.zeros_like(x)\n    k = 0\n    for i in range(max_iter):\n        if rt_g < tol:\n            stop_cond = 4\n            break\n        k += 1\n        pt_H_p = H_p.dot(p)\n        if pt_H_p <= 0:\n            if np.isinf(trust_radius):\n                raise ValueError('Negative curvature not allowed for unrestricted problems.')\n            else:\n                (_, alpha, intersect) = box_sphere_intersections(x, p, lb, ub, trust_radius, entire_line=True)\n                if intersect:\n                    x = x + alpha * p\n                x = reinforce_box_boundaries(x, lb, ub)\n                stop_cond = 3\n                hits_boundary = True\n                break\n        alpha = rt_g / pt_H_p\n        x_next = x + alpha * p\n        if np.linalg.norm(x_next) >= trust_radius:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                x = x + theta * alpha * p\n            x = reinforce_box_boundaries(x, lb, ub)\n            stop_cond = 2\n            hits_boundary = True\n            break\n        if inside_box_boundaries(x_next, lb, ub):\n            counter = 0\n        else:\n            counter += 1\n        if counter > 0:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                last_feasible_x = x + theta * alpha * p\n                last_feasible_x = reinforce_box_boundaries(last_feasible_x, lb, ub)\n                counter = 0\n        if counter > max_infeasible_iter:\n            break\n        if return_all:\n            allvecs.append(x_next)\n        r_next = r + alpha * H_p\n        g_next = Z.dot(r_next)\n        rt_g_next = norm(g_next) ** 2\n        beta = rt_g_next / rt_g\n        p = -g_next + beta * p\n        x = x_next\n        g = g_next\n        r = g_next\n        rt_g = norm(g) ** 2\n        H_p = H.dot(p)\n    if not inside_box_boundaries(x, lb, ub):\n        x = last_feasible_x\n        hits_boundary = True\n    info = {'niter': k, 'stop_cond': stop_cond, 'hits_boundary': hits_boundary}\n    if return_all:\n        info['allvecs'] = allvecs\n    return (x, info)",
            "def projected_cg(H, c, Z, Y, b, trust_radius=np.inf, lb=None, ub=None, tol=None, max_iter=None, max_infeasible_iter=None, return_all=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Solve EQP problem with projected CG method.\\n\\n    Solve equality-constrained quadratic programming problem\\n    ``min 1/2 x.T H x + x.t c``  subject to ``A x + b = 0`` and,\\n    possibly, to trust region constraints ``||x|| < trust_radius``\\n    and box constraints ``lb <= x <= ub``.\\n\\n    Parameters\\n    ----------\\n    H : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for computing ``H v``.\\n    c : array_like, shape (n,)\\n        Gradient of the quadratic objective function.\\n    Z : LinearOperator (or sparse matrix or ndarray), shape (n, n)\\n        Operator for projecting ``x`` into the null space of A.\\n    Y : LinearOperator,  sparse matrix, ndarray, shape (n, m)\\n        Operator that, for a given a vector ``b``, compute smallest\\n        norm solution of ``A x + b = 0``.\\n    b : array_like, shape (m,)\\n        Right-hand side of the constraint equation.\\n    trust_radius : float, optional\\n        Trust radius to be considered. By default, uses ``trust_radius=inf``,\\n        which means no trust radius at all.\\n    lb : array_like, shape (n,), optional\\n        Lower bounds to each one of the components of ``x``.\\n        If ``lb[i] = -Inf`` the lower bound for the i-th\\n        component is just ignored (default).\\n    ub : array_like, shape (n, ), optional\\n        Upper bounds to each one of the components of ``x``.\\n        If ``ub[i] = Inf`` the upper bound for the i-th\\n        component is just ignored (default).\\n    tol : float, optional\\n        Tolerance used to interrupt the algorithm.\\n    max_iter : int, optional\\n        Maximum algorithm iterations. Where ``max_inter <= n-m``.\\n        By default, uses ``max_iter = n-m``.\\n    max_infeasible_iter : int, optional\\n        Maximum infeasible (regarding box constraints) iterations the\\n        algorithm is allowed to take.\\n        By default, uses ``max_infeasible_iter = n-m``.\\n    return_all : bool, optional\\n        When ``true``, return the list of all vectors through the iterations.\\n\\n    Returns\\n    -------\\n    x : array_like, shape (n,)\\n        Solution of the EQP problem.\\n    info : Dict\\n        Dictionary containing the following:\\n\\n            - niter : Number of iterations.\\n            - stop_cond : Reason for algorithm termination:\\n                1. Iteration limit was reached;\\n                2. Reached the trust-region boundary;\\n                3. Negative curvature detected;\\n                4. Tolerance was satisfied.\\n            - allvecs : List containing all intermediary vectors (optional).\\n            - hits_boundary : True if the proposed step is on the boundary\\n              of the trust region.\\n\\n    Notes\\n    -----\\n    Implementation of Algorithm 6.2 on [1]_.\\n\\n    In the absence of spherical and box constraints, for sufficient\\n    iterations, the method returns a truly optimal result.\\n    In the presence of those constraints, the value returned is only\\n    a inexpensive approximation of the optimal value.\\n\\n    References\\n    ----------\\n    .. [1] Gould, Nicholas IM, Mary E. Hribar, and Jorge Nocedal.\\n           \"On the solution of equality constrained quadratic\\n            programming problems arising in optimization.\"\\n            SIAM Journal on Scientific Computing 23.4 (2001): 1376-1395.\\n    '\n    CLOSE_TO_ZERO = 1e-25\n    (n,) = np.shape(c)\n    (m,) = np.shape(b)\n    x = Y.dot(-b)\n    r = Z.dot(H.dot(x) + c)\n    g = Z.dot(r)\n    p = -g\n    if return_all:\n        allvecs = [x]\n    H_p = H.dot(p)\n    rt_g = norm(g) ** 2\n    tr_distance = trust_radius - norm(x)\n    if tr_distance < 0:\n        raise ValueError('Trust region problem does not have a solution.')\n    elif tr_distance < CLOSE_TO_ZERO:\n        info = {'niter': 0, 'stop_cond': 2, 'hits_boundary': True}\n        if return_all:\n            allvecs.append(x)\n            info['allvecs'] = allvecs\n        return (x, info)\n    if tol is None:\n        tol = max(min(0.01 * np.sqrt(rt_g), 0.1 * rt_g), CLOSE_TO_ZERO)\n    if lb is None:\n        lb = np.full(n, -np.inf)\n    if ub is None:\n        ub = np.full(n, np.inf)\n    if max_iter is None:\n        max_iter = n - m\n    max_iter = min(max_iter, n - m)\n    if max_infeasible_iter is None:\n        max_infeasible_iter = n - m\n    hits_boundary = False\n    stop_cond = 1\n    counter = 0\n    last_feasible_x = np.zeros_like(x)\n    k = 0\n    for i in range(max_iter):\n        if rt_g < tol:\n            stop_cond = 4\n            break\n        k += 1\n        pt_H_p = H_p.dot(p)\n        if pt_H_p <= 0:\n            if np.isinf(trust_radius):\n                raise ValueError('Negative curvature not allowed for unrestricted problems.')\n            else:\n                (_, alpha, intersect) = box_sphere_intersections(x, p, lb, ub, trust_radius, entire_line=True)\n                if intersect:\n                    x = x + alpha * p\n                x = reinforce_box_boundaries(x, lb, ub)\n                stop_cond = 3\n                hits_boundary = True\n                break\n        alpha = rt_g / pt_H_p\n        x_next = x + alpha * p\n        if np.linalg.norm(x_next) >= trust_radius:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                x = x + theta * alpha * p\n            x = reinforce_box_boundaries(x, lb, ub)\n            stop_cond = 2\n            hits_boundary = True\n            break\n        if inside_box_boundaries(x_next, lb, ub):\n            counter = 0\n        else:\n            counter += 1\n        if counter > 0:\n            (_, theta, intersect) = box_sphere_intersections(x, alpha * p, lb, ub, trust_radius)\n            if intersect:\n                last_feasible_x = x + theta * alpha * p\n                last_feasible_x = reinforce_box_boundaries(last_feasible_x, lb, ub)\n                counter = 0\n        if counter > max_infeasible_iter:\n            break\n        if return_all:\n            allvecs.append(x_next)\n        r_next = r + alpha * H_p\n        g_next = Z.dot(r_next)\n        rt_g_next = norm(g_next) ** 2\n        beta = rt_g_next / rt_g\n        p = -g_next + beta * p\n        x = x_next\n        g = g_next\n        r = g_next\n        rt_g = norm(g) ** 2\n        H_p = H.dot(p)\n    if not inside_box_boundaries(x, lb, ub):\n        x = last_feasible_x\n        hits_boundary = True\n    info = {'niter': k, 'stop_cond': stop_cond, 'hits_boundary': hits_boundary}\n    if return_all:\n        info['allvecs'] = allvecs\n    return (x, info)"
        ]
    }
]