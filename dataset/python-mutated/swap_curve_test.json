[
    {
        "func_name": "test_correctness",
        "original": "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness(self, dtype):\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [tf.convert_to_tensor(np.arange(0.25, x + 0.1, 0.25, dtype)) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, dtype=dtype, curve_tolerance=1e-05, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness(self, dtype):\n    if False:\n        i = 10\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [tf.convert_to_tensor(np.arange(0.25, x + 0.1, 0.25, dtype)) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, dtype=dtype, curve_tolerance=1e-05, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [tf.convert_to_tensor(np.arange(0.25, x + 0.1, 0.25, dtype)) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, dtype=dtype, curve_tolerance=1e-05, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [tf.convert_to_tensor(np.arange(0.25, x + 0.1, 0.25, dtype)) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, dtype=dtype, curve_tolerance=1e-05, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [tf.convert_to_tensor(np.arange(0.25, x + 0.1, 0.25, dtype)) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, dtype=dtype, curve_tolerance=1e-05, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [tf.convert_to_tensor(np.arange(0.25, x + 0.1, 0.25, dtype)) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, dtype=dtype, curve_tolerance=1e-05, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)"
        ]
    },
    {
        "func_name": "test_OIS_discounting",
        "original": "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32, 'curve_tolerance': 0.0001}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64, 'curve_tolerance': 1e-06})\ndef test_OIS_discounting(self, dtype, curve_tolerance):\n    \"\"\"Test the discouting of cashflows using a separate discounting curve.\"\"\"\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=curve_tolerance)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32, 'curve_tolerance': 0.0001}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64, 'curve_tolerance': 1e-06})\ndef test_OIS_discounting(self, dtype, curve_tolerance):\n    if False:\n        i = 10\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=curve_tolerance)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32, 'curve_tolerance': 0.0001}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64, 'curve_tolerance': 1e-06})\ndef test_OIS_discounting(self, dtype, curve_tolerance):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=curve_tolerance)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32, 'curve_tolerance': 0.0001}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64, 'curve_tolerance': 1e-06})\ndef test_OIS_discounting(self, dtype, curve_tolerance):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=curve_tolerance)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32, 'curve_tolerance': 0.0001}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64, 'curve_tolerance': 1e-06})\ndef test_OIS_discounting(self, dtype, curve_tolerance):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=curve_tolerance)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32, 'curve_tolerance': 0.0001}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64, 'curve_tolerance': 1e-06})\ndef test_OIS_discounting(self, dtype, curve_tolerance):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=curve_tolerance)"
        ]
    },
    {
        "func_name": "test_OIS_discounting_batch",
        "original": "def test_OIS_discounting_batch(self):\n    \"\"\"Test OIS discounting with batched inputs.\"\"\"\n    curve_tolerance = 1e-06\n    dtype = np.float64\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = np.array([[2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27], [2.9, 3.09, 2.1, 3.15, 2.18, 3.1, 3.28]])\n    expected_discount_rates = np.array([[0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], [0.02853547, 0.03043963, 0.01867736, 0.03429374, 0.01180023, 0.05393317, 0.11853233]], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.expand_dims(-par_swap_rates[:, i], -1) / 100 + np.zeros([len(x)]) for (i, x) in enumerate(fixed_leg_start_times)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = [[0.0, 0.1], [0.0, 0.2], [0.0, 0.3], [0.0, 0.5]]\n    discount_times = [1.0, 5.0, 10.0, 30.0]\n    initial_curve_rates = 0.01 * np.array(np.ones_like(2 * [mats]))\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    with self.subTest('NonFailed'):\n        self.assertFalse(np.any(results.failed))\n    with self.subTest('AllClose'):\n        self.assertAllClose(results.rates, expected_discount_rates, rtol=curve_tolerance, atol=curve_tolerance)",
        "mutated": [
            "def test_OIS_discounting_batch(self):\n    if False:\n        i = 10\n    'Test OIS discounting with batched inputs.'\n    curve_tolerance = 1e-06\n    dtype = np.float64\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = np.array([[2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27], [2.9, 3.09, 2.1, 3.15, 2.18, 3.1, 3.28]])\n    expected_discount_rates = np.array([[0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], [0.02853547, 0.03043963, 0.01867736, 0.03429374, 0.01180023, 0.05393317, 0.11853233]], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.expand_dims(-par_swap_rates[:, i], -1) / 100 + np.zeros([len(x)]) for (i, x) in enumerate(fixed_leg_start_times)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = [[0.0, 0.1], [0.0, 0.2], [0.0, 0.3], [0.0, 0.5]]\n    discount_times = [1.0, 5.0, 10.0, 30.0]\n    initial_curve_rates = 0.01 * np.array(np.ones_like(2 * [mats]))\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    with self.subTest('NonFailed'):\n        self.assertFalse(np.any(results.failed))\n    with self.subTest('AllClose'):\n        self.assertAllClose(results.rates, expected_discount_rates, rtol=curve_tolerance, atol=curve_tolerance)",
            "def test_OIS_discounting_batch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test OIS discounting with batched inputs.'\n    curve_tolerance = 1e-06\n    dtype = np.float64\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = np.array([[2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27], [2.9, 3.09, 2.1, 3.15, 2.18, 3.1, 3.28]])\n    expected_discount_rates = np.array([[0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], [0.02853547, 0.03043963, 0.01867736, 0.03429374, 0.01180023, 0.05393317, 0.11853233]], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.expand_dims(-par_swap_rates[:, i], -1) / 100 + np.zeros([len(x)]) for (i, x) in enumerate(fixed_leg_start_times)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = [[0.0, 0.1], [0.0, 0.2], [0.0, 0.3], [0.0, 0.5]]\n    discount_times = [1.0, 5.0, 10.0, 30.0]\n    initial_curve_rates = 0.01 * np.array(np.ones_like(2 * [mats]))\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    with self.subTest('NonFailed'):\n        self.assertFalse(np.any(results.failed))\n    with self.subTest('AllClose'):\n        self.assertAllClose(results.rates, expected_discount_rates, rtol=curve_tolerance, atol=curve_tolerance)",
            "def test_OIS_discounting_batch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test OIS discounting with batched inputs.'\n    curve_tolerance = 1e-06\n    dtype = np.float64\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = np.array([[2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27], [2.9, 3.09, 2.1, 3.15, 2.18, 3.1, 3.28]])\n    expected_discount_rates = np.array([[0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], [0.02853547, 0.03043963, 0.01867736, 0.03429374, 0.01180023, 0.05393317, 0.11853233]], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.expand_dims(-par_swap_rates[:, i], -1) / 100 + np.zeros([len(x)]) for (i, x) in enumerate(fixed_leg_start_times)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = [[0.0, 0.1], [0.0, 0.2], [0.0, 0.3], [0.0, 0.5]]\n    discount_times = [1.0, 5.0, 10.0, 30.0]\n    initial_curve_rates = 0.01 * np.array(np.ones_like(2 * [mats]))\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    with self.subTest('NonFailed'):\n        self.assertFalse(np.any(results.failed))\n    with self.subTest('AllClose'):\n        self.assertAllClose(results.rates, expected_discount_rates, rtol=curve_tolerance, atol=curve_tolerance)",
            "def test_OIS_discounting_batch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test OIS discounting with batched inputs.'\n    curve_tolerance = 1e-06\n    dtype = np.float64\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = np.array([[2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27], [2.9, 3.09, 2.1, 3.15, 2.18, 3.1, 3.28]])\n    expected_discount_rates = np.array([[0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], [0.02853547, 0.03043963, 0.01867736, 0.03429374, 0.01180023, 0.05393317, 0.11853233]], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.expand_dims(-par_swap_rates[:, i], -1) / 100 + np.zeros([len(x)]) for (i, x) in enumerate(fixed_leg_start_times)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = [[0.0, 0.1], [0.0, 0.2], [0.0, 0.3], [0.0, 0.5]]\n    discount_times = [1.0, 5.0, 10.0, 30.0]\n    initial_curve_rates = 0.01 * np.array(np.ones_like(2 * [mats]))\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    with self.subTest('NonFailed'):\n        self.assertFalse(np.any(results.failed))\n    with self.subTest('AllClose'):\n        self.assertAllClose(results.rates, expected_discount_rates, rtol=curve_tolerance, atol=curve_tolerance)",
            "def test_OIS_discounting_batch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test OIS discounting with batched inputs.'\n    curve_tolerance = 1e-06\n    dtype = np.float64\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = np.array([[2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27], [2.9, 3.09, 2.1, 3.15, 2.18, 3.1, 3.28]])\n    expected_discount_rates = np.array([[0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], [0.02853547, 0.03043963, 0.01867736, 0.03429374, 0.01180023, 0.05393317, 0.11853233]], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.expand_dims(-par_swap_rates[:, i], -1) / 100 + np.zeros([len(x)]) for (i, x) in enumerate(fixed_leg_start_times)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = [[0.0, 0.1], [0.0, 0.2], [0.0, 0.3], [0.0, 0.5]]\n    discount_times = [1.0, 5.0, 10.0, 30.0]\n    initial_curve_rates = 0.01 * np.array(np.ones_like(2 * [mats]))\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, curve_tolerance=curve_tolerance, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    with self.subTest('NonFailed'):\n        self.assertFalse(np.any(results.failed))\n    with self.subTest('AllClose'):\n        self.assertAllClose(results.rates, expected_discount_rates, rtol=curve_tolerance, atol=curve_tolerance)"
        ]
    },
    {
        "func_name": "curve_interpolator",
        "original": "def curve_interpolator(xi, x, y):\n    return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)",
        "mutated": [
            "def curve_interpolator(xi, x, y):\n    if False:\n        i = 10\n    return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)",
            "def curve_interpolator(xi, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)",
            "def curve_interpolator(xi, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)",
            "def curve_interpolator(xi, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)",
            "def curve_interpolator(xi, x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)"
        ]
    },
    {
        "func_name": "test_interpolation_const_fwd",
        "original": "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_interpolation_const_fwd(self, dtype):\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n\n    def curve_interpolator(xi, x, y):\n        return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, curve_tolerance=1e-05, dtype=dtype, curve_interpolator=curve_interpolator, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03076991, 0.03113377, 0.03130508, 0.03160601, 0.03213445, 0.0325467], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_interpolation_const_fwd(self, dtype):\n    if False:\n        i = 10\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n\n    def curve_interpolator(xi, x, y):\n        return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, curve_tolerance=1e-05, dtype=dtype, curve_interpolator=curve_interpolator, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03076991, 0.03113377, 0.03130508, 0.03160601, 0.03213445, 0.0325467], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_interpolation_const_fwd(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n\n    def curve_interpolator(xi, x, y):\n        return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, curve_tolerance=1e-05, dtype=dtype, curve_interpolator=curve_interpolator, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03076991, 0.03113377, 0.03130508, 0.03160601, 0.03213445, 0.0325467], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_interpolation_const_fwd(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n\n    def curve_interpolator(xi, x, y):\n        return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, curve_tolerance=1e-05, dtype=dtype, curve_interpolator=curve_interpolator, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03076991, 0.03113377, 0.03130508, 0.03160601, 0.03213445, 0.0325467], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_interpolation_const_fwd(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n\n    def curve_interpolator(xi, x, y):\n        return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, curve_tolerance=1e-05, dtype=dtype, curve_interpolator=curve_interpolator, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03076991, 0.03113377, 0.03130508, 0.03160601, 0.03213445, 0.0325467], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_interpolation_const_fwd(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n\n    def curve_interpolator(xi, x, y):\n        return tff.rates.constant_fwd.interpolate(xi, x, y, dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, curve_tolerance=1e-05, dtype=dtype, curve_interpolator=curve_interpolator, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03076991, 0.03113377, 0.03130508, 0.03160601, 0.03213445, 0.0325467], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)"
        ]
    },
    {
        "func_name": "test_settlement_times",
        "original": "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_settlement_times(self, dtype):\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    discount_rates_float = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\n    discount_times_float = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    discount_rates_fixed = np.array([0.02, 0.02, 0.02, 0.02], dtype=dtype)\n    discount_times_fixed = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    settle_times = np.array(np.repeat(3.0 / 365.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates_float, float_leg_discount_times=discount_times_float, fixed_leg_discount_rates=discount_rates_fixed, fixed_leg_discount_times=discount_times_fixed, present_values_settlement_times=settle_times, curve_tolerance=1e-05, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02820418, 0.03044715, 0.0306564, 0.03052609, 0.030508, 0.03053637, 0.02808225], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_settlement_times(self, dtype):\n    if False:\n        i = 10\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    discount_rates_float = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\n    discount_times_float = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    discount_rates_fixed = np.array([0.02, 0.02, 0.02, 0.02], dtype=dtype)\n    discount_times_fixed = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    settle_times = np.array(np.repeat(3.0 / 365.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates_float, float_leg_discount_times=discount_times_float, fixed_leg_discount_rates=discount_rates_fixed, fixed_leg_discount_times=discount_times_fixed, present_values_settlement_times=settle_times, curve_tolerance=1e-05, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02820418, 0.03044715, 0.0306564, 0.03052609, 0.030508, 0.03053637, 0.02808225], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_settlement_times(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    discount_rates_float = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\n    discount_times_float = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    discount_rates_fixed = np.array([0.02, 0.02, 0.02, 0.02], dtype=dtype)\n    discount_times_fixed = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    settle_times = np.array(np.repeat(3.0 / 365.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates_float, float_leg_discount_times=discount_times_float, fixed_leg_discount_rates=discount_rates_fixed, fixed_leg_discount_times=discount_times_fixed, present_values_settlement_times=settle_times, curve_tolerance=1e-05, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02820418, 0.03044715, 0.0306564, 0.03052609, 0.030508, 0.03053637, 0.02808225], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_settlement_times(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    discount_rates_float = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\n    discount_times_float = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    discount_rates_fixed = np.array([0.02, 0.02, 0.02, 0.02], dtype=dtype)\n    discount_times_fixed = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    settle_times = np.array(np.repeat(3.0 / 365.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates_float, float_leg_discount_times=discount_times_float, fixed_leg_discount_rates=discount_rates_fixed, fixed_leg_discount_times=discount_times_fixed, present_values_settlement_times=settle_times, curve_tolerance=1e-05, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02820418, 0.03044715, 0.0306564, 0.03052609, 0.030508, 0.03053637, 0.02808225], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_settlement_times(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    discount_rates_float = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\n    discount_times_float = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    discount_rates_fixed = np.array([0.02, 0.02, 0.02, 0.02], dtype=dtype)\n    discount_times_fixed = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    settle_times = np.array(np.repeat(3.0 / 365.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates_float, float_leg_discount_times=discount_times_float, fixed_leg_discount_rates=discount_rates_fixed, fixed_leg_discount_times=discount_times_fixed, present_values_settlement_times=settle_times, curve_tolerance=1e-05, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02820418, 0.03044715, 0.0306564, 0.03052609, 0.030508, 0.03053637, 0.02808225], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_settlement_times(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    discount_rates_float = np.array([0.01, 0.01, 0.01, 0.01], dtype=dtype)\n    discount_times_float = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    discount_rates_fixed = np.array([0.02, 0.02, 0.02, 0.02], dtype=dtype)\n    discount_times_fixed = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    settle_times = np.array(np.repeat(3.0 / 365.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_fit(float_leg_start_times, float_leg_end_times, float_leg_dc, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, fixed_leg_dc, pvs, float_leg_discount_rates=discount_rates_float, float_leg_discount_times=discount_times_float, fixed_leg_discount_rates=discount_rates_fixed, fixed_leg_discount_times=discount_times_fixed, present_values_settlement_times=settle_times, curve_tolerance=1e-05, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02820418, 0.03044715, 0.0306564, 0.03052609, 0.030508, 0.03053637, 0.02808225], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)"
        ]
    },
    {
        "func_name": "test_correctness_bootstrap",
        "original": "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness_bootstrap(self, dtype):\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness_bootstrap(self, dtype):\n    if False:\n        i = 10\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_correctness_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)"
        ]
    },
    {
        "func_name": "test_OIS_discounting_bootstrap",
        "original": "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_OIS_discounting_bootstrap(self, dtype):\n    \"\"\"Test the discouting of cashflows using a separate discounting curve.\"\"\"\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_OIS_discounting_bootstrap(self, dtype):\n    if False:\n        i = 10\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_OIS_discounting_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_OIS_discounting_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_OIS_discounting_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_OIS_discounting_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test the discouting of cashflows using a separate discounting curve.'\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    expected_discount_rates = np.array([0.02844861, 0.03084989, 0.03121727, 0.0313961, 0.0316839, 0.03217002, 0.03256696], dtype=np.float64)\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    float_leg_dc = [np.array(np.repeat(0.25, len(x)), dtype=dtype) for x in float_leg_start_times]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_dc = [np.array(np.repeat(0.5, len(x)), dtype=dtype) for x in fixed_leg_start_times]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    discount_rates = np.array([0.0, 0.0, 0.0, 0.0], dtype=dtype)\n    discount_times = np.array([1.0, 5.0, 10.0, 30.0], dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, float_leg_daycount_fractions=float_leg_dc, fixed_leg_daycount_fractions=fixed_leg_dc, float_leg_discount_rates=discount_rates, float_leg_discount_times=discount_times, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)"
        ]
    },
    {
        "func_name": "test_missing_daycount_bootstrap",
        "original": "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_missing_daycount_bootstrap(self, dtype):\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_missing_daycount_bootstrap(self, dtype):\n    if False:\n        i = 10\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_missing_daycount_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_missing_daycount_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_missing_daycount_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_missing_daycount_bootstrap(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mats = [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0]\n    par_swap_rates = [2.855, 3.097, 3.134, 3.152, 3.181, 3.23, 3.27]\n    float_leg_start_times = [np.arange(0.0, x, 0.25, dtype) for x in mats]\n    float_leg_end_times = [np.arange(0.25, x + 0.1, 0.25, dtype) for x in mats]\n    fixed_leg_start_times = [np.arange(0.0, x, 0.5, dtype) for x in mats]\n    fixed_leg_end_times = [np.arange(0.5, x + 0.1, 0.5, dtype) for x in mats]\n    fixed_leg_cashflows = [np.array(np.repeat(-y / 100.0, len(x)), dtype=dtype) for (x, y) in zip(fixed_leg_start_times, par_swap_rates)]\n    pvs = np.array(np.repeat(0.0, len(mats)), dtype=dtype)\n    initial_curve_rates = np.array(np.repeat(0.01, len(mats)), dtype=dtype)\n    results = self.evaluate(tff.rates.swap_curve_bootstrap(float_leg_start_times, float_leg_end_times, fixed_leg_start_times, fixed_leg_end_times, fixed_leg_cashflows, pvs, dtype=dtype, initial_curve_rates=initial_curve_rates))\n    np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 30.0])\n    self.assertFalse(results.failed)\n    expected_discount_rates = np.array([0.02834814, 0.03077457, 0.03113739, 0.03130794, 0.03160892, 0.03213901, 0.03257991], dtype=dtype)\n    np.testing.assert_allclose(results.rates, expected_discount_rates, atol=1e-05)"
        ]
    }
]