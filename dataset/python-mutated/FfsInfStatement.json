[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    FfsInfStatementClassObject.__init__(self)\n    self.TargetOverrideList = []\n    self.ShadowFromInfFile = None\n    self.KeepRelocFromRule = None\n    self.InDsc = True\n    self.OptRomDefs = {}\n    self.PiSpecVersion = '0x00000000'\n    self.InfModule = None\n    self.FinalTargetSuffixMap = {}\n    self.CurrentLineNum = None\n    self.CurrentLineContent = None\n    self.FileName = None\n    self.InfFileName = None\n    self.OverrideGuid = None\n    self.PatchedBinFile = ''\n    self.MacroDict = {}\n    self.Depex = False",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    FfsInfStatementClassObject.__init__(self)\n    self.TargetOverrideList = []\n    self.ShadowFromInfFile = None\n    self.KeepRelocFromRule = None\n    self.InDsc = True\n    self.OptRomDefs = {}\n    self.PiSpecVersion = '0x00000000'\n    self.InfModule = None\n    self.FinalTargetSuffixMap = {}\n    self.CurrentLineNum = None\n    self.CurrentLineContent = None\n    self.FileName = None\n    self.InfFileName = None\n    self.OverrideGuid = None\n    self.PatchedBinFile = ''\n    self.MacroDict = {}\n    self.Depex = False",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FfsInfStatementClassObject.__init__(self)\n    self.TargetOverrideList = []\n    self.ShadowFromInfFile = None\n    self.KeepRelocFromRule = None\n    self.InDsc = True\n    self.OptRomDefs = {}\n    self.PiSpecVersion = '0x00000000'\n    self.InfModule = None\n    self.FinalTargetSuffixMap = {}\n    self.CurrentLineNum = None\n    self.CurrentLineContent = None\n    self.FileName = None\n    self.InfFileName = None\n    self.OverrideGuid = None\n    self.PatchedBinFile = ''\n    self.MacroDict = {}\n    self.Depex = False",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FfsInfStatementClassObject.__init__(self)\n    self.TargetOverrideList = []\n    self.ShadowFromInfFile = None\n    self.KeepRelocFromRule = None\n    self.InDsc = True\n    self.OptRomDefs = {}\n    self.PiSpecVersion = '0x00000000'\n    self.InfModule = None\n    self.FinalTargetSuffixMap = {}\n    self.CurrentLineNum = None\n    self.CurrentLineContent = None\n    self.FileName = None\n    self.InfFileName = None\n    self.OverrideGuid = None\n    self.PatchedBinFile = ''\n    self.MacroDict = {}\n    self.Depex = False",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FfsInfStatementClassObject.__init__(self)\n    self.TargetOverrideList = []\n    self.ShadowFromInfFile = None\n    self.KeepRelocFromRule = None\n    self.InDsc = True\n    self.OptRomDefs = {}\n    self.PiSpecVersion = '0x00000000'\n    self.InfModule = None\n    self.FinalTargetSuffixMap = {}\n    self.CurrentLineNum = None\n    self.CurrentLineContent = None\n    self.FileName = None\n    self.InfFileName = None\n    self.OverrideGuid = None\n    self.PatchedBinFile = ''\n    self.MacroDict = {}\n    self.Depex = False",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FfsInfStatementClassObject.__init__(self)\n    self.TargetOverrideList = []\n    self.ShadowFromInfFile = None\n    self.KeepRelocFromRule = None\n    self.InDsc = True\n    self.OptRomDefs = {}\n    self.PiSpecVersion = '0x00000000'\n    self.InfModule = None\n    self.FinalTargetSuffixMap = {}\n    self.CurrentLineNum = None\n    self.CurrentLineContent = None\n    self.FileName = None\n    self.InfFileName = None\n    self.OverrideGuid = None\n    self.PatchedBinFile = ''\n    self.MacroDict = {}\n    self.Depex = False"
        ]
    },
    {
        "func_name": "GetFinalTargetSuffixMap",
        "original": "def GetFinalTargetSuffixMap(self):\n    if not self.InfModule or not self.CurrentArch:\n        return []\n    if not self.FinalTargetSuffixMap:\n        FinalBuildTargetList = GenFdsGlobalVariable.GetModuleCodaTargetList(self.InfModule, self.CurrentArch)\n        for File in FinalBuildTargetList:\n            self.FinalTargetSuffixMap.setdefault(os.path.splitext(File)[1], []).append(File)\n        if '.depex' not in self.FinalTargetSuffixMap and self.InfModule.ModuleType != SUP_MODULE_USER_DEFINED and (self.InfModule.ModuleType != SUP_MODULE_HOST_APPLICATION) and (not self.InfModule.DxsFile) and (not self.InfModule.LibraryClass):\n            ModuleType = self.InfModule.ModuleType\n            PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n            if ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION:\n                for LibraryClass in PlatformDataBase.LibraryClasses.GetKeys():\n                    if LibraryClass.startswith('NULL') and PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]:\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]\n            StrModule = str(self.InfModule)\n            PlatformModule = None\n            if StrModule in PlatformDataBase.Modules:\n                PlatformModule = PlatformDataBase.Modules[StrModule]\n                for LibraryClass in PlatformModule.LibraryClasses:\n                    if LibraryClass.startswith('NULL'):\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformModule.LibraryClasses[LibraryClass]\n            DependencyList = [self.InfModule]\n            LibraryInstance = {}\n            DepexList = []\n            while len(DependencyList) > 0:\n                Module = DependencyList.pop(0)\n                if not Module:\n                    continue\n                for Dep in Module.Depex[self.CurrentArch, ModuleType]:\n                    if DepexList != []:\n                        DepexList.append('AND')\n                    DepexList.append('(')\n                    DepexList.extend(Dep)\n                    if DepexList[-1] == 'END':\n                        DepexList.pop()\n                    DepexList.append(')')\n                if 'BEFORE' in DepexList or 'AFTER' in DepexList:\n                    break\n                for LibName in Module.LibraryClasses:\n                    if LibName in LibraryInstance:\n                        continue\n                    if PlatformModule and LibName in PlatformModule.LibraryClasses:\n                        LibraryPath = PlatformModule.LibraryClasses[LibName]\n                    else:\n                        LibraryPath = PlatformDataBase.LibraryClasses[LibName, ModuleType]\n                    if not LibraryPath:\n                        LibraryPath = Module.LibraryClasses[LibName]\n                    if not LibraryPath:\n                        continue\n                    LibraryModule = GenFdsGlobalVariable.WorkSpace.BuildObject[LibraryPath, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n                    LibraryInstance[LibName] = LibraryModule\n                    DependencyList.append(LibraryModule)\n            if DepexList:\n                Dpx = DependencyExpression(DepexList, ModuleType, True)\n                if len(Dpx.PostfixNotation) != 0:\n                    self.FinalTargetSuffixMap['.depex'] = [os.path.join(self.EfiOutputPath, self.BaseName) + '.depex']\n    return self.FinalTargetSuffixMap",
        "mutated": [
            "def GetFinalTargetSuffixMap(self):\n    if False:\n        i = 10\n    if not self.InfModule or not self.CurrentArch:\n        return []\n    if not self.FinalTargetSuffixMap:\n        FinalBuildTargetList = GenFdsGlobalVariable.GetModuleCodaTargetList(self.InfModule, self.CurrentArch)\n        for File in FinalBuildTargetList:\n            self.FinalTargetSuffixMap.setdefault(os.path.splitext(File)[1], []).append(File)\n        if '.depex' not in self.FinalTargetSuffixMap and self.InfModule.ModuleType != SUP_MODULE_USER_DEFINED and (self.InfModule.ModuleType != SUP_MODULE_HOST_APPLICATION) and (not self.InfModule.DxsFile) and (not self.InfModule.LibraryClass):\n            ModuleType = self.InfModule.ModuleType\n            PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n            if ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION:\n                for LibraryClass in PlatformDataBase.LibraryClasses.GetKeys():\n                    if LibraryClass.startswith('NULL') and PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]:\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]\n            StrModule = str(self.InfModule)\n            PlatformModule = None\n            if StrModule in PlatformDataBase.Modules:\n                PlatformModule = PlatformDataBase.Modules[StrModule]\n                for LibraryClass in PlatformModule.LibraryClasses:\n                    if LibraryClass.startswith('NULL'):\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformModule.LibraryClasses[LibraryClass]\n            DependencyList = [self.InfModule]\n            LibraryInstance = {}\n            DepexList = []\n            while len(DependencyList) > 0:\n                Module = DependencyList.pop(0)\n                if not Module:\n                    continue\n                for Dep in Module.Depex[self.CurrentArch, ModuleType]:\n                    if DepexList != []:\n                        DepexList.append('AND')\n                    DepexList.append('(')\n                    DepexList.extend(Dep)\n                    if DepexList[-1] == 'END':\n                        DepexList.pop()\n                    DepexList.append(')')\n                if 'BEFORE' in DepexList or 'AFTER' in DepexList:\n                    break\n                for LibName in Module.LibraryClasses:\n                    if LibName in LibraryInstance:\n                        continue\n                    if PlatformModule and LibName in PlatformModule.LibraryClasses:\n                        LibraryPath = PlatformModule.LibraryClasses[LibName]\n                    else:\n                        LibraryPath = PlatformDataBase.LibraryClasses[LibName, ModuleType]\n                    if not LibraryPath:\n                        LibraryPath = Module.LibraryClasses[LibName]\n                    if not LibraryPath:\n                        continue\n                    LibraryModule = GenFdsGlobalVariable.WorkSpace.BuildObject[LibraryPath, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n                    LibraryInstance[LibName] = LibraryModule\n                    DependencyList.append(LibraryModule)\n            if DepexList:\n                Dpx = DependencyExpression(DepexList, ModuleType, True)\n                if len(Dpx.PostfixNotation) != 0:\n                    self.FinalTargetSuffixMap['.depex'] = [os.path.join(self.EfiOutputPath, self.BaseName) + '.depex']\n    return self.FinalTargetSuffixMap",
            "def GetFinalTargetSuffixMap(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not self.InfModule or not self.CurrentArch:\n        return []\n    if not self.FinalTargetSuffixMap:\n        FinalBuildTargetList = GenFdsGlobalVariable.GetModuleCodaTargetList(self.InfModule, self.CurrentArch)\n        for File in FinalBuildTargetList:\n            self.FinalTargetSuffixMap.setdefault(os.path.splitext(File)[1], []).append(File)\n        if '.depex' not in self.FinalTargetSuffixMap and self.InfModule.ModuleType != SUP_MODULE_USER_DEFINED and (self.InfModule.ModuleType != SUP_MODULE_HOST_APPLICATION) and (not self.InfModule.DxsFile) and (not self.InfModule.LibraryClass):\n            ModuleType = self.InfModule.ModuleType\n            PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n            if ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION:\n                for LibraryClass in PlatformDataBase.LibraryClasses.GetKeys():\n                    if LibraryClass.startswith('NULL') and PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]:\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]\n            StrModule = str(self.InfModule)\n            PlatformModule = None\n            if StrModule in PlatformDataBase.Modules:\n                PlatformModule = PlatformDataBase.Modules[StrModule]\n                for LibraryClass in PlatformModule.LibraryClasses:\n                    if LibraryClass.startswith('NULL'):\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformModule.LibraryClasses[LibraryClass]\n            DependencyList = [self.InfModule]\n            LibraryInstance = {}\n            DepexList = []\n            while len(DependencyList) > 0:\n                Module = DependencyList.pop(0)\n                if not Module:\n                    continue\n                for Dep in Module.Depex[self.CurrentArch, ModuleType]:\n                    if DepexList != []:\n                        DepexList.append('AND')\n                    DepexList.append('(')\n                    DepexList.extend(Dep)\n                    if DepexList[-1] == 'END':\n                        DepexList.pop()\n                    DepexList.append(')')\n                if 'BEFORE' in DepexList or 'AFTER' in DepexList:\n                    break\n                for LibName in Module.LibraryClasses:\n                    if LibName in LibraryInstance:\n                        continue\n                    if PlatformModule and LibName in PlatformModule.LibraryClasses:\n                        LibraryPath = PlatformModule.LibraryClasses[LibName]\n                    else:\n                        LibraryPath = PlatformDataBase.LibraryClasses[LibName, ModuleType]\n                    if not LibraryPath:\n                        LibraryPath = Module.LibraryClasses[LibName]\n                    if not LibraryPath:\n                        continue\n                    LibraryModule = GenFdsGlobalVariable.WorkSpace.BuildObject[LibraryPath, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n                    LibraryInstance[LibName] = LibraryModule\n                    DependencyList.append(LibraryModule)\n            if DepexList:\n                Dpx = DependencyExpression(DepexList, ModuleType, True)\n                if len(Dpx.PostfixNotation) != 0:\n                    self.FinalTargetSuffixMap['.depex'] = [os.path.join(self.EfiOutputPath, self.BaseName) + '.depex']\n    return self.FinalTargetSuffixMap",
            "def GetFinalTargetSuffixMap(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not self.InfModule or not self.CurrentArch:\n        return []\n    if not self.FinalTargetSuffixMap:\n        FinalBuildTargetList = GenFdsGlobalVariable.GetModuleCodaTargetList(self.InfModule, self.CurrentArch)\n        for File in FinalBuildTargetList:\n            self.FinalTargetSuffixMap.setdefault(os.path.splitext(File)[1], []).append(File)\n        if '.depex' not in self.FinalTargetSuffixMap and self.InfModule.ModuleType != SUP_MODULE_USER_DEFINED and (self.InfModule.ModuleType != SUP_MODULE_HOST_APPLICATION) and (not self.InfModule.DxsFile) and (not self.InfModule.LibraryClass):\n            ModuleType = self.InfModule.ModuleType\n            PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n            if ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION:\n                for LibraryClass in PlatformDataBase.LibraryClasses.GetKeys():\n                    if LibraryClass.startswith('NULL') and PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]:\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]\n            StrModule = str(self.InfModule)\n            PlatformModule = None\n            if StrModule in PlatformDataBase.Modules:\n                PlatformModule = PlatformDataBase.Modules[StrModule]\n                for LibraryClass in PlatformModule.LibraryClasses:\n                    if LibraryClass.startswith('NULL'):\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformModule.LibraryClasses[LibraryClass]\n            DependencyList = [self.InfModule]\n            LibraryInstance = {}\n            DepexList = []\n            while len(DependencyList) > 0:\n                Module = DependencyList.pop(0)\n                if not Module:\n                    continue\n                for Dep in Module.Depex[self.CurrentArch, ModuleType]:\n                    if DepexList != []:\n                        DepexList.append('AND')\n                    DepexList.append('(')\n                    DepexList.extend(Dep)\n                    if DepexList[-1] == 'END':\n                        DepexList.pop()\n                    DepexList.append(')')\n                if 'BEFORE' in DepexList or 'AFTER' in DepexList:\n                    break\n                for LibName in Module.LibraryClasses:\n                    if LibName in LibraryInstance:\n                        continue\n                    if PlatformModule and LibName in PlatformModule.LibraryClasses:\n                        LibraryPath = PlatformModule.LibraryClasses[LibName]\n                    else:\n                        LibraryPath = PlatformDataBase.LibraryClasses[LibName, ModuleType]\n                    if not LibraryPath:\n                        LibraryPath = Module.LibraryClasses[LibName]\n                    if not LibraryPath:\n                        continue\n                    LibraryModule = GenFdsGlobalVariable.WorkSpace.BuildObject[LibraryPath, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n                    LibraryInstance[LibName] = LibraryModule\n                    DependencyList.append(LibraryModule)\n            if DepexList:\n                Dpx = DependencyExpression(DepexList, ModuleType, True)\n                if len(Dpx.PostfixNotation) != 0:\n                    self.FinalTargetSuffixMap['.depex'] = [os.path.join(self.EfiOutputPath, self.BaseName) + '.depex']\n    return self.FinalTargetSuffixMap",
            "def GetFinalTargetSuffixMap(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not self.InfModule or not self.CurrentArch:\n        return []\n    if not self.FinalTargetSuffixMap:\n        FinalBuildTargetList = GenFdsGlobalVariable.GetModuleCodaTargetList(self.InfModule, self.CurrentArch)\n        for File in FinalBuildTargetList:\n            self.FinalTargetSuffixMap.setdefault(os.path.splitext(File)[1], []).append(File)\n        if '.depex' not in self.FinalTargetSuffixMap and self.InfModule.ModuleType != SUP_MODULE_USER_DEFINED and (self.InfModule.ModuleType != SUP_MODULE_HOST_APPLICATION) and (not self.InfModule.DxsFile) and (not self.InfModule.LibraryClass):\n            ModuleType = self.InfModule.ModuleType\n            PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n            if ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION:\n                for LibraryClass in PlatformDataBase.LibraryClasses.GetKeys():\n                    if LibraryClass.startswith('NULL') and PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]:\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]\n            StrModule = str(self.InfModule)\n            PlatformModule = None\n            if StrModule in PlatformDataBase.Modules:\n                PlatformModule = PlatformDataBase.Modules[StrModule]\n                for LibraryClass in PlatformModule.LibraryClasses:\n                    if LibraryClass.startswith('NULL'):\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformModule.LibraryClasses[LibraryClass]\n            DependencyList = [self.InfModule]\n            LibraryInstance = {}\n            DepexList = []\n            while len(DependencyList) > 0:\n                Module = DependencyList.pop(0)\n                if not Module:\n                    continue\n                for Dep in Module.Depex[self.CurrentArch, ModuleType]:\n                    if DepexList != []:\n                        DepexList.append('AND')\n                    DepexList.append('(')\n                    DepexList.extend(Dep)\n                    if DepexList[-1] == 'END':\n                        DepexList.pop()\n                    DepexList.append(')')\n                if 'BEFORE' in DepexList or 'AFTER' in DepexList:\n                    break\n                for LibName in Module.LibraryClasses:\n                    if LibName in LibraryInstance:\n                        continue\n                    if PlatformModule and LibName in PlatformModule.LibraryClasses:\n                        LibraryPath = PlatformModule.LibraryClasses[LibName]\n                    else:\n                        LibraryPath = PlatformDataBase.LibraryClasses[LibName, ModuleType]\n                    if not LibraryPath:\n                        LibraryPath = Module.LibraryClasses[LibName]\n                    if not LibraryPath:\n                        continue\n                    LibraryModule = GenFdsGlobalVariable.WorkSpace.BuildObject[LibraryPath, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n                    LibraryInstance[LibName] = LibraryModule\n                    DependencyList.append(LibraryModule)\n            if DepexList:\n                Dpx = DependencyExpression(DepexList, ModuleType, True)\n                if len(Dpx.PostfixNotation) != 0:\n                    self.FinalTargetSuffixMap['.depex'] = [os.path.join(self.EfiOutputPath, self.BaseName) + '.depex']\n    return self.FinalTargetSuffixMap",
            "def GetFinalTargetSuffixMap(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not self.InfModule or not self.CurrentArch:\n        return []\n    if not self.FinalTargetSuffixMap:\n        FinalBuildTargetList = GenFdsGlobalVariable.GetModuleCodaTargetList(self.InfModule, self.CurrentArch)\n        for File in FinalBuildTargetList:\n            self.FinalTargetSuffixMap.setdefault(os.path.splitext(File)[1], []).append(File)\n        if '.depex' not in self.FinalTargetSuffixMap and self.InfModule.ModuleType != SUP_MODULE_USER_DEFINED and (self.InfModule.ModuleType != SUP_MODULE_HOST_APPLICATION) and (not self.InfModule.DxsFile) and (not self.InfModule.LibraryClass):\n            ModuleType = self.InfModule.ModuleType\n            PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n            if ModuleType != SUP_MODULE_USER_DEFINED and ModuleType != SUP_MODULE_HOST_APPLICATION:\n                for LibraryClass in PlatformDataBase.LibraryClasses.GetKeys():\n                    if LibraryClass.startswith('NULL') and PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]:\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformDataBase.LibraryClasses[LibraryClass, ModuleType]\n            StrModule = str(self.InfModule)\n            PlatformModule = None\n            if StrModule in PlatformDataBase.Modules:\n                PlatformModule = PlatformDataBase.Modules[StrModule]\n                for LibraryClass in PlatformModule.LibraryClasses:\n                    if LibraryClass.startswith('NULL'):\n                        self.InfModule.LibraryClasses[LibraryClass] = PlatformModule.LibraryClasses[LibraryClass]\n            DependencyList = [self.InfModule]\n            LibraryInstance = {}\n            DepexList = []\n            while len(DependencyList) > 0:\n                Module = DependencyList.pop(0)\n                if not Module:\n                    continue\n                for Dep in Module.Depex[self.CurrentArch, ModuleType]:\n                    if DepexList != []:\n                        DepexList.append('AND')\n                    DepexList.append('(')\n                    DepexList.extend(Dep)\n                    if DepexList[-1] == 'END':\n                        DepexList.pop()\n                    DepexList.append(')')\n                if 'BEFORE' in DepexList or 'AFTER' in DepexList:\n                    break\n                for LibName in Module.LibraryClasses:\n                    if LibName in LibraryInstance:\n                        continue\n                    if PlatformModule and LibName in PlatformModule.LibraryClasses:\n                        LibraryPath = PlatformModule.LibraryClasses[LibName]\n                    else:\n                        LibraryPath = PlatformDataBase.LibraryClasses[LibName, ModuleType]\n                    if not LibraryPath:\n                        LibraryPath = Module.LibraryClasses[LibName]\n                    if not LibraryPath:\n                        continue\n                    LibraryModule = GenFdsGlobalVariable.WorkSpace.BuildObject[LibraryPath, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n                    LibraryInstance[LibName] = LibraryModule\n                    DependencyList.append(LibraryModule)\n            if DepexList:\n                Dpx = DependencyExpression(DepexList, ModuleType, True)\n                if len(Dpx.PostfixNotation) != 0:\n                    self.FinalTargetSuffixMap['.depex'] = [os.path.join(self.EfiOutputPath, self.BaseName) + '.depex']\n    return self.FinalTargetSuffixMap"
        ]
    },
    {
        "func_name": "__InfParse__",
        "original": "def __InfParse__(self, Dict=None, IsGenFfs=False):\n    GenFdsGlobalVariable.VerboseLogger(' Begine parsing INf file : %s' % self.InfFileName)\n    self.InfFileName = self.InfFileName.replace('$(WORKSPACE)', '')\n    if len(self.InfFileName) > 1 and self.InfFileName[0] == '\\\\' and (self.InfFileName[1] == '\\\\'):\n        pass\n    elif self.InfFileName[0] == '\\\\' or self.InfFileName[0] == '/':\n        self.InfFileName = self.InfFileName[1:]\n    if self.InfFileName.find('$') == -1:\n        InfPath = NormPath(self.InfFileName)\n        if not os.path.exists(InfPath):\n            InfPath = GenFdsGlobalVariable.ReplaceWorkspaceMacro(InfPath)\n            if not os.path.exists(InfPath):\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'Non-existant Module %s !' % self.InfFileName)\n    self.CurrentArch = self.GetCurrentArch()\n    PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n    (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n    if ErrorCode != 0:\n        EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    InfLowerPath = str(PathClassObj).lower()\n    if self.OverrideGuid:\n        PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n    if self.CurrentArch is not None:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        if Inf.AutoGenVersion < 65541:\n            self.ModuleType = Inf.ComponentType\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.KeepReloc is None and Inf.Shadow:\n            self.ShadowFromInfFile = Inf.Shadow\n    else:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, TAB_COMMON, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.BinFileList == []:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'INF %s specified in FDF could not be found in build ARCH %s!' % (self.InfFileName, GenFdsGlobalVariable.ArchList))\n    if self.OverrideGuid:\n        self.ModuleGuid = self.OverrideGuid\n    if len(self.SourceFileList) != 0 and (not self.InDsc):\n        EdkLogger.warn('GenFds', GENFDS_ERROR, 'Module %s NOT found in DSC file; Is it really a binary module?' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_SMM_CORE and int(self.PiSpecVersion, 16) < 65546:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"SMM_CORE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x0001000A\", File=self.InfFileName)\n    if self.ModuleType == SUP_MODULE_MM_CORE_STANDALONE and int(self.PiSpecVersion, 16) < 65586:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"MM_CORE_STANDALONE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x00010032\", File=self.InfFileName)\n    if Inf._Defs is not None and len(Inf._Defs) > 0:\n        self.OptRomDefs.update(Inf._Defs)\n    self.PatchPcds = []\n    InfPcds = Inf.Pcds\n    Platform = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n    FdfPcdDict = GenFdsGlobalVariable.FdfParser.Profile.PcdDict\n    PlatformPcds = Platform.Pcds\n    DscModules = {}\n    for DscModule in Platform.Modules:\n        DscModules[str(DscModule).lower()] = Platform.Modules[DscModule]\n    for PcdKey in InfPcds:\n        Pcd = InfPcds[PcdKey]\n        if not hasattr(Pcd, 'Offset'):\n            continue\n        if Pcd.Type != TAB_PCDS_PATCHABLE_IN_MODULE:\n            continue\n        PatchPcd = None\n        if InfLowerPath in DscModules and PcdKey in DscModules[InfLowerPath].Pcds:\n            PatchPcd = DscModules[InfLowerPath].Pcds[PcdKey]\n        elif PcdKey in Platform.Pcds:\n            PatchPcd = Platform.Pcds[PcdKey]\n        DscOverride = False\n        if PatchPcd and Pcd.Type == PatchPcd.Type:\n            DefaultValue = PatchPcd.DefaultValue\n            DscOverride = True\n        FdfOverride = False\n        if PcdKey in FdfPcdDict:\n            DefaultValue = FdfPcdDict[PcdKey]\n            FdfOverride = True\n        BuildOptionOverride = False\n        if GlobalData.BuildOptionPcd:\n            for pcd in GlobalData.BuildOptionPcd:\n                if PcdKey == (pcd[1], pcd[0]):\n                    if pcd[2]:\n                        continue\n                    DefaultValue = pcd[3]\n                    BuildOptionOverride = True\n                    break\n        if not DscOverride and (not FdfOverride) and (not BuildOptionOverride):\n            continue\n        if DefaultValue:\n            try:\n                DefaultValue = ValueExpressionEx(DefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValue), File=self.InfFileName)\n        if Pcd.InfDefaultValue:\n            try:\n                Pcd.InfDefaultValue = ValueExpressionEx(Pcd.InfDefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DefaultValue), File=self.InfFileName)\n        if Pcd.DatumType == TAB_VOID:\n            if Pcd.InfDefaultValue == DefaultValue or not DefaultValue:\n                continue\n            if DefaultValue[0] == 'L':\n                MaxDatumSize = str((len(DefaultValue) - 2) * 2)\n            elif DefaultValue[0] == '{':\n                MaxDatumSize = str(len(DefaultValue.split(',')))\n            else:\n                MaxDatumSize = str(len(DefaultValue) - 1)\n            if DscOverride:\n                Pcd.MaxDatumSize = PatchPcd.MaxDatumSize\n            if not Pcd.MaxDatumSize:\n                Pcd.MaxDatumSize = str(len(Pcd.InfDefaultValue.split(',')))\n        else:\n            Base1 = Base2 = 10\n            if Pcd.InfDefaultValue.upper().startswith('0X'):\n                Base1 = 16\n            if DefaultValue.upper().startswith('0X'):\n                Base2 = 16\n            try:\n                PcdValueInImg = int(Pcd.InfDefaultValue, Base1)\n                PcdValueInDscOrFdf = int(DefaultValue, Base2)\n                if PcdValueInImg == PcdValueInDscOrFdf:\n                    continue\n            except:\n                continue\n        if Pcd.DatumType == TAB_VOID:\n            if int(MaxDatumSize) > int(Pcd.MaxDatumSize):\n                EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of VOID* type PCD '%s.%s' exceeds its maximum size %d bytes.\" % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, int(MaxDatumSize) - int(Pcd.MaxDatumSize)))\n        elif PcdValueInDscOrFdf > MAX_VAL_TYPE[Pcd.DatumType] or PcdValueInImg > MAX_VAL_TYPE[Pcd.DatumType]:\n            EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of %s type PCD '%s.%s' doesn't match its data type.\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        self.PatchPcds.append((Pcd, DefaultValue))\n    self.InfModule = Inf\n    self.PcdIsDriver = Inf.PcdIsDriver\n    self.IsBinaryModule = Inf.IsBinaryModule\n    if len(Inf.Depex.data) > 0 and len(Inf.DepexExpression.data) > 0:\n        self.Depex = True\n    GenFdsGlobalVariable.VerboseLogger('BaseName : %s' % self.BaseName)\n    GenFdsGlobalVariable.VerboseLogger('ModuleGuid : %s' % self.ModuleGuid)\n    GenFdsGlobalVariable.VerboseLogger('ModuleType : %s' % self.ModuleType)\n    GenFdsGlobalVariable.VerboseLogger('VersionString : %s' % self.VersionString)\n    GenFdsGlobalVariable.VerboseLogger('InfFileName :%s' % self.InfFileName)\n    if IsGenFfs:\n        Rule = self.__GetRule__()\n        if GlobalData.gGuidPatternEnd.match(Rule.NameGuid):\n            self.ModuleGuid = Rule.NameGuid\n    self.OutputPath = os.path.join(GenFdsGlobalVariable.FfsDir, self.ModuleGuid + self.BaseName)\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    (self.EfiOutputPath, self.EfiDebugPath) = self.__GetEFIOutPutPath__()\n    GenFdsGlobalVariable.VerboseLogger('ModuelEFIPath: ' + self.EfiOutputPath)",
        "mutated": [
            "def __InfParse__(self, Dict=None, IsGenFfs=False):\n    if False:\n        i = 10\n    GenFdsGlobalVariable.VerboseLogger(' Begine parsing INf file : %s' % self.InfFileName)\n    self.InfFileName = self.InfFileName.replace('$(WORKSPACE)', '')\n    if len(self.InfFileName) > 1 and self.InfFileName[0] == '\\\\' and (self.InfFileName[1] == '\\\\'):\n        pass\n    elif self.InfFileName[0] == '\\\\' or self.InfFileName[0] == '/':\n        self.InfFileName = self.InfFileName[1:]\n    if self.InfFileName.find('$') == -1:\n        InfPath = NormPath(self.InfFileName)\n        if not os.path.exists(InfPath):\n            InfPath = GenFdsGlobalVariable.ReplaceWorkspaceMacro(InfPath)\n            if not os.path.exists(InfPath):\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'Non-existant Module %s !' % self.InfFileName)\n    self.CurrentArch = self.GetCurrentArch()\n    PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n    (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n    if ErrorCode != 0:\n        EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    InfLowerPath = str(PathClassObj).lower()\n    if self.OverrideGuid:\n        PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n    if self.CurrentArch is not None:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        if Inf.AutoGenVersion < 65541:\n            self.ModuleType = Inf.ComponentType\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.KeepReloc is None and Inf.Shadow:\n            self.ShadowFromInfFile = Inf.Shadow\n    else:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, TAB_COMMON, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.BinFileList == []:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'INF %s specified in FDF could not be found in build ARCH %s!' % (self.InfFileName, GenFdsGlobalVariable.ArchList))\n    if self.OverrideGuid:\n        self.ModuleGuid = self.OverrideGuid\n    if len(self.SourceFileList) != 0 and (not self.InDsc):\n        EdkLogger.warn('GenFds', GENFDS_ERROR, 'Module %s NOT found in DSC file; Is it really a binary module?' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_SMM_CORE and int(self.PiSpecVersion, 16) < 65546:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"SMM_CORE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x0001000A\", File=self.InfFileName)\n    if self.ModuleType == SUP_MODULE_MM_CORE_STANDALONE and int(self.PiSpecVersion, 16) < 65586:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"MM_CORE_STANDALONE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x00010032\", File=self.InfFileName)\n    if Inf._Defs is not None and len(Inf._Defs) > 0:\n        self.OptRomDefs.update(Inf._Defs)\n    self.PatchPcds = []\n    InfPcds = Inf.Pcds\n    Platform = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n    FdfPcdDict = GenFdsGlobalVariable.FdfParser.Profile.PcdDict\n    PlatformPcds = Platform.Pcds\n    DscModules = {}\n    for DscModule in Platform.Modules:\n        DscModules[str(DscModule).lower()] = Platform.Modules[DscModule]\n    for PcdKey in InfPcds:\n        Pcd = InfPcds[PcdKey]\n        if not hasattr(Pcd, 'Offset'):\n            continue\n        if Pcd.Type != TAB_PCDS_PATCHABLE_IN_MODULE:\n            continue\n        PatchPcd = None\n        if InfLowerPath in DscModules and PcdKey in DscModules[InfLowerPath].Pcds:\n            PatchPcd = DscModules[InfLowerPath].Pcds[PcdKey]\n        elif PcdKey in Platform.Pcds:\n            PatchPcd = Platform.Pcds[PcdKey]\n        DscOverride = False\n        if PatchPcd and Pcd.Type == PatchPcd.Type:\n            DefaultValue = PatchPcd.DefaultValue\n            DscOverride = True\n        FdfOverride = False\n        if PcdKey in FdfPcdDict:\n            DefaultValue = FdfPcdDict[PcdKey]\n            FdfOverride = True\n        BuildOptionOverride = False\n        if GlobalData.BuildOptionPcd:\n            for pcd in GlobalData.BuildOptionPcd:\n                if PcdKey == (pcd[1], pcd[0]):\n                    if pcd[2]:\n                        continue\n                    DefaultValue = pcd[3]\n                    BuildOptionOverride = True\n                    break\n        if not DscOverride and (not FdfOverride) and (not BuildOptionOverride):\n            continue\n        if DefaultValue:\n            try:\n                DefaultValue = ValueExpressionEx(DefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValue), File=self.InfFileName)\n        if Pcd.InfDefaultValue:\n            try:\n                Pcd.InfDefaultValue = ValueExpressionEx(Pcd.InfDefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DefaultValue), File=self.InfFileName)\n        if Pcd.DatumType == TAB_VOID:\n            if Pcd.InfDefaultValue == DefaultValue or not DefaultValue:\n                continue\n            if DefaultValue[0] == 'L':\n                MaxDatumSize = str((len(DefaultValue) - 2) * 2)\n            elif DefaultValue[0] == '{':\n                MaxDatumSize = str(len(DefaultValue.split(',')))\n            else:\n                MaxDatumSize = str(len(DefaultValue) - 1)\n            if DscOverride:\n                Pcd.MaxDatumSize = PatchPcd.MaxDatumSize\n            if not Pcd.MaxDatumSize:\n                Pcd.MaxDatumSize = str(len(Pcd.InfDefaultValue.split(',')))\n        else:\n            Base1 = Base2 = 10\n            if Pcd.InfDefaultValue.upper().startswith('0X'):\n                Base1 = 16\n            if DefaultValue.upper().startswith('0X'):\n                Base2 = 16\n            try:\n                PcdValueInImg = int(Pcd.InfDefaultValue, Base1)\n                PcdValueInDscOrFdf = int(DefaultValue, Base2)\n                if PcdValueInImg == PcdValueInDscOrFdf:\n                    continue\n            except:\n                continue\n        if Pcd.DatumType == TAB_VOID:\n            if int(MaxDatumSize) > int(Pcd.MaxDatumSize):\n                EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of VOID* type PCD '%s.%s' exceeds its maximum size %d bytes.\" % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, int(MaxDatumSize) - int(Pcd.MaxDatumSize)))\n        elif PcdValueInDscOrFdf > MAX_VAL_TYPE[Pcd.DatumType] or PcdValueInImg > MAX_VAL_TYPE[Pcd.DatumType]:\n            EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of %s type PCD '%s.%s' doesn't match its data type.\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        self.PatchPcds.append((Pcd, DefaultValue))\n    self.InfModule = Inf\n    self.PcdIsDriver = Inf.PcdIsDriver\n    self.IsBinaryModule = Inf.IsBinaryModule\n    if len(Inf.Depex.data) > 0 and len(Inf.DepexExpression.data) > 0:\n        self.Depex = True\n    GenFdsGlobalVariable.VerboseLogger('BaseName : %s' % self.BaseName)\n    GenFdsGlobalVariable.VerboseLogger('ModuleGuid : %s' % self.ModuleGuid)\n    GenFdsGlobalVariable.VerboseLogger('ModuleType : %s' % self.ModuleType)\n    GenFdsGlobalVariable.VerboseLogger('VersionString : %s' % self.VersionString)\n    GenFdsGlobalVariable.VerboseLogger('InfFileName :%s' % self.InfFileName)\n    if IsGenFfs:\n        Rule = self.__GetRule__()\n        if GlobalData.gGuidPatternEnd.match(Rule.NameGuid):\n            self.ModuleGuid = Rule.NameGuid\n    self.OutputPath = os.path.join(GenFdsGlobalVariable.FfsDir, self.ModuleGuid + self.BaseName)\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    (self.EfiOutputPath, self.EfiDebugPath) = self.__GetEFIOutPutPath__()\n    GenFdsGlobalVariable.VerboseLogger('ModuelEFIPath: ' + self.EfiOutputPath)",
            "def __InfParse__(self, Dict=None, IsGenFfs=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    GenFdsGlobalVariable.VerboseLogger(' Begine parsing INf file : %s' % self.InfFileName)\n    self.InfFileName = self.InfFileName.replace('$(WORKSPACE)', '')\n    if len(self.InfFileName) > 1 and self.InfFileName[0] == '\\\\' and (self.InfFileName[1] == '\\\\'):\n        pass\n    elif self.InfFileName[0] == '\\\\' or self.InfFileName[0] == '/':\n        self.InfFileName = self.InfFileName[1:]\n    if self.InfFileName.find('$') == -1:\n        InfPath = NormPath(self.InfFileName)\n        if not os.path.exists(InfPath):\n            InfPath = GenFdsGlobalVariable.ReplaceWorkspaceMacro(InfPath)\n            if not os.path.exists(InfPath):\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'Non-existant Module %s !' % self.InfFileName)\n    self.CurrentArch = self.GetCurrentArch()\n    PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n    (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n    if ErrorCode != 0:\n        EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    InfLowerPath = str(PathClassObj).lower()\n    if self.OverrideGuid:\n        PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n    if self.CurrentArch is not None:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        if Inf.AutoGenVersion < 65541:\n            self.ModuleType = Inf.ComponentType\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.KeepReloc is None and Inf.Shadow:\n            self.ShadowFromInfFile = Inf.Shadow\n    else:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, TAB_COMMON, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.BinFileList == []:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'INF %s specified in FDF could not be found in build ARCH %s!' % (self.InfFileName, GenFdsGlobalVariable.ArchList))\n    if self.OverrideGuid:\n        self.ModuleGuid = self.OverrideGuid\n    if len(self.SourceFileList) != 0 and (not self.InDsc):\n        EdkLogger.warn('GenFds', GENFDS_ERROR, 'Module %s NOT found in DSC file; Is it really a binary module?' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_SMM_CORE and int(self.PiSpecVersion, 16) < 65546:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"SMM_CORE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x0001000A\", File=self.InfFileName)\n    if self.ModuleType == SUP_MODULE_MM_CORE_STANDALONE and int(self.PiSpecVersion, 16) < 65586:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"MM_CORE_STANDALONE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x00010032\", File=self.InfFileName)\n    if Inf._Defs is not None and len(Inf._Defs) > 0:\n        self.OptRomDefs.update(Inf._Defs)\n    self.PatchPcds = []\n    InfPcds = Inf.Pcds\n    Platform = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n    FdfPcdDict = GenFdsGlobalVariable.FdfParser.Profile.PcdDict\n    PlatformPcds = Platform.Pcds\n    DscModules = {}\n    for DscModule in Platform.Modules:\n        DscModules[str(DscModule).lower()] = Platform.Modules[DscModule]\n    for PcdKey in InfPcds:\n        Pcd = InfPcds[PcdKey]\n        if not hasattr(Pcd, 'Offset'):\n            continue\n        if Pcd.Type != TAB_PCDS_PATCHABLE_IN_MODULE:\n            continue\n        PatchPcd = None\n        if InfLowerPath in DscModules and PcdKey in DscModules[InfLowerPath].Pcds:\n            PatchPcd = DscModules[InfLowerPath].Pcds[PcdKey]\n        elif PcdKey in Platform.Pcds:\n            PatchPcd = Platform.Pcds[PcdKey]\n        DscOverride = False\n        if PatchPcd and Pcd.Type == PatchPcd.Type:\n            DefaultValue = PatchPcd.DefaultValue\n            DscOverride = True\n        FdfOverride = False\n        if PcdKey in FdfPcdDict:\n            DefaultValue = FdfPcdDict[PcdKey]\n            FdfOverride = True\n        BuildOptionOverride = False\n        if GlobalData.BuildOptionPcd:\n            for pcd in GlobalData.BuildOptionPcd:\n                if PcdKey == (pcd[1], pcd[0]):\n                    if pcd[2]:\n                        continue\n                    DefaultValue = pcd[3]\n                    BuildOptionOverride = True\n                    break\n        if not DscOverride and (not FdfOverride) and (not BuildOptionOverride):\n            continue\n        if DefaultValue:\n            try:\n                DefaultValue = ValueExpressionEx(DefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValue), File=self.InfFileName)\n        if Pcd.InfDefaultValue:\n            try:\n                Pcd.InfDefaultValue = ValueExpressionEx(Pcd.InfDefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DefaultValue), File=self.InfFileName)\n        if Pcd.DatumType == TAB_VOID:\n            if Pcd.InfDefaultValue == DefaultValue or not DefaultValue:\n                continue\n            if DefaultValue[0] == 'L':\n                MaxDatumSize = str((len(DefaultValue) - 2) * 2)\n            elif DefaultValue[0] == '{':\n                MaxDatumSize = str(len(DefaultValue.split(',')))\n            else:\n                MaxDatumSize = str(len(DefaultValue) - 1)\n            if DscOverride:\n                Pcd.MaxDatumSize = PatchPcd.MaxDatumSize\n            if not Pcd.MaxDatumSize:\n                Pcd.MaxDatumSize = str(len(Pcd.InfDefaultValue.split(',')))\n        else:\n            Base1 = Base2 = 10\n            if Pcd.InfDefaultValue.upper().startswith('0X'):\n                Base1 = 16\n            if DefaultValue.upper().startswith('0X'):\n                Base2 = 16\n            try:\n                PcdValueInImg = int(Pcd.InfDefaultValue, Base1)\n                PcdValueInDscOrFdf = int(DefaultValue, Base2)\n                if PcdValueInImg == PcdValueInDscOrFdf:\n                    continue\n            except:\n                continue\n        if Pcd.DatumType == TAB_VOID:\n            if int(MaxDatumSize) > int(Pcd.MaxDatumSize):\n                EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of VOID* type PCD '%s.%s' exceeds its maximum size %d bytes.\" % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, int(MaxDatumSize) - int(Pcd.MaxDatumSize)))\n        elif PcdValueInDscOrFdf > MAX_VAL_TYPE[Pcd.DatumType] or PcdValueInImg > MAX_VAL_TYPE[Pcd.DatumType]:\n            EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of %s type PCD '%s.%s' doesn't match its data type.\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        self.PatchPcds.append((Pcd, DefaultValue))\n    self.InfModule = Inf\n    self.PcdIsDriver = Inf.PcdIsDriver\n    self.IsBinaryModule = Inf.IsBinaryModule\n    if len(Inf.Depex.data) > 0 and len(Inf.DepexExpression.data) > 0:\n        self.Depex = True\n    GenFdsGlobalVariable.VerboseLogger('BaseName : %s' % self.BaseName)\n    GenFdsGlobalVariable.VerboseLogger('ModuleGuid : %s' % self.ModuleGuid)\n    GenFdsGlobalVariable.VerboseLogger('ModuleType : %s' % self.ModuleType)\n    GenFdsGlobalVariable.VerboseLogger('VersionString : %s' % self.VersionString)\n    GenFdsGlobalVariable.VerboseLogger('InfFileName :%s' % self.InfFileName)\n    if IsGenFfs:\n        Rule = self.__GetRule__()\n        if GlobalData.gGuidPatternEnd.match(Rule.NameGuid):\n            self.ModuleGuid = Rule.NameGuid\n    self.OutputPath = os.path.join(GenFdsGlobalVariable.FfsDir, self.ModuleGuid + self.BaseName)\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    (self.EfiOutputPath, self.EfiDebugPath) = self.__GetEFIOutPutPath__()\n    GenFdsGlobalVariable.VerboseLogger('ModuelEFIPath: ' + self.EfiOutputPath)",
            "def __InfParse__(self, Dict=None, IsGenFfs=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    GenFdsGlobalVariable.VerboseLogger(' Begine parsing INf file : %s' % self.InfFileName)\n    self.InfFileName = self.InfFileName.replace('$(WORKSPACE)', '')\n    if len(self.InfFileName) > 1 and self.InfFileName[0] == '\\\\' and (self.InfFileName[1] == '\\\\'):\n        pass\n    elif self.InfFileName[0] == '\\\\' or self.InfFileName[0] == '/':\n        self.InfFileName = self.InfFileName[1:]\n    if self.InfFileName.find('$') == -1:\n        InfPath = NormPath(self.InfFileName)\n        if not os.path.exists(InfPath):\n            InfPath = GenFdsGlobalVariable.ReplaceWorkspaceMacro(InfPath)\n            if not os.path.exists(InfPath):\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'Non-existant Module %s !' % self.InfFileName)\n    self.CurrentArch = self.GetCurrentArch()\n    PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n    (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n    if ErrorCode != 0:\n        EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    InfLowerPath = str(PathClassObj).lower()\n    if self.OverrideGuid:\n        PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n    if self.CurrentArch is not None:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        if Inf.AutoGenVersion < 65541:\n            self.ModuleType = Inf.ComponentType\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.KeepReloc is None and Inf.Shadow:\n            self.ShadowFromInfFile = Inf.Shadow\n    else:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, TAB_COMMON, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.BinFileList == []:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'INF %s specified in FDF could not be found in build ARCH %s!' % (self.InfFileName, GenFdsGlobalVariable.ArchList))\n    if self.OverrideGuid:\n        self.ModuleGuid = self.OverrideGuid\n    if len(self.SourceFileList) != 0 and (not self.InDsc):\n        EdkLogger.warn('GenFds', GENFDS_ERROR, 'Module %s NOT found in DSC file; Is it really a binary module?' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_SMM_CORE and int(self.PiSpecVersion, 16) < 65546:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"SMM_CORE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x0001000A\", File=self.InfFileName)\n    if self.ModuleType == SUP_MODULE_MM_CORE_STANDALONE and int(self.PiSpecVersion, 16) < 65586:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"MM_CORE_STANDALONE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x00010032\", File=self.InfFileName)\n    if Inf._Defs is not None and len(Inf._Defs) > 0:\n        self.OptRomDefs.update(Inf._Defs)\n    self.PatchPcds = []\n    InfPcds = Inf.Pcds\n    Platform = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n    FdfPcdDict = GenFdsGlobalVariable.FdfParser.Profile.PcdDict\n    PlatformPcds = Platform.Pcds\n    DscModules = {}\n    for DscModule in Platform.Modules:\n        DscModules[str(DscModule).lower()] = Platform.Modules[DscModule]\n    for PcdKey in InfPcds:\n        Pcd = InfPcds[PcdKey]\n        if not hasattr(Pcd, 'Offset'):\n            continue\n        if Pcd.Type != TAB_PCDS_PATCHABLE_IN_MODULE:\n            continue\n        PatchPcd = None\n        if InfLowerPath in DscModules and PcdKey in DscModules[InfLowerPath].Pcds:\n            PatchPcd = DscModules[InfLowerPath].Pcds[PcdKey]\n        elif PcdKey in Platform.Pcds:\n            PatchPcd = Platform.Pcds[PcdKey]\n        DscOverride = False\n        if PatchPcd and Pcd.Type == PatchPcd.Type:\n            DefaultValue = PatchPcd.DefaultValue\n            DscOverride = True\n        FdfOverride = False\n        if PcdKey in FdfPcdDict:\n            DefaultValue = FdfPcdDict[PcdKey]\n            FdfOverride = True\n        BuildOptionOverride = False\n        if GlobalData.BuildOptionPcd:\n            for pcd in GlobalData.BuildOptionPcd:\n                if PcdKey == (pcd[1], pcd[0]):\n                    if pcd[2]:\n                        continue\n                    DefaultValue = pcd[3]\n                    BuildOptionOverride = True\n                    break\n        if not DscOverride and (not FdfOverride) and (not BuildOptionOverride):\n            continue\n        if DefaultValue:\n            try:\n                DefaultValue = ValueExpressionEx(DefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValue), File=self.InfFileName)\n        if Pcd.InfDefaultValue:\n            try:\n                Pcd.InfDefaultValue = ValueExpressionEx(Pcd.InfDefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DefaultValue), File=self.InfFileName)\n        if Pcd.DatumType == TAB_VOID:\n            if Pcd.InfDefaultValue == DefaultValue or not DefaultValue:\n                continue\n            if DefaultValue[0] == 'L':\n                MaxDatumSize = str((len(DefaultValue) - 2) * 2)\n            elif DefaultValue[0] == '{':\n                MaxDatumSize = str(len(DefaultValue.split(',')))\n            else:\n                MaxDatumSize = str(len(DefaultValue) - 1)\n            if DscOverride:\n                Pcd.MaxDatumSize = PatchPcd.MaxDatumSize\n            if not Pcd.MaxDatumSize:\n                Pcd.MaxDatumSize = str(len(Pcd.InfDefaultValue.split(',')))\n        else:\n            Base1 = Base2 = 10\n            if Pcd.InfDefaultValue.upper().startswith('0X'):\n                Base1 = 16\n            if DefaultValue.upper().startswith('0X'):\n                Base2 = 16\n            try:\n                PcdValueInImg = int(Pcd.InfDefaultValue, Base1)\n                PcdValueInDscOrFdf = int(DefaultValue, Base2)\n                if PcdValueInImg == PcdValueInDscOrFdf:\n                    continue\n            except:\n                continue\n        if Pcd.DatumType == TAB_VOID:\n            if int(MaxDatumSize) > int(Pcd.MaxDatumSize):\n                EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of VOID* type PCD '%s.%s' exceeds its maximum size %d bytes.\" % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, int(MaxDatumSize) - int(Pcd.MaxDatumSize)))\n        elif PcdValueInDscOrFdf > MAX_VAL_TYPE[Pcd.DatumType] or PcdValueInImg > MAX_VAL_TYPE[Pcd.DatumType]:\n            EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of %s type PCD '%s.%s' doesn't match its data type.\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        self.PatchPcds.append((Pcd, DefaultValue))\n    self.InfModule = Inf\n    self.PcdIsDriver = Inf.PcdIsDriver\n    self.IsBinaryModule = Inf.IsBinaryModule\n    if len(Inf.Depex.data) > 0 and len(Inf.DepexExpression.data) > 0:\n        self.Depex = True\n    GenFdsGlobalVariable.VerboseLogger('BaseName : %s' % self.BaseName)\n    GenFdsGlobalVariable.VerboseLogger('ModuleGuid : %s' % self.ModuleGuid)\n    GenFdsGlobalVariable.VerboseLogger('ModuleType : %s' % self.ModuleType)\n    GenFdsGlobalVariable.VerboseLogger('VersionString : %s' % self.VersionString)\n    GenFdsGlobalVariable.VerboseLogger('InfFileName :%s' % self.InfFileName)\n    if IsGenFfs:\n        Rule = self.__GetRule__()\n        if GlobalData.gGuidPatternEnd.match(Rule.NameGuid):\n            self.ModuleGuid = Rule.NameGuid\n    self.OutputPath = os.path.join(GenFdsGlobalVariable.FfsDir, self.ModuleGuid + self.BaseName)\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    (self.EfiOutputPath, self.EfiDebugPath) = self.__GetEFIOutPutPath__()\n    GenFdsGlobalVariable.VerboseLogger('ModuelEFIPath: ' + self.EfiOutputPath)",
            "def __InfParse__(self, Dict=None, IsGenFfs=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    GenFdsGlobalVariable.VerboseLogger(' Begine parsing INf file : %s' % self.InfFileName)\n    self.InfFileName = self.InfFileName.replace('$(WORKSPACE)', '')\n    if len(self.InfFileName) > 1 and self.InfFileName[0] == '\\\\' and (self.InfFileName[1] == '\\\\'):\n        pass\n    elif self.InfFileName[0] == '\\\\' or self.InfFileName[0] == '/':\n        self.InfFileName = self.InfFileName[1:]\n    if self.InfFileName.find('$') == -1:\n        InfPath = NormPath(self.InfFileName)\n        if not os.path.exists(InfPath):\n            InfPath = GenFdsGlobalVariable.ReplaceWorkspaceMacro(InfPath)\n            if not os.path.exists(InfPath):\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'Non-existant Module %s !' % self.InfFileName)\n    self.CurrentArch = self.GetCurrentArch()\n    PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n    (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n    if ErrorCode != 0:\n        EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    InfLowerPath = str(PathClassObj).lower()\n    if self.OverrideGuid:\n        PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n    if self.CurrentArch is not None:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        if Inf.AutoGenVersion < 65541:\n            self.ModuleType = Inf.ComponentType\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.KeepReloc is None and Inf.Shadow:\n            self.ShadowFromInfFile = Inf.Shadow\n    else:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, TAB_COMMON, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.BinFileList == []:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'INF %s specified in FDF could not be found in build ARCH %s!' % (self.InfFileName, GenFdsGlobalVariable.ArchList))\n    if self.OverrideGuid:\n        self.ModuleGuid = self.OverrideGuid\n    if len(self.SourceFileList) != 0 and (not self.InDsc):\n        EdkLogger.warn('GenFds', GENFDS_ERROR, 'Module %s NOT found in DSC file; Is it really a binary module?' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_SMM_CORE and int(self.PiSpecVersion, 16) < 65546:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"SMM_CORE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x0001000A\", File=self.InfFileName)\n    if self.ModuleType == SUP_MODULE_MM_CORE_STANDALONE and int(self.PiSpecVersion, 16) < 65586:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"MM_CORE_STANDALONE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x00010032\", File=self.InfFileName)\n    if Inf._Defs is not None and len(Inf._Defs) > 0:\n        self.OptRomDefs.update(Inf._Defs)\n    self.PatchPcds = []\n    InfPcds = Inf.Pcds\n    Platform = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n    FdfPcdDict = GenFdsGlobalVariable.FdfParser.Profile.PcdDict\n    PlatformPcds = Platform.Pcds\n    DscModules = {}\n    for DscModule in Platform.Modules:\n        DscModules[str(DscModule).lower()] = Platform.Modules[DscModule]\n    for PcdKey in InfPcds:\n        Pcd = InfPcds[PcdKey]\n        if not hasattr(Pcd, 'Offset'):\n            continue\n        if Pcd.Type != TAB_PCDS_PATCHABLE_IN_MODULE:\n            continue\n        PatchPcd = None\n        if InfLowerPath in DscModules and PcdKey in DscModules[InfLowerPath].Pcds:\n            PatchPcd = DscModules[InfLowerPath].Pcds[PcdKey]\n        elif PcdKey in Platform.Pcds:\n            PatchPcd = Platform.Pcds[PcdKey]\n        DscOverride = False\n        if PatchPcd and Pcd.Type == PatchPcd.Type:\n            DefaultValue = PatchPcd.DefaultValue\n            DscOverride = True\n        FdfOverride = False\n        if PcdKey in FdfPcdDict:\n            DefaultValue = FdfPcdDict[PcdKey]\n            FdfOverride = True\n        BuildOptionOverride = False\n        if GlobalData.BuildOptionPcd:\n            for pcd in GlobalData.BuildOptionPcd:\n                if PcdKey == (pcd[1], pcd[0]):\n                    if pcd[2]:\n                        continue\n                    DefaultValue = pcd[3]\n                    BuildOptionOverride = True\n                    break\n        if not DscOverride and (not FdfOverride) and (not BuildOptionOverride):\n            continue\n        if DefaultValue:\n            try:\n                DefaultValue = ValueExpressionEx(DefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValue), File=self.InfFileName)\n        if Pcd.InfDefaultValue:\n            try:\n                Pcd.InfDefaultValue = ValueExpressionEx(Pcd.InfDefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DefaultValue), File=self.InfFileName)\n        if Pcd.DatumType == TAB_VOID:\n            if Pcd.InfDefaultValue == DefaultValue or not DefaultValue:\n                continue\n            if DefaultValue[0] == 'L':\n                MaxDatumSize = str((len(DefaultValue) - 2) * 2)\n            elif DefaultValue[0] == '{':\n                MaxDatumSize = str(len(DefaultValue.split(',')))\n            else:\n                MaxDatumSize = str(len(DefaultValue) - 1)\n            if DscOverride:\n                Pcd.MaxDatumSize = PatchPcd.MaxDatumSize\n            if not Pcd.MaxDatumSize:\n                Pcd.MaxDatumSize = str(len(Pcd.InfDefaultValue.split(',')))\n        else:\n            Base1 = Base2 = 10\n            if Pcd.InfDefaultValue.upper().startswith('0X'):\n                Base1 = 16\n            if DefaultValue.upper().startswith('0X'):\n                Base2 = 16\n            try:\n                PcdValueInImg = int(Pcd.InfDefaultValue, Base1)\n                PcdValueInDscOrFdf = int(DefaultValue, Base2)\n                if PcdValueInImg == PcdValueInDscOrFdf:\n                    continue\n            except:\n                continue\n        if Pcd.DatumType == TAB_VOID:\n            if int(MaxDatumSize) > int(Pcd.MaxDatumSize):\n                EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of VOID* type PCD '%s.%s' exceeds its maximum size %d bytes.\" % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, int(MaxDatumSize) - int(Pcd.MaxDatumSize)))\n        elif PcdValueInDscOrFdf > MAX_VAL_TYPE[Pcd.DatumType] or PcdValueInImg > MAX_VAL_TYPE[Pcd.DatumType]:\n            EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of %s type PCD '%s.%s' doesn't match its data type.\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        self.PatchPcds.append((Pcd, DefaultValue))\n    self.InfModule = Inf\n    self.PcdIsDriver = Inf.PcdIsDriver\n    self.IsBinaryModule = Inf.IsBinaryModule\n    if len(Inf.Depex.data) > 0 and len(Inf.DepexExpression.data) > 0:\n        self.Depex = True\n    GenFdsGlobalVariable.VerboseLogger('BaseName : %s' % self.BaseName)\n    GenFdsGlobalVariable.VerboseLogger('ModuleGuid : %s' % self.ModuleGuid)\n    GenFdsGlobalVariable.VerboseLogger('ModuleType : %s' % self.ModuleType)\n    GenFdsGlobalVariable.VerboseLogger('VersionString : %s' % self.VersionString)\n    GenFdsGlobalVariable.VerboseLogger('InfFileName :%s' % self.InfFileName)\n    if IsGenFfs:\n        Rule = self.__GetRule__()\n        if GlobalData.gGuidPatternEnd.match(Rule.NameGuid):\n            self.ModuleGuid = Rule.NameGuid\n    self.OutputPath = os.path.join(GenFdsGlobalVariable.FfsDir, self.ModuleGuid + self.BaseName)\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    (self.EfiOutputPath, self.EfiDebugPath) = self.__GetEFIOutPutPath__()\n    GenFdsGlobalVariable.VerboseLogger('ModuelEFIPath: ' + self.EfiOutputPath)",
            "def __InfParse__(self, Dict=None, IsGenFfs=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    GenFdsGlobalVariable.VerboseLogger(' Begine parsing INf file : %s' % self.InfFileName)\n    self.InfFileName = self.InfFileName.replace('$(WORKSPACE)', '')\n    if len(self.InfFileName) > 1 and self.InfFileName[0] == '\\\\' and (self.InfFileName[1] == '\\\\'):\n        pass\n    elif self.InfFileName[0] == '\\\\' or self.InfFileName[0] == '/':\n        self.InfFileName = self.InfFileName[1:]\n    if self.InfFileName.find('$') == -1:\n        InfPath = NormPath(self.InfFileName)\n        if not os.path.exists(InfPath):\n            InfPath = GenFdsGlobalVariable.ReplaceWorkspaceMacro(InfPath)\n            if not os.path.exists(InfPath):\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'Non-existant Module %s !' % self.InfFileName)\n    self.CurrentArch = self.GetCurrentArch()\n    PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n    (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n    if ErrorCode != 0:\n        EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    InfLowerPath = str(PathClassObj).lower()\n    if self.OverrideGuid:\n        PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n    if self.CurrentArch is not None:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        if Inf.AutoGenVersion < 65541:\n            self.ModuleType = Inf.ComponentType\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.KeepReloc is None and Inf.Shadow:\n            self.ShadowFromInfFile = Inf.Shadow\n    else:\n        Inf = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClassObj, TAB_COMMON, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        self.BaseName = Inf.BaseName\n        self.ModuleGuid = Inf.Guid\n        self.ModuleType = Inf.ModuleType\n        if Inf.Specification is not None and 'PI_SPECIFICATION_VERSION' in Inf.Specification:\n            self.PiSpecVersion = Inf.Specification['PI_SPECIFICATION_VERSION']\n        self.VersionString = Inf.Version\n        self.BinFileList = Inf.Binaries\n        self.SourceFileList = Inf.Sources\n        if self.BinFileList == []:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'INF %s specified in FDF could not be found in build ARCH %s!' % (self.InfFileName, GenFdsGlobalVariable.ArchList))\n    if self.OverrideGuid:\n        self.ModuleGuid = self.OverrideGuid\n    if len(self.SourceFileList) != 0 and (not self.InDsc):\n        EdkLogger.warn('GenFds', GENFDS_ERROR, 'Module %s NOT found in DSC file; Is it really a binary module?' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_SMM_CORE and int(self.PiSpecVersion, 16) < 65546:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"SMM_CORE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x0001000A\", File=self.InfFileName)\n    if self.ModuleType == SUP_MODULE_MM_CORE_STANDALONE and int(self.PiSpecVersion, 16) < 65586:\n        EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"MM_CORE_STANDALONE module type can't be used in the module with PI_SPECIFICATION_VERSION less than 0x00010032\", File=self.InfFileName)\n    if Inf._Defs is not None and len(Inf._Defs) > 0:\n        self.OptRomDefs.update(Inf._Defs)\n    self.PatchPcds = []\n    InfPcds = Inf.Pcds\n    Platform = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, self.CurrentArch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n    FdfPcdDict = GenFdsGlobalVariable.FdfParser.Profile.PcdDict\n    PlatformPcds = Platform.Pcds\n    DscModules = {}\n    for DscModule in Platform.Modules:\n        DscModules[str(DscModule).lower()] = Platform.Modules[DscModule]\n    for PcdKey in InfPcds:\n        Pcd = InfPcds[PcdKey]\n        if not hasattr(Pcd, 'Offset'):\n            continue\n        if Pcd.Type != TAB_PCDS_PATCHABLE_IN_MODULE:\n            continue\n        PatchPcd = None\n        if InfLowerPath in DscModules and PcdKey in DscModules[InfLowerPath].Pcds:\n            PatchPcd = DscModules[InfLowerPath].Pcds[PcdKey]\n        elif PcdKey in Platform.Pcds:\n            PatchPcd = Platform.Pcds[PcdKey]\n        DscOverride = False\n        if PatchPcd and Pcd.Type == PatchPcd.Type:\n            DefaultValue = PatchPcd.DefaultValue\n            DscOverride = True\n        FdfOverride = False\n        if PcdKey in FdfPcdDict:\n            DefaultValue = FdfPcdDict[PcdKey]\n            FdfOverride = True\n        BuildOptionOverride = False\n        if GlobalData.BuildOptionPcd:\n            for pcd in GlobalData.BuildOptionPcd:\n                if PcdKey == (pcd[1], pcd[0]):\n                    if pcd[2]:\n                        continue\n                    DefaultValue = pcd[3]\n                    BuildOptionOverride = True\n                    break\n        if not DscOverride and (not FdfOverride) and (not BuildOptionOverride):\n            continue\n        if DefaultValue:\n            try:\n                DefaultValue = ValueExpressionEx(DefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValue), File=self.InfFileName)\n        if Pcd.InfDefaultValue:\n            try:\n                Pcd.InfDefaultValue = ValueExpressionEx(Pcd.InfDefaultValue, Pcd.DatumType, Platform._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('GenFds', GENFDS_ERROR, 'PCD [%s.%s] Value \"%s\"' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DefaultValue), File=self.InfFileName)\n        if Pcd.DatumType == TAB_VOID:\n            if Pcd.InfDefaultValue == DefaultValue or not DefaultValue:\n                continue\n            if DefaultValue[0] == 'L':\n                MaxDatumSize = str((len(DefaultValue) - 2) * 2)\n            elif DefaultValue[0] == '{':\n                MaxDatumSize = str(len(DefaultValue.split(',')))\n            else:\n                MaxDatumSize = str(len(DefaultValue) - 1)\n            if DscOverride:\n                Pcd.MaxDatumSize = PatchPcd.MaxDatumSize\n            if not Pcd.MaxDatumSize:\n                Pcd.MaxDatumSize = str(len(Pcd.InfDefaultValue.split(',')))\n        else:\n            Base1 = Base2 = 10\n            if Pcd.InfDefaultValue.upper().startswith('0X'):\n                Base1 = 16\n            if DefaultValue.upper().startswith('0X'):\n                Base2 = 16\n            try:\n                PcdValueInImg = int(Pcd.InfDefaultValue, Base1)\n                PcdValueInDscOrFdf = int(DefaultValue, Base2)\n                if PcdValueInImg == PcdValueInDscOrFdf:\n                    continue\n            except:\n                continue\n        if Pcd.DatumType == TAB_VOID:\n            if int(MaxDatumSize) > int(Pcd.MaxDatumSize):\n                EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of VOID* type PCD '%s.%s' exceeds its maximum size %d bytes.\" % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, int(MaxDatumSize) - int(Pcd.MaxDatumSize)))\n        elif PcdValueInDscOrFdf > MAX_VAL_TYPE[Pcd.DatumType] or PcdValueInImg > MAX_VAL_TYPE[Pcd.DatumType]:\n            EdkLogger.error('GenFds', GENFDS_ERROR, \"The size of %s type PCD '%s.%s' doesn't match its data type.\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        self.PatchPcds.append((Pcd, DefaultValue))\n    self.InfModule = Inf\n    self.PcdIsDriver = Inf.PcdIsDriver\n    self.IsBinaryModule = Inf.IsBinaryModule\n    if len(Inf.Depex.data) > 0 and len(Inf.DepexExpression.data) > 0:\n        self.Depex = True\n    GenFdsGlobalVariable.VerboseLogger('BaseName : %s' % self.BaseName)\n    GenFdsGlobalVariable.VerboseLogger('ModuleGuid : %s' % self.ModuleGuid)\n    GenFdsGlobalVariable.VerboseLogger('ModuleType : %s' % self.ModuleType)\n    GenFdsGlobalVariable.VerboseLogger('VersionString : %s' % self.VersionString)\n    GenFdsGlobalVariable.VerboseLogger('InfFileName :%s' % self.InfFileName)\n    if IsGenFfs:\n        Rule = self.__GetRule__()\n        if GlobalData.gGuidPatternEnd.match(Rule.NameGuid):\n            self.ModuleGuid = Rule.NameGuid\n    self.OutputPath = os.path.join(GenFdsGlobalVariable.FfsDir, self.ModuleGuid + self.BaseName)\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    (self.EfiOutputPath, self.EfiDebugPath) = self.__GetEFIOutPutPath__()\n    GenFdsGlobalVariable.VerboseLogger('ModuelEFIPath: ' + self.EfiOutputPath)"
        ]
    },
    {
        "func_name": "PatchEfiFile",
        "original": "def PatchEfiFile(self, EfiFile, FileType):\n    if not self.PatchPcds:\n        return EfiFile\n    if FileType != BINARY_FILE_TYPE_PE32 and self.ModuleType != SUP_MODULE_USER_DEFINED and (self.ModuleType != SUP_MODULE_HOST_APPLICATION):\n        return EfiFile\n    Basename = os.path.basename(EfiFile)\n    Output = os.path.normpath(os.path.join(self.OutputPath, Basename))\n    if self.PatchedBinFile == Output:\n        return Output\n    if self.PatchedBinFile:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Only one binary file can be patched:\\n  a binary file has been patched: %s\\n  current file: %s' % (self.PatchedBinFile, EfiFile), File=self.InfFileName)\n    CopyLongFilePath(EfiFile, Output)\n    for (Pcd, Value) in self.PatchPcds:\n        (RetVal, RetStr) = PatchBinaryFile(Output, int(Pcd.Offset, 0), Pcd.DatumType, Value, Pcd.MaxDatumSize)\n        if RetVal:\n            EdkLogger.error('GenFds', GENFDS_ERROR, RetStr, File=self.InfFileName)\n    self.PatchedBinFile = Output\n    return Output",
        "mutated": [
            "def PatchEfiFile(self, EfiFile, FileType):\n    if False:\n        i = 10\n    if not self.PatchPcds:\n        return EfiFile\n    if FileType != BINARY_FILE_TYPE_PE32 and self.ModuleType != SUP_MODULE_USER_DEFINED and (self.ModuleType != SUP_MODULE_HOST_APPLICATION):\n        return EfiFile\n    Basename = os.path.basename(EfiFile)\n    Output = os.path.normpath(os.path.join(self.OutputPath, Basename))\n    if self.PatchedBinFile == Output:\n        return Output\n    if self.PatchedBinFile:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Only one binary file can be patched:\\n  a binary file has been patched: %s\\n  current file: %s' % (self.PatchedBinFile, EfiFile), File=self.InfFileName)\n    CopyLongFilePath(EfiFile, Output)\n    for (Pcd, Value) in self.PatchPcds:\n        (RetVal, RetStr) = PatchBinaryFile(Output, int(Pcd.Offset, 0), Pcd.DatumType, Value, Pcd.MaxDatumSize)\n        if RetVal:\n            EdkLogger.error('GenFds', GENFDS_ERROR, RetStr, File=self.InfFileName)\n    self.PatchedBinFile = Output\n    return Output",
            "def PatchEfiFile(self, EfiFile, FileType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not self.PatchPcds:\n        return EfiFile\n    if FileType != BINARY_FILE_TYPE_PE32 and self.ModuleType != SUP_MODULE_USER_DEFINED and (self.ModuleType != SUP_MODULE_HOST_APPLICATION):\n        return EfiFile\n    Basename = os.path.basename(EfiFile)\n    Output = os.path.normpath(os.path.join(self.OutputPath, Basename))\n    if self.PatchedBinFile == Output:\n        return Output\n    if self.PatchedBinFile:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Only one binary file can be patched:\\n  a binary file has been patched: %s\\n  current file: %s' % (self.PatchedBinFile, EfiFile), File=self.InfFileName)\n    CopyLongFilePath(EfiFile, Output)\n    for (Pcd, Value) in self.PatchPcds:\n        (RetVal, RetStr) = PatchBinaryFile(Output, int(Pcd.Offset, 0), Pcd.DatumType, Value, Pcd.MaxDatumSize)\n        if RetVal:\n            EdkLogger.error('GenFds', GENFDS_ERROR, RetStr, File=self.InfFileName)\n    self.PatchedBinFile = Output\n    return Output",
            "def PatchEfiFile(self, EfiFile, FileType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not self.PatchPcds:\n        return EfiFile\n    if FileType != BINARY_FILE_TYPE_PE32 and self.ModuleType != SUP_MODULE_USER_DEFINED and (self.ModuleType != SUP_MODULE_HOST_APPLICATION):\n        return EfiFile\n    Basename = os.path.basename(EfiFile)\n    Output = os.path.normpath(os.path.join(self.OutputPath, Basename))\n    if self.PatchedBinFile == Output:\n        return Output\n    if self.PatchedBinFile:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Only one binary file can be patched:\\n  a binary file has been patched: %s\\n  current file: %s' % (self.PatchedBinFile, EfiFile), File=self.InfFileName)\n    CopyLongFilePath(EfiFile, Output)\n    for (Pcd, Value) in self.PatchPcds:\n        (RetVal, RetStr) = PatchBinaryFile(Output, int(Pcd.Offset, 0), Pcd.DatumType, Value, Pcd.MaxDatumSize)\n        if RetVal:\n            EdkLogger.error('GenFds', GENFDS_ERROR, RetStr, File=self.InfFileName)\n    self.PatchedBinFile = Output\n    return Output",
            "def PatchEfiFile(self, EfiFile, FileType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not self.PatchPcds:\n        return EfiFile\n    if FileType != BINARY_FILE_TYPE_PE32 and self.ModuleType != SUP_MODULE_USER_DEFINED and (self.ModuleType != SUP_MODULE_HOST_APPLICATION):\n        return EfiFile\n    Basename = os.path.basename(EfiFile)\n    Output = os.path.normpath(os.path.join(self.OutputPath, Basename))\n    if self.PatchedBinFile == Output:\n        return Output\n    if self.PatchedBinFile:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Only one binary file can be patched:\\n  a binary file has been patched: %s\\n  current file: %s' % (self.PatchedBinFile, EfiFile), File=self.InfFileName)\n    CopyLongFilePath(EfiFile, Output)\n    for (Pcd, Value) in self.PatchPcds:\n        (RetVal, RetStr) = PatchBinaryFile(Output, int(Pcd.Offset, 0), Pcd.DatumType, Value, Pcd.MaxDatumSize)\n        if RetVal:\n            EdkLogger.error('GenFds', GENFDS_ERROR, RetStr, File=self.InfFileName)\n    self.PatchedBinFile = Output\n    return Output",
            "def PatchEfiFile(self, EfiFile, FileType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not self.PatchPcds:\n        return EfiFile\n    if FileType != BINARY_FILE_TYPE_PE32 and self.ModuleType != SUP_MODULE_USER_DEFINED and (self.ModuleType != SUP_MODULE_HOST_APPLICATION):\n        return EfiFile\n    Basename = os.path.basename(EfiFile)\n    Output = os.path.normpath(os.path.join(self.OutputPath, Basename))\n    if self.PatchedBinFile == Output:\n        return Output\n    if self.PatchedBinFile:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Only one binary file can be patched:\\n  a binary file has been patched: %s\\n  current file: %s' % (self.PatchedBinFile, EfiFile), File=self.InfFileName)\n    CopyLongFilePath(EfiFile, Output)\n    for (Pcd, Value) in self.PatchPcds:\n        (RetVal, RetStr) = PatchBinaryFile(Output, int(Pcd.Offset, 0), Pcd.DatumType, Value, Pcd.MaxDatumSize)\n        if RetVal:\n            EdkLogger.error('GenFds', GENFDS_ERROR, RetStr, File=self.InfFileName)\n    self.PatchedBinFile = Output\n    return Output"
        ]
    },
    {
        "func_name": "GenFfs",
        "original": "def GenFfs(self, Dict=None, FvChildAddr=[], FvParentAddr=None, IsMakefile=False, FvName=None):\n    if Dict is None:\n        Dict = {}\n    self.__InfParse__(Dict, IsGenFfs=True)\n    Arch = self.GetCurrentArch()\n    SrcFile = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n    DestFile = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    SrcFileDir = '.'\n    SrcPath = os.path.dirname(SrcFile)\n    SrcFileName = os.path.basename(SrcFile)\n    (SrcFileBase, SrcFileExt) = os.path.splitext(SrcFileName)\n    DestPath = os.path.dirname(DestFile)\n    DestFileName = os.path.basename(DestFile)\n    (DestFileBase, DestFileExt) = os.path.splitext(DestFileName)\n    self.MacroDict = {'${src}': SrcFile, '${s_path}': SrcPath, '${s_dir}': SrcFileDir, '${s_name}': SrcFileName, '${s_base}': SrcFileBase, '${s_ext}': SrcFileExt, '${dst}': DestFile, '${d_path}': DestPath, '${d_name}': DestFileName, '${d_base}': DestFileBase, '${d_ext}': DestFileExt}\n    if len(self.BinFileList) > 0:\n        if self.Rule is None or self.Rule == '':\n            self.Rule = 'BINARY'\n    if not IsMakefile and GenFdsGlobalVariable.EnableGenfdsMultiThread and (self.Rule != 'BINARY'):\n        IsMakefile = True\n    Rule = self.__GetRule__()\n    GenFdsGlobalVariable.VerboseLogger('Packing binaries from inf file : %s' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if Rule.FvFileType == 'DRIVER':\n            Rule.FvFileType = 'SMM'\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if Rule.FvFileType == 'SMM' or Rule.FvFileType == SUP_MODULE_SMM_CORE:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM or SMM_CORE FV file type\", File=self.InfFileName)\n    MakefilePath = None\n    if self.IsBinaryModule:\n        IsMakefile = False\n    if IsMakefile:\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        if self.OverrideGuid:\n            PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n        MakefilePath = (PathClassObj.Path, Arch)\n    if isinstance(Rule, RuleSimpleFile.RuleSimpleFile):\n        SectionOutputList = self.__GenSimpleFileSection__(Rule, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenSimpleFileFfs__(Rule, SectionOutputList, MakefilePath=MakefilePath)\n        return FfsOutput\n    elif isinstance(Rule, RuleComplexFile.RuleComplexFile):\n        (InputSectList, InputSectAlignments) = self.__GenComplexFileSection__(Rule, FvChildAddr, FvParentAddr, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenComplexFileFfs__(Rule, InputSectList, InputSectAlignments, MakefilePath=MakefilePath)\n        return FfsOutput",
        "mutated": [
            "def GenFfs(self, Dict=None, FvChildAddr=[], FvParentAddr=None, IsMakefile=False, FvName=None):\n    if False:\n        i = 10\n    if Dict is None:\n        Dict = {}\n    self.__InfParse__(Dict, IsGenFfs=True)\n    Arch = self.GetCurrentArch()\n    SrcFile = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n    DestFile = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    SrcFileDir = '.'\n    SrcPath = os.path.dirname(SrcFile)\n    SrcFileName = os.path.basename(SrcFile)\n    (SrcFileBase, SrcFileExt) = os.path.splitext(SrcFileName)\n    DestPath = os.path.dirname(DestFile)\n    DestFileName = os.path.basename(DestFile)\n    (DestFileBase, DestFileExt) = os.path.splitext(DestFileName)\n    self.MacroDict = {'${src}': SrcFile, '${s_path}': SrcPath, '${s_dir}': SrcFileDir, '${s_name}': SrcFileName, '${s_base}': SrcFileBase, '${s_ext}': SrcFileExt, '${dst}': DestFile, '${d_path}': DestPath, '${d_name}': DestFileName, '${d_base}': DestFileBase, '${d_ext}': DestFileExt}\n    if len(self.BinFileList) > 0:\n        if self.Rule is None or self.Rule == '':\n            self.Rule = 'BINARY'\n    if not IsMakefile and GenFdsGlobalVariable.EnableGenfdsMultiThread and (self.Rule != 'BINARY'):\n        IsMakefile = True\n    Rule = self.__GetRule__()\n    GenFdsGlobalVariable.VerboseLogger('Packing binaries from inf file : %s' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if Rule.FvFileType == 'DRIVER':\n            Rule.FvFileType = 'SMM'\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if Rule.FvFileType == 'SMM' or Rule.FvFileType == SUP_MODULE_SMM_CORE:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM or SMM_CORE FV file type\", File=self.InfFileName)\n    MakefilePath = None\n    if self.IsBinaryModule:\n        IsMakefile = False\n    if IsMakefile:\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        if self.OverrideGuid:\n            PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n        MakefilePath = (PathClassObj.Path, Arch)\n    if isinstance(Rule, RuleSimpleFile.RuleSimpleFile):\n        SectionOutputList = self.__GenSimpleFileSection__(Rule, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenSimpleFileFfs__(Rule, SectionOutputList, MakefilePath=MakefilePath)\n        return FfsOutput\n    elif isinstance(Rule, RuleComplexFile.RuleComplexFile):\n        (InputSectList, InputSectAlignments) = self.__GenComplexFileSection__(Rule, FvChildAddr, FvParentAddr, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenComplexFileFfs__(Rule, InputSectList, InputSectAlignments, MakefilePath=MakefilePath)\n        return FfsOutput",
            "def GenFfs(self, Dict=None, FvChildAddr=[], FvParentAddr=None, IsMakefile=False, FvName=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Dict is None:\n        Dict = {}\n    self.__InfParse__(Dict, IsGenFfs=True)\n    Arch = self.GetCurrentArch()\n    SrcFile = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n    DestFile = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    SrcFileDir = '.'\n    SrcPath = os.path.dirname(SrcFile)\n    SrcFileName = os.path.basename(SrcFile)\n    (SrcFileBase, SrcFileExt) = os.path.splitext(SrcFileName)\n    DestPath = os.path.dirname(DestFile)\n    DestFileName = os.path.basename(DestFile)\n    (DestFileBase, DestFileExt) = os.path.splitext(DestFileName)\n    self.MacroDict = {'${src}': SrcFile, '${s_path}': SrcPath, '${s_dir}': SrcFileDir, '${s_name}': SrcFileName, '${s_base}': SrcFileBase, '${s_ext}': SrcFileExt, '${dst}': DestFile, '${d_path}': DestPath, '${d_name}': DestFileName, '${d_base}': DestFileBase, '${d_ext}': DestFileExt}\n    if len(self.BinFileList) > 0:\n        if self.Rule is None or self.Rule == '':\n            self.Rule = 'BINARY'\n    if not IsMakefile and GenFdsGlobalVariable.EnableGenfdsMultiThread and (self.Rule != 'BINARY'):\n        IsMakefile = True\n    Rule = self.__GetRule__()\n    GenFdsGlobalVariable.VerboseLogger('Packing binaries from inf file : %s' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if Rule.FvFileType == 'DRIVER':\n            Rule.FvFileType = 'SMM'\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if Rule.FvFileType == 'SMM' or Rule.FvFileType == SUP_MODULE_SMM_CORE:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM or SMM_CORE FV file type\", File=self.InfFileName)\n    MakefilePath = None\n    if self.IsBinaryModule:\n        IsMakefile = False\n    if IsMakefile:\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        if self.OverrideGuid:\n            PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n        MakefilePath = (PathClassObj.Path, Arch)\n    if isinstance(Rule, RuleSimpleFile.RuleSimpleFile):\n        SectionOutputList = self.__GenSimpleFileSection__(Rule, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenSimpleFileFfs__(Rule, SectionOutputList, MakefilePath=MakefilePath)\n        return FfsOutput\n    elif isinstance(Rule, RuleComplexFile.RuleComplexFile):\n        (InputSectList, InputSectAlignments) = self.__GenComplexFileSection__(Rule, FvChildAddr, FvParentAddr, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenComplexFileFfs__(Rule, InputSectList, InputSectAlignments, MakefilePath=MakefilePath)\n        return FfsOutput",
            "def GenFfs(self, Dict=None, FvChildAddr=[], FvParentAddr=None, IsMakefile=False, FvName=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Dict is None:\n        Dict = {}\n    self.__InfParse__(Dict, IsGenFfs=True)\n    Arch = self.GetCurrentArch()\n    SrcFile = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n    DestFile = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    SrcFileDir = '.'\n    SrcPath = os.path.dirname(SrcFile)\n    SrcFileName = os.path.basename(SrcFile)\n    (SrcFileBase, SrcFileExt) = os.path.splitext(SrcFileName)\n    DestPath = os.path.dirname(DestFile)\n    DestFileName = os.path.basename(DestFile)\n    (DestFileBase, DestFileExt) = os.path.splitext(DestFileName)\n    self.MacroDict = {'${src}': SrcFile, '${s_path}': SrcPath, '${s_dir}': SrcFileDir, '${s_name}': SrcFileName, '${s_base}': SrcFileBase, '${s_ext}': SrcFileExt, '${dst}': DestFile, '${d_path}': DestPath, '${d_name}': DestFileName, '${d_base}': DestFileBase, '${d_ext}': DestFileExt}\n    if len(self.BinFileList) > 0:\n        if self.Rule is None or self.Rule == '':\n            self.Rule = 'BINARY'\n    if not IsMakefile and GenFdsGlobalVariable.EnableGenfdsMultiThread and (self.Rule != 'BINARY'):\n        IsMakefile = True\n    Rule = self.__GetRule__()\n    GenFdsGlobalVariable.VerboseLogger('Packing binaries from inf file : %s' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if Rule.FvFileType == 'DRIVER':\n            Rule.FvFileType = 'SMM'\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if Rule.FvFileType == 'SMM' or Rule.FvFileType == SUP_MODULE_SMM_CORE:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM or SMM_CORE FV file type\", File=self.InfFileName)\n    MakefilePath = None\n    if self.IsBinaryModule:\n        IsMakefile = False\n    if IsMakefile:\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        if self.OverrideGuid:\n            PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n        MakefilePath = (PathClassObj.Path, Arch)\n    if isinstance(Rule, RuleSimpleFile.RuleSimpleFile):\n        SectionOutputList = self.__GenSimpleFileSection__(Rule, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenSimpleFileFfs__(Rule, SectionOutputList, MakefilePath=MakefilePath)\n        return FfsOutput\n    elif isinstance(Rule, RuleComplexFile.RuleComplexFile):\n        (InputSectList, InputSectAlignments) = self.__GenComplexFileSection__(Rule, FvChildAddr, FvParentAddr, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenComplexFileFfs__(Rule, InputSectList, InputSectAlignments, MakefilePath=MakefilePath)\n        return FfsOutput",
            "def GenFfs(self, Dict=None, FvChildAddr=[], FvParentAddr=None, IsMakefile=False, FvName=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Dict is None:\n        Dict = {}\n    self.__InfParse__(Dict, IsGenFfs=True)\n    Arch = self.GetCurrentArch()\n    SrcFile = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n    DestFile = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    SrcFileDir = '.'\n    SrcPath = os.path.dirname(SrcFile)\n    SrcFileName = os.path.basename(SrcFile)\n    (SrcFileBase, SrcFileExt) = os.path.splitext(SrcFileName)\n    DestPath = os.path.dirname(DestFile)\n    DestFileName = os.path.basename(DestFile)\n    (DestFileBase, DestFileExt) = os.path.splitext(DestFileName)\n    self.MacroDict = {'${src}': SrcFile, '${s_path}': SrcPath, '${s_dir}': SrcFileDir, '${s_name}': SrcFileName, '${s_base}': SrcFileBase, '${s_ext}': SrcFileExt, '${dst}': DestFile, '${d_path}': DestPath, '${d_name}': DestFileName, '${d_base}': DestFileBase, '${d_ext}': DestFileExt}\n    if len(self.BinFileList) > 0:\n        if self.Rule is None or self.Rule == '':\n            self.Rule = 'BINARY'\n    if not IsMakefile and GenFdsGlobalVariable.EnableGenfdsMultiThread and (self.Rule != 'BINARY'):\n        IsMakefile = True\n    Rule = self.__GetRule__()\n    GenFdsGlobalVariable.VerboseLogger('Packing binaries from inf file : %s' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if Rule.FvFileType == 'DRIVER':\n            Rule.FvFileType = 'SMM'\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if Rule.FvFileType == 'SMM' or Rule.FvFileType == SUP_MODULE_SMM_CORE:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM or SMM_CORE FV file type\", File=self.InfFileName)\n    MakefilePath = None\n    if self.IsBinaryModule:\n        IsMakefile = False\n    if IsMakefile:\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        if self.OverrideGuid:\n            PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n        MakefilePath = (PathClassObj.Path, Arch)\n    if isinstance(Rule, RuleSimpleFile.RuleSimpleFile):\n        SectionOutputList = self.__GenSimpleFileSection__(Rule, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenSimpleFileFfs__(Rule, SectionOutputList, MakefilePath=MakefilePath)\n        return FfsOutput\n    elif isinstance(Rule, RuleComplexFile.RuleComplexFile):\n        (InputSectList, InputSectAlignments) = self.__GenComplexFileSection__(Rule, FvChildAddr, FvParentAddr, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenComplexFileFfs__(Rule, InputSectList, InputSectAlignments, MakefilePath=MakefilePath)\n        return FfsOutput",
            "def GenFfs(self, Dict=None, FvChildAddr=[], FvParentAddr=None, IsMakefile=False, FvName=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Dict is None:\n        Dict = {}\n    self.__InfParse__(Dict, IsGenFfs=True)\n    Arch = self.GetCurrentArch()\n    SrcFile = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n    DestFile = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    SrcFileDir = '.'\n    SrcPath = os.path.dirname(SrcFile)\n    SrcFileName = os.path.basename(SrcFile)\n    (SrcFileBase, SrcFileExt) = os.path.splitext(SrcFileName)\n    DestPath = os.path.dirname(DestFile)\n    DestFileName = os.path.basename(DestFile)\n    (DestFileBase, DestFileExt) = os.path.splitext(DestFileName)\n    self.MacroDict = {'${src}': SrcFile, '${s_path}': SrcPath, '${s_dir}': SrcFileDir, '${s_name}': SrcFileName, '${s_base}': SrcFileBase, '${s_ext}': SrcFileExt, '${dst}': DestFile, '${d_path}': DestPath, '${d_name}': DestFileName, '${d_base}': DestFileBase, '${d_ext}': DestFileExt}\n    if len(self.BinFileList) > 0:\n        if self.Rule is None or self.Rule == '':\n            self.Rule = 'BINARY'\n    if not IsMakefile and GenFdsGlobalVariable.EnableGenfdsMultiThread and (self.Rule != 'BINARY'):\n        IsMakefile = True\n    Rule = self.__GetRule__()\n    GenFdsGlobalVariable.VerboseLogger('Packing binaries from inf file : %s' % self.InfFileName)\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if Rule.FvFileType == 'DRIVER':\n            Rule.FvFileType = 'SMM'\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if Rule.FvFileType == 'SMM' or Rule.FvFileType == SUP_MODULE_SMM_CORE:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM or SMM_CORE FV file type\", File=self.InfFileName)\n    MakefilePath = None\n    if self.IsBinaryModule:\n        IsMakefile = False\n    if IsMakefile:\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        if self.OverrideGuid:\n            PathClassObj = ProcessDuplicatedInf(PathClassObj, self.OverrideGuid, GenFdsGlobalVariable.WorkSpaceDir)\n        MakefilePath = (PathClassObj.Path, Arch)\n    if isinstance(Rule, RuleSimpleFile.RuleSimpleFile):\n        SectionOutputList = self.__GenSimpleFileSection__(Rule, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenSimpleFileFfs__(Rule, SectionOutputList, MakefilePath=MakefilePath)\n        return FfsOutput\n    elif isinstance(Rule, RuleComplexFile.RuleComplexFile):\n        (InputSectList, InputSectAlignments) = self.__GenComplexFileSection__(Rule, FvChildAddr, FvParentAddr, IsMakefile=IsMakefile)\n        FfsOutput = self.__GenComplexFileFfs__(Rule, InputSectList, InputSectAlignments, MakefilePath=MakefilePath)\n        return FfsOutput"
        ]
    },
    {
        "func_name": "__ExtendMacro__",
        "original": "def __ExtendMacro__(self, String):\n    MacroDict = {'$(INF_OUTPUT)': self.EfiOutputPath, '$(MODULE_NAME)': self.BaseName, '$(BUILD_NUMBER)': self.BuildNum, '$(INF_VERSION)': self.VersionString, '$(NAMED_GUID)': self.ModuleGuid}\n    String = GenFdsGlobalVariable.MacroExtend(String, MacroDict)\n    String = GenFdsGlobalVariable.MacroExtend(String, self.MacroDict)\n    return String",
        "mutated": [
            "def __ExtendMacro__(self, String):\n    if False:\n        i = 10\n    MacroDict = {'$(INF_OUTPUT)': self.EfiOutputPath, '$(MODULE_NAME)': self.BaseName, '$(BUILD_NUMBER)': self.BuildNum, '$(INF_VERSION)': self.VersionString, '$(NAMED_GUID)': self.ModuleGuid}\n    String = GenFdsGlobalVariable.MacroExtend(String, MacroDict)\n    String = GenFdsGlobalVariable.MacroExtend(String, self.MacroDict)\n    return String",
            "def __ExtendMacro__(self, String):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    MacroDict = {'$(INF_OUTPUT)': self.EfiOutputPath, '$(MODULE_NAME)': self.BaseName, '$(BUILD_NUMBER)': self.BuildNum, '$(INF_VERSION)': self.VersionString, '$(NAMED_GUID)': self.ModuleGuid}\n    String = GenFdsGlobalVariable.MacroExtend(String, MacroDict)\n    String = GenFdsGlobalVariable.MacroExtend(String, self.MacroDict)\n    return String",
            "def __ExtendMacro__(self, String):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    MacroDict = {'$(INF_OUTPUT)': self.EfiOutputPath, '$(MODULE_NAME)': self.BaseName, '$(BUILD_NUMBER)': self.BuildNum, '$(INF_VERSION)': self.VersionString, '$(NAMED_GUID)': self.ModuleGuid}\n    String = GenFdsGlobalVariable.MacroExtend(String, MacroDict)\n    String = GenFdsGlobalVariable.MacroExtend(String, self.MacroDict)\n    return String",
            "def __ExtendMacro__(self, String):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    MacroDict = {'$(INF_OUTPUT)': self.EfiOutputPath, '$(MODULE_NAME)': self.BaseName, '$(BUILD_NUMBER)': self.BuildNum, '$(INF_VERSION)': self.VersionString, '$(NAMED_GUID)': self.ModuleGuid}\n    String = GenFdsGlobalVariable.MacroExtend(String, MacroDict)\n    String = GenFdsGlobalVariable.MacroExtend(String, self.MacroDict)\n    return String",
            "def __ExtendMacro__(self, String):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    MacroDict = {'$(INF_OUTPUT)': self.EfiOutputPath, '$(MODULE_NAME)': self.BaseName, '$(BUILD_NUMBER)': self.BuildNum, '$(INF_VERSION)': self.VersionString, '$(NAMED_GUID)': self.ModuleGuid}\n    String = GenFdsGlobalVariable.MacroExtend(String, MacroDict)\n    String = GenFdsGlobalVariable.MacroExtend(String, self.MacroDict)\n    return String"
        ]
    },
    {
        "func_name": "__GetRule__",
        "original": "def __GetRule__(self):\n    CurrentArchList = []\n    if self.CurrentArch is None:\n        CurrentArchList = ['common']\n    else:\n        CurrentArchList.append(self.CurrentArch)\n    for CurrentArch in CurrentArchList:\n        RuleName = 'RULE' + '.' + CurrentArch.upper() + '.' + self.ModuleType.upper()\n        if self.Rule is not None:\n            RuleName = RuleName + '.' + self.Rule.upper()\n        Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n        if Rule is not None:\n            GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n            return Rule\n    RuleName = 'RULE' + '.' + TAB_COMMON + '.' + self.ModuleType.upper()\n    if self.Rule is not None:\n        RuleName = RuleName + '.' + self.Rule.upper()\n    GenFdsGlobalVariable.VerboseLogger('Trying to apply common rule %s for INF %s' % (RuleName, self.InfFileName))\n    Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n    if Rule is not None:\n        GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n        return Rule\n    if Rule is None:\n        EdkLogger.error('GenFds', GENFDS_ERROR, \"Don't Find common rule %s for INF %s\" % (RuleName, self.InfFileName))",
        "mutated": [
            "def __GetRule__(self):\n    if False:\n        i = 10\n    CurrentArchList = []\n    if self.CurrentArch is None:\n        CurrentArchList = ['common']\n    else:\n        CurrentArchList.append(self.CurrentArch)\n    for CurrentArch in CurrentArchList:\n        RuleName = 'RULE' + '.' + CurrentArch.upper() + '.' + self.ModuleType.upper()\n        if self.Rule is not None:\n            RuleName = RuleName + '.' + self.Rule.upper()\n        Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n        if Rule is not None:\n            GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n            return Rule\n    RuleName = 'RULE' + '.' + TAB_COMMON + '.' + self.ModuleType.upper()\n    if self.Rule is not None:\n        RuleName = RuleName + '.' + self.Rule.upper()\n    GenFdsGlobalVariable.VerboseLogger('Trying to apply common rule %s for INF %s' % (RuleName, self.InfFileName))\n    Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n    if Rule is not None:\n        GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n        return Rule\n    if Rule is None:\n        EdkLogger.error('GenFds', GENFDS_ERROR, \"Don't Find common rule %s for INF %s\" % (RuleName, self.InfFileName))",
            "def __GetRule__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CurrentArchList = []\n    if self.CurrentArch is None:\n        CurrentArchList = ['common']\n    else:\n        CurrentArchList.append(self.CurrentArch)\n    for CurrentArch in CurrentArchList:\n        RuleName = 'RULE' + '.' + CurrentArch.upper() + '.' + self.ModuleType.upper()\n        if self.Rule is not None:\n            RuleName = RuleName + '.' + self.Rule.upper()\n        Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n        if Rule is not None:\n            GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n            return Rule\n    RuleName = 'RULE' + '.' + TAB_COMMON + '.' + self.ModuleType.upper()\n    if self.Rule is not None:\n        RuleName = RuleName + '.' + self.Rule.upper()\n    GenFdsGlobalVariable.VerboseLogger('Trying to apply common rule %s for INF %s' % (RuleName, self.InfFileName))\n    Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n    if Rule is not None:\n        GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n        return Rule\n    if Rule is None:\n        EdkLogger.error('GenFds', GENFDS_ERROR, \"Don't Find common rule %s for INF %s\" % (RuleName, self.InfFileName))",
            "def __GetRule__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CurrentArchList = []\n    if self.CurrentArch is None:\n        CurrentArchList = ['common']\n    else:\n        CurrentArchList.append(self.CurrentArch)\n    for CurrentArch in CurrentArchList:\n        RuleName = 'RULE' + '.' + CurrentArch.upper() + '.' + self.ModuleType.upper()\n        if self.Rule is not None:\n            RuleName = RuleName + '.' + self.Rule.upper()\n        Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n        if Rule is not None:\n            GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n            return Rule\n    RuleName = 'RULE' + '.' + TAB_COMMON + '.' + self.ModuleType.upper()\n    if self.Rule is not None:\n        RuleName = RuleName + '.' + self.Rule.upper()\n    GenFdsGlobalVariable.VerboseLogger('Trying to apply common rule %s for INF %s' % (RuleName, self.InfFileName))\n    Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n    if Rule is not None:\n        GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n        return Rule\n    if Rule is None:\n        EdkLogger.error('GenFds', GENFDS_ERROR, \"Don't Find common rule %s for INF %s\" % (RuleName, self.InfFileName))",
            "def __GetRule__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CurrentArchList = []\n    if self.CurrentArch is None:\n        CurrentArchList = ['common']\n    else:\n        CurrentArchList.append(self.CurrentArch)\n    for CurrentArch in CurrentArchList:\n        RuleName = 'RULE' + '.' + CurrentArch.upper() + '.' + self.ModuleType.upper()\n        if self.Rule is not None:\n            RuleName = RuleName + '.' + self.Rule.upper()\n        Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n        if Rule is not None:\n            GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n            return Rule\n    RuleName = 'RULE' + '.' + TAB_COMMON + '.' + self.ModuleType.upper()\n    if self.Rule is not None:\n        RuleName = RuleName + '.' + self.Rule.upper()\n    GenFdsGlobalVariable.VerboseLogger('Trying to apply common rule %s for INF %s' % (RuleName, self.InfFileName))\n    Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n    if Rule is not None:\n        GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n        return Rule\n    if Rule is None:\n        EdkLogger.error('GenFds', GENFDS_ERROR, \"Don't Find common rule %s for INF %s\" % (RuleName, self.InfFileName))",
            "def __GetRule__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CurrentArchList = []\n    if self.CurrentArch is None:\n        CurrentArchList = ['common']\n    else:\n        CurrentArchList.append(self.CurrentArch)\n    for CurrentArch in CurrentArchList:\n        RuleName = 'RULE' + '.' + CurrentArch.upper() + '.' + self.ModuleType.upper()\n        if self.Rule is not None:\n            RuleName = RuleName + '.' + self.Rule.upper()\n        Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n        if Rule is not None:\n            GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n            return Rule\n    RuleName = 'RULE' + '.' + TAB_COMMON + '.' + self.ModuleType.upper()\n    if self.Rule is not None:\n        RuleName = RuleName + '.' + self.Rule.upper()\n    GenFdsGlobalVariable.VerboseLogger('Trying to apply common rule %s for INF %s' % (RuleName, self.InfFileName))\n    Rule = GenFdsGlobalVariable.FdfParser.Profile.RuleDict.get(RuleName)\n    if Rule is not None:\n        GenFdsGlobalVariable.VerboseLogger('Want To Find Rule Name is : ' + RuleName)\n        return Rule\n    if Rule is None:\n        EdkLogger.error('GenFds', GENFDS_ERROR, \"Don't Find common rule %s for INF %s\" % (RuleName, self.InfFileName))"
        ]
    },
    {
        "func_name": "__GetPlatformArchList__",
        "original": "def __GetPlatformArchList__(self):\n    InfFileKey = os.path.normpath(mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName))\n    DscArchList = []\n    for Arch in GenFdsGlobalVariable.ArchList:\n        PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, Arch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        if PlatformDataBase is not None:\n            if InfFileKey in PlatformDataBase.Modules:\n                DscArchList.append(Arch)\n            else:\n                for key in PlatformDataBase.Modules:\n                    if InfFileKey == str(PlatformDataBase.Modules[key].MetaFile.Path):\n                        DscArchList.append(Arch)\n                        break\n    return DscArchList",
        "mutated": [
            "def __GetPlatformArchList__(self):\n    if False:\n        i = 10\n    InfFileKey = os.path.normpath(mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName))\n    DscArchList = []\n    for Arch in GenFdsGlobalVariable.ArchList:\n        PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, Arch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        if PlatformDataBase is not None:\n            if InfFileKey in PlatformDataBase.Modules:\n                DscArchList.append(Arch)\n            else:\n                for key in PlatformDataBase.Modules:\n                    if InfFileKey == str(PlatformDataBase.Modules[key].MetaFile.Path):\n                        DscArchList.append(Arch)\n                        break\n    return DscArchList",
            "def __GetPlatformArchList__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    InfFileKey = os.path.normpath(mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName))\n    DscArchList = []\n    for Arch in GenFdsGlobalVariable.ArchList:\n        PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, Arch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        if PlatformDataBase is not None:\n            if InfFileKey in PlatformDataBase.Modules:\n                DscArchList.append(Arch)\n            else:\n                for key in PlatformDataBase.Modules:\n                    if InfFileKey == str(PlatformDataBase.Modules[key].MetaFile.Path):\n                        DscArchList.append(Arch)\n                        break\n    return DscArchList",
            "def __GetPlatformArchList__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    InfFileKey = os.path.normpath(mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName))\n    DscArchList = []\n    for Arch in GenFdsGlobalVariable.ArchList:\n        PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, Arch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        if PlatformDataBase is not None:\n            if InfFileKey in PlatformDataBase.Modules:\n                DscArchList.append(Arch)\n            else:\n                for key in PlatformDataBase.Modules:\n                    if InfFileKey == str(PlatformDataBase.Modules[key].MetaFile.Path):\n                        DscArchList.append(Arch)\n                        break\n    return DscArchList",
            "def __GetPlatformArchList__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    InfFileKey = os.path.normpath(mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName))\n    DscArchList = []\n    for Arch in GenFdsGlobalVariable.ArchList:\n        PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, Arch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        if PlatformDataBase is not None:\n            if InfFileKey in PlatformDataBase.Modules:\n                DscArchList.append(Arch)\n            else:\n                for key in PlatformDataBase.Modules:\n                    if InfFileKey == str(PlatformDataBase.Modules[key].MetaFile.Path):\n                        DscArchList.append(Arch)\n                        break\n    return DscArchList",
            "def __GetPlatformArchList__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    InfFileKey = os.path.normpath(mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName))\n    DscArchList = []\n    for Arch in GenFdsGlobalVariable.ArchList:\n        PlatformDataBase = GenFdsGlobalVariable.WorkSpace.BuildObject[GenFdsGlobalVariable.ActivePlatform, Arch, GenFdsGlobalVariable.TargetName, GenFdsGlobalVariable.ToolChainTag]\n        if PlatformDataBase is not None:\n            if InfFileKey in PlatformDataBase.Modules:\n                DscArchList.append(Arch)\n            else:\n                for key in PlatformDataBase.Modules:\n                    if InfFileKey == str(PlatformDataBase.Modules[key].MetaFile.Path):\n                        DscArchList.append(Arch)\n                        break\n    return DscArchList"
        ]
    },
    {
        "func_name": "GetCurrentArch",
        "original": "def GetCurrentArch(self):\n    TargetArchList = GenFdsGlobalVariable.ArchList\n    PlatformArchList = self.__GetPlatformArchList__()\n    CurArchList = TargetArchList\n    if PlatformArchList != []:\n        CurArchList = list(set(TargetArchList) & set(PlatformArchList))\n    GenFdsGlobalVariable.VerboseLogger('Valid target architecture(s) is : ' + ' '.join(CurArchList))\n    ArchList = []\n    if self.KeyStringList != []:\n        for Key in self.KeyStringList:\n            Key = GenFdsGlobalVariable.MacroExtend(Key)\n            (Target, Tag, Arch) = Key.split('_')\n            if Arch in CurArchList:\n                ArchList.append(Arch)\n            if Target not in self.TargetOverrideList:\n                self.TargetOverrideList.append(Target)\n    else:\n        ArchList = CurArchList\n    UseArchList = TargetArchList\n    if self.UseArch is not None:\n        UseArchList = []\n        UseArchList.append(self.UseArch)\n        ArchList = list(set(UseArchList) & set(ArchList))\n    self.InfFileName = NormPath(self.InfFileName)\n    if len(PlatformArchList) == 0:\n        self.InDsc = False\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    if len(ArchList) == 1:\n        Arch = ArchList[0]\n        return Arch\n    elif len(ArchList) > 1:\n        if len(PlatformArchList) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GenFds command line option has multiple ARCHs %s. Not able to determine which ARCH is valid for Module %s !' % (str(ArchList), self.InfFileName))\n        else:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'Module built under multiple ARCHs %s. Not able to determine which output to put into flash for Module %s !' % (str(ArchList), self.InfFileName))\n    else:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Module %s appears under ARCH %s in platform %s, but current deduced ARCH is %s, so NO build output could be put into flash.' % (self.InfFileName, str(PlatformArchList), GenFdsGlobalVariable.ActivePlatform, str(set(UseArchList) & set(TargetArchList))))",
        "mutated": [
            "def GetCurrentArch(self):\n    if False:\n        i = 10\n    TargetArchList = GenFdsGlobalVariable.ArchList\n    PlatformArchList = self.__GetPlatformArchList__()\n    CurArchList = TargetArchList\n    if PlatformArchList != []:\n        CurArchList = list(set(TargetArchList) & set(PlatformArchList))\n    GenFdsGlobalVariable.VerboseLogger('Valid target architecture(s) is : ' + ' '.join(CurArchList))\n    ArchList = []\n    if self.KeyStringList != []:\n        for Key in self.KeyStringList:\n            Key = GenFdsGlobalVariable.MacroExtend(Key)\n            (Target, Tag, Arch) = Key.split('_')\n            if Arch in CurArchList:\n                ArchList.append(Arch)\n            if Target not in self.TargetOverrideList:\n                self.TargetOverrideList.append(Target)\n    else:\n        ArchList = CurArchList\n    UseArchList = TargetArchList\n    if self.UseArch is not None:\n        UseArchList = []\n        UseArchList.append(self.UseArch)\n        ArchList = list(set(UseArchList) & set(ArchList))\n    self.InfFileName = NormPath(self.InfFileName)\n    if len(PlatformArchList) == 0:\n        self.InDsc = False\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    if len(ArchList) == 1:\n        Arch = ArchList[0]\n        return Arch\n    elif len(ArchList) > 1:\n        if len(PlatformArchList) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GenFds command line option has multiple ARCHs %s. Not able to determine which ARCH is valid for Module %s !' % (str(ArchList), self.InfFileName))\n        else:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'Module built under multiple ARCHs %s. Not able to determine which output to put into flash for Module %s !' % (str(ArchList), self.InfFileName))\n    else:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Module %s appears under ARCH %s in platform %s, but current deduced ARCH is %s, so NO build output could be put into flash.' % (self.InfFileName, str(PlatformArchList), GenFdsGlobalVariable.ActivePlatform, str(set(UseArchList) & set(TargetArchList))))",
            "def GetCurrentArch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    TargetArchList = GenFdsGlobalVariable.ArchList\n    PlatformArchList = self.__GetPlatformArchList__()\n    CurArchList = TargetArchList\n    if PlatformArchList != []:\n        CurArchList = list(set(TargetArchList) & set(PlatformArchList))\n    GenFdsGlobalVariable.VerboseLogger('Valid target architecture(s) is : ' + ' '.join(CurArchList))\n    ArchList = []\n    if self.KeyStringList != []:\n        for Key in self.KeyStringList:\n            Key = GenFdsGlobalVariable.MacroExtend(Key)\n            (Target, Tag, Arch) = Key.split('_')\n            if Arch in CurArchList:\n                ArchList.append(Arch)\n            if Target not in self.TargetOverrideList:\n                self.TargetOverrideList.append(Target)\n    else:\n        ArchList = CurArchList\n    UseArchList = TargetArchList\n    if self.UseArch is not None:\n        UseArchList = []\n        UseArchList.append(self.UseArch)\n        ArchList = list(set(UseArchList) & set(ArchList))\n    self.InfFileName = NormPath(self.InfFileName)\n    if len(PlatformArchList) == 0:\n        self.InDsc = False\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    if len(ArchList) == 1:\n        Arch = ArchList[0]\n        return Arch\n    elif len(ArchList) > 1:\n        if len(PlatformArchList) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GenFds command line option has multiple ARCHs %s. Not able to determine which ARCH is valid for Module %s !' % (str(ArchList), self.InfFileName))\n        else:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'Module built under multiple ARCHs %s. Not able to determine which output to put into flash for Module %s !' % (str(ArchList), self.InfFileName))\n    else:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Module %s appears under ARCH %s in platform %s, but current deduced ARCH is %s, so NO build output could be put into flash.' % (self.InfFileName, str(PlatformArchList), GenFdsGlobalVariable.ActivePlatform, str(set(UseArchList) & set(TargetArchList))))",
            "def GetCurrentArch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    TargetArchList = GenFdsGlobalVariable.ArchList\n    PlatformArchList = self.__GetPlatformArchList__()\n    CurArchList = TargetArchList\n    if PlatformArchList != []:\n        CurArchList = list(set(TargetArchList) & set(PlatformArchList))\n    GenFdsGlobalVariable.VerboseLogger('Valid target architecture(s) is : ' + ' '.join(CurArchList))\n    ArchList = []\n    if self.KeyStringList != []:\n        for Key in self.KeyStringList:\n            Key = GenFdsGlobalVariable.MacroExtend(Key)\n            (Target, Tag, Arch) = Key.split('_')\n            if Arch in CurArchList:\n                ArchList.append(Arch)\n            if Target not in self.TargetOverrideList:\n                self.TargetOverrideList.append(Target)\n    else:\n        ArchList = CurArchList\n    UseArchList = TargetArchList\n    if self.UseArch is not None:\n        UseArchList = []\n        UseArchList.append(self.UseArch)\n        ArchList = list(set(UseArchList) & set(ArchList))\n    self.InfFileName = NormPath(self.InfFileName)\n    if len(PlatformArchList) == 0:\n        self.InDsc = False\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    if len(ArchList) == 1:\n        Arch = ArchList[0]\n        return Arch\n    elif len(ArchList) > 1:\n        if len(PlatformArchList) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GenFds command line option has multiple ARCHs %s. Not able to determine which ARCH is valid for Module %s !' % (str(ArchList), self.InfFileName))\n        else:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'Module built under multiple ARCHs %s. Not able to determine which output to put into flash for Module %s !' % (str(ArchList), self.InfFileName))\n    else:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Module %s appears under ARCH %s in platform %s, but current deduced ARCH is %s, so NO build output could be put into flash.' % (self.InfFileName, str(PlatformArchList), GenFdsGlobalVariable.ActivePlatform, str(set(UseArchList) & set(TargetArchList))))",
            "def GetCurrentArch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    TargetArchList = GenFdsGlobalVariable.ArchList\n    PlatformArchList = self.__GetPlatformArchList__()\n    CurArchList = TargetArchList\n    if PlatformArchList != []:\n        CurArchList = list(set(TargetArchList) & set(PlatformArchList))\n    GenFdsGlobalVariable.VerboseLogger('Valid target architecture(s) is : ' + ' '.join(CurArchList))\n    ArchList = []\n    if self.KeyStringList != []:\n        for Key in self.KeyStringList:\n            Key = GenFdsGlobalVariable.MacroExtend(Key)\n            (Target, Tag, Arch) = Key.split('_')\n            if Arch in CurArchList:\n                ArchList.append(Arch)\n            if Target not in self.TargetOverrideList:\n                self.TargetOverrideList.append(Target)\n    else:\n        ArchList = CurArchList\n    UseArchList = TargetArchList\n    if self.UseArch is not None:\n        UseArchList = []\n        UseArchList.append(self.UseArch)\n        ArchList = list(set(UseArchList) & set(ArchList))\n    self.InfFileName = NormPath(self.InfFileName)\n    if len(PlatformArchList) == 0:\n        self.InDsc = False\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    if len(ArchList) == 1:\n        Arch = ArchList[0]\n        return Arch\n    elif len(ArchList) > 1:\n        if len(PlatformArchList) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GenFds command line option has multiple ARCHs %s. Not able to determine which ARCH is valid for Module %s !' % (str(ArchList), self.InfFileName))\n        else:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'Module built under multiple ARCHs %s. Not able to determine which output to put into flash for Module %s !' % (str(ArchList), self.InfFileName))\n    else:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Module %s appears under ARCH %s in platform %s, but current deduced ARCH is %s, so NO build output could be put into flash.' % (self.InfFileName, str(PlatformArchList), GenFdsGlobalVariable.ActivePlatform, str(set(UseArchList) & set(TargetArchList))))",
            "def GetCurrentArch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    TargetArchList = GenFdsGlobalVariable.ArchList\n    PlatformArchList = self.__GetPlatformArchList__()\n    CurArchList = TargetArchList\n    if PlatformArchList != []:\n        CurArchList = list(set(TargetArchList) & set(PlatformArchList))\n    GenFdsGlobalVariable.VerboseLogger('Valid target architecture(s) is : ' + ' '.join(CurArchList))\n    ArchList = []\n    if self.KeyStringList != []:\n        for Key in self.KeyStringList:\n            Key = GenFdsGlobalVariable.MacroExtend(Key)\n            (Target, Tag, Arch) = Key.split('_')\n            if Arch in CurArchList:\n                ArchList.append(Arch)\n            if Target not in self.TargetOverrideList:\n                self.TargetOverrideList.append(Target)\n    else:\n        ArchList = CurArchList\n    UseArchList = TargetArchList\n    if self.UseArch is not None:\n        UseArchList = []\n        UseArchList.append(self.UseArch)\n        ArchList = list(set(UseArchList) & set(ArchList))\n    self.InfFileName = NormPath(self.InfFileName)\n    if len(PlatformArchList) == 0:\n        self.InDsc = False\n        PathClassObj = PathClass(self.InfFileName, GenFdsGlobalVariable.WorkSpaceDir)\n        (ErrorCode, ErrorInfo) = PathClassObj.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('GenFds', ErrorCode, ExtraData=ErrorInfo)\n    if len(ArchList) == 1:\n        Arch = ArchList[0]\n        return Arch\n    elif len(ArchList) > 1:\n        if len(PlatformArchList) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GenFds command line option has multiple ARCHs %s. Not able to determine which ARCH is valid for Module %s !' % (str(ArchList), self.InfFileName))\n        else:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'Module built under multiple ARCHs %s. Not able to determine which output to put into flash for Module %s !' % (str(ArchList), self.InfFileName))\n    else:\n        EdkLogger.error('GenFds', GENFDS_ERROR, 'Module %s appears under ARCH %s in platform %s, but current deduced ARCH is %s, so NO build output could be put into flash.' % (self.InfFileName, str(PlatformArchList), GenFdsGlobalVariable.ActivePlatform, str(set(UseArchList) & set(TargetArchList))))"
        ]
    },
    {
        "func_name": "__GetEFIOutPutPath__",
        "original": "def __GetEFIOutPutPath__(self):\n    Arch = ''\n    OutputPath = ''\n    DebugPath = ''\n    (ModulePath, FileName) = os.path.split(self.InfFileName)\n    Index = FileName.rfind('.')\n    FileName = FileName[0:Index]\n    if self.OverrideGuid:\n        FileName = self.OverrideGuid\n    Arch = 'NoneArch'\n    if self.CurrentArch is not None:\n        Arch = self.CurrentArch\n    OutputPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'OUTPUT')\n    DebugPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'DEBUG')\n    OutputPath = os.path.abspath(OutputPath)\n    DebugPath = os.path.abspath(DebugPath)\n    return (OutputPath, DebugPath)",
        "mutated": [
            "def __GetEFIOutPutPath__(self):\n    if False:\n        i = 10\n    Arch = ''\n    OutputPath = ''\n    DebugPath = ''\n    (ModulePath, FileName) = os.path.split(self.InfFileName)\n    Index = FileName.rfind('.')\n    FileName = FileName[0:Index]\n    if self.OverrideGuid:\n        FileName = self.OverrideGuid\n    Arch = 'NoneArch'\n    if self.CurrentArch is not None:\n        Arch = self.CurrentArch\n    OutputPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'OUTPUT')\n    DebugPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'DEBUG')\n    OutputPath = os.path.abspath(OutputPath)\n    DebugPath = os.path.abspath(DebugPath)\n    return (OutputPath, DebugPath)",
            "def __GetEFIOutPutPath__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Arch = ''\n    OutputPath = ''\n    DebugPath = ''\n    (ModulePath, FileName) = os.path.split(self.InfFileName)\n    Index = FileName.rfind('.')\n    FileName = FileName[0:Index]\n    if self.OverrideGuid:\n        FileName = self.OverrideGuid\n    Arch = 'NoneArch'\n    if self.CurrentArch is not None:\n        Arch = self.CurrentArch\n    OutputPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'OUTPUT')\n    DebugPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'DEBUG')\n    OutputPath = os.path.abspath(OutputPath)\n    DebugPath = os.path.abspath(DebugPath)\n    return (OutputPath, DebugPath)",
            "def __GetEFIOutPutPath__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Arch = ''\n    OutputPath = ''\n    DebugPath = ''\n    (ModulePath, FileName) = os.path.split(self.InfFileName)\n    Index = FileName.rfind('.')\n    FileName = FileName[0:Index]\n    if self.OverrideGuid:\n        FileName = self.OverrideGuid\n    Arch = 'NoneArch'\n    if self.CurrentArch is not None:\n        Arch = self.CurrentArch\n    OutputPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'OUTPUT')\n    DebugPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'DEBUG')\n    OutputPath = os.path.abspath(OutputPath)\n    DebugPath = os.path.abspath(DebugPath)\n    return (OutputPath, DebugPath)",
            "def __GetEFIOutPutPath__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Arch = ''\n    OutputPath = ''\n    DebugPath = ''\n    (ModulePath, FileName) = os.path.split(self.InfFileName)\n    Index = FileName.rfind('.')\n    FileName = FileName[0:Index]\n    if self.OverrideGuid:\n        FileName = self.OverrideGuid\n    Arch = 'NoneArch'\n    if self.CurrentArch is not None:\n        Arch = self.CurrentArch\n    OutputPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'OUTPUT')\n    DebugPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'DEBUG')\n    OutputPath = os.path.abspath(OutputPath)\n    DebugPath = os.path.abspath(DebugPath)\n    return (OutputPath, DebugPath)",
            "def __GetEFIOutPutPath__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Arch = ''\n    OutputPath = ''\n    DebugPath = ''\n    (ModulePath, FileName) = os.path.split(self.InfFileName)\n    Index = FileName.rfind('.')\n    FileName = FileName[0:Index]\n    if self.OverrideGuid:\n        FileName = self.OverrideGuid\n    Arch = 'NoneArch'\n    if self.CurrentArch is not None:\n        Arch = self.CurrentArch\n    OutputPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'OUTPUT')\n    DebugPath = os.path.join(GenFdsGlobalVariable.OutputDirDict[Arch], Arch, ModulePath, FileName, 'DEBUG')\n    OutputPath = os.path.abspath(OutputPath)\n    DebugPath = os.path.abspath(DebugPath)\n    return (OutputPath, DebugPath)"
        ]
    },
    {
        "func_name": "__GenSimpleFileSection__",
        "original": "def __GenSimpleFileSection__(self, Rule, IsMakefile=False):\n    FileList = []\n    OutputFileList = []\n    GenSecInputFile = None\n    if Rule.FileName is not None:\n        GenSecInputFile = self.__ExtendMacro__(Rule.FileName)\n        if os.path.isabs(GenSecInputFile):\n            GenSecInputFile = os.path.normpath(GenSecInputFile)\n        else:\n            GenSecInputFile = os.path.normpath(os.path.join(self.EfiOutputPath, GenSecInputFile))\n    else:\n        (FileList, IsSect) = Section.Section.GetFileList(self, '', Rule.FileExtension)\n    Index = 1\n    SectionType = Rule.SectionType\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n            SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n    NoStrip = True\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM):\n        if self.KeepReloc is not None:\n            NoStrip = self.KeepReloc\n        elif Rule.KeepReloc is not None:\n            NoStrip = Rule.KeepReloc\n        elif self.ShadowFromInfFile is not None:\n            NoStrip = self.ShadowFromInfFile\n    if FileList != []:\n        for File in FileList:\n            SecNum = '%d' % Index\n            GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n            Index = Index + 1\n            OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n            File = GenFdsGlobalVariable.MacroExtend(File, Dict, self.CurrentArch)\n            if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n                ImageObj = PeImageClass(File)\n                if ImageObj.SectionAlignment < 1024:\n                    self.Alignment = str(ImageObj.SectionAlignment)\n                elif ImageObj.SectionAlignment < 1048576:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n                else:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n            if not NoStrip:\n                FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n                if not os.path.exists(FileBeforeStrip) or os.path.getmtime(File) > os.path.getmtime(FileBeforeStrip):\n                    CopyLongFilePath(File, FileBeforeStrip)\n                StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n                GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [File], Strip=True, IsMakefile=IsMakefile)\n                File = StrippedFile\n            if SectionType == BINARY_FILE_TYPE_TE:\n                TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n                GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [File], Type='te', IsMakefile=IsMakefile)\n                File = TeFile\n            GenFdsGlobalVariable.GenerateSection(OutputFile, [File], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n            OutputFileList.append(OutputFile)\n    else:\n        SecNum = '%d' % Index\n        GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n        OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n        GenSecInputFile = GenFdsGlobalVariable.MacroExtend(GenSecInputFile, Dict, self.CurrentArch)\n        if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n            ImageObj = PeImageClass(GenSecInputFile)\n            if ImageObj.SectionAlignment < 1024:\n                self.Alignment = str(ImageObj.SectionAlignment)\n            elif ImageObj.SectionAlignment < 1048576:\n                self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n            else:\n                self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n        if not NoStrip:\n            FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n            if not os.path.exists(FileBeforeStrip) or os.path.getmtime(GenSecInputFile) > os.path.getmtime(FileBeforeStrip):\n                CopyLongFilePath(GenSecInputFile, FileBeforeStrip)\n            StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n            GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [GenSecInputFile], Strip=True, IsMakefile=IsMakefile)\n            GenSecInputFile = StrippedFile\n        if SectionType == BINARY_FILE_TYPE_TE:\n            TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n            GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [GenSecInputFile], Type='te', IsMakefile=IsMakefile)\n            GenSecInputFile = TeFile\n        GenFdsGlobalVariable.GenerateSection(OutputFile, [GenSecInputFile], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n        OutputFileList.append(OutputFile)\n    return OutputFileList",
        "mutated": [
            "def __GenSimpleFileSection__(self, Rule, IsMakefile=False):\n    if False:\n        i = 10\n    FileList = []\n    OutputFileList = []\n    GenSecInputFile = None\n    if Rule.FileName is not None:\n        GenSecInputFile = self.__ExtendMacro__(Rule.FileName)\n        if os.path.isabs(GenSecInputFile):\n            GenSecInputFile = os.path.normpath(GenSecInputFile)\n        else:\n            GenSecInputFile = os.path.normpath(os.path.join(self.EfiOutputPath, GenSecInputFile))\n    else:\n        (FileList, IsSect) = Section.Section.GetFileList(self, '', Rule.FileExtension)\n    Index = 1\n    SectionType = Rule.SectionType\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n            SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n    NoStrip = True\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM):\n        if self.KeepReloc is not None:\n            NoStrip = self.KeepReloc\n        elif Rule.KeepReloc is not None:\n            NoStrip = Rule.KeepReloc\n        elif self.ShadowFromInfFile is not None:\n            NoStrip = self.ShadowFromInfFile\n    if FileList != []:\n        for File in FileList:\n            SecNum = '%d' % Index\n            GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n            Index = Index + 1\n            OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n            File = GenFdsGlobalVariable.MacroExtend(File, Dict, self.CurrentArch)\n            if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n                ImageObj = PeImageClass(File)\n                if ImageObj.SectionAlignment < 1024:\n                    self.Alignment = str(ImageObj.SectionAlignment)\n                elif ImageObj.SectionAlignment < 1048576:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n                else:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n            if not NoStrip:\n                FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n                if not os.path.exists(FileBeforeStrip) or os.path.getmtime(File) > os.path.getmtime(FileBeforeStrip):\n                    CopyLongFilePath(File, FileBeforeStrip)\n                StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n                GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [File], Strip=True, IsMakefile=IsMakefile)\n                File = StrippedFile\n            if SectionType == BINARY_FILE_TYPE_TE:\n                TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n                GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [File], Type='te', IsMakefile=IsMakefile)\n                File = TeFile\n            GenFdsGlobalVariable.GenerateSection(OutputFile, [File], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n            OutputFileList.append(OutputFile)\n    else:\n        SecNum = '%d' % Index\n        GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n        OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n        GenSecInputFile = GenFdsGlobalVariable.MacroExtend(GenSecInputFile, Dict, self.CurrentArch)\n        if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n            ImageObj = PeImageClass(GenSecInputFile)\n            if ImageObj.SectionAlignment < 1024:\n                self.Alignment = str(ImageObj.SectionAlignment)\n            elif ImageObj.SectionAlignment < 1048576:\n                self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n            else:\n                self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n        if not NoStrip:\n            FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n            if not os.path.exists(FileBeforeStrip) or os.path.getmtime(GenSecInputFile) > os.path.getmtime(FileBeforeStrip):\n                CopyLongFilePath(GenSecInputFile, FileBeforeStrip)\n            StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n            GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [GenSecInputFile], Strip=True, IsMakefile=IsMakefile)\n            GenSecInputFile = StrippedFile\n        if SectionType == BINARY_FILE_TYPE_TE:\n            TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n            GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [GenSecInputFile], Type='te', IsMakefile=IsMakefile)\n            GenSecInputFile = TeFile\n        GenFdsGlobalVariable.GenerateSection(OutputFile, [GenSecInputFile], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n        OutputFileList.append(OutputFile)\n    return OutputFileList",
            "def __GenSimpleFileSection__(self, Rule, IsMakefile=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FileList = []\n    OutputFileList = []\n    GenSecInputFile = None\n    if Rule.FileName is not None:\n        GenSecInputFile = self.__ExtendMacro__(Rule.FileName)\n        if os.path.isabs(GenSecInputFile):\n            GenSecInputFile = os.path.normpath(GenSecInputFile)\n        else:\n            GenSecInputFile = os.path.normpath(os.path.join(self.EfiOutputPath, GenSecInputFile))\n    else:\n        (FileList, IsSect) = Section.Section.GetFileList(self, '', Rule.FileExtension)\n    Index = 1\n    SectionType = Rule.SectionType\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n            SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n    NoStrip = True\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM):\n        if self.KeepReloc is not None:\n            NoStrip = self.KeepReloc\n        elif Rule.KeepReloc is not None:\n            NoStrip = Rule.KeepReloc\n        elif self.ShadowFromInfFile is not None:\n            NoStrip = self.ShadowFromInfFile\n    if FileList != []:\n        for File in FileList:\n            SecNum = '%d' % Index\n            GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n            Index = Index + 1\n            OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n            File = GenFdsGlobalVariable.MacroExtend(File, Dict, self.CurrentArch)\n            if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n                ImageObj = PeImageClass(File)\n                if ImageObj.SectionAlignment < 1024:\n                    self.Alignment = str(ImageObj.SectionAlignment)\n                elif ImageObj.SectionAlignment < 1048576:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n                else:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n            if not NoStrip:\n                FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n                if not os.path.exists(FileBeforeStrip) or os.path.getmtime(File) > os.path.getmtime(FileBeforeStrip):\n                    CopyLongFilePath(File, FileBeforeStrip)\n                StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n                GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [File], Strip=True, IsMakefile=IsMakefile)\n                File = StrippedFile\n            if SectionType == BINARY_FILE_TYPE_TE:\n                TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n                GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [File], Type='te', IsMakefile=IsMakefile)\n                File = TeFile\n            GenFdsGlobalVariable.GenerateSection(OutputFile, [File], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n            OutputFileList.append(OutputFile)\n    else:\n        SecNum = '%d' % Index\n        GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n        OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n        GenSecInputFile = GenFdsGlobalVariable.MacroExtend(GenSecInputFile, Dict, self.CurrentArch)\n        if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n            ImageObj = PeImageClass(GenSecInputFile)\n            if ImageObj.SectionAlignment < 1024:\n                self.Alignment = str(ImageObj.SectionAlignment)\n            elif ImageObj.SectionAlignment < 1048576:\n                self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n            else:\n                self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n        if not NoStrip:\n            FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n            if not os.path.exists(FileBeforeStrip) or os.path.getmtime(GenSecInputFile) > os.path.getmtime(FileBeforeStrip):\n                CopyLongFilePath(GenSecInputFile, FileBeforeStrip)\n            StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n            GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [GenSecInputFile], Strip=True, IsMakefile=IsMakefile)\n            GenSecInputFile = StrippedFile\n        if SectionType == BINARY_FILE_TYPE_TE:\n            TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n            GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [GenSecInputFile], Type='te', IsMakefile=IsMakefile)\n            GenSecInputFile = TeFile\n        GenFdsGlobalVariable.GenerateSection(OutputFile, [GenSecInputFile], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n        OutputFileList.append(OutputFile)\n    return OutputFileList",
            "def __GenSimpleFileSection__(self, Rule, IsMakefile=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FileList = []\n    OutputFileList = []\n    GenSecInputFile = None\n    if Rule.FileName is not None:\n        GenSecInputFile = self.__ExtendMacro__(Rule.FileName)\n        if os.path.isabs(GenSecInputFile):\n            GenSecInputFile = os.path.normpath(GenSecInputFile)\n        else:\n            GenSecInputFile = os.path.normpath(os.path.join(self.EfiOutputPath, GenSecInputFile))\n    else:\n        (FileList, IsSect) = Section.Section.GetFileList(self, '', Rule.FileExtension)\n    Index = 1\n    SectionType = Rule.SectionType\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n            SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n    NoStrip = True\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM):\n        if self.KeepReloc is not None:\n            NoStrip = self.KeepReloc\n        elif Rule.KeepReloc is not None:\n            NoStrip = Rule.KeepReloc\n        elif self.ShadowFromInfFile is not None:\n            NoStrip = self.ShadowFromInfFile\n    if FileList != []:\n        for File in FileList:\n            SecNum = '%d' % Index\n            GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n            Index = Index + 1\n            OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n            File = GenFdsGlobalVariable.MacroExtend(File, Dict, self.CurrentArch)\n            if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n                ImageObj = PeImageClass(File)\n                if ImageObj.SectionAlignment < 1024:\n                    self.Alignment = str(ImageObj.SectionAlignment)\n                elif ImageObj.SectionAlignment < 1048576:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n                else:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n            if not NoStrip:\n                FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n                if not os.path.exists(FileBeforeStrip) or os.path.getmtime(File) > os.path.getmtime(FileBeforeStrip):\n                    CopyLongFilePath(File, FileBeforeStrip)\n                StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n                GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [File], Strip=True, IsMakefile=IsMakefile)\n                File = StrippedFile\n            if SectionType == BINARY_FILE_TYPE_TE:\n                TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n                GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [File], Type='te', IsMakefile=IsMakefile)\n                File = TeFile\n            GenFdsGlobalVariable.GenerateSection(OutputFile, [File], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n            OutputFileList.append(OutputFile)\n    else:\n        SecNum = '%d' % Index\n        GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n        OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n        GenSecInputFile = GenFdsGlobalVariable.MacroExtend(GenSecInputFile, Dict, self.CurrentArch)\n        if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n            ImageObj = PeImageClass(GenSecInputFile)\n            if ImageObj.SectionAlignment < 1024:\n                self.Alignment = str(ImageObj.SectionAlignment)\n            elif ImageObj.SectionAlignment < 1048576:\n                self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n            else:\n                self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n        if not NoStrip:\n            FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n            if not os.path.exists(FileBeforeStrip) or os.path.getmtime(GenSecInputFile) > os.path.getmtime(FileBeforeStrip):\n                CopyLongFilePath(GenSecInputFile, FileBeforeStrip)\n            StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n            GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [GenSecInputFile], Strip=True, IsMakefile=IsMakefile)\n            GenSecInputFile = StrippedFile\n        if SectionType == BINARY_FILE_TYPE_TE:\n            TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n            GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [GenSecInputFile], Type='te', IsMakefile=IsMakefile)\n            GenSecInputFile = TeFile\n        GenFdsGlobalVariable.GenerateSection(OutputFile, [GenSecInputFile], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n        OutputFileList.append(OutputFile)\n    return OutputFileList",
            "def __GenSimpleFileSection__(self, Rule, IsMakefile=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FileList = []\n    OutputFileList = []\n    GenSecInputFile = None\n    if Rule.FileName is not None:\n        GenSecInputFile = self.__ExtendMacro__(Rule.FileName)\n        if os.path.isabs(GenSecInputFile):\n            GenSecInputFile = os.path.normpath(GenSecInputFile)\n        else:\n            GenSecInputFile = os.path.normpath(os.path.join(self.EfiOutputPath, GenSecInputFile))\n    else:\n        (FileList, IsSect) = Section.Section.GetFileList(self, '', Rule.FileExtension)\n    Index = 1\n    SectionType = Rule.SectionType\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n            SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n    NoStrip = True\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM):\n        if self.KeepReloc is not None:\n            NoStrip = self.KeepReloc\n        elif Rule.KeepReloc is not None:\n            NoStrip = Rule.KeepReloc\n        elif self.ShadowFromInfFile is not None:\n            NoStrip = self.ShadowFromInfFile\n    if FileList != []:\n        for File in FileList:\n            SecNum = '%d' % Index\n            GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n            Index = Index + 1\n            OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n            File = GenFdsGlobalVariable.MacroExtend(File, Dict, self.CurrentArch)\n            if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n                ImageObj = PeImageClass(File)\n                if ImageObj.SectionAlignment < 1024:\n                    self.Alignment = str(ImageObj.SectionAlignment)\n                elif ImageObj.SectionAlignment < 1048576:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n                else:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n            if not NoStrip:\n                FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n                if not os.path.exists(FileBeforeStrip) or os.path.getmtime(File) > os.path.getmtime(FileBeforeStrip):\n                    CopyLongFilePath(File, FileBeforeStrip)\n                StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n                GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [File], Strip=True, IsMakefile=IsMakefile)\n                File = StrippedFile\n            if SectionType == BINARY_FILE_TYPE_TE:\n                TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n                GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [File], Type='te', IsMakefile=IsMakefile)\n                File = TeFile\n            GenFdsGlobalVariable.GenerateSection(OutputFile, [File], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n            OutputFileList.append(OutputFile)\n    else:\n        SecNum = '%d' % Index\n        GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n        OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n        GenSecInputFile = GenFdsGlobalVariable.MacroExtend(GenSecInputFile, Dict, self.CurrentArch)\n        if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n            ImageObj = PeImageClass(GenSecInputFile)\n            if ImageObj.SectionAlignment < 1024:\n                self.Alignment = str(ImageObj.SectionAlignment)\n            elif ImageObj.SectionAlignment < 1048576:\n                self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n            else:\n                self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n        if not NoStrip:\n            FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n            if not os.path.exists(FileBeforeStrip) or os.path.getmtime(GenSecInputFile) > os.path.getmtime(FileBeforeStrip):\n                CopyLongFilePath(GenSecInputFile, FileBeforeStrip)\n            StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n            GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [GenSecInputFile], Strip=True, IsMakefile=IsMakefile)\n            GenSecInputFile = StrippedFile\n        if SectionType == BINARY_FILE_TYPE_TE:\n            TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n            GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [GenSecInputFile], Type='te', IsMakefile=IsMakefile)\n            GenSecInputFile = TeFile\n        GenFdsGlobalVariable.GenerateSection(OutputFile, [GenSecInputFile], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n        OutputFileList.append(OutputFile)\n    return OutputFileList",
            "def __GenSimpleFileSection__(self, Rule, IsMakefile=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FileList = []\n    OutputFileList = []\n    GenSecInputFile = None\n    if Rule.FileName is not None:\n        GenSecInputFile = self.__ExtendMacro__(Rule.FileName)\n        if os.path.isabs(GenSecInputFile):\n            GenSecInputFile = os.path.normpath(GenSecInputFile)\n        else:\n            GenSecInputFile = os.path.normpath(os.path.join(self.EfiOutputPath, GenSecInputFile))\n    else:\n        (FileList, IsSect) = Section.Section.GetFileList(self, '', Rule.FileExtension)\n    Index = 1\n    SectionType = Rule.SectionType\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n        if SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n            SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n    if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n        if SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n            EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n    NoStrip = True\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM):\n        if self.KeepReloc is not None:\n            NoStrip = self.KeepReloc\n        elif Rule.KeepReloc is not None:\n            NoStrip = Rule.KeepReloc\n        elif self.ShadowFromInfFile is not None:\n            NoStrip = self.ShadowFromInfFile\n    if FileList != []:\n        for File in FileList:\n            SecNum = '%d' % Index\n            GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n            Index = Index + 1\n            OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n            File = GenFdsGlobalVariable.MacroExtend(File, Dict, self.CurrentArch)\n            if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n                ImageObj = PeImageClass(File)\n                if ImageObj.SectionAlignment < 1024:\n                    self.Alignment = str(ImageObj.SectionAlignment)\n                elif ImageObj.SectionAlignment < 1048576:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n                else:\n                    self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n            if not NoStrip:\n                FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n                if not os.path.exists(FileBeforeStrip) or os.path.getmtime(File) > os.path.getmtime(FileBeforeStrip):\n                    CopyLongFilePath(File, FileBeforeStrip)\n                StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n                GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [File], Strip=True, IsMakefile=IsMakefile)\n                File = StrippedFile\n            if SectionType == BINARY_FILE_TYPE_TE:\n                TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n                GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [File], Type='te', IsMakefile=IsMakefile)\n                File = TeFile\n            GenFdsGlobalVariable.GenerateSection(OutputFile, [File], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n            OutputFileList.append(OutputFile)\n    else:\n        SecNum = '%d' % Index\n        GenSecOutputFile = self.__ExtendMacro__(Rule.NameGuid) + SectionSuffix[SectionType] + SUP_MODULE_SEC + SecNum\n        OutputFile = os.path.join(self.OutputPath, GenSecOutputFile)\n        GenSecInputFile = GenFdsGlobalVariable.MacroExtend(GenSecInputFile, Dict, self.CurrentArch)\n        if self.Alignment == 'Auto' and (SectionType == BINARY_FILE_TYPE_PE32 or SectionType == BINARY_FILE_TYPE_TE):\n            ImageObj = PeImageClass(GenSecInputFile)\n            if ImageObj.SectionAlignment < 1024:\n                self.Alignment = str(ImageObj.SectionAlignment)\n            elif ImageObj.SectionAlignment < 1048576:\n                self.Alignment = str(ImageObj.SectionAlignment // 1024) + 'K'\n            else:\n                self.Alignment = str(ImageObj.SectionAlignment // 1048576) + 'M'\n        if not NoStrip:\n            FileBeforeStrip = os.path.join(self.OutputPath, ModuleName + '.reloc')\n            if not os.path.exists(FileBeforeStrip) or os.path.getmtime(GenSecInputFile) > os.path.getmtime(FileBeforeStrip):\n                CopyLongFilePath(GenSecInputFile, FileBeforeStrip)\n            StrippedFile = os.path.join(self.OutputPath, ModuleName + '.stipped')\n            GenFdsGlobalVariable.GenerateFirmwareImage(StrippedFile, [GenSecInputFile], Strip=True, IsMakefile=IsMakefile)\n            GenSecInputFile = StrippedFile\n        if SectionType == BINARY_FILE_TYPE_TE:\n            TeFile = os.path.join(self.OutputPath, self.ModuleGuid + 'Te.raw')\n            GenFdsGlobalVariable.GenerateFirmwareImage(TeFile, [GenSecInputFile], Type='te', IsMakefile=IsMakefile)\n            GenSecInputFile = TeFile\n        GenFdsGlobalVariable.GenerateSection(OutputFile, [GenSecInputFile], Section.Section.SectionType[SectionType], IsMakefile=IsMakefile)\n        OutputFileList.append(OutputFile)\n    return OutputFileList"
        ]
    },
    {
        "func_name": "__GenSimpleFileFfs__",
        "original": "def __GenSimpleFileFfs__(self, Rule, InputFileList, MakefilePath=None):\n    FfsOutput = self.OutputPath + os.sep + self.__ExtendMacro__(Rule.NameGuid) + '.ffs'\n    GenFdsGlobalVariable.VerboseLogger(self.__ExtendMacro__(Rule.NameGuid))\n    InputSection = []\n    SectionAlignments = []\n    for InputFile in InputFileList:\n        InputSection.append(InputFile)\n        SectionAlignments.append(Rule.SectAlignment)\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n        GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputSection, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=SectionAlignments, MakefilePath=MakefilePath)\n    return FfsOutput",
        "mutated": [
            "def __GenSimpleFileFfs__(self, Rule, InputFileList, MakefilePath=None):\n    if False:\n        i = 10\n    FfsOutput = self.OutputPath + os.sep + self.__ExtendMacro__(Rule.NameGuid) + '.ffs'\n    GenFdsGlobalVariable.VerboseLogger(self.__ExtendMacro__(Rule.NameGuid))\n    InputSection = []\n    SectionAlignments = []\n    for InputFile in InputFileList:\n        InputSection.append(InputFile)\n        SectionAlignments.append(Rule.SectAlignment)\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n        GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputSection, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=SectionAlignments, MakefilePath=MakefilePath)\n    return FfsOutput",
            "def __GenSimpleFileFfs__(self, Rule, InputFileList, MakefilePath=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FfsOutput = self.OutputPath + os.sep + self.__ExtendMacro__(Rule.NameGuid) + '.ffs'\n    GenFdsGlobalVariable.VerboseLogger(self.__ExtendMacro__(Rule.NameGuid))\n    InputSection = []\n    SectionAlignments = []\n    for InputFile in InputFileList:\n        InputSection.append(InputFile)\n        SectionAlignments.append(Rule.SectAlignment)\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n        GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputSection, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=SectionAlignments, MakefilePath=MakefilePath)\n    return FfsOutput",
            "def __GenSimpleFileFfs__(self, Rule, InputFileList, MakefilePath=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FfsOutput = self.OutputPath + os.sep + self.__ExtendMacro__(Rule.NameGuid) + '.ffs'\n    GenFdsGlobalVariable.VerboseLogger(self.__ExtendMacro__(Rule.NameGuid))\n    InputSection = []\n    SectionAlignments = []\n    for InputFile in InputFileList:\n        InputSection.append(InputFile)\n        SectionAlignments.append(Rule.SectAlignment)\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n        GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputSection, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=SectionAlignments, MakefilePath=MakefilePath)\n    return FfsOutput",
            "def __GenSimpleFileFfs__(self, Rule, InputFileList, MakefilePath=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FfsOutput = self.OutputPath + os.sep + self.__ExtendMacro__(Rule.NameGuid) + '.ffs'\n    GenFdsGlobalVariable.VerboseLogger(self.__ExtendMacro__(Rule.NameGuid))\n    InputSection = []\n    SectionAlignments = []\n    for InputFile in InputFileList:\n        InputSection.append(InputFile)\n        SectionAlignments.append(Rule.SectAlignment)\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n        GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputSection, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=SectionAlignments, MakefilePath=MakefilePath)\n    return FfsOutput",
            "def __GenSimpleFileFfs__(self, Rule, InputFileList, MakefilePath=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FfsOutput = self.OutputPath + os.sep + self.__ExtendMacro__(Rule.NameGuid) + '.ffs'\n    GenFdsGlobalVariable.VerboseLogger(self.__ExtendMacro__(Rule.NameGuid))\n    InputSection = []\n    SectionAlignments = []\n    for InputFile in InputFileList:\n        InputSection.append(InputFile)\n        SectionAlignments.append(Rule.SectAlignment)\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n        GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputSection, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=SectionAlignments, MakefilePath=MakefilePath)\n    return FfsOutput"
        ]
    },
    {
        "func_name": "__GenComplexFileSection__",
        "original": "def __GenComplexFileSection__(self, Rule, FvChildAddr, FvParentAddr, IsMakefile=False):\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM, SUP_MODULE_MM_CORE_STANDALONE):\n        if Rule.KeepReloc is not None:\n            self.KeepRelocFromRule = Rule.KeepReloc\n    SectFiles = []\n    SectAlignments = []\n    Index = 1\n    HasGeneratedFlag = False\n    if self.PcdIsDriver == 'PEI_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'PEIPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'PEIPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'PEIPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    elif self.PcdIsDriver == 'DXE_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'DXEPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'DXEPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'DXEPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    for Sect in Rule.SectionList:\n        SecIndex = '%d' % Index\n        SectList = []\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n                Sect.SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n                EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n        if FvChildAddr != []:\n            if isinstance(Sect, FvImageSection):\n                Sect.FvAddr = FvChildAddr.pop(0)\n            elif isinstance(Sect, GuidSection):\n                Sect.FvAddr = FvChildAddr\n        if FvParentAddr is not None and isinstance(Sect, GuidSection):\n            Sect.FvParentAddr = FvParentAddr\n        if Rule.KeyStringList != []:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, Rule.KeyStringList, self, IsMakefile=IsMakefile)\n        else:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, self.KeyStringList, self, IsMakefile=IsMakefile)\n        if not HasGeneratedFlag:\n            UniVfrOffsetFileSection = ''\n            ModuleFileName = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n            InfData = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClass(ModuleFileName), self.CurrentArch]\n            VfrUniBaseName = {}\n            VfrUniOffsetList = []\n            for SourceFile in InfData.Sources:\n                if SourceFile.Type.upper() == '.VFR':\n                    VfrUniBaseName[SourceFile.BaseName] = SourceFile.BaseName + 'Bin'\n                if SourceFile.Type.upper() == '.UNI':\n                    VfrUniBaseName['UniOffsetName'] = self.BaseName + 'Strings'\n            if len(VfrUniBaseName) > 0:\n                if IsMakefile:\n                    if InfData.BuildType != 'UEFI_HII':\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        TrimCmd = 'Trim --Vfr-Uni-Offset -o %s --ModuleName=%s --DebugDir=%s ' % (UniVfrOffsetFileName, self.BaseName, self.EfiDebugPath)\n                        GenFdsGlobalVariable.SecCmdList.append(TrimCmd)\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, [UniVfrOffsetFileName], 'EFI_SECTION_RAW', IsMakefile=True)\n                else:\n                    VfrUniOffsetList = self.__GetBuildOutputMapFileVfrUniInfo(VfrUniBaseName)\n                    if VfrUniOffsetList:\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        FfsInfStatement.__GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName)\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        'Call GenSection'\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, UniVfrOffsetFileNameList, 'EFI_SECTION_RAW')\n                if UniVfrOffsetFileSection:\n                    SectList.append(UniVfrOffsetFileSection)\n                    HasGeneratedFlag = True\n        for SecName in SectList:\n            SectFiles.append(SecName)\n            SectAlignments.append(Align)\n        Index = Index + 1\n    return (SectFiles, SectAlignments)",
        "mutated": [
            "def __GenComplexFileSection__(self, Rule, FvChildAddr, FvParentAddr, IsMakefile=False):\n    if False:\n        i = 10\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM, SUP_MODULE_MM_CORE_STANDALONE):\n        if Rule.KeepReloc is not None:\n            self.KeepRelocFromRule = Rule.KeepReloc\n    SectFiles = []\n    SectAlignments = []\n    Index = 1\n    HasGeneratedFlag = False\n    if self.PcdIsDriver == 'PEI_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'PEIPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'PEIPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'PEIPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    elif self.PcdIsDriver == 'DXE_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'DXEPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'DXEPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'DXEPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    for Sect in Rule.SectionList:\n        SecIndex = '%d' % Index\n        SectList = []\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n                Sect.SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n                EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n        if FvChildAddr != []:\n            if isinstance(Sect, FvImageSection):\n                Sect.FvAddr = FvChildAddr.pop(0)\n            elif isinstance(Sect, GuidSection):\n                Sect.FvAddr = FvChildAddr\n        if FvParentAddr is not None and isinstance(Sect, GuidSection):\n            Sect.FvParentAddr = FvParentAddr\n        if Rule.KeyStringList != []:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, Rule.KeyStringList, self, IsMakefile=IsMakefile)\n        else:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, self.KeyStringList, self, IsMakefile=IsMakefile)\n        if not HasGeneratedFlag:\n            UniVfrOffsetFileSection = ''\n            ModuleFileName = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n            InfData = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClass(ModuleFileName), self.CurrentArch]\n            VfrUniBaseName = {}\n            VfrUniOffsetList = []\n            for SourceFile in InfData.Sources:\n                if SourceFile.Type.upper() == '.VFR':\n                    VfrUniBaseName[SourceFile.BaseName] = SourceFile.BaseName + 'Bin'\n                if SourceFile.Type.upper() == '.UNI':\n                    VfrUniBaseName['UniOffsetName'] = self.BaseName + 'Strings'\n            if len(VfrUniBaseName) > 0:\n                if IsMakefile:\n                    if InfData.BuildType != 'UEFI_HII':\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        TrimCmd = 'Trim --Vfr-Uni-Offset -o %s --ModuleName=%s --DebugDir=%s ' % (UniVfrOffsetFileName, self.BaseName, self.EfiDebugPath)\n                        GenFdsGlobalVariable.SecCmdList.append(TrimCmd)\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, [UniVfrOffsetFileName], 'EFI_SECTION_RAW', IsMakefile=True)\n                else:\n                    VfrUniOffsetList = self.__GetBuildOutputMapFileVfrUniInfo(VfrUniBaseName)\n                    if VfrUniOffsetList:\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        FfsInfStatement.__GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName)\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        'Call GenSection'\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, UniVfrOffsetFileNameList, 'EFI_SECTION_RAW')\n                if UniVfrOffsetFileSection:\n                    SectList.append(UniVfrOffsetFileSection)\n                    HasGeneratedFlag = True\n        for SecName in SectList:\n            SectFiles.append(SecName)\n            SectAlignments.append(Align)\n        Index = Index + 1\n    return (SectFiles, SectAlignments)",
            "def __GenComplexFileSection__(self, Rule, FvChildAddr, FvParentAddr, IsMakefile=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM, SUP_MODULE_MM_CORE_STANDALONE):\n        if Rule.KeepReloc is not None:\n            self.KeepRelocFromRule = Rule.KeepReloc\n    SectFiles = []\n    SectAlignments = []\n    Index = 1\n    HasGeneratedFlag = False\n    if self.PcdIsDriver == 'PEI_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'PEIPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'PEIPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'PEIPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    elif self.PcdIsDriver == 'DXE_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'DXEPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'DXEPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'DXEPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    for Sect in Rule.SectionList:\n        SecIndex = '%d' % Index\n        SectList = []\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n                Sect.SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n                EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n        if FvChildAddr != []:\n            if isinstance(Sect, FvImageSection):\n                Sect.FvAddr = FvChildAddr.pop(0)\n            elif isinstance(Sect, GuidSection):\n                Sect.FvAddr = FvChildAddr\n        if FvParentAddr is not None and isinstance(Sect, GuidSection):\n            Sect.FvParentAddr = FvParentAddr\n        if Rule.KeyStringList != []:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, Rule.KeyStringList, self, IsMakefile=IsMakefile)\n        else:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, self.KeyStringList, self, IsMakefile=IsMakefile)\n        if not HasGeneratedFlag:\n            UniVfrOffsetFileSection = ''\n            ModuleFileName = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n            InfData = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClass(ModuleFileName), self.CurrentArch]\n            VfrUniBaseName = {}\n            VfrUniOffsetList = []\n            for SourceFile in InfData.Sources:\n                if SourceFile.Type.upper() == '.VFR':\n                    VfrUniBaseName[SourceFile.BaseName] = SourceFile.BaseName + 'Bin'\n                if SourceFile.Type.upper() == '.UNI':\n                    VfrUniBaseName['UniOffsetName'] = self.BaseName + 'Strings'\n            if len(VfrUniBaseName) > 0:\n                if IsMakefile:\n                    if InfData.BuildType != 'UEFI_HII':\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        TrimCmd = 'Trim --Vfr-Uni-Offset -o %s --ModuleName=%s --DebugDir=%s ' % (UniVfrOffsetFileName, self.BaseName, self.EfiDebugPath)\n                        GenFdsGlobalVariable.SecCmdList.append(TrimCmd)\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, [UniVfrOffsetFileName], 'EFI_SECTION_RAW', IsMakefile=True)\n                else:\n                    VfrUniOffsetList = self.__GetBuildOutputMapFileVfrUniInfo(VfrUniBaseName)\n                    if VfrUniOffsetList:\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        FfsInfStatement.__GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName)\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        'Call GenSection'\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, UniVfrOffsetFileNameList, 'EFI_SECTION_RAW')\n                if UniVfrOffsetFileSection:\n                    SectList.append(UniVfrOffsetFileSection)\n                    HasGeneratedFlag = True\n        for SecName in SectList:\n            SectFiles.append(SecName)\n            SectAlignments.append(Align)\n        Index = Index + 1\n    return (SectFiles, SectAlignments)",
            "def __GenComplexFileSection__(self, Rule, FvChildAddr, FvParentAddr, IsMakefile=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM, SUP_MODULE_MM_CORE_STANDALONE):\n        if Rule.KeepReloc is not None:\n            self.KeepRelocFromRule = Rule.KeepReloc\n    SectFiles = []\n    SectAlignments = []\n    Index = 1\n    HasGeneratedFlag = False\n    if self.PcdIsDriver == 'PEI_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'PEIPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'PEIPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'PEIPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    elif self.PcdIsDriver == 'DXE_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'DXEPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'DXEPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'DXEPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    for Sect in Rule.SectionList:\n        SecIndex = '%d' % Index\n        SectList = []\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n                Sect.SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n                EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n        if FvChildAddr != []:\n            if isinstance(Sect, FvImageSection):\n                Sect.FvAddr = FvChildAddr.pop(0)\n            elif isinstance(Sect, GuidSection):\n                Sect.FvAddr = FvChildAddr\n        if FvParentAddr is not None and isinstance(Sect, GuidSection):\n            Sect.FvParentAddr = FvParentAddr\n        if Rule.KeyStringList != []:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, Rule.KeyStringList, self, IsMakefile=IsMakefile)\n        else:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, self.KeyStringList, self, IsMakefile=IsMakefile)\n        if not HasGeneratedFlag:\n            UniVfrOffsetFileSection = ''\n            ModuleFileName = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n            InfData = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClass(ModuleFileName), self.CurrentArch]\n            VfrUniBaseName = {}\n            VfrUniOffsetList = []\n            for SourceFile in InfData.Sources:\n                if SourceFile.Type.upper() == '.VFR':\n                    VfrUniBaseName[SourceFile.BaseName] = SourceFile.BaseName + 'Bin'\n                if SourceFile.Type.upper() == '.UNI':\n                    VfrUniBaseName['UniOffsetName'] = self.BaseName + 'Strings'\n            if len(VfrUniBaseName) > 0:\n                if IsMakefile:\n                    if InfData.BuildType != 'UEFI_HII':\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        TrimCmd = 'Trim --Vfr-Uni-Offset -o %s --ModuleName=%s --DebugDir=%s ' % (UniVfrOffsetFileName, self.BaseName, self.EfiDebugPath)\n                        GenFdsGlobalVariable.SecCmdList.append(TrimCmd)\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, [UniVfrOffsetFileName], 'EFI_SECTION_RAW', IsMakefile=True)\n                else:\n                    VfrUniOffsetList = self.__GetBuildOutputMapFileVfrUniInfo(VfrUniBaseName)\n                    if VfrUniOffsetList:\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        FfsInfStatement.__GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName)\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        'Call GenSection'\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, UniVfrOffsetFileNameList, 'EFI_SECTION_RAW')\n                if UniVfrOffsetFileSection:\n                    SectList.append(UniVfrOffsetFileSection)\n                    HasGeneratedFlag = True\n        for SecName in SectList:\n            SectFiles.append(SecName)\n            SectAlignments.append(Align)\n        Index = Index + 1\n    return (SectFiles, SectAlignments)",
            "def __GenComplexFileSection__(self, Rule, FvChildAddr, FvParentAddr, IsMakefile=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM, SUP_MODULE_MM_CORE_STANDALONE):\n        if Rule.KeepReloc is not None:\n            self.KeepRelocFromRule = Rule.KeepReloc\n    SectFiles = []\n    SectAlignments = []\n    Index = 1\n    HasGeneratedFlag = False\n    if self.PcdIsDriver == 'PEI_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'PEIPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'PEIPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'PEIPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    elif self.PcdIsDriver == 'DXE_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'DXEPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'DXEPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'DXEPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    for Sect in Rule.SectionList:\n        SecIndex = '%d' % Index\n        SectList = []\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n                Sect.SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n                EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n        if FvChildAddr != []:\n            if isinstance(Sect, FvImageSection):\n                Sect.FvAddr = FvChildAddr.pop(0)\n            elif isinstance(Sect, GuidSection):\n                Sect.FvAddr = FvChildAddr\n        if FvParentAddr is not None and isinstance(Sect, GuidSection):\n            Sect.FvParentAddr = FvParentAddr\n        if Rule.KeyStringList != []:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, Rule.KeyStringList, self, IsMakefile=IsMakefile)\n        else:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, self.KeyStringList, self, IsMakefile=IsMakefile)\n        if not HasGeneratedFlag:\n            UniVfrOffsetFileSection = ''\n            ModuleFileName = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n            InfData = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClass(ModuleFileName), self.CurrentArch]\n            VfrUniBaseName = {}\n            VfrUniOffsetList = []\n            for SourceFile in InfData.Sources:\n                if SourceFile.Type.upper() == '.VFR':\n                    VfrUniBaseName[SourceFile.BaseName] = SourceFile.BaseName + 'Bin'\n                if SourceFile.Type.upper() == '.UNI':\n                    VfrUniBaseName['UniOffsetName'] = self.BaseName + 'Strings'\n            if len(VfrUniBaseName) > 0:\n                if IsMakefile:\n                    if InfData.BuildType != 'UEFI_HII':\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        TrimCmd = 'Trim --Vfr-Uni-Offset -o %s --ModuleName=%s --DebugDir=%s ' % (UniVfrOffsetFileName, self.BaseName, self.EfiDebugPath)\n                        GenFdsGlobalVariable.SecCmdList.append(TrimCmd)\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, [UniVfrOffsetFileName], 'EFI_SECTION_RAW', IsMakefile=True)\n                else:\n                    VfrUniOffsetList = self.__GetBuildOutputMapFileVfrUniInfo(VfrUniBaseName)\n                    if VfrUniOffsetList:\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        FfsInfStatement.__GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName)\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        'Call GenSection'\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, UniVfrOffsetFileNameList, 'EFI_SECTION_RAW')\n                if UniVfrOffsetFileSection:\n                    SectList.append(UniVfrOffsetFileSection)\n                    HasGeneratedFlag = True\n        for SecName in SectList:\n            SectFiles.append(SecName)\n            SectAlignments.append(Align)\n        Index = Index + 1\n    return (SectFiles, SectAlignments)",
            "def __GenComplexFileSection__(self, Rule, FvChildAddr, FvParentAddr, IsMakefile=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.ModuleType in (SUP_MODULE_SEC, SUP_MODULE_PEI_CORE, SUP_MODULE_PEIM, SUP_MODULE_MM_CORE_STANDALONE):\n        if Rule.KeepReloc is not None:\n            self.KeepRelocFromRule = Rule.KeepReloc\n    SectFiles = []\n    SectAlignments = []\n    Index = 1\n    HasGeneratedFlag = False\n    if self.PcdIsDriver == 'PEI_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'PEIPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'PEIPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'PEIPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    elif self.PcdIsDriver == 'DXE_PCD_DRIVER':\n        if self.IsBinaryModule:\n            PcdExDbFileName = os.path.join(GenFdsGlobalVariable.FvDir, 'DXEPcdDataBase.raw')\n        else:\n            PcdExDbFileName = os.path.join(self.EfiOutputPath, 'DXEPcdDataBase.raw')\n        PcdExDbSecName = os.path.join(self.OutputPath, 'DXEPcdDataBaseSec.raw')\n        GenFdsGlobalVariable.GenerateSection(PcdExDbSecName, [PcdExDbFileName], 'EFI_SECTION_RAW', IsMakefile=IsMakefile)\n        SectFiles.append(PcdExDbSecName)\n        SectAlignments.append(None)\n    for Sect in Rule.SectionList:\n        SecIndex = '%d' % Index\n        SectList = []\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) >= 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_DXE_DEPEX:\n                Sect.SectionType = BINARY_FILE_TYPE_SMM_DEPEX\n        if self.ModuleType == SUP_MODULE_DXE_SMM_DRIVER and int(self.PiSpecVersion, 16) < 65546:\n            if Sect.SectionType == BINARY_FILE_TYPE_SMM_DEPEX:\n                EdkLogger.error('GenFds', FORMAT_NOT_SUPPORTED, \"Framework SMM module doesn't support SMM_DEPEX section type\", File=self.InfFileName)\n        if FvChildAddr != []:\n            if isinstance(Sect, FvImageSection):\n                Sect.FvAddr = FvChildAddr.pop(0)\n            elif isinstance(Sect, GuidSection):\n                Sect.FvAddr = FvChildAddr\n        if FvParentAddr is not None and isinstance(Sect, GuidSection):\n            Sect.FvParentAddr = FvParentAddr\n        if Rule.KeyStringList != []:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, Rule.KeyStringList, self, IsMakefile=IsMakefile)\n        else:\n            (SectList, Align) = Sect.GenSection(self.OutputPath, self.ModuleGuid, SecIndex, self.KeyStringList, self, IsMakefile=IsMakefile)\n        if not HasGeneratedFlag:\n            UniVfrOffsetFileSection = ''\n            ModuleFileName = mws.join(GenFdsGlobalVariable.WorkSpaceDir, self.InfFileName)\n            InfData = GenFdsGlobalVariable.WorkSpace.BuildObject[PathClass(ModuleFileName), self.CurrentArch]\n            VfrUniBaseName = {}\n            VfrUniOffsetList = []\n            for SourceFile in InfData.Sources:\n                if SourceFile.Type.upper() == '.VFR':\n                    VfrUniBaseName[SourceFile.BaseName] = SourceFile.BaseName + 'Bin'\n                if SourceFile.Type.upper() == '.UNI':\n                    VfrUniBaseName['UniOffsetName'] = self.BaseName + 'Strings'\n            if len(VfrUniBaseName) > 0:\n                if IsMakefile:\n                    if InfData.BuildType != 'UEFI_HII':\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        TrimCmd = 'Trim --Vfr-Uni-Offset -o %s --ModuleName=%s --DebugDir=%s ' % (UniVfrOffsetFileName, self.BaseName, self.EfiDebugPath)\n                        GenFdsGlobalVariable.SecCmdList.append(TrimCmd)\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, [UniVfrOffsetFileName], 'EFI_SECTION_RAW', IsMakefile=True)\n                else:\n                    VfrUniOffsetList = self.__GetBuildOutputMapFileVfrUniInfo(VfrUniBaseName)\n                    if VfrUniOffsetList:\n                        UniVfrOffsetFileName = os.path.join(self.OutputPath, self.BaseName + '.offset')\n                        UniVfrOffsetFileSection = os.path.join(self.OutputPath, self.BaseName + 'Offset' + '.raw')\n                        FfsInfStatement.__GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName)\n                        UniVfrOffsetFileNameList = []\n                        UniVfrOffsetFileNameList.append(UniVfrOffsetFileName)\n                        'Call GenSection'\n                        GenFdsGlobalVariable.GenerateSection(UniVfrOffsetFileSection, UniVfrOffsetFileNameList, 'EFI_SECTION_RAW')\n                if UniVfrOffsetFileSection:\n                    SectList.append(UniVfrOffsetFileSection)\n                    HasGeneratedFlag = True\n        for SecName in SectList:\n            SectFiles.append(SecName)\n            SectAlignments.append(Align)\n        Index = Index + 1\n    return (SectFiles, SectAlignments)"
        ]
    },
    {
        "func_name": "__GenComplexFileFfs__",
        "original": "def __GenComplexFileFfs__(self, Rule, InputFile, Alignments, MakefilePath=None):\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n    FfsOutput = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputFile, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=Alignments, MakefilePath=MakefilePath)\n    return FfsOutput",
        "mutated": [
            "def __GenComplexFileFfs__(self, Rule, InputFile, Alignments, MakefilePath=None):\n    if False:\n        i = 10\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n    FfsOutput = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputFile, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=Alignments, MakefilePath=MakefilePath)\n    return FfsOutput",
            "def __GenComplexFileFfs__(self, Rule, InputFile, Alignments, MakefilePath=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n    FfsOutput = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputFile, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=Alignments, MakefilePath=MakefilePath)\n    return FfsOutput",
            "def __GenComplexFileFfs__(self, Rule, InputFile, Alignments, MakefilePath=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n    FfsOutput = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputFile, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=Alignments, MakefilePath=MakefilePath)\n    return FfsOutput",
            "def __GenComplexFileFfs__(self, Rule, InputFile, Alignments, MakefilePath=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n    FfsOutput = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputFile, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=Alignments, MakefilePath=MakefilePath)\n    return FfsOutput",
            "def __GenComplexFileFfs__(self, Rule, InputFile, Alignments, MakefilePath=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Rule.NameGuid is not None and Rule.NameGuid.startswith('PCD('):\n        PcdValue = GenFdsGlobalVariable.GetPcdValue(Rule.NameGuid)\n        if len(PcdValue) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, '%s NOT defined.' % Rule.NameGuid)\n        if PcdValue.startswith('{'):\n            PcdValue = GuidStructureByteArrayToGuidString(PcdValue)\n        RegistryGuidStr = PcdValue\n        if len(RegistryGuidStr) == 0:\n            EdkLogger.error('GenFds', GENFDS_ERROR, 'GUID value for %s in wrong format.' % Rule.NameGuid)\n        self.ModuleGuid = RegistryGuidStr\n    FfsOutput = os.path.join(self.OutputPath, self.ModuleGuid + '.ffs')\n    GenFdsGlobalVariable.GenerateFfs(FfsOutput, InputFile, FdfFvFileTypeToFileType[Rule.FvFileType], self.ModuleGuid, Fixed=Rule.Fixed, CheckSum=Rule.CheckSum, Align=Rule.Alignment, SectionAlign=Alignments, MakefilePath=MakefilePath)\n    return FfsOutput"
        ]
    },
    {
        "func_name": "__GetBuildOutputMapFileVfrUniInfo",
        "original": "def __GetBuildOutputMapFileVfrUniInfo(self, VfrUniBaseName):\n    MapFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.map')\n    EfiFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.efi')\n    return GetVariableOffset(MapFileName, EfiFileName, list(VfrUniBaseName.values()))",
        "mutated": [
            "def __GetBuildOutputMapFileVfrUniInfo(self, VfrUniBaseName):\n    if False:\n        i = 10\n    MapFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.map')\n    EfiFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.efi')\n    return GetVariableOffset(MapFileName, EfiFileName, list(VfrUniBaseName.values()))",
            "def __GetBuildOutputMapFileVfrUniInfo(self, VfrUniBaseName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    MapFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.map')\n    EfiFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.efi')\n    return GetVariableOffset(MapFileName, EfiFileName, list(VfrUniBaseName.values()))",
            "def __GetBuildOutputMapFileVfrUniInfo(self, VfrUniBaseName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    MapFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.map')\n    EfiFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.efi')\n    return GetVariableOffset(MapFileName, EfiFileName, list(VfrUniBaseName.values()))",
            "def __GetBuildOutputMapFileVfrUniInfo(self, VfrUniBaseName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    MapFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.map')\n    EfiFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.efi')\n    return GetVariableOffset(MapFileName, EfiFileName, list(VfrUniBaseName.values()))",
            "def __GetBuildOutputMapFileVfrUniInfo(self, VfrUniBaseName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    MapFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.map')\n    EfiFileName = os.path.join(self.EfiOutputPath, self.BaseName + '.efi')\n    return GetVariableOffset(MapFileName, EfiFileName, list(VfrUniBaseName.values()))"
        ]
    },
    {
        "func_name": "__GenUniVfrOffsetFile",
        "original": "@staticmethod\ndef __GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName):\n    fStringIO = BytesIO()\n    for Item in VfrUniOffsetList:\n        if Item[0].find('Strings') != -1:\n            UniGuid = b'\\xe0\\xc5\\x13\\x89\\xf63\\x86M\\x9b\\xf1C\\xef\\x89\\xfc\\x06f'\n            fStringIO.write(UniGuid)\n            UniValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(UniValue)\n        else:\n            VfrGuid = b'\\xb4|\\xbc\\xd0Gj_I\\xaa\\x11q\\x07F\\xda\\x06\\xa2'\n            fStringIO.write(VfrGuid)\n            type(Item[1])\n            VfrValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(VfrValue)\n    try:\n        SaveFileOnChange(UniVfrOffsetFileName, fStringIO.getvalue())\n    except:\n        EdkLogger.error('GenFds', FILE_WRITE_FAILURE, 'Write data to file %s failed, please check whether the file been locked or using by other applications.' % UniVfrOffsetFileName, None)\n    fStringIO.close()",
        "mutated": [
            "@staticmethod\ndef __GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName):\n    if False:\n        i = 10\n    fStringIO = BytesIO()\n    for Item in VfrUniOffsetList:\n        if Item[0].find('Strings') != -1:\n            UniGuid = b'\\xe0\\xc5\\x13\\x89\\xf63\\x86M\\x9b\\xf1C\\xef\\x89\\xfc\\x06f'\n            fStringIO.write(UniGuid)\n            UniValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(UniValue)\n        else:\n            VfrGuid = b'\\xb4|\\xbc\\xd0Gj_I\\xaa\\x11q\\x07F\\xda\\x06\\xa2'\n            fStringIO.write(VfrGuid)\n            type(Item[1])\n            VfrValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(VfrValue)\n    try:\n        SaveFileOnChange(UniVfrOffsetFileName, fStringIO.getvalue())\n    except:\n        EdkLogger.error('GenFds', FILE_WRITE_FAILURE, 'Write data to file %s failed, please check whether the file been locked or using by other applications.' % UniVfrOffsetFileName, None)\n    fStringIO.close()",
            "@staticmethod\ndef __GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    fStringIO = BytesIO()\n    for Item in VfrUniOffsetList:\n        if Item[0].find('Strings') != -1:\n            UniGuid = b'\\xe0\\xc5\\x13\\x89\\xf63\\x86M\\x9b\\xf1C\\xef\\x89\\xfc\\x06f'\n            fStringIO.write(UniGuid)\n            UniValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(UniValue)\n        else:\n            VfrGuid = b'\\xb4|\\xbc\\xd0Gj_I\\xaa\\x11q\\x07F\\xda\\x06\\xa2'\n            fStringIO.write(VfrGuid)\n            type(Item[1])\n            VfrValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(VfrValue)\n    try:\n        SaveFileOnChange(UniVfrOffsetFileName, fStringIO.getvalue())\n    except:\n        EdkLogger.error('GenFds', FILE_WRITE_FAILURE, 'Write data to file %s failed, please check whether the file been locked or using by other applications.' % UniVfrOffsetFileName, None)\n    fStringIO.close()",
            "@staticmethod\ndef __GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    fStringIO = BytesIO()\n    for Item in VfrUniOffsetList:\n        if Item[0].find('Strings') != -1:\n            UniGuid = b'\\xe0\\xc5\\x13\\x89\\xf63\\x86M\\x9b\\xf1C\\xef\\x89\\xfc\\x06f'\n            fStringIO.write(UniGuid)\n            UniValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(UniValue)\n        else:\n            VfrGuid = b'\\xb4|\\xbc\\xd0Gj_I\\xaa\\x11q\\x07F\\xda\\x06\\xa2'\n            fStringIO.write(VfrGuid)\n            type(Item[1])\n            VfrValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(VfrValue)\n    try:\n        SaveFileOnChange(UniVfrOffsetFileName, fStringIO.getvalue())\n    except:\n        EdkLogger.error('GenFds', FILE_WRITE_FAILURE, 'Write data to file %s failed, please check whether the file been locked or using by other applications.' % UniVfrOffsetFileName, None)\n    fStringIO.close()",
            "@staticmethod\ndef __GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    fStringIO = BytesIO()\n    for Item in VfrUniOffsetList:\n        if Item[0].find('Strings') != -1:\n            UniGuid = b'\\xe0\\xc5\\x13\\x89\\xf63\\x86M\\x9b\\xf1C\\xef\\x89\\xfc\\x06f'\n            fStringIO.write(UniGuid)\n            UniValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(UniValue)\n        else:\n            VfrGuid = b'\\xb4|\\xbc\\xd0Gj_I\\xaa\\x11q\\x07F\\xda\\x06\\xa2'\n            fStringIO.write(VfrGuid)\n            type(Item[1])\n            VfrValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(VfrValue)\n    try:\n        SaveFileOnChange(UniVfrOffsetFileName, fStringIO.getvalue())\n    except:\n        EdkLogger.error('GenFds', FILE_WRITE_FAILURE, 'Write data to file %s failed, please check whether the file been locked or using by other applications.' % UniVfrOffsetFileName, None)\n    fStringIO.close()",
            "@staticmethod\ndef __GenUniVfrOffsetFile(VfrUniOffsetList, UniVfrOffsetFileName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    fStringIO = BytesIO()\n    for Item in VfrUniOffsetList:\n        if Item[0].find('Strings') != -1:\n            UniGuid = b'\\xe0\\xc5\\x13\\x89\\xf63\\x86M\\x9b\\xf1C\\xef\\x89\\xfc\\x06f'\n            fStringIO.write(UniGuid)\n            UniValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(UniValue)\n        else:\n            VfrGuid = b'\\xb4|\\xbc\\xd0Gj_I\\xaa\\x11q\\x07F\\xda\\x06\\xa2'\n            fStringIO.write(VfrGuid)\n            type(Item[1])\n            VfrValue = pack('Q', int(Item[1], 16))\n            fStringIO.write(VfrValue)\n    try:\n        SaveFileOnChange(UniVfrOffsetFileName, fStringIO.getvalue())\n    except:\n        EdkLogger.error('GenFds', FILE_WRITE_FAILURE, 'Write data to file %s failed, please check whether the file been locked or using by other applications.' % UniVfrOffsetFileName, None)\n    fStringIO.close()"
        ]
    }
]