[
    {
        "func_name": "factory",
        "original": "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n    return container.bind_context(function)",
        "mutated": [
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n    if False:\n        i = 10\n    return container.bind_context(function)",
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return container.bind_context(function)",
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return container.bind_context(function)",
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return container.bind_context(function)",
            "@kinded\ndef factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return container.bind_context(function)"
        ]
    },
    {
        "func_name": "bind_context2",
        "original": "def bind_context2(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _SecondType]]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _UpdatedType, _SecondType]]]:\n    \"\"\"\n    Composes successful container with a function that returns a container.\n\n    In other words, it modifies the function's\n    signature from:\n    ``a -> RequresContext[b, c]``\n    to:\n    ``Container[a, c] -> Container[b, c]``\n\n    .. code:: python\n\n      >>> from returns.pointfree import bind_context2\n      >>> from returns.context import Reader\n\n      >>> def example(argument: int) -> Reader[int, int]:\n      ...     return Reader(lambda deps: argument + deps)\n\n      >>> assert bind_context2(example)(Reader.from_value(2))(3) == 5\n\n    Note, that this function works with only ``Kind2`` containers\n    with ``.bind_context`` method.\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\n    for more info.\n\n    \"\"\"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n        return container.bind_context(function)\n    return factory",
        "mutated": [
            "def bind_context2(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _SecondType]]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _UpdatedType, _SecondType]]]:\n    if False:\n        i = 10\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> RequresContext[b, c]``\\n    to:\\n    ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import bind_context2\\n      >>> from returns.context import Reader\\n\\n      >>> def example(argument: int) -> Reader[int, int]:\\n      ...     return Reader(lambda deps: argument + deps)\\n\\n      >>> assert bind_context2(example)(Reader.from_value(2))(3) == 5\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n        return container.bind_context(function)\n    return factory",
            "def bind_context2(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _SecondType]]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _UpdatedType, _SecondType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> RequresContext[b, c]``\\n    to:\\n    ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import bind_context2\\n      >>> from returns.context import Reader\\n\\n      >>> def example(argument: int) -> Reader[int, int]:\\n      ...     return Reader(lambda deps: argument + deps)\\n\\n      >>> assert bind_context2(example)(Reader.from_value(2))(3) == 5\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n        return container.bind_context(function)\n    return factory",
            "def bind_context2(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _SecondType]]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _UpdatedType, _SecondType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> RequresContext[b, c]``\\n    to:\\n    ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import bind_context2\\n      >>> from returns.context import Reader\\n\\n      >>> def example(argument: int) -> Reader[int, int]:\\n      ...     return Reader(lambda deps: argument + deps)\\n\\n      >>> assert bind_context2(example)(Reader.from_value(2))(3) == 5\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n        return container.bind_context(function)\n    return factory",
            "def bind_context2(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _SecondType]]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _UpdatedType, _SecondType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> RequresContext[b, c]``\\n    to:\\n    ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import bind_context2\\n      >>> from returns.context import Reader\\n\\n      >>> def example(argument: int) -> Reader[int, int]:\\n      ...     return Reader(lambda deps: argument + deps)\\n\\n      >>> assert bind_context2(example)(Reader.from_value(2))(3) == 5\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n        return container.bind_context(function)\n    return factory",
            "def bind_context2(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _SecondType]]) -> Kinded[Callable[[Kind2[_Reader2Kind, _FirstType, _SecondType]], Kind2[_Reader2Kind, _UpdatedType, _SecondType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from:\\n    ``a -> RequresContext[b, c]``\\n    to:\\n    ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n      >>> from returns.pointfree import bind_context2\\n      >>> from returns.context import Reader\\n\\n      >>> def example(argument: int) -> Reader[int, int]:\\n      ...     return Reader(lambda deps: argument + deps)\\n\\n      >>> assert bind_context2(example)(Reader.from_value(2))(3) == 5\\n\\n    Note, that this function works with only ``Kind2`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike2`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind2[_Reader2Kind, _FirstType, _SecondType]) -> Kind2[_Reader2Kind, _UpdatedType, _SecondType]:\n        return container.bind_context(function)\n    return factory"
        ]
    },
    {
        "func_name": "factory",
        "original": "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n    return container.bind_context(function)",
        "mutated": [
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n    if False:\n        i = 10\n    return container.bind_context(function)",
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return container.bind_context(function)",
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return container.bind_context(function)",
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return container.bind_context(function)",
            "@kinded\ndef factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return container.bind_context(function)"
        ]
    },
    {
        "func_name": "bind_context3",
        "original": "def bind_context3(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _ThirdType]]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]]]:\n    \"\"\"\n    Composes successful container with a function that returns a container.\n\n    In other words, it modifies the function's\n    signature from: ``a -> RequresContext[b, c]``\n    to: ``Container[a, c] -> Container[b, c]``\n\n    .. code:: python\n\n        >>> from returns.context import RequiresContext, RequiresContextResult\n        >>> from returns.result import Success, Failure\n        >>> from returns.pointfree import bind_context\n\n        >>> def function(arg: int) -> RequiresContext[str, int]:\n        ...     return RequiresContext(lambda deps: len(deps) + arg)\n\n        >>> assert bind_context(function)(\n        ...     RequiresContextResult.from_value(2),\n        ... )('abc') == Success(5)\n        >>> assert bind_context(function)(\n        ...     RequiresContextResult.from_failure(0),\n        ... )('abc') == Failure(0)\n\n    Note, that this function works with only ``Kind3`` containers\n    with ``.bind_context`` method.\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\n    for more info.\n\n    \"\"\"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n        return container.bind_context(function)\n    return factory",
        "mutated": [
            "def bind_context3(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _ThirdType]]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]]]:\n    if False:\n        i = 10\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> RequresContext[b, c]``\\n    to: ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n        >>> from returns.context import RequiresContext, RequiresContextResult\\n        >>> from returns.result import Success, Failure\\n        >>> from returns.pointfree import bind_context\\n\\n        >>> def function(arg: int) -> RequiresContext[str, int]:\\n        ...     return RequiresContext(lambda deps: len(deps) + arg)\\n\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_value(2),\\n        ... )('abc') == Success(5)\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_failure(0),\\n        ... )('abc') == Failure(0)\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n        return container.bind_context(function)\n    return factory",
            "def bind_context3(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _ThirdType]]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> RequresContext[b, c]``\\n    to: ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n        >>> from returns.context import RequiresContext, RequiresContextResult\\n        >>> from returns.result import Success, Failure\\n        >>> from returns.pointfree import bind_context\\n\\n        >>> def function(arg: int) -> RequiresContext[str, int]:\\n        ...     return RequiresContext(lambda deps: len(deps) + arg)\\n\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_value(2),\\n        ... )('abc') == Success(5)\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_failure(0),\\n        ... )('abc') == Failure(0)\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n        return container.bind_context(function)\n    return factory",
            "def bind_context3(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _ThirdType]]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> RequresContext[b, c]``\\n    to: ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n        >>> from returns.context import RequiresContext, RequiresContextResult\\n        >>> from returns.result import Success, Failure\\n        >>> from returns.pointfree import bind_context\\n\\n        >>> def function(arg: int) -> RequiresContext[str, int]:\\n        ...     return RequiresContext(lambda deps: len(deps) + arg)\\n\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_value(2),\\n        ... )('abc') == Success(5)\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_failure(0),\\n        ... )('abc') == Failure(0)\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n        return container.bind_context(function)\n    return factory",
            "def bind_context3(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _ThirdType]]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> RequresContext[b, c]``\\n    to: ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n        >>> from returns.context import RequiresContext, RequiresContextResult\\n        >>> from returns.result import Success, Failure\\n        >>> from returns.pointfree import bind_context\\n\\n        >>> def function(arg: int) -> RequiresContext[str, int]:\\n        ...     return RequiresContext(lambda deps: len(deps) + arg)\\n\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_value(2),\\n        ... )('abc') == Success(5)\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_failure(0),\\n        ... )('abc') == Failure(0)\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n        return container.bind_context(function)\n    return factory",
            "def bind_context3(function: Callable[[_FirstType], RequiresContext[_UpdatedType, _ThirdType]]) -> Kinded[Callable[[Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]], Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Composes successful container with a function that returns a container.\\n\\n    In other words, it modifies the function's\\n    signature from: ``a -> RequresContext[b, c]``\\n    to: ``Container[a, c] -> Container[b, c]``\\n\\n    .. code:: python\\n\\n        >>> from returns.context import RequiresContext, RequiresContextResult\\n        >>> from returns.result import Success, Failure\\n        >>> from returns.pointfree import bind_context\\n\\n        >>> def function(arg: int) -> RequiresContext[str, int]:\\n        ...     return RequiresContext(lambda deps: len(deps) + arg)\\n\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_value(2),\\n        ... )('abc') == Success(5)\\n        >>> assert bind_context(function)(\\n        ...     RequiresContextResult.from_failure(0),\\n        ... )('abc') == Failure(0)\\n\\n    Note, that this function works with only ``Kind3`` containers\\n    with ``.bind_context`` method.\\n    See :class:`returns.primitives.interfaces.specific.reader.ReaderLike3`\\n    for more info.\\n\\n    \"\n\n    @kinded\n    def factory(container: Kind3[_Reader3Kind, _FirstType, _SecondType, _ThirdType]) -> Kind3[_Reader3Kind, _UpdatedType, _SecondType, _ThirdType]:\n        return container.bind_context(function)\n    return factory"
        ]
    }
]