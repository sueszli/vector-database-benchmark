[
    {
        "func_name": "__init__",
        "original": "def __init__(self, context, srckey, laykey, grdkey=None):\n    self.context = context\n    self.scn = context.scene\n    GeoScene.__init__(self, self.scn)\n    self.area = context.area\n    self.area3d = [r for r in self.area.regions if r.type == 'WINDOW'][0]\n    self.view3d = self.area.spaces.active\n    self.reg3d = self.view3d.region_3d\n    prefs = context.preferences.addons[PKG].preferences\n    cacheFolder = prefs.cacheFolder\n    self.synchOrj = prefs.synchOrj\n    MapService.RESAMP_ALG = prefs.resamplAlg\n    self.srv = MapService(srckey, cacheFolder)\n    self.name = srckey + '_' + laykey + '_' + grdkey\n    if grdkey is None:\n        grdkey = self.srv.srcGridKey\n    if grdkey == self.srv.srcGridKey:\n        self.tm = self.srv.srcTms\n    else:\n        self.srv.setDstGrid(grdkey)\n        self.tm = self.srv.dstTms\n    if not self.hasCRS:\n        self.crs = self.tm.CRS\n    if not self.hasOriginPrj:\n        self.setOriginPrj(0, 0, self.synchOrj)\n    if not self.hasScale:\n        self.scale = 1\n    if not self.hasZoom:\n        self.zoom = 0\n    self.lockedZoom = None\n    if bpy.data.is_saved:\n        folder = os.path.dirname(bpy.data.filepath) + os.sep\n    else:\n        folder = bpy.app.tempdir\n    self.imgPath = folder + self.name + '.tif'\n    self.layer = self.srv.layers[laykey]\n    self.srckey = srckey\n    self.laykey = laykey\n    self.grdkey = grdkey\n    self.thread = None\n    self.img = None\n    self.bkg = None\n    self.viewDstZ = None",
        "mutated": [
            "def __init__(self, context, srckey, laykey, grdkey=None):\n    if False:\n        i = 10\n    self.context = context\n    self.scn = context.scene\n    GeoScene.__init__(self, self.scn)\n    self.area = context.area\n    self.area3d = [r for r in self.area.regions if r.type == 'WINDOW'][0]\n    self.view3d = self.area.spaces.active\n    self.reg3d = self.view3d.region_3d\n    prefs = context.preferences.addons[PKG].preferences\n    cacheFolder = prefs.cacheFolder\n    self.synchOrj = prefs.synchOrj\n    MapService.RESAMP_ALG = prefs.resamplAlg\n    self.srv = MapService(srckey, cacheFolder)\n    self.name = srckey + '_' + laykey + '_' + grdkey\n    if grdkey is None:\n        grdkey = self.srv.srcGridKey\n    if grdkey == self.srv.srcGridKey:\n        self.tm = self.srv.srcTms\n    else:\n        self.srv.setDstGrid(grdkey)\n        self.tm = self.srv.dstTms\n    if not self.hasCRS:\n        self.crs = self.tm.CRS\n    if not self.hasOriginPrj:\n        self.setOriginPrj(0, 0, self.synchOrj)\n    if not self.hasScale:\n        self.scale = 1\n    if not self.hasZoom:\n        self.zoom = 0\n    self.lockedZoom = None\n    if bpy.data.is_saved:\n        folder = os.path.dirname(bpy.data.filepath) + os.sep\n    else:\n        folder = bpy.app.tempdir\n    self.imgPath = folder + self.name + '.tif'\n    self.layer = self.srv.layers[laykey]\n    self.srckey = srckey\n    self.laykey = laykey\n    self.grdkey = grdkey\n    self.thread = None\n    self.img = None\n    self.bkg = None\n    self.viewDstZ = None",
            "def __init__(self, context, srckey, laykey, grdkey=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.context = context\n    self.scn = context.scene\n    GeoScene.__init__(self, self.scn)\n    self.area = context.area\n    self.area3d = [r for r in self.area.regions if r.type == 'WINDOW'][0]\n    self.view3d = self.area.spaces.active\n    self.reg3d = self.view3d.region_3d\n    prefs = context.preferences.addons[PKG].preferences\n    cacheFolder = prefs.cacheFolder\n    self.synchOrj = prefs.synchOrj\n    MapService.RESAMP_ALG = prefs.resamplAlg\n    self.srv = MapService(srckey, cacheFolder)\n    self.name = srckey + '_' + laykey + '_' + grdkey\n    if grdkey is None:\n        grdkey = self.srv.srcGridKey\n    if grdkey == self.srv.srcGridKey:\n        self.tm = self.srv.srcTms\n    else:\n        self.srv.setDstGrid(grdkey)\n        self.tm = self.srv.dstTms\n    if not self.hasCRS:\n        self.crs = self.tm.CRS\n    if not self.hasOriginPrj:\n        self.setOriginPrj(0, 0, self.synchOrj)\n    if not self.hasScale:\n        self.scale = 1\n    if not self.hasZoom:\n        self.zoom = 0\n    self.lockedZoom = None\n    if bpy.data.is_saved:\n        folder = os.path.dirname(bpy.data.filepath) + os.sep\n    else:\n        folder = bpy.app.tempdir\n    self.imgPath = folder + self.name + '.tif'\n    self.layer = self.srv.layers[laykey]\n    self.srckey = srckey\n    self.laykey = laykey\n    self.grdkey = grdkey\n    self.thread = None\n    self.img = None\n    self.bkg = None\n    self.viewDstZ = None",
            "def __init__(self, context, srckey, laykey, grdkey=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.context = context\n    self.scn = context.scene\n    GeoScene.__init__(self, self.scn)\n    self.area = context.area\n    self.area3d = [r for r in self.area.regions if r.type == 'WINDOW'][0]\n    self.view3d = self.area.spaces.active\n    self.reg3d = self.view3d.region_3d\n    prefs = context.preferences.addons[PKG].preferences\n    cacheFolder = prefs.cacheFolder\n    self.synchOrj = prefs.synchOrj\n    MapService.RESAMP_ALG = prefs.resamplAlg\n    self.srv = MapService(srckey, cacheFolder)\n    self.name = srckey + '_' + laykey + '_' + grdkey\n    if grdkey is None:\n        grdkey = self.srv.srcGridKey\n    if grdkey == self.srv.srcGridKey:\n        self.tm = self.srv.srcTms\n    else:\n        self.srv.setDstGrid(grdkey)\n        self.tm = self.srv.dstTms\n    if not self.hasCRS:\n        self.crs = self.tm.CRS\n    if not self.hasOriginPrj:\n        self.setOriginPrj(0, 0, self.synchOrj)\n    if not self.hasScale:\n        self.scale = 1\n    if not self.hasZoom:\n        self.zoom = 0\n    self.lockedZoom = None\n    if bpy.data.is_saved:\n        folder = os.path.dirname(bpy.data.filepath) + os.sep\n    else:\n        folder = bpy.app.tempdir\n    self.imgPath = folder + self.name + '.tif'\n    self.layer = self.srv.layers[laykey]\n    self.srckey = srckey\n    self.laykey = laykey\n    self.grdkey = grdkey\n    self.thread = None\n    self.img = None\n    self.bkg = None\n    self.viewDstZ = None",
            "def __init__(self, context, srckey, laykey, grdkey=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.context = context\n    self.scn = context.scene\n    GeoScene.__init__(self, self.scn)\n    self.area = context.area\n    self.area3d = [r for r in self.area.regions if r.type == 'WINDOW'][0]\n    self.view3d = self.area.spaces.active\n    self.reg3d = self.view3d.region_3d\n    prefs = context.preferences.addons[PKG].preferences\n    cacheFolder = prefs.cacheFolder\n    self.synchOrj = prefs.synchOrj\n    MapService.RESAMP_ALG = prefs.resamplAlg\n    self.srv = MapService(srckey, cacheFolder)\n    self.name = srckey + '_' + laykey + '_' + grdkey\n    if grdkey is None:\n        grdkey = self.srv.srcGridKey\n    if grdkey == self.srv.srcGridKey:\n        self.tm = self.srv.srcTms\n    else:\n        self.srv.setDstGrid(grdkey)\n        self.tm = self.srv.dstTms\n    if not self.hasCRS:\n        self.crs = self.tm.CRS\n    if not self.hasOriginPrj:\n        self.setOriginPrj(0, 0, self.synchOrj)\n    if not self.hasScale:\n        self.scale = 1\n    if not self.hasZoom:\n        self.zoom = 0\n    self.lockedZoom = None\n    if bpy.data.is_saved:\n        folder = os.path.dirname(bpy.data.filepath) + os.sep\n    else:\n        folder = bpy.app.tempdir\n    self.imgPath = folder + self.name + '.tif'\n    self.layer = self.srv.layers[laykey]\n    self.srckey = srckey\n    self.laykey = laykey\n    self.grdkey = grdkey\n    self.thread = None\n    self.img = None\n    self.bkg = None\n    self.viewDstZ = None",
            "def __init__(self, context, srckey, laykey, grdkey=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.context = context\n    self.scn = context.scene\n    GeoScene.__init__(self, self.scn)\n    self.area = context.area\n    self.area3d = [r for r in self.area.regions if r.type == 'WINDOW'][0]\n    self.view3d = self.area.spaces.active\n    self.reg3d = self.view3d.region_3d\n    prefs = context.preferences.addons[PKG].preferences\n    cacheFolder = prefs.cacheFolder\n    self.synchOrj = prefs.synchOrj\n    MapService.RESAMP_ALG = prefs.resamplAlg\n    self.srv = MapService(srckey, cacheFolder)\n    self.name = srckey + '_' + laykey + '_' + grdkey\n    if grdkey is None:\n        grdkey = self.srv.srcGridKey\n    if grdkey == self.srv.srcGridKey:\n        self.tm = self.srv.srcTms\n    else:\n        self.srv.setDstGrid(grdkey)\n        self.tm = self.srv.dstTms\n    if not self.hasCRS:\n        self.crs = self.tm.CRS\n    if not self.hasOriginPrj:\n        self.setOriginPrj(0, 0, self.synchOrj)\n    if not self.hasScale:\n        self.scale = 1\n    if not self.hasZoom:\n        self.zoom = 0\n    self.lockedZoom = None\n    if bpy.data.is_saved:\n        folder = os.path.dirname(bpy.data.filepath) + os.sep\n    else:\n        folder = bpy.app.tempdir\n    self.imgPath = folder + self.name + '.tif'\n    self.layer = self.srv.layers[laykey]\n    self.srckey = srckey\n    self.laykey = laykey\n    self.grdkey = grdkey\n    self.thread = None\n    self.img = None\n    self.bkg = None\n    self.viewDstZ = None"
        ]
    },
    {
        "func_name": "get",
        "original": "def get(self):\n    \"\"\"Launch run() function in a new thread\"\"\"\n    self.stop()\n    self.srv.start()\n    self.thread = threading.Thread(target=self.run)\n    self.thread.start()",
        "mutated": [
            "def get(self):\n    if False:\n        i = 10\n    'Launch run() function in a new thread'\n    self.stop()\n    self.srv.start()\n    self.thread = threading.Thread(target=self.run)\n    self.thread.start()",
            "def get(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Launch run() function in a new thread'\n    self.stop()\n    self.srv.start()\n    self.thread = threading.Thread(target=self.run)\n    self.thread.start()",
            "def get(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Launch run() function in a new thread'\n    self.stop()\n    self.srv.start()\n    self.thread = threading.Thread(target=self.run)\n    self.thread.start()",
            "def get(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Launch run() function in a new thread'\n    self.stop()\n    self.srv.start()\n    self.thread = threading.Thread(target=self.run)\n    self.thread.start()",
            "def get(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Launch run() function in a new thread'\n    self.stop()\n    self.srv.start()\n    self.thread = threading.Thread(target=self.run)\n    self.thread.start()"
        ]
    },
    {
        "func_name": "stop",
        "original": "def stop(self):\n    \"\"\"Stop actual thread\"\"\"\n    if self.srv.running:\n        self.srv.stop()\n        self.thread.join()",
        "mutated": [
            "def stop(self):\n    if False:\n        i = 10\n    'Stop actual thread'\n    if self.srv.running:\n        self.srv.stop()\n        self.thread.join()",
            "def stop(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Stop actual thread'\n    if self.srv.running:\n        self.srv.stop()\n        self.thread.join()",
            "def stop(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Stop actual thread'\n    if self.srv.running:\n        self.srv.stop()\n        self.thread.join()",
            "def stop(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Stop actual thread'\n    if self.srv.running:\n        self.srv.stop()\n        self.thread.join()",
            "def stop(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Stop actual thread'\n    if self.srv.running:\n        self.srv.stop()\n        self.thread.join()"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self):\n    \"\"\"thread method\"\"\"\n    self.mosaic = self.request()\n    if self.srv.running and self.mosaic is not None:\n        self.mosaic.save(self.imgPath)\n    if self.srv.running:\n        self.place()\n    self.srv.stop()",
        "mutated": [
            "def run(self):\n    if False:\n        i = 10\n    'thread method'\n    self.mosaic = self.request()\n    if self.srv.running and self.mosaic is not None:\n        self.mosaic.save(self.imgPath)\n    if self.srv.running:\n        self.place()\n    self.srv.stop()",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'thread method'\n    self.mosaic = self.request()\n    if self.srv.running and self.mosaic is not None:\n        self.mosaic.save(self.imgPath)\n    if self.srv.running:\n        self.place()\n    self.srv.stop()",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'thread method'\n    self.mosaic = self.request()\n    if self.srv.running and self.mosaic is not None:\n        self.mosaic.save(self.imgPath)\n    if self.srv.running:\n        self.place()\n    self.srv.stop()",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'thread method'\n    self.mosaic = self.request()\n    if self.srv.running and self.mosaic is not None:\n        self.mosaic.save(self.imgPath)\n    if self.srv.running:\n        self.place()\n    self.srv.stop()",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'thread method'\n    self.mosaic = self.request()\n    if self.srv.running and self.mosaic is not None:\n        self.mosaic.save(self.imgPath)\n    if self.srv.running:\n        self.place()\n    self.srv.stop()"
        ]
    },
    {
        "func_name": "moveOrigin",
        "original": "def moveOrigin(self, dx, dy, useScale=True, updObjLoc=True):\n    \"\"\"Move scene origin and update props\"\"\"\n    self.moveOriginPrj(dx, dy, useScale, updObjLoc, self.synchOrj)",
        "mutated": [
            "def moveOrigin(self, dx, dy, useScale=True, updObjLoc=True):\n    if False:\n        i = 10\n    'Move scene origin and update props'\n    self.moveOriginPrj(dx, dy, useScale, updObjLoc, self.synchOrj)",
            "def moveOrigin(self, dx, dy, useScale=True, updObjLoc=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Move scene origin and update props'\n    self.moveOriginPrj(dx, dy, useScale, updObjLoc, self.synchOrj)",
            "def moveOrigin(self, dx, dy, useScale=True, updObjLoc=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Move scene origin and update props'\n    self.moveOriginPrj(dx, dy, useScale, updObjLoc, self.synchOrj)",
            "def moveOrigin(self, dx, dy, useScale=True, updObjLoc=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Move scene origin and update props'\n    self.moveOriginPrj(dx, dy, useScale, updObjLoc, self.synchOrj)",
            "def moveOrigin(self, dx, dy, useScale=True, updObjLoc=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Move scene origin and update props'\n    self.moveOriginPrj(dx, dy, useScale, updObjLoc, self.synchOrj)"
        ]
    },
    {
        "func_name": "request",
        "original": "def request(self):\n    \"\"\"Request map service to build a mosaic of required tiles to cover view3d area\"\"\"\n    (w, h) = (self.area.width, self.area.height)\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    if self.crs == 'EPSG:4326':\n        res = meters2dd(res)\n    (dx, dy, dz) = self.reg3d.view_location\n    ox = self.crsx + dx * self.scale\n    oy = self.crsy + dy * self.scale\n    xmin = ox - w / 2 * res * self.scale\n    ymax = oy + h / 2 * res * self.scale\n    xmax = ox + w / 2 * res * self.scale\n    ymin = oy - h / 2 * res * self.scale\n    bbox = (xmin, ymin, xmax, ymax)\n    if self.crs != self.tm.CRS:\n        bbox = reprojBbox(self.crs, self.tm.CRS, bbox)\n    '\\n\\t\\t#Method 2\\n\\t\\tbbox = getBBOX.fromTopView(self.context) #ERROR context is None ????\\n\\t\\tbbox = bbox.toGeo(geoscn=self)\\n\\t\\tif self.crs != self.tm.CRS:\\n\\t\\t\\tbbox = reprojBbox(self.crs, self.tm.CRS, bbox)\\n\\t\\t'\n    log.debug('Bounding box request : {}'.format(bbox))\n    if self.srv.srcGridKey == self.grdkey:\n        toDstGrid = False\n    else:\n        toDstGrid = True\n    mosaic = self.srv.getImage(self.laykey, bbox, self.zoom, toDstGrid=toDstGrid, outCRS=self.crs)\n    return mosaic",
        "mutated": [
            "def request(self):\n    if False:\n        i = 10\n    'Request map service to build a mosaic of required tiles to cover view3d area'\n    (w, h) = (self.area.width, self.area.height)\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    if self.crs == 'EPSG:4326':\n        res = meters2dd(res)\n    (dx, dy, dz) = self.reg3d.view_location\n    ox = self.crsx + dx * self.scale\n    oy = self.crsy + dy * self.scale\n    xmin = ox - w / 2 * res * self.scale\n    ymax = oy + h / 2 * res * self.scale\n    xmax = ox + w / 2 * res * self.scale\n    ymin = oy - h / 2 * res * self.scale\n    bbox = (xmin, ymin, xmax, ymax)\n    if self.crs != self.tm.CRS:\n        bbox = reprojBbox(self.crs, self.tm.CRS, bbox)\n    '\\n\\t\\t#Method 2\\n\\t\\tbbox = getBBOX.fromTopView(self.context) #ERROR context is None ????\\n\\t\\tbbox = bbox.toGeo(geoscn=self)\\n\\t\\tif self.crs != self.tm.CRS:\\n\\t\\t\\tbbox = reprojBbox(self.crs, self.tm.CRS, bbox)\\n\\t\\t'\n    log.debug('Bounding box request : {}'.format(bbox))\n    if self.srv.srcGridKey == self.grdkey:\n        toDstGrid = False\n    else:\n        toDstGrid = True\n    mosaic = self.srv.getImage(self.laykey, bbox, self.zoom, toDstGrid=toDstGrid, outCRS=self.crs)\n    return mosaic",
            "def request(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Request map service to build a mosaic of required tiles to cover view3d area'\n    (w, h) = (self.area.width, self.area.height)\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    if self.crs == 'EPSG:4326':\n        res = meters2dd(res)\n    (dx, dy, dz) = self.reg3d.view_location\n    ox = self.crsx + dx * self.scale\n    oy = self.crsy + dy * self.scale\n    xmin = ox - w / 2 * res * self.scale\n    ymax = oy + h / 2 * res * self.scale\n    xmax = ox + w / 2 * res * self.scale\n    ymin = oy - h / 2 * res * self.scale\n    bbox = (xmin, ymin, xmax, ymax)\n    if self.crs != self.tm.CRS:\n        bbox = reprojBbox(self.crs, self.tm.CRS, bbox)\n    '\\n\\t\\t#Method 2\\n\\t\\tbbox = getBBOX.fromTopView(self.context) #ERROR context is None ????\\n\\t\\tbbox = bbox.toGeo(geoscn=self)\\n\\t\\tif self.crs != self.tm.CRS:\\n\\t\\t\\tbbox = reprojBbox(self.crs, self.tm.CRS, bbox)\\n\\t\\t'\n    log.debug('Bounding box request : {}'.format(bbox))\n    if self.srv.srcGridKey == self.grdkey:\n        toDstGrid = False\n    else:\n        toDstGrid = True\n    mosaic = self.srv.getImage(self.laykey, bbox, self.zoom, toDstGrid=toDstGrid, outCRS=self.crs)\n    return mosaic",
            "def request(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Request map service to build a mosaic of required tiles to cover view3d area'\n    (w, h) = (self.area.width, self.area.height)\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    if self.crs == 'EPSG:4326':\n        res = meters2dd(res)\n    (dx, dy, dz) = self.reg3d.view_location\n    ox = self.crsx + dx * self.scale\n    oy = self.crsy + dy * self.scale\n    xmin = ox - w / 2 * res * self.scale\n    ymax = oy + h / 2 * res * self.scale\n    xmax = ox + w / 2 * res * self.scale\n    ymin = oy - h / 2 * res * self.scale\n    bbox = (xmin, ymin, xmax, ymax)\n    if self.crs != self.tm.CRS:\n        bbox = reprojBbox(self.crs, self.tm.CRS, bbox)\n    '\\n\\t\\t#Method 2\\n\\t\\tbbox = getBBOX.fromTopView(self.context) #ERROR context is None ????\\n\\t\\tbbox = bbox.toGeo(geoscn=self)\\n\\t\\tif self.crs != self.tm.CRS:\\n\\t\\t\\tbbox = reprojBbox(self.crs, self.tm.CRS, bbox)\\n\\t\\t'\n    log.debug('Bounding box request : {}'.format(bbox))\n    if self.srv.srcGridKey == self.grdkey:\n        toDstGrid = False\n    else:\n        toDstGrid = True\n    mosaic = self.srv.getImage(self.laykey, bbox, self.zoom, toDstGrid=toDstGrid, outCRS=self.crs)\n    return mosaic",
            "def request(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Request map service to build a mosaic of required tiles to cover view3d area'\n    (w, h) = (self.area.width, self.area.height)\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    if self.crs == 'EPSG:4326':\n        res = meters2dd(res)\n    (dx, dy, dz) = self.reg3d.view_location\n    ox = self.crsx + dx * self.scale\n    oy = self.crsy + dy * self.scale\n    xmin = ox - w / 2 * res * self.scale\n    ymax = oy + h / 2 * res * self.scale\n    xmax = ox + w / 2 * res * self.scale\n    ymin = oy - h / 2 * res * self.scale\n    bbox = (xmin, ymin, xmax, ymax)\n    if self.crs != self.tm.CRS:\n        bbox = reprojBbox(self.crs, self.tm.CRS, bbox)\n    '\\n\\t\\t#Method 2\\n\\t\\tbbox = getBBOX.fromTopView(self.context) #ERROR context is None ????\\n\\t\\tbbox = bbox.toGeo(geoscn=self)\\n\\t\\tif self.crs != self.tm.CRS:\\n\\t\\t\\tbbox = reprojBbox(self.crs, self.tm.CRS, bbox)\\n\\t\\t'\n    log.debug('Bounding box request : {}'.format(bbox))\n    if self.srv.srcGridKey == self.grdkey:\n        toDstGrid = False\n    else:\n        toDstGrid = True\n    mosaic = self.srv.getImage(self.laykey, bbox, self.zoom, toDstGrid=toDstGrid, outCRS=self.crs)\n    return mosaic",
            "def request(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Request map service to build a mosaic of required tiles to cover view3d area'\n    (w, h) = (self.area.width, self.area.height)\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    if self.crs == 'EPSG:4326':\n        res = meters2dd(res)\n    (dx, dy, dz) = self.reg3d.view_location\n    ox = self.crsx + dx * self.scale\n    oy = self.crsy + dy * self.scale\n    xmin = ox - w / 2 * res * self.scale\n    ymax = oy + h / 2 * res * self.scale\n    xmax = ox + w / 2 * res * self.scale\n    ymin = oy - h / 2 * res * self.scale\n    bbox = (xmin, ymin, xmax, ymax)\n    if self.crs != self.tm.CRS:\n        bbox = reprojBbox(self.crs, self.tm.CRS, bbox)\n    '\\n\\t\\t#Method 2\\n\\t\\tbbox = getBBOX.fromTopView(self.context) #ERROR context is None ????\\n\\t\\tbbox = bbox.toGeo(geoscn=self)\\n\\t\\tif self.crs != self.tm.CRS:\\n\\t\\t\\tbbox = reprojBbox(self.crs, self.tm.CRS, bbox)\\n\\t\\t'\n    log.debug('Bounding box request : {}'.format(bbox))\n    if self.srv.srcGridKey == self.grdkey:\n        toDstGrid = False\n    else:\n        toDstGrid = True\n    mosaic = self.srv.getImage(self.laykey, bbox, self.zoom, toDstGrid=toDstGrid, outCRS=self.crs)\n    return mosaic"
        ]
    },
    {
        "func_name": "place",
        "original": "def place(self):\n    \"\"\"Set map as background image\"\"\"\n    try:\n        self.img = [img for img in bpy.data.images if img.filepath == self.imgPath and len(img.packed_files) == 0][0]\n    except IndexError:\n        self.img = bpy.data.images.load(self.imgPath)\n    empties = [obj for obj in self.scn.objects if obj.type == 'EMPTY']\n    bkgs = [obj for obj in empties if obj.empty_display_type == 'IMAGE']\n    for bkg in bkgs:\n        bkg.hide_viewport = True\n    try:\n        self.bkg = [bkg for bkg in bkgs if bkg.data.filepath == self.imgPath and len(bkg.data.packed_files) == 0][0]\n    except IndexError:\n        self.bkg = bpy.data.objects.new(self.name, None)\n        self.bkg.empty_display_type = 'IMAGE'\n        self.bkg.empty_image_depth = 'BACK'\n        self.bkg.data = self.img\n        self.scn.collection.objects.link(self.bkg)\n    else:\n        self.bkg.hide_viewport = False\n    (img_ox, img_oy) = self.mosaic.center\n    (img_w, img_h) = self.mosaic.size\n    res = self.mosaic.pxSize.x\n    sizex = img_w * res / self.scale\n    sizey = img_h * res / self.scale\n    size = max([sizex, sizey])\n    self.bkg.empty_display_size = 1\n    self.bkg.scale = (size, size, 1)\n    dx = (self.crsx - img_ox) / self.scale\n    dy = (self.crsy - img_oy) / self.scale\n    self.bkg.location = (-dx, -dy, 0)\n    dst = max([self.area.width, self.area.height])\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    dst = dst * res / self.scale\n    view3D_aperture = 36\n    view3D_zoom = 2\n    fov = 2 * math.atan(view3D_aperture / (self.view3d.lens * 2))\n    fov = math.atan(math.tan(fov / 2) * view3D_zoom) * 2\n    zdst = dst / 2 / math.tan(fov / 2)\n    zdst = math.floor(zdst)\n    self.reg3d.view_distance = zdst\n    self.viewDstZ = zdst\n    self.bkg.data.reload()",
        "mutated": [
            "def place(self):\n    if False:\n        i = 10\n    'Set map as background image'\n    try:\n        self.img = [img for img in bpy.data.images if img.filepath == self.imgPath and len(img.packed_files) == 0][0]\n    except IndexError:\n        self.img = bpy.data.images.load(self.imgPath)\n    empties = [obj for obj in self.scn.objects if obj.type == 'EMPTY']\n    bkgs = [obj for obj in empties if obj.empty_display_type == 'IMAGE']\n    for bkg in bkgs:\n        bkg.hide_viewport = True\n    try:\n        self.bkg = [bkg for bkg in bkgs if bkg.data.filepath == self.imgPath and len(bkg.data.packed_files) == 0][0]\n    except IndexError:\n        self.bkg = bpy.data.objects.new(self.name, None)\n        self.bkg.empty_display_type = 'IMAGE'\n        self.bkg.empty_image_depth = 'BACK'\n        self.bkg.data = self.img\n        self.scn.collection.objects.link(self.bkg)\n    else:\n        self.bkg.hide_viewport = False\n    (img_ox, img_oy) = self.mosaic.center\n    (img_w, img_h) = self.mosaic.size\n    res = self.mosaic.pxSize.x\n    sizex = img_w * res / self.scale\n    sizey = img_h * res / self.scale\n    size = max([sizex, sizey])\n    self.bkg.empty_display_size = 1\n    self.bkg.scale = (size, size, 1)\n    dx = (self.crsx - img_ox) / self.scale\n    dy = (self.crsy - img_oy) / self.scale\n    self.bkg.location = (-dx, -dy, 0)\n    dst = max([self.area.width, self.area.height])\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    dst = dst * res / self.scale\n    view3D_aperture = 36\n    view3D_zoom = 2\n    fov = 2 * math.atan(view3D_aperture / (self.view3d.lens * 2))\n    fov = math.atan(math.tan(fov / 2) * view3D_zoom) * 2\n    zdst = dst / 2 / math.tan(fov / 2)\n    zdst = math.floor(zdst)\n    self.reg3d.view_distance = zdst\n    self.viewDstZ = zdst\n    self.bkg.data.reload()",
            "def place(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Set map as background image'\n    try:\n        self.img = [img for img in bpy.data.images if img.filepath == self.imgPath and len(img.packed_files) == 0][0]\n    except IndexError:\n        self.img = bpy.data.images.load(self.imgPath)\n    empties = [obj for obj in self.scn.objects if obj.type == 'EMPTY']\n    bkgs = [obj for obj in empties if obj.empty_display_type == 'IMAGE']\n    for bkg in bkgs:\n        bkg.hide_viewport = True\n    try:\n        self.bkg = [bkg for bkg in bkgs if bkg.data.filepath == self.imgPath and len(bkg.data.packed_files) == 0][0]\n    except IndexError:\n        self.bkg = bpy.data.objects.new(self.name, None)\n        self.bkg.empty_display_type = 'IMAGE'\n        self.bkg.empty_image_depth = 'BACK'\n        self.bkg.data = self.img\n        self.scn.collection.objects.link(self.bkg)\n    else:\n        self.bkg.hide_viewport = False\n    (img_ox, img_oy) = self.mosaic.center\n    (img_w, img_h) = self.mosaic.size\n    res = self.mosaic.pxSize.x\n    sizex = img_w * res / self.scale\n    sizey = img_h * res / self.scale\n    size = max([sizex, sizey])\n    self.bkg.empty_display_size = 1\n    self.bkg.scale = (size, size, 1)\n    dx = (self.crsx - img_ox) / self.scale\n    dy = (self.crsy - img_oy) / self.scale\n    self.bkg.location = (-dx, -dy, 0)\n    dst = max([self.area.width, self.area.height])\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    dst = dst * res / self.scale\n    view3D_aperture = 36\n    view3D_zoom = 2\n    fov = 2 * math.atan(view3D_aperture / (self.view3d.lens * 2))\n    fov = math.atan(math.tan(fov / 2) * view3D_zoom) * 2\n    zdst = dst / 2 / math.tan(fov / 2)\n    zdst = math.floor(zdst)\n    self.reg3d.view_distance = zdst\n    self.viewDstZ = zdst\n    self.bkg.data.reload()",
            "def place(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Set map as background image'\n    try:\n        self.img = [img for img in bpy.data.images if img.filepath == self.imgPath and len(img.packed_files) == 0][0]\n    except IndexError:\n        self.img = bpy.data.images.load(self.imgPath)\n    empties = [obj for obj in self.scn.objects if obj.type == 'EMPTY']\n    bkgs = [obj for obj in empties if obj.empty_display_type == 'IMAGE']\n    for bkg in bkgs:\n        bkg.hide_viewport = True\n    try:\n        self.bkg = [bkg for bkg in bkgs if bkg.data.filepath == self.imgPath and len(bkg.data.packed_files) == 0][0]\n    except IndexError:\n        self.bkg = bpy.data.objects.new(self.name, None)\n        self.bkg.empty_display_type = 'IMAGE'\n        self.bkg.empty_image_depth = 'BACK'\n        self.bkg.data = self.img\n        self.scn.collection.objects.link(self.bkg)\n    else:\n        self.bkg.hide_viewport = False\n    (img_ox, img_oy) = self.mosaic.center\n    (img_w, img_h) = self.mosaic.size\n    res = self.mosaic.pxSize.x\n    sizex = img_w * res / self.scale\n    sizey = img_h * res / self.scale\n    size = max([sizex, sizey])\n    self.bkg.empty_display_size = 1\n    self.bkg.scale = (size, size, 1)\n    dx = (self.crsx - img_ox) / self.scale\n    dy = (self.crsy - img_oy) / self.scale\n    self.bkg.location = (-dx, -dy, 0)\n    dst = max([self.area.width, self.area.height])\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    dst = dst * res / self.scale\n    view3D_aperture = 36\n    view3D_zoom = 2\n    fov = 2 * math.atan(view3D_aperture / (self.view3d.lens * 2))\n    fov = math.atan(math.tan(fov / 2) * view3D_zoom) * 2\n    zdst = dst / 2 / math.tan(fov / 2)\n    zdst = math.floor(zdst)\n    self.reg3d.view_distance = zdst\n    self.viewDstZ = zdst\n    self.bkg.data.reload()",
            "def place(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Set map as background image'\n    try:\n        self.img = [img for img in bpy.data.images if img.filepath == self.imgPath and len(img.packed_files) == 0][0]\n    except IndexError:\n        self.img = bpy.data.images.load(self.imgPath)\n    empties = [obj for obj in self.scn.objects if obj.type == 'EMPTY']\n    bkgs = [obj for obj in empties if obj.empty_display_type == 'IMAGE']\n    for bkg in bkgs:\n        bkg.hide_viewport = True\n    try:\n        self.bkg = [bkg for bkg in bkgs if bkg.data.filepath == self.imgPath and len(bkg.data.packed_files) == 0][0]\n    except IndexError:\n        self.bkg = bpy.data.objects.new(self.name, None)\n        self.bkg.empty_display_type = 'IMAGE'\n        self.bkg.empty_image_depth = 'BACK'\n        self.bkg.data = self.img\n        self.scn.collection.objects.link(self.bkg)\n    else:\n        self.bkg.hide_viewport = False\n    (img_ox, img_oy) = self.mosaic.center\n    (img_w, img_h) = self.mosaic.size\n    res = self.mosaic.pxSize.x\n    sizex = img_w * res / self.scale\n    sizey = img_h * res / self.scale\n    size = max([sizex, sizey])\n    self.bkg.empty_display_size = 1\n    self.bkg.scale = (size, size, 1)\n    dx = (self.crsx - img_ox) / self.scale\n    dy = (self.crsy - img_oy) / self.scale\n    self.bkg.location = (-dx, -dy, 0)\n    dst = max([self.area.width, self.area.height])\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    dst = dst * res / self.scale\n    view3D_aperture = 36\n    view3D_zoom = 2\n    fov = 2 * math.atan(view3D_aperture / (self.view3d.lens * 2))\n    fov = math.atan(math.tan(fov / 2) * view3D_zoom) * 2\n    zdst = dst / 2 / math.tan(fov / 2)\n    zdst = math.floor(zdst)\n    self.reg3d.view_distance = zdst\n    self.viewDstZ = zdst\n    self.bkg.data.reload()",
            "def place(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Set map as background image'\n    try:\n        self.img = [img for img in bpy.data.images if img.filepath == self.imgPath and len(img.packed_files) == 0][0]\n    except IndexError:\n        self.img = bpy.data.images.load(self.imgPath)\n    empties = [obj for obj in self.scn.objects if obj.type == 'EMPTY']\n    bkgs = [obj for obj in empties if obj.empty_display_type == 'IMAGE']\n    for bkg in bkgs:\n        bkg.hide_viewport = True\n    try:\n        self.bkg = [bkg for bkg in bkgs if bkg.data.filepath == self.imgPath and len(bkg.data.packed_files) == 0][0]\n    except IndexError:\n        self.bkg = bpy.data.objects.new(self.name, None)\n        self.bkg.empty_display_type = 'IMAGE'\n        self.bkg.empty_image_depth = 'BACK'\n        self.bkg.data = self.img\n        self.scn.collection.objects.link(self.bkg)\n    else:\n        self.bkg.hide_viewport = False\n    (img_ox, img_oy) = self.mosaic.center\n    (img_w, img_h) = self.mosaic.size\n    res = self.mosaic.pxSize.x\n    sizex = img_w * res / self.scale\n    sizey = img_h * res / self.scale\n    size = max([sizex, sizey])\n    self.bkg.empty_display_size = 1\n    self.bkg.scale = (size, size, 1)\n    dx = (self.crsx - img_ox) / self.scale\n    dy = (self.crsy - img_oy) / self.scale\n    self.bkg.location = (-dx, -dy, 0)\n    dst = max([self.area.width, self.area.height])\n    z = self.lockedZoom if self.lockedZoom is not None else self.zoom\n    res = self.tm.getRes(z)\n    dst = dst * res / self.scale\n    view3D_aperture = 36\n    view3D_zoom = 2\n    fov = 2 * math.atan(view3D_aperture / (self.view3d.lens * 2))\n    fov = math.atan(math.tan(fov / 2) * view3D_zoom) * 2\n    zdst = dst / 2 / math.tan(fov / 2)\n    zdst = math.floor(zdst)\n    self.reg3d.view_distance = zdst\n    self.viewDstZ = zdst\n    self.bkg.data.reload()"
        ]
    },
    {
        "func_name": "drawInfosText",
        "original": "def drawInfosText(self, context):\n    scn = context.scene\n    area = context.area\n    area3d = [reg for reg in area.regions if reg.type == 'WINDOW'][0]\n    view3d = area.spaces.active\n    reg3d = view3d.region_3d\n    geoscn = GeoScene(scn)\n    zoom = geoscn.zoom\n    scale = geoscn.scale\n    txt = 'Map view : '\n    txt += 'Zoom ' + str(zoom)\n    if self.map.lockedZoom is not None:\n        txt += ' (Locked)'\n    txt += ' - Scale 1:' + str(int(scale))\n    \"\\n\\t# view3d distance\\n\\tdst = reg3d.view_distance\\n\\tif dst > 1000:\\n\\t\\tdst /= 1000\\n\\t\\tunit = 'km'\\n\\telse:\\n\\t\\tunit = 'm'\\n\\ttxt += ' 3D View distance ' + str(int(dst)) + ' ' + unit\\n\\t\"\n    txt += ' ' + str((int(self.posx), int(self.posy)))\n    txt += ' ' + self.progress\n    context.area.header_text_set(txt)",
        "mutated": [
            "def drawInfosText(self, context):\n    if False:\n        i = 10\n    scn = context.scene\n    area = context.area\n    area3d = [reg for reg in area.regions if reg.type == 'WINDOW'][0]\n    view3d = area.spaces.active\n    reg3d = view3d.region_3d\n    geoscn = GeoScene(scn)\n    zoom = geoscn.zoom\n    scale = geoscn.scale\n    txt = 'Map view : '\n    txt += 'Zoom ' + str(zoom)\n    if self.map.lockedZoom is not None:\n        txt += ' (Locked)'\n    txt += ' - Scale 1:' + str(int(scale))\n    \"\\n\\t# view3d distance\\n\\tdst = reg3d.view_distance\\n\\tif dst > 1000:\\n\\t\\tdst /= 1000\\n\\t\\tunit = 'km'\\n\\telse:\\n\\t\\tunit = 'm'\\n\\ttxt += ' 3D View distance ' + str(int(dst)) + ' ' + unit\\n\\t\"\n    txt += ' ' + str((int(self.posx), int(self.posy)))\n    txt += ' ' + self.progress\n    context.area.header_text_set(txt)",
            "def drawInfosText(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    scn = context.scene\n    area = context.area\n    area3d = [reg for reg in area.regions if reg.type == 'WINDOW'][0]\n    view3d = area.spaces.active\n    reg3d = view3d.region_3d\n    geoscn = GeoScene(scn)\n    zoom = geoscn.zoom\n    scale = geoscn.scale\n    txt = 'Map view : '\n    txt += 'Zoom ' + str(zoom)\n    if self.map.lockedZoom is not None:\n        txt += ' (Locked)'\n    txt += ' - Scale 1:' + str(int(scale))\n    \"\\n\\t# view3d distance\\n\\tdst = reg3d.view_distance\\n\\tif dst > 1000:\\n\\t\\tdst /= 1000\\n\\t\\tunit = 'km'\\n\\telse:\\n\\t\\tunit = 'm'\\n\\ttxt += ' 3D View distance ' + str(int(dst)) + ' ' + unit\\n\\t\"\n    txt += ' ' + str((int(self.posx), int(self.posy)))\n    txt += ' ' + self.progress\n    context.area.header_text_set(txt)",
            "def drawInfosText(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    scn = context.scene\n    area = context.area\n    area3d = [reg for reg in area.regions if reg.type == 'WINDOW'][0]\n    view3d = area.spaces.active\n    reg3d = view3d.region_3d\n    geoscn = GeoScene(scn)\n    zoom = geoscn.zoom\n    scale = geoscn.scale\n    txt = 'Map view : '\n    txt += 'Zoom ' + str(zoom)\n    if self.map.lockedZoom is not None:\n        txt += ' (Locked)'\n    txt += ' - Scale 1:' + str(int(scale))\n    \"\\n\\t# view3d distance\\n\\tdst = reg3d.view_distance\\n\\tif dst > 1000:\\n\\t\\tdst /= 1000\\n\\t\\tunit = 'km'\\n\\telse:\\n\\t\\tunit = 'm'\\n\\ttxt += ' 3D View distance ' + str(int(dst)) + ' ' + unit\\n\\t\"\n    txt += ' ' + str((int(self.posx), int(self.posy)))\n    txt += ' ' + self.progress\n    context.area.header_text_set(txt)",
            "def drawInfosText(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    scn = context.scene\n    area = context.area\n    area3d = [reg for reg in area.regions if reg.type == 'WINDOW'][0]\n    view3d = area.spaces.active\n    reg3d = view3d.region_3d\n    geoscn = GeoScene(scn)\n    zoom = geoscn.zoom\n    scale = geoscn.scale\n    txt = 'Map view : '\n    txt += 'Zoom ' + str(zoom)\n    if self.map.lockedZoom is not None:\n        txt += ' (Locked)'\n    txt += ' - Scale 1:' + str(int(scale))\n    \"\\n\\t# view3d distance\\n\\tdst = reg3d.view_distance\\n\\tif dst > 1000:\\n\\t\\tdst /= 1000\\n\\t\\tunit = 'km'\\n\\telse:\\n\\t\\tunit = 'm'\\n\\ttxt += ' 3D View distance ' + str(int(dst)) + ' ' + unit\\n\\t\"\n    txt += ' ' + str((int(self.posx), int(self.posy)))\n    txt += ' ' + self.progress\n    context.area.header_text_set(txt)",
            "def drawInfosText(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    scn = context.scene\n    area = context.area\n    area3d = [reg for reg in area.regions if reg.type == 'WINDOW'][0]\n    view3d = area.spaces.active\n    reg3d = view3d.region_3d\n    geoscn = GeoScene(scn)\n    zoom = geoscn.zoom\n    scale = geoscn.scale\n    txt = 'Map view : '\n    txt += 'Zoom ' + str(zoom)\n    if self.map.lockedZoom is not None:\n        txt += ' (Locked)'\n    txt += ' - Scale 1:' + str(int(scale))\n    \"\\n\\t# view3d distance\\n\\tdst = reg3d.view_distance\\n\\tif dst > 1000:\\n\\t\\tdst /= 1000\\n\\t\\tunit = 'km'\\n\\telse:\\n\\t\\tunit = 'm'\\n\\ttxt += ' 3D View distance ' + str(int(dst)) + ' ' + unit\\n\\t\"\n    txt += ' ' + str((int(self.posx), int(self.posy)))\n    txt += ' ' + self.progress\n    context.area.header_text_set(txt)"
        ]
    },
    {
        "func_name": "drawZoomBox",
        "original": "def drawZoomBox(self, context):\n    if self.zoomBoxMode and (not self.zoomBoxDrag):\n        (px, py) = (self.zb_xmax, self.zb_ymax)\n        p1 = (0, py, 0)\n        p2 = (context.area.width, py, 0)\n        p3 = (px, 0, 0)\n        p4 = (px, context.area.height, 0)\n        coords = [p1, p2, p3, p4]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)\n    elif self.zoomBoxMode and self.zoomBoxDrag:\n        p1 = (self.zb_xmin, self.zb_ymin, 0)\n        p2 = (self.zb_xmin, self.zb_ymax, 0)\n        p3 = (self.zb_xmax, self.zb_ymax, 0)\n        p4 = (self.zb_xmax, self.zb_ymin, 0)\n        coords = [p1, p2, p2, p3, p3, p4, p4, p1]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)",
        "mutated": [
            "def drawZoomBox(self, context):\n    if False:\n        i = 10\n    if self.zoomBoxMode and (not self.zoomBoxDrag):\n        (px, py) = (self.zb_xmax, self.zb_ymax)\n        p1 = (0, py, 0)\n        p2 = (context.area.width, py, 0)\n        p3 = (px, 0, 0)\n        p4 = (px, context.area.height, 0)\n        coords = [p1, p2, p3, p4]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)\n    elif self.zoomBoxMode and self.zoomBoxDrag:\n        p1 = (self.zb_xmin, self.zb_ymin, 0)\n        p2 = (self.zb_xmin, self.zb_ymax, 0)\n        p3 = (self.zb_xmax, self.zb_ymax, 0)\n        p4 = (self.zb_xmax, self.zb_ymin, 0)\n        coords = [p1, p2, p2, p3, p3, p4, p4, p1]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)",
            "def drawZoomBox(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.zoomBoxMode and (not self.zoomBoxDrag):\n        (px, py) = (self.zb_xmax, self.zb_ymax)\n        p1 = (0, py, 0)\n        p2 = (context.area.width, py, 0)\n        p3 = (px, 0, 0)\n        p4 = (px, context.area.height, 0)\n        coords = [p1, p2, p3, p4]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)\n    elif self.zoomBoxMode and self.zoomBoxDrag:\n        p1 = (self.zb_xmin, self.zb_ymin, 0)\n        p2 = (self.zb_xmin, self.zb_ymax, 0)\n        p3 = (self.zb_xmax, self.zb_ymax, 0)\n        p4 = (self.zb_xmax, self.zb_ymin, 0)\n        coords = [p1, p2, p2, p3, p3, p4, p4, p1]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)",
            "def drawZoomBox(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.zoomBoxMode and (not self.zoomBoxDrag):\n        (px, py) = (self.zb_xmax, self.zb_ymax)\n        p1 = (0, py, 0)\n        p2 = (context.area.width, py, 0)\n        p3 = (px, 0, 0)\n        p4 = (px, context.area.height, 0)\n        coords = [p1, p2, p3, p4]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)\n    elif self.zoomBoxMode and self.zoomBoxDrag:\n        p1 = (self.zb_xmin, self.zb_ymin, 0)\n        p2 = (self.zb_xmin, self.zb_ymax, 0)\n        p3 = (self.zb_xmax, self.zb_ymax, 0)\n        p4 = (self.zb_xmax, self.zb_ymin, 0)\n        coords = [p1, p2, p2, p3, p3, p4, p4, p1]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)",
            "def drawZoomBox(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.zoomBoxMode and (not self.zoomBoxDrag):\n        (px, py) = (self.zb_xmax, self.zb_ymax)\n        p1 = (0, py, 0)\n        p2 = (context.area.width, py, 0)\n        p3 = (px, 0, 0)\n        p4 = (px, context.area.height, 0)\n        coords = [p1, p2, p3, p4]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)\n    elif self.zoomBoxMode and self.zoomBoxDrag:\n        p1 = (self.zb_xmin, self.zb_ymin, 0)\n        p2 = (self.zb_xmin, self.zb_ymax, 0)\n        p3 = (self.zb_xmax, self.zb_ymax, 0)\n        p4 = (self.zb_xmax, self.zb_ymin, 0)\n        coords = [p1, p2, p2, p3, p3, p4, p4, p1]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)",
            "def drawZoomBox(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.zoomBoxMode and (not self.zoomBoxDrag):\n        (px, py) = (self.zb_xmax, self.zb_ymax)\n        p1 = (0, py, 0)\n        p2 = (context.area.width, py, 0)\n        p3 = (px, 0, 0)\n        p4 = (px, context.area.height, 0)\n        coords = [p1, p2, p3, p4]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)\n    elif self.zoomBoxMode and self.zoomBoxDrag:\n        p1 = (self.zb_xmin, self.zb_ymin, 0)\n        p2 = (self.zb_xmin, self.zb_ymax, 0)\n        p3 = (self.zb_xmax, self.zb_ymax, 0)\n        p4 = (self.zb_xmax, self.zb_ymin, 0)\n        coords = [p1, p2, p2, p3, p3, p4, p4, p1]\n        shader = gpu.shader.from_builtin('3D_UNIFORM_COLOR')\n        batch = batch_for_shader(shader, 'LINES', {'pos': coords})\n        shader.bind()\n        shader.uniform_float('color', (0, 0, 0, 1))\n        batch.draw(shader)"
        ]
    },
    {
        "func_name": "check",
        "original": "def check(self, context):\n    return True",
        "mutated": [
            "def check(self, context):\n    if False:\n        i = 10\n    return True",
            "def check(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return True",
            "def check(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return True",
            "def check(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return True",
            "def check(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return True"
        ]
    },
    {
        "func_name": "listSources",
        "original": "def listSources(self, context):\n    srcItems = []\n    for (srckey, src) in SOURCES.items():\n        srcItems.append((srckey, src['name'], src['description']))\n    return srcItems",
        "mutated": [
            "def listSources(self, context):\n    if False:\n        i = 10\n    srcItems = []\n    for (srckey, src) in SOURCES.items():\n        srcItems.append((srckey, src['name'], src['description']))\n    return srcItems",
            "def listSources(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    srcItems = []\n    for (srckey, src) in SOURCES.items():\n        srcItems.append((srckey, src['name'], src['description']))\n    return srcItems",
            "def listSources(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    srcItems = []\n    for (srckey, src) in SOURCES.items():\n        srcItems.append((srckey, src['name'], src['description']))\n    return srcItems",
            "def listSources(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    srcItems = []\n    for (srckey, src) in SOURCES.items():\n        srcItems.append((srckey, src['name'], src['description']))\n    return srcItems",
            "def listSources(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    srcItems = []\n    for (srckey, src) in SOURCES.items():\n        srcItems.append((srckey, src['name'], src['description']))\n    return srcItems"
        ]
    },
    {
        "func_name": "listGrids",
        "original": "def listGrids(self, context):\n    grdItems = []\n    src = SOURCES[self.src]\n    for (gridkey, grd) in GRIDS.items():\n        if gridkey == src['grid']:\n            grdItems.insert(0, (gridkey, grd['name'] + ' (source)', grd['description']))\n        else:\n            grdItems.append((gridkey, grd['name'], grd['description']))\n    return grdItems",
        "mutated": [
            "def listGrids(self, context):\n    if False:\n        i = 10\n    grdItems = []\n    src = SOURCES[self.src]\n    for (gridkey, grd) in GRIDS.items():\n        if gridkey == src['grid']:\n            grdItems.insert(0, (gridkey, grd['name'] + ' (source)', grd['description']))\n        else:\n            grdItems.append((gridkey, grd['name'], grd['description']))\n    return grdItems",
            "def listGrids(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    grdItems = []\n    src = SOURCES[self.src]\n    for (gridkey, grd) in GRIDS.items():\n        if gridkey == src['grid']:\n            grdItems.insert(0, (gridkey, grd['name'] + ' (source)', grd['description']))\n        else:\n            grdItems.append((gridkey, grd['name'], grd['description']))\n    return grdItems",
            "def listGrids(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    grdItems = []\n    src = SOURCES[self.src]\n    for (gridkey, grd) in GRIDS.items():\n        if gridkey == src['grid']:\n            grdItems.insert(0, (gridkey, grd['name'] + ' (source)', grd['description']))\n        else:\n            grdItems.append((gridkey, grd['name'], grd['description']))\n    return grdItems",
            "def listGrids(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    grdItems = []\n    src = SOURCES[self.src]\n    for (gridkey, grd) in GRIDS.items():\n        if gridkey == src['grid']:\n            grdItems.insert(0, (gridkey, grd['name'] + ' (source)', grd['description']))\n        else:\n            grdItems.append((gridkey, grd['name'], grd['description']))\n    return grdItems",
            "def listGrids(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    grdItems = []\n    src = SOURCES[self.src]\n    for (gridkey, grd) in GRIDS.items():\n        if gridkey == src['grid']:\n            grdItems.insert(0, (gridkey, grd['name'] + ' (source)', grd['description']))\n        else:\n            grdItems.append((gridkey, grd['name'], grd['description']))\n    return grdItems"
        ]
    },
    {
        "func_name": "listLayers",
        "original": "def listLayers(self, context):\n    layItems = []\n    src = SOURCES[self.src]\n    for (laykey, lay) in src['layers'].items():\n        layItems.append((laykey, lay['name'], lay['description']))\n    return layItems",
        "mutated": [
            "def listLayers(self, context):\n    if False:\n        i = 10\n    layItems = []\n    src = SOURCES[self.src]\n    for (laykey, lay) in src['layers'].items():\n        layItems.append((laykey, lay['name'], lay['description']))\n    return layItems",
            "def listLayers(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    layItems = []\n    src = SOURCES[self.src]\n    for (laykey, lay) in src['layers'].items():\n        layItems.append((laykey, lay['name'], lay['description']))\n    return layItems",
            "def listLayers(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    layItems = []\n    src = SOURCES[self.src]\n    for (laykey, lay) in src['layers'].items():\n        layItems.append((laykey, lay['name'], lay['description']))\n    return layItems",
            "def listLayers(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    layItems = []\n    src = SOURCES[self.src]\n    for (laykey, lay) in src['layers'].items():\n        layItems.append((laykey, lay['name'], lay['description']))\n    return layItems",
            "def listLayers(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    layItems = []\n    src = SOURCES[self.src]\n    for (laykey, lay) in src['layers'].items():\n        layItems.append((laykey, lay['name'], lay['description']))\n    return layItems"
        ]
    },
    {
        "func_name": "draw",
        "original": "def draw(self, context):\n    addonPrefs = context.preferences.addons[PKG].preferences\n    scn = context.scene\n    layout = self.layout\n    if self.dialog == 'SEARCH':\n        layout.prop(self, 'query')\n        layout.prop(self, 'zoom', slider=True)\n    elif self.dialog == 'OPTIONS':\n        layout.prop(addonPrefs, 'zoomToMouse')\n        layout.prop(addonPrefs, 'lockObj')\n        layout.prop(addonPrefs, 'lockOrigin')\n        layout.prop(addonPrefs, 'synchOrj')\n    elif self.dialog == 'MAP':\n        layout.prop(self, 'src', text='Source')\n        layout.prop(self, 'lay', text='Layer')\n        col = layout.column()\n        if not HAS_GDAL:\n            col.enabled = False\n            col.label(text='(No raster reprojection support)')\n        col.prop(self, 'grd', text='Tile matrix set')\n        grdCRS = GRIDS[self.grd]['CRS']\n        row = layout.row()\n        desc = PredefCRS.getName(grdCRS)\n        if desc is not None:\n            row.label(text='CRS: ' + desc)\n        else:\n            row.label(text='CRS: ' + grdCRS)\n        row = layout.row()\n        row.prop(self, 'recenter')\n        geoscn = GeoScene(scn)\n        if geoscn.isPartiallyGeoref:\n            georefManagerLayout(self, context)",
        "mutated": [
            "def draw(self, context):\n    if False:\n        i = 10\n    addonPrefs = context.preferences.addons[PKG].preferences\n    scn = context.scene\n    layout = self.layout\n    if self.dialog == 'SEARCH':\n        layout.prop(self, 'query')\n        layout.prop(self, 'zoom', slider=True)\n    elif self.dialog == 'OPTIONS':\n        layout.prop(addonPrefs, 'zoomToMouse')\n        layout.prop(addonPrefs, 'lockObj')\n        layout.prop(addonPrefs, 'lockOrigin')\n        layout.prop(addonPrefs, 'synchOrj')\n    elif self.dialog == 'MAP':\n        layout.prop(self, 'src', text='Source')\n        layout.prop(self, 'lay', text='Layer')\n        col = layout.column()\n        if not HAS_GDAL:\n            col.enabled = False\n            col.label(text='(No raster reprojection support)')\n        col.prop(self, 'grd', text='Tile matrix set')\n        grdCRS = GRIDS[self.grd]['CRS']\n        row = layout.row()\n        desc = PredefCRS.getName(grdCRS)\n        if desc is not None:\n            row.label(text='CRS: ' + desc)\n        else:\n            row.label(text='CRS: ' + grdCRS)\n        row = layout.row()\n        row.prop(self, 'recenter')\n        geoscn = GeoScene(scn)\n        if geoscn.isPartiallyGeoref:\n            georefManagerLayout(self, context)",
            "def draw(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    addonPrefs = context.preferences.addons[PKG].preferences\n    scn = context.scene\n    layout = self.layout\n    if self.dialog == 'SEARCH':\n        layout.prop(self, 'query')\n        layout.prop(self, 'zoom', slider=True)\n    elif self.dialog == 'OPTIONS':\n        layout.prop(addonPrefs, 'zoomToMouse')\n        layout.prop(addonPrefs, 'lockObj')\n        layout.prop(addonPrefs, 'lockOrigin')\n        layout.prop(addonPrefs, 'synchOrj')\n    elif self.dialog == 'MAP':\n        layout.prop(self, 'src', text='Source')\n        layout.prop(self, 'lay', text='Layer')\n        col = layout.column()\n        if not HAS_GDAL:\n            col.enabled = False\n            col.label(text='(No raster reprojection support)')\n        col.prop(self, 'grd', text='Tile matrix set')\n        grdCRS = GRIDS[self.grd]['CRS']\n        row = layout.row()\n        desc = PredefCRS.getName(grdCRS)\n        if desc is not None:\n            row.label(text='CRS: ' + desc)\n        else:\n            row.label(text='CRS: ' + grdCRS)\n        row = layout.row()\n        row.prop(self, 'recenter')\n        geoscn = GeoScene(scn)\n        if geoscn.isPartiallyGeoref:\n            georefManagerLayout(self, context)",
            "def draw(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    addonPrefs = context.preferences.addons[PKG].preferences\n    scn = context.scene\n    layout = self.layout\n    if self.dialog == 'SEARCH':\n        layout.prop(self, 'query')\n        layout.prop(self, 'zoom', slider=True)\n    elif self.dialog == 'OPTIONS':\n        layout.prop(addonPrefs, 'zoomToMouse')\n        layout.prop(addonPrefs, 'lockObj')\n        layout.prop(addonPrefs, 'lockOrigin')\n        layout.prop(addonPrefs, 'synchOrj')\n    elif self.dialog == 'MAP':\n        layout.prop(self, 'src', text='Source')\n        layout.prop(self, 'lay', text='Layer')\n        col = layout.column()\n        if not HAS_GDAL:\n            col.enabled = False\n            col.label(text='(No raster reprojection support)')\n        col.prop(self, 'grd', text='Tile matrix set')\n        grdCRS = GRIDS[self.grd]['CRS']\n        row = layout.row()\n        desc = PredefCRS.getName(grdCRS)\n        if desc is not None:\n            row.label(text='CRS: ' + desc)\n        else:\n            row.label(text='CRS: ' + grdCRS)\n        row = layout.row()\n        row.prop(self, 'recenter')\n        geoscn = GeoScene(scn)\n        if geoscn.isPartiallyGeoref:\n            georefManagerLayout(self, context)",
            "def draw(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    addonPrefs = context.preferences.addons[PKG].preferences\n    scn = context.scene\n    layout = self.layout\n    if self.dialog == 'SEARCH':\n        layout.prop(self, 'query')\n        layout.prop(self, 'zoom', slider=True)\n    elif self.dialog == 'OPTIONS':\n        layout.prop(addonPrefs, 'zoomToMouse')\n        layout.prop(addonPrefs, 'lockObj')\n        layout.prop(addonPrefs, 'lockOrigin')\n        layout.prop(addonPrefs, 'synchOrj')\n    elif self.dialog == 'MAP':\n        layout.prop(self, 'src', text='Source')\n        layout.prop(self, 'lay', text='Layer')\n        col = layout.column()\n        if not HAS_GDAL:\n            col.enabled = False\n            col.label(text='(No raster reprojection support)')\n        col.prop(self, 'grd', text='Tile matrix set')\n        grdCRS = GRIDS[self.grd]['CRS']\n        row = layout.row()\n        desc = PredefCRS.getName(grdCRS)\n        if desc is not None:\n            row.label(text='CRS: ' + desc)\n        else:\n            row.label(text='CRS: ' + grdCRS)\n        row = layout.row()\n        row.prop(self, 'recenter')\n        geoscn = GeoScene(scn)\n        if geoscn.isPartiallyGeoref:\n            georefManagerLayout(self, context)",
            "def draw(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    addonPrefs = context.preferences.addons[PKG].preferences\n    scn = context.scene\n    layout = self.layout\n    if self.dialog == 'SEARCH':\n        layout.prop(self, 'query')\n        layout.prop(self, 'zoom', slider=True)\n    elif self.dialog == 'OPTIONS':\n        layout.prop(addonPrefs, 'zoomToMouse')\n        layout.prop(addonPrefs, 'lockObj')\n        layout.prop(addonPrefs, 'lockOrigin')\n        layout.prop(addonPrefs, 'synchOrj')\n    elif self.dialog == 'MAP':\n        layout.prop(self, 'src', text='Source')\n        layout.prop(self, 'lay', text='Layer')\n        col = layout.column()\n        if not HAS_GDAL:\n            col.enabled = False\n            col.label(text='(No raster reprojection support)')\n        col.prop(self, 'grd', text='Tile matrix set')\n        grdCRS = GRIDS[self.grd]['CRS']\n        row = layout.row()\n        desc = PredefCRS.getName(grdCRS)\n        if desc is not None:\n            row.label(text='CRS: ' + desc)\n        else:\n            row.label(text='CRS: ' + grdCRS)\n        row = layout.row()\n        row.prop(self, 'recenter')\n        geoscn = GeoScene(scn)\n        if geoscn.isPartiallyGeoref:\n            georefManagerLayout(self, context)"
        ]
    },
    {
        "func_name": "invoke",
        "original": "def invoke(self, context, event):\n    if not HAS_PIL and (not HAS_GDAL) and (not HAS_IMGIO):\n        self.report({'ERROR'}, 'No imaging library available. ImageIO module was not correctly installed.')\n        return {'CANCELLED'}\n    if not context.area.type == 'VIEW_3D':\n        self.report({'WARNING'}, 'View3D not found, cannot run operator')\n        return {'CANCELLED'}\n    geoscn = GeoScene(context.scene)\n    if geoscn.hasZoom:\n        self.zoom = geoscn.zoom\n    return context.window_manager.invoke_props_dialog(self)",
        "mutated": [
            "def invoke(self, context, event):\n    if False:\n        i = 10\n    if not HAS_PIL and (not HAS_GDAL) and (not HAS_IMGIO):\n        self.report({'ERROR'}, 'No imaging library available. ImageIO module was not correctly installed.')\n        return {'CANCELLED'}\n    if not context.area.type == 'VIEW_3D':\n        self.report({'WARNING'}, 'View3D not found, cannot run operator')\n        return {'CANCELLED'}\n    geoscn = GeoScene(context.scene)\n    if geoscn.hasZoom:\n        self.zoom = geoscn.zoom\n    return context.window_manager.invoke_props_dialog(self)",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not HAS_PIL and (not HAS_GDAL) and (not HAS_IMGIO):\n        self.report({'ERROR'}, 'No imaging library available. ImageIO module was not correctly installed.')\n        return {'CANCELLED'}\n    if not context.area.type == 'VIEW_3D':\n        self.report({'WARNING'}, 'View3D not found, cannot run operator')\n        return {'CANCELLED'}\n    geoscn = GeoScene(context.scene)\n    if geoscn.hasZoom:\n        self.zoom = geoscn.zoom\n    return context.window_manager.invoke_props_dialog(self)",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not HAS_PIL and (not HAS_GDAL) and (not HAS_IMGIO):\n        self.report({'ERROR'}, 'No imaging library available. ImageIO module was not correctly installed.')\n        return {'CANCELLED'}\n    if not context.area.type == 'VIEW_3D':\n        self.report({'WARNING'}, 'View3D not found, cannot run operator')\n        return {'CANCELLED'}\n    geoscn = GeoScene(context.scene)\n    if geoscn.hasZoom:\n        self.zoom = geoscn.zoom\n    return context.window_manager.invoke_props_dialog(self)",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not HAS_PIL and (not HAS_GDAL) and (not HAS_IMGIO):\n        self.report({'ERROR'}, 'No imaging library available. ImageIO module was not correctly installed.')\n        return {'CANCELLED'}\n    if not context.area.type == 'VIEW_3D':\n        self.report({'WARNING'}, 'View3D not found, cannot run operator')\n        return {'CANCELLED'}\n    geoscn = GeoScene(context.scene)\n    if geoscn.hasZoom:\n        self.zoom = geoscn.zoom\n    return context.window_manager.invoke_props_dialog(self)",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not HAS_PIL and (not HAS_GDAL) and (not HAS_IMGIO):\n        self.report({'ERROR'}, 'No imaging library available. ImageIO module was not correctly installed.')\n        return {'CANCELLED'}\n    if not context.area.type == 'VIEW_3D':\n        self.report({'WARNING'}, 'View3D not found, cannot run operator')\n        return {'CANCELLED'}\n    geoscn = GeoScene(context.scene)\n    if geoscn.hasZoom:\n        self.zoom = geoscn.zoom\n    return context.window_manager.invoke_props_dialog(self)"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, context):\n    scn = context.scene\n    geoscn = GeoScene(scn)\n    prefs = context.preferences.addons[PKG].preferences\n    folder = prefs.cacheFolder\n    if folder == '' or not os.path.exists(folder):\n        self.report({'ERROR'}, \"Please define a valid cache folder path in addon's preferences\")\n        return {'CANCELLED'}\n    if not os.access(folder, os.X_OK | os.W_OK):\n        self.report({'ERROR'}, 'The selected cache folder has no write access')\n        return {'CANCELLED'}\n    if self.dialog == 'MAP':\n        grdCRS = GRIDS[self.grd]['CRS']\n        if geoscn.isBroken:\n            self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n            return {'CANCELLED'}\n        if geoscn.hasCRS and geoscn.crs != grdCRS and (not HAS_GDAL):\n            self.report({'ERROR'}, 'Please install gdal to enable raster reprojection support')\n            return {'CANCELLED'}\n    if self.dialog == 'SEARCH':\n        r = bpy.ops.view3d.map_search('EXEC_DEFAULT', query=self.query)\n        if r == {'CANCELLED'}:\n            self.report({'INFO'}, 'No location found')\n        else:\n            geoscn.zoom = self.zoom\n    self.dialog = 'MAP'\n    bpy.ops.view3d.map_viewer('INVOKE_DEFAULT', srckey=self.src, laykey=self.lay, grdkey=self.grd, recenter=self.recenter)\n    return {'FINISHED'}",
        "mutated": [
            "def execute(self, context):\n    if False:\n        i = 10\n    scn = context.scene\n    geoscn = GeoScene(scn)\n    prefs = context.preferences.addons[PKG].preferences\n    folder = prefs.cacheFolder\n    if folder == '' or not os.path.exists(folder):\n        self.report({'ERROR'}, \"Please define a valid cache folder path in addon's preferences\")\n        return {'CANCELLED'}\n    if not os.access(folder, os.X_OK | os.W_OK):\n        self.report({'ERROR'}, 'The selected cache folder has no write access')\n        return {'CANCELLED'}\n    if self.dialog == 'MAP':\n        grdCRS = GRIDS[self.grd]['CRS']\n        if geoscn.isBroken:\n            self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n            return {'CANCELLED'}\n        if geoscn.hasCRS and geoscn.crs != grdCRS and (not HAS_GDAL):\n            self.report({'ERROR'}, 'Please install gdal to enable raster reprojection support')\n            return {'CANCELLED'}\n    if self.dialog == 'SEARCH':\n        r = bpy.ops.view3d.map_search('EXEC_DEFAULT', query=self.query)\n        if r == {'CANCELLED'}:\n            self.report({'INFO'}, 'No location found')\n        else:\n            geoscn.zoom = self.zoom\n    self.dialog = 'MAP'\n    bpy.ops.view3d.map_viewer('INVOKE_DEFAULT', srckey=self.src, laykey=self.lay, grdkey=self.grd, recenter=self.recenter)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    scn = context.scene\n    geoscn = GeoScene(scn)\n    prefs = context.preferences.addons[PKG].preferences\n    folder = prefs.cacheFolder\n    if folder == '' or not os.path.exists(folder):\n        self.report({'ERROR'}, \"Please define a valid cache folder path in addon's preferences\")\n        return {'CANCELLED'}\n    if not os.access(folder, os.X_OK | os.W_OK):\n        self.report({'ERROR'}, 'The selected cache folder has no write access')\n        return {'CANCELLED'}\n    if self.dialog == 'MAP':\n        grdCRS = GRIDS[self.grd]['CRS']\n        if geoscn.isBroken:\n            self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n            return {'CANCELLED'}\n        if geoscn.hasCRS and geoscn.crs != grdCRS and (not HAS_GDAL):\n            self.report({'ERROR'}, 'Please install gdal to enable raster reprojection support')\n            return {'CANCELLED'}\n    if self.dialog == 'SEARCH':\n        r = bpy.ops.view3d.map_search('EXEC_DEFAULT', query=self.query)\n        if r == {'CANCELLED'}:\n            self.report({'INFO'}, 'No location found')\n        else:\n            geoscn.zoom = self.zoom\n    self.dialog = 'MAP'\n    bpy.ops.view3d.map_viewer('INVOKE_DEFAULT', srckey=self.src, laykey=self.lay, grdkey=self.grd, recenter=self.recenter)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    scn = context.scene\n    geoscn = GeoScene(scn)\n    prefs = context.preferences.addons[PKG].preferences\n    folder = prefs.cacheFolder\n    if folder == '' or not os.path.exists(folder):\n        self.report({'ERROR'}, \"Please define a valid cache folder path in addon's preferences\")\n        return {'CANCELLED'}\n    if not os.access(folder, os.X_OK | os.W_OK):\n        self.report({'ERROR'}, 'The selected cache folder has no write access')\n        return {'CANCELLED'}\n    if self.dialog == 'MAP':\n        grdCRS = GRIDS[self.grd]['CRS']\n        if geoscn.isBroken:\n            self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n            return {'CANCELLED'}\n        if geoscn.hasCRS and geoscn.crs != grdCRS and (not HAS_GDAL):\n            self.report({'ERROR'}, 'Please install gdal to enable raster reprojection support')\n            return {'CANCELLED'}\n    if self.dialog == 'SEARCH':\n        r = bpy.ops.view3d.map_search('EXEC_DEFAULT', query=self.query)\n        if r == {'CANCELLED'}:\n            self.report({'INFO'}, 'No location found')\n        else:\n            geoscn.zoom = self.zoom\n    self.dialog = 'MAP'\n    bpy.ops.view3d.map_viewer('INVOKE_DEFAULT', srckey=self.src, laykey=self.lay, grdkey=self.grd, recenter=self.recenter)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    scn = context.scene\n    geoscn = GeoScene(scn)\n    prefs = context.preferences.addons[PKG].preferences\n    folder = prefs.cacheFolder\n    if folder == '' or not os.path.exists(folder):\n        self.report({'ERROR'}, \"Please define a valid cache folder path in addon's preferences\")\n        return {'CANCELLED'}\n    if not os.access(folder, os.X_OK | os.W_OK):\n        self.report({'ERROR'}, 'The selected cache folder has no write access')\n        return {'CANCELLED'}\n    if self.dialog == 'MAP':\n        grdCRS = GRIDS[self.grd]['CRS']\n        if geoscn.isBroken:\n            self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n            return {'CANCELLED'}\n        if geoscn.hasCRS and geoscn.crs != grdCRS and (not HAS_GDAL):\n            self.report({'ERROR'}, 'Please install gdal to enable raster reprojection support')\n            return {'CANCELLED'}\n    if self.dialog == 'SEARCH':\n        r = bpy.ops.view3d.map_search('EXEC_DEFAULT', query=self.query)\n        if r == {'CANCELLED'}:\n            self.report({'INFO'}, 'No location found')\n        else:\n            geoscn.zoom = self.zoom\n    self.dialog = 'MAP'\n    bpy.ops.view3d.map_viewer('INVOKE_DEFAULT', srckey=self.src, laykey=self.lay, grdkey=self.grd, recenter=self.recenter)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    scn = context.scene\n    geoscn = GeoScene(scn)\n    prefs = context.preferences.addons[PKG].preferences\n    folder = prefs.cacheFolder\n    if folder == '' or not os.path.exists(folder):\n        self.report({'ERROR'}, \"Please define a valid cache folder path in addon's preferences\")\n        return {'CANCELLED'}\n    if not os.access(folder, os.X_OK | os.W_OK):\n        self.report({'ERROR'}, 'The selected cache folder has no write access')\n        return {'CANCELLED'}\n    if self.dialog == 'MAP':\n        grdCRS = GRIDS[self.grd]['CRS']\n        if geoscn.isBroken:\n            self.report({'ERROR'}, 'Scene georef is broken, please fix it beforehand')\n            return {'CANCELLED'}\n        if geoscn.hasCRS and geoscn.crs != grdCRS and (not HAS_GDAL):\n            self.report({'ERROR'}, 'Please install gdal to enable raster reprojection support')\n            return {'CANCELLED'}\n    if self.dialog == 'SEARCH':\n        r = bpy.ops.view3d.map_search('EXEC_DEFAULT', query=self.query)\n        if r == {'CANCELLED'}:\n            self.report({'INFO'}, 'No location found')\n        else:\n            geoscn.zoom = self.zoom\n    self.dialog = 'MAP'\n    bpy.ops.view3d.map_viewer('INVOKE_DEFAULT', srckey=self.src, laykey=self.lay, grdkey=self.grd, recenter=self.recenter)\n    return {'FINISHED'}"
        ]
    },
    {
        "func_name": "poll",
        "original": "@classmethod\ndef poll(cls, context):\n    return context.area.type == 'VIEW_3D'",
        "mutated": [
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n    return context.area.type == 'VIEW_3D'",
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return context.area.type == 'VIEW_3D'",
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return context.area.type == 'VIEW_3D'",
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return context.area.type == 'VIEW_3D'",
            "@classmethod\ndef poll(cls, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return context.area.type == 'VIEW_3D'"
        ]
    },
    {
        "func_name": "__del__",
        "original": "def __del__(self):\n    if getattr(self, 'restart', False):\n        bpy.ops.view3d.map_start('INVOKE_DEFAULT', src=self.srckey, lay=self.laykey, grd=self.grdkey, dialog=self.dialog)",
        "mutated": [
            "def __del__(self):\n    if False:\n        i = 10\n    if getattr(self, 'restart', False):\n        bpy.ops.view3d.map_start('INVOKE_DEFAULT', src=self.srckey, lay=self.laykey, grd=self.grdkey, dialog=self.dialog)",
            "def __del__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if getattr(self, 'restart', False):\n        bpy.ops.view3d.map_start('INVOKE_DEFAULT', src=self.srckey, lay=self.laykey, grd=self.grdkey, dialog=self.dialog)",
            "def __del__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if getattr(self, 'restart', False):\n        bpy.ops.view3d.map_start('INVOKE_DEFAULT', src=self.srckey, lay=self.laykey, grd=self.grdkey, dialog=self.dialog)",
            "def __del__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if getattr(self, 'restart', False):\n        bpy.ops.view3d.map_start('INVOKE_DEFAULT', src=self.srckey, lay=self.laykey, grd=self.grdkey, dialog=self.dialog)",
            "def __del__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if getattr(self, 'restart', False):\n        bpy.ops.view3d.map_start('INVOKE_DEFAULT', src=self.srckey, lay=self.laykey, grd=self.grdkey, dialog=self.dialog)"
        ]
    },
    {
        "func_name": "invoke",
        "original": "def invoke(self, context, event):\n    self.restart = False\n    self.dialog = 'MAP'\n    self.moveFactor = 0.1\n    self.prefs = context.preferences.addons[PKG].preferences\n    self.updObjLoc = self.prefs.lockObj\n    args = (self, context)\n    self._drawTextHandler = bpy.types.SpaceView3D.draw_handler_add(drawInfosText, args, 'WINDOW', 'POST_PIXEL')\n    self._drawZoomBoxHandler = bpy.types.SpaceView3D.draw_handler_add(drawZoomBox, args, 'WINDOW', 'POST_PIXEL')\n    context.window_manager.modal_handler_add(self)\n    self.timer = context.window_manager.event_timer_add(0.04, window=context.window)\n    view3d = context.area.spaces.active\n    bpy.ops.view3d.view_axis(type='TOP')\n    view3d.region_3d.view_perspective = 'ORTHO'\n    context.scene.cursor.location = (0, 0, 0)\n    if not self.prefs.lockOrigin:\n        view3d.region_3d.view_location = (0, 0, 0)\n    self.inMove = False\n    (self.posx, self.posy) = (0, 0)\n    self.progress = ''\n    self.zoomBoxMode = False\n    self.zoomBoxDrag = False\n    (self.zb_xmin, self.zb_xmax) = (0, 0)\n    (self.zb_ymin, self.zb_ymax) = (0, 0)\n    self.map = BaseMap(context, self.srckey, self.laykey, self.grdkey)\n    if self.recenter and len(context.scene.objects) > 0:\n        scnBbox = getBBOX.fromScn(context.scene).to2D()\n        (w, h) = scnBbox.dimensions\n        px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n        dst_diag = math.sqrt(w ** 2 + h ** 2)\n        targetRes = dst_diag / px_diag\n        z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n        resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n        context.region_data.view_distance *= resFactor\n        (x, y) = scnBbox.center\n        if self.prefs.lockOrigin:\n            context.region_data.view_location = (x, y, 0)\n        else:\n            self.map.moveOrigin(x, y)\n        self.map.zoom = z\n    self.map.get()\n    return {'RUNNING_MODAL'}",
        "mutated": [
            "def invoke(self, context, event):\n    if False:\n        i = 10\n    self.restart = False\n    self.dialog = 'MAP'\n    self.moveFactor = 0.1\n    self.prefs = context.preferences.addons[PKG].preferences\n    self.updObjLoc = self.prefs.lockObj\n    args = (self, context)\n    self._drawTextHandler = bpy.types.SpaceView3D.draw_handler_add(drawInfosText, args, 'WINDOW', 'POST_PIXEL')\n    self._drawZoomBoxHandler = bpy.types.SpaceView3D.draw_handler_add(drawZoomBox, args, 'WINDOW', 'POST_PIXEL')\n    context.window_manager.modal_handler_add(self)\n    self.timer = context.window_manager.event_timer_add(0.04, window=context.window)\n    view3d = context.area.spaces.active\n    bpy.ops.view3d.view_axis(type='TOP')\n    view3d.region_3d.view_perspective = 'ORTHO'\n    context.scene.cursor.location = (0, 0, 0)\n    if not self.prefs.lockOrigin:\n        view3d.region_3d.view_location = (0, 0, 0)\n    self.inMove = False\n    (self.posx, self.posy) = (0, 0)\n    self.progress = ''\n    self.zoomBoxMode = False\n    self.zoomBoxDrag = False\n    (self.zb_xmin, self.zb_xmax) = (0, 0)\n    (self.zb_ymin, self.zb_ymax) = (0, 0)\n    self.map = BaseMap(context, self.srckey, self.laykey, self.grdkey)\n    if self.recenter and len(context.scene.objects) > 0:\n        scnBbox = getBBOX.fromScn(context.scene).to2D()\n        (w, h) = scnBbox.dimensions\n        px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n        dst_diag = math.sqrt(w ** 2 + h ** 2)\n        targetRes = dst_diag / px_diag\n        z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n        resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n        context.region_data.view_distance *= resFactor\n        (x, y) = scnBbox.center\n        if self.prefs.lockOrigin:\n            context.region_data.view_location = (x, y, 0)\n        else:\n            self.map.moveOrigin(x, y)\n        self.map.zoom = z\n    self.map.get()\n    return {'RUNNING_MODAL'}",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.restart = False\n    self.dialog = 'MAP'\n    self.moveFactor = 0.1\n    self.prefs = context.preferences.addons[PKG].preferences\n    self.updObjLoc = self.prefs.lockObj\n    args = (self, context)\n    self._drawTextHandler = bpy.types.SpaceView3D.draw_handler_add(drawInfosText, args, 'WINDOW', 'POST_PIXEL')\n    self._drawZoomBoxHandler = bpy.types.SpaceView3D.draw_handler_add(drawZoomBox, args, 'WINDOW', 'POST_PIXEL')\n    context.window_manager.modal_handler_add(self)\n    self.timer = context.window_manager.event_timer_add(0.04, window=context.window)\n    view3d = context.area.spaces.active\n    bpy.ops.view3d.view_axis(type='TOP')\n    view3d.region_3d.view_perspective = 'ORTHO'\n    context.scene.cursor.location = (0, 0, 0)\n    if not self.prefs.lockOrigin:\n        view3d.region_3d.view_location = (0, 0, 0)\n    self.inMove = False\n    (self.posx, self.posy) = (0, 0)\n    self.progress = ''\n    self.zoomBoxMode = False\n    self.zoomBoxDrag = False\n    (self.zb_xmin, self.zb_xmax) = (0, 0)\n    (self.zb_ymin, self.zb_ymax) = (0, 0)\n    self.map = BaseMap(context, self.srckey, self.laykey, self.grdkey)\n    if self.recenter and len(context.scene.objects) > 0:\n        scnBbox = getBBOX.fromScn(context.scene).to2D()\n        (w, h) = scnBbox.dimensions\n        px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n        dst_diag = math.sqrt(w ** 2 + h ** 2)\n        targetRes = dst_diag / px_diag\n        z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n        resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n        context.region_data.view_distance *= resFactor\n        (x, y) = scnBbox.center\n        if self.prefs.lockOrigin:\n            context.region_data.view_location = (x, y, 0)\n        else:\n            self.map.moveOrigin(x, y)\n        self.map.zoom = z\n    self.map.get()\n    return {'RUNNING_MODAL'}",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.restart = False\n    self.dialog = 'MAP'\n    self.moveFactor = 0.1\n    self.prefs = context.preferences.addons[PKG].preferences\n    self.updObjLoc = self.prefs.lockObj\n    args = (self, context)\n    self._drawTextHandler = bpy.types.SpaceView3D.draw_handler_add(drawInfosText, args, 'WINDOW', 'POST_PIXEL')\n    self._drawZoomBoxHandler = bpy.types.SpaceView3D.draw_handler_add(drawZoomBox, args, 'WINDOW', 'POST_PIXEL')\n    context.window_manager.modal_handler_add(self)\n    self.timer = context.window_manager.event_timer_add(0.04, window=context.window)\n    view3d = context.area.spaces.active\n    bpy.ops.view3d.view_axis(type='TOP')\n    view3d.region_3d.view_perspective = 'ORTHO'\n    context.scene.cursor.location = (0, 0, 0)\n    if not self.prefs.lockOrigin:\n        view3d.region_3d.view_location = (0, 0, 0)\n    self.inMove = False\n    (self.posx, self.posy) = (0, 0)\n    self.progress = ''\n    self.zoomBoxMode = False\n    self.zoomBoxDrag = False\n    (self.zb_xmin, self.zb_xmax) = (0, 0)\n    (self.zb_ymin, self.zb_ymax) = (0, 0)\n    self.map = BaseMap(context, self.srckey, self.laykey, self.grdkey)\n    if self.recenter and len(context.scene.objects) > 0:\n        scnBbox = getBBOX.fromScn(context.scene).to2D()\n        (w, h) = scnBbox.dimensions\n        px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n        dst_diag = math.sqrt(w ** 2 + h ** 2)\n        targetRes = dst_diag / px_diag\n        z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n        resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n        context.region_data.view_distance *= resFactor\n        (x, y) = scnBbox.center\n        if self.prefs.lockOrigin:\n            context.region_data.view_location = (x, y, 0)\n        else:\n            self.map.moveOrigin(x, y)\n        self.map.zoom = z\n    self.map.get()\n    return {'RUNNING_MODAL'}",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.restart = False\n    self.dialog = 'MAP'\n    self.moveFactor = 0.1\n    self.prefs = context.preferences.addons[PKG].preferences\n    self.updObjLoc = self.prefs.lockObj\n    args = (self, context)\n    self._drawTextHandler = bpy.types.SpaceView3D.draw_handler_add(drawInfosText, args, 'WINDOW', 'POST_PIXEL')\n    self._drawZoomBoxHandler = bpy.types.SpaceView3D.draw_handler_add(drawZoomBox, args, 'WINDOW', 'POST_PIXEL')\n    context.window_manager.modal_handler_add(self)\n    self.timer = context.window_manager.event_timer_add(0.04, window=context.window)\n    view3d = context.area.spaces.active\n    bpy.ops.view3d.view_axis(type='TOP')\n    view3d.region_3d.view_perspective = 'ORTHO'\n    context.scene.cursor.location = (0, 0, 0)\n    if not self.prefs.lockOrigin:\n        view3d.region_3d.view_location = (0, 0, 0)\n    self.inMove = False\n    (self.posx, self.posy) = (0, 0)\n    self.progress = ''\n    self.zoomBoxMode = False\n    self.zoomBoxDrag = False\n    (self.zb_xmin, self.zb_xmax) = (0, 0)\n    (self.zb_ymin, self.zb_ymax) = (0, 0)\n    self.map = BaseMap(context, self.srckey, self.laykey, self.grdkey)\n    if self.recenter and len(context.scene.objects) > 0:\n        scnBbox = getBBOX.fromScn(context.scene).to2D()\n        (w, h) = scnBbox.dimensions\n        px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n        dst_diag = math.sqrt(w ** 2 + h ** 2)\n        targetRes = dst_diag / px_diag\n        z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n        resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n        context.region_data.view_distance *= resFactor\n        (x, y) = scnBbox.center\n        if self.prefs.lockOrigin:\n            context.region_data.view_location = (x, y, 0)\n        else:\n            self.map.moveOrigin(x, y)\n        self.map.zoom = z\n    self.map.get()\n    return {'RUNNING_MODAL'}",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.restart = False\n    self.dialog = 'MAP'\n    self.moveFactor = 0.1\n    self.prefs = context.preferences.addons[PKG].preferences\n    self.updObjLoc = self.prefs.lockObj\n    args = (self, context)\n    self._drawTextHandler = bpy.types.SpaceView3D.draw_handler_add(drawInfosText, args, 'WINDOW', 'POST_PIXEL')\n    self._drawZoomBoxHandler = bpy.types.SpaceView3D.draw_handler_add(drawZoomBox, args, 'WINDOW', 'POST_PIXEL')\n    context.window_manager.modal_handler_add(self)\n    self.timer = context.window_manager.event_timer_add(0.04, window=context.window)\n    view3d = context.area.spaces.active\n    bpy.ops.view3d.view_axis(type='TOP')\n    view3d.region_3d.view_perspective = 'ORTHO'\n    context.scene.cursor.location = (0, 0, 0)\n    if not self.prefs.lockOrigin:\n        view3d.region_3d.view_location = (0, 0, 0)\n    self.inMove = False\n    (self.posx, self.posy) = (0, 0)\n    self.progress = ''\n    self.zoomBoxMode = False\n    self.zoomBoxDrag = False\n    (self.zb_xmin, self.zb_xmax) = (0, 0)\n    (self.zb_ymin, self.zb_ymax) = (0, 0)\n    self.map = BaseMap(context, self.srckey, self.laykey, self.grdkey)\n    if self.recenter and len(context.scene.objects) > 0:\n        scnBbox = getBBOX.fromScn(context.scene).to2D()\n        (w, h) = scnBbox.dimensions\n        px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n        dst_diag = math.sqrt(w ** 2 + h ** 2)\n        targetRes = dst_diag / px_diag\n        z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n        resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n        context.region_data.view_distance *= resFactor\n        (x, y) = scnBbox.center\n        if self.prefs.lockOrigin:\n            context.region_data.view_location = (x, y, 0)\n        else:\n            self.map.moveOrigin(x, y)\n        self.map.zoom = z\n    self.map.get()\n    return {'RUNNING_MODAL'}"
        ]
    },
    {
        "func_name": "modal",
        "original": "def modal(self, context, event):\n    context.area.tag_redraw()\n    scn = bpy.context.scene\n    if event.type == 'TIMER':\n        self.progress = self.map.srv.report\n        return {'PASS_THROUGH'}\n    if event.type in ['WHEELUPMOUSE', 'NUMPAD_PLUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                self.map.scale *= 10\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location /= 10\n                    obj.scale /= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance -= dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc += deltaVect\n            elif self.map.zoom < self.map.layer.zmax and self.map.zoom < self.map.tm.nbLevels - 1:\n                self.map.zoom += 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getNextResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type in ['WHEELDOWNMOUSE', 'NUMPAD_MINUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                s = self.map.scale / 10\n                if s < 1:\n                    s = 1\n                self.map.scale = s\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location *= 10\n                    obj.scale *= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance += dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc -= deltaVect\n            elif self.map.zoom > self.map.layer.zmin and self.map.zoom > 0:\n                self.map.zoom -= 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getPrevResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type == 'MOUSEMOVE':\n        loc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n        (self.posx, self.posy) = self.map.view3dToProj(loc.x, loc.y)\n        if self.zoomBoxMode:\n            (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        if self.inMove:\n            loc1 = mouseTo3d(context, self.x1, self.y1)\n            loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n            dlt = loc1 - loc2\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location = self.viewLoc1 + dlt\n            else:\n                if self.map.bkg is not None:\n                    self.map.bkg.location[0] = self.offx1 - dlt.x\n                    self.map.bkg.location[1] = self.offy1 - dlt.y\n                if self.updObjLoc:\n                    topParents = [obj for obj in scn.objects if not obj.parent]\n                    for (i, obj) in enumerate(topParents):\n                        if obj == self.map.bkg:\n                            continue\n                        loc1 = self.objsLoc1[i]\n                        obj.location.x = loc1.x - dlt.x\n                        obj.location.y = loc1.y - dlt.y\n    if event.type in {'LEFTMOUSE', 'MIDDLEMOUSE'}:\n        if event.value == 'PRESS' and (not self.zoomBoxMode):\n            (self.x1, self.y1) = (event.mouse_region_x, event.mouse_region_y)\n            self.viewLoc1 = context.region_data.view_location.copy()\n            if not event.ctrl:\n                self.map.stop()\n                if not self.prefs.lockOrigin:\n                    if self.map.bkg is not None:\n                        self.offx1 = self.map.bkg.location[0]\n                        self.offy1 = self.map.bkg.location[1]\n                    self.objsLoc1 = [obj.location.copy() for obj in scn.objects if not obj.parent]\n            self.inMove = True\n        if event.value == 'RELEASE' and (not self.zoomBoxMode):\n            self.inMove = False\n            if not event.ctrl:\n                if not self.prefs.lockOrigin:\n                    loc1 = mouseTo3d(context, self.x1, self.y1)\n                    loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    dlt = loc1 - loc2\n                    self.map.moveOrigin(dlt.x, dlt.y, updObjLoc=False)\n                self.map.get()\n        if event.value == 'PRESS' and self.zoomBoxMode:\n            self.zoomBoxDrag = True\n            (self.zb_xmin, self.zb_ymin) = (event.mouse_region_x, event.mouse_region_y)\n        if event.value == 'RELEASE' and self.zoomBoxMode:\n            xmax = max(event.mouse_region_x, self.zb_xmin)\n            ymax = max(event.mouse_region_y, self.zb_ymin)\n            xmin = min(event.mouse_region_x, self.zb_xmin)\n            ymin = min(event.mouse_region_y, self.zb_ymin)\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n            w = xmax - xmin\n            h = ymax - ymin\n            cx = xmin + w / 2\n            cy = ymin + h / 2\n            loc = mouseTo3d(context, cx, cy)\n            px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n            mapRes = self.map.tm.getRes(self.map.zoom)\n            dst_diag = math.sqrt((w * mapRes) ** 2 + (h * mapRes) ** 2)\n            targetRes = dst_diag / px_diag\n            z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n            resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n            context.region_data.view_distance *= resFactor\n            if self.prefs.lockOrigin:\n                context.region_data.view_location = loc\n            else:\n                self.map.moveOrigin(loc.x, loc.y, updObjLoc=self.updObjLoc)\n            self.map.zoom = z\n            self.map.get()\n    if event.type in ['LEFT_CTRL', 'RIGHT_CTRL']:\n        if event.value == 'PRESS':\n            self._viewDstZ = context.region_data.view_distance\n            self._viewLoc = context.region_data.view_location.copy()\n        if event.value == 'RELEASE':\n            context.region_data.view_distance = self._viewDstZ\n            context.region_data.view_location = self._viewLoc\n    if event.value == 'PRESS' and event.type in ['NUMPAD_2', 'NUMPAD_4', 'NUMPAD_6', 'NUMPAD_8']:\n        delta = self.map.bkg.scale.x * self.moveFactor\n        if event.type == 'NUMPAD_4':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((-delta, 0, 0))\n            else:\n                self.map.moveOrigin(-delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_6':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((delta, 0, 0))\n            else:\n                self.map.moveOrigin(delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_2':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, -delta, 0))\n            else:\n                self.map.moveOrigin(0, -delta, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_8':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, delta, 0))\n            else:\n                self.map.moveOrigin(0, delta, updObjLoc=self.updObjLoc)\n        if not event.ctrl:\n            self.map.get()\n    if event.type == 'SPACE':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        return {'FINISHED'}\n    if event.type == 'G':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'SEARCH'\n        return {'FINISHED'}\n    if event.type == 'O':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'OPTIONS'\n        return {'FINISHED'}\n    if event.type == 'L' and event.value == 'PRESS':\n        if self.map.lockedZoom is None:\n            self.map.lockedZoom = self.map.zoom\n        else:\n            self.map.lockedZoom = None\n            self.map.get()\n    if event.type == 'B' and event.value == 'PRESS':\n        self.map.stop()\n        self.zoomBoxMode = True\n        (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        context.window.cursor_set('CROSSHAIR')\n    if event.type == 'E' and event.value == 'PRESS':\n        if not self.map.srv.running and self.map.mosaic is not None:\n            self.map.stop()\n            self.map.bkg.hide_viewport = True\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            bpyImg = bpy.data.images.load(self.map.imgPath)\n            name = 'EXPORT_' + self.map.srckey + '_' + self.map.laykey + '_' + self.map.grdkey\n            bpyImg.name = name\n            bpyImg.pack()\n            rast = self.map.mosaic\n            setattr(rast, 'bpyImg', bpyImg)\n            (dx, dy) = self.map.getOriginPrj()\n            mesh = rasterExtentToMesh(name, rast, dx, dy, pxLoc='CORNER')\n            obj = placeObj(mesh, name)\n            uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n            geoRastUVmap(obj, uvTxtLayer, rast, dx, dy)\n            mat = bpy.data.materials.new('rastMat')\n            obj.data.materials.append(mat)\n            addTexture(mat, bpyImg, uvTxtLayer)\n            if self.prefs.adjust3Dview:\n                adjust3Dview(context, getBBOX.fromObj(obj))\n            if self.prefs.forceTexturedSolid:\n                showTextures(context)\n            return {'FINISHED'}\n    if event.type == 'ESC' and event.value == 'PRESS':\n        if self.zoomBoxMode:\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n        else:\n            self.map.stop()\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            return {'CANCELLED'}\n    return {'RUNNING_MODAL'}",
        "mutated": [
            "def modal(self, context, event):\n    if False:\n        i = 10\n    context.area.tag_redraw()\n    scn = bpy.context.scene\n    if event.type == 'TIMER':\n        self.progress = self.map.srv.report\n        return {'PASS_THROUGH'}\n    if event.type in ['WHEELUPMOUSE', 'NUMPAD_PLUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                self.map.scale *= 10\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location /= 10\n                    obj.scale /= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance -= dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc += deltaVect\n            elif self.map.zoom < self.map.layer.zmax and self.map.zoom < self.map.tm.nbLevels - 1:\n                self.map.zoom += 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getNextResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type in ['WHEELDOWNMOUSE', 'NUMPAD_MINUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                s = self.map.scale / 10\n                if s < 1:\n                    s = 1\n                self.map.scale = s\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location *= 10\n                    obj.scale *= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance += dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc -= deltaVect\n            elif self.map.zoom > self.map.layer.zmin and self.map.zoom > 0:\n                self.map.zoom -= 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getPrevResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type == 'MOUSEMOVE':\n        loc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n        (self.posx, self.posy) = self.map.view3dToProj(loc.x, loc.y)\n        if self.zoomBoxMode:\n            (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        if self.inMove:\n            loc1 = mouseTo3d(context, self.x1, self.y1)\n            loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n            dlt = loc1 - loc2\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location = self.viewLoc1 + dlt\n            else:\n                if self.map.bkg is not None:\n                    self.map.bkg.location[0] = self.offx1 - dlt.x\n                    self.map.bkg.location[1] = self.offy1 - dlt.y\n                if self.updObjLoc:\n                    topParents = [obj for obj in scn.objects if not obj.parent]\n                    for (i, obj) in enumerate(topParents):\n                        if obj == self.map.bkg:\n                            continue\n                        loc1 = self.objsLoc1[i]\n                        obj.location.x = loc1.x - dlt.x\n                        obj.location.y = loc1.y - dlt.y\n    if event.type in {'LEFTMOUSE', 'MIDDLEMOUSE'}:\n        if event.value == 'PRESS' and (not self.zoomBoxMode):\n            (self.x1, self.y1) = (event.mouse_region_x, event.mouse_region_y)\n            self.viewLoc1 = context.region_data.view_location.copy()\n            if not event.ctrl:\n                self.map.stop()\n                if not self.prefs.lockOrigin:\n                    if self.map.bkg is not None:\n                        self.offx1 = self.map.bkg.location[0]\n                        self.offy1 = self.map.bkg.location[1]\n                    self.objsLoc1 = [obj.location.copy() for obj in scn.objects if not obj.parent]\n            self.inMove = True\n        if event.value == 'RELEASE' and (not self.zoomBoxMode):\n            self.inMove = False\n            if not event.ctrl:\n                if not self.prefs.lockOrigin:\n                    loc1 = mouseTo3d(context, self.x1, self.y1)\n                    loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    dlt = loc1 - loc2\n                    self.map.moveOrigin(dlt.x, dlt.y, updObjLoc=False)\n                self.map.get()\n        if event.value == 'PRESS' and self.zoomBoxMode:\n            self.zoomBoxDrag = True\n            (self.zb_xmin, self.zb_ymin) = (event.mouse_region_x, event.mouse_region_y)\n        if event.value == 'RELEASE' and self.zoomBoxMode:\n            xmax = max(event.mouse_region_x, self.zb_xmin)\n            ymax = max(event.mouse_region_y, self.zb_ymin)\n            xmin = min(event.mouse_region_x, self.zb_xmin)\n            ymin = min(event.mouse_region_y, self.zb_ymin)\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n            w = xmax - xmin\n            h = ymax - ymin\n            cx = xmin + w / 2\n            cy = ymin + h / 2\n            loc = mouseTo3d(context, cx, cy)\n            px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n            mapRes = self.map.tm.getRes(self.map.zoom)\n            dst_diag = math.sqrt((w * mapRes) ** 2 + (h * mapRes) ** 2)\n            targetRes = dst_diag / px_diag\n            z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n            resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n            context.region_data.view_distance *= resFactor\n            if self.prefs.lockOrigin:\n                context.region_data.view_location = loc\n            else:\n                self.map.moveOrigin(loc.x, loc.y, updObjLoc=self.updObjLoc)\n            self.map.zoom = z\n            self.map.get()\n    if event.type in ['LEFT_CTRL', 'RIGHT_CTRL']:\n        if event.value == 'PRESS':\n            self._viewDstZ = context.region_data.view_distance\n            self._viewLoc = context.region_data.view_location.copy()\n        if event.value == 'RELEASE':\n            context.region_data.view_distance = self._viewDstZ\n            context.region_data.view_location = self._viewLoc\n    if event.value == 'PRESS' and event.type in ['NUMPAD_2', 'NUMPAD_4', 'NUMPAD_6', 'NUMPAD_8']:\n        delta = self.map.bkg.scale.x * self.moveFactor\n        if event.type == 'NUMPAD_4':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((-delta, 0, 0))\n            else:\n                self.map.moveOrigin(-delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_6':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((delta, 0, 0))\n            else:\n                self.map.moveOrigin(delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_2':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, -delta, 0))\n            else:\n                self.map.moveOrigin(0, -delta, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_8':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, delta, 0))\n            else:\n                self.map.moveOrigin(0, delta, updObjLoc=self.updObjLoc)\n        if not event.ctrl:\n            self.map.get()\n    if event.type == 'SPACE':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        return {'FINISHED'}\n    if event.type == 'G':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'SEARCH'\n        return {'FINISHED'}\n    if event.type == 'O':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'OPTIONS'\n        return {'FINISHED'}\n    if event.type == 'L' and event.value == 'PRESS':\n        if self.map.lockedZoom is None:\n            self.map.lockedZoom = self.map.zoom\n        else:\n            self.map.lockedZoom = None\n            self.map.get()\n    if event.type == 'B' and event.value == 'PRESS':\n        self.map.stop()\n        self.zoomBoxMode = True\n        (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        context.window.cursor_set('CROSSHAIR')\n    if event.type == 'E' and event.value == 'PRESS':\n        if not self.map.srv.running and self.map.mosaic is not None:\n            self.map.stop()\n            self.map.bkg.hide_viewport = True\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            bpyImg = bpy.data.images.load(self.map.imgPath)\n            name = 'EXPORT_' + self.map.srckey + '_' + self.map.laykey + '_' + self.map.grdkey\n            bpyImg.name = name\n            bpyImg.pack()\n            rast = self.map.mosaic\n            setattr(rast, 'bpyImg', bpyImg)\n            (dx, dy) = self.map.getOriginPrj()\n            mesh = rasterExtentToMesh(name, rast, dx, dy, pxLoc='CORNER')\n            obj = placeObj(mesh, name)\n            uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n            geoRastUVmap(obj, uvTxtLayer, rast, dx, dy)\n            mat = bpy.data.materials.new('rastMat')\n            obj.data.materials.append(mat)\n            addTexture(mat, bpyImg, uvTxtLayer)\n            if self.prefs.adjust3Dview:\n                adjust3Dview(context, getBBOX.fromObj(obj))\n            if self.prefs.forceTexturedSolid:\n                showTextures(context)\n            return {'FINISHED'}\n    if event.type == 'ESC' and event.value == 'PRESS':\n        if self.zoomBoxMode:\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n        else:\n            self.map.stop()\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            return {'CANCELLED'}\n    return {'RUNNING_MODAL'}",
            "def modal(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    context.area.tag_redraw()\n    scn = bpy.context.scene\n    if event.type == 'TIMER':\n        self.progress = self.map.srv.report\n        return {'PASS_THROUGH'}\n    if event.type in ['WHEELUPMOUSE', 'NUMPAD_PLUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                self.map.scale *= 10\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location /= 10\n                    obj.scale /= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance -= dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc += deltaVect\n            elif self.map.zoom < self.map.layer.zmax and self.map.zoom < self.map.tm.nbLevels - 1:\n                self.map.zoom += 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getNextResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type in ['WHEELDOWNMOUSE', 'NUMPAD_MINUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                s = self.map.scale / 10\n                if s < 1:\n                    s = 1\n                self.map.scale = s\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location *= 10\n                    obj.scale *= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance += dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc -= deltaVect\n            elif self.map.zoom > self.map.layer.zmin and self.map.zoom > 0:\n                self.map.zoom -= 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getPrevResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type == 'MOUSEMOVE':\n        loc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n        (self.posx, self.posy) = self.map.view3dToProj(loc.x, loc.y)\n        if self.zoomBoxMode:\n            (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        if self.inMove:\n            loc1 = mouseTo3d(context, self.x1, self.y1)\n            loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n            dlt = loc1 - loc2\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location = self.viewLoc1 + dlt\n            else:\n                if self.map.bkg is not None:\n                    self.map.bkg.location[0] = self.offx1 - dlt.x\n                    self.map.bkg.location[1] = self.offy1 - dlt.y\n                if self.updObjLoc:\n                    topParents = [obj for obj in scn.objects if not obj.parent]\n                    for (i, obj) in enumerate(topParents):\n                        if obj == self.map.bkg:\n                            continue\n                        loc1 = self.objsLoc1[i]\n                        obj.location.x = loc1.x - dlt.x\n                        obj.location.y = loc1.y - dlt.y\n    if event.type in {'LEFTMOUSE', 'MIDDLEMOUSE'}:\n        if event.value == 'PRESS' and (not self.zoomBoxMode):\n            (self.x1, self.y1) = (event.mouse_region_x, event.mouse_region_y)\n            self.viewLoc1 = context.region_data.view_location.copy()\n            if not event.ctrl:\n                self.map.stop()\n                if not self.prefs.lockOrigin:\n                    if self.map.bkg is not None:\n                        self.offx1 = self.map.bkg.location[0]\n                        self.offy1 = self.map.bkg.location[1]\n                    self.objsLoc1 = [obj.location.copy() for obj in scn.objects if not obj.parent]\n            self.inMove = True\n        if event.value == 'RELEASE' and (not self.zoomBoxMode):\n            self.inMove = False\n            if not event.ctrl:\n                if not self.prefs.lockOrigin:\n                    loc1 = mouseTo3d(context, self.x1, self.y1)\n                    loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    dlt = loc1 - loc2\n                    self.map.moveOrigin(dlt.x, dlt.y, updObjLoc=False)\n                self.map.get()\n        if event.value == 'PRESS' and self.zoomBoxMode:\n            self.zoomBoxDrag = True\n            (self.zb_xmin, self.zb_ymin) = (event.mouse_region_x, event.mouse_region_y)\n        if event.value == 'RELEASE' and self.zoomBoxMode:\n            xmax = max(event.mouse_region_x, self.zb_xmin)\n            ymax = max(event.mouse_region_y, self.zb_ymin)\n            xmin = min(event.mouse_region_x, self.zb_xmin)\n            ymin = min(event.mouse_region_y, self.zb_ymin)\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n            w = xmax - xmin\n            h = ymax - ymin\n            cx = xmin + w / 2\n            cy = ymin + h / 2\n            loc = mouseTo3d(context, cx, cy)\n            px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n            mapRes = self.map.tm.getRes(self.map.zoom)\n            dst_diag = math.sqrt((w * mapRes) ** 2 + (h * mapRes) ** 2)\n            targetRes = dst_diag / px_diag\n            z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n            resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n            context.region_data.view_distance *= resFactor\n            if self.prefs.lockOrigin:\n                context.region_data.view_location = loc\n            else:\n                self.map.moveOrigin(loc.x, loc.y, updObjLoc=self.updObjLoc)\n            self.map.zoom = z\n            self.map.get()\n    if event.type in ['LEFT_CTRL', 'RIGHT_CTRL']:\n        if event.value == 'PRESS':\n            self._viewDstZ = context.region_data.view_distance\n            self._viewLoc = context.region_data.view_location.copy()\n        if event.value == 'RELEASE':\n            context.region_data.view_distance = self._viewDstZ\n            context.region_data.view_location = self._viewLoc\n    if event.value == 'PRESS' and event.type in ['NUMPAD_2', 'NUMPAD_4', 'NUMPAD_6', 'NUMPAD_8']:\n        delta = self.map.bkg.scale.x * self.moveFactor\n        if event.type == 'NUMPAD_4':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((-delta, 0, 0))\n            else:\n                self.map.moveOrigin(-delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_6':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((delta, 0, 0))\n            else:\n                self.map.moveOrigin(delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_2':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, -delta, 0))\n            else:\n                self.map.moveOrigin(0, -delta, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_8':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, delta, 0))\n            else:\n                self.map.moveOrigin(0, delta, updObjLoc=self.updObjLoc)\n        if not event.ctrl:\n            self.map.get()\n    if event.type == 'SPACE':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        return {'FINISHED'}\n    if event.type == 'G':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'SEARCH'\n        return {'FINISHED'}\n    if event.type == 'O':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'OPTIONS'\n        return {'FINISHED'}\n    if event.type == 'L' and event.value == 'PRESS':\n        if self.map.lockedZoom is None:\n            self.map.lockedZoom = self.map.zoom\n        else:\n            self.map.lockedZoom = None\n            self.map.get()\n    if event.type == 'B' and event.value == 'PRESS':\n        self.map.stop()\n        self.zoomBoxMode = True\n        (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        context.window.cursor_set('CROSSHAIR')\n    if event.type == 'E' and event.value == 'PRESS':\n        if not self.map.srv.running and self.map.mosaic is not None:\n            self.map.stop()\n            self.map.bkg.hide_viewport = True\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            bpyImg = bpy.data.images.load(self.map.imgPath)\n            name = 'EXPORT_' + self.map.srckey + '_' + self.map.laykey + '_' + self.map.grdkey\n            bpyImg.name = name\n            bpyImg.pack()\n            rast = self.map.mosaic\n            setattr(rast, 'bpyImg', bpyImg)\n            (dx, dy) = self.map.getOriginPrj()\n            mesh = rasterExtentToMesh(name, rast, dx, dy, pxLoc='CORNER')\n            obj = placeObj(mesh, name)\n            uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n            geoRastUVmap(obj, uvTxtLayer, rast, dx, dy)\n            mat = bpy.data.materials.new('rastMat')\n            obj.data.materials.append(mat)\n            addTexture(mat, bpyImg, uvTxtLayer)\n            if self.prefs.adjust3Dview:\n                adjust3Dview(context, getBBOX.fromObj(obj))\n            if self.prefs.forceTexturedSolid:\n                showTextures(context)\n            return {'FINISHED'}\n    if event.type == 'ESC' and event.value == 'PRESS':\n        if self.zoomBoxMode:\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n        else:\n            self.map.stop()\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            return {'CANCELLED'}\n    return {'RUNNING_MODAL'}",
            "def modal(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    context.area.tag_redraw()\n    scn = bpy.context.scene\n    if event.type == 'TIMER':\n        self.progress = self.map.srv.report\n        return {'PASS_THROUGH'}\n    if event.type in ['WHEELUPMOUSE', 'NUMPAD_PLUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                self.map.scale *= 10\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location /= 10\n                    obj.scale /= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance -= dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc += deltaVect\n            elif self.map.zoom < self.map.layer.zmax and self.map.zoom < self.map.tm.nbLevels - 1:\n                self.map.zoom += 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getNextResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type in ['WHEELDOWNMOUSE', 'NUMPAD_MINUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                s = self.map.scale / 10\n                if s < 1:\n                    s = 1\n                self.map.scale = s\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location *= 10\n                    obj.scale *= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance += dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc -= deltaVect\n            elif self.map.zoom > self.map.layer.zmin and self.map.zoom > 0:\n                self.map.zoom -= 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getPrevResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type == 'MOUSEMOVE':\n        loc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n        (self.posx, self.posy) = self.map.view3dToProj(loc.x, loc.y)\n        if self.zoomBoxMode:\n            (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        if self.inMove:\n            loc1 = mouseTo3d(context, self.x1, self.y1)\n            loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n            dlt = loc1 - loc2\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location = self.viewLoc1 + dlt\n            else:\n                if self.map.bkg is not None:\n                    self.map.bkg.location[0] = self.offx1 - dlt.x\n                    self.map.bkg.location[1] = self.offy1 - dlt.y\n                if self.updObjLoc:\n                    topParents = [obj for obj in scn.objects if not obj.parent]\n                    for (i, obj) in enumerate(topParents):\n                        if obj == self.map.bkg:\n                            continue\n                        loc1 = self.objsLoc1[i]\n                        obj.location.x = loc1.x - dlt.x\n                        obj.location.y = loc1.y - dlt.y\n    if event.type in {'LEFTMOUSE', 'MIDDLEMOUSE'}:\n        if event.value == 'PRESS' and (not self.zoomBoxMode):\n            (self.x1, self.y1) = (event.mouse_region_x, event.mouse_region_y)\n            self.viewLoc1 = context.region_data.view_location.copy()\n            if not event.ctrl:\n                self.map.stop()\n                if not self.prefs.lockOrigin:\n                    if self.map.bkg is not None:\n                        self.offx1 = self.map.bkg.location[0]\n                        self.offy1 = self.map.bkg.location[1]\n                    self.objsLoc1 = [obj.location.copy() for obj in scn.objects if not obj.parent]\n            self.inMove = True\n        if event.value == 'RELEASE' and (not self.zoomBoxMode):\n            self.inMove = False\n            if not event.ctrl:\n                if not self.prefs.lockOrigin:\n                    loc1 = mouseTo3d(context, self.x1, self.y1)\n                    loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    dlt = loc1 - loc2\n                    self.map.moveOrigin(dlt.x, dlt.y, updObjLoc=False)\n                self.map.get()\n        if event.value == 'PRESS' and self.zoomBoxMode:\n            self.zoomBoxDrag = True\n            (self.zb_xmin, self.zb_ymin) = (event.mouse_region_x, event.mouse_region_y)\n        if event.value == 'RELEASE' and self.zoomBoxMode:\n            xmax = max(event.mouse_region_x, self.zb_xmin)\n            ymax = max(event.mouse_region_y, self.zb_ymin)\n            xmin = min(event.mouse_region_x, self.zb_xmin)\n            ymin = min(event.mouse_region_y, self.zb_ymin)\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n            w = xmax - xmin\n            h = ymax - ymin\n            cx = xmin + w / 2\n            cy = ymin + h / 2\n            loc = mouseTo3d(context, cx, cy)\n            px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n            mapRes = self.map.tm.getRes(self.map.zoom)\n            dst_diag = math.sqrt((w * mapRes) ** 2 + (h * mapRes) ** 2)\n            targetRes = dst_diag / px_diag\n            z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n            resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n            context.region_data.view_distance *= resFactor\n            if self.prefs.lockOrigin:\n                context.region_data.view_location = loc\n            else:\n                self.map.moveOrigin(loc.x, loc.y, updObjLoc=self.updObjLoc)\n            self.map.zoom = z\n            self.map.get()\n    if event.type in ['LEFT_CTRL', 'RIGHT_CTRL']:\n        if event.value == 'PRESS':\n            self._viewDstZ = context.region_data.view_distance\n            self._viewLoc = context.region_data.view_location.copy()\n        if event.value == 'RELEASE':\n            context.region_data.view_distance = self._viewDstZ\n            context.region_data.view_location = self._viewLoc\n    if event.value == 'PRESS' and event.type in ['NUMPAD_2', 'NUMPAD_4', 'NUMPAD_6', 'NUMPAD_8']:\n        delta = self.map.bkg.scale.x * self.moveFactor\n        if event.type == 'NUMPAD_4':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((-delta, 0, 0))\n            else:\n                self.map.moveOrigin(-delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_6':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((delta, 0, 0))\n            else:\n                self.map.moveOrigin(delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_2':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, -delta, 0))\n            else:\n                self.map.moveOrigin(0, -delta, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_8':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, delta, 0))\n            else:\n                self.map.moveOrigin(0, delta, updObjLoc=self.updObjLoc)\n        if not event.ctrl:\n            self.map.get()\n    if event.type == 'SPACE':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        return {'FINISHED'}\n    if event.type == 'G':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'SEARCH'\n        return {'FINISHED'}\n    if event.type == 'O':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'OPTIONS'\n        return {'FINISHED'}\n    if event.type == 'L' and event.value == 'PRESS':\n        if self.map.lockedZoom is None:\n            self.map.lockedZoom = self.map.zoom\n        else:\n            self.map.lockedZoom = None\n            self.map.get()\n    if event.type == 'B' and event.value == 'PRESS':\n        self.map.stop()\n        self.zoomBoxMode = True\n        (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        context.window.cursor_set('CROSSHAIR')\n    if event.type == 'E' and event.value == 'PRESS':\n        if not self.map.srv.running and self.map.mosaic is not None:\n            self.map.stop()\n            self.map.bkg.hide_viewport = True\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            bpyImg = bpy.data.images.load(self.map.imgPath)\n            name = 'EXPORT_' + self.map.srckey + '_' + self.map.laykey + '_' + self.map.grdkey\n            bpyImg.name = name\n            bpyImg.pack()\n            rast = self.map.mosaic\n            setattr(rast, 'bpyImg', bpyImg)\n            (dx, dy) = self.map.getOriginPrj()\n            mesh = rasterExtentToMesh(name, rast, dx, dy, pxLoc='CORNER')\n            obj = placeObj(mesh, name)\n            uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n            geoRastUVmap(obj, uvTxtLayer, rast, dx, dy)\n            mat = bpy.data.materials.new('rastMat')\n            obj.data.materials.append(mat)\n            addTexture(mat, bpyImg, uvTxtLayer)\n            if self.prefs.adjust3Dview:\n                adjust3Dview(context, getBBOX.fromObj(obj))\n            if self.prefs.forceTexturedSolid:\n                showTextures(context)\n            return {'FINISHED'}\n    if event.type == 'ESC' and event.value == 'PRESS':\n        if self.zoomBoxMode:\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n        else:\n            self.map.stop()\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            return {'CANCELLED'}\n    return {'RUNNING_MODAL'}",
            "def modal(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    context.area.tag_redraw()\n    scn = bpy.context.scene\n    if event.type == 'TIMER':\n        self.progress = self.map.srv.report\n        return {'PASS_THROUGH'}\n    if event.type in ['WHEELUPMOUSE', 'NUMPAD_PLUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                self.map.scale *= 10\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location /= 10\n                    obj.scale /= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance -= dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc += deltaVect\n            elif self.map.zoom < self.map.layer.zmax and self.map.zoom < self.map.tm.nbLevels - 1:\n                self.map.zoom += 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getNextResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type in ['WHEELDOWNMOUSE', 'NUMPAD_MINUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                s = self.map.scale / 10\n                if s < 1:\n                    s = 1\n                self.map.scale = s\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location *= 10\n                    obj.scale *= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance += dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc -= deltaVect\n            elif self.map.zoom > self.map.layer.zmin and self.map.zoom > 0:\n                self.map.zoom -= 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getPrevResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type == 'MOUSEMOVE':\n        loc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n        (self.posx, self.posy) = self.map.view3dToProj(loc.x, loc.y)\n        if self.zoomBoxMode:\n            (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        if self.inMove:\n            loc1 = mouseTo3d(context, self.x1, self.y1)\n            loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n            dlt = loc1 - loc2\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location = self.viewLoc1 + dlt\n            else:\n                if self.map.bkg is not None:\n                    self.map.bkg.location[0] = self.offx1 - dlt.x\n                    self.map.bkg.location[1] = self.offy1 - dlt.y\n                if self.updObjLoc:\n                    topParents = [obj for obj in scn.objects if not obj.parent]\n                    for (i, obj) in enumerate(topParents):\n                        if obj == self.map.bkg:\n                            continue\n                        loc1 = self.objsLoc1[i]\n                        obj.location.x = loc1.x - dlt.x\n                        obj.location.y = loc1.y - dlt.y\n    if event.type in {'LEFTMOUSE', 'MIDDLEMOUSE'}:\n        if event.value == 'PRESS' and (not self.zoomBoxMode):\n            (self.x1, self.y1) = (event.mouse_region_x, event.mouse_region_y)\n            self.viewLoc1 = context.region_data.view_location.copy()\n            if not event.ctrl:\n                self.map.stop()\n                if not self.prefs.lockOrigin:\n                    if self.map.bkg is not None:\n                        self.offx1 = self.map.bkg.location[0]\n                        self.offy1 = self.map.bkg.location[1]\n                    self.objsLoc1 = [obj.location.copy() for obj in scn.objects if not obj.parent]\n            self.inMove = True\n        if event.value == 'RELEASE' and (not self.zoomBoxMode):\n            self.inMove = False\n            if not event.ctrl:\n                if not self.prefs.lockOrigin:\n                    loc1 = mouseTo3d(context, self.x1, self.y1)\n                    loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    dlt = loc1 - loc2\n                    self.map.moveOrigin(dlt.x, dlt.y, updObjLoc=False)\n                self.map.get()\n        if event.value == 'PRESS' and self.zoomBoxMode:\n            self.zoomBoxDrag = True\n            (self.zb_xmin, self.zb_ymin) = (event.mouse_region_x, event.mouse_region_y)\n        if event.value == 'RELEASE' and self.zoomBoxMode:\n            xmax = max(event.mouse_region_x, self.zb_xmin)\n            ymax = max(event.mouse_region_y, self.zb_ymin)\n            xmin = min(event.mouse_region_x, self.zb_xmin)\n            ymin = min(event.mouse_region_y, self.zb_ymin)\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n            w = xmax - xmin\n            h = ymax - ymin\n            cx = xmin + w / 2\n            cy = ymin + h / 2\n            loc = mouseTo3d(context, cx, cy)\n            px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n            mapRes = self.map.tm.getRes(self.map.zoom)\n            dst_diag = math.sqrt((w * mapRes) ** 2 + (h * mapRes) ** 2)\n            targetRes = dst_diag / px_diag\n            z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n            resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n            context.region_data.view_distance *= resFactor\n            if self.prefs.lockOrigin:\n                context.region_data.view_location = loc\n            else:\n                self.map.moveOrigin(loc.x, loc.y, updObjLoc=self.updObjLoc)\n            self.map.zoom = z\n            self.map.get()\n    if event.type in ['LEFT_CTRL', 'RIGHT_CTRL']:\n        if event.value == 'PRESS':\n            self._viewDstZ = context.region_data.view_distance\n            self._viewLoc = context.region_data.view_location.copy()\n        if event.value == 'RELEASE':\n            context.region_data.view_distance = self._viewDstZ\n            context.region_data.view_location = self._viewLoc\n    if event.value == 'PRESS' and event.type in ['NUMPAD_2', 'NUMPAD_4', 'NUMPAD_6', 'NUMPAD_8']:\n        delta = self.map.bkg.scale.x * self.moveFactor\n        if event.type == 'NUMPAD_4':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((-delta, 0, 0))\n            else:\n                self.map.moveOrigin(-delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_6':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((delta, 0, 0))\n            else:\n                self.map.moveOrigin(delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_2':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, -delta, 0))\n            else:\n                self.map.moveOrigin(0, -delta, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_8':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, delta, 0))\n            else:\n                self.map.moveOrigin(0, delta, updObjLoc=self.updObjLoc)\n        if not event.ctrl:\n            self.map.get()\n    if event.type == 'SPACE':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        return {'FINISHED'}\n    if event.type == 'G':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'SEARCH'\n        return {'FINISHED'}\n    if event.type == 'O':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'OPTIONS'\n        return {'FINISHED'}\n    if event.type == 'L' and event.value == 'PRESS':\n        if self.map.lockedZoom is None:\n            self.map.lockedZoom = self.map.zoom\n        else:\n            self.map.lockedZoom = None\n            self.map.get()\n    if event.type == 'B' and event.value == 'PRESS':\n        self.map.stop()\n        self.zoomBoxMode = True\n        (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        context.window.cursor_set('CROSSHAIR')\n    if event.type == 'E' and event.value == 'PRESS':\n        if not self.map.srv.running and self.map.mosaic is not None:\n            self.map.stop()\n            self.map.bkg.hide_viewport = True\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            bpyImg = bpy.data.images.load(self.map.imgPath)\n            name = 'EXPORT_' + self.map.srckey + '_' + self.map.laykey + '_' + self.map.grdkey\n            bpyImg.name = name\n            bpyImg.pack()\n            rast = self.map.mosaic\n            setattr(rast, 'bpyImg', bpyImg)\n            (dx, dy) = self.map.getOriginPrj()\n            mesh = rasterExtentToMesh(name, rast, dx, dy, pxLoc='CORNER')\n            obj = placeObj(mesh, name)\n            uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n            geoRastUVmap(obj, uvTxtLayer, rast, dx, dy)\n            mat = bpy.data.materials.new('rastMat')\n            obj.data.materials.append(mat)\n            addTexture(mat, bpyImg, uvTxtLayer)\n            if self.prefs.adjust3Dview:\n                adjust3Dview(context, getBBOX.fromObj(obj))\n            if self.prefs.forceTexturedSolid:\n                showTextures(context)\n            return {'FINISHED'}\n    if event.type == 'ESC' and event.value == 'PRESS':\n        if self.zoomBoxMode:\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n        else:\n            self.map.stop()\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            return {'CANCELLED'}\n    return {'RUNNING_MODAL'}",
            "def modal(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    context.area.tag_redraw()\n    scn = bpy.context.scene\n    if event.type == 'TIMER':\n        self.progress = self.map.srv.report\n        return {'PASS_THROUGH'}\n    if event.type in ['WHEELUPMOUSE', 'NUMPAD_PLUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                self.map.scale *= 10\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location /= 10\n                    obj.scale /= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance -= dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc += deltaVect\n            elif self.map.zoom < self.map.layer.zmax and self.map.zoom < self.map.tm.nbLevels - 1:\n                self.map.zoom += 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getNextResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type in ['WHEELDOWNMOUSE', 'NUMPAD_MINUS']:\n        if event.value == 'PRESS':\n            if event.alt:\n                s = self.map.scale / 10\n                if s < 1:\n                    s = 1\n                self.map.scale = s\n                self.map.place()\n                for obj in scn.objects:\n                    obj.location *= 10\n                    obj.scale *= 10\n            elif event.ctrl:\n                dst = context.region_data.view_distance\n                context.region_data.view_distance += dst * self.moveFactor\n                if self.prefs.zoomToMouse:\n                    mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    viewLoc = context.region_data.view_location\n                    deltaVect = (mouseLoc - viewLoc) * self.moveFactor\n                    viewLoc -= deltaVect\n            elif self.map.zoom > self.map.layer.zmin and self.map.zoom > 0:\n                self.map.zoom -= 1\n                if self.map.lockedZoom is None:\n                    resFactor = self.map.tm.getPrevResFac(self.map.zoom)\n                    if not self.prefs.zoomToMouse:\n                        context.region_data.view_distance *= resFactor\n                    else:\n                        dst = context.region_data.view_distance\n                        dst2 = dst * resFactor\n                        context.region_data.view_distance = dst2\n                        mouseLoc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                        viewLoc = context.region_data.view_location\n                        moveFactor = (dst - dst2) / dst\n                        deltaVect = (mouseLoc - viewLoc) * moveFactor\n                        if self.prefs.lockOrigin:\n                            viewLoc += deltaVect\n                        else:\n                            (dx, dy, dz) = deltaVect\n                            if not self.prefs.lockObj and self.map.bkg is not None:\n                                self.map.bkg.location -= deltaVect\n                            self.map.moveOrigin(dx, dy, updObjLoc=self.updObjLoc)\n                self.map.get()\n    if event.type == 'MOUSEMOVE':\n        loc = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n        (self.posx, self.posy) = self.map.view3dToProj(loc.x, loc.y)\n        if self.zoomBoxMode:\n            (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        if self.inMove:\n            loc1 = mouseTo3d(context, self.x1, self.y1)\n            loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n            dlt = loc1 - loc2\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location = self.viewLoc1 + dlt\n            else:\n                if self.map.bkg is not None:\n                    self.map.bkg.location[0] = self.offx1 - dlt.x\n                    self.map.bkg.location[1] = self.offy1 - dlt.y\n                if self.updObjLoc:\n                    topParents = [obj for obj in scn.objects if not obj.parent]\n                    for (i, obj) in enumerate(topParents):\n                        if obj == self.map.bkg:\n                            continue\n                        loc1 = self.objsLoc1[i]\n                        obj.location.x = loc1.x - dlt.x\n                        obj.location.y = loc1.y - dlt.y\n    if event.type in {'LEFTMOUSE', 'MIDDLEMOUSE'}:\n        if event.value == 'PRESS' and (not self.zoomBoxMode):\n            (self.x1, self.y1) = (event.mouse_region_x, event.mouse_region_y)\n            self.viewLoc1 = context.region_data.view_location.copy()\n            if not event.ctrl:\n                self.map.stop()\n                if not self.prefs.lockOrigin:\n                    if self.map.bkg is not None:\n                        self.offx1 = self.map.bkg.location[0]\n                        self.offy1 = self.map.bkg.location[1]\n                    self.objsLoc1 = [obj.location.copy() for obj in scn.objects if not obj.parent]\n            self.inMove = True\n        if event.value == 'RELEASE' and (not self.zoomBoxMode):\n            self.inMove = False\n            if not event.ctrl:\n                if not self.prefs.lockOrigin:\n                    loc1 = mouseTo3d(context, self.x1, self.y1)\n                    loc2 = mouseTo3d(context, event.mouse_region_x, event.mouse_region_y)\n                    dlt = loc1 - loc2\n                    self.map.moveOrigin(dlt.x, dlt.y, updObjLoc=False)\n                self.map.get()\n        if event.value == 'PRESS' and self.zoomBoxMode:\n            self.zoomBoxDrag = True\n            (self.zb_xmin, self.zb_ymin) = (event.mouse_region_x, event.mouse_region_y)\n        if event.value == 'RELEASE' and self.zoomBoxMode:\n            xmax = max(event.mouse_region_x, self.zb_xmin)\n            ymax = max(event.mouse_region_y, self.zb_ymin)\n            xmin = min(event.mouse_region_x, self.zb_xmin)\n            ymin = min(event.mouse_region_y, self.zb_ymin)\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n            w = xmax - xmin\n            h = ymax - ymin\n            cx = xmin + w / 2\n            cy = ymin + h / 2\n            loc = mouseTo3d(context, cx, cy)\n            px_diag = math.sqrt(context.area.width ** 2 + context.area.height ** 2)\n            mapRes = self.map.tm.getRes(self.map.zoom)\n            dst_diag = math.sqrt((w * mapRes) ** 2 + (h * mapRes) ** 2)\n            targetRes = dst_diag / px_diag\n            z = self.map.tm.getNearestZoom(targetRes, rule='lower')\n            resFactor = self.map.tm.getFromToResFac(self.map.zoom, z)\n            context.region_data.view_distance *= resFactor\n            if self.prefs.lockOrigin:\n                context.region_data.view_location = loc\n            else:\n                self.map.moveOrigin(loc.x, loc.y, updObjLoc=self.updObjLoc)\n            self.map.zoom = z\n            self.map.get()\n    if event.type in ['LEFT_CTRL', 'RIGHT_CTRL']:\n        if event.value == 'PRESS':\n            self._viewDstZ = context.region_data.view_distance\n            self._viewLoc = context.region_data.view_location.copy()\n        if event.value == 'RELEASE':\n            context.region_data.view_distance = self._viewDstZ\n            context.region_data.view_location = self._viewLoc\n    if event.value == 'PRESS' and event.type in ['NUMPAD_2', 'NUMPAD_4', 'NUMPAD_6', 'NUMPAD_8']:\n        delta = self.map.bkg.scale.x * self.moveFactor\n        if event.type == 'NUMPAD_4':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((-delta, 0, 0))\n            else:\n                self.map.moveOrigin(-delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_6':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((delta, 0, 0))\n            else:\n                self.map.moveOrigin(delta, 0, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_2':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, -delta, 0))\n            else:\n                self.map.moveOrigin(0, -delta, updObjLoc=self.updObjLoc)\n        if event.type == 'NUMPAD_8':\n            if event.ctrl or self.prefs.lockOrigin:\n                context.region_data.view_location += Vector((0, delta, 0))\n            else:\n                self.map.moveOrigin(0, delta, updObjLoc=self.updObjLoc)\n        if not event.ctrl:\n            self.map.get()\n    if event.type == 'SPACE':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        return {'FINISHED'}\n    if event.type == 'G':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'SEARCH'\n        return {'FINISHED'}\n    if event.type == 'O':\n        self.map.stop()\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n        bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n        context.area.header_text_set(None)\n        self.restart = True\n        self.dialog = 'OPTIONS'\n        return {'FINISHED'}\n    if event.type == 'L' and event.value == 'PRESS':\n        if self.map.lockedZoom is None:\n            self.map.lockedZoom = self.map.zoom\n        else:\n            self.map.lockedZoom = None\n            self.map.get()\n    if event.type == 'B' and event.value == 'PRESS':\n        self.map.stop()\n        self.zoomBoxMode = True\n        (self.zb_xmax, self.zb_ymax) = (event.mouse_region_x, event.mouse_region_y)\n        context.window.cursor_set('CROSSHAIR')\n    if event.type == 'E' and event.value == 'PRESS':\n        if not self.map.srv.running and self.map.mosaic is not None:\n            self.map.stop()\n            self.map.bkg.hide_viewport = True\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            bpyImg = bpy.data.images.load(self.map.imgPath)\n            name = 'EXPORT_' + self.map.srckey + '_' + self.map.laykey + '_' + self.map.grdkey\n            bpyImg.name = name\n            bpyImg.pack()\n            rast = self.map.mosaic\n            setattr(rast, 'bpyImg', bpyImg)\n            (dx, dy) = self.map.getOriginPrj()\n            mesh = rasterExtentToMesh(name, rast, dx, dy, pxLoc='CORNER')\n            obj = placeObj(mesh, name)\n            uvTxtLayer = mesh.uv_layers.new(name='rastUVmap')\n            geoRastUVmap(obj, uvTxtLayer, rast, dx, dy)\n            mat = bpy.data.materials.new('rastMat')\n            obj.data.materials.append(mat)\n            addTexture(mat, bpyImg, uvTxtLayer)\n            if self.prefs.adjust3Dview:\n                adjust3Dview(context, getBBOX.fromObj(obj))\n            if self.prefs.forceTexturedSolid:\n                showTextures(context)\n            return {'FINISHED'}\n    if event.type == 'ESC' and event.value == 'PRESS':\n        if self.zoomBoxMode:\n            self.zoomBoxDrag = False\n            self.zoomBoxMode = False\n            context.window.cursor_set('DEFAULT')\n        else:\n            self.map.stop()\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawTextHandler, 'WINDOW')\n            bpy.types.SpaceView3D.draw_handler_remove(self._drawZoomBoxHandler, 'WINDOW')\n            context.area.header_text_set(None)\n            return {'CANCELLED'}\n    return {'RUNNING_MODAL'}"
        ]
    },
    {
        "func_name": "invoke",
        "original": "def invoke(self, context, event):\n    geoscn = GeoScene(context.scene)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken')\n        return {'CANCELLED'}\n    return context.window_manager.invoke_props_dialog(self)",
        "mutated": [
            "def invoke(self, context, event):\n    if False:\n        i = 10\n    geoscn = GeoScene(context.scene)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken')\n        return {'CANCELLED'}\n    return context.window_manager.invoke_props_dialog(self)",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    geoscn = GeoScene(context.scene)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken')\n        return {'CANCELLED'}\n    return context.window_manager.invoke_props_dialog(self)",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    geoscn = GeoScene(context.scene)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken')\n        return {'CANCELLED'}\n    return context.window_manager.invoke_props_dialog(self)",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    geoscn = GeoScene(context.scene)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken')\n        return {'CANCELLED'}\n    return context.window_manager.invoke_props_dialog(self)",
            "def invoke(self, context, event):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    geoscn = GeoScene(context.scene)\n    if geoscn.isBroken:\n        self.report({'ERROR'}, 'Scene georef is broken')\n        return {'CANCELLED'}\n    return context.window_manager.invoke_props_dialog(self)"
        ]
    },
    {
        "func_name": "execute",
        "original": "def execute(self, context):\n    geoscn = GeoScene(context.scene)\n    prefs = context.preferences.addons[PKG].preferences\n    try:\n        results = nominatimQuery(self.query, referer='bgis', user_agent=USER_AGENT)\n    except Exception as e:\n        log.error('Failed Nominatim query', exc_info=True)\n        return {'CANCELLED'}\n    if len(results) == 0:\n        return {'CANCELLED'}\n    else:\n        log.debug('Nominatim search results : {}'.format([r['display_name'] for r in results]))\n        result = results[0]\n        (lat, lon) = (float(result['lat']), float(result['lon']))\n        if geoscn.isGeoref:\n            geoscn.updOriginGeo(lon, lat, updObjLoc=prefs.lockObj)\n        else:\n            geoscn.setOriginGeo(lon, lat)\n    return {'FINISHED'}",
        "mutated": [
            "def execute(self, context):\n    if False:\n        i = 10\n    geoscn = GeoScene(context.scene)\n    prefs = context.preferences.addons[PKG].preferences\n    try:\n        results = nominatimQuery(self.query, referer='bgis', user_agent=USER_AGENT)\n    except Exception as e:\n        log.error('Failed Nominatim query', exc_info=True)\n        return {'CANCELLED'}\n    if len(results) == 0:\n        return {'CANCELLED'}\n    else:\n        log.debug('Nominatim search results : {}'.format([r['display_name'] for r in results]))\n        result = results[0]\n        (lat, lon) = (float(result['lat']), float(result['lon']))\n        if geoscn.isGeoref:\n            geoscn.updOriginGeo(lon, lat, updObjLoc=prefs.lockObj)\n        else:\n            geoscn.setOriginGeo(lon, lat)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    geoscn = GeoScene(context.scene)\n    prefs = context.preferences.addons[PKG].preferences\n    try:\n        results = nominatimQuery(self.query, referer='bgis', user_agent=USER_AGENT)\n    except Exception as e:\n        log.error('Failed Nominatim query', exc_info=True)\n        return {'CANCELLED'}\n    if len(results) == 0:\n        return {'CANCELLED'}\n    else:\n        log.debug('Nominatim search results : {}'.format([r['display_name'] for r in results]))\n        result = results[0]\n        (lat, lon) = (float(result['lat']), float(result['lon']))\n        if geoscn.isGeoref:\n            geoscn.updOriginGeo(lon, lat, updObjLoc=prefs.lockObj)\n        else:\n            geoscn.setOriginGeo(lon, lat)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    geoscn = GeoScene(context.scene)\n    prefs = context.preferences.addons[PKG].preferences\n    try:\n        results = nominatimQuery(self.query, referer='bgis', user_agent=USER_AGENT)\n    except Exception as e:\n        log.error('Failed Nominatim query', exc_info=True)\n        return {'CANCELLED'}\n    if len(results) == 0:\n        return {'CANCELLED'}\n    else:\n        log.debug('Nominatim search results : {}'.format([r['display_name'] for r in results]))\n        result = results[0]\n        (lat, lon) = (float(result['lat']), float(result['lon']))\n        if geoscn.isGeoref:\n            geoscn.updOriginGeo(lon, lat, updObjLoc=prefs.lockObj)\n        else:\n            geoscn.setOriginGeo(lon, lat)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    geoscn = GeoScene(context.scene)\n    prefs = context.preferences.addons[PKG].preferences\n    try:\n        results = nominatimQuery(self.query, referer='bgis', user_agent=USER_AGENT)\n    except Exception as e:\n        log.error('Failed Nominatim query', exc_info=True)\n        return {'CANCELLED'}\n    if len(results) == 0:\n        return {'CANCELLED'}\n    else:\n        log.debug('Nominatim search results : {}'.format([r['display_name'] for r in results]))\n        result = results[0]\n        (lat, lon) = (float(result['lat']), float(result['lon']))\n        if geoscn.isGeoref:\n            geoscn.updOriginGeo(lon, lat, updObjLoc=prefs.lockObj)\n        else:\n            geoscn.setOriginGeo(lon, lat)\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    geoscn = GeoScene(context.scene)\n    prefs = context.preferences.addons[PKG].preferences\n    try:\n        results = nominatimQuery(self.query, referer='bgis', user_agent=USER_AGENT)\n    except Exception as e:\n        log.error('Failed Nominatim query', exc_info=True)\n        return {'CANCELLED'}\n    if len(results) == 0:\n        return {'CANCELLED'}\n    else:\n        log.debug('Nominatim search results : {}'.format([r['display_name'] for r in results]))\n        result = results[0]\n        (lat, lon) = (float(result['lat']), float(result['lon']))\n        if geoscn.isGeoref:\n            geoscn.updOriginGeo(lon, lat, updObjLoc=prefs.lockObj)\n        else:\n            geoscn.setOriginGeo(lon, lat)\n    return {'FINISHED'}"
        ]
    },
    {
        "func_name": "register",
        "original": "def register():\n    for cls in classes:\n        try:\n            bpy.utils.register_class(cls)\n        except ValueError as e:\n            log.warning('{} is already registered, now unregister and retry... '.format(cls))\n            bpy.utils.unregister_class(cls)\n            bpy.utils.register_class(cls)",
        "mutated": [
            "def register():\n    if False:\n        i = 10\n    for cls in classes:\n        try:\n            bpy.utils.register_class(cls)\n        except ValueError as e:\n            log.warning('{} is already registered, now unregister and retry... '.format(cls))\n            bpy.utils.unregister_class(cls)\n            bpy.utils.register_class(cls)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for cls in classes:\n        try:\n            bpy.utils.register_class(cls)\n        except ValueError as e:\n            log.warning('{} is already registered, now unregister and retry... '.format(cls))\n            bpy.utils.unregister_class(cls)\n            bpy.utils.register_class(cls)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for cls in classes:\n        try:\n            bpy.utils.register_class(cls)\n        except ValueError as e:\n            log.warning('{} is already registered, now unregister and retry... '.format(cls))\n            bpy.utils.unregister_class(cls)\n            bpy.utils.register_class(cls)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for cls in classes:\n        try:\n            bpy.utils.register_class(cls)\n        except ValueError as e:\n            log.warning('{} is already registered, now unregister and retry... '.format(cls))\n            bpy.utils.unregister_class(cls)\n            bpy.utils.register_class(cls)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for cls in classes:\n        try:\n            bpy.utils.register_class(cls)\n        except ValueError as e:\n            log.warning('{} is already registered, now unregister and retry... '.format(cls))\n            bpy.utils.unregister_class(cls)\n            bpy.utils.register_class(cls)"
        ]
    },
    {
        "func_name": "unregister",
        "original": "def unregister():\n    for cls in classes:\n        bpy.utils.unregister_class(cls)",
        "mutated": [
            "def unregister():\n    if False:\n        i = 10\n    for cls in classes:\n        bpy.utils.unregister_class(cls)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for cls in classes:\n        bpy.utils.unregister_class(cls)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for cls in classes:\n        bpy.utils.unregister_class(cls)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for cls in classes:\n        bpy.utils.unregister_class(cls)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for cls in classes:\n        bpy.utils.unregister_class(cls)"
        ]
    }
]