[
    {
        "func_name": "benchmark",
        "original": "@ignore_warnings\ndef benchmark(metrics=tuple((v for (k, v) in sorted(METRICS.items()))), formats=tuple((v for (k, v) in sorted(FORMATS.items()))), samples=1000, classes=4, density=0.2, n_times=5):\n    \"\"\"Times metric calculations for a number of inputs\n\n    Parameters\n    ----------\n    metrics : array-like of callables (1d or 0d)\n        The metric functions to time.\n\n    formats : array-like of callables (1d or 0d)\n        These may transform a dense indicator matrix into multilabel\n        representation.\n\n    samples : array-like of ints (1d or 0d)\n        The number of samples to generate as input.\n\n    classes : array-like of ints (1d or 0d)\n        The number of classes in the input.\n\n    density : array-like of ints (1d or 0d)\n        The density of positive labels in the input.\n\n    n_times : int\n        Time calling the metric n_times times.\n\n    Returns\n    -------\n    array of floats shaped like (metrics, formats, samples, classes, density)\n        Time in seconds.\n    \"\"\"\n    metrics = np.atleast_1d(metrics)\n    samples = np.atleast_1d(samples)\n    classes = np.atleast_1d(classes)\n    density = np.atleast_1d(density)\n    formats = np.atleast_1d(formats)\n    out = np.zeros((len(metrics), len(formats), len(samples), len(classes), len(density)), dtype=float)\n    it = itertools.product(samples, classes, density)\n    for (i, (s, c, d)) in enumerate(it):\n        (_, y_true) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=42)\n        (_, y_pred) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=84)\n        for (j, f) in enumerate(formats):\n            f_true = f(y_true)\n            f_pred = f(y_pred)\n            for (k, metric) in enumerate(metrics):\n                t = timeit(partial(metric, f_true, f_pred), number=n_times)\n                out[k, j].flat[i] = t\n    return out",
        "mutated": [
            "@ignore_warnings\ndef benchmark(metrics=tuple((v for (k, v) in sorted(METRICS.items()))), formats=tuple((v for (k, v) in sorted(FORMATS.items()))), samples=1000, classes=4, density=0.2, n_times=5):\n    if False:\n        i = 10\n    'Times metric calculations for a number of inputs\\n\\n    Parameters\\n    ----------\\n    metrics : array-like of callables (1d or 0d)\\n        The metric functions to time.\\n\\n    formats : array-like of callables (1d or 0d)\\n        These may transform a dense indicator matrix into multilabel\\n        representation.\\n\\n    samples : array-like of ints (1d or 0d)\\n        The number of samples to generate as input.\\n\\n    classes : array-like of ints (1d or 0d)\\n        The number of classes in the input.\\n\\n    density : array-like of ints (1d or 0d)\\n        The density of positive labels in the input.\\n\\n    n_times : int\\n        Time calling the metric n_times times.\\n\\n    Returns\\n    -------\\n    array of floats shaped like (metrics, formats, samples, classes, density)\\n        Time in seconds.\\n    '\n    metrics = np.atleast_1d(metrics)\n    samples = np.atleast_1d(samples)\n    classes = np.atleast_1d(classes)\n    density = np.atleast_1d(density)\n    formats = np.atleast_1d(formats)\n    out = np.zeros((len(metrics), len(formats), len(samples), len(classes), len(density)), dtype=float)\n    it = itertools.product(samples, classes, density)\n    for (i, (s, c, d)) in enumerate(it):\n        (_, y_true) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=42)\n        (_, y_pred) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=84)\n        for (j, f) in enumerate(formats):\n            f_true = f(y_true)\n            f_pred = f(y_pred)\n            for (k, metric) in enumerate(metrics):\n                t = timeit(partial(metric, f_true, f_pred), number=n_times)\n                out[k, j].flat[i] = t\n    return out",
            "@ignore_warnings\ndef benchmark(metrics=tuple((v for (k, v) in sorted(METRICS.items()))), formats=tuple((v for (k, v) in sorted(FORMATS.items()))), samples=1000, classes=4, density=0.2, n_times=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Times metric calculations for a number of inputs\\n\\n    Parameters\\n    ----------\\n    metrics : array-like of callables (1d or 0d)\\n        The metric functions to time.\\n\\n    formats : array-like of callables (1d or 0d)\\n        These may transform a dense indicator matrix into multilabel\\n        representation.\\n\\n    samples : array-like of ints (1d or 0d)\\n        The number of samples to generate as input.\\n\\n    classes : array-like of ints (1d or 0d)\\n        The number of classes in the input.\\n\\n    density : array-like of ints (1d or 0d)\\n        The density of positive labels in the input.\\n\\n    n_times : int\\n        Time calling the metric n_times times.\\n\\n    Returns\\n    -------\\n    array of floats shaped like (metrics, formats, samples, classes, density)\\n        Time in seconds.\\n    '\n    metrics = np.atleast_1d(metrics)\n    samples = np.atleast_1d(samples)\n    classes = np.atleast_1d(classes)\n    density = np.atleast_1d(density)\n    formats = np.atleast_1d(formats)\n    out = np.zeros((len(metrics), len(formats), len(samples), len(classes), len(density)), dtype=float)\n    it = itertools.product(samples, classes, density)\n    for (i, (s, c, d)) in enumerate(it):\n        (_, y_true) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=42)\n        (_, y_pred) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=84)\n        for (j, f) in enumerate(formats):\n            f_true = f(y_true)\n            f_pred = f(y_pred)\n            for (k, metric) in enumerate(metrics):\n                t = timeit(partial(metric, f_true, f_pred), number=n_times)\n                out[k, j].flat[i] = t\n    return out",
            "@ignore_warnings\ndef benchmark(metrics=tuple((v for (k, v) in sorted(METRICS.items()))), formats=tuple((v for (k, v) in sorted(FORMATS.items()))), samples=1000, classes=4, density=0.2, n_times=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Times metric calculations for a number of inputs\\n\\n    Parameters\\n    ----------\\n    metrics : array-like of callables (1d or 0d)\\n        The metric functions to time.\\n\\n    formats : array-like of callables (1d or 0d)\\n        These may transform a dense indicator matrix into multilabel\\n        representation.\\n\\n    samples : array-like of ints (1d or 0d)\\n        The number of samples to generate as input.\\n\\n    classes : array-like of ints (1d or 0d)\\n        The number of classes in the input.\\n\\n    density : array-like of ints (1d or 0d)\\n        The density of positive labels in the input.\\n\\n    n_times : int\\n        Time calling the metric n_times times.\\n\\n    Returns\\n    -------\\n    array of floats shaped like (metrics, formats, samples, classes, density)\\n        Time in seconds.\\n    '\n    metrics = np.atleast_1d(metrics)\n    samples = np.atleast_1d(samples)\n    classes = np.atleast_1d(classes)\n    density = np.atleast_1d(density)\n    formats = np.atleast_1d(formats)\n    out = np.zeros((len(metrics), len(formats), len(samples), len(classes), len(density)), dtype=float)\n    it = itertools.product(samples, classes, density)\n    for (i, (s, c, d)) in enumerate(it):\n        (_, y_true) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=42)\n        (_, y_pred) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=84)\n        for (j, f) in enumerate(formats):\n            f_true = f(y_true)\n            f_pred = f(y_pred)\n            for (k, metric) in enumerate(metrics):\n                t = timeit(partial(metric, f_true, f_pred), number=n_times)\n                out[k, j].flat[i] = t\n    return out",
            "@ignore_warnings\ndef benchmark(metrics=tuple((v for (k, v) in sorted(METRICS.items()))), formats=tuple((v for (k, v) in sorted(FORMATS.items()))), samples=1000, classes=4, density=0.2, n_times=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Times metric calculations for a number of inputs\\n\\n    Parameters\\n    ----------\\n    metrics : array-like of callables (1d or 0d)\\n        The metric functions to time.\\n\\n    formats : array-like of callables (1d or 0d)\\n        These may transform a dense indicator matrix into multilabel\\n        representation.\\n\\n    samples : array-like of ints (1d or 0d)\\n        The number of samples to generate as input.\\n\\n    classes : array-like of ints (1d or 0d)\\n        The number of classes in the input.\\n\\n    density : array-like of ints (1d or 0d)\\n        The density of positive labels in the input.\\n\\n    n_times : int\\n        Time calling the metric n_times times.\\n\\n    Returns\\n    -------\\n    array of floats shaped like (metrics, formats, samples, classes, density)\\n        Time in seconds.\\n    '\n    metrics = np.atleast_1d(metrics)\n    samples = np.atleast_1d(samples)\n    classes = np.atleast_1d(classes)\n    density = np.atleast_1d(density)\n    formats = np.atleast_1d(formats)\n    out = np.zeros((len(metrics), len(formats), len(samples), len(classes), len(density)), dtype=float)\n    it = itertools.product(samples, classes, density)\n    for (i, (s, c, d)) in enumerate(it):\n        (_, y_true) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=42)\n        (_, y_pred) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=84)\n        for (j, f) in enumerate(formats):\n            f_true = f(y_true)\n            f_pred = f(y_pred)\n            for (k, metric) in enumerate(metrics):\n                t = timeit(partial(metric, f_true, f_pred), number=n_times)\n                out[k, j].flat[i] = t\n    return out",
            "@ignore_warnings\ndef benchmark(metrics=tuple((v for (k, v) in sorted(METRICS.items()))), formats=tuple((v for (k, v) in sorted(FORMATS.items()))), samples=1000, classes=4, density=0.2, n_times=5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Times metric calculations for a number of inputs\\n\\n    Parameters\\n    ----------\\n    metrics : array-like of callables (1d or 0d)\\n        The metric functions to time.\\n\\n    formats : array-like of callables (1d or 0d)\\n        These may transform a dense indicator matrix into multilabel\\n        representation.\\n\\n    samples : array-like of ints (1d or 0d)\\n        The number of samples to generate as input.\\n\\n    classes : array-like of ints (1d or 0d)\\n        The number of classes in the input.\\n\\n    density : array-like of ints (1d or 0d)\\n        The density of positive labels in the input.\\n\\n    n_times : int\\n        Time calling the metric n_times times.\\n\\n    Returns\\n    -------\\n    array of floats shaped like (metrics, formats, samples, classes, density)\\n        Time in seconds.\\n    '\n    metrics = np.atleast_1d(metrics)\n    samples = np.atleast_1d(samples)\n    classes = np.atleast_1d(classes)\n    density = np.atleast_1d(density)\n    formats = np.atleast_1d(formats)\n    out = np.zeros((len(metrics), len(formats), len(samples), len(classes), len(density)), dtype=float)\n    it = itertools.product(samples, classes, density)\n    for (i, (s, c, d)) in enumerate(it):\n        (_, y_true) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=42)\n        (_, y_pred) = make_multilabel_classification(n_samples=s, n_features=1, n_classes=c, n_labels=d * c, random_state=84)\n        for (j, f) in enumerate(formats):\n            f_true = f(y_true)\n            f_pred = f(y_pred)\n            for (k, metric) in enumerate(metrics):\n                t = timeit(partial(metric, f_true, f_pred), number=n_times)\n                out[k, j].flat[i] = t\n    return out"
        ]
    },
    {
        "func_name": "_tabulate",
        "original": "def _tabulate(results, metrics, formats):\n    \"\"\"Prints results by metric and format\n\n    Uses the last ([-1]) value of other fields\n    \"\"\"\n    column_width = max(max((len(k) for k in formats)) + 1, 8)\n    first_width = max((len(k) for k in metrics))\n    head_fmt = '{:<{fw}s}' + '{:>{cw}s}' * len(formats)\n    row_fmt = '{:<{fw}s}' + '{:>{cw}.3f}' * len(formats)\n    print(head_fmt.format('Metric', *formats, cw=column_width, fw=first_width))\n    for (metric, row) in zip(metrics, results[:, :, -1, -1, -1]):\n        print(row_fmt.format(metric, *row, cw=column_width, fw=first_width))",
        "mutated": [
            "def _tabulate(results, metrics, formats):\n    if False:\n        i = 10\n    'Prints results by metric and format\\n\\n    Uses the last ([-1]) value of other fields\\n    '\n    column_width = max(max((len(k) for k in formats)) + 1, 8)\n    first_width = max((len(k) for k in metrics))\n    head_fmt = '{:<{fw}s}' + '{:>{cw}s}' * len(formats)\n    row_fmt = '{:<{fw}s}' + '{:>{cw}.3f}' * len(formats)\n    print(head_fmt.format('Metric', *formats, cw=column_width, fw=first_width))\n    for (metric, row) in zip(metrics, results[:, :, -1, -1, -1]):\n        print(row_fmt.format(metric, *row, cw=column_width, fw=first_width))",
            "def _tabulate(results, metrics, formats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Prints results by metric and format\\n\\n    Uses the last ([-1]) value of other fields\\n    '\n    column_width = max(max((len(k) for k in formats)) + 1, 8)\n    first_width = max((len(k) for k in metrics))\n    head_fmt = '{:<{fw}s}' + '{:>{cw}s}' * len(formats)\n    row_fmt = '{:<{fw}s}' + '{:>{cw}.3f}' * len(formats)\n    print(head_fmt.format('Metric', *formats, cw=column_width, fw=first_width))\n    for (metric, row) in zip(metrics, results[:, :, -1, -1, -1]):\n        print(row_fmt.format(metric, *row, cw=column_width, fw=first_width))",
            "def _tabulate(results, metrics, formats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Prints results by metric and format\\n\\n    Uses the last ([-1]) value of other fields\\n    '\n    column_width = max(max((len(k) for k in formats)) + 1, 8)\n    first_width = max((len(k) for k in metrics))\n    head_fmt = '{:<{fw}s}' + '{:>{cw}s}' * len(formats)\n    row_fmt = '{:<{fw}s}' + '{:>{cw}.3f}' * len(formats)\n    print(head_fmt.format('Metric', *formats, cw=column_width, fw=first_width))\n    for (metric, row) in zip(metrics, results[:, :, -1, -1, -1]):\n        print(row_fmt.format(metric, *row, cw=column_width, fw=first_width))",
            "def _tabulate(results, metrics, formats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Prints results by metric and format\\n\\n    Uses the last ([-1]) value of other fields\\n    '\n    column_width = max(max((len(k) for k in formats)) + 1, 8)\n    first_width = max((len(k) for k in metrics))\n    head_fmt = '{:<{fw}s}' + '{:>{cw}s}' * len(formats)\n    row_fmt = '{:<{fw}s}' + '{:>{cw}.3f}' * len(formats)\n    print(head_fmt.format('Metric', *formats, cw=column_width, fw=first_width))\n    for (metric, row) in zip(metrics, results[:, :, -1, -1, -1]):\n        print(row_fmt.format(metric, *row, cw=column_width, fw=first_width))",
            "def _tabulate(results, metrics, formats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Prints results by metric and format\\n\\n    Uses the last ([-1]) value of other fields\\n    '\n    column_width = max(max((len(k) for k in formats)) + 1, 8)\n    first_width = max((len(k) for k in metrics))\n    head_fmt = '{:<{fw}s}' + '{:>{cw}s}' * len(formats)\n    row_fmt = '{:<{fw}s}' + '{:>{cw}.3f}' * len(formats)\n    print(head_fmt.format('Metric', *formats, cw=column_width, fw=first_width))\n    for (metric, row) in zip(metrics, results[:, :, -1, -1, -1]):\n        print(row_fmt.format(metric, *row, cw=column_width, fw=first_width))"
        ]
    },
    {
        "func_name": "_plot",
        "original": "def _plot(results, metrics, formats, title, x_ticks, x_label, format_markers=('x', '|', 'o', '+'), metric_colors=('c', 'm', 'y', 'k', 'g', 'r', 'b')):\n    \"\"\"\n    Plot the results by metric, format and some other variable given by\n    x_label\n    \"\"\"\n    fig = plt.figure('scikit-learn multilabel metrics benchmarks')\n    plt.title(title)\n    ax = fig.add_subplot(111)\n    for (i, metric) in enumerate(metrics):\n        for (j, format) in enumerate(formats):\n            ax.plot(x_ticks, results[i, j].flat, label='{}, {}'.format(metric, format), marker=format_markers[j], color=metric_colors[i % len(metric_colors)])\n    ax.set_xlabel(x_label)\n    ax.set_ylabel('Time (s)')\n    ax.legend()\n    plt.show()",
        "mutated": [
            "def _plot(results, metrics, formats, title, x_ticks, x_label, format_markers=('x', '|', 'o', '+'), metric_colors=('c', 'm', 'y', 'k', 'g', 'r', 'b')):\n    if False:\n        i = 10\n    '\\n    Plot the results by metric, format and some other variable given by\\n    x_label\\n    '\n    fig = plt.figure('scikit-learn multilabel metrics benchmarks')\n    plt.title(title)\n    ax = fig.add_subplot(111)\n    for (i, metric) in enumerate(metrics):\n        for (j, format) in enumerate(formats):\n            ax.plot(x_ticks, results[i, j].flat, label='{}, {}'.format(metric, format), marker=format_markers[j], color=metric_colors[i % len(metric_colors)])\n    ax.set_xlabel(x_label)\n    ax.set_ylabel('Time (s)')\n    ax.legend()\n    plt.show()",
            "def _plot(results, metrics, formats, title, x_ticks, x_label, format_markers=('x', '|', 'o', '+'), metric_colors=('c', 'm', 'y', 'k', 'g', 'r', 'b')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Plot the results by metric, format and some other variable given by\\n    x_label\\n    '\n    fig = plt.figure('scikit-learn multilabel metrics benchmarks')\n    plt.title(title)\n    ax = fig.add_subplot(111)\n    for (i, metric) in enumerate(metrics):\n        for (j, format) in enumerate(formats):\n            ax.plot(x_ticks, results[i, j].flat, label='{}, {}'.format(metric, format), marker=format_markers[j], color=metric_colors[i % len(metric_colors)])\n    ax.set_xlabel(x_label)\n    ax.set_ylabel('Time (s)')\n    ax.legend()\n    plt.show()",
            "def _plot(results, metrics, formats, title, x_ticks, x_label, format_markers=('x', '|', 'o', '+'), metric_colors=('c', 'm', 'y', 'k', 'g', 'r', 'b')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Plot the results by metric, format and some other variable given by\\n    x_label\\n    '\n    fig = plt.figure('scikit-learn multilabel metrics benchmarks')\n    plt.title(title)\n    ax = fig.add_subplot(111)\n    for (i, metric) in enumerate(metrics):\n        for (j, format) in enumerate(formats):\n            ax.plot(x_ticks, results[i, j].flat, label='{}, {}'.format(metric, format), marker=format_markers[j], color=metric_colors[i % len(metric_colors)])\n    ax.set_xlabel(x_label)\n    ax.set_ylabel('Time (s)')\n    ax.legend()\n    plt.show()",
            "def _plot(results, metrics, formats, title, x_ticks, x_label, format_markers=('x', '|', 'o', '+'), metric_colors=('c', 'm', 'y', 'k', 'g', 'r', 'b')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Plot the results by metric, format and some other variable given by\\n    x_label\\n    '\n    fig = plt.figure('scikit-learn multilabel metrics benchmarks')\n    plt.title(title)\n    ax = fig.add_subplot(111)\n    for (i, metric) in enumerate(metrics):\n        for (j, format) in enumerate(formats):\n            ax.plot(x_ticks, results[i, j].flat, label='{}, {}'.format(metric, format), marker=format_markers[j], color=metric_colors[i % len(metric_colors)])\n    ax.set_xlabel(x_label)\n    ax.set_ylabel('Time (s)')\n    ax.legend()\n    plt.show()",
            "def _plot(results, metrics, formats, title, x_ticks, x_label, format_markers=('x', '|', 'o', '+'), metric_colors=('c', 'm', 'y', 'k', 'g', 'r', 'b')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Plot the results by metric, format and some other variable given by\\n    x_label\\n    '\n    fig = plt.figure('scikit-learn multilabel metrics benchmarks')\n    plt.title(title)\n    ax = fig.add_subplot(111)\n    for (i, metric) in enumerate(metrics):\n        for (j, format) in enumerate(formats):\n            ax.plot(x_ticks, results[i, j].flat, label='{}, {}'.format(metric, format), marker=format_markers[j], color=metric_colors[i % len(metric_colors)])\n    ax.set_xlabel(x_label)\n    ax.set_ylabel('Time (s)')\n    ax.legend()\n    plt.show()"
        ]
    }
]