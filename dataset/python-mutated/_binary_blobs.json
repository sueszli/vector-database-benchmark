[
    {
        "func_name": "binary_blobs",
        "original": "@deprecate_kwarg({'seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef binary_blobs(length=512, blob_size_fraction=0.1, n_dim=2, volume_fraction=0.5, rng=None):\n    \"\"\"\n    Generate synthetic binary image with several rounded blob-like objects.\n\n    Parameters\n    ----------\n    length : int, optional\n        Linear size of output image.\n    blob_size_fraction : float, optional\n        Typical linear size of blob, as a fraction of ``length``, should be\n        smaller than 1.\n    n_dim : int, optional\n        Number of dimensions of output image.\n    volume_fraction : float, default 0.5\n        Fraction of image pixels covered by the blobs (where the output is 1).\n        Should be in [0, 1].\n    rng : {`numpy.random.Generator`, int}, optional\n        Pseudo-random number generator.\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\n        If `rng` is an int, it is used to seed the generator.\n\n    Returns\n    -------\n    blobs : ndarray of bools\n        Output binary image\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> data.binary_blobs(length=5, blob_size_fraction=0.2)  # doctest: +SKIP\n    array([[ True, False,  True,  True,  True],\n           [ True,  True,  True, False,  True],\n           [False,  True, False,  True,  True],\n           [ True, False, False,  True,  True],\n           [ True, False, False, False,  True]])\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.1)\n    >>> # Finer structures\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.05)\n    >>> # Blobs cover a smaller volume fraction of the image\n    >>> blobs = data.binary_blobs(length=256, volume_fraction=0.3)\n\n    \"\"\"\n    rs = np.random.default_rng(rng)\n    shape = tuple([length] * n_dim)\n    mask = np.zeros(shape)\n    n_pts = max(int(1.0 / blob_size_fraction) ** n_dim, 1)\n    points = (length * rs.random((n_dim, n_pts))).astype(int)\n    mask[tuple((indices for indices in points))] = 1\n    mask = gaussian(mask, sigma=0.25 * length * blob_size_fraction, preserve_range=False)\n    threshold = np.percentile(mask, 100 * (1 - volume_fraction))\n    return np.logical_not(mask < threshold)",
        "mutated": [
            "@deprecate_kwarg({'seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef binary_blobs(length=512, blob_size_fraction=0.1, n_dim=2, volume_fraction=0.5, rng=None):\n    if False:\n        i = 10\n    '\\n    Generate synthetic binary image with several rounded blob-like objects.\\n\\n    Parameters\\n    ----------\\n    length : int, optional\\n        Linear size of output image.\\n    blob_size_fraction : float, optional\\n        Typical linear size of blob, as a fraction of ``length``, should be\\n        smaller than 1.\\n    n_dim : int, optional\\n        Number of dimensions of output image.\\n    volume_fraction : float, default 0.5\\n        Fraction of image pixels covered by the blobs (where the output is 1).\\n        Should be in [0, 1].\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n    Returns\\n    -------\\n    blobs : ndarray of bools\\n        Output binary image\\n\\n    Examples\\n    --------\\n    >>> from skimage import data\\n    >>> data.binary_blobs(length=5, blob_size_fraction=0.2)  # doctest: +SKIP\\n    array([[ True, False,  True,  True,  True],\\n           [ True,  True,  True, False,  True],\\n           [False,  True, False,  True,  True],\\n           [ True, False, False,  True,  True],\\n           [ True, False, False, False,  True]])\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.1)\\n    >>> # Finer structures\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.05)\\n    >>> # Blobs cover a smaller volume fraction of the image\\n    >>> blobs = data.binary_blobs(length=256, volume_fraction=0.3)\\n\\n    '\n    rs = np.random.default_rng(rng)\n    shape = tuple([length] * n_dim)\n    mask = np.zeros(shape)\n    n_pts = max(int(1.0 / blob_size_fraction) ** n_dim, 1)\n    points = (length * rs.random((n_dim, n_pts))).astype(int)\n    mask[tuple((indices for indices in points))] = 1\n    mask = gaussian(mask, sigma=0.25 * length * blob_size_fraction, preserve_range=False)\n    threshold = np.percentile(mask, 100 * (1 - volume_fraction))\n    return np.logical_not(mask < threshold)",
            "@deprecate_kwarg({'seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef binary_blobs(length=512, blob_size_fraction=0.1, n_dim=2, volume_fraction=0.5, rng=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate synthetic binary image with several rounded blob-like objects.\\n\\n    Parameters\\n    ----------\\n    length : int, optional\\n        Linear size of output image.\\n    blob_size_fraction : float, optional\\n        Typical linear size of blob, as a fraction of ``length``, should be\\n        smaller than 1.\\n    n_dim : int, optional\\n        Number of dimensions of output image.\\n    volume_fraction : float, default 0.5\\n        Fraction of image pixels covered by the blobs (where the output is 1).\\n        Should be in [0, 1].\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n    Returns\\n    -------\\n    blobs : ndarray of bools\\n        Output binary image\\n\\n    Examples\\n    --------\\n    >>> from skimage import data\\n    >>> data.binary_blobs(length=5, blob_size_fraction=0.2)  # doctest: +SKIP\\n    array([[ True, False,  True,  True,  True],\\n           [ True,  True,  True, False,  True],\\n           [False,  True, False,  True,  True],\\n           [ True, False, False,  True,  True],\\n           [ True, False, False, False,  True]])\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.1)\\n    >>> # Finer structures\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.05)\\n    >>> # Blobs cover a smaller volume fraction of the image\\n    >>> blobs = data.binary_blobs(length=256, volume_fraction=0.3)\\n\\n    '\n    rs = np.random.default_rng(rng)\n    shape = tuple([length] * n_dim)\n    mask = np.zeros(shape)\n    n_pts = max(int(1.0 / blob_size_fraction) ** n_dim, 1)\n    points = (length * rs.random((n_dim, n_pts))).astype(int)\n    mask[tuple((indices for indices in points))] = 1\n    mask = gaussian(mask, sigma=0.25 * length * blob_size_fraction, preserve_range=False)\n    threshold = np.percentile(mask, 100 * (1 - volume_fraction))\n    return np.logical_not(mask < threshold)",
            "@deprecate_kwarg({'seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef binary_blobs(length=512, blob_size_fraction=0.1, n_dim=2, volume_fraction=0.5, rng=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate synthetic binary image with several rounded blob-like objects.\\n\\n    Parameters\\n    ----------\\n    length : int, optional\\n        Linear size of output image.\\n    blob_size_fraction : float, optional\\n        Typical linear size of blob, as a fraction of ``length``, should be\\n        smaller than 1.\\n    n_dim : int, optional\\n        Number of dimensions of output image.\\n    volume_fraction : float, default 0.5\\n        Fraction of image pixels covered by the blobs (where the output is 1).\\n        Should be in [0, 1].\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n    Returns\\n    -------\\n    blobs : ndarray of bools\\n        Output binary image\\n\\n    Examples\\n    --------\\n    >>> from skimage import data\\n    >>> data.binary_blobs(length=5, blob_size_fraction=0.2)  # doctest: +SKIP\\n    array([[ True, False,  True,  True,  True],\\n           [ True,  True,  True, False,  True],\\n           [False,  True, False,  True,  True],\\n           [ True, False, False,  True,  True],\\n           [ True, False, False, False,  True]])\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.1)\\n    >>> # Finer structures\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.05)\\n    >>> # Blobs cover a smaller volume fraction of the image\\n    >>> blobs = data.binary_blobs(length=256, volume_fraction=0.3)\\n\\n    '\n    rs = np.random.default_rng(rng)\n    shape = tuple([length] * n_dim)\n    mask = np.zeros(shape)\n    n_pts = max(int(1.0 / blob_size_fraction) ** n_dim, 1)\n    points = (length * rs.random((n_dim, n_pts))).astype(int)\n    mask[tuple((indices for indices in points))] = 1\n    mask = gaussian(mask, sigma=0.25 * length * blob_size_fraction, preserve_range=False)\n    threshold = np.percentile(mask, 100 * (1 - volume_fraction))\n    return np.logical_not(mask < threshold)",
            "@deprecate_kwarg({'seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef binary_blobs(length=512, blob_size_fraction=0.1, n_dim=2, volume_fraction=0.5, rng=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate synthetic binary image with several rounded blob-like objects.\\n\\n    Parameters\\n    ----------\\n    length : int, optional\\n        Linear size of output image.\\n    blob_size_fraction : float, optional\\n        Typical linear size of blob, as a fraction of ``length``, should be\\n        smaller than 1.\\n    n_dim : int, optional\\n        Number of dimensions of output image.\\n    volume_fraction : float, default 0.5\\n        Fraction of image pixels covered by the blobs (where the output is 1).\\n        Should be in [0, 1].\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n    Returns\\n    -------\\n    blobs : ndarray of bools\\n        Output binary image\\n\\n    Examples\\n    --------\\n    >>> from skimage import data\\n    >>> data.binary_blobs(length=5, blob_size_fraction=0.2)  # doctest: +SKIP\\n    array([[ True, False,  True,  True,  True],\\n           [ True,  True,  True, False,  True],\\n           [False,  True, False,  True,  True],\\n           [ True, False, False,  True,  True],\\n           [ True, False, False, False,  True]])\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.1)\\n    >>> # Finer structures\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.05)\\n    >>> # Blobs cover a smaller volume fraction of the image\\n    >>> blobs = data.binary_blobs(length=256, volume_fraction=0.3)\\n\\n    '\n    rs = np.random.default_rng(rng)\n    shape = tuple([length] * n_dim)\n    mask = np.zeros(shape)\n    n_pts = max(int(1.0 / blob_size_fraction) ** n_dim, 1)\n    points = (length * rs.random((n_dim, n_pts))).astype(int)\n    mask[tuple((indices for indices in points))] = 1\n    mask = gaussian(mask, sigma=0.25 * length * blob_size_fraction, preserve_range=False)\n    threshold = np.percentile(mask, 100 * (1 - volume_fraction))\n    return np.logical_not(mask < threshold)",
            "@deprecate_kwarg({'seed': 'rng'}, deprecated_version='0.21', removed_version='0.23')\ndef binary_blobs(length=512, blob_size_fraction=0.1, n_dim=2, volume_fraction=0.5, rng=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate synthetic binary image with several rounded blob-like objects.\\n\\n    Parameters\\n    ----------\\n    length : int, optional\\n        Linear size of output image.\\n    blob_size_fraction : float, optional\\n        Typical linear size of blob, as a fraction of ``length``, should be\\n        smaller than 1.\\n    n_dim : int, optional\\n        Number of dimensions of output image.\\n    volume_fraction : float, default 0.5\\n        Fraction of image pixels covered by the blobs (where the output is 1).\\n        Should be in [0, 1].\\n    rng : {`numpy.random.Generator`, int}, optional\\n        Pseudo-random number generator.\\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\\n        If `rng` is an int, it is used to seed the generator.\\n\\n    Returns\\n    -------\\n    blobs : ndarray of bools\\n        Output binary image\\n\\n    Examples\\n    --------\\n    >>> from skimage import data\\n    >>> data.binary_blobs(length=5, blob_size_fraction=0.2)  # doctest: +SKIP\\n    array([[ True, False,  True,  True,  True],\\n           [ True,  True,  True, False,  True],\\n           [False,  True, False,  True,  True],\\n           [ True, False, False,  True,  True],\\n           [ True, False, False, False,  True]])\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.1)\\n    >>> # Finer structures\\n    >>> blobs = data.binary_blobs(length=256, blob_size_fraction=0.05)\\n    >>> # Blobs cover a smaller volume fraction of the image\\n    >>> blobs = data.binary_blobs(length=256, volume_fraction=0.3)\\n\\n    '\n    rs = np.random.default_rng(rng)\n    shape = tuple([length] * n_dim)\n    mask = np.zeros(shape)\n    n_pts = max(int(1.0 / blob_size_fraction) ** n_dim, 1)\n    points = (length * rs.random((n_dim, n_pts))).astype(int)\n    mask[tuple((indices for indices in points))] = 1\n    mask = gaussian(mask, sigma=0.25 * length * blob_size_fraction, preserve_range=False)\n    threshold = np.percentile(mask, 100 * (1 - volume_fraction))\n    return np.logical_not(mask < threshold)"
        ]
    }
]