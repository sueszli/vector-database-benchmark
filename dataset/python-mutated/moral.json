[
    {
        "func_name": "moral_graph",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch\ndef moral_graph(G):\n    \"\"\"Return the Moral Graph\n\n    Returns the moralized graph of a given directed graph.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Directed graph\n\n    Returns\n    -------\n    H : NetworkX graph\n        The undirected moralized graph of G\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If `G` is undirected.\n\n    Examples\n    --------\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (2, 5), (3, 4), (4, 3)])\n    >>> G_moral = nx.moral_graph(G)\n    >>> G_moral.edges()\n    EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])\n\n    Notes\n    -----\n    A moral graph is an undirected graph H = (V, E) generated from a\n    directed Graph, where if a node has more than one parent node, edges\n    between these parent nodes are inserted and all directed edges become\n    undirected.\n\n    https://en.wikipedia.org/wiki/Moral_graph\n\n    References\n    ----------\n    .. [1] Wray L. Buntine. 1995. Chain graphs for learning.\n           In Proceedings of the Eleventh conference on Uncertainty\n           in artificial intelligence (UAI'95)\n    \"\"\"\n    H = G.to_undirected()\n    for preds in G.pred.values():\n        predecessors_combinations = itertools.combinations(preds, r=2)\n        H.add_edges_from(predecessors_combinations)\n    return H",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef moral_graph(G):\n    if False:\n        i = 10\n    \"Return the Moral Graph\\n\\n    Returns the moralized graph of a given directed graph.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Directed graph\\n\\n    Returns\\n    -------\\n    H : NetworkX graph\\n        The undirected moralized graph of G\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If `G` is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (2, 5), (3, 4), (4, 3)])\\n    >>> G_moral = nx.moral_graph(G)\\n    >>> G_moral.edges()\\n    EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])\\n\\n    Notes\\n    -----\\n    A moral graph is an undirected graph H = (V, E) generated from a\\n    directed Graph, where if a node has more than one parent node, edges\\n    between these parent nodes are inserted and all directed edges become\\n    undirected.\\n\\n    https://en.wikipedia.org/wiki/Moral_graph\\n\\n    References\\n    ----------\\n    .. [1] Wray L. Buntine. 1995. Chain graphs for learning.\\n           In Proceedings of the Eleventh conference on Uncertainty\\n           in artificial intelligence (UAI'95)\\n    \"\n    H = G.to_undirected()\n    for preds in G.pred.values():\n        predecessors_combinations = itertools.combinations(preds, r=2)\n        H.add_edges_from(predecessors_combinations)\n    return H",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef moral_graph(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return the Moral Graph\\n\\n    Returns the moralized graph of a given directed graph.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Directed graph\\n\\n    Returns\\n    -------\\n    H : NetworkX graph\\n        The undirected moralized graph of G\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If `G` is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (2, 5), (3, 4), (4, 3)])\\n    >>> G_moral = nx.moral_graph(G)\\n    >>> G_moral.edges()\\n    EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])\\n\\n    Notes\\n    -----\\n    A moral graph is an undirected graph H = (V, E) generated from a\\n    directed Graph, where if a node has more than one parent node, edges\\n    between these parent nodes are inserted and all directed edges become\\n    undirected.\\n\\n    https://en.wikipedia.org/wiki/Moral_graph\\n\\n    References\\n    ----------\\n    .. [1] Wray L. Buntine. 1995. Chain graphs for learning.\\n           In Proceedings of the Eleventh conference on Uncertainty\\n           in artificial intelligence (UAI'95)\\n    \"\n    H = G.to_undirected()\n    for preds in G.pred.values():\n        predecessors_combinations = itertools.combinations(preds, r=2)\n        H.add_edges_from(predecessors_combinations)\n    return H",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef moral_graph(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return the Moral Graph\\n\\n    Returns the moralized graph of a given directed graph.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Directed graph\\n\\n    Returns\\n    -------\\n    H : NetworkX graph\\n        The undirected moralized graph of G\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If `G` is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (2, 5), (3, 4), (4, 3)])\\n    >>> G_moral = nx.moral_graph(G)\\n    >>> G_moral.edges()\\n    EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])\\n\\n    Notes\\n    -----\\n    A moral graph is an undirected graph H = (V, E) generated from a\\n    directed Graph, where if a node has more than one parent node, edges\\n    between these parent nodes are inserted and all directed edges become\\n    undirected.\\n\\n    https://en.wikipedia.org/wiki/Moral_graph\\n\\n    References\\n    ----------\\n    .. [1] Wray L. Buntine. 1995. Chain graphs for learning.\\n           In Proceedings of the Eleventh conference on Uncertainty\\n           in artificial intelligence (UAI'95)\\n    \"\n    H = G.to_undirected()\n    for preds in G.pred.values():\n        predecessors_combinations = itertools.combinations(preds, r=2)\n        H.add_edges_from(predecessors_combinations)\n    return H",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef moral_graph(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return the Moral Graph\\n\\n    Returns the moralized graph of a given directed graph.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Directed graph\\n\\n    Returns\\n    -------\\n    H : NetworkX graph\\n        The undirected moralized graph of G\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If `G` is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (2, 5), (3, 4), (4, 3)])\\n    >>> G_moral = nx.moral_graph(G)\\n    >>> G_moral.edges()\\n    EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])\\n\\n    Notes\\n    -----\\n    A moral graph is an undirected graph H = (V, E) generated from a\\n    directed Graph, where if a node has more than one parent node, edges\\n    between these parent nodes are inserted and all directed edges become\\n    undirected.\\n\\n    https://en.wikipedia.org/wiki/Moral_graph\\n\\n    References\\n    ----------\\n    .. [1] Wray L. Buntine. 1995. Chain graphs for learning.\\n           In Proceedings of the Eleventh conference on Uncertainty\\n           in artificial intelligence (UAI'95)\\n    \"\n    H = G.to_undirected()\n    for preds in G.pred.values():\n        predecessors_combinations = itertools.combinations(preds, r=2)\n        H.add_edges_from(predecessors_combinations)\n    return H",
            "@not_implemented_for('undirected')\n@nx._dispatch\ndef moral_graph(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return the Moral Graph\\n\\n    Returns the moralized graph of a given directed graph.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Directed graph\\n\\n    Returns\\n    -------\\n    H : NetworkX graph\\n        The undirected moralized graph of G\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If `G` is undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (2, 5), (3, 4), (4, 3)])\\n    >>> G_moral = nx.moral_graph(G)\\n    >>> G_moral.edges()\\n    EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])\\n\\n    Notes\\n    -----\\n    A moral graph is an undirected graph H = (V, E) generated from a\\n    directed Graph, where if a node has more than one parent node, edges\\n    between these parent nodes are inserted and all directed edges become\\n    undirected.\\n\\n    https://en.wikipedia.org/wiki/Moral_graph\\n\\n    References\\n    ----------\\n    .. [1] Wray L. Buntine. 1995. Chain graphs for learning.\\n           In Proceedings of the Eleventh conference on Uncertainty\\n           in artificial intelligence (UAI'95)\\n    \"\n    H = G.to_undirected()\n    for preds in G.pred.values():\n        predecessors_combinations = itertools.combinations(preds, r=2)\n        H.add_edges_from(predecessors_combinations)\n    return H"
        ]
    }
]