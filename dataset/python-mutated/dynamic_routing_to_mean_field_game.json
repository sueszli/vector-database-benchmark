[
    {
        "func_name": "_create_empty_mfg_state",
        "original": "def _create_empty_mfg_state(game: dynamic_routing.DynamicRoutingGame):\n    \"\"\"Create an empty MFG state for the N player routing game.\n\n  Args:\n    game: the N player game.\n\n  Returns:\n    new_mfg_state: an empty MFG state corresponding to the N player game.\n  \"\"\"\n    od_demand_dict = {}\n    for vehicle in game._vehicles:\n        key = (vehicle.origin, vehicle.destination, vehicle.departure_time)\n        if key not in od_demand_dict:\n            od_demand_dict[key] = 0\n        od_demand_dict[key] += 1\n    od_demand = []\n    for ((origin, destination, departure_time), counts) in od_demand_dict.items():\n        od_demand.append(dynamic_routing_utils.OriginDestinationDemand(origin, destination, departure_time, counts))\n    return mean_field_routing_game.MeanFieldRoutingGame({'max_num_time_step': game.max_game_length(), 'time_step_length': game.time_step_length}, network=game.network, od_demand=od_demand, perform_sanity_checks=game.perform_sanity_checks).new_initial_state()",
        "mutated": [
            "def _create_empty_mfg_state(game: dynamic_routing.DynamicRoutingGame):\n    if False:\n        i = 10\n    'Create an empty MFG state for the N player routing game.\\n\\n  Args:\\n    game: the N player game.\\n\\n  Returns:\\n    new_mfg_state: an empty MFG state corresponding to the N player game.\\n  '\n    od_demand_dict = {}\n    for vehicle in game._vehicles:\n        key = (vehicle.origin, vehicle.destination, vehicle.departure_time)\n        if key not in od_demand_dict:\n            od_demand_dict[key] = 0\n        od_demand_dict[key] += 1\n    od_demand = []\n    for ((origin, destination, departure_time), counts) in od_demand_dict.items():\n        od_demand.append(dynamic_routing_utils.OriginDestinationDemand(origin, destination, departure_time, counts))\n    return mean_field_routing_game.MeanFieldRoutingGame({'max_num_time_step': game.max_game_length(), 'time_step_length': game.time_step_length}, network=game.network, od_demand=od_demand, perform_sanity_checks=game.perform_sanity_checks).new_initial_state()",
            "def _create_empty_mfg_state(game: dynamic_routing.DynamicRoutingGame):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create an empty MFG state for the N player routing game.\\n\\n  Args:\\n    game: the N player game.\\n\\n  Returns:\\n    new_mfg_state: an empty MFG state corresponding to the N player game.\\n  '\n    od_demand_dict = {}\n    for vehicle in game._vehicles:\n        key = (vehicle.origin, vehicle.destination, vehicle.departure_time)\n        if key not in od_demand_dict:\n            od_demand_dict[key] = 0\n        od_demand_dict[key] += 1\n    od_demand = []\n    for ((origin, destination, departure_time), counts) in od_demand_dict.items():\n        od_demand.append(dynamic_routing_utils.OriginDestinationDemand(origin, destination, departure_time, counts))\n    return mean_field_routing_game.MeanFieldRoutingGame({'max_num_time_step': game.max_game_length(), 'time_step_length': game.time_step_length}, network=game.network, od_demand=od_demand, perform_sanity_checks=game.perform_sanity_checks).new_initial_state()",
            "def _create_empty_mfg_state(game: dynamic_routing.DynamicRoutingGame):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create an empty MFG state for the N player routing game.\\n\\n  Args:\\n    game: the N player game.\\n\\n  Returns:\\n    new_mfg_state: an empty MFG state corresponding to the N player game.\\n  '\n    od_demand_dict = {}\n    for vehicle in game._vehicles:\n        key = (vehicle.origin, vehicle.destination, vehicle.departure_time)\n        if key not in od_demand_dict:\n            od_demand_dict[key] = 0\n        od_demand_dict[key] += 1\n    od_demand = []\n    for ((origin, destination, departure_time), counts) in od_demand_dict.items():\n        od_demand.append(dynamic_routing_utils.OriginDestinationDemand(origin, destination, departure_time, counts))\n    return mean_field_routing_game.MeanFieldRoutingGame({'max_num_time_step': game.max_game_length(), 'time_step_length': game.time_step_length}, network=game.network, od_demand=od_demand, perform_sanity_checks=game.perform_sanity_checks).new_initial_state()",
            "def _create_empty_mfg_state(game: dynamic_routing.DynamicRoutingGame):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create an empty MFG state for the N player routing game.\\n\\n  Args:\\n    game: the N player game.\\n\\n  Returns:\\n    new_mfg_state: an empty MFG state corresponding to the N player game.\\n  '\n    od_demand_dict = {}\n    for vehicle in game._vehicles:\n        key = (vehicle.origin, vehicle.destination, vehicle.departure_time)\n        if key not in od_demand_dict:\n            od_demand_dict[key] = 0\n        od_demand_dict[key] += 1\n    od_demand = []\n    for ((origin, destination, departure_time), counts) in od_demand_dict.items():\n        od_demand.append(dynamic_routing_utils.OriginDestinationDemand(origin, destination, departure_time, counts))\n    return mean_field_routing_game.MeanFieldRoutingGame({'max_num_time_step': game.max_game_length(), 'time_step_length': game.time_step_length}, network=game.network, od_demand=od_demand, perform_sanity_checks=game.perform_sanity_checks).new_initial_state()",
            "def _create_empty_mfg_state(game: dynamic_routing.DynamicRoutingGame):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create an empty MFG state for the N player routing game.\\n\\n  Args:\\n    game: the N player game.\\n\\n  Returns:\\n    new_mfg_state: an empty MFG state corresponding to the N player game.\\n  '\n    od_demand_dict = {}\n    for vehicle in game._vehicles:\n        key = (vehicle.origin, vehicle.destination, vehicle.departure_time)\n        if key not in od_demand_dict:\n            od_demand_dict[key] = 0\n        od_demand_dict[key] += 1\n    od_demand = []\n    for ((origin, destination, departure_time), counts) in od_demand_dict.items():\n        od_demand.append(dynamic_routing_utils.OriginDestinationDemand(origin, destination, departure_time, counts))\n    return mean_field_routing_game.MeanFieldRoutingGame({'max_num_time_step': game.max_game_length(), 'time_step_length': game.time_step_length}, network=game.network, od_demand=od_demand, perform_sanity_checks=game.perform_sanity_checks).new_initial_state()"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, game: dynamic_routing.DynamicRoutingGame, mfg_policy: policy.Policy):\n    \"\"\"Initializes a uniform random policy for all players in the game.\"\"\"\n    super().__init__(game, list(range(game.num_players())))\n    self._mfg_policy = mfg_policy\n    self._mfg_empty_state = _create_empty_mfg_state(game)\n    self._state_memoization = {}",
        "mutated": [
            "def __init__(self, game: dynamic_routing.DynamicRoutingGame, mfg_policy: policy.Policy):\n    if False:\n        i = 10\n    'Initializes a uniform random policy for all players in the game.'\n    super().__init__(game, list(range(game.num_players())))\n    self._mfg_policy = mfg_policy\n    self._mfg_empty_state = _create_empty_mfg_state(game)\n    self._state_memoization = {}",
            "def __init__(self, game: dynamic_routing.DynamicRoutingGame, mfg_policy: policy.Policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initializes a uniform random policy for all players in the game.'\n    super().__init__(game, list(range(game.num_players())))\n    self._mfg_policy = mfg_policy\n    self._mfg_empty_state = _create_empty_mfg_state(game)\n    self._state_memoization = {}",
            "def __init__(self, game: dynamic_routing.DynamicRoutingGame, mfg_policy: policy.Policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initializes a uniform random policy for all players in the game.'\n    super().__init__(game, list(range(game.num_players())))\n    self._mfg_policy = mfg_policy\n    self._mfg_empty_state = _create_empty_mfg_state(game)\n    self._state_memoization = {}",
            "def __init__(self, game: dynamic_routing.DynamicRoutingGame, mfg_policy: policy.Policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initializes a uniform random policy for all players in the game.'\n    super().__init__(game, list(range(game.num_players())))\n    self._mfg_policy = mfg_policy\n    self._mfg_empty_state = _create_empty_mfg_state(game)\n    self._state_memoization = {}",
            "def __init__(self, game: dynamic_routing.DynamicRoutingGame, mfg_policy: policy.Policy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initializes a uniform random policy for all players in the game.'\n    super().__init__(game, list(range(game.num_players())))\n    self._mfg_policy = mfg_policy\n    self._mfg_empty_state = _create_empty_mfg_state(game)\n    self._state_memoization = {}"
        ]
    },
    {
        "func_name": "_convert_state_to_mean_field_state",
        "original": "def _convert_state_to_mean_field_state(self, n_player_state: dynamic_routing.DynamicRoutingGameState, player_id: int) -> mean_field_routing_game.MeanFieldRoutingGameState:\n    \"\"\"Convert a N player state to a mean field state.\"\"\"\n    assert player_id >= 0, 'player_id should be a positive integer.'\n    state_key = (str(n_player_state), player_id)\n    mfg_state = self._state_memoization.get(state_key)\n    if mfg_state is not None:\n        return mfg_state\n    mfg_state = self._mfg_empty_state.clone()\n    mfg_state._is_chance_init = False\n    mfg_state._current_time_step = n_player_state._current_time_step\n    mfg_state._is_terminal = n_player_state._is_terminal\n    mfg_state._player_id = pyspiel.PlayerId.DEFAULT_PLAYER_ID\n    mfg_state._waiting_time = n_player_state._waiting_times[player_id]\n    mfg_state._vehicle_at_destination = player_id in n_player_state._vehicle_at_destination\n    mfg_state._vehicle_destination = n_player_state._vehicle_destinations[player_id]\n    mfg_state._vehicle_final_arrival_time = n_player_state._vehicle_final_arrival_times[player_id]\n    mfg_state._vehicle_location = n_player_state._vehicle_locations[player_id]\n    mfg_state._vehicle_without_legal_action = player_id in n_player_state._vehicle_without_legal_actions\n    self._state_memoization[state_key] = mfg_state\n    return mfg_state",
        "mutated": [
            "def _convert_state_to_mean_field_state(self, n_player_state: dynamic_routing.DynamicRoutingGameState, player_id: int) -> mean_field_routing_game.MeanFieldRoutingGameState:\n    if False:\n        i = 10\n    'Convert a N player state to a mean field state.'\n    assert player_id >= 0, 'player_id should be a positive integer.'\n    state_key = (str(n_player_state), player_id)\n    mfg_state = self._state_memoization.get(state_key)\n    if mfg_state is not None:\n        return mfg_state\n    mfg_state = self._mfg_empty_state.clone()\n    mfg_state._is_chance_init = False\n    mfg_state._current_time_step = n_player_state._current_time_step\n    mfg_state._is_terminal = n_player_state._is_terminal\n    mfg_state._player_id = pyspiel.PlayerId.DEFAULT_PLAYER_ID\n    mfg_state._waiting_time = n_player_state._waiting_times[player_id]\n    mfg_state._vehicle_at_destination = player_id in n_player_state._vehicle_at_destination\n    mfg_state._vehicle_destination = n_player_state._vehicle_destinations[player_id]\n    mfg_state._vehicle_final_arrival_time = n_player_state._vehicle_final_arrival_times[player_id]\n    mfg_state._vehicle_location = n_player_state._vehicle_locations[player_id]\n    mfg_state._vehicle_without_legal_action = player_id in n_player_state._vehicle_without_legal_actions\n    self._state_memoization[state_key] = mfg_state\n    return mfg_state",
            "def _convert_state_to_mean_field_state(self, n_player_state: dynamic_routing.DynamicRoutingGameState, player_id: int) -> mean_field_routing_game.MeanFieldRoutingGameState:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert a N player state to a mean field state.'\n    assert player_id >= 0, 'player_id should be a positive integer.'\n    state_key = (str(n_player_state), player_id)\n    mfg_state = self._state_memoization.get(state_key)\n    if mfg_state is not None:\n        return mfg_state\n    mfg_state = self._mfg_empty_state.clone()\n    mfg_state._is_chance_init = False\n    mfg_state._current_time_step = n_player_state._current_time_step\n    mfg_state._is_terminal = n_player_state._is_terminal\n    mfg_state._player_id = pyspiel.PlayerId.DEFAULT_PLAYER_ID\n    mfg_state._waiting_time = n_player_state._waiting_times[player_id]\n    mfg_state._vehicle_at_destination = player_id in n_player_state._vehicle_at_destination\n    mfg_state._vehicle_destination = n_player_state._vehicle_destinations[player_id]\n    mfg_state._vehicle_final_arrival_time = n_player_state._vehicle_final_arrival_times[player_id]\n    mfg_state._vehicle_location = n_player_state._vehicle_locations[player_id]\n    mfg_state._vehicle_without_legal_action = player_id in n_player_state._vehicle_without_legal_actions\n    self._state_memoization[state_key] = mfg_state\n    return mfg_state",
            "def _convert_state_to_mean_field_state(self, n_player_state: dynamic_routing.DynamicRoutingGameState, player_id: int) -> mean_field_routing_game.MeanFieldRoutingGameState:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert a N player state to a mean field state.'\n    assert player_id >= 0, 'player_id should be a positive integer.'\n    state_key = (str(n_player_state), player_id)\n    mfg_state = self._state_memoization.get(state_key)\n    if mfg_state is not None:\n        return mfg_state\n    mfg_state = self._mfg_empty_state.clone()\n    mfg_state._is_chance_init = False\n    mfg_state._current_time_step = n_player_state._current_time_step\n    mfg_state._is_terminal = n_player_state._is_terminal\n    mfg_state._player_id = pyspiel.PlayerId.DEFAULT_PLAYER_ID\n    mfg_state._waiting_time = n_player_state._waiting_times[player_id]\n    mfg_state._vehicle_at_destination = player_id in n_player_state._vehicle_at_destination\n    mfg_state._vehicle_destination = n_player_state._vehicle_destinations[player_id]\n    mfg_state._vehicle_final_arrival_time = n_player_state._vehicle_final_arrival_times[player_id]\n    mfg_state._vehicle_location = n_player_state._vehicle_locations[player_id]\n    mfg_state._vehicle_without_legal_action = player_id in n_player_state._vehicle_without_legal_actions\n    self._state_memoization[state_key] = mfg_state\n    return mfg_state",
            "def _convert_state_to_mean_field_state(self, n_player_state: dynamic_routing.DynamicRoutingGameState, player_id: int) -> mean_field_routing_game.MeanFieldRoutingGameState:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert a N player state to a mean field state.'\n    assert player_id >= 0, 'player_id should be a positive integer.'\n    state_key = (str(n_player_state), player_id)\n    mfg_state = self._state_memoization.get(state_key)\n    if mfg_state is not None:\n        return mfg_state\n    mfg_state = self._mfg_empty_state.clone()\n    mfg_state._is_chance_init = False\n    mfg_state._current_time_step = n_player_state._current_time_step\n    mfg_state._is_terminal = n_player_state._is_terminal\n    mfg_state._player_id = pyspiel.PlayerId.DEFAULT_PLAYER_ID\n    mfg_state._waiting_time = n_player_state._waiting_times[player_id]\n    mfg_state._vehicle_at_destination = player_id in n_player_state._vehicle_at_destination\n    mfg_state._vehicle_destination = n_player_state._vehicle_destinations[player_id]\n    mfg_state._vehicle_final_arrival_time = n_player_state._vehicle_final_arrival_times[player_id]\n    mfg_state._vehicle_location = n_player_state._vehicle_locations[player_id]\n    mfg_state._vehicle_without_legal_action = player_id in n_player_state._vehicle_without_legal_actions\n    self._state_memoization[state_key] = mfg_state\n    return mfg_state",
            "def _convert_state_to_mean_field_state(self, n_player_state: dynamic_routing.DynamicRoutingGameState, player_id: int) -> mean_field_routing_game.MeanFieldRoutingGameState:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert a N player state to a mean field state.'\n    assert player_id >= 0, 'player_id should be a positive integer.'\n    state_key = (str(n_player_state), player_id)\n    mfg_state = self._state_memoization.get(state_key)\n    if mfg_state is not None:\n        return mfg_state\n    mfg_state = self._mfg_empty_state.clone()\n    mfg_state._is_chance_init = False\n    mfg_state._current_time_step = n_player_state._current_time_step\n    mfg_state._is_terminal = n_player_state._is_terminal\n    mfg_state._player_id = pyspiel.PlayerId.DEFAULT_PLAYER_ID\n    mfg_state._waiting_time = n_player_state._waiting_times[player_id]\n    mfg_state._vehicle_at_destination = player_id in n_player_state._vehicle_at_destination\n    mfg_state._vehicle_destination = n_player_state._vehicle_destinations[player_id]\n    mfg_state._vehicle_final_arrival_time = n_player_state._vehicle_final_arrival_times[player_id]\n    mfg_state._vehicle_location = n_player_state._vehicle_locations[player_id]\n    mfg_state._vehicle_without_legal_action = player_id in n_player_state._vehicle_without_legal_actions\n    self._state_memoization[state_key] = mfg_state\n    return mfg_state"
        ]
    },
    {
        "func_name": "action_probabilities",
        "original": "def action_probabilities(self, state: dynamic_routing.DynamicRoutingGameState, player_id=None) -> Dict[int, float]:\n    \"\"\"Returns the mean field action to apply in the N player state.\n\n    Args:\n      state: An N player dynamic routing game state.\n      player_id: the player id for which we want an action. Should be given to\n        the function.\n\n    Returns:\n      A `dict` of `{action: probability}` for the specified player in the\n      supplied state.\n    \"\"\"\n    assert player_id is not None\n    mfg_state = self._convert_state_to_mean_field_state(state, player_id)\n    return self._mfg_policy.action_probabilities(mfg_state)",
        "mutated": [
            "def action_probabilities(self, state: dynamic_routing.DynamicRoutingGameState, player_id=None) -> Dict[int, float]:\n    if False:\n        i = 10\n    'Returns the mean field action to apply in the N player state.\\n\\n    Args:\\n      state: An N player dynamic routing game state.\\n      player_id: the player id for which we want an action. Should be given to\\n        the function.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    assert player_id is not None\n    mfg_state = self._convert_state_to_mean_field_state(state, player_id)\n    return self._mfg_policy.action_probabilities(mfg_state)",
            "def action_probabilities(self, state: dynamic_routing.DynamicRoutingGameState, player_id=None) -> Dict[int, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the mean field action to apply in the N player state.\\n\\n    Args:\\n      state: An N player dynamic routing game state.\\n      player_id: the player id for which we want an action. Should be given to\\n        the function.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    assert player_id is not None\n    mfg_state = self._convert_state_to_mean_field_state(state, player_id)\n    return self._mfg_policy.action_probabilities(mfg_state)",
            "def action_probabilities(self, state: dynamic_routing.DynamicRoutingGameState, player_id=None) -> Dict[int, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the mean field action to apply in the N player state.\\n\\n    Args:\\n      state: An N player dynamic routing game state.\\n      player_id: the player id for which we want an action. Should be given to\\n        the function.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    assert player_id is not None\n    mfg_state = self._convert_state_to_mean_field_state(state, player_id)\n    return self._mfg_policy.action_probabilities(mfg_state)",
            "def action_probabilities(self, state: dynamic_routing.DynamicRoutingGameState, player_id=None) -> Dict[int, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the mean field action to apply in the N player state.\\n\\n    Args:\\n      state: An N player dynamic routing game state.\\n      player_id: the player id for which we want an action. Should be given to\\n        the function.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    assert player_id is not None\n    mfg_state = self._convert_state_to_mean_field_state(state, player_id)\n    return self._mfg_policy.action_probabilities(mfg_state)",
            "def action_probabilities(self, state: dynamic_routing.DynamicRoutingGameState, player_id=None) -> Dict[int, float]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the mean field action to apply in the N player state.\\n\\n    Args:\\n      state: An N player dynamic routing game state.\\n      player_id: the player id for which we want an action. Should be given to\\n        the function.\\n\\n    Returns:\\n      A `dict` of `{action: probability}` for the specified player in the\\n      supplied state.\\n    '\n    assert player_id is not None\n    mfg_state = self._convert_state_to_mean_field_state(state, player_id)\n    return self._mfg_policy.action_probabilities(mfg_state)"
        ]
    }
]