[
    {
        "func_name": "__init__",
        "original": "def __init__(self, pd_results, *, features, feature_names, target_idx, deciles, kind='average', subsample=1000, random_state=None, is_categorical=None):\n    self.pd_results = pd_results\n    self.features = features\n    self.feature_names = feature_names\n    self.target_idx = target_idx\n    self.deciles = deciles\n    self.kind = kind\n    self.subsample = subsample\n    self.random_state = random_state\n    self.is_categorical = is_categorical",
        "mutated": [
            "def __init__(self, pd_results, *, features, feature_names, target_idx, deciles, kind='average', subsample=1000, random_state=None, is_categorical=None):\n    if False:\n        i = 10\n    self.pd_results = pd_results\n    self.features = features\n    self.feature_names = feature_names\n    self.target_idx = target_idx\n    self.deciles = deciles\n    self.kind = kind\n    self.subsample = subsample\n    self.random_state = random_state\n    self.is_categorical = is_categorical",
            "def __init__(self, pd_results, *, features, feature_names, target_idx, deciles, kind='average', subsample=1000, random_state=None, is_categorical=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.pd_results = pd_results\n    self.features = features\n    self.feature_names = feature_names\n    self.target_idx = target_idx\n    self.deciles = deciles\n    self.kind = kind\n    self.subsample = subsample\n    self.random_state = random_state\n    self.is_categorical = is_categorical",
            "def __init__(self, pd_results, *, features, feature_names, target_idx, deciles, kind='average', subsample=1000, random_state=None, is_categorical=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.pd_results = pd_results\n    self.features = features\n    self.feature_names = feature_names\n    self.target_idx = target_idx\n    self.deciles = deciles\n    self.kind = kind\n    self.subsample = subsample\n    self.random_state = random_state\n    self.is_categorical = is_categorical",
            "def __init__(self, pd_results, *, features, feature_names, target_idx, deciles, kind='average', subsample=1000, random_state=None, is_categorical=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.pd_results = pd_results\n    self.features = features\n    self.feature_names = feature_names\n    self.target_idx = target_idx\n    self.deciles = deciles\n    self.kind = kind\n    self.subsample = subsample\n    self.random_state = random_state\n    self.is_categorical = is_categorical",
            "def __init__(self, pd_results, *, features, feature_names, target_idx, deciles, kind='average', subsample=1000, random_state=None, is_categorical=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.pd_results = pd_results\n    self.features = features\n    self.feature_names = feature_names\n    self.target_idx = target_idx\n    self.deciles = deciles\n    self.kind = kind\n    self.subsample = subsample\n    self.random_state = random_state\n    self.is_categorical = is_categorical"
        ]
    },
    {
        "func_name": "from_estimator",
        "original": "@classmethod\ndef from_estimator(cls, estimator, X, features, *, sample_weight=None, categorical_features=None, feature_names=None, target=None, response_method='auto', n_cols=3, grid_resolution=100, percentiles=(0.05, 0.95), method='auto', n_jobs=None, verbose=0, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, ax=None, kind='average', centered=False, subsample=1000, random_state=None):\n    \"\"\"Partial dependence (PD) and individual conditional expectation (ICE) plots.\n\n        Partial dependence plots, individual conditional expectation plots or an\n        overlay of both of them can be plotted by setting the ``kind``\n        parameter. The ``len(features)`` plots are arranged in a grid with\n        ``n_cols`` columns. Two-way partial dependence plots are plotted as\n        contour plots. The deciles of the feature values will be shown with tick\n        marks on the x-axes for one-way plots, and on both axes for two-way\n        plots.\n\n        Read more in the :ref:`User Guide <partial_dependence>`.\n\n        .. note::\n\n            :func:`PartialDependenceDisplay.from_estimator` does not support using the\n            same axes with multiple calls. To plot the partial dependence for\n            multiple estimators, please pass the axes created by the first call to the\n            second call::\n\n               >>> from sklearn.inspection import PartialDependenceDisplay\n               >>> from sklearn.datasets import make_friedman1\n               >>> from sklearn.linear_model import LinearRegression\n               >>> from sklearn.ensemble import RandomForestRegressor\n               >>> X, y = make_friedman1()\n               >>> est1 = LinearRegression().fit(X, y)\n               >>> est2 = RandomForestRegressor().fit(X, y)\n               >>> disp1 = PartialDependenceDisplay.from_estimator(est1, X,\n               ...                                                 [1, 2])\n               >>> disp2 = PartialDependenceDisplay.from_estimator(est2, X, [1, 2],\n               ...                                                 ax=disp1.axes_)\n\n        .. warning::\n\n            For :class:`~sklearn.ensemble.GradientBoostingClassifier` and\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, the\n            `'recursion'` method (used by default) will not account for the `init`\n            predictor of the boosting process. In practice, this will produce\n            the same values as `'brute'` up to a constant offset in the target\n            response, provided that `init` is a constant estimator (which is the\n            default). However, if `init` is not a constant estimator, the\n            partial dependence values are incorrect for `'recursion'` because the\n            offset will be sample-dependent. It is preferable to use the `'brute'`\n            method. Note that this only applies to\n            :class:`~sklearn.ensemble.GradientBoostingClassifier` and\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, not to\n            :class:`~sklearn.ensemble.HistGradientBoostingClassifier` and\n            :class:`~sklearn.ensemble.HistGradientBoostingRegressor`.\n\n        .. versionadded:: 1.0\n\n        Parameters\n        ----------\n        estimator : BaseEstimator\n            A fitted estimator object implementing :term:`predict`,\n            :term:`predict_proba`, or :term:`decision_function`.\n            Multioutput-multiclass classifiers are not supported.\n\n        X : {array-like, dataframe} of shape (n_samples, n_features)\n            ``X`` is used to generate a grid of values for the target\n            ``features`` (where the partial dependence will be evaluated), and\n            also to generate values for the complement features when the\n            `method` is `'brute'`.\n\n        features : list of {int, str, pair of int, pair of str}\n            The target features for which to create the PDPs.\n            If `features[i]` is an integer or a string, a one-way PDP is created;\n            if `features[i]` is a tuple, a two-way PDP is created (only supported\n            with `kind='average'`). Each tuple must be of size 2.\n            If any entry is a string, then it must be in ``feature_names``.\n\n        sample_weight : array-like of shape (n_samples,), default=None\n            Sample weights are used to calculate weighted means when averaging the\n            model output. If `None`, then samples are equally weighted. If\n            `sample_weight` is not `None`, then `method` will be set to `'brute'`.\n            Note that `sample_weight` is ignored for `kind='individual'`.\n\n            .. versionadded:: 1.3\n\n        categorical_features : array-like of shape (n_features,) or shape                 (n_categorical_features,), dtype={bool, int, str}, default=None\n            Indicates the categorical features.\n\n            - `None`: no feature will be considered categorical;\n            - boolean array-like: boolean mask of shape `(n_features,)`\n              indicating which features are categorical. Thus, this array has\n              the same shape has `X.shape[1]`;\n            - integer or string array-like: integer indices or strings\n              indicating categorical features.\n\n            .. versionadded:: 1.2\n\n        feature_names : array-like of shape (n_features,), dtype=str, default=None\n            Name of each feature; `feature_names[i]` holds the name of the feature\n            with index `i`.\n            By default, the name of the feature corresponds to their numerical\n            index for NumPy array and their column name for pandas dataframe.\n\n        target : int, default=None\n            - In a multiclass setting, specifies the class for which the PDPs\n              should be computed. Note that for binary classification, the\n              positive class (index 1) is always used.\n            - In a multioutput setting, specifies the task for which the PDPs\n              should be computed.\n\n            Ignored in binary classification or classical regression settings.\n\n        response_method : {'auto', 'predict_proba', 'decision_function'},                 default='auto'\n            Specifies whether to use :term:`predict_proba` or\n            :term:`decision_function` as the target response. For regressors\n            this parameter is ignored and the response is always the output of\n            :term:`predict`. By default, :term:`predict_proba` is tried first\n            and we revert to :term:`decision_function` if it doesn't exist. If\n            ``method`` is `'recursion'`, the response is always the output of\n            :term:`decision_function`.\n\n        n_cols : int, default=3\n            The maximum number of columns in the grid plot. Only active when `ax`\n            is a single axis or `None`.\n\n        grid_resolution : int, default=100\n            The number of equally spaced points on the axes of the plots, for each\n            target feature.\n\n        percentiles : tuple of float, default=(0.05, 0.95)\n            The lower and upper percentile used to create the extreme values\n            for the PDP axes. Must be in [0, 1].\n\n        method : str, default='auto'\n            The method used to calculate the averaged predictions:\n\n            - `'recursion'` is only supported for some tree-based estimators\n              (namely\n              :class:`~sklearn.ensemble.GradientBoostingClassifier`,\n              :class:`~sklearn.ensemble.GradientBoostingRegressor`,\n              :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,\n              :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,\n              :class:`~sklearn.tree.DecisionTreeRegressor`,\n              :class:`~sklearn.ensemble.RandomForestRegressor`\n              but is more efficient in terms of speed.\n              With this method, the target response of a\n              classifier is always the decision function, not the predicted\n              probabilities. Since the `'recursion'` method implicitly computes\n              the average of the ICEs by design, it is not compatible with ICE and\n              thus `kind` must be `'average'`.\n\n            - `'brute'` is supported for any estimator, but is more\n              computationally intensive.\n\n            - `'auto'`: the `'recursion'` is used for estimators that support it,\n              and `'brute'` is used otherwise. If `sample_weight` is not `None`,\n              then `'brute'` is used regardless of the estimator.\n\n            Please see :ref:`this note <pdp_method_differences>` for\n            differences between the `'brute'` and `'recursion'` method.\n\n        n_jobs : int, default=None\n            The number of CPUs to use to compute the partial dependences.\n            Computation is parallelized over features specified by the `features`\n            parameter.\n\n            ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n            ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n            for more details.\n\n        verbose : int, default=0\n            Verbose output during PD computations.\n\n        line_kw : dict, default=None\n            Dict with keywords passed to the ``matplotlib.pyplot.plot`` call.\n            For one-way partial dependence plots. It can be used to define common\n            properties for both `ice_lines_kw` and `pdp_line_kw`.\n\n        ice_lines_kw : dict, default=None\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\n            For ICE lines in the one-way partial dependence plots.\n            The key value pairs defined in `ice_lines_kw` takes priority over\n            `line_kw`.\n\n        pd_line_kw : dict, default=None\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\n            For partial dependence in one-way partial dependence plots.\n            The key value pairs defined in `pd_line_kw` takes priority over\n            `line_kw`.\n\n        contour_kw : dict, default=None\n            Dict with keywords passed to the ``matplotlib.pyplot.contourf`` call.\n            For two-way partial dependence plots.\n\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\n            - If a single axis is passed in, it is treated as a bounding axes\n              and a grid of partial dependence plots will be drawn within\n              these bounds. The `n_cols` parameter controls the number of\n              columns in the grid.\n            - If an array-like of axes are passed in, the partial dependence\n              plots will be drawn directly into these axes.\n            - If `None`, a figure and a bounding axes is created and treated\n              as the single axes case.\n\n        kind : {'average', 'individual', 'both'}, default='average'\n            Whether to plot the partial dependence averaged across all the samples\n            in the dataset or one line per sample or both.\n\n            - ``kind='average'`` results in the traditional PD plot;\n            - ``kind='individual'`` results in the ICE plot.\n\n           Note that the fast `method='recursion'` option is only available for\n           `kind='average'` and `sample_weights=None`. Computing individual\n           dependencies and doing weighted averages requires using the slower\n           `method='brute'`.\n\n        centered : bool, default=False\n            If `True`, the ICE and PD lines will start at the origin of the\n            y-axis. By default, no centering is done.\n\n            .. versionadded:: 1.1\n\n        subsample : float, int or None, default=1000\n            Sampling for ICE curves when `kind` is 'individual' or 'both'.\n            If `float`, should be between 0.0 and 1.0 and represent the proportion\n            of the dataset to be used to plot ICE curves. If `int`, represents the\n            absolute number samples to use.\n\n            Note that the full dataset is still used to calculate averaged partial\n            dependence when `kind='both'`.\n\n        random_state : int, RandomState instance or None, default=None\n            Controls the randomness of the selected samples when subsamples is not\n            `None` and `kind` is either `'both'` or `'individual'`.\n            See :term:`Glossary <random_state>` for details.\n\n        Returns\n        -------\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\n\n        See Also\n        --------\n        partial_dependence : Compute Partial Dependence values.\n\n        Examples\n        --------\n        >>> import matplotlib.pyplot as plt\n        >>> from sklearn.datasets import make_friedman1\n        >>> from sklearn.ensemble import GradientBoostingRegressor\n        >>> from sklearn.inspection import PartialDependenceDisplay\n        >>> X, y = make_friedman1()\n        >>> clf = GradientBoostingRegressor(n_estimators=10).fit(X, y)\n        >>> PartialDependenceDisplay.from_estimator(clf, X, [0, (0, 1)])\n        <...>\n        >>> plt.show()\n        \"\"\"\n    check_matplotlib_support(f'{cls.__name__}.from_estimator')\n    import matplotlib.pyplot as plt\n    if hasattr(estimator, 'classes_') and np.size(estimator.classes_) > 2:\n        if target is None:\n            raise ValueError('target must be specified for multi-class')\n        target_idx = np.searchsorted(estimator.classes_, target)\n        if not 0 <= target_idx < len(estimator.classes_) or estimator.classes_[target_idx] != target:\n            raise ValueError('target not in est.classes_, got {}'.format(target))\n    else:\n        target_idx = 0\n    if not (hasattr(X, '__array__') or sparse.issparse(X)):\n        X = check_array(X, force_all_finite='allow-nan', dtype=object)\n    n_features = X.shape[1]\n    feature_names = _check_feature_names(X, feature_names)\n    kind_ = [kind] * len(features) if isinstance(kind, str) else kind\n    if len(kind_) != len(features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind_)} element(s) and `features` contains {len(features)} element(s).')\n    (tmp_features, ice_for_two_way_pd) = ([], [])\n    for (kind_plot, fxs) in zip(kind_, features):\n        if isinstance(fxs, (numbers.Integral, str)):\n            fxs = (fxs,)\n        try:\n            fxs = tuple((_get_feature_index(fx, feature_names=feature_names) for fx in fxs))\n        except TypeError as e:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.') from e\n        if not 1 <= np.size(fxs) <= 2:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.')\n        ice_for_two_way_pd.append(kind_plot != 'average' and np.size(fxs) > 1)\n        tmp_features.append(fxs)\n    if any(ice_for_two_way_pd):\n        kind_ = ['average' if forcing_average else kind_plot for (forcing_average, kind_plot) in zip(ice_for_two_way_pd, kind_)]\n        raise ValueError(f\"ICE plot cannot be rendered for 2-way feature interactions. 2-way feature interactions mandates PD plots using the 'average' kind: features={features!r} should be configured to use kind={kind_!r} explicitly.\")\n    features = tmp_features\n    if categorical_features is None:\n        is_categorical = [(False,) if len(fxs) == 1 else (False, False) for fxs in features]\n    else:\n        categorical_features = np.array(categorical_features, copy=False)\n        if categorical_features.dtype.kind == 'b':\n            if categorical_features.size != n_features:\n                raise ValueError(f'When `categorical_features` is a boolean array-like, the array should be of shape (n_features,). Got {categorical_features.size} elements while `X` contains {n_features} features.')\n            is_categorical = [tuple((categorical_features[fx] for fx in fxs)) for fxs in features]\n        elif categorical_features.dtype.kind in ('i', 'O', 'U'):\n            categorical_features_idx = [_get_feature_index(cat, feature_names=feature_names) for cat in categorical_features]\n            is_categorical = [tuple([idx in categorical_features_idx for idx in fxs]) for fxs in features]\n        else:\n            raise ValueError(f'Expected `categorical_features` to be an array-like of boolean, integer, or string. Got {categorical_features.dtype} instead.')\n        for cats in is_categorical:\n            if np.size(cats) == 2 and cats[0] != cats[1]:\n                raise ValueError('Two-way partial dependence plots are not supported for pairs of continuous and categorical features.')\n        categorical_features_targeted = set([fx for (fxs, cats) in zip(features, is_categorical) for fx in fxs if any(cats)])\n        if categorical_features_targeted:\n            min_n_cats = min([len(_unique(_safe_indexing(X, idx, axis=1))) for idx in categorical_features_targeted])\n            if grid_resolution < min_n_cats:\n                raise ValueError(f'The resolution of the computed grid is less than the minimum number of categories in the targeted categorical features. Expect the `grid_resolution` to be greater than {min_n_cats}. Got {grid_resolution} instead.')\n        for (is_cat, kind_plot) in zip(is_categorical, kind_):\n            if any(is_cat) and kind_plot != 'average':\n                raise ValueError('It is not possible to display individual effects for categorical features.')\n    if ax is not None and (not isinstance(ax, plt.Axes)):\n        axes = np.asarray(ax, dtype=object)\n        if axes.size != len(features):\n            raise ValueError('Expected ax to have {} axes, got {}'.format(len(features), axes.size))\n    for i in chain.from_iterable(features):\n        if i >= len(feature_names):\n            raise ValueError('All entries of features must be less than len(feature_names) = {0}, got {1}.'.format(len(feature_names), i))\n    if isinstance(subsample, numbers.Integral):\n        if subsample <= 0:\n            raise ValueError(f'When an integer, subsample={subsample} should be positive.')\n    elif isinstance(subsample, numbers.Real):\n        if subsample <= 0 or subsample >= 1:\n            raise ValueError(f'When a floating-point, subsample={subsample} should be in the (0, 1) range.')\n    pd_results = Parallel(n_jobs=n_jobs, verbose=verbose)((delayed(partial_dependence)(estimator, X, fxs, sample_weight=sample_weight, feature_names=feature_names, categorical_features=categorical_features, response_method=response_method, method=method, grid_resolution=grid_resolution, percentiles=percentiles, kind=kind_plot) for (kind_plot, fxs) in zip(kind_, features)))\n    pd_result = pd_results[0]\n    n_tasks = pd_result.average.shape[0] if kind_[0] == 'average' else pd_result.individual.shape[0]\n    if is_regressor(estimator) and n_tasks > 1:\n        if target is None:\n            raise ValueError('target must be specified for multi-output regressors')\n        if not 0 <= target <= n_tasks:\n            raise ValueError('target must be in [0, n_tasks], got {}.'.format(target))\n        target_idx = target\n    deciles = {}\n    for (fxs, cats) in zip(features, is_categorical):\n        for (fx, cat) in zip(fxs, cats):\n            if not cat and fx not in deciles:\n                X_col = _safe_indexing(X, fx, axis=1)\n                deciles[fx] = mquantiles(X_col, prob=np.arange(0.1, 1.0, 0.1))\n    display = PartialDependenceDisplay(pd_results=pd_results, features=features, feature_names=feature_names, target_idx=target_idx, deciles=deciles, kind=kind, subsample=subsample, random_state=random_state, is_categorical=is_categorical)\n    return display.plot(ax=ax, n_cols=n_cols, line_kw=line_kw, ice_lines_kw=ice_lines_kw, pd_line_kw=pd_line_kw, contour_kw=contour_kw, centered=centered)",
        "mutated": [
            "@classmethod\ndef from_estimator(cls, estimator, X, features, *, sample_weight=None, categorical_features=None, feature_names=None, target=None, response_method='auto', n_cols=3, grid_resolution=100, percentiles=(0.05, 0.95), method='auto', n_jobs=None, verbose=0, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, ax=None, kind='average', centered=False, subsample=1000, random_state=None):\n    if False:\n        i = 10\n    \"Partial dependence (PD) and individual conditional expectation (ICE) plots.\\n\\n        Partial dependence plots, individual conditional expectation plots or an\\n        overlay of both of them can be plotted by setting the ``kind``\\n        parameter. The ``len(features)`` plots are arranged in a grid with\\n        ``n_cols`` columns. Two-way partial dependence plots are plotted as\\n        contour plots. The deciles of the feature values will be shown with tick\\n        marks on the x-axes for one-way plots, and on both axes for two-way\\n        plots.\\n\\n        Read more in the :ref:`User Guide <partial_dependence>`.\\n\\n        .. note::\\n\\n            :func:`PartialDependenceDisplay.from_estimator` does not support using the\\n            same axes with multiple calls. To plot the partial dependence for\\n            multiple estimators, please pass the axes created by the first call to the\\n            second call::\\n\\n               >>> from sklearn.inspection import PartialDependenceDisplay\\n               >>> from sklearn.datasets import make_friedman1\\n               >>> from sklearn.linear_model import LinearRegression\\n               >>> from sklearn.ensemble import RandomForestRegressor\\n               >>> X, y = make_friedman1()\\n               >>> est1 = LinearRegression().fit(X, y)\\n               >>> est2 = RandomForestRegressor().fit(X, y)\\n               >>> disp1 = PartialDependenceDisplay.from_estimator(est1, X,\\n               ...                                                 [1, 2])\\n               >>> disp2 = PartialDependenceDisplay.from_estimator(est2, X, [1, 2],\\n               ...                                                 ax=disp1.axes_)\\n\\n        .. warning::\\n\\n            For :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, the\\n            `'recursion'` method (used by default) will not account for the `init`\\n            predictor of the boosting process. In practice, this will produce\\n            the same values as `'brute'` up to a constant offset in the target\\n            response, provided that `init` is a constant estimator (which is the\\n            default). However, if `init` is not a constant estimator, the\\n            partial dependence values are incorrect for `'recursion'` because the\\n            offset will be sample-dependent. It is preferable to use the `'brute'`\\n            method. Note that this only applies to\\n            :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, not to\\n            :class:`~sklearn.ensemble.HistGradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.HistGradientBoostingRegressor`.\\n\\n        .. versionadded:: 1.0\\n\\n        Parameters\\n        ----------\\n        estimator : BaseEstimator\\n            A fitted estimator object implementing :term:`predict`,\\n            :term:`predict_proba`, or :term:`decision_function`.\\n            Multioutput-multiclass classifiers are not supported.\\n\\n        X : {array-like, dataframe} of shape (n_samples, n_features)\\n            ``X`` is used to generate a grid of values for the target\\n            ``features`` (where the partial dependence will be evaluated), and\\n            also to generate values for the complement features when the\\n            `method` is `'brute'`.\\n\\n        features : list of {int, str, pair of int, pair of str}\\n            The target features for which to create the PDPs.\\n            If `features[i]` is an integer or a string, a one-way PDP is created;\\n            if `features[i]` is a tuple, a two-way PDP is created (only supported\\n            with `kind='average'`). Each tuple must be of size 2.\\n            If any entry is a string, then it must be in ``feature_names``.\\n\\n        sample_weight : array-like of shape (n_samples,), default=None\\n            Sample weights are used to calculate weighted means when averaging the\\n            model output. If `None`, then samples are equally weighted. If\\n            `sample_weight` is not `None`, then `method` will be set to `'brute'`.\\n            Note that `sample_weight` is ignored for `kind='individual'`.\\n\\n            .. versionadded:: 1.3\\n\\n        categorical_features : array-like of shape (n_features,) or shape                 (n_categorical_features,), dtype={bool, int, str}, default=None\\n            Indicates the categorical features.\\n\\n            - `None`: no feature will be considered categorical;\\n            - boolean array-like: boolean mask of shape `(n_features,)`\\n              indicating which features are categorical. Thus, this array has\\n              the same shape has `X.shape[1]`;\\n            - integer or string array-like: integer indices or strings\\n              indicating categorical features.\\n\\n            .. versionadded:: 1.2\\n\\n        feature_names : array-like of shape (n_features,), dtype=str, default=None\\n            Name of each feature; `feature_names[i]` holds the name of the feature\\n            with index `i`.\\n            By default, the name of the feature corresponds to their numerical\\n            index for NumPy array and their column name for pandas dataframe.\\n\\n        target : int, default=None\\n            - In a multiclass setting, specifies the class for which the PDPs\\n              should be computed. Note that for binary classification, the\\n              positive class (index 1) is always used.\\n            - In a multioutput setting, specifies the task for which the PDPs\\n              should be computed.\\n\\n            Ignored in binary classification or classical regression settings.\\n\\n        response_method : {'auto', 'predict_proba', 'decision_function'},                 default='auto'\\n            Specifies whether to use :term:`predict_proba` or\\n            :term:`decision_function` as the target response. For regressors\\n            this parameter is ignored and the response is always the output of\\n            :term:`predict`. By default, :term:`predict_proba` is tried first\\n            and we revert to :term:`decision_function` if it doesn't exist. If\\n            ``method`` is `'recursion'`, the response is always the output of\\n            :term:`decision_function`.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when `ax`\\n            is a single axis or `None`.\\n\\n        grid_resolution : int, default=100\\n            The number of equally spaced points on the axes of the plots, for each\\n            target feature.\\n\\n        percentiles : tuple of float, default=(0.05, 0.95)\\n            The lower and upper percentile used to create the extreme values\\n            for the PDP axes. Must be in [0, 1].\\n\\n        method : str, default='auto'\\n            The method used to calculate the averaged predictions:\\n\\n            - `'recursion'` is only supported for some tree-based estimators\\n              (namely\\n              :class:`~sklearn.ensemble.GradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.GradientBoostingRegressor`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,\\n              :class:`~sklearn.tree.DecisionTreeRegressor`,\\n              :class:`~sklearn.ensemble.RandomForestRegressor`\\n              but is more efficient in terms of speed.\\n              With this method, the target response of a\\n              classifier is always the decision function, not the predicted\\n              probabilities. Since the `'recursion'` method implicitly computes\\n              the average of the ICEs by design, it is not compatible with ICE and\\n              thus `kind` must be `'average'`.\\n\\n            - `'brute'` is supported for any estimator, but is more\\n              computationally intensive.\\n\\n            - `'auto'`: the `'recursion'` is used for estimators that support it,\\n              and `'brute'` is used otherwise. If `sample_weight` is not `None`,\\n              then `'brute'` is used regardless of the estimator.\\n\\n            Please see :ref:`this note <pdp_method_differences>` for\\n            differences between the `'brute'` and `'recursion'` method.\\n\\n        n_jobs : int, default=None\\n            The number of CPUs to use to compute the partial dependences.\\n            Computation is parallelized over features specified by the `features`\\n            parameter.\\n\\n            ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\\n            ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\\n            for more details.\\n\\n        verbose : int, default=0\\n            Verbose output during PD computations.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.plot`` call.\\n            For one-way partial dependence plots. It can be used to define common\\n            properties for both `ice_lines_kw` and `pdp_line_kw`.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.contourf`` call.\\n            For two-way partial dependence plots.\\n\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n              and a grid of partial dependence plots will be drawn within\\n              these bounds. The `n_cols` parameter controls the number of\\n              columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n              plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n              as the single axes case.\\n\\n        kind : {'average', 'individual', 'both'}, default='average'\\n            Whether to plot the partial dependence averaged across all the samples\\n            in the dataset or one line per sample or both.\\n\\n            - ``kind='average'`` results in the traditional PD plot;\\n            - ``kind='individual'`` results in the ICE plot.\\n\\n           Note that the fast `method='recursion'` option is only available for\\n           `kind='average'` and `sample_weights=None`. Computing individual\\n           dependencies and doing weighted averages requires using the slower\\n           `method='brute'`.\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        subsample : float, int or None, default=1000\\n            Sampling for ICE curves when `kind` is 'individual' or 'both'.\\n            If `float`, should be between 0.0 and 1.0 and represent the proportion\\n            of the dataset to be used to plot ICE curves. If `int`, represents the\\n            absolute number samples to use.\\n\\n            Note that the full dataset is still used to calculate averaged partial\\n            dependence when `kind='both'`.\\n\\n        random_state : int, RandomState instance or None, default=None\\n            Controls the randomness of the selected samples when subsamples is not\\n            `None` and `kind` is either `'both'` or `'individual'`.\\n            See :term:`Glossary <random_state>` for details.\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n\\n        See Also\\n        --------\\n        partial_dependence : Compute Partial Dependence values.\\n\\n        Examples\\n        --------\\n        >>> import matplotlib.pyplot as plt\\n        >>> from sklearn.datasets import make_friedman1\\n        >>> from sklearn.ensemble import GradientBoostingRegressor\\n        >>> from sklearn.inspection import PartialDependenceDisplay\\n        >>> X, y = make_friedman1()\\n        >>> clf = GradientBoostingRegressor(n_estimators=10).fit(X, y)\\n        >>> PartialDependenceDisplay.from_estimator(clf, X, [0, (0, 1)])\\n        <...>\\n        >>> plt.show()\\n        \"\n    check_matplotlib_support(f'{cls.__name__}.from_estimator')\n    import matplotlib.pyplot as plt\n    if hasattr(estimator, 'classes_') and np.size(estimator.classes_) > 2:\n        if target is None:\n            raise ValueError('target must be specified for multi-class')\n        target_idx = np.searchsorted(estimator.classes_, target)\n        if not 0 <= target_idx < len(estimator.classes_) or estimator.classes_[target_idx] != target:\n            raise ValueError('target not in est.classes_, got {}'.format(target))\n    else:\n        target_idx = 0\n    if not (hasattr(X, '__array__') or sparse.issparse(X)):\n        X = check_array(X, force_all_finite='allow-nan', dtype=object)\n    n_features = X.shape[1]\n    feature_names = _check_feature_names(X, feature_names)\n    kind_ = [kind] * len(features) if isinstance(kind, str) else kind\n    if len(kind_) != len(features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind_)} element(s) and `features` contains {len(features)} element(s).')\n    (tmp_features, ice_for_two_way_pd) = ([], [])\n    for (kind_plot, fxs) in zip(kind_, features):\n        if isinstance(fxs, (numbers.Integral, str)):\n            fxs = (fxs,)\n        try:\n            fxs = tuple((_get_feature_index(fx, feature_names=feature_names) for fx in fxs))\n        except TypeError as e:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.') from e\n        if not 1 <= np.size(fxs) <= 2:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.')\n        ice_for_two_way_pd.append(kind_plot != 'average' and np.size(fxs) > 1)\n        tmp_features.append(fxs)\n    if any(ice_for_two_way_pd):\n        kind_ = ['average' if forcing_average else kind_plot for (forcing_average, kind_plot) in zip(ice_for_two_way_pd, kind_)]\n        raise ValueError(f\"ICE plot cannot be rendered for 2-way feature interactions. 2-way feature interactions mandates PD plots using the 'average' kind: features={features!r} should be configured to use kind={kind_!r} explicitly.\")\n    features = tmp_features\n    if categorical_features is None:\n        is_categorical = [(False,) if len(fxs) == 1 else (False, False) for fxs in features]\n    else:\n        categorical_features = np.array(categorical_features, copy=False)\n        if categorical_features.dtype.kind == 'b':\n            if categorical_features.size != n_features:\n                raise ValueError(f'When `categorical_features` is a boolean array-like, the array should be of shape (n_features,). Got {categorical_features.size} elements while `X` contains {n_features} features.')\n            is_categorical = [tuple((categorical_features[fx] for fx in fxs)) for fxs in features]\n        elif categorical_features.dtype.kind in ('i', 'O', 'U'):\n            categorical_features_idx = [_get_feature_index(cat, feature_names=feature_names) for cat in categorical_features]\n            is_categorical = [tuple([idx in categorical_features_idx for idx in fxs]) for fxs in features]\n        else:\n            raise ValueError(f'Expected `categorical_features` to be an array-like of boolean, integer, or string. Got {categorical_features.dtype} instead.')\n        for cats in is_categorical:\n            if np.size(cats) == 2 and cats[0] != cats[1]:\n                raise ValueError('Two-way partial dependence plots are not supported for pairs of continuous and categorical features.')\n        categorical_features_targeted = set([fx for (fxs, cats) in zip(features, is_categorical) for fx in fxs if any(cats)])\n        if categorical_features_targeted:\n            min_n_cats = min([len(_unique(_safe_indexing(X, idx, axis=1))) for idx in categorical_features_targeted])\n            if grid_resolution < min_n_cats:\n                raise ValueError(f'The resolution of the computed grid is less than the minimum number of categories in the targeted categorical features. Expect the `grid_resolution` to be greater than {min_n_cats}. Got {grid_resolution} instead.')\n        for (is_cat, kind_plot) in zip(is_categorical, kind_):\n            if any(is_cat) and kind_plot != 'average':\n                raise ValueError('It is not possible to display individual effects for categorical features.')\n    if ax is not None and (not isinstance(ax, plt.Axes)):\n        axes = np.asarray(ax, dtype=object)\n        if axes.size != len(features):\n            raise ValueError('Expected ax to have {} axes, got {}'.format(len(features), axes.size))\n    for i in chain.from_iterable(features):\n        if i >= len(feature_names):\n            raise ValueError('All entries of features must be less than len(feature_names) = {0}, got {1}.'.format(len(feature_names), i))\n    if isinstance(subsample, numbers.Integral):\n        if subsample <= 0:\n            raise ValueError(f'When an integer, subsample={subsample} should be positive.')\n    elif isinstance(subsample, numbers.Real):\n        if subsample <= 0 or subsample >= 1:\n            raise ValueError(f'When a floating-point, subsample={subsample} should be in the (0, 1) range.')\n    pd_results = Parallel(n_jobs=n_jobs, verbose=verbose)((delayed(partial_dependence)(estimator, X, fxs, sample_weight=sample_weight, feature_names=feature_names, categorical_features=categorical_features, response_method=response_method, method=method, grid_resolution=grid_resolution, percentiles=percentiles, kind=kind_plot) for (kind_plot, fxs) in zip(kind_, features)))\n    pd_result = pd_results[0]\n    n_tasks = pd_result.average.shape[0] if kind_[0] == 'average' else pd_result.individual.shape[0]\n    if is_regressor(estimator) and n_tasks > 1:\n        if target is None:\n            raise ValueError('target must be specified for multi-output regressors')\n        if not 0 <= target <= n_tasks:\n            raise ValueError('target must be in [0, n_tasks], got {}.'.format(target))\n        target_idx = target\n    deciles = {}\n    for (fxs, cats) in zip(features, is_categorical):\n        for (fx, cat) in zip(fxs, cats):\n            if not cat and fx not in deciles:\n                X_col = _safe_indexing(X, fx, axis=1)\n                deciles[fx] = mquantiles(X_col, prob=np.arange(0.1, 1.0, 0.1))\n    display = PartialDependenceDisplay(pd_results=pd_results, features=features, feature_names=feature_names, target_idx=target_idx, deciles=deciles, kind=kind, subsample=subsample, random_state=random_state, is_categorical=is_categorical)\n    return display.plot(ax=ax, n_cols=n_cols, line_kw=line_kw, ice_lines_kw=ice_lines_kw, pd_line_kw=pd_line_kw, contour_kw=contour_kw, centered=centered)",
            "@classmethod\ndef from_estimator(cls, estimator, X, features, *, sample_weight=None, categorical_features=None, feature_names=None, target=None, response_method='auto', n_cols=3, grid_resolution=100, percentiles=(0.05, 0.95), method='auto', n_jobs=None, verbose=0, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, ax=None, kind='average', centered=False, subsample=1000, random_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Partial dependence (PD) and individual conditional expectation (ICE) plots.\\n\\n        Partial dependence plots, individual conditional expectation plots or an\\n        overlay of both of them can be plotted by setting the ``kind``\\n        parameter. The ``len(features)`` plots are arranged in a grid with\\n        ``n_cols`` columns. Two-way partial dependence plots are plotted as\\n        contour plots. The deciles of the feature values will be shown with tick\\n        marks on the x-axes for one-way plots, and on both axes for two-way\\n        plots.\\n\\n        Read more in the :ref:`User Guide <partial_dependence>`.\\n\\n        .. note::\\n\\n            :func:`PartialDependenceDisplay.from_estimator` does not support using the\\n            same axes with multiple calls. To plot the partial dependence for\\n            multiple estimators, please pass the axes created by the first call to the\\n            second call::\\n\\n               >>> from sklearn.inspection import PartialDependenceDisplay\\n               >>> from sklearn.datasets import make_friedman1\\n               >>> from sklearn.linear_model import LinearRegression\\n               >>> from sklearn.ensemble import RandomForestRegressor\\n               >>> X, y = make_friedman1()\\n               >>> est1 = LinearRegression().fit(X, y)\\n               >>> est2 = RandomForestRegressor().fit(X, y)\\n               >>> disp1 = PartialDependenceDisplay.from_estimator(est1, X,\\n               ...                                                 [1, 2])\\n               >>> disp2 = PartialDependenceDisplay.from_estimator(est2, X, [1, 2],\\n               ...                                                 ax=disp1.axes_)\\n\\n        .. warning::\\n\\n            For :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, the\\n            `'recursion'` method (used by default) will not account for the `init`\\n            predictor of the boosting process. In practice, this will produce\\n            the same values as `'brute'` up to a constant offset in the target\\n            response, provided that `init` is a constant estimator (which is the\\n            default). However, if `init` is not a constant estimator, the\\n            partial dependence values are incorrect for `'recursion'` because the\\n            offset will be sample-dependent. It is preferable to use the `'brute'`\\n            method. Note that this only applies to\\n            :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, not to\\n            :class:`~sklearn.ensemble.HistGradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.HistGradientBoostingRegressor`.\\n\\n        .. versionadded:: 1.0\\n\\n        Parameters\\n        ----------\\n        estimator : BaseEstimator\\n            A fitted estimator object implementing :term:`predict`,\\n            :term:`predict_proba`, or :term:`decision_function`.\\n            Multioutput-multiclass classifiers are not supported.\\n\\n        X : {array-like, dataframe} of shape (n_samples, n_features)\\n            ``X`` is used to generate a grid of values for the target\\n            ``features`` (where the partial dependence will be evaluated), and\\n            also to generate values for the complement features when the\\n            `method` is `'brute'`.\\n\\n        features : list of {int, str, pair of int, pair of str}\\n            The target features for which to create the PDPs.\\n            If `features[i]` is an integer or a string, a one-way PDP is created;\\n            if `features[i]` is a tuple, a two-way PDP is created (only supported\\n            with `kind='average'`). Each tuple must be of size 2.\\n            If any entry is a string, then it must be in ``feature_names``.\\n\\n        sample_weight : array-like of shape (n_samples,), default=None\\n            Sample weights are used to calculate weighted means when averaging the\\n            model output. If `None`, then samples are equally weighted. If\\n            `sample_weight` is not `None`, then `method` will be set to `'brute'`.\\n            Note that `sample_weight` is ignored for `kind='individual'`.\\n\\n            .. versionadded:: 1.3\\n\\n        categorical_features : array-like of shape (n_features,) or shape                 (n_categorical_features,), dtype={bool, int, str}, default=None\\n            Indicates the categorical features.\\n\\n            - `None`: no feature will be considered categorical;\\n            - boolean array-like: boolean mask of shape `(n_features,)`\\n              indicating which features are categorical. Thus, this array has\\n              the same shape has `X.shape[1]`;\\n            - integer or string array-like: integer indices or strings\\n              indicating categorical features.\\n\\n            .. versionadded:: 1.2\\n\\n        feature_names : array-like of shape (n_features,), dtype=str, default=None\\n            Name of each feature; `feature_names[i]` holds the name of the feature\\n            with index `i`.\\n            By default, the name of the feature corresponds to their numerical\\n            index for NumPy array and their column name for pandas dataframe.\\n\\n        target : int, default=None\\n            - In a multiclass setting, specifies the class for which the PDPs\\n              should be computed. Note that for binary classification, the\\n              positive class (index 1) is always used.\\n            - In a multioutput setting, specifies the task for which the PDPs\\n              should be computed.\\n\\n            Ignored in binary classification or classical regression settings.\\n\\n        response_method : {'auto', 'predict_proba', 'decision_function'},                 default='auto'\\n            Specifies whether to use :term:`predict_proba` or\\n            :term:`decision_function` as the target response. For regressors\\n            this parameter is ignored and the response is always the output of\\n            :term:`predict`. By default, :term:`predict_proba` is tried first\\n            and we revert to :term:`decision_function` if it doesn't exist. If\\n            ``method`` is `'recursion'`, the response is always the output of\\n            :term:`decision_function`.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when `ax`\\n            is a single axis or `None`.\\n\\n        grid_resolution : int, default=100\\n            The number of equally spaced points on the axes of the plots, for each\\n            target feature.\\n\\n        percentiles : tuple of float, default=(0.05, 0.95)\\n            The lower and upper percentile used to create the extreme values\\n            for the PDP axes. Must be in [0, 1].\\n\\n        method : str, default='auto'\\n            The method used to calculate the averaged predictions:\\n\\n            - `'recursion'` is only supported for some tree-based estimators\\n              (namely\\n              :class:`~sklearn.ensemble.GradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.GradientBoostingRegressor`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,\\n              :class:`~sklearn.tree.DecisionTreeRegressor`,\\n              :class:`~sklearn.ensemble.RandomForestRegressor`\\n              but is more efficient in terms of speed.\\n              With this method, the target response of a\\n              classifier is always the decision function, not the predicted\\n              probabilities. Since the `'recursion'` method implicitly computes\\n              the average of the ICEs by design, it is not compatible with ICE and\\n              thus `kind` must be `'average'`.\\n\\n            - `'brute'` is supported for any estimator, but is more\\n              computationally intensive.\\n\\n            - `'auto'`: the `'recursion'` is used for estimators that support it,\\n              and `'brute'` is used otherwise. If `sample_weight` is not `None`,\\n              then `'brute'` is used regardless of the estimator.\\n\\n            Please see :ref:`this note <pdp_method_differences>` for\\n            differences between the `'brute'` and `'recursion'` method.\\n\\n        n_jobs : int, default=None\\n            The number of CPUs to use to compute the partial dependences.\\n            Computation is parallelized over features specified by the `features`\\n            parameter.\\n\\n            ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\\n            ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\\n            for more details.\\n\\n        verbose : int, default=0\\n            Verbose output during PD computations.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.plot`` call.\\n            For one-way partial dependence plots. It can be used to define common\\n            properties for both `ice_lines_kw` and `pdp_line_kw`.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.contourf`` call.\\n            For two-way partial dependence plots.\\n\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n              and a grid of partial dependence plots will be drawn within\\n              these bounds. The `n_cols` parameter controls the number of\\n              columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n              plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n              as the single axes case.\\n\\n        kind : {'average', 'individual', 'both'}, default='average'\\n            Whether to plot the partial dependence averaged across all the samples\\n            in the dataset or one line per sample or both.\\n\\n            - ``kind='average'`` results in the traditional PD plot;\\n            - ``kind='individual'`` results in the ICE plot.\\n\\n           Note that the fast `method='recursion'` option is only available for\\n           `kind='average'` and `sample_weights=None`. Computing individual\\n           dependencies and doing weighted averages requires using the slower\\n           `method='brute'`.\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        subsample : float, int or None, default=1000\\n            Sampling for ICE curves when `kind` is 'individual' or 'both'.\\n            If `float`, should be between 0.0 and 1.0 and represent the proportion\\n            of the dataset to be used to plot ICE curves. If `int`, represents the\\n            absolute number samples to use.\\n\\n            Note that the full dataset is still used to calculate averaged partial\\n            dependence when `kind='both'`.\\n\\n        random_state : int, RandomState instance or None, default=None\\n            Controls the randomness of the selected samples when subsamples is not\\n            `None` and `kind` is either `'both'` or `'individual'`.\\n            See :term:`Glossary <random_state>` for details.\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n\\n        See Also\\n        --------\\n        partial_dependence : Compute Partial Dependence values.\\n\\n        Examples\\n        --------\\n        >>> import matplotlib.pyplot as plt\\n        >>> from sklearn.datasets import make_friedman1\\n        >>> from sklearn.ensemble import GradientBoostingRegressor\\n        >>> from sklearn.inspection import PartialDependenceDisplay\\n        >>> X, y = make_friedman1()\\n        >>> clf = GradientBoostingRegressor(n_estimators=10).fit(X, y)\\n        >>> PartialDependenceDisplay.from_estimator(clf, X, [0, (0, 1)])\\n        <...>\\n        >>> plt.show()\\n        \"\n    check_matplotlib_support(f'{cls.__name__}.from_estimator')\n    import matplotlib.pyplot as plt\n    if hasattr(estimator, 'classes_') and np.size(estimator.classes_) > 2:\n        if target is None:\n            raise ValueError('target must be specified for multi-class')\n        target_idx = np.searchsorted(estimator.classes_, target)\n        if not 0 <= target_idx < len(estimator.classes_) or estimator.classes_[target_idx] != target:\n            raise ValueError('target not in est.classes_, got {}'.format(target))\n    else:\n        target_idx = 0\n    if not (hasattr(X, '__array__') or sparse.issparse(X)):\n        X = check_array(X, force_all_finite='allow-nan', dtype=object)\n    n_features = X.shape[1]\n    feature_names = _check_feature_names(X, feature_names)\n    kind_ = [kind] * len(features) if isinstance(kind, str) else kind\n    if len(kind_) != len(features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind_)} element(s) and `features` contains {len(features)} element(s).')\n    (tmp_features, ice_for_two_way_pd) = ([], [])\n    for (kind_plot, fxs) in zip(kind_, features):\n        if isinstance(fxs, (numbers.Integral, str)):\n            fxs = (fxs,)\n        try:\n            fxs = tuple((_get_feature_index(fx, feature_names=feature_names) for fx in fxs))\n        except TypeError as e:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.') from e\n        if not 1 <= np.size(fxs) <= 2:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.')\n        ice_for_two_way_pd.append(kind_plot != 'average' and np.size(fxs) > 1)\n        tmp_features.append(fxs)\n    if any(ice_for_two_way_pd):\n        kind_ = ['average' if forcing_average else kind_plot for (forcing_average, kind_plot) in zip(ice_for_two_way_pd, kind_)]\n        raise ValueError(f\"ICE plot cannot be rendered for 2-way feature interactions. 2-way feature interactions mandates PD plots using the 'average' kind: features={features!r} should be configured to use kind={kind_!r} explicitly.\")\n    features = tmp_features\n    if categorical_features is None:\n        is_categorical = [(False,) if len(fxs) == 1 else (False, False) for fxs in features]\n    else:\n        categorical_features = np.array(categorical_features, copy=False)\n        if categorical_features.dtype.kind == 'b':\n            if categorical_features.size != n_features:\n                raise ValueError(f'When `categorical_features` is a boolean array-like, the array should be of shape (n_features,). Got {categorical_features.size} elements while `X` contains {n_features} features.')\n            is_categorical = [tuple((categorical_features[fx] for fx in fxs)) for fxs in features]\n        elif categorical_features.dtype.kind in ('i', 'O', 'U'):\n            categorical_features_idx = [_get_feature_index(cat, feature_names=feature_names) for cat in categorical_features]\n            is_categorical = [tuple([idx in categorical_features_idx for idx in fxs]) for fxs in features]\n        else:\n            raise ValueError(f'Expected `categorical_features` to be an array-like of boolean, integer, or string. Got {categorical_features.dtype} instead.')\n        for cats in is_categorical:\n            if np.size(cats) == 2 and cats[0] != cats[1]:\n                raise ValueError('Two-way partial dependence plots are not supported for pairs of continuous and categorical features.')\n        categorical_features_targeted = set([fx for (fxs, cats) in zip(features, is_categorical) for fx in fxs if any(cats)])\n        if categorical_features_targeted:\n            min_n_cats = min([len(_unique(_safe_indexing(X, idx, axis=1))) for idx in categorical_features_targeted])\n            if grid_resolution < min_n_cats:\n                raise ValueError(f'The resolution of the computed grid is less than the minimum number of categories in the targeted categorical features. Expect the `grid_resolution` to be greater than {min_n_cats}. Got {grid_resolution} instead.')\n        for (is_cat, kind_plot) in zip(is_categorical, kind_):\n            if any(is_cat) and kind_plot != 'average':\n                raise ValueError('It is not possible to display individual effects for categorical features.')\n    if ax is not None and (not isinstance(ax, plt.Axes)):\n        axes = np.asarray(ax, dtype=object)\n        if axes.size != len(features):\n            raise ValueError('Expected ax to have {} axes, got {}'.format(len(features), axes.size))\n    for i in chain.from_iterable(features):\n        if i >= len(feature_names):\n            raise ValueError('All entries of features must be less than len(feature_names) = {0}, got {1}.'.format(len(feature_names), i))\n    if isinstance(subsample, numbers.Integral):\n        if subsample <= 0:\n            raise ValueError(f'When an integer, subsample={subsample} should be positive.')\n    elif isinstance(subsample, numbers.Real):\n        if subsample <= 0 or subsample >= 1:\n            raise ValueError(f'When a floating-point, subsample={subsample} should be in the (0, 1) range.')\n    pd_results = Parallel(n_jobs=n_jobs, verbose=verbose)((delayed(partial_dependence)(estimator, X, fxs, sample_weight=sample_weight, feature_names=feature_names, categorical_features=categorical_features, response_method=response_method, method=method, grid_resolution=grid_resolution, percentiles=percentiles, kind=kind_plot) for (kind_plot, fxs) in zip(kind_, features)))\n    pd_result = pd_results[0]\n    n_tasks = pd_result.average.shape[0] if kind_[0] == 'average' else pd_result.individual.shape[0]\n    if is_regressor(estimator) and n_tasks > 1:\n        if target is None:\n            raise ValueError('target must be specified for multi-output regressors')\n        if not 0 <= target <= n_tasks:\n            raise ValueError('target must be in [0, n_tasks], got {}.'.format(target))\n        target_idx = target\n    deciles = {}\n    for (fxs, cats) in zip(features, is_categorical):\n        for (fx, cat) in zip(fxs, cats):\n            if not cat and fx not in deciles:\n                X_col = _safe_indexing(X, fx, axis=1)\n                deciles[fx] = mquantiles(X_col, prob=np.arange(0.1, 1.0, 0.1))\n    display = PartialDependenceDisplay(pd_results=pd_results, features=features, feature_names=feature_names, target_idx=target_idx, deciles=deciles, kind=kind, subsample=subsample, random_state=random_state, is_categorical=is_categorical)\n    return display.plot(ax=ax, n_cols=n_cols, line_kw=line_kw, ice_lines_kw=ice_lines_kw, pd_line_kw=pd_line_kw, contour_kw=contour_kw, centered=centered)",
            "@classmethod\ndef from_estimator(cls, estimator, X, features, *, sample_weight=None, categorical_features=None, feature_names=None, target=None, response_method='auto', n_cols=3, grid_resolution=100, percentiles=(0.05, 0.95), method='auto', n_jobs=None, verbose=0, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, ax=None, kind='average', centered=False, subsample=1000, random_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Partial dependence (PD) and individual conditional expectation (ICE) plots.\\n\\n        Partial dependence plots, individual conditional expectation plots or an\\n        overlay of both of them can be plotted by setting the ``kind``\\n        parameter. The ``len(features)`` plots are arranged in a grid with\\n        ``n_cols`` columns. Two-way partial dependence plots are plotted as\\n        contour plots. The deciles of the feature values will be shown with tick\\n        marks on the x-axes for one-way plots, and on both axes for two-way\\n        plots.\\n\\n        Read more in the :ref:`User Guide <partial_dependence>`.\\n\\n        .. note::\\n\\n            :func:`PartialDependenceDisplay.from_estimator` does not support using the\\n            same axes with multiple calls. To plot the partial dependence for\\n            multiple estimators, please pass the axes created by the first call to the\\n            second call::\\n\\n               >>> from sklearn.inspection import PartialDependenceDisplay\\n               >>> from sklearn.datasets import make_friedman1\\n               >>> from sklearn.linear_model import LinearRegression\\n               >>> from sklearn.ensemble import RandomForestRegressor\\n               >>> X, y = make_friedman1()\\n               >>> est1 = LinearRegression().fit(X, y)\\n               >>> est2 = RandomForestRegressor().fit(X, y)\\n               >>> disp1 = PartialDependenceDisplay.from_estimator(est1, X,\\n               ...                                                 [1, 2])\\n               >>> disp2 = PartialDependenceDisplay.from_estimator(est2, X, [1, 2],\\n               ...                                                 ax=disp1.axes_)\\n\\n        .. warning::\\n\\n            For :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, the\\n            `'recursion'` method (used by default) will not account for the `init`\\n            predictor of the boosting process. In practice, this will produce\\n            the same values as `'brute'` up to a constant offset in the target\\n            response, provided that `init` is a constant estimator (which is the\\n            default). However, if `init` is not a constant estimator, the\\n            partial dependence values are incorrect for `'recursion'` because the\\n            offset will be sample-dependent. It is preferable to use the `'brute'`\\n            method. Note that this only applies to\\n            :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, not to\\n            :class:`~sklearn.ensemble.HistGradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.HistGradientBoostingRegressor`.\\n\\n        .. versionadded:: 1.0\\n\\n        Parameters\\n        ----------\\n        estimator : BaseEstimator\\n            A fitted estimator object implementing :term:`predict`,\\n            :term:`predict_proba`, or :term:`decision_function`.\\n            Multioutput-multiclass classifiers are not supported.\\n\\n        X : {array-like, dataframe} of shape (n_samples, n_features)\\n            ``X`` is used to generate a grid of values for the target\\n            ``features`` (where the partial dependence will be evaluated), and\\n            also to generate values for the complement features when the\\n            `method` is `'brute'`.\\n\\n        features : list of {int, str, pair of int, pair of str}\\n            The target features for which to create the PDPs.\\n            If `features[i]` is an integer or a string, a one-way PDP is created;\\n            if `features[i]` is a tuple, a two-way PDP is created (only supported\\n            with `kind='average'`). Each tuple must be of size 2.\\n            If any entry is a string, then it must be in ``feature_names``.\\n\\n        sample_weight : array-like of shape (n_samples,), default=None\\n            Sample weights are used to calculate weighted means when averaging the\\n            model output. If `None`, then samples are equally weighted. If\\n            `sample_weight` is not `None`, then `method` will be set to `'brute'`.\\n            Note that `sample_weight` is ignored for `kind='individual'`.\\n\\n            .. versionadded:: 1.3\\n\\n        categorical_features : array-like of shape (n_features,) or shape                 (n_categorical_features,), dtype={bool, int, str}, default=None\\n            Indicates the categorical features.\\n\\n            - `None`: no feature will be considered categorical;\\n            - boolean array-like: boolean mask of shape `(n_features,)`\\n              indicating which features are categorical. Thus, this array has\\n              the same shape has `X.shape[1]`;\\n            - integer or string array-like: integer indices or strings\\n              indicating categorical features.\\n\\n            .. versionadded:: 1.2\\n\\n        feature_names : array-like of shape (n_features,), dtype=str, default=None\\n            Name of each feature; `feature_names[i]` holds the name of the feature\\n            with index `i`.\\n            By default, the name of the feature corresponds to their numerical\\n            index for NumPy array and their column name for pandas dataframe.\\n\\n        target : int, default=None\\n            - In a multiclass setting, specifies the class for which the PDPs\\n              should be computed. Note that for binary classification, the\\n              positive class (index 1) is always used.\\n            - In a multioutput setting, specifies the task for which the PDPs\\n              should be computed.\\n\\n            Ignored in binary classification or classical regression settings.\\n\\n        response_method : {'auto', 'predict_proba', 'decision_function'},                 default='auto'\\n            Specifies whether to use :term:`predict_proba` or\\n            :term:`decision_function` as the target response. For regressors\\n            this parameter is ignored and the response is always the output of\\n            :term:`predict`. By default, :term:`predict_proba` is tried first\\n            and we revert to :term:`decision_function` if it doesn't exist. If\\n            ``method`` is `'recursion'`, the response is always the output of\\n            :term:`decision_function`.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when `ax`\\n            is a single axis or `None`.\\n\\n        grid_resolution : int, default=100\\n            The number of equally spaced points on the axes of the plots, for each\\n            target feature.\\n\\n        percentiles : tuple of float, default=(0.05, 0.95)\\n            The lower and upper percentile used to create the extreme values\\n            for the PDP axes. Must be in [0, 1].\\n\\n        method : str, default='auto'\\n            The method used to calculate the averaged predictions:\\n\\n            - `'recursion'` is only supported for some tree-based estimators\\n              (namely\\n              :class:`~sklearn.ensemble.GradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.GradientBoostingRegressor`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,\\n              :class:`~sklearn.tree.DecisionTreeRegressor`,\\n              :class:`~sklearn.ensemble.RandomForestRegressor`\\n              but is more efficient in terms of speed.\\n              With this method, the target response of a\\n              classifier is always the decision function, not the predicted\\n              probabilities. Since the `'recursion'` method implicitly computes\\n              the average of the ICEs by design, it is not compatible with ICE and\\n              thus `kind` must be `'average'`.\\n\\n            - `'brute'` is supported for any estimator, but is more\\n              computationally intensive.\\n\\n            - `'auto'`: the `'recursion'` is used for estimators that support it,\\n              and `'brute'` is used otherwise. If `sample_weight` is not `None`,\\n              then `'brute'` is used regardless of the estimator.\\n\\n            Please see :ref:`this note <pdp_method_differences>` for\\n            differences between the `'brute'` and `'recursion'` method.\\n\\n        n_jobs : int, default=None\\n            The number of CPUs to use to compute the partial dependences.\\n            Computation is parallelized over features specified by the `features`\\n            parameter.\\n\\n            ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\\n            ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\\n            for more details.\\n\\n        verbose : int, default=0\\n            Verbose output during PD computations.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.plot`` call.\\n            For one-way partial dependence plots. It can be used to define common\\n            properties for both `ice_lines_kw` and `pdp_line_kw`.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.contourf`` call.\\n            For two-way partial dependence plots.\\n\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n              and a grid of partial dependence plots will be drawn within\\n              these bounds. The `n_cols` parameter controls the number of\\n              columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n              plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n              as the single axes case.\\n\\n        kind : {'average', 'individual', 'both'}, default='average'\\n            Whether to plot the partial dependence averaged across all the samples\\n            in the dataset or one line per sample or both.\\n\\n            - ``kind='average'`` results in the traditional PD plot;\\n            - ``kind='individual'`` results in the ICE plot.\\n\\n           Note that the fast `method='recursion'` option is only available for\\n           `kind='average'` and `sample_weights=None`. Computing individual\\n           dependencies and doing weighted averages requires using the slower\\n           `method='brute'`.\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        subsample : float, int or None, default=1000\\n            Sampling for ICE curves when `kind` is 'individual' or 'both'.\\n            If `float`, should be between 0.0 and 1.0 and represent the proportion\\n            of the dataset to be used to plot ICE curves. If `int`, represents the\\n            absolute number samples to use.\\n\\n            Note that the full dataset is still used to calculate averaged partial\\n            dependence when `kind='both'`.\\n\\n        random_state : int, RandomState instance or None, default=None\\n            Controls the randomness of the selected samples when subsamples is not\\n            `None` and `kind` is either `'both'` or `'individual'`.\\n            See :term:`Glossary <random_state>` for details.\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n\\n        See Also\\n        --------\\n        partial_dependence : Compute Partial Dependence values.\\n\\n        Examples\\n        --------\\n        >>> import matplotlib.pyplot as plt\\n        >>> from sklearn.datasets import make_friedman1\\n        >>> from sklearn.ensemble import GradientBoostingRegressor\\n        >>> from sklearn.inspection import PartialDependenceDisplay\\n        >>> X, y = make_friedman1()\\n        >>> clf = GradientBoostingRegressor(n_estimators=10).fit(X, y)\\n        >>> PartialDependenceDisplay.from_estimator(clf, X, [0, (0, 1)])\\n        <...>\\n        >>> plt.show()\\n        \"\n    check_matplotlib_support(f'{cls.__name__}.from_estimator')\n    import matplotlib.pyplot as plt\n    if hasattr(estimator, 'classes_') and np.size(estimator.classes_) > 2:\n        if target is None:\n            raise ValueError('target must be specified for multi-class')\n        target_idx = np.searchsorted(estimator.classes_, target)\n        if not 0 <= target_idx < len(estimator.classes_) or estimator.classes_[target_idx] != target:\n            raise ValueError('target not in est.classes_, got {}'.format(target))\n    else:\n        target_idx = 0\n    if not (hasattr(X, '__array__') or sparse.issparse(X)):\n        X = check_array(X, force_all_finite='allow-nan', dtype=object)\n    n_features = X.shape[1]\n    feature_names = _check_feature_names(X, feature_names)\n    kind_ = [kind] * len(features) if isinstance(kind, str) else kind\n    if len(kind_) != len(features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind_)} element(s) and `features` contains {len(features)} element(s).')\n    (tmp_features, ice_for_two_way_pd) = ([], [])\n    for (kind_plot, fxs) in zip(kind_, features):\n        if isinstance(fxs, (numbers.Integral, str)):\n            fxs = (fxs,)\n        try:\n            fxs = tuple((_get_feature_index(fx, feature_names=feature_names) for fx in fxs))\n        except TypeError as e:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.') from e\n        if not 1 <= np.size(fxs) <= 2:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.')\n        ice_for_two_way_pd.append(kind_plot != 'average' and np.size(fxs) > 1)\n        tmp_features.append(fxs)\n    if any(ice_for_two_way_pd):\n        kind_ = ['average' if forcing_average else kind_plot for (forcing_average, kind_plot) in zip(ice_for_two_way_pd, kind_)]\n        raise ValueError(f\"ICE plot cannot be rendered for 2-way feature interactions. 2-way feature interactions mandates PD plots using the 'average' kind: features={features!r} should be configured to use kind={kind_!r} explicitly.\")\n    features = tmp_features\n    if categorical_features is None:\n        is_categorical = [(False,) if len(fxs) == 1 else (False, False) for fxs in features]\n    else:\n        categorical_features = np.array(categorical_features, copy=False)\n        if categorical_features.dtype.kind == 'b':\n            if categorical_features.size != n_features:\n                raise ValueError(f'When `categorical_features` is a boolean array-like, the array should be of shape (n_features,). Got {categorical_features.size} elements while `X` contains {n_features} features.')\n            is_categorical = [tuple((categorical_features[fx] for fx in fxs)) for fxs in features]\n        elif categorical_features.dtype.kind in ('i', 'O', 'U'):\n            categorical_features_idx = [_get_feature_index(cat, feature_names=feature_names) for cat in categorical_features]\n            is_categorical = [tuple([idx in categorical_features_idx for idx in fxs]) for fxs in features]\n        else:\n            raise ValueError(f'Expected `categorical_features` to be an array-like of boolean, integer, or string. Got {categorical_features.dtype} instead.')\n        for cats in is_categorical:\n            if np.size(cats) == 2 and cats[0] != cats[1]:\n                raise ValueError('Two-way partial dependence plots are not supported for pairs of continuous and categorical features.')\n        categorical_features_targeted = set([fx for (fxs, cats) in zip(features, is_categorical) for fx in fxs if any(cats)])\n        if categorical_features_targeted:\n            min_n_cats = min([len(_unique(_safe_indexing(X, idx, axis=1))) for idx in categorical_features_targeted])\n            if grid_resolution < min_n_cats:\n                raise ValueError(f'The resolution of the computed grid is less than the minimum number of categories in the targeted categorical features. Expect the `grid_resolution` to be greater than {min_n_cats}. Got {grid_resolution} instead.')\n        for (is_cat, kind_plot) in zip(is_categorical, kind_):\n            if any(is_cat) and kind_plot != 'average':\n                raise ValueError('It is not possible to display individual effects for categorical features.')\n    if ax is not None and (not isinstance(ax, plt.Axes)):\n        axes = np.asarray(ax, dtype=object)\n        if axes.size != len(features):\n            raise ValueError('Expected ax to have {} axes, got {}'.format(len(features), axes.size))\n    for i in chain.from_iterable(features):\n        if i >= len(feature_names):\n            raise ValueError('All entries of features must be less than len(feature_names) = {0}, got {1}.'.format(len(feature_names), i))\n    if isinstance(subsample, numbers.Integral):\n        if subsample <= 0:\n            raise ValueError(f'When an integer, subsample={subsample} should be positive.')\n    elif isinstance(subsample, numbers.Real):\n        if subsample <= 0 or subsample >= 1:\n            raise ValueError(f'When a floating-point, subsample={subsample} should be in the (0, 1) range.')\n    pd_results = Parallel(n_jobs=n_jobs, verbose=verbose)((delayed(partial_dependence)(estimator, X, fxs, sample_weight=sample_weight, feature_names=feature_names, categorical_features=categorical_features, response_method=response_method, method=method, grid_resolution=grid_resolution, percentiles=percentiles, kind=kind_plot) for (kind_plot, fxs) in zip(kind_, features)))\n    pd_result = pd_results[0]\n    n_tasks = pd_result.average.shape[0] if kind_[0] == 'average' else pd_result.individual.shape[0]\n    if is_regressor(estimator) and n_tasks > 1:\n        if target is None:\n            raise ValueError('target must be specified for multi-output regressors')\n        if not 0 <= target <= n_tasks:\n            raise ValueError('target must be in [0, n_tasks], got {}.'.format(target))\n        target_idx = target\n    deciles = {}\n    for (fxs, cats) in zip(features, is_categorical):\n        for (fx, cat) in zip(fxs, cats):\n            if not cat and fx not in deciles:\n                X_col = _safe_indexing(X, fx, axis=1)\n                deciles[fx] = mquantiles(X_col, prob=np.arange(0.1, 1.0, 0.1))\n    display = PartialDependenceDisplay(pd_results=pd_results, features=features, feature_names=feature_names, target_idx=target_idx, deciles=deciles, kind=kind, subsample=subsample, random_state=random_state, is_categorical=is_categorical)\n    return display.plot(ax=ax, n_cols=n_cols, line_kw=line_kw, ice_lines_kw=ice_lines_kw, pd_line_kw=pd_line_kw, contour_kw=contour_kw, centered=centered)",
            "@classmethod\ndef from_estimator(cls, estimator, X, features, *, sample_weight=None, categorical_features=None, feature_names=None, target=None, response_method='auto', n_cols=3, grid_resolution=100, percentiles=(0.05, 0.95), method='auto', n_jobs=None, verbose=0, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, ax=None, kind='average', centered=False, subsample=1000, random_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Partial dependence (PD) and individual conditional expectation (ICE) plots.\\n\\n        Partial dependence plots, individual conditional expectation plots or an\\n        overlay of both of them can be plotted by setting the ``kind``\\n        parameter. The ``len(features)`` plots are arranged in a grid with\\n        ``n_cols`` columns. Two-way partial dependence plots are plotted as\\n        contour plots. The deciles of the feature values will be shown with tick\\n        marks on the x-axes for one-way plots, and on both axes for two-way\\n        plots.\\n\\n        Read more in the :ref:`User Guide <partial_dependence>`.\\n\\n        .. note::\\n\\n            :func:`PartialDependenceDisplay.from_estimator` does not support using the\\n            same axes with multiple calls. To plot the partial dependence for\\n            multiple estimators, please pass the axes created by the first call to the\\n            second call::\\n\\n               >>> from sklearn.inspection import PartialDependenceDisplay\\n               >>> from sklearn.datasets import make_friedman1\\n               >>> from sklearn.linear_model import LinearRegression\\n               >>> from sklearn.ensemble import RandomForestRegressor\\n               >>> X, y = make_friedman1()\\n               >>> est1 = LinearRegression().fit(X, y)\\n               >>> est2 = RandomForestRegressor().fit(X, y)\\n               >>> disp1 = PartialDependenceDisplay.from_estimator(est1, X,\\n               ...                                                 [1, 2])\\n               >>> disp2 = PartialDependenceDisplay.from_estimator(est2, X, [1, 2],\\n               ...                                                 ax=disp1.axes_)\\n\\n        .. warning::\\n\\n            For :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, the\\n            `'recursion'` method (used by default) will not account for the `init`\\n            predictor of the boosting process. In practice, this will produce\\n            the same values as `'brute'` up to a constant offset in the target\\n            response, provided that `init` is a constant estimator (which is the\\n            default). However, if `init` is not a constant estimator, the\\n            partial dependence values are incorrect for `'recursion'` because the\\n            offset will be sample-dependent. It is preferable to use the `'brute'`\\n            method. Note that this only applies to\\n            :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, not to\\n            :class:`~sklearn.ensemble.HistGradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.HistGradientBoostingRegressor`.\\n\\n        .. versionadded:: 1.0\\n\\n        Parameters\\n        ----------\\n        estimator : BaseEstimator\\n            A fitted estimator object implementing :term:`predict`,\\n            :term:`predict_proba`, or :term:`decision_function`.\\n            Multioutput-multiclass classifiers are not supported.\\n\\n        X : {array-like, dataframe} of shape (n_samples, n_features)\\n            ``X`` is used to generate a grid of values for the target\\n            ``features`` (where the partial dependence will be evaluated), and\\n            also to generate values for the complement features when the\\n            `method` is `'brute'`.\\n\\n        features : list of {int, str, pair of int, pair of str}\\n            The target features for which to create the PDPs.\\n            If `features[i]` is an integer or a string, a one-way PDP is created;\\n            if `features[i]` is a tuple, a two-way PDP is created (only supported\\n            with `kind='average'`). Each tuple must be of size 2.\\n            If any entry is a string, then it must be in ``feature_names``.\\n\\n        sample_weight : array-like of shape (n_samples,), default=None\\n            Sample weights are used to calculate weighted means when averaging the\\n            model output. If `None`, then samples are equally weighted. If\\n            `sample_weight` is not `None`, then `method` will be set to `'brute'`.\\n            Note that `sample_weight` is ignored for `kind='individual'`.\\n\\n            .. versionadded:: 1.3\\n\\n        categorical_features : array-like of shape (n_features,) or shape                 (n_categorical_features,), dtype={bool, int, str}, default=None\\n            Indicates the categorical features.\\n\\n            - `None`: no feature will be considered categorical;\\n            - boolean array-like: boolean mask of shape `(n_features,)`\\n              indicating which features are categorical. Thus, this array has\\n              the same shape has `X.shape[1]`;\\n            - integer or string array-like: integer indices or strings\\n              indicating categorical features.\\n\\n            .. versionadded:: 1.2\\n\\n        feature_names : array-like of shape (n_features,), dtype=str, default=None\\n            Name of each feature; `feature_names[i]` holds the name of the feature\\n            with index `i`.\\n            By default, the name of the feature corresponds to their numerical\\n            index for NumPy array and their column name for pandas dataframe.\\n\\n        target : int, default=None\\n            - In a multiclass setting, specifies the class for which the PDPs\\n              should be computed. Note that for binary classification, the\\n              positive class (index 1) is always used.\\n            - In a multioutput setting, specifies the task for which the PDPs\\n              should be computed.\\n\\n            Ignored in binary classification or classical regression settings.\\n\\n        response_method : {'auto', 'predict_proba', 'decision_function'},                 default='auto'\\n            Specifies whether to use :term:`predict_proba` or\\n            :term:`decision_function` as the target response. For regressors\\n            this parameter is ignored and the response is always the output of\\n            :term:`predict`. By default, :term:`predict_proba` is tried first\\n            and we revert to :term:`decision_function` if it doesn't exist. If\\n            ``method`` is `'recursion'`, the response is always the output of\\n            :term:`decision_function`.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when `ax`\\n            is a single axis or `None`.\\n\\n        grid_resolution : int, default=100\\n            The number of equally spaced points on the axes of the plots, for each\\n            target feature.\\n\\n        percentiles : tuple of float, default=(0.05, 0.95)\\n            The lower and upper percentile used to create the extreme values\\n            for the PDP axes. Must be in [0, 1].\\n\\n        method : str, default='auto'\\n            The method used to calculate the averaged predictions:\\n\\n            - `'recursion'` is only supported for some tree-based estimators\\n              (namely\\n              :class:`~sklearn.ensemble.GradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.GradientBoostingRegressor`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,\\n              :class:`~sklearn.tree.DecisionTreeRegressor`,\\n              :class:`~sklearn.ensemble.RandomForestRegressor`\\n              but is more efficient in terms of speed.\\n              With this method, the target response of a\\n              classifier is always the decision function, not the predicted\\n              probabilities. Since the `'recursion'` method implicitly computes\\n              the average of the ICEs by design, it is not compatible with ICE and\\n              thus `kind` must be `'average'`.\\n\\n            - `'brute'` is supported for any estimator, but is more\\n              computationally intensive.\\n\\n            - `'auto'`: the `'recursion'` is used for estimators that support it,\\n              and `'brute'` is used otherwise. If `sample_weight` is not `None`,\\n              then `'brute'` is used regardless of the estimator.\\n\\n            Please see :ref:`this note <pdp_method_differences>` for\\n            differences between the `'brute'` and `'recursion'` method.\\n\\n        n_jobs : int, default=None\\n            The number of CPUs to use to compute the partial dependences.\\n            Computation is parallelized over features specified by the `features`\\n            parameter.\\n\\n            ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\\n            ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\\n            for more details.\\n\\n        verbose : int, default=0\\n            Verbose output during PD computations.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.plot`` call.\\n            For one-way partial dependence plots. It can be used to define common\\n            properties for both `ice_lines_kw` and `pdp_line_kw`.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.contourf`` call.\\n            For two-way partial dependence plots.\\n\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n              and a grid of partial dependence plots will be drawn within\\n              these bounds. The `n_cols` parameter controls the number of\\n              columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n              plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n              as the single axes case.\\n\\n        kind : {'average', 'individual', 'both'}, default='average'\\n            Whether to plot the partial dependence averaged across all the samples\\n            in the dataset or one line per sample or both.\\n\\n            - ``kind='average'`` results in the traditional PD plot;\\n            - ``kind='individual'`` results in the ICE plot.\\n\\n           Note that the fast `method='recursion'` option is only available for\\n           `kind='average'` and `sample_weights=None`. Computing individual\\n           dependencies and doing weighted averages requires using the slower\\n           `method='brute'`.\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        subsample : float, int or None, default=1000\\n            Sampling for ICE curves when `kind` is 'individual' or 'both'.\\n            If `float`, should be between 0.0 and 1.0 and represent the proportion\\n            of the dataset to be used to plot ICE curves. If `int`, represents the\\n            absolute number samples to use.\\n\\n            Note that the full dataset is still used to calculate averaged partial\\n            dependence when `kind='both'`.\\n\\n        random_state : int, RandomState instance or None, default=None\\n            Controls the randomness of the selected samples when subsamples is not\\n            `None` and `kind` is either `'both'` or `'individual'`.\\n            See :term:`Glossary <random_state>` for details.\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n\\n        See Also\\n        --------\\n        partial_dependence : Compute Partial Dependence values.\\n\\n        Examples\\n        --------\\n        >>> import matplotlib.pyplot as plt\\n        >>> from sklearn.datasets import make_friedman1\\n        >>> from sklearn.ensemble import GradientBoostingRegressor\\n        >>> from sklearn.inspection import PartialDependenceDisplay\\n        >>> X, y = make_friedman1()\\n        >>> clf = GradientBoostingRegressor(n_estimators=10).fit(X, y)\\n        >>> PartialDependenceDisplay.from_estimator(clf, X, [0, (0, 1)])\\n        <...>\\n        >>> plt.show()\\n        \"\n    check_matplotlib_support(f'{cls.__name__}.from_estimator')\n    import matplotlib.pyplot as plt\n    if hasattr(estimator, 'classes_') and np.size(estimator.classes_) > 2:\n        if target is None:\n            raise ValueError('target must be specified for multi-class')\n        target_idx = np.searchsorted(estimator.classes_, target)\n        if not 0 <= target_idx < len(estimator.classes_) or estimator.classes_[target_idx] != target:\n            raise ValueError('target not in est.classes_, got {}'.format(target))\n    else:\n        target_idx = 0\n    if not (hasattr(X, '__array__') or sparse.issparse(X)):\n        X = check_array(X, force_all_finite='allow-nan', dtype=object)\n    n_features = X.shape[1]\n    feature_names = _check_feature_names(X, feature_names)\n    kind_ = [kind] * len(features) if isinstance(kind, str) else kind\n    if len(kind_) != len(features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind_)} element(s) and `features` contains {len(features)} element(s).')\n    (tmp_features, ice_for_two_way_pd) = ([], [])\n    for (kind_plot, fxs) in zip(kind_, features):\n        if isinstance(fxs, (numbers.Integral, str)):\n            fxs = (fxs,)\n        try:\n            fxs = tuple((_get_feature_index(fx, feature_names=feature_names) for fx in fxs))\n        except TypeError as e:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.') from e\n        if not 1 <= np.size(fxs) <= 2:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.')\n        ice_for_two_way_pd.append(kind_plot != 'average' and np.size(fxs) > 1)\n        tmp_features.append(fxs)\n    if any(ice_for_two_way_pd):\n        kind_ = ['average' if forcing_average else kind_plot for (forcing_average, kind_plot) in zip(ice_for_two_way_pd, kind_)]\n        raise ValueError(f\"ICE plot cannot be rendered for 2-way feature interactions. 2-way feature interactions mandates PD plots using the 'average' kind: features={features!r} should be configured to use kind={kind_!r} explicitly.\")\n    features = tmp_features\n    if categorical_features is None:\n        is_categorical = [(False,) if len(fxs) == 1 else (False, False) for fxs in features]\n    else:\n        categorical_features = np.array(categorical_features, copy=False)\n        if categorical_features.dtype.kind == 'b':\n            if categorical_features.size != n_features:\n                raise ValueError(f'When `categorical_features` is a boolean array-like, the array should be of shape (n_features,). Got {categorical_features.size} elements while `X` contains {n_features} features.')\n            is_categorical = [tuple((categorical_features[fx] for fx in fxs)) for fxs in features]\n        elif categorical_features.dtype.kind in ('i', 'O', 'U'):\n            categorical_features_idx = [_get_feature_index(cat, feature_names=feature_names) for cat in categorical_features]\n            is_categorical = [tuple([idx in categorical_features_idx for idx in fxs]) for fxs in features]\n        else:\n            raise ValueError(f'Expected `categorical_features` to be an array-like of boolean, integer, or string. Got {categorical_features.dtype} instead.')\n        for cats in is_categorical:\n            if np.size(cats) == 2 and cats[0] != cats[1]:\n                raise ValueError('Two-way partial dependence plots are not supported for pairs of continuous and categorical features.')\n        categorical_features_targeted = set([fx for (fxs, cats) in zip(features, is_categorical) for fx in fxs if any(cats)])\n        if categorical_features_targeted:\n            min_n_cats = min([len(_unique(_safe_indexing(X, idx, axis=1))) for idx in categorical_features_targeted])\n            if grid_resolution < min_n_cats:\n                raise ValueError(f'The resolution of the computed grid is less than the minimum number of categories in the targeted categorical features. Expect the `grid_resolution` to be greater than {min_n_cats}. Got {grid_resolution} instead.')\n        for (is_cat, kind_plot) in zip(is_categorical, kind_):\n            if any(is_cat) and kind_plot != 'average':\n                raise ValueError('It is not possible to display individual effects for categorical features.')\n    if ax is not None and (not isinstance(ax, plt.Axes)):\n        axes = np.asarray(ax, dtype=object)\n        if axes.size != len(features):\n            raise ValueError('Expected ax to have {} axes, got {}'.format(len(features), axes.size))\n    for i in chain.from_iterable(features):\n        if i >= len(feature_names):\n            raise ValueError('All entries of features must be less than len(feature_names) = {0}, got {1}.'.format(len(feature_names), i))\n    if isinstance(subsample, numbers.Integral):\n        if subsample <= 0:\n            raise ValueError(f'When an integer, subsample={subsample} should be positive.')\n    elif isinstance(subsample, numbers.Real):\n        if subsample <= 0 or subsample >= 1:\n            raise ValueError(f'When a floating-point, subsample={subsample} should be in the (0, 1) range.')\n    pd_results = Parallel(n_jobs=n_jobs, verbose=verbose)((delayed(partial_dependence)(estimator, X, fxs, sample_weight=sample_weight, feature_names=feature_names, categorical_features=categorical_features, response_method=response_method, method=method, grid_resolution=grid_resolution, percentiles=percentiles, kind=kind_plot) for (kind_plot, fxs) in zip(kind_, features)))\n    pd_result = pd_results[0]\n    n_tasks = pd_result.average.shape[0] if kind_[0] == 'average' else pd_result.individual.shape[0]\n    if is_regressor(estimator) and n_tasks > 1:\n        if target is None:\n            raise ValueError('target must be specified for multi-output regressors')\n        if not 0 <= target <= n_tasks:\n            raise ValueError('target must be in [0, n_tasks], got {}.'.format(target))\n        target_idx = target\n    deciles = {}\n    for (fxs, cats) in zip(features, is_categorical):\n        for (fx, cat) in zip(fxs, cats):\n            if not cat and fx not in deciles:\n                X_col = _safe_indexing(X, fx, axis=1)\n                deciles[fx] = mquantiles(X_col, prob=np.arange(0.1, 1.0, 0.1))\n    display = PartialDependenceDisplay(pd_results=pd_results, features=features, feature_names=feature_names, target_idx=target_idx, deciles=deciles, kind=kind, subsample=subsample, random_state=random_state, is_categorical=is_categorical)\n    return display.plot(ax=ax, n_cols=n_cols, line_kw=line_kw, ice_lines_kw=ice_lines_kw, pd_line_kw=pd_line_kw, contour_kw=contour_kw, centered=centered)",
            "@classmethod\ndef from_estimator(cls, estimator, X, features, *, sample_weight=None, categorical_features=None, feature_names=None, target=None, response_method='auto', n_cols=3, grid_resolution=100, percentiles=(0.05, 0.95), method='auto', n_jobs=None, verbose=0, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, ax=None, kind='average', centered=False, subsample=1000, random_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Partial dependence (PD) and individual conditional expectation (ICE) plots.\\n\\n        Partial dependence plots, individual conditional expectation plots or an\\n        overlay of both of them can be plotted by setting the ``kind``\\n        parameter. The ``len(features)`` plots are arranged in a grid with\\n        ``n_cols`` columns. Two-way partial dependence plots are plotted as\\n        contour plots. The deciles of the feature values will be shown with tick\\n        marks on the x-axes for one-way plots, and on both axes for two-way\\n        plots.\\n\\n        Read more in the :ref:`User Guide <partial_dependence>`.\\n\\n        .. note::\\n\\n            :func:`PartialDependenceDisplay.from_estimator` does not support using the\\n            same axes with multiple calls. To plot the partial dependence for\\n            multiple estimators, please pass the axes created by the first call to the\\n            second call::\\n\\n               >>> from sklearn.inspection import PartialDependenceDisplay\\n               >>> from sklearn.datasets import make_friedman1\\n               >>> from sklearn.linear_model import LinearRegression\\n               >>> from sklearn.ensemble import RandomForestRegressor\\n               >>> X, y = make_friedman1()\\n               >>> est1 = LinearRegression().fit(X, y)\\n               >>> est2 = RandomForestRegressor().fit(X, y)\\n               >>> disp1 = PartialDependenceDisplay.from_estimator(est1, X,\\n               ...                                                 [1, 2])\\n               >>> disp2 = PartialDependenceDisplay.from_estimator(est2, X, [1, 2],\\n               ...                                                 ax=disp1.axes_)\\n\\n        .. warning::\\n\\n            For :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, the\\n            `'recursion'` method (used by default) will not account for the `init`\\n            predictor of the boosting process. In practice, this will produce\\n            the same values as `'brute'` up to a constant offset in the target\\n            response, provided that `init` is a constant estimator (which is the\\n            default). However, if `init` is not a constant estimator, the\\n            partial dependence values are incorrect for `'recursion'` because the\\n            offset will be sample-dependent. It is preferable to use the `'brute'`\\n            method. Note that this only applies to\\n            :class:`~sklearn.ensemble.GradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.GradientBoostingRegressor`, not to\\n            :class:`~sklearn.ensemble.HistGradientBoostingClassifier` and\\n            :class:`~sklearn.ensemble.HistGradientBoostingRegressor`.\\n\\n        .. versionadded:: 1.0\\n\\n        Parameters\\n        ----------\\n        estimator : BaseEstimator\\n            A fitted estimator object implementing :term:`predict`,\\n            :term:`predict_proba`, or :term:`decision_function`.\\n            Multioutput-multiclass classifiers are not supported.\\n\\n        X : {array-like, dataframe} of shape (n_samples, n_features)\\n            ``X`` is used to generate a grid of values for the target\\n            ``features`` (where the partial dependence will be evaluated), and\\n            also to generate values for the complement features when the\\n            `method` is `'brute'`.\\n\\n        features : list of {int, str, pair of int, pair of str}\\n            The target features for which to create the PDPs.\\n            If `features[i]` is an integer or a string, a one-way PDP is created;\\n            if `features[i]` is a tuple, a two-way PDP is created (only supported\\n            with `kind='average'`). Each tuple must be of size 2.\\n            If any entry is a string, then it must be in ``feature_names``.\\n\\n        sample_weight : array-like of shape (n_samples,), default=None\\n            Sample weights are used to calculate weighted means when averaging the\\n            model output. If `None`, then samples are equally weighted. If\\n            `sample_weight` is not `None`, then `method` will be set to `'brute'`.\\n            Note that `sample_weight` is ignored for `kind='individual'`.\\n\\n            .. versionadded:: 1.3\\n\\n        categorical_features : array-like of shape (n_features,) or shape                 (n_categorical_features,), dtype={bool, int, str}, default=None\\n            Indicates the categorical features.\\n\\n            - `None`: no feature will be considered categorical;\\n            - boolean array-like: boolean mask of shape `(n_features,)`\\n              indicating which features are categorical. Thus, this array has\\n              the same shape has `X.shape[1]`;\\n            - integer or string array-like: integer indices or strings\\n              indicating categorical features.\\n\\n            .. versionadded:: 1.2\\n\\n        feature_names : array-like of shape (n_features,), dtype=str, default=None\\n            Name of each feature; `feature_names[i]` holds the name of the feature\\n            with index `i`.\\n            By default, the name of the feature corresponds to their numerical\\n            index for NumPy array and their column name for pandas dataframe.\\n\\n        target : int, default=None\\n            - In a multiclass setting, specifies the class for which the PDPs\\n              should be computed. Note that for binary classification, the\\n              positive class (index 1) is always used.\\n            - In a multioutput setting, specifies the task for which the PDPs\\n              should be computed.\\n\\n            Ignored in binary classification or classical regression settings.\\n\\n        response_method : {'auto', 'predict_proba', 'decision_function'},                 default='auto'\\n            Specifies whether to use :term:`predict_proba` or\\n            :term:`decision_function` as the target response. For regressors\\n            this parameter is ignored and the response is always the output of\\n            :term:`predict`. By default, :term:`predict_proba` is tried first\\n            and we revert to :term:`decision_function` if it doesn't exist. If\\n            ``method`` is `'recursion'`, the response is always the output of\\n            :term:`decision_function`.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when `ax`\\n            is a single axis or `None`.\\n\\n        grid_resolution : int, default=100\\n            The number of equally spaced points on the axes of the plots, for each\\n            target feature.\\n\\n        percentiles : tuple of float, default=(0.05, 0.95)\\n            The lower and upper percentile used to create the extreme values\\n            for the PDP axes. Must be in [0, 1].\\n\\n        method : str, default='auto'\\n            The method used to calculate the averaged predictions:\\n\\n            - `'recursion'` is only supported for some tree-based estimators\\n              (namely\\n              :class:`~sklearn.ensemble.GradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.GradientBoostingRegressor`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingClassifier`,\\n              :class:`~sklearn.ensemble.HistGradientBoostingRegressor`,\\n              :class:`~sklearn.tree.DecisionTreeRegressor`,\\n              :class:`~sklearn.ensemble.RandomForestRegressor`\\n              but is more efficient in terms of speed.\\n              With this method, the target response of a\\n              classifier is always the decision function, not the predicted\\n              probabilities. Since the `'recursion'` method implicitly computes\\n              the average of the ICEs by design, it is not compatible with ICE and\\n              thus `kind` must be `'average'`.\\n\\n            - `'brute'` is supported for any estimator, but is more\\n              computationally intensive.\\n\\n            - `'auto'`: the `'recursion'` is used for estimators that support it,\\n              and `'brute'` is used otherwise. If `sample_weight` is not `None`,\\n              then `'brute'` is used regardless of the estimator.\\n\\n            Please see :ref:`this note <pdp_method_differences>` for\\n            differences between the `'brute'` and `'recursion'` method.\\n\\n        n_jobs : int, default=None\\n            The number of CPUs to use to compute the partial dependences.\\n            Computation is parallelized over features specified by the `features`\\n            parameter.\\n\\n            ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\\n            ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\\n            for more details.\\n\\n        verbose : int, default=0\\n            Verbose output during PD computations.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.plot`` call.\\n            For one-way partial dependence plots. It can be used to define common\\n            properties for both `ice_lines_kw` and `pdp_line_kw`.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the ``matplotlib.pyplot.contourf`` call.\\n            For two-way partial dependence plots.\\n\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n              and a grid of partial dependence plots will be drawn within\\n              these bounds. The `n_cols` parameter controls the number of\\n              columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n              plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n              as the single axes case.\\n\\n        kind : {'average', 'individual', 'both'}, default='average'\\n            Whether to plot the partial dependence averaged across all the samples\\n            in the dataset or one line per sample or both.\\n\\n            - ``kind='average'`` results in the traditional PD plot;\\n            - ``kind='individual'`` results in the ICE plot.\\n\\n           Note that the fast `method='recursion'` option is only available for\\n           `kind='average'` and `sample_weights=None`. Computing individual\\n           dependencies and doing weighted averages requires using the slower\\n           `method='brute'`.\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        subsample : float, int or None, default=1000\\n            Sampling for ICE curves when `kind` is 'individual' or 'both'.\\n            If `float`, should be between 0.0 and 1.0 and represent the proportion\\n            of the dataset to be used to plot ICE curves. If `int`, represents the\\n            absolute number samples to use.\\n\\n            Note that the full dataset is still used to calculate averaged partial\\n            dependence when `kind='both'`.\\n\\n        random_state : int, RandomState instance or None, default=None\\n            Controls the randomness of the selected samples when subsamples is not\\n            `None` and `kind` is either `'both'` or `'individual'`.\\n            See :term:`Glossary <random_state>` for details.\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n\\n        See Also\\n        --------\\n        partial_dependence : Compute Partial Dependence values.\\n\\n        Examples\\n        --------\\n        >>> import matplotlib.pyplot as plt\\n        >>> from sklearn.datasets import make_friedman1\\n        >>> from sklearn.ensemble import GradientBoostingRegressor\\n        >>> from sklearn.inspection import PartialDependenceDisplay\\n        >>> X, y = make_friedman1()\\n        >>> clf = GradientBoostingRegressor(n_estimators=10).fit(X, y)\\n        >>> PartialDependenceDisplay.from_estimator(clf, X, [0, (0, 1)])\\n        <...>\\n        >>> plt.show()\\n        \"\n    check_matplotlib_support(f'{cls.__name__}.from_estimator')\n    import matplotlib.pyplot as plt\n    if hasattr(estimator, 'classes_') and np.size(estimator.classes_) > 2:\n        if target is None:\n            raise ValueError('target must be specified for multi-class')\n        target_idx = np.searchsorted(estimator.classes_, target)\n        if not 0 <= target_idx < len(estimator.classes_) or estimator.classes_[target_idx] != target:\n            raise ValueError('target not in est.classes_, got {}'.format(target))\n    else:\n        target_idx = 0\n    if not (hasattr(X, '__array__') or sparse.issparse(X)):\n        X = check_array(X, force_all_finite='allow-nan', dtype=object)\n    n_features = X.shape[1]\n    feature_names = _check_feature_names(X, feature_names)\n    kind_ = [kind] * len(features) if isinstance(kind, str) else kind\n    if len(kind_) != len(features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind_)} element(s) and `features` contains {len(features)} element(s).')\n    (tmp_features, ice_for_two_way_pd) = ([], [])\n    for (kind_plot, fxs) in zip(kind_, features):\n        if isinstance(fxs, (numbers.Integral, str)):\n            fxs = (fxs,)\n        try:\n            fxs = tuple((_get_feature_index(fx, feature_names=feature_names) for fx in fxs))\n        except TypeError as e:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.') from e\n        if not 1 <= np.size(fxs) <= 2:\n            raise ValueError('Each entry in features must be either an int, a string, or an iterable of size at most 2.')\n        ice_for_two_way_pd.append(kind_plot != 'average' and np.size(fxs) > 1)\n        tmp_features.append(fxs)\n    if any(ice_for_two_way_pd):\n        kind_ = ['average' if forcing_average else kind_plot for (forcing_average, kind_plot) in zip(ice_for_two_way_pd, kind_)]\n        raise ValueError(f\"ICE plot cannot be rendered for 2-way feature interactions. 2-way feature interactions mandates PD plots using the 'average' kind: features={features!r} should be configured to use kind={kind_!r} explicitly.\")\n    features = tmp_features\n    if categorical_features is None:\n        is_categorical = [(False,) if len(fxs) == 1 else (False, False) for fxs in features]\n    else:\n        categorical_features = np.array(categorical_features, copy=False)\n        if categorical_features.dtype.kind == 'b':\n            if categorical_features.size != n_features:\n                raise ValueError(f'When `categorical_features` is a boolean array-like, the array should be of shape (n_features,). Got {categorical_features.size} elements while `X` contains {n_features} features.')\n            is_categorical = [tuple((categorical_features[fx] for fx in fxs)) for fxs in features]\n        elif categorical_features.dtype.kind in ('i', 'O', 'U'):\n            categorical_features_idx = [_get_feature_index(cat, feature_names=feature_names) for cat in categorical_features]\n            is_categorical = [tuple([idx in categorical_features_idx for idx in fxs]) for fxs in features]\n        else:\n            raise ValueError(f'Expected `categorical_features` to be an array-like of boolean, integer, or string. Got {categorical_features.dtype} instead.')\n        for cats in is_categorical:\n            if np.size(cats) == 2 and cats[0] != cats[1]:\n                raise ValueError('Two-way partial dependence plots are not supported for pairs of continuous and categorical features.')\n        categorical_features_targeted = set([fx for (fxs, cats) in zip(features, is_categorical) for fx in fxs if any(cats)])\n        if categorical_features_targeted:\n            min_n_cats = min([len(_unique(_safe_indexing(X, idx, axis=1))) for idx in categorical_features_targeted])\n            if grid_resolution < min_n_cats:\n                raise ValueError(f'The resolution of the computed grid is less than the minimum number of categories in the targeted categorical features. Expect the `grid_resolution` to be greater than {min_n_cats}. Got {grid_resolution} instead.')\n        for (is_cat, kind_plot) in zip(is_categorical, kind_):\n            if any(is_cat) and kind_plot != 'average':\n                raise ValueError('It is not possible to display individual effects for categorical features.')\n    if ax is not None and (not isinstance(ax, plt.Axes)):\n        axes = np.asarray(ax, dtype=object)\n        if axes.size != len(features):\n            raise ValueError('Expected ax to have {} axes, got {}'.format(len(features), axes.size))\n    for i in chain.from_iterable(features):\n        if i >= len(feature_names):\n            raise ValueError('All entries of features must be less than len(feature_names) = {0}, got {1}.'.format(len(feature_names), i))\n    if isinstance(subsample, numbers.Integral):\n        if subsample <= 0:\n            raise ValueError(f'When an integer, subsample={subsample} should be positive.')\n    elif isinstance(subsample, numbers.Real):\n        if subsample <= 0 or subsample >= 1:\n            raise ValueError(f'When a floating-point, subsample={subsample} should be in the (0, 1) range.')\n    pd_results = Parallel(n_jobs=n_jobs, verbose=verbose)((delayed(partial_dependence)(estimator, X, fxs, sample_weight=sample_weight, feature_names=feature_names, categorical_features=categorical_features, response_method=response_method, method=method, grid_resolution=grid_resolution, percentiles=percentiles, kind=kind_plot) for (kind_plot, fxs) in zip(kind_, features)))\n    pd_result = pd_results[0]\n    n_tasks = pd_result.average.shape[0] if kind_[0] == 'average' else pd_result.individual.shape[0]\n    if is_regressor(estimator) and n_tasks > 1:\n        if target is None:\n            raise ValueError('target must be specified for multi-output regressors')\n        if not 0 <= target <= n_tasks:\n            raise ValueError('target must be in [0, n_tasks], got {}.'.format(target))\n        target_idx = target\n    deciles = {}\n    for (fxs, cats) in zip(features, is_categorical):\n        for (fx, cat) in zip(fxs, cats):\n            if not cat and fx not in deciles:\n                X_col = _safe_indexing(X, fx, axis=1)\n                deciles[fx] = mquantiles(X_col, prob=np.arange(0.1, 1.0, 0.1))\n    display = PartialDependenceDisplay(pd_results=pd_results, features=features, feature_names=feature_names, target_idx=target_idx, deciles=deciles, kind=kind, subsample=subsample, random_state=random_state, is_categorical=is_categorical)\n    return display.plot(ax=ax, n_cols=n_cols, line_kw=line_kw, ice_lines_kw=ice_lines_kw, pd_line_kw=pd_line_kw, contour_kw=contour_kw, centered=centered)"
        ]
    },
    {
        "func_name": "_get_sample_count",
        "original": "def _get_sample_count(self, n_samples):\n    \"\"\"Compute the number of samples as an integer.\"\"\"\n    if isinstance(self.subsample, numbers.Integral):\n        if self.subsample < n_samples:\n            return self.subsample\n        return n_samples\n    elif isinstance(self.subsample, numbers.Real):\n        return ceil(n_samples * self.subsample)\n    return n_samples",
        "mutated": [
            "def _get_sample_count(self, n_samples):\n    if False:\n        i = 10\n    'Compute the number of samples as an integer.'\n    if isinstance(self.subsample, numbers.Integral):\n        if self.subsample < n_samples:\n            return self.subsample\n        return n_samples\n    elif isinstance(self.subsample, numbers.Real):\n        return ceil(n_samples * self.subsample)\n    return n_samples",
            "def _get_sample_count(self, n_samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute the number of samples as an integer.'\n    if isinstance(self.subsample, numbers.Integral):\n        if self.subsample < n_samples:\n            return self.subsample\n        return n_samples\n    elif isinstance(self.subsample, numbers.Real):\n        return ceil(n_samples * self.subsample)\n    return n_samples",
            "def _get_sample_count(self, n_samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute the number of samples as an integer.'\n    if isinstance(self.subsample, numbers.Integral):\n        if self.subsample < n_samples:\n            return self.subsample\n        return n_samples\n    elif isinstance(self.subsample, numbers.Real):\n        return ceil(n_samples * self.subsample)\n    return n_samples",
            "def _get_sample_count(self, n_samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute the number of samples as an integer.'\n    if isinstance(self.subsample, numbers.Integral):\n        if self.subsample < n_samples:\n            return self.subsample\n        return n_samples\n    elif isinstance(self.subsample, numbers.Real):\n        return ceil(n_samples * self.subsample)\n    return n_samples",
            "def _get_sample_count(self, n_samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute the number of samples as an integer.'\n    if isinstance(self.subsample, numbers.Integral):\n        if self.subsample < n_samples:\n            return self.subsample\n        return n_samples\n    elif isinstance(self.subsample, numbers.Real):\n        return ceil(n_samples * self.subsample)\n    return n_samples"
        ]
    },
    {
        "func_name": "_plot_ice_lines",
        "original": "def _plot_ice_lines(self, preds, feature_values, n_ice_to_plot, ax, pd_plot_idx, n_total_lines_by_plot, individual_line_kw):\n    \"\"\"Plot the ICE lines.\n\n        Parameters\n        ----------\n        preds : ndarray of shape                 (n_instances, n_grid_points)\n            The predictions computed for all points of `feature_values` for a\n            given feature for all samples in `X`.\n        feature_values : ndarray of shape (n_grid_points,)\n            The feature values for which the predictions have been computed.\n        n_ice_to_plot : int\n            The number of ICE lines to plot.\n        ax : Matplotlib axes\n            The axis on which to plot the ICE lines.\n        pd_plot_idx : int\n            The sequential index of the plot. It will be unraveled to find the\n            matching 2D position in the grid layout.\n        n_total_lines_by_plot : int\n            The total number of lines expected to be plot on the axis.\n        individual_line_kw : dict\n            Dict with keywords passed when plotting the ICE lines.\n        \"\"\"\n    rng = check_random_state(self.random_state)\n    ice_lines_idx = rng.choice(preds.shape[0], n_ice_to_plot, replace=False)\n    ice_lines_subsampled = preds[ice_lines_idx, :]\n    for (ice_idx, ice) in enumerate(ice_lines_subsampled):\n        line_idx = np.unravel_index(pd_plot_idx * n_total_lines_by_plot + ice_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, ice.ravel(), **individual_line_kw)[0]",
        "mutated": [
            "def _plot_ice_lines(self, preds, feature_values, n_ice_to_plot, ax, pd_plot_idx, n_total_lines_by_plot, individual_line_kw):\n    if False:\n        i = 10\n    'Plot the ICE lines.\\n\\n        Parameters\\n        ----------\\n        preds : ndarray of shape                 (n_instances, n_grid_points)\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        n_ice_to_plot : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_total_lines_by_plot : int\\n            The total number of lines expected to be plot on the axis.\\n        individual_line_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        '\n    rng = check_random_state(self.random_state)\n    ice_lines_idx = rng.choice(preds.shape[0], n_ice_to_plot, replace=False)\n    ice_lines_subsampled = preds[ice_lines_idx, :]\n    for (ice_idx, ice) in enumerate(ice_lines_subsampled):\n        line_idx = np.unravel_index(pd_plot_idx * n_total_lines_by_plot + ice_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, ice.ravel(), **individual_line_kw)[0]",
            "def _plot_ice_lines(self, preds, feature_values, n_ice_to_plot, ax, pd_plot_idx, n_total_lines_by_plot, individual_line_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the ICE lines.\\n\\n        Parameters\\n        ----------\\n        preds : ndarray of shape                 (n_instances, n_grid_points)\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        n_ice_to_plot : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_total_lines_by_plot : int\\n            The total number of lines expected to be plot on the axis.\\n        individual_line_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        '\n    rng = check_random_state(self.random_state)\n    ice_lines_idx = rng.choice(preds.shape[0], n_ice_to_plot, replace=False)\n    ice_lines_subsampled = preds[ice_lines_idx, :]\n    for (ice_idx, ice) in enumerate(ice_lines_subsampled):\n        line_idx = np.unravel_index(pd_plot_idx * n_total_lines_by_plot + ice_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, ice.ravel(), **individual_line_kw)[0]",
            "def _plot_ice_lines(self, preds, feature_values, n_ice_to_plot, ax, pd_plot_idx, n_total_lines_by_plot, individual_line_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the ICE lines.\\n\\n        Parameters\\n        ----------\\n        preds : ndarray of shape                 (n_instances, n_grid_points)\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        n_ice_to_plot : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_total_lines_by_plot : int\\n            The total number of lines expected to be plot on the axis.\\n        individual_line_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        '\n    rng = check_random_state(self.random_state)\n    ice_lines_idx = rng.choice(preds.shape[0], n_ice_to_plot, replace=False)\n    ice_lines_subsampled = preds[ice_lines_idx, :]\n    for (ice_idx, ice) in enumerate(ice_lines_subsampled):\n        line_idx = np.unravel_index(pd_plot_idx * n_total_lines_by_plot + ice_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, ice.ravel(), **individual_line_kw)[0]",
            "def _plot_ice_lines(self, preds, feature_values, n_ice_to_plot, ax, pd_plot_idx, n_total_lines_by_plot, individual_line_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the ICE lines.\\n\\n        Parameters\\n        ----------\\n        preds : ndarray of shape                 (n_instances, n_grid_points)\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        n_ice_to_plot : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_total_lines_by_plot : int\\n            The total number of lines expected to be plot on the axis.\\n        individual_line_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        '\n    rng = check_random_state(self.random_state)\n    ice_lines_idx = rng.choice(preds.shape[0], n_ice_to_plot, replace=False)\n    ice_lines_subsampled = preds[ice_lines_idx, :]\n    for (ice_idx, ice) in enumerate(ice_lines_subsampled):\n        line_idx = np.unravel_index(pd_plot_idx * n_total_lines_by_plot + ice_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, ice.ravel(), **individual_line_kw)[0]",
            "def _plot_ice_lines(self, preds, feature_values, n_ice_to_plot, ax, pd_plot_idx, n_total_lines_by_plot, individual_line_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the ICE lines.\\n\\n        Parameters\\n        ----------\\n        preds : ndarray of shape                 (n_instances, n_grid_points)\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        n_ice_to_plot : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_total_lines_by_plot : int\\n            The total number of lines expected to be plot on the axis.\\n        individual_line_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        '\n    rng = check_random_state(self.random_state)\n    ice_lines_idx = rng.choice(preds.shape[0], n_ice_to_plot, replace=False)\n    ice_lines_subsampled = preds[ice_lines_idx, :]\n    for (ice_idx, ice) in enumerate(ice_lines_subsampled):\n        line_idx = np.unravel_index(pd_plot_idx * n_total_lines_by_plot + ice_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, ice.ravel(), **individual_line_kw)[0]"
        ]
    },
    {
        "func_name": "_plot_average_dependence",
        "original": "def _plot_average_dependence(self, avg_preds, feature_values, ax, pd_line_idx, line_kw, categorical, bar_kw):\n    \"\"\"Plot the average partial dependence.\n\n        Parameters\n        ----------\n        avg_preds : ndarray of shape (n_grid_points,)\n            The average predictions for all points of `feature_values` for a\n            given feature for all samples in `X`.\n        feature_values : ndarray of shape (n_grid_points,)\n            The feature values for which the predictions have been computed.\n        ax : Matplotlib axes\n            The axis on which to plot the average PD.\n        pd_line_idx : int\n            The sequential index of the plot. It will be unraveled to find the\n            matching 2D position in the grid layout.\n        line_kw : dict\n            Dict with keywords passed when plotting the PD plot.\n        categorical : bool\n            Whether feature is categorical.\n        bar_kw: dict\n            Dict with keywords passed when plotting the PD bars (categorical).\n        \"\"\"\n    if categorical:\n        bar_idx = np.unravel_index(pd_line_idx, self.bars_.shape)\n        self.bars_[bar_idx] = ax.bar(feature_values, avg_preds, **bar_kw)[0]\n        ax.tick_params(axis='x', rotation=90)\n    else:\n        line_idx = np.unravel_index(pd_line_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, avg_preds, **line_kw)[0]",
        "mutated": [
            "def _plot_average_dependence(self, avg_preds, feature_values, ax, pd_line_idx, line_kw, categorical, bar_kw):\n    if False:\n        i = 10\n    'Plot the average partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        ax : Matplotlib axes\\n            The axis on which to plot the average PD.\\n        pd_line_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        '\n    if categorical:\n        bar_idx = np.unravel_index(pd_line_idx, self.bars_.shape)\n        self.bars_[bar_idx] = ax.bar(feature_values, avg_preds, **bar_kw)[0]\n        ax.tick_params(axis='x', rotation=90)\n    else:\n        line_idx = np.unravel_index(pd_line_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, avg_preds, **line_kw)[0]",
            "def _plot_average_dependence(self, avg_preds, feature_values, ax, pd_line_idx, line_kw, categorical, bar_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot the average partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        ax : Matplotlib axes\\n            The axis on which to plot the average PD.\\n        pd_line_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        '\n    if categorical:\n        bar_idx = np.unravel_index(pd_line_idx, self.bars_.shape)\n        self.bars_[bar_idx] = ax.bar(feature_values, avg_preds, **bar_kw)[0]\n        ax.tick_params(axis='x', rotation=90)\n    else:\n        line_idx = np.unravel_index(pd_line_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, avg_preds, **line_kw)[0]",
            "def _plot_average_dependence(self, avg_preds, feature_values, ax, pd_line_idx, line_kw, categorical, bar_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot the average partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        ax : Matplotlib axes\\n            The axis on which to plot the average PD.\\n        pd_line_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        '\n    if categorical:\n        bar_idx = np.unravel_index(pd_line_idx, self.bars_.shape)\n        self.bars_[bar_idx] = ax.bar(feature_values, avg_preds, **bar_kw)[0]\n        ax.tick_params(axis='x', rotation=90)\n    else:\n        line_idx = np.unravel_index(pd_line_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, avg_preds, **line_kw)[0]",
            "def _plot_average_dependence(self, avg_preds, feature_values, ax, pd_line_idx, line_kw, categorical, bar_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot the average partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        ax : Matplotlib axes\\n            The axis on which to plot the average PD.\\n        pd_line_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        '\n    if categorical:\n        bar_idx = np.unravel_index(pd_line_idx, self.bars_.shape)\n        self.bars_[bar_idx] = ax.bar(feature_values, avg_preds, **bar_kw)[0]\n        ax.tick_params(axis='x', rotation=90)\n    else:\n        line_idx = np.unravel_index(pd_line_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, avg_preds, **line_kw)[0]",
            "def _plot_average_dependence(self, avg_preds, feature_values, ax, pd_line_idx, line_kw, categorical, bar_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot the average partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        ax : Matplotlib axes\\n            The axis on which to plot the average PD.\\n        pd_line_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        '\n    if categorical:\n        bar_idx = np.unravel_index(pd_line_idx, self.bars_.shape)\n        self.bars_[bar_idx] = ax.bar(feature_values, avg_preds, **bar_kw)[0]\n        ax.tick_params(axis='x', rotation=90)\n    else:\n        line_idx = np.unravel_index(pd_line_idx, self.lines_.shape)\n        self.lines_[line_idx] = ax.plot(feature_values, avg_preds, **line_kw)[0]"
        ]
    },
    {
        "func_name": "_plot_one_way_partial_dependence",
        "original": "def _plot_one_way_partial_dependence(self, kind, preds, avg_preds, feature_values, feature_idx, n_ice_lines, ax, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, categorical, bar_kw, pdp_lim):\n    \"\"\"Plot 1-way partial dependence: ICE and PDP.\n\n        Parameters\n        ----------\n        kind : str\n            The kind of partial plot to draw.\n        preds : ndarray of shape                 (n_instances, n_grid_points) or None\n            The predictions computed for all points of `feature_values` for a\n            given feature for all samples in `X`.\n        avg_preds : ndarray of shape (n_grid_points,)\n            The average predictions for all points of `feature_values` for a\n            given feature for all samples in `X`.\n        feature_values : ndarray of shape (n_grid_points,)\n            The feature values for which the predictions have been computed.\n        feature_idx : int\n            The index corresponding to the target feature.\n        n_ice_lines : int\n            The number of ICE lines to plot.\n        ax : Matplotlib axes\n            The axis on which to plot the ICE and PDP lines.\n        n_cols : int or None\n            The number of column in the axis.\n        pd_plot_idx : int\n            The sequential index of the plot. It will be unraveled to find the\n            matching 2D position in the grid layout.\n        n_lines : int\n            The total number of lines expected to be plot on the axis.\n        ice_lines_kw : dict\n            Dict with keywords passed when plotting the ICE lines.\n        pd_line_kw : dict\n            Dict with keywords passed when plotting the PD plot.\n        categorical : bool\n            Whether feature is categorical.\n        bar_kw: dict\n            Dict with keywords passed when plotting the PD bars (categorical).\n        pdp_lim : dict\n            Global min and max average predictions, such that all plots will\n            have the same scale and y limits. `pdp_lim[1]` is the global min\n            and max for single partial dependence curves.\n        \"\"\"\n    from matplotlib import transforms\n    if kind in ('individual', 'both'):\n        self._plot_ice_lines(preds[self.target_idx], feature_values, n_ice_lines, ax, pd_plot_idx, n_lines, ice_lines_kw)\n    if kind in ('average', 'both'):\n        if kind == 'average':\n            pd_line_idx = pd_plot_idx\n        else:\n            pd_line_idx = pd_plot_idx * n_lines + n_ice_lines\n        self._plot_average_dependence(avg_preds[self.target_idx].ravel(), feature_values, ax, pd_line_idx, pd_line_kw, categorical, bar_kw)\n    trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n    if self.deciles.get(feature_idx[0], None) is not None:\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n    min_val = min((val[0] for val in pdp_lim.values()))\n    max_val = max((val[1] for val in pdp_lim.values()))\n    ax.set_ylim([min_val, max_val])\n    if not ax.get_xlabel():\n        ax.set_xlabel(self.feature_names[feature_idx[0]])\n    if n_cols is None or pd_plot_idx % n_cols == 0:\n        if not ax.get_ylabel():\n            ax.set_ylabel('Partial dependence')\n    else:\n        ax.set_yticklabels([])\n    if pd_line_kw.get('label', None) and kind != 'individual' and (not categorical):\n        ax.legend()",
        "mutated": [
            "def _plot_one_way_partial_dependence(self, kind, preds, avg_preds, feature_values, feature_idx, n_ice_lines, ax, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, categorical, bar_kw, pdp_lim):\n    if False:\n        i = 10\n    'Plot 1-way partial dependence: ICE and PDP.\\n\\n        Parameters\\n        ----------\\n        kind : str\\n            The kind of partial plot to draw.\\n        preds : ndarray of shape                 (n_instances, n_grid_points) or None\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        feature_idx : int\\n            The index corresponding to the target feature.\\n        n_ice_lines : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        n_cols : int or None\\n            The number of column in the axis.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_lines : int\\n            The total number of lines expected to be plot on the axis.\\n        ice_lines_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        pd_line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        pdp_lim : dict\\n            Global min and max average predictions, such that all plots will\\n            have the same scale and y limits. `pdp_lim[1]` is the global min\\n            and max for single partial dependence curves.\\n        '\n    from matplotlib import transforms\n    if kind in ('individual', 'both'):\n        self._plot_ice_lines(preds[self.target_idx], feature_values, n_ice_lines, ax, pd_plot_idx, n_lines, ice_lines_kw)\n    if kind in ('average', 'both'):\n        if kind == 'average':\n            pd_line_idx = pd_plot_idx\n        else:\n            pd_line_idx = pd_plot_idx * n_lines + n_ice_lines\n        self._plot_average_dependence(avg_preds[self.target_idx].ravel(), feature_values, ax, pd_line_idx, pd_line_kw, categorical, bar_kw)\n    trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n    if self.deciles.get(feature_idx[0], None) is not None:\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n    min_val = min((val[0] for val in pdp_lim.values()))\n    max_val = max((val[1] for val in pdp_lim.values()))\n    ax.set_ylim([min_val, max_val])\n    if not ax.get_xlabel():\n        ax.set_xlabel(self.feature_names[feature_idx[0]])\n    if n_cols is None or pd_plot_idx % n_cols == 0:\n        if not ax.get_ylabel():\n            ax.set_ylabel('Partial dependence')\n    else:\n        ax.set_yticklabels([])\n    if pd_line_kw.get('label', None) and kind != 'individual' and (not categorical):\n        ax.legend()",
            "def _plot_one_way_partial_dependence(self, kind, preds, avg_preds, feature_values, feature_idx, n_ice_lines, ax, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, categorical, bar_kw, pdp_lim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot 1-way partial dependence: ICE and PDP.\\n\\n        Parameters\\n        ----------\\n        kind : str\\n            The kind of partial plot to draw.\\n        preds : ndarray of shape                 (n_instances, n_grid_points) or None\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        feature_idx : int\\n            The index corresponding to the target feature.\\n        n_ice_lines : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        n_cols : int or None\\n            The number of column in the axis.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_lines : int\\n            The total number of lines expected to be plot on the axis.\\n        ice_lines_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        pd_line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        pdp_lim : dict\\n            Global min and max average predictions, such that all plots will\\n            have the same scale and y limits. `pdp_lim[1]` is the global min\\n            and max for single partial dependence curves.\\n        '\n    from matplotlib import transforms\n    if kind in ('individual', 'both'):\n        self._plot_ice_lines(preds[self.target_idx], feature_values, n_ice_lines, ax, pd_plot_idx, n_lines, ice_lines_kw)\n    if kind in ('average', 'both'):\n        if kind == 'average':\n            pd_line_idx = pd_plot_idx\n        else:\n            pd_line_idx = pd_plot_idx * n_lines + n_ice_lines\n        self._plot_average_dependence(avg_preds[self.target_idx].ravel(), feature_values, ax, pd_line_idx, pd_line_kw, categorical, bar_kw)\n    trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n    if self.deciles.get(feature_idx[0], None) is not None:\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n    min_val = min((val[0] for val in pdp_lim.values()))\n    max_val = max((val[1] for val in pdp_lim.values()))\n    ax.set_ylim([min_val, max_val])\n    if not ax.get_xlabel():\n        ax.set_xlabel(self.feature_names[feature_idx[0]])\n    if n_cols is None or pd_plot_idx % n_cols == 0:\n        if not ax.get_ylabel():\n            ax.set_ylabel('Partial dependence')\n    else:\n        ax.set_yticklabels([])\n    if pd_line_kw.get('label', None) and kind != 'individual' and (not categorical):\n        ax.legend()",
            "def _plot_one_way_partial_dependence(self, kind, preds, avg_preds, feature_values, feature_idx, n_ice_lines, ax, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, categorical, bar_kw, pdp_lim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot 1-way partial dependence: ICE and PDP.\\n\\n        Parameters\\n        ----------\\n        kind : str\\n            The kind of partial plot to draw.\\n        preds : ndarray of shape                 (n_instances, n_grid_points) or None\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        feature_idx : int\\n            The index corresponding to the target feature.\\n        n_ice_lines : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        n_cols : int or None\\n            The number of column in the axis.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_lines : int\\n            The total number of lines expected to be plot on the axis.\\n        ice_lines_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        pd_line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        pdp_lim : dict\\n            Global min and max average predictions, such that all plots will\\n            have the same scale and y limits. `pdp_lim[1]` is the global min\\n            and max for single partial dependence curves.\\n        '\n    from matplotlib import transforms\n    if kind in ('individual', 'both'):\n        self._plot_ice_lines(preds[self.target_idx], feature_values, n_ice_lines, ax, pd_plot_idx, n_lines, ice_lines_kw)\n    if kind in ('average', 'both'):\n        if kind == 'average':\n            pd_line_idx = pd_plot_idx\n        else:\n            pd_line_idx = pd_plot_idx * n_lines + n_ice_lines\n        self._plot_average_dependence(avg_preds[self.target_idx].ravel(), feature_values, ax, pd_line_idx, pd_line_kw, categorical, bar_kw)\n    trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n    if self.deciles.get(feature_idx[0], None) is not None:\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n    min_val = min((val[0] for val in pdp_lim.values()))\n    max_val = max((val[1] for val in pdp_lim.values()))\n    ax.set_ylim([min_val, max_val])\n    if not ax.get_xlabel():\n        ax.set_xlabel(self.feature_names[feature_idx[0]])\n    if n_cols is None or pd_plot_idx % n_cols == 0:\n        if not ax.get_ylabel():\n            ax.set_ylabel('Partial dependence')\n    else:\n        ax.set_yticklabels([])\n    if pd_line_kw.get('label', None) and kind != 'individual' and (not categorical):\n        ax.legend()",
            "def _plot_one_way_partial_dependence(self, kind, preds, avg_preds, feature_values, feature_idx, n_ice_lines, ax, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, categorical, bar_kw, pdp_lim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot 1-way partial dependence: ICE and PDP.\\n\\n        Parameters\\n        ----------\\n        kind : str\\n            The kind of partial plot to draw.\\n        preds : ndarray of shape                 (n_instances, n_grid_points) or None\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        feature_idx : int\\n            The index corresponding to the target feature.\\n        n_ice_lines : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        n_cols : int or None\\n            The number of column in the axis.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_lines : int\\n            The total number of lines expected to be plot on the axis.\\n        ice_lines_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        pd_line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        pdp_lim : dict\\n            Global min and max average predictions, such that all plots will\\n            have the same scale and y limits. `pdp_lim[1]` is the global min\\n            and max for single partial dependence curves.\\n        '\n    from matplotlib import transforms\n    if kind in ('individual', 'both'):\n        self._plot_ice_lines(preds[self.target_idx], feature_values, n_ice_lines, ax, pd_plot_idx, n_lines, ice_lines_kw)\n    if kind in ('average', 'both'):\n        if kind == 'average':\n            pd_line_idx = pd_plot_idx\n        else:\n            pd_line_idx = pd_plot_idx * n_lines + n_ice_lines\n        self._plot_average_dependence(avg_preds[self.target_idx].ravel(), feature_values, ax, pd_line_idx, pd_line_kw, categorical, bar_kw)\n    trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n    if self.deciles.get(feature_idx[0], None) is not None:\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n    min_val = min((val[0] for val in pdp_lim.values()))\n    max_val = max((val[1] for val in pdp_lim.values()))\n    ax.set_ylim([min_val, max_val])\n    if not ax.get_xlabel():\n        ax.set_xlabel(self.feature_names[feature_idx[0]])\n    if n_cols is None or pd_plot_idx % n_cols == 0:\n        if not ax.get_ylabel():\n            ax.set_ylabel('Partial dependence')\n    else:\n        ax.set_yticklabels([])\n    if pd_line_kw.get('label', None) and kind != 'individual' and (not categorical):\n        ax.legend()",
            "def _plot_one_way_partial_dependence(self, kind, preds, avg_preds, feature_values, feature_idx, n_ice_lines, ax, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, categorical, bar_kw, pdp_lim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot 1-way partial dependence: ICE and PDP.\\n\\n        Parameters\\n        ----------\\n        kind : str\\n            The kind of partial plot to draw.\\n        preds : ndarray of shape                 (n_instances, n_grid_points) or None\\n            The predictions computed for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        avg_preds : ndarray of shape (n_grid_points,)\\n            The average predictions for all points of `feature_values` for a\\n            given feature for all samples in `X`.\\n        feature_values : ndarray of shape (n_grid_points,)\\n            The feature values for which the predictions have been computed.\\n        feature_idx : int\\n            The index corresponding to the target feature.\\n        n_ice_lines : int\\n            The number of ICE lines to plot.\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        n_cols : int or None\\n            The number of column in the axis.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        n_lines : int\\n            The total number of lines expected to be plot on the axis.\\n        ice_lines_kw : dict\\n            Dict with keywords passed when plotting the ICE lines.\\n        pd_line_kw : dict\\n            Dict with keywords passed when plotting the PD plot.\\n        categorical : bool\\n            Whether feature is categorical.\\n        bar_kw: dict\\n            Dict with keywords passed when plotting the PD bars (categorical).\\n        pdp_lim : dict\\n            Global min and max average predictions, such that all plots will\\n            have the same scale and y limits. `pdp_lim[1]` is the global min\\n            and max for single partial dependence curves.\\n        '\n    from matplotlib import transforms\n    if kind in ('individual', 'both'):\n        self._plot_ice_lines(preds[self.target_idx], feature_values, n_ice_lines, ax, pd_plot_idx, n_lines, ice_lines_kw)\n    if kind in ('average', 'both'):\n        if kind == 'average':\n            pd_line_idx = pd_plot_idx\n        else:\n            pd_line_idx = pd_plot_idx * n_lines + n_ice_lines\n        self._plot_average_dependence(avg_preds[self.target_idx].ravel(), feature_values, ax, pd_line_idx, pd_line_kw, categorical, bar_kw)\n    trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n    if self.deciles.get(feature_idx[0], None) is not None:\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n    min_val = min((val[0] for val in pdp_lim.values()))\n    max_val = max((val[1] for val in pdp_lim.values()))\n    ax.set_ylim([min_val, max_val])\n    if not ax.get_xlabel():\n        ax.set_xlabel(self.feature_names[feature_idx[0]])\n    if n_cols is None or pd_plot_idx % n_cols == 0:\n        if not ax.get_ylabel():\n            ax.set_ylabel('Partial dependence')\n    else:\n        ax.set_yticklabels([])\n    if pd_line_kw.get('label', None) and kind != 'individual' and (not categorical):\n        ax.legend()"
        ]
    },
    {
        "func_name": "_plot_two_way_partial_dependence",
        "original": "def _plot_two_way_partial_dependence(self, avg_preds, feature_values, feature_idx, ax, pd_plot_idx, Z_level, contour_kw, categorical, heatmap_kw):\n    \"\"\"Plot 2-way partial dependence.\n\n        Parameters\n        ----------\n        avg_preds : ndarray of shape                 (n_instances, n_grid_points, n_grid_points)\n            The average predictions for all points of `feature_values[0]` and\n            `feature_values[1]` for some given features for all samples in `X`.\n        feature_values : seq of 1d array\n            A sequence of array of the feature values for which the predictions\n            have been computed.\n        feature_idx : tuple of int\n            The indices of the target features\n        ax : Matplotlib axes\n            The axis on which to plot the ICE and PDP lines.\n        pd_plot_idx : int\n            The sequential index of the plot. It will be unraveled to find the\n            matching 2D position in the grid layout.\n        Z_level : ndarray of shape (8, 8)\n            The Z-level used to encode the average predictions.\n        contour_kw : dict\n            Dict with keywords passed when plotting the contours.\n        categorical : bool\n            Whether features are categorical.\n        heatmap_kw: dict\n            Dict with keywords passed when plotting the PD heatmap\n            (categorical).\n        \"\"\"\n    if categorical:\n        import matplotlib.pyplot as plt\n        default_im_kw = dict(interpolation='nearest', cmap='viridis')\n        im_kw = {**default_im_kw, **heatmap_kw}\n        data = avg_preds[self.target_idx]\n        im = ax.imshow(data, **im_kw)\n        text = None\n        (cmap_min, cmap_max) = (im.cmap(0), im.cmap(1.0))\n        text = np.empty_like(data, dtype=object)\n        thresh = (data.max() + data.min()) / 2.0\n        for flat_index in range(data.size):\n            (row, col) = np.unravel_index(flat_index, data.shape)\n            color = cmap_max if data[row, col] < thresh else cmap_min\n            values_format = '.2f'\n            text_data = format(data[row, col], values_format)\n            text_kwargs = dict(ha='center', va='center', color=color)\n            text[row, col] = ax.text(col, row, text_data, **text_kwargs)\n        fig = ax.figure\n        fig.colorbar(im, ax=ax)\n        ax.set(xticks=np.arange(len(feature_values[1])), yticks=np.arange(len(feature_values[0])), xticklabels=feature_values[1], yticklabels=feature_values[0], xlabel=self.feature_names[feature_idx[1]], ylabel=self.feature_names[feature_idx[0]])\n        plt.setp(ax.get_xticklabels(), rotation='vertical')\n        heatmap_idx = np.unravel_index(pd_plot_idx, self.heatmaps_.shape)\n        self.heatmaps_[heatmap_idx] = im\n    else:\n        from matplotlib import transforms\n        (XX, YY) = np.meshgrid(feature_values[0], feature_values[1])\n        Z = avg_preds[self.target_idx].T\n        CS = ax.contour(XX, YY, Z, levels=Z_level, linewidths=0.5, colors='k')\n        contour_idx = np.unravel_index(pd_plot_idx, self.contours_.shape)\n        self.contours_[contour_idx] = ax.contourf(XX, YY, Z, levels=Z_level, vmax=Z_level[-1], vmin=Z_level[0], **contour_kw)\n        ax.clabel(CS, fmt='%2.2f', colors='k', fontsize=10, inline=True)\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n        (xlim, ylim) = (ax.get_xlim(), ax.get_ylim())\n        vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n        hlines_idx = np.unravel_index(pd_plot_idx, self.deciles_hlines_.shape)\n        self.deciles_hlines_[hlines_idx] = ax.hlines(self.deciles[feature_idx[1]], 0, 0.05, transform=trans, color='k')\n        ax.set_xlim(xlim)\n        ax.set_ylim(ylim)\n        if not ax.get_xlabel():\n            ax.set_xlabel(self.feature_names[feature_idx[0]])\n        ax.set_ylabel(self.feature_names[feature_idx[1]])",
        "mutated": [
            "def _plot_two_way_partial_dependence(self, avg_preds, feature_values, feature_idx, ax, pd_plot_idx, Z_level, contour_kw, categorical, heatmap_kw):\n    if False:\n        i = 10\n    'Plot 2-way partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape                 (n_instances, n_grid_points, n_grid_points)\\n            The average predictions for all points of `feature_values[0]` and\\n            `feature_values[1]` for some given features for all samples in `X`.\\n        feature_values : seq of 1d array\\n            A sequence of array of the feature values for which the predictions\\n            have been computed.\\n        feature_idx : tuple of int\\n            The indices of the target features\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        Z_level : ndarray of shape (8, 8)\\n            The Z-level used to encode the average predictions.\\n        contour_kw : dict\\n            Dict with keywords passed when plotting the contours.\\n        categorical : bool\\n            Whether features are categorical.\\n        heatmap_kw: dict\\n            Dict with keywords passed when plotting the PD heatmap\\n            (categorical).\\n        '\n    if categorical:\n        import matplotlib.pyplot as plt\n        default_im_kw = dict(interpolation='nearest', cmap='viridis')\n        im_kw = {**default_im_kw, **heatmap_kw}\n        data = avg_preds[self.target_idx]\n        im = ax.imshow(data, **im_kw)\n        text = None\n        (cmap_min, cmap_max) = (im.cmap(0), im.cmap(1.0))\n        text = np.empty_like(data, dtype=object)\n        thresh = (data.max() + data.min()) / 2.0\n        for flat_index in range(data.size):\n            (row, col) = np.unravel_index(flat_index, data.shape)\n            color = cmap_max if data[row, col] < thresh else cmap_min\n            values_format = '.2f'\n            text_data = format(data[row, col], values_format)\n            text_kwargs = dict(ha='center', va='center', color=color)\n            text[row, col] = ax.text(col, row, text_data, **text_kwargs)\n        fig = ax.figure\n        fig.colorbar(im, ax=ax)\n        ax.set(xticks=np.arange(len(feature_values[1])), yticks=np.arange(len(feature_values[0])), xticklabels=feature_values[1], yticklabels=feature_values[0], xlabel=self.feature_names[feature_idx[1]], ylabel=self.feature_names[feature_idx[0]])\n        plt.setp(ax.get_xticklabels(), rotation='vertical')\n        heatmap_idx = np.unravel_index(pd_plot_idx, self.heatmaps_.shape)\n        self.heatmaps_[heatmap_idx] = im\n    else:\n        from matplotlib import transforms\n        (XX, YY) = np.meshgrid(feature_values[0], feature_values[1])\n        Z = avg_preds[self.target_idx].T\n        CS = ax.contour(XX, YY, Z, levels=Z_level, linewidths=0.5, colors='k')\n        contour_idx = np.unravel_index(pd_plot_idx, self.contours_.shape)\n        self.contours_[contour_idx] = ax.contourf(XX, YY, Z, levels=Z_level, vmax=Z_level[-1], vmin=Z_level[0], **contour_kw)\n        ax.clabel(CS, fmt='%2.2f', colors='k', fontsize=10, inline=True)\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n        (xlim, ylim) = (ax.get_xlim(), ax.get_ylim())\n        vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n        hlines_idx = np.unravel_index(pd_plot_idx, self.deciles_hlines_.shape)\n        self.deciles_hlines_[hlines_idx] = ax.hlines(self.deciles[feature_idx[1]], 0, 0.05, transform=trans, color='k')\n        ax.set_xlim(xlim)\n        ax.set_ylim(ylim)\n        if not ax.get_xlabel():\n            ax.set_xlabel(self.feature_names[feature_idx[0]])\n        ax.set_ylabel(self.feature_names[feature_idx[1]])",
            "def _plot_two_way_partial_dependence(self, avg_preds, feature_values, feature_idx, ax, pd_plot_idx, Z_level, contour_kw, categorical, heatmap_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot 2-way partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape                 (n_instances, n_grid_points, n_grid_points)\\n            The average predictions for all points of `feature_values[0]` and\\n            `feature_values[1]` for some given features for all samples in `X`.\\n        feature_values : seq of 1d array\\n            A sequence of array of the feature values for which the predictions\\n            have been computed.\\n        feature_idx : tuple of int\\n            The indices of the target features\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        Z_level : ndarray of shape (8, 8)\\n            The Z-level used to encode the average predictions.\\n        contour_kw : dict\\n            Dict with keywords passed when plotting the contours.\\n        categorical : bool\\n            Whether features are categorical.\\n        heatmap_kw: dict\\n            Dict with keywords passed when plotting the PD heatmap\\n            (categorical).\\n        '\n    if categorical:\n        import matplotlib.pyplot as plt\n        default_im_kw = dict(interpolation='nearest', cmap='viridis')\n        im_kw = {**default_im_kw, **heatmap_kw}\n        data = avg_preds[self.target_idx]\n        im = ax.imshow(data, **im_kw)\n        text = None\n        (cmap_min, cmap_max) = (im.cmap(0), im.cmap(1.0))\n        text = np.empty_like(data, dtype=object)\n        thresh = (data.max() + data.min()) / 2.0\n        for flat_index in range(data.size):\n            (row, col) = np.unravel_index(flat_index, data.shape)\n            color = cmap_max if data[row, col] < thresh else cmap_min\n            values_format = '.2f'\n            text_data = format(data[row, col], values_format)\n            text_kwargs = dict(ha='center', va='center', color=color)\n            text[row, col] = ax.text(col, row, text_data, **text_kwargs)\n        fig = ax.figure\n        fig.colorbar(im, ax=ax)\n        ax.set(xticks=np.arange(len(feature_values[1])), yticks=np.arange(len(feature_values[0])), xticklabels=feature_values[1], yticklabels=feature_values[0], xlabel=self.feature_names[feature_idx[1]], ylabel=self.feature_names[feature_idx[0]])\n        plt.setp(ax.get_xticklabels(), rotation='vertical')\n        heatmap_idx = np.unravel_index(pd_plot_idx, self.heatmaps_.shape)\n        self.heatmaps_[heatmap_idx] = im\n    else:\n        from matplotlib import transforms\n        (XX, YY) = np.meshgrid(feature_values[0], feature_values[1])\n        Z = avg_preds[self.target_idx].T\n        CS = ax.contour(XX, YY, Z, levels=Z_level, linewidths=0.5, colors='k')\n        contour_idx = np.unravel_index(pd_plot_idx, self.contours_.shape)\n        self.contours_[contour_idx] = ax.contourf(XX, YY, Z, levels=Z_level, vmax=Z_level[-1], vmin=Z_level[0], **contour_kw)\n        ax.clabel(CS, fmt='%2.2f', colors='k', fontsize=10, inline=True)\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n        (xlim, ylim) = (ax.get_xlim(), ax.get_ylim())\n        vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n        hlines_idx = np.unravel_index(pd_plot_idx, self.deciles_hlines_.shape)\n        self.deciles_hlines_[hlines_idx] = ax.hlines(self.deciles[feature_idx[1]], 0, 0.05, transform=trans, color='k')\n        ax.set_xlim(xlim)\n        ax.set_ylim(ylim)\n        if not ax.get_xlabel():\n            ax.set_xlabel(self.feature_names[feature_idx[0]])\n        ax.set_ylabel(self.feature_names[feature_idx[1]])",
            "def _plot_two_way_partial_dependence(self, avg_preds, feature_values, feature_idx, ax, pd_plot_idx, Z_level, contour_kw, categorical, heatmap_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot 2-way partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape                 (n_instances, n_grid_points, n_grid_points)\\n            The average predictions for all points of `feature_values[0]` and\\n            `feature_values[1]` for some given features for all samples in `X`.\\n        feature_values : seq of 1d array\\n            A sequence of array of the feature values for which the predictions\\n            have been computed.\\n        feature_idx : tuple of int\\n            The indices of the target features\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        Z_level : ndarray of shape (8, 8)\\n            The Z-level used to encode the average predictions.\\n        contour_kw : dict\\n            Dict with keywords passed when plotting the contours.\\n        categorical : bool\\n            Whether features are categorical.\\n        heatmap_kw: dict\\n            Dict with keywords passed when plotting the PD heatmap\\n            (categorical).\\n        '\n    if categorical:\n        import matplotlib.pyplot as plt\n        default_im_kw = dict(interpolation='nearest', cmap='viridis')\n        im_kw = {**default_im_kw, **heatmap_kw}\n        data = avg_preds[self.target_idx]\n        im = ax.imshow(data, **im_kw)\n        text = None\n        (cmap_min, cmap_max) = (im.cmap(0), im.cmap(1.0))\n        text = np.empty_like(data, dtype=object)\n        thresh = (data.max() + data.min()) / 2.0\n        for flat_index in range(data.size):\n            (row, col) = np.unravel_index(flat_index, data.shape)\n            color = cmap_max if data[row, col] < thresh else cmap_min\n            values_format = '.2f'\n            text_data = format(data[row, col], values_format)\n            text_kwargs = dict(ha='center', va='center', color=color)\n            text[row, col] = ax.text(col, row, text_data, **text_kwargs)\n        fig = ax.figure\n        fig.colorbar(im, ax=ax)\n        ax.set(xticks=np.arange(len(feature_values[1])), yticks=np.arange(len(feature_values[0])), xticklabels=feature_values[1], yticklabels=feature_values[0], xlabel=self.feature_names[feature_idx[1]], ylabel=self.feature_names[feature_idx[0]])\n        plt.setp(ax.get_xticklabels(), rotation='vertical')\n        heatmap_idx = np.unravel_index(pd_plot_idx, self.heatmaps_.shape)\n        self.heatmaps_[heatmap_idx] = im\n    else:\n        from matplotlib import transforms\n        (XX, YY) = np.meshgrid(feature_values[0], feature_values[1])\n        Z = avg_preds[self.target_idx].T\n        CS = ax.contour(XX, YY, Z, levels=Z_level, linewidths=0.5, colors='k')\n        contour_idx = np.unravel_index(pd_plot_idx, self.contours_.shape)\n        self.contours_[contour_idx] = ax.contourf(XX, YY, Z, levels=Z_level, vmax=Z_level[-1], vmin=Z_level[0], **contour_kw)\n        ax.clabel(CS, fmt='%2.2f', colors='k', fontsize=10, inline=True)\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n        (xlim, ylim) = (ax.get_xlim(), ax.get_ylim())\n        vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n        hlines_idx = np.unravel_index(pd_plot_idx, self.deciles_hlines_.shape)\n        self.deciles_hlines_[hlines_idx] = ax.hlines(self.deciles[feature_idx[1]], 0, 0.05, transform=trans, color='k')\n        ax.set_xlim(xlim)\n        ax.set_ylim(ylim)\n        if not ax.get_xlabel():\n            ax.set_xlabel(self.feature_names[feature_idx[0]])\n        ax.set_ylabel(self.feature_names[feature_idx[1]])",
            "def _plot_two_way_partial_dependence(self, avg_preds, feature_values, feature_idx, ax, pd_plot_idx, Z_level, contour_kw, categorical, heatmap_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot 2-way partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape                 (n_instances, n_grid_points, n_grid_points)\\n            The average predictions for all points of `feature_values[0]` and\\n            `feature_values[1]` for some given features for all samples in `X`.\\n        feature_values : seq of 1d array\\n            A sequence of array of the feature values for which the predictions\\n            have been computed.\\n        feature_idx : tuple of int\\n            The indices of the target features\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        Z_level : ndarray of shape (8, 8)\\n            The Z-level used to encode the average predictions.\\n        contour_kw : dict\\n            Dict with keywords passed when plotting the contours.\\n        categorical : bool\\n            Whether features are categorical.\\n        heatmap_kw: dict\\n            Dict with keywords passed when plotting the PD heatmap\\n            (categorical).\\n        '\n    if categorical:\n        import matplotlib.pyplot as plt\n        default_im_kw = dict(interpolation='nearest', cmap='viridis')\n        im_kw = {**default_im_kw, **heatmap_kw}\n        data = avg_preds[self.target_idx]\n        im = ax.imshow(data, **im_kw)\n        text = None\n        (cmap_min, cmap_max) = (im.cmap(0), im.cmap(1.0))\n        text = np.empty_like(data, dtype=object)\n        thresh = (data.max() + data.min()) / 2.0\n        for flat_index in range(data.size):\n            (row, col) = np.unravel_index(flat_index, data.shape)\n            color = cmap_max if data[row, col] < thresh else cmap_min\n            values_format = '.2f'\n            text_data = format(data[row, col], values_format)\n            text_kwargs = dict(ha='center', va='center', color=color)\n            text[row, col] = ax.text(col, row, text_data, **text_kwargs)\n        fig = ax.figure\n        fig.colorbar(im, ax=ax)\n        ax.set(xticks=np.arange(len(feature_values[1])), yticks=np.arange(len(feature_values[0])), xticklabels=feature_values[1], yticklabels=feature_values[0], xlabel=self.feature_names[feature_idx[1]], ylabel=self.feature_names[feature_idx[0]])\n        plt.setp(ax.get_xticklabels(), rotation='vertical')\n        heatmap_idx = np.unravel_index(pd_plot_idx, self.heatmaps_.shape)\n        self.heatmaps_[heatmap_idx] = im\n    else:\n        from matplotlib import transforms\n        (XX, YY) = np.meshgrid(feature_values[0], feature_values[1])\n        Z = avg_preds[self.target_idx].T\n        CS = ax.contour(XX, YY, Z, levels=Z_level, linewidths=0.5, colors='k')\n        contour_idx = np.unravel_index(pd_plot_idx, self.contours_.shape)\n        self.contours_[contour_idx] = ax.contourf(XX, YY, Z, levels=Z_level, vmax=Z_level[-1], vmin=Z_level[0], **contour_kw)\n        ax.clabel(CS, fmt='%2.2f', colors='k', fontsize=10, inline=True)\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n        (xlim, ylim) = (ax.get_xlim(), ax.get_ylim())\n        vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n        hlines_idx = np.unravel_index(pd_plot_idx, self.deciles_hlines_.shape)\n        self.deciles_hlines_[hlines_idx] = ax.hlines(self.deciles[feature_idx[1]], 0, 0.05, transform=trans, color='k')\n        ax.set_xlim(xlim)\n        ax.set_ylim(ylim)\n        if not ax.get_xlabel():\n            ax.set_xlabel(self.feature_names[feature_idx[0]])\n        ax.set_ylabel(self.feature_names[feature_idx[1]])",
            "def _plot_two_way_partial_dependence(self, avg_preds, feature_values, feature_idx, ax, pd_plot_idx, Z_level, contour_kw, categorical, heatmap_kw):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot 2-way partial dependence.\\n\\n        Parameters\\n        ----------\\n        avg_preds : ndarray of shape                 (n_instances, n_grid_points, n_grid_points)\\n            The average predictions for all points of `feature_values[0]` and\\n            `feature_values[1]` for some given features for all samples in `X`.\\n        feature_values : seq of 1d array\\n            A sequence of array of the feature values for which the predictions\\n            have been computed.\\n        feature_idx : tuple of int\\n            The indices of the target features\\n        ax : Matplotlib axes\\n            The axis on which to plot the ICE and PDP lines.\\n        pd_plot_idx : int\\n            The sequential index of the plot. It will be unraveled to find the\\n            matching 2D position in the grid layout.\\n        Z_level : ndarray of shape (8, 8)\\n            The Z-level used to encode the average predictions.\\n        contour_kw : dict\\n            Dict with keywords passed when plotting the contours.\\n        categorical : bool\\n            Whether features are categorical.\\n        heatmap_kw: dict\\n            Dict with keywords passed when plotting the PD heatmap\\n            (categorical).\\n        '\n    if categorical:\n        import matplotlib.pyplot as plt\n        default_im_kw = dict(interpolation='nearest', cmap='viridis')\n        im_kw = {**default_im_kw, **heatmap_kw}\n        data = avg_preds[self.target_idx]\n        im = ax.imshow(data, **im_kw)\n        text = None\n        (cmap_min, cmap_max) = (im.cmap(0), im.cmap(1.0))\n        text = np.empty_like(data, dtype=object)\n        thresh = (data.max() + data.min()) / 2.0\n        for flat_index in range(data.size):\n            (row, col) = np.unravel_index(flat_index, data.shape)\n            color = cmap_max if data[row, col] < thresh else cmap_min\n            values_format = '.2f'\n            text_data = format(data[row, col], values_format)\n            text_kwargs = dict(ha='center', va='center', color=color)\n            text[row, col] = ax.text(col, row, text_data, **text_kwargs)\n        fig = ax.figure\n        fig.colorbar(im, ax=ax)\n        ax.set(xticks=np.arange(len(feature_values[1])), yticks=np.arange(len(feature_values[0])), xticklabels=feature_values[1], yticklabels=feature_values[0], xlabel=self.feature_names[feature_idx[1]], ylabel=self.feature_names[feature_idx[0]])\n        plt.setp(ax.get_xticklabels(), rotation='vertical')\n        heatmap_idx = np.unravel_index(pd_plot_idx, self.heatmaps_.shape)\n        self.heatmaps_[heatmap_idx] = im\n    else:\n        from matplotlib import transforms\n        (XX, YY) = np.meshgrid(feature_values[0], feature_values[1])\n        Z = avg_preds[self.target_idx].T\n        CS = ax.contour(XX, YY, Z, levels=Z_level, linewidths=0.5, colors='k')\n        contour_idx = np.unravel_index(pd_plot_idx, self.contours_.shape)\n        self.contours_[contour_idx] = ax.contourf(XX, YY, Z, levels=Z_level, vmax=Z_level[-1], vmin=Z_level[0], **contour_kw)\n        ax.clabel(CS, fmt='%2.2f', colors='k', fontsize=10, inline=True)\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n        (xlim, ylim) = (ax.get_xlim(), ax.get_ylim())\n        vlines_idx = np.unravel_index(pd_plot_idx, self.deciles_vlines_.shape)\n        self.deciles_vlines_[vlines_idx] = ax.vlines(self.deciles[feature_idx[0]], 0, 0.05, transform=trans, color='k')\n        hlines_idx = np.unravel_index(pd_plot_idx, self.deciles_hlines_.shape)\n        self.deciles_hlines_[hlines_idx] = ax.hlines(self.deciles[feature_idx[1]], 0, 0.05, transform=trans, color='k')\n        ax.set_xlim(xlim)\n        ax.set_ylim(ylim)\n        if not ax.get_xlabel():\n            ax.set_xlabel(self.feature_names[feature_idx[0]])\n        ax.set_ylabel(self.feature_names[feature_idx[1]])"
        ]
    },
    {
        "func_name": "plot",
        "original": "def plot(self, *, ax=None, n_cols=3, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, bar_kw=None, heatmap_kw=None, pdp_lim=None, centered=False):\n    \"\"\"Plot partial dependence plots.\n\n        Parameters\n        ----------\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\n            - If a single axis is passed in, it is treated as a bounding axes\n                and a grid of partial dependence plots will be drawn within\n                these bounds. The `n_cols` parameter controls the number of\n                columns in the grid.\n            - If an array-like of axes are passed in, the partial dependence\n                plots will be drawn directly into these axes.\n            - If `None`, a figure and a bounding axes is created and treated\n                as the single axes case.\n\n        n_cols : int, default=3\n            The maximum number of columns in the grid plot. Only active when\n            `ax` is a single axes or `None`.\n\n        line_kw : dict, default=None\n            Dict with keywords passed to the `matplotlib.pyplot.plot` call.\n            For one-way partial dependence plots.\n\n        ice_lines_kw : dict, default=None\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\n            For ICE lines in the one-way partial dependence plots.\n            The key value pairs defined in `ice_lines_kw` takes priority over\n            `line_kw`.\n\n            .. versionadded:: 1.0\n\n        pd_line_kw : dict, default=None\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\n            For partial dependence in one-way partial dependence plots.\n            The key value pairs defined in `pd_line_kw` takes priority over\n            `line_kw`.\n\n            .. versionadded:: 1.0\n\n        contour_kw : dict, default=None\n            Dict with keywords passed to the `matplotlib.pyplot.contourf`\n            call for two-way partial dependence plots.\n\n        bar_kw : dict, default=None\n            Dict with keywords passed to the `matplotlib.pyplot.bar`\n            call for one-way categorical partial dependence plots.\n\n            .. versionadded:: 1.2\n\n        heatmap_kw : dict, default=None\n            Dict with keywords passed to the `matplotlib.pyplot.imshow`\n            call for two-way categorical partial dependence plots.\n\n            .. versionadded:: 1.2\n\n        pdp_lim : dict, default=None\n            Global min and max average predictions, such that all plots will have the\n            same scale and y limits. `pdp_lim[1]` is the global min and max for single\n            partial dependence curves. `pdp_lim[2]` is the global min and max for\n            two-way partial dependence curves. If `None` (default), the limit will be\n            inferred from the global minimum and maximum of all predictions.\n\n            .. versionadded:: 1.1\n\n        centered : bool, default=False\n            If `True`, the ICE and PD lines will start at the origin of the\n            y-axis. By default, no centering is done.\n\n            .. versionadded:: 1.1\n\n        Returns\n        -------\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\n            Returns a :class:`~sklearn.inspection.PartialDependenceDisplay`\n            object that contains the partial dependence plots.\n        \"\"\"\n    check_matplotlib_support('plot_partial_dependence')\n    import matplotlib.pyplot as plt\n    from matplotlib.gridspec import GridSpecFromSubplotSpec\n    if isinstance(self.kind, str):\n        kind = [self.kind] * len(self.features)\n    else:\n        kind = self.kind\n    if self.is_categorical is None:\n        is_categorical = [(False,) if len(fx) == 1 else (False, False) for fx in self.features]\n    else:\n        is_categorical = self.is_categorical\n    if len(kind) != len(self.features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind)} element(s) and `features` contains {len(self.features)} element(s).')\n    valid_kinds = {'average', 'individual', 'both'}\n    if any([k not in valid_kinds for k in kind]):\n        raise ValueError(f'Values provided to `kind` must be one of: {valid_kinds!r} or a list of such values. Currently, kind={self.kind!r}')\n    if not centered:\n        pd_results_ = self.pd_results\n    else:\n        pd_results_ = []\n        for (kind_plot, pd_result) in zip(kind, self.pd_results):\n            current_results = {'grid_values': pd_result['grid_values']}\n            if kind_plot in ('individual', 'both'):\n                preds = pd_result.individual\n                preds = preds - preds[self.target_idx, :, 0, None]\n                current_results['individual'] = preds\n            if kind_plot in ('average', 'both'):\n                avg_preds = pd_result.average\n                avg_preds = avg_preds - avg_preds[self.target_idx, 0, None]\n                current_results['average'] = avg_preds\n            pd_results_.append(Bunch(**current_results))\n    if pdp_lim is None:\n        pdp_lim = {}\n        for (kind_plot, pdp) in zip(kind, pd_results_):\n            values = pdp['grid_values']\n            preds = pdp.average if kind_plot == 'average' else pdp.individual\n            min_pd = preds[self.target_idx].min()\n            max_pd = preds[self.target_idx].max()\n            span = max_pd - min_pd\n            min_pd -= 0.05 * span\n            max_pd += 0.05 * span\n            n_fx = len(values)\n            (old_min_pd, old_max_pd) = pdp_lim.get(n_fx, (min_pd, max_pd))\n            min_pd = min(min_pd, old_min_pd)\n            max_pd = max(max_pd, old_max_pd)\n            pdp_lim[n_fx] = (min_pd, max_pd)\n    if line_kw is None:\n        line_kw = {}\n    if ice_lines_kw is None:\n        ice_lines_kw = {}\n    if pd_line_kw is None:\n        pd_line_kw = {}\n    if bar_kw is None:\n        bar_kw = {}\n    if heatmap_kw is None:\n        heatmap_kw = {}\n    if ax is None:\n        (_, ax) = plt.subplots()\n    if contour_kw is None:\n        contour_kw = {}\n    default_contour_kws = {'alpha': 0.75}\n    contour_kw = {**default_contour_kws, **contour_kw}\n    n_features = len(self.features)\n    is_average_plot = [kind_plot == 'average' for kind_plot in kind]\n    if all(is_average_plot):\n        n_ice_lines = 0\n        n_lines = 1\n    else:\n        ice_plot_idx = is_average_plot.index(False)\n        n_ice_lines = self._get_sample_count(len(pd_results_[ice_plot_idx].individual[0]))\n        if any([kind_plot == 'both' for kind_plot in kind]):\n            n_lines = n_ice_lines + 1\n        else:\n            n_lines = n_ice_lines\n    if isinstance(ax, plt.Axes):\n        if not ax.axison:\n            raise ValueError('The ax was already used in another plot function, please set ax=display.axes_ instead')\n        ax.set_axis_off()\n        self.bounding_ax_ = ax\n        self.figure_ = ax.figure\n        n_cols = min(n_cols, n_features)\n        n_rows = int(np.ceil(n_features / float(n_cols)))\n        self.axes_ = np.empty((n_rows, n_cols), dtype=object)\n        if all(is_average_plot):\n            self.lines_ = np.empty((n_rows, n_cols), dtype=object)\n        else:\n            self.lines_ = np.empty((n_rows, n_cols, n_lines), dtype=object)\n        self.contours_ = np.empty((n_rows, n_cols), dtype=object)\n        self.bars_ = np.empty((n_rows, n_cols), dtype=object)\n        self.heatmaps_ = np.empty((n_rows, n_cols), dtype=object)\n        axes_ravel = self.axes_.ravel()\n        gs = GridSpecFromSubplotSpec(n_rows, n_cols, subplot_spec=ax.get_subplotspec())\n        for (i, spec) in zip(range(n_features), gs):\n            axes_ravel[i] = self.figure_.add_subplot(spec)\n    else:\n        ax = np.asarray(ax, dtype=object)\n        if ax.size != n_features:\n            raise ValueError('Expected ax to have {} axes, got {}'.format(n_features, ax.size))\n        if ax.ndim == 2:\n            n_cols = ax.shape[1]\n        else:\n            n_cols = None\n        self.bounding_ax_ = None\n        self.figure_ = ax.ravel()[0].figure\n        self.axes_ = ax\n        if all(is_average_plot):\n            self.lines_ = np.empty_like(ax, dtype=object)\n        else:\n            self.lines_ = np.empty(ax.shape + (n_lines,), dtype=object)\n        self.contours_ = np.empty_like(ax, dtype=object)\n        self.bars_ = np.empty_like(ax, dtype=object)\n        self.heatmaps_ = np.empty_like(ax, dtype=object)\n    if 2 in pdp_lim:\n        Z_level = np.linspace(*pdp_lim[2], num=8)\n    self.deciles_vlines_ = np.empty_like(self.axes_, dtype=object)\n    self.deciles_hlines_ = np.empty_like(self.axes_, dtype=object)\n    for (pd_plot_idx, (axi, feature_idx, cat, pd_result, kind_plot)) in enumerate(zip(self.axes_.ravel(), self.features, is_categorical, pd_results_, kind)):\n        avg_preds = None\n        preds = None\n        feature_values = pd_result['grid_values']\n        if kind_plot == 'individual':\n            preds = pd_result.individual\n        elif kind_plot == 'average':\n            avg_preds = pd_result.average\n        else:\n            avg_preds = pd_result.average\n            preds = pd_result.individual\n        if len(feature_values) == 1:\n            default_line_kws = {'color': 'C0', 'label': 'average' if kind_plot == 'both' else None}\n            if kind_plot == 'individual':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5}\n                default_pd_lines_kws = {}\n            elif kind_plot == 'both':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5, 'color': 'tab:blue'}\n                default_pd_lines_kws = {'color': 'tab:orange', 'linestyle': '--'}\n            else:\n                default_ice_lines_kws = {}\n                default_pd_lines_kws = {}\n            ice_lines_kw = {**default_line_kws, **default_ice_lines_kws, **line_kw, **ice_lines_kw}\n            del ice_lines_kw['label']\n            pd_line_kw = {**default_line_kws, **default_pd_lines_kws, **line_kw, **pd_line_kw}\n            default_bar_kws = {'color': 'C0'}\n            bar_kw = {**default_bar_kws, **bar_kw}\n            default_heatmap_kw = {}\n            heatmap_kw = {**default_heatmap_kw, **heatmap_kw}\n            self._plot_one_way_partial_dependence(kind_plot, preds, avg_preds, feature_values[0], feature_idx, n_ice_lines, axi, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, cat[0], bar_kw, pdp_lim)\n        else:\n            self._plot_two_way_partial_dependence(avg_preds, feature_values, feature_idx, axi, pd_plot_idx, Z_level, contour_kw, cat[0] and cat[1], heatmap_kw)\n    return self",
        "mutated": [
            "def plot(self, *, ax=None, n_cols=3, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, bar_kw=None, heatmap_kw=None, pdp_lim=None, centered=False):\n    if False:\n        i = 10\n    'Plot partial dependence plots.\\n\\n        Parameters\\n        ----------\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n                and a grid of partial dependence plots will be drawn within\\n                these bounds. The `n_cols` parameter controls the number of\\n                columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n                plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n                as the single axes case.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when\\n            `ax` is a single axes or `None`.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For one-way partial dependence plots.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.contourf`\\n            call for two-way partial dependence plots.\\n\\n        bar_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.bar`\\n            call for one-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        heatmap_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.imshow`\\n            call for two-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        pdp_lim : dict, default=None\\n            Global min and max average predictions, such that all plots will have the\\n            same scale and y limits. `pdp_lim[1]` is the global min and max for single\\n            partial dependence curves. `pdp_lim[2]` is the global min and max for\\n            two-way partial dependence curves. If `None` (default), the limit will be\\n            inferred from the global minimum and maximum of all predictions.\\n\\n            .. versionadded:: 1.1\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            Returns a :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            object that contains the partial dependence plots.\\n        '\n    check_matplotlib_support('plot_partial_dependence')\n    import matplotlib.pyplot as plt\n    from matplotlib.gridspec import GridSpecFromSubplotSpec\n    if isinstance(self.kind, str):\n        kind = [self.kind] * len(self.features)\n    else:\n        kind = self.kind\n    if self.is_categorical is None:\n        is_categorical = [(False,) if len(fx) == 1 else (False, False) for fx in self.features]\n    else:\n        is_categorical = self.is_categorical\n    if len(kind) != len(self.features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind)} element(s) and `features` contains {len(self.features)} element(s).')\n    valid_kinds = {'average', 'individual', 'both'}\n    if any([k not in valid_kinds for k in kind]):\n        raise ValueError(f'Values provided to `kind` must be one of: {valid_kinds!r} or a list of such values. Currently, kind={self.kind!r}')\n    if not centered:\n        pd_results_ = self.pd_results\n    else:\n        pd_results_ = []\n        for (kind_plot, pd_result) in zip(kind, self.pd_results):\n            current_results = {'grid_values': pd_result['grid_values']}\n            if kind_plot in ('individual', 'both'):\n                preds = pd_result.individual\n                preds = preds - preds[self.target_idx, :, 0, None]\n                current_results['individual'] = preds\n            if kind_plot in ('average', 'both'):\n                avg_preds = pd_result.average\n                avg_preds = avg_preds - avg_preds[self.target_idx, 0, None]\n                current_results['average'] = avg_preds\n            pd_results_.append(Bunch(**current_results))\n    if pdp_lim is None:\n        pdp_lim = {}\n        for (kind_plot, pdp) in zip(kind, pd_results_):\n            values = pdp['grid_values']\n            preds = pdp.average if kind_plot == 'average' else pdp.individual\n            min_pd = preds[self.target_idx].min()\n            max_pd = preds[self.target_idx].max()\n            span = max_pd - min_pd\n            min_pd -= 0.05 * span\n            max_pd += 0.05 * span\n            n_fx = len(values)\n            (old_min_pd, old_max_pd) = pdp_lim.get(n_fx, (min_pd, max_pd))\n            min_pd = min(min_pd, old_min_pd)\n            max_pd = max(max_pd, old_max_pd)\n            pdp_lim[n_fx] = (min_pd, max_pd)\n    if line_kw is None:\n        line_kw = {}\n    if ice_lines_kw is None:\n        ice_lines_kw = {}\n    if pd_line_kw is None:\n        pd_line_kw = {}\n    if bar_kw is None:\n        bar_kw = {}\n    if heatmap_kw is None:\n        heatmap_kw = {}\n    if ax is None:\n        (_, ax) = plt.subplots()\n    if contour_kw is None:\n        contour_kw = {}\n    default_contour_kws = {'alpha': 0.75}\n    contour_kw = {**default_contour_kws, **contour_kw}\n    n_features = len(self.features)\n    is_average_plot = [kind_plot == 'average' for kind_plot in kind]\n    if all(is_average_plot):\n        n_ice_lines = 0\n        n_lines = 1\n    else:\n        ice_plot_idx = is_average_plot.index(False)\n        n_ice_lines = self._get_sample_count(len(pd_results_[ice_plot_idx].individual[0]))\n        if any([kind_plot == 'both' for kind_plot in kind]):\n            n_lines = n_ice_lines + 1\n        else:\n            n_lines = n_ice_lines\n    if isinstance(ax, plt.Axes):\n        if not ax.axison:\n            raise ValueError('The ax was already used in another plot function, please set ax=display.axes_ instead')\n        ax.set_axis_off()\n        self.bounding_ax_ = ax\n        self.figure_ = ax.figure\n        n_cols = min(n_cols, n_features)\n        n_rows = int(np.ceil(n_features / float(n_cols)))\n        self.axes_ = np.empty((n_rows, n_cols), dtype=object)\n        if all(is_average_plot):\n            self.lines_ = np.empty((n_rows, n_cols), dtype=object)\n        else:\n            self.lines_ = np.empty((n_rows, n_cols, n_lines), dtype=object)\n        self.contours_ = np.empty((n_rows, n_cols), dtype=object)\n        self.bars_ = np.empty((n_rows, n_cols), dtype=object)\n        self.heatmaps_ = np.empty((n_rows, n_cols), dtype=object)\n        axes_ravel = self.axes_.ravel()\n        gs = GridSpecFromSubplotSpec(n_rows, n_cols, subplot_spec=ax.get_subplotspec())\n        for (i, spec) in zip(range(n_features), gs):\n            axes_ravel[i] = self.figure_.add_subplot(spec)\n    else:\n        ax = np.asarray(ax, dtype=object)\n        if ax.size != n_features:\n            raise ValueError('Expected ax to have {} axes, got {}'.format(n_features, ax.size))\n        if ax.ndim == 2:\n            n_cols = ax.shape[1]\n        else:\n            n_cols = None\n        self.bounding_ax_ = None\n        self.figure_ = ax.ravel()[0].figure\n        self.axes_ = ax\n        if all(is_average_plot):\n            self.lines_ = np.empty_like(ax, dtype=object)\n        else:\n            self.lines_ = np.empty(ax.shape + (n_lines,), dtype=object)\n        self.contours_ = np.empty_like(ax, dtype=object)\n        self.bars_ = np.empty_like(ax, dtype=object)\n        self.heatmaps_ = np.empty_like(ax, dtype=object)\n    if 2 in pdp_lim:\n        Z_level = np.linspace(*pdp_lim[2], num=8)\n    self.deciles_vlines_ = np.empty_like(self.axes_, dtype=object)\n    self.deciles_hlines_ = np.empty_like(self.axes_, dtype=object)\n    for (pd_plot_idx, (axi, feature_idx, cat, pd_result, kind_plot)) in enumerate(zip(self.axes_.ravel(), self.features, is_categorical, pd_results_, kind)):\n        avg_preds = None\n        preds = None\n        feature_values = pd_result['grid_values']\n        if kind_plot == 'individual':\n            preds = pd_result.individual\n        elif kind_plot == 'average':\n            avg_preds = pd_result.average\n        else:\n            avg_preds = pd_result.average\n            preds = pd_result.individual\n        if len(feature_values) == 1:\n            default_line_kws = {'color': 'C0', 'label': 'average' if kind_plot == 'both' else None}\n            if kind_plot == 'individual':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5}\n                default_pd_lines_kws = {}\n            elif kind_plot == 'both':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5, 'color': 'tab:blue'}\n                default_pd_lines_kws = {'color': 'tab:orange', 'linestyle': '--'}\n            else:\n                default_ice_lines_kws = {}\n                default_pd_lines_kws = {}\n            ice_lines_kw = {**default_line_kws, **default_ice_lines_kws, **line_kw, **ice_lines_kw}\n            del ice_lines_kw['label']\n            pd_line_kw = {**default_line_kws, **default_pd_lines_kws, **line_kw, **pd_line_kw}\n            default_bar_kws = {'color': 'C0'}\n            bar_kw = {**default_bar_kws, **bar_kw}\n            default_heatmap_kw = {}\n            heatmap_kw = {**default_heatmap_kw, **heatmap_kw}\n            self._plot_one_way_partial_dependence(kind_plot, preds, avg_preds, feature_values[0], feature_idx, n_ice_lines, axi, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, cat[0], bar_kw, pdp_lim)\n        else:\n            self._plot_two_way_partial_dependence(avg_preds, feature_values, feature_idx, axi, pd_plot_idx, Z_level, contour_kw, cat[0] and cat[1], heatmap_kw)\n    return self",
            "def plot(self, *, ax=None, n_cols=3, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, bar_kw=None, heatmap_kw=None, pdp_lim=None, centered=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plot partial dependence plots.\\n\\n        Parameters\\n        ----------\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n                and a grid of partial dependence plots will be drawn within\\n                these bounds. The `n_cols` parameter controls the number of\\n                columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n                plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n                as the single axes case.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when\\n            `ax` is a single axes or `None`.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For one-way partial dependence plots.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.contourf`\\n            call for two-way partial dependence plots.\\n\\n        bar_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.bar`\\n            call for one-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        heatmap_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.imshow`\\n            call for two-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        pdp_lim : dict, default=None\\n            Global min and max average predictions, such that all plots will have the\\n            same scale and y limits. `pdp_lim[1]` is the global min and max for single\\n            partial dependence curves. `pdp_lim[2]` is the global min and max for\\n            two-way partial dependence curves. If `None` (default), the limit will be\\n            inferred from the global minimum and maximum of all predictions.\\n\\n            .. versionadded:: 1.1\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            Returns a :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            object that contains the partial dependence plots.\\n        '\n    check_matplotlib_support('plot_partial_dependence')\n    import matplotlib.pyplot as plt\n    from matplotlib.gridspec import GridSpecFromSubplotSpec\n    if isinstance(self.kind, str):\n        kind = [self.kind] * len(self.features)\n    else:\n        kind = self.kind\n    if self.is_categorical is None:\n        is_categorical = [(False,) if len(fx) == 1 else (False, False) for fx in self.features]\n    else:\n        is_categorical = self.is_categorical\n    if len(kind) != len(self.features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind)} element(s) and `features` contains {len(self.features)} element(s).')\n    valid_kinds = {'average', 'individual', 'both'}\n    if any([k not in valid_kinds for k in kind]):\n        raise ValueError(f'Values provided to `kind` must be one of: {valid_kinds!r} or a list of such values. Currently, kind={self.kind!r}')\n    if not centered:\n        pd_results_ = self.pd_results\n    else:\n        pd_results_ = []\n        for (kind_plot, pd_result) in zip(kind, self.pd_results):\n            current_results = {'grid_values': pd_result['grid_values']}\n            if kind_plot in ('individual', 'both'):\n                preds = pd_result.individual\n                preds = preds - preds[self.target_idx, :, 0, None]\n                current_results['individual'] = preds\n            if kind_plot in ('average', 'both'):\n                avg_preds = pd_result.average\n                avg_preds = avg_preds - avg_preds[self.target_idx, 0, None]\n                current_results['average'] = avg_preds\n            pd_results_.append(Bunch(**current_results))\n    if pdp_lim is None:\n        pdp_lim = {}\n        for (kind_plot, pdp) in zip(kind, pd_results_):\n            values = pdp['grid_values']\n            preds = pdp.average if kind_plot == 'average' else pdp.individual\n            min_pd = preds[self.target_idx].min()\n            max_pd = preds[self.target_idx].max()\n            span = max_pd - min_pd\n            min_pd -= 0.05 * span\n            max_pd += 0.05 * span\n            n_fx = len(values)\n            (old_min_pd, old_max_pd) = pdp_lim.get(n_fx, (min_pd, max_pd))\n            min_pd = min(min_pd, old_min_pd)\n            max_pd = max(max_pd, old_max_pd)\n            pdp_lim[n_fx] = (min_pd, max_pd)\n    if line_kw is None:\n        line_kw = {}\n    if ice_lines_kw is None:\n        ice_lines_kw = {}\n    if pd_line_kw is None:\n        pd_line_kw = {}\n    if bar_kw is None:\n        bar_kw = {}\n    if heatmap_kw is None:\n        heatmap_kw = {}\n    if ax is None:\n        (_, ax) = plt.subplots()\n    if contour_kw is None:\n        contour_kw = {}\n    default_contour_kws = {'alpha': 0.75}\n    contour_kw = {**default_contour_kws, **contour_kw}\n    n_features = len(self.features)\n    is_average_plot = [kind_plot == 'average' for kind_plot in kind]\n    if all(is_average_plot):\n        n_ice_lines = 0\n        n_lines = 1\n    else:\n        ice_plot_idx = is_average_plot.index(False)\n        n_ice_lines = self._get_sample_count(len(pd_results_[ice_plot_idx].individual[0]))\n        if any([kind_plot == 'both' for kind_plot in kind]):\n            n_lines = n_ice_lines + 1\n        else:\n            n_lines = n_ice_lines\n    if isinstance(ax, plt.Axes):\n        if not ax.axison:\n            raise ValueError('The ax was already used in another plot function, please set ax=display.axes_ instead')\n        ax.set_axis_off()\n        self.bounding_ax_ = ax\n        self.figure_ = ax.figure\n        n_cols = min(n_cols, n_features)\n        n_rows = int(np.ceil(n_features / float(n_cols)))\n        self.axes_ = np.empty((n_rows, n_cols), dtype=object)\n        if all(is_average_plot):\n            self.lines_ = np.empty((n_rows, n_cols), dtype=object)\n        else:\n            self.lines_ = np.empty((n_rows, n_cols, n_lines), dtype=object)\n        self.contours_ = np.empty((n_rows, n_cols), dtype=object)\n        self.bars_ = np.empty((n_rows, n_cols), dtype=object)\n        self.heatmaps_ = np.empty((n_rows, n_cols), dtype=object)\n        axes_ravel = self.axes_.ravel()\n        gs = GridSpecFromSubplotSpec(n_rows, n_cols, subplot_spec=ax.get_subplotspec())\n        for (i, spec) in zip(range(n_features), gs):\n            axes_ravel[i] = self.figure_.add_subplot(spec)\n    else:\n        ax = np.asarray(ax, dtype=object)\n        if ax.size != n_features:\n            raise ValueError('Expected ax to have {} axes, got {}'.format(n_features, ax.size))\n        if ax.ndim == 2:\n            n_cols = ax.shape[1]\n        else:\n            n_cols = None\n        self.bounding_ax_ = None\n        self.figure_ = ax.ravel()[0].figure\n        self.axes_ = ax\n        if all(is_average_plot):\n            self.lines_ = np.empty_like(ax, dtype=object)\n        else:\n            self.lines_ = np.empty(ax.shape + (n_lines,), dtype=object)\n        self.contours_ = np.empty_like(ax, dtype=object)\n        self.bars_ = np.empty_like(ax, dtype=object)\n        self.heatmaps_ = np.empty_like(ax, dtype=object)\n    if 2 in pdp_lim:\n        Z_level = np.linspace(*pdp_lim[2], num=8)\n    self.deciles_vlines_ = np.empty_like(self.axes_, dtype=object)\n    self.deciles_hlines_ = np.empty_like(self.axes_, dtype=object)\n    for (pd_plot_idx, (axi, feature_idx, cat, pd_result, kind_plot)) in enumerate(zip(self.axes_.ravel(), self.features, is_categorical, pd_results_, kind)):\n        avg_preds = None\n        preds = None\n        feature_values = pd_result['grid_values']\n        if kind_plot == 'individual':\n            preds = pd_result.individual\n        elif kind_plot == 'average':\n            avg_preds = pd_result.average\n        else:\n            avg_preds = pd_result.average\n            preds = pd_result.individual\n        if len(feature_values) == 1:\n            default_line_kws = {'color': 'C0', 'label': 'average' if kind_plot == 'both' else None}\n            if kind_plot == 'individual':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5}\n                default_pd_lines_kws = {}\n            elif kind_plot == 'both':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5, 'color': 'tab:blue'}\n                default_pd_lines_kws = {'color': 'tab:orange', 'linestyle': '--'}\n            else:\n                default_ice_lines_kws = {}\n                default_pd_lines_kws = {}\n            ice_lines_kw = {**default_line_kws, **default_ice_lines_kws, **line_kw, **ice_lines_kw}\n            del ice_lines_kw['label']\n            pd_line_kw = {**default_line_kws, **default_pd_lines_kws, **line_kw, **pd_line_kw}\n            default_bar_kws = {'color': 'C0'}\n            bar_kw = {**default_bar_kws, **bar_kw}\n            default_heatmap_kw = {}\n            heatmap_kw = {**default_heatmap_kw, **heatmap_kw}\n            self._plot_one_way_partial_dependence(kind_plot, preds, avg_preds, feature_values[0], feature_idx, n_ice_lines, axi, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, cat[0], bar_kw, pdp_lim)\n        else:\n            self._plot_two_way_partial_dependence(avg_preds, feature_values, feature_idx, axi, pd_plot_idx, Z_level, contour_kw, cat[0] and cat[1], heatmap_kw)\n    return self",
            "def plot(self, *, ax=None, n_cols=3, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, bar_kw=None, heatmap_kw=None, pdp_lim=None, centered=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plot partial dependence plots.\\n\\n        Parameters\\n        ----------\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n                and a grid of partial dependence plots will be drawn within\\n                these bounds. The `n_cols` parameter controls the number of\\n                columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n                plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n                as the single axes case.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when\\n            `ax` is a single axes or `None`.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For one-way partial dependence plots.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.contourf`\\n            call for two-way partial dependence plots.\\n\\n        bar_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.bar`\\n            call for one-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        heatmap_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.imshow`\\n            call for two-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        pdp_lim : dict, default=None\\n            Global min and max average predictions, such that all plots will have the\\n            same scale and y limits. `pdp_lim[1]` is the global min and max for single\\n            partial dependence curves. `pdp_lim[2]` is the global min and max for\\n            two-way partial dependence curves. If `None` (default), the limit will be\\n            inferred from the global minimum and maximum of all predictions.\\n\\n            .. versionadded:: 1.1\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            Returns a :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            object that contains the partial dependence plots.\\n        '\n    check_matplotlib_support('plot_partial_dependence')\n    import matplotlib.pyplot as plt\n    from matplotlib.gridspec import GridSpecFromSubplotSpec\n    if isinstance(self.kind, str):\n        kind = [self.kind] * len(self.features)\n    else:\n        kind = self.kind\n    if self.is_categorical is None:\n        is_categorical = [(False,) if len(fx) == 1 else (False, False) for fx in self.features]\n    else:\n        is_categorical = self.is_categorical\n    if len(kind) != len(self.features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind)} element(s) and `features` contains {len(self.features)} element(s).')\n    valid_kinds = {'average', 'individual', 'both'}\n    if any([k not in valid_kinds for k in kind]):\n        raise ValueError(f'Values provided to `kind` must be one of: {valid_kinds!r} or a list of such values. Currently, kind={self.kind!r}')\n    if not centered:\n        pd_results_ = self.pd_results\n    else:\n        pd_results_ = []\n        for (kind_plot, pd_result) in zip(kind, self.pd_results):\n            current_results = {'grid_values': pd_result['grid_values']}\n            if kind_plot in ('individual', 'both'):\n                preds = pd_result.individual\n                preds = preds - preds[self.target_idx, :, 0, None]\n                current_results['individual'] = preds\n            if kind_plot in ('average', 'both'):\n                avg_preds = pd_result.average\n                avg_preds = avg_preds - avg_preds[self.target_idx, 0, None]\n                current_results['average'] = avg_preds\n            pd_results_.append(Bunch(**current_results))\n    if pdp_lim is None:\n        pdp_lim = {}\n        for (kind_plot, pdp) in zip(kind, pd_results_):\n            values = pdp['grid_values']\n            preds = pdp.average if kind_plot == 'average' else pdp.individual\n            min_pd = preds[self.target_idx].min()\n            max_pd = preds[self.target_idx].max()\n            span = max_pd - min_pd\n            min_pd -= 0.05 * span\n            max_pd += 0.05 * span\n            n_fx = len(values)\n            (old_min_pd, old_max_pd) = pdp_lim.get(n_fx, (min_pd, max_pd))\n            min_pd = min(min_pd, old_min_pd)\n            max_pd = max(max_pd, old_max_pd)\n            pdp_lim[n_fx] = (min_pd, max_pd)\n    if line_kw is None:\n        line_kw = {}\n    if ice_lines_kw is None:\n        ice_lines_kw = {}\n    if pd_line_kw is None:\n        pd_line_kw = {}\n    if bar_kw is None:\n        bar_kw = {}\n    if heatmap_kw is None:\n        heatmap_kw = {}\n    if ax is None:\n        (_, ax) = plt.subplots()\n    if contour_kw is None:\n        contour_kw = {}\n    default_contour_kws = {'alpha': 0.75}\n    contour_kw = {**default_contour_kws, **contour_kw}\n    n_features = len(self.features)\n    is_average_plot = [kind_plot == 'average' for kind_plot in kind]\n    if all(is_average_plot):\n        n_ice_lines = 0\n        n_lines = 1\n    else:\n        ice_plot_idx = is_average_plot.index(False)\n        n_ice_lines = self._get_sample_count(len(pd_results_[ice_plot_idx].individual[0]))\n        if any([kind_plot == 'both' for kind_plot in kind]):\n            n_lines = n_ice_lines + 1\n        else:\n            n_lines = n_ice_lines\n    if isinstance(ax, plt.Axes):\n        if not ax.axison:\n            raise ValueError('The ax was already used in another plot function, please set ax=display.axes_ instead')\n        ax.set_axis_off()\n        self.bounding_ax_ = ax\n        self.figure_ = ax.figure\n        n_cols = min(n_cols, n_features)\n        n_rows = int(np.ceil(n_features / float(n_cols)))\n        self.axes_ = np.empty((n_rows, n_cols), dtype=object)\n        if all(is_average_plot):\n            self.lines_ = np.empty((n_rows, n_cols), dtype=object)\n        else:\n            self.lines_ = np.empty((n_rows, n_cols, n_lines), dtype=object)\n        self.contours_ = np.empty((n_rows, n_cols), dtype=object)\n        self.bars_ = np.empty((n_rows, n_cols), dtype=object)\n        self.heatmaps_ = np.empty((n_rows, n_cols), dtype=object)\n        axes_ravel = self.axes_.ravel()\n        gs = GridSpecFromSubplotSpec(n_rows, n_cols, subplot_spec=ax.get_subplotspec())\n        for (i, spec) in zip(range(n_features), gs):\n            axes_ravel[i] = self.figure_.add_subplot(spec)\n    else:\n        ax = np.asarray(ax, dtype=object)\n        if ax.size != n_features:\n            raise ValueError('Expected ax to have {} axes, got {}'.format(n_features, ax.size))\n        if ax.ndim == 2:\n            n_cols = ax.shape[1]\n        else:\n            n_cols = None\n        self.bounding_ax_ = None\n        self.figure_ = ax.ravel()[0].figure\n        self.axes_ = ax\n        if all(is_average_plot):\n            self.lines_ = np.empty_like(ax, dtype=object)\n        else:\n            self.lines_ = np.empty(ax.shape + (n_lines,), dtype=object)\n        self.contours_ = np.empty_like(ax, dtype=object)\n        self.bars_ = np.empty_like(ax, dtype=object)\n        self.heatmaps_ = np.empty_like(ax, dtype=object)\n    if 2 in pdp_lim:\n        Z_level = np.linspace(*pdp_lim[2], num=8)\n    self.deciles_vlines_ = np.empty_like(self.axes_, dtype=object)\n    self.deciles_hlines_ = np.empty_like(self.axes_, dtype=object)\n    for (pd_plot_idx, (axi, feature_idx, cat, pd_result, kind_plot)) in enumerate(zip(self.axes_.ravel(), self.features, is_categorical, pd_results_, kind)):\n        avg_preds = None\n        preds = None\n        feature_values = pd_result['grid_values']\n        if kind_plot == 'individual':\n            preds = pd_result.individual\n        elif kind_plot == 'average':\n            avg_preds = pd_result.average\n        else:\n            avg_preds = pd_result.average\n            preds = pd_result.individual\n        if len(feature_values) == 1:\n            default_line_kws = {'color': 'C0', 'label': 'average' if kind_plot == 'both' else None}\n            if kind_plot == 'individual':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5}\n                default_pd_lines_kws = {}\n            elif kind_plot == 'both':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5, 'color': 'tab:blue'}\n                default_pd_lines_kws = {'color': 'tab:orange', 'linestyle': '--'}\n            else:\n                default_ice_lines_kws = {}\n                default_pd_lines_kws = {}\n            ice_lines_kw = {**default_line_kws, **default_ice_lines_kws, **line_kw, **ice_lines_kw}\n            del ice_lines_kw['label']\n            pd_line_kw = {**default_line_kws, **default_pd_lines_kws, **line_kw, **pd_line_kw}\n            default_bar_kws = {'color': 'C0'}\n            bar_kw = {**default_bar_kws, **bar_kw}\n            default_heatmap_kw = {}\n            heatmap_kw = {**default_heatmap_kw, **heatmap_kw}\n            self._plot_one_way_partial_dependence(kind_plot, preds, avg_preds, feature_values[0], feature_idx, n_ice_lines, axi, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, cat[0], bar_kw, pdp_lim)\n        else:\n            self._plot_two_way_partial_dependence(avg_preds, feature_values, feature_idx, axi, pd_plot_idx, Z_level, contour_kw, cat[0] and cat[1], heatmap_kw)\n    return self",
            "def plot(self, *, ax=None, n_cols=3, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, bar_kw=None, heatmap_kw=None, pdp_lim=None, centered=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plot partial dependence plots.\\n\\n        Parameters\\n        ----------\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n                and a grid of partial dependence plots will be drawn within\\n                these bounds. The `n_cols` parameter controls the number of\\n                columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n                plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n                as the single axes case.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when\\n            `ax` is a single axes or `None`.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For one-way partial dependence plots.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.contourf`\\n            call for two-way partial dependence plots.\\n\\n        bar_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.bar`\\n            call for one-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        heatmap_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.imshow`\\n            call for two-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        pdp_lim : dict, default=None\\n            Global min and max average predictions, such that all plots will have the\\n            same scale and y limits. `pdp_lim[1]` is the global min and max for single\\n            partial dependence curves. `pdp_lim[2]` is the global min and max for\\n            two-way partial dependence curves. If `None` (default), the limit will be\\n            inferred from the global minimum and maximum of all predictions.\\n\\n            .. versionadded:: 1.1\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            Returns a :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            object that contains the partial dependence plots.\\n        '\n    check_matplotlib_support('plot_partial_dependence')\n    import matplotlib.pyplot as plt\n    from matplotlib.gridspec import GridSpecFromSubplotSpec\n    if isinstance(self.kind, str):\n        kind = [self.kind] * len(self.features)\n    else:\n        kind = self.kind\n    if self.is_categorical is None:\n        is_categorical = [(False,) if len(fx) == 1 else (False, False) for fx in self.features]\n    else:\n        is_categorical = self.is_categorical\n    if len(kind) != len(self.features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind)} element(s) and `features` contains {len(self.features)} element(s).')\n    valid_kinds = {'average', 'individual', 'both'}\n    if any([k not in valid_kinds for k in kind]):\n        raise ValueError(f'Values provided to `kind` must be one of: {valid_kinds!r} or a list of such values. Currently, kind={self.kind!r}')\n    if not centered:\n        pd_results_ = self.pd_results\n    else:\n        pd_results_ = []\n        for (kind_plot, pd_result) in zip(kind, self.pd_results):\n            current_results = {'grid_values': pd_result['grid_values']}\n            if kind_plot in ('individual', 'both'):\n                preds = pd_result.individual\n                preds = preds - preds[self.target_idx, :, 0, None]\n                current_results['individual'] = preds\n            if kind_plot in ('average', 'both'):\n                avg_preds = pd_result.average\n                avg_preds = avg_preds - avg_preds[self.target_idx, 0, None]\n                current_results['average'] = avg_preds\n            pd_results_.append(Bunch(**current_results))\n    if pdp_lim is None:\n        pdp_lim = {}\n        for (kind_plot, pdp) in zip(kind, pd_results_):\n            values = pdp['grid_values']\n            preds = pdp.average if kind_plot == 'average' else pdp.individual\n            min_pd = preds[self.target_idx].min()\n            max_pd = preds[self.target_idx].max()\n            span = max_pd - min_pd\n            min_pd -= 0.05 * span\n            max_pd += 0.05 * span\n            n_fx = len(values)\n            (old_min_pd, old_max_pd) = pdp_lim.get(n_fx, (min_pd, max_pd))\n            min_pd = min(min_pd, old_min_pd)\n            max_pd = max(max_pd, old_max_pd)\n            pdp_lim[n_fx] = (min_pd, max_pd)\n    if line_kw is None:\n        line_kw = {}\n    if ice_lines_kw is None:\n        ice_lines_kw = {}\n    if pd_line_kw is None:\n        pd_line_kw = {}\n    if bar_kw is None:\n        bar_kw = {}\n    if heatmap_kw is None:\n        heatmap_kw = {}\n    if ax is None:\n        (_, ax) = plt.subplots()\n    if contour_kw is None:\n        contour_kw = {}\n    default_contour_kws = {'alpha': 0.75}\n    contour_kw = {**default_contour_kws, **contour_kw}\n    n_features = len(self.features)\n    is_average_plot = [kind_plot == 'average' for kind_plot in kind]\n    if all(is_average_plot):\n        n_ice_lines = 0\n        n_lines = 1\n    else:\n        ice_plot_idx = is_average_plot.index(False)\n        n_ice_lines = self._get_sample_count(len(pd_results_[ice_plot_idx].individual[0]))\n        if any([kind_plot == 'both' for kind_plot in kind]):\n            n_lines = n_ice_lines + 1\n        else:\n            n_lines = n_ice_lines\n    if isinstance(ax, plt.Axes):\n        if not ax.axison:\n            raise ValueError('The ax was already used in another plot function, please set ax=display.axes_ instead')\n        ax.set_axis_off()\n        self.bounding_ax_ = ax\n        self.figure_ = ax.figure\n        n_cols = min(n_cols, n_features)\n        n_rows = int(np.ceil(n_features / float(n_cols)))\n        self.axes_ = np.empty((n_rows, n_cols), dtype=object)\n        if all(is_average_plot):\n            self.lines_ = np.empty((n_rows, n_cols), dtype=object)\n        else:\n            self.lines_ = np.empty((n_rows, n_cols, n_lines), dtype=object)\n        self.contours_ = np.empty((n_rows, n_cols), dtype=object)\n        self.bars_ = np.empty((n_rows, n_cols), dtype=object)\n        self.heatmaps_ = np.empty((n_rows, n_cols), dtype=object)\n        axes_ravel = self.axes_.ravel()\n        gs = GridSpecFromSubplotSpec(n_rows, n_cols, subplot_spec=ax.get_subplotspec())\n        for (i, spec) in zip(range(n_features), gs):\n            axes_ravel[i] = self.figure_.add_subplot(spec)\n    else:\n        ax = np.asarray(ax, dtype=object)\n        if ax.size != n_features:\n            raise ValueError('Expected ax to have {} axes, got {}'.format(n_features, ax.size))\n        if ax.ndim == 2:\n            n_cols = ax.shape[1]\n        else:\n            n_cols = None\n        self.bounding_ax_ = None\n        self.figure_ = ax.ravel()[0].figure\n        self.axes_ = ax\n        if all(is_average_plot):\n            self.lines_ = np.empty_like(ax, dtype=object)\n        else:\n            self.lines_ = np.empty(ax.shape + (n_lines,), dtype=object)\n        self.contours_ = np.empty_like(ax, dtype=object)\n        self.bars_ = np.empty_like(ax, dtype=object)\n        self.heatmaps_ = np.empty_like(ax, dtype=object)\n    if 2 in pdp_lim:\n        Z_level = np.linspace(*pdp_lim[2], num=8)\n    self.deciles_vlines_ = np.empty_like(self.axes_, dtype=object)\n    self.deciles_hlines_ = np.empty_like(self.axes_, dtype=object)\n    for (pd_plot_idx, (axi, feature_idx, cat, pd_result, kind_plot)) in enumerate(zip(self.axes_.ravel(), self.features, is_categorical, pd_results_, kind)):\n        avg_preds = None\n        preds = None\n        feature_values = pd_result['grid_values']\n        if kind_plot == 'individual':\n            preds = pd_result.individual\n        elif kind_plot == 'average':\n            avg_preds = pd_result.average\n        else:\n            avg_preds = pd_result.average\n            preds = pd_result.individual\n        if len(feature_values) == 1:\n            default_line_kws = {'color': 'C0', 'label': 'average' if kind_plot == 'both' else None}\n            if kind_plot == 'individual':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5}\n                default_pd_lines_kws = {}\n            elif kind_plot == 'both':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5, 'color': 'tab:blue'}\n                default_pd_lines_kws = {'color': 'tab:orange', 'linestyle': '--'}\n            else:\n                default_ice_lines_kws = {}\n                default_pd_lines_kws = {}\n            ice_lines_kw = {**default_line_kws, **default_ice_lines_kws, **line_kw, **ice_lines_kw}\n            del ice_lines_kw['label']\n            pd_line_kw = {**default_line_kws, **default_pd_lines_kws, **line_kw, **pd_line_kw}\n            default_bar_kws = {'color': 'C0'}\n            bar_kw = {**default_bar_kws, **bar_kw}\n            default_heatmap_kw = {}\n            heatmap_kw = {**default_heatmap_kw, **heatmap_kw}\n            self._plot_one_way_partial_dependence(kind_plot, preds, avg_preds, feature_values[0], feature_idx, n_ice_lines, axi, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, cat[0], bar_kw, pdp_lim)\n        else:\n            self._plot_two_way_partial_dependence(avg_preds, feature_values, feature_idx, axi, pd_plot_idx, Z_level, contour_kw, cat[0] and cat[1], heatmap_kw)\n    return self",
            "def plot(self, *, ax=None, n_cols=3, line_kw=None, ice_lines_kw=None, pd_line_kw=None, contour_kw=None, bar_kw=None, heatmap_kw=None, pdp_lim=None, centered=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plot partial dependence plots.\\n\\n        Parameters\\n        ----------\\n        ax : Matplotlib axes or array-like of Matplotlib axes, default=None\\n            - If a single axis is passed in, it is treated as a bounding axes\\n                and a grid of partial dependence plots will be drawn within\\n                these bounds. The `n_cols` parameter controls the number of\\n                columns in the grid.\\n            - If an array-like of axes are passed in, the partial dependence\\n                plots will be drawn directly into these axes.\\n            - If `None`, a figure and a bounding axes is created and treated\\n                as the single axes case.\\n\\n        n_cols : int, default=3\\n            The maximum number of columns in the grid plot. Only active when\\n            `ax` is a single axes or `None`.\\n\\n        line_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For one-way partial dependence plots.\\n\\n        ice_lines_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For ICE lines in the one-way partial dependence plots.\\n            The key value pairs defined in `ice_lines_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        pd_line_kw : dict, default=None\\n            Dictionary with keywords passed to the `matplotlib.pyplot.plot` call.\\n            For partial dependence in one-way partial dependence plots.\\n            The key value pairs defined in `pd_line_kw` takes priority over\\n            `line_kw`.\\n\\n            .. versionadded:: 1.0\\n\\n        contour_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.contourf`\\n            call for two-way partial dependence plots.\\n\\n        bar_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.bar`\\n            call for one-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        heatmap_kw : dict, default=None\\n            Dict with keywords passed to the `matplotlib.pyplot.imshow`\\n            call for two-way categorical partial dependence plots.\\n\\n            .. versionadded:: 1.2\\n\\n        pdp_lim : dict, default=None\\n            Global min and max average predictions, such that all plots will have the\\n            same scale and y limits. `pdp_lim[1]` is the global min and max for single\\n            partial dependence curves. `pdp_lim[2]` is the global min and max for\\n            two-way partial dependence curves. If `None` (default), the limit will be\\n            inferred from the global minimum and maximum of all predictions.\\n\\n            .. versionadded:: 1.1\\n\\n        centered : bool, default=False\\n            If `True`, the ICE and PD lines will start at the origin of the\\n            y-axis. By default, no centering is done.\\n\\n            .. versionadded:: 1.1\\n\\n        Returns\\n        -------\\n        display : :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            Returns a :class:`~sklearn.inspection.PartialDependenceDisplay`\\n            object that contains the partial dependence plots.\\n        '\n    check_matplotlib_support('plot_partial_dependence')\n    import matplotlib.pyplot as plt\n    from matplotlib.gridspec import GridSpecFromSubplotSpec\n    if isinstance(self.kind, str):\n        kind = [self.kind] * len(self.features)\n    else:\n        kind = self.kind\n    if self.is_categorical is None:\n        is_categorical = [(False,) if len(fx) == 1 else (False, False) for fx in self.features]\n    else:\n        is_categorical = self.is_categorical\n    if len(kind) != len(self.features):\n        raise ValueError(f'When `kind` is provided as a list of strings, it should contain as many elements as `features`. `kind` contains {len(kind)} element(s) and `features` contains {len(self.features)} element(s).')\n    valid_kinds = {'average', 'individual', 'both'}\n    if any([k not in valid_kinds for k in kind]):\n        raise ValueError(f'Values provided to `kind` must be one of: {valid_kinds!r} or a list of such values. Currently, kind={self.kind!r}')\n    if not centered:\n        pd_results_ = self.pd_results\n    else:\n        pd_results_ = []\n        for (kind_plot, pd_result) in zip(kind, self.pd_results):\n            current_results = {'grid_values': pd_result['grid_values']}\n            if kind_plot in ('individual', 'both'):\n                preds = pd_result.individual\n                preds = preds - preds[self.target_idx, :, 0, None]\n                current_results['individual'] = preds\n            if kind_plot in ('average', 'both'):\n                avg_preds = pd_result.average\n                avg_preds = avg_preds - avg_preds[self.target_idx, 0, None]\n                current_results['average'] = avg_preds\n            pd_results_.append(Bunch(**current_results))\n    if pdp_lim is None:\n        pdp_lim = {}\n        for (kind_plot, pdp) in zip(kind, pd_results_):\n            values = pdp['grid_values']\n            preds = pdp.average if kind_plot == 'average' else pdp.individual\n            min_pd = preds[self.target_idx].min()\n            max_pd = preds[self.target_idx].max()\n            span = max_pd - min_pd\n            min_pd -= 0.05 * span\n            max_pd += 0.05 * span\n            n_fx = len(values)\n            (old_min_pd, old_max_pd) = pdp_lim.get(n_fx, (min_pd, max_pd))\n            min_pd = min(min_pd, old_min_pd)\n            max_pd = max(max_pd, old_max_pd)\n            pdp_lim[n_fx] = (min_pd, max_pd)\n    if line_kw is None:\n        line_kw = {}\n    if ice_lines_kw is None:\n        ice_lines_kw = {}\n    if pd_line_kw is None:\n        pd_line_kw = {}\n    if bar_kw is None:\n        bar_kw = {}\n    if heatmap_kw is None:\n        heatmap_kw = {}\n    if ax is None:\n        (_, ax) = plt.subplots()\n    if contour_kw is None:\n        contour_kw = {}\n    default_contour_kws = {'alpha': 0.75}\n    contour_kw = {**default_contour_kws, **contour_kw}\n    n_features = len(self.features)\n    is_average_plot = [kind_plot == 'average' for kind_plot in kind]\n    if all(is_average_plot):\n        n_ice_lines = 0\n        n_lines = 1\n    else:\n        ice_plot_idx = is_average_plot.index(False)\n        n_ice_lines = self._get_sample_count(len(pd_results_[ice_plot_idx].individual[0]))\n        if any([kind_plot == 'both' for kind_plot in kind]):\n            n_lines = n_ice_lines + 1\n        else:\n            n_lines = n_ice_lines\n    if isinstance(ax, plt.Axes):\n        if not ax.axison:\n            raise ValueError('The ax was already used in another plot function, please set ax=display.axes_ instead')\n        ax.set_axis_off()\n        self.bounding_ax_ = ax\n        self.figure_ = ax.figure\n        n_cols = min(n_cols, n_features)\n        n_rows = int(np.ceil(n_features / float(n_cols)))\n        self.axes_ = np.empty((n_rows, n_cols), dtype=object)\n        if all(is_average_plot):\n            self.lines_ = np.empty((n_rows, n_cols), dtype=object)\n        else:\n            self.lines_ = np.empty((n_rows, n_cols, n_lines), dtype=object)\n        self.contours_ = np.empty((n_rows, n_cols), dtype=object)\n        self.bars_ = np.empty((n_rows, n_cols), dtype=object)\n        self.heatmaps_ = np.empty((n_rows, n_cols), dtype=object)\n        axes_ravel = self.axes_.ravel()\n        gs = GridSpecFromSubplotSpec(n_rows, n_cols, subplot_spec=ax.get_subplotspec())\n        for (i, spec) in zip(range(n_features), gs):\n            axes_ravel[i] = self.figure_.add_subplot(spec)\n    else:\n        ax = np.asarray(ax, dtype=object)\n        if ax.size != n_features:\n            raise ValueError('Expected ax to have {} axes, got {}'.format(n_features, ax.size))\n        if ax.ndim == 2:\n            n_cols = ax.shape[1]\n        else:\n            n_cols = None\n        self.bounding_ax_ = None\n        self.figure_ = ax.ravel()[0].figure\n        self.axes_ = ax\n        if all(is_average_plot):\n            self.lines_ = np.empty_like(ax, dtype=object)\n        else:\n            self.lines_ = np.empty(ax.shape + (n_lines,), dtype=object)\n        self.contours_ = np.empty_like(ax, dtype=object)\n        self.bars_ = np.empty_like(ax, dtype=object)\n        self.heatmaps_ = np.empty_like(ax, dtype=object)\n    if 2 in pdp_lim:\n        Z_level = np.linspace(*pdp_lim[2], num=8)\n    self.deciles_vlines_ = np.empty_like(self.axes_, dtype=object)\n    self.deciles_hlines_ = np.empty_like(self.axes_, dtype=object)\n    for (pd_plot_idx, (axi, feature_idx, cat, pd_result, kind_plot)) in enumerate(zip(self.axes_.ravel(), self.features, is_categorical, pd_results_, kind)):\n        avg_preds = None\n        preds = None\n        feature_values = pd_result['grid_values']\n        if kind_plot == 'individual':\n            preds = pd_result.individual\n        elif kind_plot == 'average':\n            avg_preds = pd_result.average\n        else:\n            avg_preds = pd_result.average\n            preds = pd_result.individual\n        if len(feature_values) == 1:\n            default_line_kws = {'color': 'C0', 'label': 'average' if kind_plot == 'both' else None}\n            if kind_plot == 'individual':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5}\n                default_pd_lines_kws = {}\n            elif kind_plot == 'both':\n                default_ice_lines_kws = {'alpha': 0.3, 'linewidth': 0.5, 'color': 'tab:blue'}\n                default_pd_lines_kws = {'color': 'tab:orange', 'linestyle': '--'}\n            else:\n                default_ice_lines_kws = {}\n                default_pd_lines_kws = {}\n            ice_lines_kw = {**default_line_kws, **default_ice_lines_kws, **line_kw, **ice_lines_kw}\n            del ice_lines_kw['label']\n            pd_line_kw = {**default_line_kws, **default_pd_lines_kws, **line_kw, **pd_line_kw}\n            default_bar_kws = {'color': 'C0'}\n            bar_kw = {**default_bar_kws, **bar_kw}\n            default_heatmap_kw = {}\n            heatmap_kw = {**default_heatmap_kw, **heatmap_kw}\n            self._plot_one_way_partial_dependence(kind_plot, preds, avg_preds, feature_values[0], feature_idx, n_ice_lines, axi, n_cols, pd_plot_idx, n_lines, ice_lines_kw, pd_line_kw, cat[0], bar_kw, pdp_lim)\n        else:\n            self._plot_two_way_partial_dependence(avg_preds, feature_values, feature_idx, axi, pd_plot_idx, Z_level, contour_kw, cat[0] and cat[1], heatmap_kw)\n    return self"
        ]
    }
]