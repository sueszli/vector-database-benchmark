DEBUG = False
if __name__ == '__main__' and (not DEBUG):
    print('Suppressing output of generate_hardware_hacking_substitutions.py')

def debug(*args, **kwargs):
    if False:
        for i in range(10):
            print('nop')
    if DEBUG:
        print(*args, **kwargs)
import os
import sys
import generate_tables
bindings_infos = generate_tables.bindings_infos
lang = 'en'
examples = {'c': 'C', 'csharp': 'C#', 'delphi': 'Delphi', 'java': 'Java', 'php': 'PHP', 'python': 'Python', 'ruby': 'Ruby', 'vbnet': 'Visual Basic .NET'}
binding_name = {'en': ':ref:`{0} <api_bindings_{1}>`', 'de': ':ref:`{0} <api_bindings_{1}>`'}
binding_names = {'en': '\n.. |bindings| replace:: {0}\n', 'de': '\n.. |bindings| replace:: {0}\n'}
common_intro = {'en': '\n>>>intro\nFor this project we are assuming, that you have a {0} development environment\nset up and that you have a rudimentary understanding of the {0} language.\n\nIf you are totally new to {0} itself you should start `here <{2}>`__. If you are\nnew to the Tinkerforge API, you should start :ref:`here <api_bindings_{1}>`.\n<<<intro\n', 'de': '\n>>>intro\nFür diese Projekt setzen wir voraus, dass eine {0} Entwicklungsumgebung\neingerichtet ist und ein grundsätzliches Verständnis der {0} Programmiersprache\nvorhanden ist.\n\nFalls dies nicht der Fall ist sollte `hier <{2}>`__ begonnen werden. Informationen\nüber die Tinkerforge API sind dann :ref:`hier <api_bindings_{1}>` zu finden.\n<<<intro\n'}
android_common_intro = {'en': '\n>>>intro\nFor this project we are assuming, that you have the `Android SDK\n<https://developer.android.com/sdk/index.html>`__ set up and that you have a\nrudimentary understanding of the Java language.\n\nIf you are totally new to Java itself you should start\n`here <https://docs.oracle.com/javase/tutorial/>`__.\nIf you are new to the Tinkerforge API, you should start\n:ref:`here <api_bindings_java_android>`.\n<<<intro\n', 'de': '\n>>>intro\nFür diese Projekt setzen wir voraus, dass das `Android SDK\n<https://developer.android.com/sdk/index.html>`__\neingerichtet ist und ein grundsätzliches Verständnis der Java Programmiersprache\nvorhanden ist.\n\nFalls dies nicht der Fall ist sollte\n`hier <https://docs.oracle.com/javase/tutorial/>`__ begonnen werden. Informationen\nüber die Tinkerforge API sind dann :ref:`hier <api_bindings_java_android>` zu\nfinden.\n<<<intro\n'}
windows_phone_common_intro = {'en': '\n>>>intro\nFor this project we are assuming, that you have the `Windows Phone SDK\n<https://dev.windowsphone.com/en-us/downloadsdk>`__ set up and that you have a\nrudimentary understanding of the C# language.\n\nIf you are totally new to C# itself you should start\n`here <https://csharp.net-tutorials.com/>`__.\nIf you are new to the Tinkerforge API, you should start\n:ref:`here <api_bindings_csharp_windows_phone>`.\n<<<intro\n', 'de': '\n>>>intro\nFür diese Projekt setzen wir voraus, dass das `Windows Phone SDK\n<https://dev.windowsphone.com/de-de/downloadsdk>`__\neingerichtet ist und ein grundsätzliches Verständnis der C# Programmiersprache\nvorhanden ist.\n\nFalls dies nicht der Fall ist sollte\n`hier <https://csharp.net-tutorials.com/>`__ begonnen werden. Informationen\nüber die Tinkerforge API sind dann :ref:`hier <api_bindings_csharp_windows_phone>`\nzu finden.\n<<<intro\n'}
ios_common_intro = {'en': '\n>>>intro\nFor this project we are assuming, that you have `Xcode\n<https://developer.apple.com/xcode/>`__ set up and that you have a\nrudimentary understanding of the Objective-C language.\n\nIf you are totally new to Objective-C itself you should start\n`here <https://cocoadevcentral.com/d/learn_objectivec/>`__.\nIf you are new to the Tinkerforge API, you should start\n:ref:`here <api_bindings_c_ios>`.\n<<<intro\n', 'de': '\n>>>intro\nFür diese Projekt setzen wir voraus, dass `Xcode\n<https://developer.apple.com/xcode/>`__\neingerichtet ist und ein grundsätzliches Verständnis der Objective-C\nProgrammiersprache vorhanden ist.\n\nFalls dies nicht der Fall ist sollte\n`hier <https://cocoadevcentral.com/d/learn_objectivec/>`__ begonnen werden. Informationen\nüber die Tinkerforge API sind dann :ref:`hier <api_bindings_c_ios>` zu finden.\n<<<intro\n'}
remote_switch_example_line = {'en': ':ref:`{0} <starter_kit_hardware_hacking_remote_switch_{1}>`', 'de': ':ref:`{0} <starter_kit_hardware_hacking_remote_switch_{1}>`'}
remote_switch_examples = {'en': '\n.. |remote_switch_examples| replace:: {0}\n', 'de': '\n.. |remote_switch_examples| replace:: {0}\n'}
remote_switch_examples_toctree_line = {'en': '   Using {0} <RemoteSwitch_{1}>', 'de': '   Mit {0} <RemoteSwitch_{1}>'}
remote_switch_examples_toctree = {'en': '.. toctree::\n   :hidden:\n\n{0}\n', 'de': '.. toctree::\n   :hidden:\n\n{0}\n'}
remote_switch_example_download_line = {'en': '`{0} <https://github.com/Tinkerforge/hardware-hacking/tree/master/remote_switch/{1}>`__', 'de': '`{0} <https://github.com/Tinkerforge/hardware-hacking/tree/master/remote_switch/{1}>`__'}
remote_switch_example_downloads = {'en': '\n.. |remote_switch_examples_download| replace:: {0}\n', 'de': '\n.. |remote_switch_examples_download| replace:: {0}\n'}
remote_switch_intro = {'en': '\n>>>intro\nWe are also assuming that you have the remote control connected to an\n:ref:`Industrial Quad Relay Bricklet <industrial_quad_relay_bricklet>`\nas described :ref:`here <starter_kit_hardware_hacking_remote_switch_hardware_setup>`.\n<<<intro\n', 'de': '\n>>>intro\nWir setzen weiterhin voraus, dass die Fernbedienung mit einem\n:ref:`Industrial Quad Relay Bricklet <industrial_quad_relay_bricklet>`\nverbunden wurde wie :ref:`hier <starter_kit_hardware_hacking_remote_switch_hardware_setup>`\nbeschrieben.\n<<<intro\n'}
remote_switch_goals = {'en': '\n>>>goals\nThe goal of this little project is to give an idea how the relays of the\nIndustrial Quad Relay Bricklet have to be switched to turn the mains\nswitches on/off.\n\nThe following code uses |ref_set_monoflop| to trigger a button\npress on the remote control. A monoflop will set a new state (relay open or close)\nand hold it for a given time (1.5s in the example code). After this time\nthe previous state is restored. This approach simulates a button click that\ntakes 1.5s (1500ms).\n\nAccording to the :ref:`hardware setup section\n<starter_kit_hardware_hacking_remote_switch_hardware_setup_relay_matrix>` the\ninputs of the remote control should be connected as follows:\n\n====== =====\nSignal Relay\n====== =====\nA      0\nB      1\nON     2\nOFF    3\n====== =====\n\nTo trigger the switch "A ON" of the remote control the relays 0 and 2 of the\nIndustrial Quad Relay Bricklet have to be closed. This is represented by the\nselection mask |bitmask_02|.\n\nSo the monoflop function should be called with this selection mask and\na time of 1500ms to simulate a button press of "A ON". See the following\nsource code for a minimal example.\n<<<goals\n', 'de': '\n>>>goals\nDas Ziel dieses kleinen Projekts ist es, eine Vorstellung darüber zu vermitteln\nwie die Relais des Industrial Quad Relay Bricklets geschaltet werden müssen,\ndamit die Funksteckdosen an- und ausgeschaltet werden können.\n\nDer folgende Quelltext benutzt |ref_set_monoflop| um eine Knopfdruck\nauf der Fernbedienung auszulösen. Ein Monoflop setzt einen neuen Zustand\n(Relais offen oder geschlossen) und hält diesen für eine bestimmte Zeit\n(1,5s im Beispielquelltext). Nach dieser Zeit wird der vorheriger Zustand\nwiederhergestellt. Dieses Ansatz simuliert einen Knopfdruck der für 1,5s\n(1500ms) anhält.\n\nGemäße der :ref:`Hardware-Aufbau Beschreibung\n<starter_kit_hardware_hacking_remote_switch_hardware_setup_relay_matrix>`\nist die Fernbedienung wie folgt mit den Relais verbunden:\n\n====== ======\nSignal Relais\n====== ======\nA      0\nB      1\nON     2\nOFF    3\n====== ======\n\nUm "A ON" auf der Fernbedienung auszulösen müssen also die Relais 0 und 2\ndes Industrial Quad Relay Bricklets geschlossen werden. Dies wird durch die\nBitmaske |bitmask_02| repräsentiert.\n\nDie Monoflop-Funktion kann also mit dieser Bitmaske und einer\nZeit von 1500ms aufgerufen werden um einen Knopfdruck von "A ON"\nzu simulieren. Im Folgenden wird dies in einem minimalen Beispielquelltext\ndargestellt.\n<<<goals\n'}
smoke_detector_example_line = {'en': ':ref:`{0} <starter_kit_hardware_hacking_smoke_detector_{1}>`', 'de': ':ref:`{0} <starter_kit_hardware_hacking_smoke_detector_{1}>`'}
smoke_detector_examples = {'en': '\n.. |smoke_detector_examples| replace:: {0}\n', 'de': '\n.. |smoke_detector_examples| replace:: {0}\n'}
smoke_detector_examples_toctree_line = {'en': '   Using {0} <SmokeDetector_{1}>', 'de': '   Mit {0} <SmokeDetector_{1}>'}
smoke_detector_examples_toctree = {'en': '.. toctree::\n   :hidden:\n\n{0}\n', 'de': '.. toctree::\n   :hidden:\n\n{0}\n'}
smoke_detector_example_download_line = {'en': '`{0} <https://github.com/Tinkerforge/hardware-hacking/tree/master/smoke_detector/{1}>`__', 'de': '`{0} <https://github.com/Tinkerforge/hardware-hacking/tree/master/smoke_detector/{1}>`__'}
smoke_detector_example_downloads = {'en': '\n.. |smoke_detector_examples_download| replace:: {0}\n', 'de': '\n.. |smoke_detector_examples_download| replace:: {0}\n'}
smoke_detector_intro = {'en': '\n>>>intro\nWe are also assuming that you have a smoke detector connected to an\n:ref:`Industrial Digital In 4 Bricklet <industrial_digital_in_4_bricklet>` as\ndescribed :ref:`here <starter_kit_hardware_hacking_smoke_detector_hardware_setup>`.\n<<<intro\n', 'de': '\n>>>intro\nWir setzen weiterhin voraus, dass ein passender Rauchmelder mit einem\n:ref:`Industrial Digital In 4 Bricklet <industrial_digital_in_4_bricklet>` verbunden\nwurde wie :ref:`hier <starter_kit_hardware_hacking_smoke_detector_hardware_setup>`\nbeschrieben.\n<<<intro\n'}
smoke_detector_goals = {'en': "\n>>>goals\nWe are setting the following goal for this project:\n\n* Read out the alarm status of a smoke detector\n* and react on its alarm signal.\n\nSince this project will likely run 24/7, we will also make sure\nthat the application is as robust towards external influences as possible.\nThe application should still work when\n\n* Bricklets are exchanged (i.e. we don't rely on UIDs),\n* Brick Daemon isn't running or is restarted,\n* WIFI Extension is out of range or\n* Brick is restarted (power loss or accidental USB removal).\n\nIn the following we will show step-by-step how this can be achieved.\n<<<goals\n", 'de': '\n>>>goals\nWir setzen uns folgendes Ziel für dieses Projekt:\n\n* Alarmstatus eines Rauchmelders auslesen\n* und auf dessen Alarmsignal reagieren.\n\nDa dieses Projekt wahrscheinlich 24/7 laufen wird, wollen wir sicherstellen,\ndass das Programm möglichst robust gegen externe Einflüsse ist. Das Programm\nsollte weiterhin funktionieren falls\n\n* Bricklets ausgetauscht werden (z.B. verwenden wir keine fixen UIDs),\n* Brick Daemon läuft nicht oder wird neu gestartet,\n* WIFI Extension ist außer Reichweite oder\n* Brick wurde neu gestartet (Stromausfall oder USB getrennt).\n\nIm Folgenden werden wir Schritt für Schritt zeigen wie diese Ziele erreicht\nwerden können.\n<<<goals\n'}
smoke_detector_steps = {'en': '\n.. |step1_start_off| replace::\n To start off, we need to define where our program should connect to:\n\n.. |step1_ip_address| replace::\n If the WIFI Extension is used or if the Brick Daemon is\n running on a different PC, you have to exchange "localhost" with the\n IP address or hostname of the WIFI Extension or PC.\n\n.. |step1_register_callbacks| replace::\n When the program is started, we need to register the |ref_CALLBACK_ENUMERATE|\n |callback| and the |ref_CALLBACK_CONNECTED| |callback| and trigger a first\n enumerate:\n\n.. |step1_enumerate_callback| replace::\n The enumerate callback is triggered if a Brick gets connected over USB or if\n the |ref_enumerate| function is called. This allows to discover the Bricks and\n Bricklets in a stack without knowing their types or UIDs beforehand.\n\n.. |step1_connected_callback| replace::\n The connected callback is triggered if the connection to the WIFI Extension or\n to the Brick Daemon got established. In this callback we need to trigger the\n enumerate again, if the reason is an auto reconnect:\n\n.. |step1_auto_reconnect_callback| replace::\n An auto reconnect means, that the connection to the WIFI Extension or to the\n Brick Daemon was lost and could subsequently be established again. In this\n case the Bricklets may have lost their configurations and we have to\n reconfigure them. Since the configuration is done during the\n enumeration process (see below), we have to trigger another enumeration.\n\n.. |step1_put_together| replace::\n Step 1 put together:\n\n.. |step2_intro| replace::\n During the enumeration we want to configure the Industrial Digital In 4 Bricklet.\n Doing this during the enumeration ensures that the Bricklet gets reconfigured\n if the Brick was disconnected or there was a power loss.\n\n.. |step2_enumerate| replace::\n The configurations should be performed on first startup\n (|ENUMERATION_TYPE_CONNECTED|) as well as whenever the enumeration is\n triggered externally by us (|ENUMERATION_TYPE_AVAILABLE|):\n\n.. |step2_config| replace::\n We configure the Industrial Digital In 4 Bricklet to call the |cb_interrupt|\n callback if a change of the voltage level on any input pin is detected. The\n debounce period is set to 10s (10000ms) to avoid being spammed with callbacks.\n Interrupt detection is enabled for all inputs (15 = 0b1111).\n\n.. |step2_put_together| replace::\n Step 2 put together:\n\n.. |step3_intro| replace::\n Now we need to react on the alarm signal of the smoke detector. But we want to\n react only if the LED is turned on, not if it is turn off. This is done by\n checking |value_mask| for being ``> 0``. In that case there is a voltage\n applied to at least one input, therefore, the LED is on.\n\n.. |step3_complete| replace::\n That\'s it. If we would copy these three steps together in one file and\n execute it, we would have a working program that reads the alarm status of a\n hacked smoke detector and reacts on its alarm signal!\n\n.. |step3_suggestions| replace::\n Currently the program just outputs a warning. There are several ways to extend\n this. For example, the program could send an email or a text message to notify\n someone about the alarm.\n\n.. |step3_robust1| replace::\n However, we do not meet all of our goals yet. The program is not yet\n robust enough. What happens if it can\'t connect on startup? What happens if\n the enumerate after an auto reconnect doesn\'t work?\n\n.. |step3_robust2| replace::\n What we need is error handling!\n\n.. |step4_intro1| replace::\n On startup, we need to try to connect until the connection works:\n\n.. |step4_intro2| replace::\n and we need to try enumerating until the message goes through:\n\n.. |step4_sleep_in_c| replace::\n There is no portable sleep function in C. On Windows ``windows.h`` declares\n a ``Sleep`` function that takes the duration in milliseconds. On POSIX\n systems such as Linux and macOS there is a ``sleep`` function declared\n in ``unistd.h`` that takes the duration in seconds.\n\n.. |step4_connect_afterwards| replace::\n With these changes it is now possible to first start the program and\n connect the Master Brick afterwards.\n\n.. |step4_initialization| replace::\n We also have to deal with errors during the initialization:\n\n.. |step4_logging1| replace::\n Additionally we added some logging. With the logging we can later find out\n what exactly caused a potential problem.\n\n.. |step4_logging2| replace::\n For example, if we connect to the Master Brick via Wi-Fi and we have\n regular auto reconnects, it likely means that the Wi-Fi connection is not\n very stable.\n\n.. |step5_intro| replace::\n That\'s it! We are already done with our hacked smoke detector and all of the\n goals should be met.\n\n.. |step5_put_together| replace::\n Now all of the above put together\n', 'de': '\n.. |step1_start_off| replace::\n Als Erstes legen wir fest wohin unser Programm sich verbinden soll:\n\n.. |step1_ip_address| replace::\n Falls eine WIFI Extension verwendet wird, oder der Brick Daemon auf einem\n anderen PC läuft, dann muss "localhost" durch die IP Adresse oder den Hostnamen\n der WIFI Extension oder des anderen PCs ersetzt werden.\n\n.. |step1_register_callbacks| replace::\n Nach dem Start des Programms müssen der |ref_CALLBACK_ENUMERATE| |callback|\n und der |ref_CALLBACK_CONNECTED| |callback| registriert und ein erstes\n Enumerate ausgelöst werden:\n\n.. |step1_enumerate_callback| replace::\n Der Enumerate Callback wird ausgelöst wenn ein Brick per USB angeschlossen wird\n oder wenn die |ref_enumerate| Funktion aufgerufen wird. Dies ermöglicht es die\n Bricks und Bricklets im Stapel zu erkennen ohne im Voraus ihre UIDs kennen zu\n müssen.\n\n.. |step1_connected_callback| replace::\n Der Connected Callback wird ausgelöst wenn die Verbindung zur WIFI Extension\n oder zum Brick Daemon hergestellt wurde. In diesem Callback muss wiederum ein\n Enumerate angestoßen werden, wenn es sich um ein Auto-Reconnect handelt:\n\n.. |step1_auto_reconnect_callback| replace::\n Ein Auto-Reconnect bedeutet, dass die Verbindung zur WIFI Extension oder zum\n Brick Daemon verloren gegangen ist und automatisch wiederhergestellt werden\n konnte. In diesem Fall kann es sein, dass die Bricklets ihre Konfiguration\n verloren haben und wir sie neu konfigurieren müssen. Da die Konfiguration\n beim Enumerate (siehe unten) durchgeführt wird, lösen wir einfach noch ein\n Enumerate aus.\n\n.. |step1_put_together| replace::\n Schritt 1 zusammengefügt:\n\n.. |step2_intro| replace::\n Während des Enumerierungsprozesses soll das Industrial Digital In 4 Bricklet\n konfiguriert werden. Dadurch ist sichergestellt, dass es neu konfiguriert wird\n nach einem Verbindungsabbruch oder einer Unterbrechung der Stromversorgung.\n\n.. |step2_enumerate| replace::\n Die Konfiguration soll beim ersten Start (|ENUMERATION_TYPE_CONNECTED|)\n durchgeführt werden und auch bei jedem extern ausgelösten Enumerate\n (|ENUMERATION_TYPE_AVAILABLE|):\n\n.. |step2_config| replace::\n Das Industrial Digital In 4 Bricklet wird so eingestellt, dass es die\n |cb_interrupt| Callback-Funktion aufruft wenn sich die Spannung an einem\n der Eingänge verändert. Die Entprellperiode wird auf 10s (10000ms) gestellt,\n um zu vermeiden zu viele Callback zu erhalten. Interrupt-Erkennung wird für\n alle Eingänge aktiviert (15 = 0b1111).\n\n.. |step2_put_together| replace::\n Schritt 2 zusammengefügt:\n\n.. |step3_intro| replace::\n Jetzt müssen wir noch auf das Alarmsignal des Rauchmelders reagieren. Es soll\n aber nur auf das Einschalten der LED reagiert werden, nicht auf das\n Ausschalten. Dazu wird |value_mask| auf ``> 0`` geprüft, in diesem Fall liegt\n an mindesten einem Eingang eine Spannung an, sprich die LED leuchtet.\n\n.. |step3_complete| replace::\n Das ist es. Wenn wir diese drei Schritte zusammen in eine Datei kopieren und\n ausführen, dann hätten wir jetzt eine funktionierendes Programm, das den\n Alarmstatus eines Rauchmelders ausließt und auf dessen Alarmsignal reagiert.\n\n.. |step3_suggestions| replace::\n In der jetzigen Form gibt das Programm nur eine Meldung aus. Dies kann auf\n verschiedene Weise verbessert werden. Zum Beispiel könnte das Programm jemanden\n per E-Mail oder SMS über den Alarm informieren.\n\n.. |step3_robust1| replace::\n Wie dem auch sei, wir haben noch nicht alle Ziele erreicht. Das Programm ist\n noch nicht robust genug. Was passiert wenn die Verbindung beim Start des\n Programms nicht hergestellt werden kann, oder wenn das Enumerate nach einem\n Auto-Reconnect nicht funktioniert?\n\n.. |step3_robust2| replace::\n Wir brauchen noch Fehlerbehandlung!\n\n.. |step4_intro1| replace::\n Beim Start des Programms versuchen wir solange die Verbindung herzustellen,\n bis es klappt:\n\n.. |step4_intro2| replace::\n und es wird solange versucht ein Enumerate zu starten bis auch dies geklappt\n hat:\n\n.. |step4_sleep_in_c| replace::\n Es gibt keine portable Sleep Funktion in C. Auf Windows deklariert `windows.h``\n eine ``Sleep`` Funktion die die Wartedauer in Millisekunden übergeben bekommt.\n Auf POSIX Systemen wie Linux und macOS gibt es eine ``sleep`` Funktion\n deklariert in ``unistd.h`` die die Wartedauer in Sekunden übergeben bekommt.\n\n.. |step4_connect_afterwards| replace::\n Mit diesen Änderungen kann das Programm schon gestartet werden bevor der\n Master Brick angeschlossen ist.\n\n.. |step4_initialization| replace::\n Es müssen auch noch mögliche Fehler während des Enumerierungsprozesses\n behandelt werden:\n\n.. |step4_logging1| replace::\n Zusätzlich wollen wir noch ein paar Logausgaben einfügen. Diese ermöglichen es\n später herauszufinden was ein mögliches Problem ausgelöst hat.\n\n.. |step4_logging2| replace::\n Zum Beispiel, wenn der Master Brick über WLAN angebunden ist und häufig\n Auto-Reconnects auftreten, dann ist wahrscheinlich die WLAN Verbindung nicht\n sehr stabil.\n\n.. |step5_intro| replace::\n Jetzt sind alle für gesteckten Ziele für unseren gehackten Rauchmelder erreicht.\n\n.. |step5_put_together| replace::\n Das gesamte Programm für den gehackten Rauchmelder\n'}
garage_control_intro = {'en': '\n>>>intro\nWe are also assuming that you have a remote control connected to\nan :ref:`Industrial Quad Relay Bricklet <industrial_quad_relay_bricklet>` as\ndescribed :ref:`here <starter_kit_hardware_hacking_garage_control_hardware_setup>`.\n<<<intro\n', 'de': '\n>>>intro\nWir setzen weiterhin voraus, dass die Fernbedienung mit einem\n:ref:`Industrial Quad Relay Bricklet <industrial_quad_relay_bricklet>` verbunden\nwurde wie :ref:`hier <starter_kit_hardware_hacking_garage_control_hardware_setup>`\nbeschrieben.\n<<<intro\n'}
garage_control_goals = {'en': '\n>>>goals\nIn this project we will create a simple |name| app that resembles the\nfunctionality of the actual remote control.\n<<<goals\n', 'de': '\n>>>goals\nIn diesem Projekt werden wir eine einfach |name| App entwickeln, die die\nFunktionalität der eigentlichen Fernbedienung nachbildet.\n<<<goals\n'}
garage_control_steps = {'en': "\n.. |step2_discover_by_uid| replace::\n We apply some changes to make it work in a GUI program and instead of using the\n |ref_CALLBACK_ENUMERATE| to discover the Industrial Quad Relay Bricklet its UID\n has to be specified. This approach allows to pick the correct Industrial Quad\n Relay Bricklet even if multiple are connected to the same host at once.\n\n.. |step2_async| replace::\n We don't want to call the |ref_connect| method directly, because it might take\n a moment and block the GUI during that period of time. Instead |connect| will\n be called from |async_helper|, so it will run in the background and the GUI\n stays responsive:\n\n.. |step2_finish| replace::\n Host, port and UID can now be configured and a click on the connect button\n establishes the connection.\n\n.. |step3_intro| replace::\n The connection is established and the Industrial Quad Relay Bricklet is found\n but there is no logic yet to trigger the switch on the remote control if the\n trigger button is clicked.\n\n.. |step3_monoflop| replace::\n The call to |set_monoflop| closes the first relay for 1.5s then opens it again.\n\n.. |step3_finish1| replace::\n That's it. If we would copy these three steps together in one project, we would\n have a working app that allows a smart phone to control a garage door opener\n using its hacked remote control!\n\n.. |step3_finish2| replace::\n We don't have a disconnect button yet and the trigger button can be clicked\n before the connection is established. We need some more GUI logic!\n\n.. |step4_intro| replace::\n There is no button to close the connection again after it got established. The\n connect button could do this. When the connection is established it should\n allow to disconnect it again:\n\n.. |step4_disabled_gui| replace::\n Finally, the user should not be able to change the content of the text fields\n during the time the connection gets established and the trigger button should\n not be clickable if there is no connection.\n\n.. |step4_robust1| replace::\n But the program is not yet robust enough. What happens if can't connect? What\n happens if there is no Industrial Quad Relay Bricklet with the given UID?\n\n.. |step4_robust2| replace::\n What we need is error handling!\n\n.. |step5_connect_result1| replace::\n SUCCESS: The connection got established and an Industrial Quad Relay Bricklet\n with the given UID was found.\n\n.. |step5_connect_result2| replace::\n NO_CONNECTION: The connection could not be established.\n\n.. |step5_connect_result3| replace::\n NO_DEVICE: The connection got established but there was no Industrial Quad\n Relay Bricklet with the given UID.\n\n.. |step5_check_identity| replace::\n The |ref_get_identity| is used to check that the device for the given\n UID really is an Industrial Quad Relay Bricklet. If this is not the case then\n the connection gets closed:\n\n.. |step5_success| replace::\n In case the connection attempt was successful the original logic stays the same:\n\n.. |step5_finish| replace::\n Now the app can connect to an configurable host and port and trigger a button\n on the remote control of your garage door opener using an Industrial Quad Relay\n Bricklet.\n\n.. |step6_finish| replace::\n Now the configuration and state is stored persistent across a restart of the app.\n\n.. |step7_intro| replace::\n That's it! We are done with the app for our hacked garage door opener remote\n control.\n\n.. |step7_together| replace::\n Now all of the above put together\n", 'de': '\n.. |step2_discover_by_uid| replace::\n Einige Änderungen sind notwendig damit es in einem GUI Programm funktioniert.\n Statt dem |ref_CALLBACK_ENUMERATE| zum Erkennen des Industrial Quad Relay\n Bricklets verwenden muss dessen UID angegeben werden. Dieser Ansatz erlaubt es\n gezielt ein Industrial Quad Relay Bricklet auszuwählen, selbst wenn mehrere am\n gleichen Host angeschlossen sind.\n\n.. |step2_async| replace::\n Die |ref_connect| Methode soll nicht direkt aufgerufen werden, da dies einen\n Moment dauern kann und in dieser Zeit die GUI nicht auf den Benutzer reagieren\n könnte. Daher wird |connect| aus |async_helper| aufgerufen werden, so\n dass es im Hintergrund ausgeführt und die GUI nicht blockiert wird\n\n.. |step2_finish| replace::\n Host, Port und UID können jetzt eingestellt werden und ein Klick auf den\n Connect Knopf stellt die Verbindung her.\n\n.. |step3_intro| replace::\n Die Verbindung ist hergestellt und das Industrial Quad Relay Bricklet wurde\n gefunden, aber es fehlt noch die Logik um einen Taster auf der Fernbedienung\n auszulösen wenn der Knopf geklickt wurde.\n\n.. |step3_monoflop| replace::\n Der Aufruf von |set_monoflop| schließt das erste Relais für 1,5s und öffnet\n es dann wieder.\n\n.. |step3_finish1| replace::\n Das ist es. Wenn wir diese drei Schritte zusammen in ein Projekt kopieren, dann\n hätten wir jetzt eine funktionierende App, die es ermöglicht vom Smartphone\n aus den Garagentoröffner mittels dessen gehackter Fernbedienung zu steuern.\n\n.. |step3_finish2| replace::\n Es fehlt noch ein Disconnect-Knopf und der Trigger-Knopf kann auch geklickt\n werden obwohl keine Verbindung besteht. Es fehlt also noch etwas mehr\n GUI-Logik!\n\n.. |step4_intro| replace::\n Es gibt noch keinen Knopf um die Verbindung wieder zu trennen nachdem sie\n aufgebaut wurde. Der Connect-Knopf könnte dies tun. Wenn die Verbindung\n aufgebaut ist sollte er bei einem Klick die Verbindung wieder trennen:\n\n.. |step4_disabled_gui| replace::\n Außerdem sollte der Benutzer nicht den Inhalt der Eingabefelder ändern können\n solange die Verbindung aufgebaut wird oder besteht und der Trigger-Knopf sollte\n nicht klickbar sein wenn keine Verbindung besteht.\n\n.. |step4_robust1| replace::\n Das Programm ist noch nicht robust genug. Was passiert wenn die Verbindung\n nicht hergestellt werden kann? Was passiert wenn kein Industrial Quad Relay\n Bricklet mit passender UID gefunden werden kann?\n\n.. |step4_robust2| replace::\n Wir brauchen noch Fehlerbehandlung!\n\n.. |step5_connect_result1| replace::\n SUCCESS: Die Verbindung wurde hergestellt und ein Industrial Quad Relay\n Bricklet mit passender UID wurde gefunden.\n\n.. |step5_connect_result2| replace::\n NO_CONNECTION: Die Verbindung konnte nicht hergestellt werden.\n\n.. |step5_connect_result3| replace::\n NO_DEVICE: Die Verbindung wurde hergestellt, aber es wurde kein Industrial Quad\n Relay Bricklet mit passender UID gefunden.\n\n.. |step5_check_identity| replace::\n Mit der |ref_get_identity| wird überprüft, ob die angegebene UID\n wirklich zu einem Industrial Quad Relay Bricklet gehört. Falls das nicht der\n Fall ist wird die Verbindung getrennt:\n\n.. |step5_success| replace::\n Im Falle, dass die Verbindung erfolgreich war bleibt die ursprüngliche Logik\n bestehen:\n\n.. |step5_finish| replace::\n Die App kann sich zum eingestellten Host und Port verbinden und einen Taster\n auf der Fernbedienung des Garagentoröffners mittels eines Industrial\n Quad Relay Bricklets betätigen.\n\n.. |step6_finish| replace::\n Jetzt wird die Konfiguration und der Zustand dauerhaft. auch über einen\n Neustart der App hinweg, gespeichert.\n\n.. |step7_intro| replace::\n Das ist es! Die App für die gehackte Fernbedienung des Garagentoröffners ist\n fertig.\n\n.. |step7_together| replace::\n Das Hauptprogramm in einem Stück\n'}
power_outlet_control_intro = {'en': '\n>>>intro\nWe are also assuming that you have a remote control connected to\nan :ref:`Industrial Quad Relay Bricklet <industrial_quad_relay_bricklet>` as\ndescribed :ref:`here <starter_kit_hardware_hacking_garage_control_hardware_setup>`.\n<<<intro\n', 'de': '\n>>>intro\nWir setzen weiterhin voraus, dass die Fernbedienung mit einem\n:ref:`Industrial Quad Relay Bricklet <industrial_quad_relay_bricklet>` verbunden\nwurde wie :ref:`hier <starter_kit_hardware_hacking_garage_control_hardware_setup>`\nbeschrieben.\n<<<intro\n'}
power_outlet_control_goals = {'en': '\n>>>goals\nIn this project we will create a simple |name| app that resembles the\nfunctionality of the actual remote control.\n<<<goals\n', 'de': '\n>>>goals\nIn diesem Projekt werden wir eine einfach |name| App entwickeln, die die\nFunktionalität der eigentlichen Fernbedienung nachbildet.\n<<<goals\n'}
power_outlet_control_steps = {'en': "\n.. |step2_discover_by_uid| replace::\n We apply some changes to make it work in a GUI program and instead of using the\n |ref_CALLBACK_ENUMERATE| to discover the Industrial Quad Relay Bricklet its UID\n has to be specified. This approach allows to pick the correct Industrial Quad\n Relay Bricklet even if multiple are connected to the same host at once.\n\n.. |step2_async| replace::\n We don't want to call the |ref_connect| method directly, because it might take\n a moment and block the GUI during that period of time. Instead |connect| will\n be called from |async_helper|, so it will run in the background and the GUI\n stays responsive:\n\n.. |step2_finish| replace::\n Host, port and UID can now be configured and a click on the connect button\n establishes the connection.\n\n.. |step3_intro| replace::\n The connection is established and the Industrial Quad Relay Bricklet is found\n but there is no logic yet to trigger a switch on the remote control if one of\n the four trigger buttons is clicked.\n\n.. |step3_monoflop| replace::\n The call to |set_monoflop| closes the selected relays for 0.5s then opens them\n again.\n\n.. |step3_finish1| replace::\n That's it. If we would copy these three steps together in one project, we would\n have a working app that allows a smart phone to control remote mains switches\n using their hacked remote control!\n\n.. |step3_finish2| replace::\n We don't have a disconnect button yet and the trigger buttons can be clicked\n before the connection is established. We need some more GUI logic!\n\n.. |step4_intro| replace::\n There is no button to close the connection again after it got established. The\n connect button could do this. When the connection is established it should\n allow to disconnect it again:\n\n.. |step4_disabled_gui| replace::\n Finally, the user should not be able to change the content of the text fields\n during the time the connection gets established and the trigger buttons should\n not be clickable if there is no connection.\n\n.. |step4_robust1| replace::\n But the program is not yet robust enough. What happens if it can't connect?\n What happens if there is no Industrial Quad Relay Bricklet with the given UID?\n\n.. |step4_robust2| replace::\n What we need is error handling!\n\n.. |step5_connect_result1| replace::\n SUCCESS: The connection got established and an Industrial Quad Relay Bricklet\n with the given UID was found.\n\n.. |step5_connect_result2| replace::\n NO_CONNECTION: The connection could not be established.\n\n.. |step5_connect_result3| replace::\n NO_DEVICE: The connection got established but there was no Industrial Quad\n Relay Bricklet with the given UID.\n\n.. |step5_check_identity| replace::\n The |ref_get_identity| is used to check that the device for the given\n UID really is an Industrial Quad Relay Bricklet. If this is not the case then\n the connection gets closed:\n\n.. |step5_success| replace::\n In case the connection attempt was successful the original logic stays the same:\n\n.. |step5_finish| replace::\n Now the app can connect to an configurable host and port and trigger a button\n on the remote control of your garage door opener using an Industrial Quad Relay\n Bricklet.\n\n.. |step6_finish| replace::\n Now the configuration and state is stored persistent across a restart of the app.\n\n.. |step7_intro| replace::\n That's it! We are done with the app for our hacked garage door opener remote\n control.\n\n.. |step7_together| replace::\n Now all of the above put together\n", 'de': '\n.. |step2_discover_by_uid| replace::\n Einige Änderungen sind notwendig damit es in einem GUI Programm funktioniert.\n Statt dem |ref_CALLBACK_ENUMERATE| zum Erkennen des Industrial Quad Relay\n Bricklets verwenden muss dessen UID angegeben werden. Dieser Ansatz erlaubt es\n gezielt ein Industrial Quad Relay Bricklet auszuwählen, selbst wenn mehrere am\n gleichen Host angeschlossen sind.\n\n.. |step2_async| replace::\n Die |ref_connect| Methode soll nicht direkt aufgerufen werden, da dies einen\n Moment dauern kann und in dieser Zeit die GUI nicht auf den Benutzer reagieren\n könnte. Daher wird |connect| aus |async_helper| aufgerufen werden, so\n dass es im Hintergrund ausgeführt und die GUI nicht blockiert wird:\n\n.. |step2_finish| replace::\n Host, Port und UID können jetzt eingestellt werden und ein Klick auf den\n Connect Knopf stellt die Verbindung her.\n\n.. |step3_intro| replace::\n Die Verbindung ist hergestellt und das Industrial Quad Relay Bricklet wurde\n gefunden, aber es fehlt noch die Logik um einen der Taster auf der Fernbedienung\n auszulösen wenn einer der Knöpfe geklickt wurde.\n\n.. |step3_monoflop| replace::\n Der Aufruf von |set_monoflop| schließt die ausgewählten Relais für 0,5s und\n öffnet es dann wieder.\n\n.. |step3_finish1| replace::\n Das ist es. Wenn wir diese drei Schritte zusammen in ein Projekt kopieren, dann\n hätten wir jetzt eine funktionierende App, die es ermöglicht vom Smartphone\n aus Funksteckdosen mittels deren gehackter Fernbedienung zu steuern.\n\n.. |step3_finish2| replace::\n Es fehlt noch ein Disconnect-Knopf und die Trigger-Knöpfe kann auch geklickt\n werden obwohl keine Verbindung besteht. Es fehlt also noch etwas mehr\n GUI-Logik!\n\n.. |step4_intro| replace::\n Es gibt noch keinen Knopf um die Verbindung wieder zu trennen nachdem sie\n aufgebaut wurde. Der Connect-Knopf könnte dies tun. Wenn die Verbindung\n aufgebaut ist sollte er bei einem Klick die Verbindung wieder trennen:\n\n.. |step4_disabled_gui| replace::\n Außerdem sollte der Benutzer nicht den Inhalt der Eingabefelder ändern können\n solange die Verbindung aufgebaut wird oder besteht und die Trigger-Knöpfe\n sollten nicht klickbar sein wenn keine Verbindung besteht.\n\n.. |step4_robust1| replace::\n Das Programm ist noch nicht robust genug. Was passiert wenn die Verbindung\n nicht hergestellt werden kann? Was passiert wenn kein Industrial Quad Relay\n Bricklet mit passender UID gefunden werden kann?\n\n.. |step4_robust2| replace::\n Wir brauchen noch Fehlerbehandlung!\n\n.. |step5_connect_result1| replace::\n SUCCESS: Die Verbindung wurde hergestellt und ein Industrial Quad Relay\n Bricklet mit passender UID wurde gefunden.\n\n.. |step5_connect_result2| replace::\n NO_CONNECTION: Die Verbindung konnte nicht hergestellt werden.\n\n.. |step5_connect_result3| replace::\n NO_DEVICE: Die Verbindung wurde hergestellt, aber es wurde kein Industrial Quad\n Relay Bricklet mit passender UID gefunden.\n\n.. |step5_check_identity| replace::\n Mit der |ref_get_identity| wird überprüft, ob die angegebene UID\n wirklich zu einem Industrial Quad Relay Bricklet gehört. Falls das nicht der\n Fall ist wird die Verbindung getrennt:\n\n.. |step5_success| replace::\n Im Falle, dass die Verbindung erfolgreich war bleibt die ursprüngliche Logik\n bestehen:\n\n.. |step5_finish| replace::\n Die App kann sich zum eingestellten Host und Port verbinden und einen Taster\n auf der Fernbedienung des Garagentoröffners betätigen mittels eines Industrial\n Quad Relay Bricklets.\n\n.. |step6_finish| replace::\n Jetzt wird die Konfiguration und der Zustand dauerhaft. auch über einen\n Neustart der App hinweg, gespeichert.\n\n.. |step7_intro| replace::\n Das ist es! Die App für die gehackte Fernbedienung des Garagentoröffners ist\n fertig.\n\n.. |step7_together| replace::\n Das Hauptprogramm in einem Stück\n'}

def make_substitutions():
    if False:
        for i in range(10):
            print('nop')
    substitutions = ''
    formated_binding_names = []
    for bindings_info in bindings_infos:
        if bindings_info.is_programming_language and bindings_info.is_released:
            formated_binding_names.append(binding_name[lang].format(bindings_info.display_name[lang], bindings_info.url_part))
    substitutions += binding_names[lang].format(', '.join(formated_binding_names)) + '\n'
    example_lines = []
    for bindings_info in bindings_infos:
        if bindings_info.url_part in examples and bindings_info.is_programming_language and bindings_info.is_released:
            example_lines.append(smoke_detector_example_line[lang].format(examples[bindings_info.url_part], bindings_info.url_part))
    substitutions += smoke_detector_examples[lang].format(', '.join(example_lines))
    example_download_lines = []
    for bindings_info in bindings_infos:
        if bindings_info.url_part in examples and bindings_info.is_programming_language and bindings_info.is_released:
            example_download_lines.append(smoke_detector_example_download_line[lang].format(examples[bindings_info.url_part], bindings_info.url_part))
    substitutions += smoke_detector_example_downloads[lang].format(', '.join(example_download_lines))
    example_lines = []
    for bindings_info in bindings_infos:
        if bindings_info.url_part in examples:
            example_lines.append(remote_switch_example_line[lang].format(examples[bindings_info.url_part], bindings_info.url_part))
    substitutions += remote_switch_examples[lang].format(', '.join(example_lines))
    example_download_lines = []
    for bindings_info in bindings_infos:
        if bindings_info.url_part in examples:
            example_download_lines.append(remote_switch_example_download_line[lang].format(examples[bindings_info.url_part], bindings_info.url_part))
    substitutions += remote_switch_example_downloads[lang].format(', '.join(example_download_lines))
    return substitutions

def make_common_substitutions(bindings_info):
    if False:
        i = 10
        return i + 15
    substitutions = ''
    if bindings_info.url_part in examples:
        substitutions += common_intro[lang].format(examples[bindings_info.url_part], bindings_info.url_part, bindings_info.tutorial[lang])
    return substitutions

def make_android_common_substitutions():
    if False:
        while True:
            i = 10
    substitutions = ''
    substitutions += android_common_intro[lang]
    return substitutions

def make_windows_phone_common_substitutions():
    if False:
        for i in range(10):
            print('nop')
    substitutions = ''
    substitutions += windows_phone_common_intro[lang]
    return substitutions

def make_ios_common_substitutions():
    if False:
        return 10
    substitutions = ''
    substitutions += ios_common_intro[lang]
    return substitutions

def make_smoke_detector_substitutions():
    if False:
        return 10
    substitutions = ''
    substitutions += smoke_detector_intro[lang] + '\n'
    substitutions += smoke_detector_goals[lang] + '\n'
    substitutions += '>>>substitutions\n'
    substitutions += smoke_detector_steps[lang] + '\n'
    substitutions += '<<<substitutions\n'
    return substitutions

def make_smoke_detector_toctree():
    if False:
        while True:
            i = 10
    toctree_lines = []
    for bindings_info in bindings_infos:
        if bindings_info.url_part in examples:
            toctree_lines.append(smoke_detector_examples_toctree_line[lang].format(bindings_info.display_name[lang], bindings_info.software_doc_suffix))
    return smoke_detector_examples_toctree[lang].format('\n'.join(toctree_lines))

def make_remote_switch_substitutions():
    if False:
        while True:
            i = 10
    substitutions = ''
    substitutions += remote_switch_intro[lang] + '\n'
    substitutions += remote_switch_goals[lang] + '\n'
    return substitutions

def make_remote_switch_toctree():
    if False:
        for i in range(10):
            print('nop')
    toctree_lines = []
    for bindings_info in bindings_infos:
        if bindings_info.url_part in examples:
            toctree_lines.append(remote_switch_examples_toctree_line[lang].format(bindings_info.display_name[lang], bindings_info.software_doc_suffix))
    return remote_switch_examples_toctree[lang].format('\n'.join(toctree_lines))

def make_garage_control_substitutions():
    if False:
        return 10
    substitutions = ''
    substitutions += garage_control_intro[lang] + '\n'
    substitutions += garage_control_goals[lang] + '\n'
    substitutions += '>>>substitutions\n'
    substitutions += garage_control_steps[lang] + '\n'
    substitutions += '<<<substitutions\n'
    return substitutions

def make_power_outlet_control_substitutions():
    if False:
        print('Hello World!')
    substitutions = ''
    substitutions += power_outlet_control_intro[lang] + '\n'
    substitutions += power_outlet_control_goals[lang] + '\n'
    substitutions += '>>>substitutions\n'
    substitutions += power_outlet_control_steps[lang] + '\n'
    substitutions += '<<<substitutions\n'
    return substitutions

def write_if_changed(path, content):
    if False:
        return 10
    if os.path.exists(path):
        with open(path, 'r') as f:
            existing = f.read()
        if existing == content:
            return
    with open(path, 'w') as f:
        f.write(content)

def generate(path):
    if False:
        for i in range(10):
            print('nop')
    global lang
    if path.endswith('/en'):
        lang = 'en'
    elif path.endswith('/de'):
        lang = 'de'
    else:
        debug('Wrong working directory')
        sys.exit(1)
    generate_tables.lang = lang
    debug('Generating HardwareHacking.substitutions')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'HardwareHacking.substitutions'), make_substitutions())
    for bindings_info in bindings_infos:
        if bindings_info.url_part in examples:
            debug('Generating {0}Common.substitutions (HardwareHacking)'.format(bindings_info.software_doc_suffix))
            write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', bindings_info.software_doc_suffix + 'Common.substitutions'), make_common_substitutions(bindings_info))
    debug('Generating AndroidCommon.substitutions (HardwareHacking)')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'AndroidCommon.substitutions'), make_android_common_substitutions())
    debug('Generating WindowsPhoneCommon.substitutions (HardwareHacking)')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'WindowsPhoneCommon.substitutions'), make_windows_phone_common_substitutions())
    debug('Generating iOSCommon.substitutions (HardwareHacking)')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'iOSCommon.substitutions'), make_ios_common_substitutions())
    debug('Generating SmokeDetector.substitutions (HardwareHacking)')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'SmokeDetector.substitutions'), make_smoke_detector_substitutions())
    debug('Generating SmokeDetector.toctree (HardwareHacking)')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'SmokeDetector.toctree'), make_smoke_detector_toctree())
    debug('Generating RemoteSwitch.substitutions (HardwareHacking)')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'RemoteSwitch.substitutions'), make_remote_switch_substitutions())
    debug('Generating RemoteSwitch.toctree (HardwareHacking)')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'RemoteSwitch.toctree'), make_remote_switch_toctree())
    debug('Generating GarageControl.substitutions (HardwareHacking)')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'GarageControl.substitutions'), make_garage_control_substitutions())
    debug('Generating PowerOutletControl.substitutions (HardwareHacking)')
    write_if_changed(os.path.join(path, 'source', 'Kits', 'HardwareHacking', 'PowerOutletControl.substitutions'), make_power_outlet_control_substitutions())
if __name__ == '__main__':
    generate(os.getcwd())