[
    {
        "func_name": "__init__",
        "original": "def __init__(self, G, multigraph, demand='demand', capacity='capacity', weight='weight'):\n    self.node_list = list(G)\n    self.node_indices = {u: i for (i, u) in enumerate(self.node_list)}\n    self.node_demands = [G.nodes[u].get(demand, 0) for u in self.node_list]\n    self.edge_sources = []\n    self.edge_targets = []\n    if multigraph:\n        self.edge_keys = []\n    self.edge_indices = {}\n    self.edge_capacities = []\n    self.edge_weights = []\n    if not multigraph:\n        edges = G.edges(data=True)\n    else:\n        edges = G.edges(data=True, keys=True)\n    inf = float('inf')\n    edges = (e for e in edges if e[0] != e[1] and e[-1].get(capacity, inf) != 0)\n    for (i, e) in enumerate(edges):\n        self.edge_sources.append(self.node_indices[e[0]])\n        self.edge_targets.append(self.node_indices[e[1]])\n        if multigraph:\n            self.edge_keys.append(e[2])\n        self.edge_indices[e[:-1]] = i\n        self.edge_capacities.append(e[-1].get(capacity, inf))\n        self.edge_weights.append(e[-1].get(weight, 0))\n    self.edge_count = None\n    self.edge_flow = None\n    self.node_potentials = None\n    self.parent = None\n    self.parent_edge = None\n    self.subtree_size = None\n    self.next_node_dft = None\n    self.prev_node_dft = None\n    self.last_descendent_dft = None\n    self._spanning_tree_initialized = False",
        "mutated": [
            "def __init__(self, G, multigraph, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n    self.node_list = list(G)\n    self.node_indices = {u: i for (i, u) in enumerate(self.node_list)}\n    self.node_demands = [G.nodes[u].get(demand, 0) for u in self.node_list]\n    self.edge_sources = []\n    self.edge_targets = []\n    if multigraph:\n        self.edge_keys = []\n    self.edge_indices = {}\n    self.edge_capacities = []\n    self.edge_weights = []\n    if not multigraph:\n        edges = G.edges(data=True)\n    else:\n        edges = G.edges(data=True, keys=True)\n    inf = float('inf')\n    edges = (e for e in edges if e[0] != e[1] and e[-1].get(capacity, inf) != 0)\n    for (i, e) in enumerate(edges):\n        self.edge_sources.append(self.node_indices[e[0]])\n        self.edge_targets.append(self.node_indices[e[1]])\n        if multigraph:\n            self.edge_keys.append(e[2])\n        self.edge_indices[e[:-1]] = i\n        self.edge_capacities.append(e[-1].get(capacity, inf))\n        self.edge_weights.append(e[-1].get(weight, 0))\n    self.edge_count = None\n    self.edge_flow = None\n    self.node_potentials = None\n    self.parent = None\n    self.parent_edge = None\n    self.subtree_size = None\n    self.next_node_dft = None\n    self.prev_node_dft = None\n    self.last_descendent_dft = None\n    self._spanning_tree_initialized = False",
            "def __init__(self, G, multigraph, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.node_list = list(G)\n    self.node_indices = {u: i for (i, u) in enumerate(self.node_list)}\n    self.node_demands = [G.nodes[u].get(demand, 0) for u in self.node_list]\n    self.edge_sources = []\n    self.edge_targets = []\n    if multigraph:\n        self.edge_keys = []\n    self.edge_indices = {}\n    self.edge_capacities = []\n    self.edge_weights = []\n    if not multigraph:\n        edges = G.edges(data=True)\n    else:\n        edges = G.edges(data=True, keys=True)\n    inf = float('inf')\n    edges = (e for e in edges if e[0] != e[1] and e[-1].get(capacity, inf) != 0)\n    for (i, e) in enumerate(edges):\n        self.edge_sources.append(self.node_indices[e[0]])\n        self.edge_targets.append(self.node_indices[e[1]])\n        if multigraph:\n            self.edge_keys.append(e[2])\n        self.edge_indices[e[:-1]] = i\n        self.edge_capacities.append(e[-1].get(capacity, inf))\n        self.edge_weights.append(e[-1].get(weight, 0))\n    self.edge_count = None\n    self.edge_flow = None\n    self.node_potentials = None\n    self.parent = None\n    self.parent_edge = None\n    self.subtree_size = None\n    self.next_node_dft = None\n    self.prev_node_dft = None\n    self.last_descendent_dft = None\n    self._spanning_tree_initialized = False",
            "def __init__(self, G, multigraph, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.node_list = list(G)\n    self.node_indices = {u: i for (i, u) in enumerate(self.node_list)}\n    self.node_demands = [G.nodes[u].get(demand, 0) for u in self.node_list]\n    self.edge_sources = []\n    self.edge_targets = []\n    if multigraph:\n        self.edge_keys = []\n    self.edge_indices = {}\n    self.edge_capacities = []\n    self.edge_weights = []\n    if not multigraph:\n        edges = G.edges(data=True)\n    else:\n        edges = G.edges(data=True, keys=True)\n    inf = float('inf')\n    edges = (e for e in edges if e[0] != e[1] and e[-1].get(capacity, inf) != 0)\n    for (i, e) in enumerate(edges):\n        self.edge_sources.append(self.node_indices[e[0]])\n        self.edge_targets.append(self.node_indices[e[1]])\n        if multigraph:\n            self.edge_keys.append(e[2])\n        self.edge_indices[e[:-1]] = i\n        self.edge_capacities.append(e[-1].get(capacity, inf))\n        self.edge_weights.append(e[-1].get(weight, 0))\n    self.edge_count = None\n    self.edge_flow = None\n    self.node_potentials = None\n    self.parent = None\n    self.parent_edge = None\n    self.subtree_size = None\n    self.next_node_dft = None\n    self.prev_node_dft = None\n    self.last_descendent_dft = None\n    self._spanning_tree_initialized = False",
            "def __init__(self, G, multigraph, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.node_list = list(G)\n    self.node_indices = {u: i for (i, u) in enumerate(self.node_list)}\n    self.node_demands = [G.nodes[u].get(demand, 0) for u in self.node_list]\n    self.edge_sources = []\n    self.edge_targets = []\n    if multigraph:\n        self.edge_keys = []\n    self.edge_indices = {}\n    self.edge_capacities = []\n    self.edge_weights = []\n    if not multigraph:\n        edges = G.edges(data=True)\n    else:\n        edges = G.edges(data=True, keys=True)\n    inf = float('inf')\n    edges = (e for e in edges if e[0] != e[1] and e[-1].get(capacity, inf) != 0)\n    for (i, e) in enumerate(edges):\n        self.edge_sources.append(self.node_indices[e[0]])\n        self.edge_targets.append(self.node_indices[e[1]])\n        if multigraph:\n            self.edge_keys.append(e[2])\n        self.edge_indices[e[:-1]] = i\n        self.edge_capacities.append(e[-1].get(capacity, inf))\n        self.edge_weights.append(e[-1].get(weight, 0))\n    self.edge_count = None\n    self.edge_flow = None\n    self.node_potentials = None\n    self.parent = None\n    self.parent_edge = None\n    self.subtree_size = None\n    self.next_node_dft = None\n    self.prev_node_dft = None\n    self.last_descendent_dft = None\n    self._spanning_tree_initialized = False",
            "def __init__(self, G, multigraph, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.node_list = list(G)\n    self.node_indices = {u: i for (i, u) in enumerate(self.node_list)}\n    self.node_demands = [G.nodes[u].get(demand, 0) for u in self.node_list]\n    self.edge_sources = []\n    self.edge_targets = []\n    if multigraph:\n        self.edge_keys = []\n    self.edge_indices = {}\n    self.edge_capacities = []\n    self.edge_weights = []\n    if not multigraph:\n        edges = G.edges(data=True)\n    else:\n        edges = G.edges(data=True, keys=True)\n    inf = float('inf')\n    edges = (e for e in edges if e[0] != e[1] and e[-1].get(capacity, inf) != 0)\n    for (i, e) in enumerate(edges):\n        self.edge_sources.append(self.node_indices[e[0]])\n        self.edge_targets.append(self.node_indices[e[1]])\n        if multigraph:\n            self.edge_keys.append(e[2])\n        self.edge_indices[e[:-1]] = i\n        self.edge_capacities.append(e[-1].get(capacity, inf))\n        self.edge_weights.append(e[-1].get(weight, 0))\n    self.edge_count = None\n    self.edge_flow = None\n    self.node_potentials = None\n    self.parent = None\n    self.parent_edge = None\n    self.subtree_size = None\n    self.next_node_dft = None\n    self.prev_node_dft = None\n    self.last_descendent_dft = None\n    self._spanning_tree_initialized = False"
        ]
    },
    {
        "func_name": "initialize_spanning_tree",
        "original": "def initialize_spanning_tree(self, n, faux_inf):\n    self.edge_count = len(self.edge_indices)\n    self.edge_flow = list(chain(repeat(0, self.edge_count), (abs(d) for d in self.node_demands)))\n    self.node_potentials = [faux_inf if d <= 0 else -faux_inf for d in self.node_demands]\n    self.parent = list(chain(repeat(-1, n), [None]))\n    self.parent_edge = list(range(self.edge_count, self.edge_count + n))\n    self.subtree_size = list(chain(repeat(1, n), [n + 1]))\n    self.next_node_dft = list(chain(range(1, n), [-1, 0]))\n    self.prev_node_dft = list(range(-1, n))\n    self.last_descendent_dft = list(chain(range(n), [n - 1]))\n    self._spanning_tree_initialized = True",
        "mutated": [
            "def initialize_spanning_tree(self, n, faux_inf):\n    if False:\n        i = 10\n    self.edge_count = len(self.edge_indices)\n    self.edge_flow = list(chain(repeat(0, self.edge_count), (abs(d) for d in self.node_demands)))\n    self.node_potentials = [faux_inf if d <= 0 else -faux_inf for d in self.node_demands]\n    self.parent = list(chain(repeat(-1, n), [None]))\n    self.parent_edge = list(range(self.edge_count, self.edge_count + n))\n    self.subtree_size = list(chain(repeat(1, n), [n + 1]))\n    self.next_node_dft = list(chain(range(1, n), [-1, 0]))\n    self.prev_node_dft = list(range(-1, n))\n    self.last_descendent_dft = list(chain(range(n), [n - 1]))\n    self._spanning_tree_initialized = True",
            "def initialize_spanning_tree(self, n, faux_inf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.edge_count = len(self.edge_indices)\n    self.edge_flow = list(chain(repeat(0, self.edge_count), (abs(d) for d in self.node_demands)))\n    self.node_potentials = [faux_inf if d <= 0 else -faux_inf for d in self.node_demands]\n    self.parent = list(chain(repeat(-1, n), [None]))\n    self.parent_edge = list(range(self.edge_count, self.edge_count + n))\n    self.subtree_size = list(chain(repeat(1, n), [n + 1]))\n    self.next_node_dft = list(chain(range(1, n), [-1, 0]))\n    self.prev_node_dft = list(range(-1, n))\n    self.last_descendent_dft = list(chain(range(n), [n - 1]))\n    self._spanning_tree_initialized = True",
            "def initialize_spanning_tree(self, n, faux_inf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.edge_count = len(self.edge_indices)\n    self.edge_flow = list(chain(repeat(0, self.edge_count), (abs(d) for d in self.node_demands)))\n    self.node_potentials = [faux_inf if d <= 0 else -faux_inf for d in self.node_demands]\n    self.parent = list(chain(repeat(-1, n), [None]))\n    self.parent_edge = list(range(self.edge_count, self.edge_count + n))\n    self.subtree_size = list(chain(repeat(1, n), [n + 1]))\n    self.next_node_dft = list(chain(range(1, n), [-1, 0]))\n    self.prev_node_dft = list(range(-1, n))\n    self.last_descendent_dft = list(chain(range(n), [n - 1]))\n    self._spanning_tree_initialized = True",
            "def initialize_spanning_tree(self, n, faux_inf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.edge_count = len(self.edge_indices)\n    self.edge_flow = list(chain(repeat(0, self.edge_count), (abs(d) for d in self.node_demands)))\n    self.node_potentials = [faux_inf if d <= 0 else -faux_inf for d in self.node_demands]\n    self.parent = list(chain(repeat(-1, n), [None]))\n    self.parent_edge = list(range(self.edge_count, self.edge_count + n))\n    self.subtree_size = list(chain(repeat(1, n), [n + 1]))\n    self.next_node_dft = list(chain(range(1, n), [-1, 0]))\n    self.prev_node_dft = list(range(-1, n))\n    self.last_descendent_dft = list(chain(range(n), [n - 1]))\n    self._spanning_tree_initialized = True",
            "def initialize_spanning_tree(self, n, faux_inf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.edge_count = len(self.edge_indices)\n    self.edge_flow = list(chain(repeat(0, self.edge_count), (abs(d) for d in self.node_demands)))\n    self.node_potentials = [faux_inf if d <= 0 else -faux_inf for d in self.node_demands]\n    self.parent = list(chain(repeat(-1, n), [None]))\n    self.parent_edge = list(range(self.edge_count, self.edge_count + n))\n    self.subtree_size = list(chain(repeat(1, n), [n + 1]))\n    self.next_node_dft = list(chain(range(1, n), [-1, 0]))\n    self.prev_node_dft = list(range(-1, n))\n    self.last_descendent_dft = list(chain(range(n), [n - 1]))\n    self._spanning_tree_initialized = True"
        ]
    },
    {
        "func_name": "find_apex",
        "original": "def find_apex(self, p, q):\n    \"\"\"\n        Find the lowest common ancestor of nodes p and q in the spanning tree.\n        \"\"\"\n    size_p = self.subtree_size[p]\n    size_q = self.subtree_size[q]\n    while True:\n        while size_p < size_q:\n            p = self.parent[p]\n            size_p = self.subtree_size[p]\n        while size_p > size_q:\n            q = self.parent[q]\n            size_q = self.subtree_size[q]\n        if size_p == size_q:\n            if p != q:\n                p = self.parent[p]\n                size_p = self.subtree_size[p]\n                q = self.parent[q]\n                size_q = self.subtree_size[q]\n            else:\n                return p",
        "mutated": [
            "def find_apex(self, p, q):\n    if False:\n        i = 10\n    '\\n        Find the lowest common ancestor of nodes p and q in the spanning tree.\\n        '\n    size_p = self.subtree_size[p]\n    size_q = self.subtree_size[q]\n    while True:\n        while size_p < size_q:\n            p = self.parent[p]\n            size_p = self.subtree_size[p]\n        while size_p > size_q:\n            q = self.parent[q]\n            size_q = self.subtree_size[q]\n        if size_p == size_q:\n            if p != q:\n                p = self.parent[p]\n                size_p = self.subtree_size[p]\n                q = self.parent[q]\n                size_q = self.subtree_size[q]\n            else:\n                return p",
            "def find_apex(self, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Find the lowest common ancestor of nodes p and q in the spanning tree.\\n        '\n    size_p = self.subtree_size[p]\n    size_q = self.subtree_size[q]\n    while True:\n        while size_p < size_q:\n            p = self.parent[p]\n            size_p = self.subtree_size[p]\n        while size_p > size_q:\n            q = self.parent[q]\n            size_q = self.subtree_size[q]\n        if size_p == size_q:\n            if p != q:\n                p = self.parent[p]\n                size_p = self.subtree_size[p]\n                q = self.parent[q]\n                size_q = self.subtree_size[q]\n            else:\n                return p",
            "def find_apex(self, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Find the lowest common ancestor of nodes p and q in the spanning tree.\\n        '\n    size_p = self.subtree_size[p]\n    size_q = self.subtree_size[q]\n    while True:\n        while size_p < size_q:\n            p = self.parent[p]\n            size_p = self.subtree_size[p]\n        while size_p > size_q:\n            q = self.parent[q]\n            size_q = self.subtree_size[q]\n        if size_p == size_q:\n            if p != q:\n                p = self.parent[p]\n                size_p = self.subtree_size[p]\n                q = self.parent[q]\n                size_q = self.subtree_size[q]\n            else:\n                return p",
            "def find_apex(self, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Find the lowest common ancestor of nodes p and q in the spanning tree.\\n        '\n    size_p = self.subtree_size[p]\n    size_q = self.subtree_size[q]\n    while True:\n        while size_p < size_q:\n            p = self.parent[p]\n            size_p = self.subtree_size[p]\n        while size_p > size_q:\n            q = self.parent[q]\n            size_q = self.subtree_size[q]\n        if size_p == size_q:\n            if p != q:\n                p = self.parent[p]\n                size_p = self.subtree_size[p]\n                q = self.parent[q]\n                size_q = self.subtree_size[q]\n            else:\n                return p",
            "def find_apex(self, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Find the lowest common ancestor of nodes p and q in the spanning tree.\\n        '\n    size_p = self.subtree_size[p]\n    size_q = self.subtree_size[q]\n    while True:\n        while size_p < size_q:\n            p = self.parent[p]\n            size_p = self.subtree_size[p]\n        while size_p > size_q:\n            q = self.parent[q]\n            size_q = self.subtree_size[q]\n        if size_p == size_q:\n            if p != q:\n                p = self.parent[p]\n                size_p = self.subtree_size[p]\n                q = self.parent[q]\n                size_q = self.subtree_size[q]\n            else:\n                return p"
        ]
    },
    {
        "func_name": "trace_path",
        "original": "def trace_path(self, p, w):\n    \"\"\"\n        Returns the nodes and edges on the path from node p to its ancestor w.\n        \"\"\"\n    Wn = [p]\n    We = []\n    while p != w:\n        We.append(self.parent_edge[p])\n        p = self.parent[p]\n        Wn.append(p)\n    return (Wn, We)",
        "mutated": [
            "def trace_path(self, p, w):\n    if False:\n        i = 10\n    '\\n        Returns the nodes and edges on the path from node p to its ancestor w.\\n        '\n    Wn = [p]\n    We = []\n    while p != w:\n        We.append(self.parent_edge[p])\n        p = self.parent[p]\n        Wn.append(p)\n    return (Wn, We)",
            "def trace_path(self, p, w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns the nodes and edges on the path from node p to its ancestor w.\\n        '\n    Wn = [p]\n    We = []\n    while p != w:\n        We.append(self.parent_edge[p])\n        p = self.parent[p]\n        Wn.append(p)\n    return (Wn, We)",
            "def trace_path(self, p, w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns the nodes and edges on the path from node p to its ancestor w.\\n        '\n    Wn = [p]\n    We = []\n    while p != w:\n        We.append(self.parent_edge[p])\n        p = self.parent[p]\n        Wn.append(p)\n    return (Wn, We)",
            "def trace_path(self, p, w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns the nodes and edges on the path from node p to its ancestor w.\\n        '\n    Wn = [p]\n    We = []\n    while p != w:\n        We.append(self.parent_edge[p])\n        p = self.parent[p]\n        Wn.append(p)\n    return (Wn, We)",
            "def trace_path(self, p, w):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns the nodes and edges on the path from node p to its ancestor w.\\n        '\n    Wn = [p]\n    We = []\n    while p != w:\n        We.append(self.parent_edge[p])\n        p = self.parent[p]\n        Wn.append(p)\n    return (Wn, We)"
        ]
    },
    {
        "func_name": "find_cycle",
        "original": "def find_cycle(self, i, p, q):\n    \"\"\"\n        Returns the nodes and edges on the cycle containing edge i == (p, q)\n        when the latter is added to the spanning tree.\n\n        The cycle is oriented in the direction from p to q.\n        \"\"\"\n    w = self.find_apex(p, q)\n    (Wn, We) = self.trace_path(p, w)\n    Wn.reverse()\n    We.reverse()\n    if We != [i]:\n        We.append(i)\n    (WnR, WeR) = self.trace_path(q, w)\n    del WnR[-1]\n    Wn += WnR\n    We += WeR\n    return (Wn, We)",
        "mutated": [
            "def find_cycle(self, i, p, q):\n    if False:\n        i = 10\n    '\\n        Returns the nodes and edges on the cycle containing edge i == (p, q)\\n        when the latter is added to the spanning tree.\\n\\n        The cycle is oriented in the direction from p to q.\\n        '\n    w = self.find_apex(p, q)\n    (Wn, We) = self.trace_path(p, w)\n    Wn.reverse()\n    We.reverse()\n    if We != [i]:\n        We.append(i)\n    (WnR, WeR) = self.trace_path(q, w)\n    del WnR[-1]\n    Wn += WnR\n    We += WeR\n    return (Wn, We)",
            "def find_cycle(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns the nodes and edges on the cycle containing edge i == (p, q)\\n        when the latter is added to the spanning tree.\\n\\n        The cycle is oriented in the direction from p to q.\\n        '\n    w = self.find_apex(p, q)\n    (Wn, We) = self.trace_path(p, w)\n    Wn.reverse()\n    We.reverse()\n    if We != [i]:\n        We.append(i)\n    (WnR, WeR) = self.trace_path(q, w)\n    del WnR[-1]\n    Wn += WnR\n    We += WeR\n    return (Wn, We)",
            "def find_cycle(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns the nodes and edges on the cycle containing edge i == (p, q)\\n        when the latter is added to the spanning tree.\\n\\n        The cycle is oriented in the direction from p to q.\\n        '\n    w = self.find_apex(p, q)\n    (Wn, We) = self.trace_path(p, w)\n    Wn.reverse()\n    We.reverse()\n    if We != [i]:\n        We.append(i)\n    (WnR, WeR) = self.trace_path(q, w)\n    del WnR[-1]\n    Wn += WnR\n    We += WeR\n    return (Wn, We)",
            "def find_cycle(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns the nodes and edges on the cycle containing edge i == (p, q)\\n        when the latter is added to the spanning tree.\\n\\n        The cycle is oriented in the direction from p to q.\\n        '\n    w = self.find_apex(p, q)\n    (Wn, We) = self.trace_path(p, w)\n    Wn.reverse()\n    We.reverse()\n    if We != [i]:\n        We.append(i)\n    (WnR, WeR) = self.trace_path(q, w)\n    del WnR[-1]\n    Wn += WnR\n    We += WeR\n    return (Wn, We)",
            "def find_cycle(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns the nodes and edges on the cycle containing edge i == (p, q)\\n        when the latter is added to the spanning tree.\\n\\n        The cycle is oriented in the direction from p to q.\\n        '\n    w = self.find_apex(p, q)\n    (Wn, We) = self.trace_path(p, w)\n    Wn.reverse()\n    We.reverse()\n    if We != [i]:\n        We.append(i)\n    (WnR, WeR) = self.trace_path(q, w)\n    del WnR[-1]\n    Wn += WnR\n    We += WeR\n    return (Wn, We)"
        ]
    },
    {
        "func_name": "augment_flow",
        "original": "def augment_flow(self, Wn, We, f):\n    \"\"\"\n        Augment f units of flow along a cycle represented by Wn and We.\n        \"\"\"\n    for (i, p) in zip(We, Wn):\n        if self.edge_sources[i] == p:\n            self.edge_flow[i] += f\n        else:\n            self.edge_flow[i] -= f",
        "mutated": [
            "def augment_flow(self, Wn, We, f):\n    if False:\n        i = 10\n    '\\n        Augment f units of flow along a cycle represented by Wn and We.\\n        '\n    for (i, p) in zip(We, Wn):\n        if self.edge_sources[i] == p:\n            self.edge_flow[i] += f\n        else:\n            self.edge_flow[i] -= f",
            "def augment_flow(self, Wn, We, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Augment f units of flow along a cycle represented by Wn and We.\\n        '\n    for (i, p) in zip(We, Wn):\n        if self.edge_sources[i] == p:\n            self.edge_flow[i] += f\n        else:\n            self.edge_flow[i] -= f",
            "def augment_flow(self, Wn, We, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Augment f units of flow along a cycle represented by Wn and We.\\n        '\n    for (i, p) in zip(We, Wn):\n        if self.edge_sources[i] == p:\n            self.edge_flow[i] += f\n        else:\n            self.edge_flow[i] -= f",
            "def augment_flow(self, Wn, We, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Augment f units of flow along a cycle represented by Wn and We.\\n        '\n    for (i, p) in zip(We, Wn):\n        if self.edge_sources[i] == p:\n            self.edge_flow[i] += f\n        else:\n            self.edge_flow[i] -= f",
            "def augment_flow(self, Wn, We, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Augment f units of flow along a cycle represented by Wn and We.\\n        '\n    for (i, p) in zip(We, Wn):\n        if self.edge_sources[i] == p:\n            self.edge_flow[i] += f\n        else:\n            self.edge_flow[i] -= f"
        ]
    },
    {
        "func_name": "trace_subtree",
        "original": "def trace_subtree(self, p):\n    \"\"\"\n        Yield the nodes in the subtree rooted at a node p.\n        \"\"\"\n    yield p\n    l = self.last_descendent_dft[p]\n    while p != l:\n        p = self.next_node_dft[p]\n        yield p",
        "mutated": [
            "def trace_subtree(self, p):\n    if False:\n        i = 10\n    '\\n        Yield the nodes in the subtree rooted at a node p.\\n        '\n    yield p\n    l = self.last_descendent_dft[p]\n    while p != l:\n        p = self.next_node_dft[p]\n        yield p",
            "def trace_subtree(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Yield the nodes in the subtree rooted at a node p.\\n        '\n    yield p\n    l = self.last_descendent_dft[p]\n    while p != l:\n        p = self.next_node_dft[p]\n        yield p",
            "def trace_subtree(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Yield the nodes in the subtree rooted at a node p.\\n        '\n    yield p\n    l = self.last_descendent_dft[p]\n    while p != l:\n        p = self.next_node_dft[p]\n        yield p",
            "def trace_subtree(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Yield the nodes in the subtree rooted at a node p.\\n        '\n    yield p\n    l = self.last_descendent_dft[p]\n    while p != l:\n        p = self.next_node_dft[p]\n        yield p",
            "def trace_subtree(self, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Yield the nodes in the subtree rooted at a node p.\\n        '\n    yield p\n    l = self.last_descendent_dft[p]\n    while p != l:\n        p = self.next_node_dft[p]\n        yield p"
        ]
    },
    {
        "func_name": "remove_edge",
        "original": "def remove_edge(self, s, t):\n    \"\"\"\n        Remove an edge (s, t) where parent[t] == s from the spanning tree.\n        \"\"\"\n    size_t = self.subtree_size[t]\n    prev_t = self.prev_node_dft[t]\n    last_t = self.last_descendent_dft[t]\n    next_last_t = self.next_node_dft[last_t]\n    self.parent[t] = None\n    self.parent_edge[t] = None\n    self.next_node_dft[prev_t] = next_last_t\n    self.prev_node_dft[next_last_t] = prev_t\n    self.next_node_dft[last_t] = t\n    self.prev_node_dft[t] = last_t\n    while s is not None:\n        self.subtree_size[s] -= size_t\n        if self.last_descendent_dft[s] == last_t:\n            self.last_descendent_dft[s] = prev_t\n        s = self.parent[s]",
        "mutated": [
            "def remove_edge(self, s, t):\n    if False:\n        i = 10\n    '\\n        Remove an edge (s, t) where parent[t] == s from the spanning tree.\\n        '\n    size_t = self.subtree_size[t]\n    prev_t = self.prev_node_dft[t]\n    last_t = self.last_descendent_dft[t]\n    next_last_t = self.next_node_dft[last_t]\n    self.parent[t] = None\n    self.parent_edge[t] = None\n    self.next_node_dft[prev_t] = next_last_t\n    self.prev_node_dft[next_last_t] = prev_t\n    self.next_node_dft[last_t] = t\n    self.prev_node_dft[t] = last_t\n    while s is not None:\n        self.subtree_size[s] -= size_t\n        if self.last_descendent_dft[s] == last_t:\n            self.last_descendent_dft[s] = prev_t\n        s = self.parent[s]",
            "def remove_edge(self, s, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Remove an edge (s, t) where parent[t] == s from the spanning tree.\\n        '\n    size_t = self.subtree_size[t]\n    prev_t = self.prev_node_dft[t]\n    last_t = self.last_descendent_dft[t]\n    next_last_t = self.next_node_dft[last_t]\n    self.parent[t] = None\n    self.parent_edge[t] = None\n    self.next_node_dft[prev_t] = next_last_t\n    self.prev_node_dft[next_last_t] = prev_t\n    self.next_node_dft[last_t] = t\n    self.prev_node_dft[t] = last_t\n    while s is not None:\n        self.subtree_size[s] -= size_t\n        if self.last_descendent_dft[s] == last_t:\n            self.last_descendent_dft[s] = prev_t\n        s = self.parent[s]",
            "def remove_edge(self, s, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Remove an edge (s, t) where parent[t] == s from the spanning tree.\\n        '\n    size_t = self.subtree_size[t]\n    prev_t = self.prev_node_dft[t]\n    last_t = self.last_descendent_dft[t]\n    next_last_t = self.next_node_dft[last_t]\n    self.parent[t] = None\n    self.parent_edge[t] = None\n    self.next_node_dft[prev_t] = next_last_t\n    self.prev_node_dft[next_last_t] = prev_t\n    self.next_node_dft[last_t] = t\n    self.prev_node_dft[t] = last_t\n    while s is not None:\n        self.subtree_size[s] -= size_t\n        if self.last_descendent_dft[s] == last_t:\n            self.last_descendent_dft[s] = prev_t\n        s = self.parent[s]",
            "def remove_edge(self, s, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Remove an edge (s, t) where parent[t] == s from the spanning tree.\\n        '\n    size_t = self.subtree_size[t]\n    prev_t = self.prev_node_dft[t]\n    last_t = self.last_descendent_dft[t]\n    next_last_t = self.next_node_dft[last_t]\n    self.parent[t] = None\n    self.parent_edge[t] = None\n    self.next_node_dft[prev_t] = next_last_t\n    self.prev_node_dft[next_last_t] = prev_t\n    self.next_node_dft[last_t] = t\n    self.prev_node_dft[t] = last_t\n    while s is not None:\n        self.subtree_size[s] -= size_t\n        if self.last_descendent_dft[s] == last_t:\n            self.last_descendent_dft[s] = prev_t\n        s = self.parent[s]",
            "def remove_edge(self, s, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Remove an edge (s, t) where parent[t] == s from the spanning tree.\\n        '\n    size_t = self.subtree_size[t]\n    prev_t = self.prev_node_dft[t]\n    last_t = self.last_descendent_dft[t]\n    next_last_t = self.next_node_dft[last_t]\n    self.parent[t] = None\n    self.parent_edge[t] = None\n    self.next_node_dft[prev_t] = next_last_t\n    self.prev_node_dft[next_last_t] = prev_t\n    self.next_node_dft[last_t] = t\n    self.prev_node_dft[t] = last_t\n    while s is not None:\n        self.subtree_size[s] -= size_t\n        if self.last_descendent_dft[s] == last_t:\n            self.last_descendent_dft[s] = prev_t\n        s = self.parent[s]"
        ]
    },
    {
        "func_name": "make_root",
        "original": "def make_root(self, q):\n    \"\"\"\n        Make a node q the root of its containing subtree.\n        \"\"\"\n    ancestors = []\n    while q is not None:\n        ancestors.append(q)\n        q = self.parent[q]\n    ancestors.reverse()\n    for (p, q) in zip(ancestors, islice(ancestors, 1, None)):\n        size_p = self.subtree_size[p]\n        last_p = self.last_descendent_dft[p]\n        prev_q = self.prev_node_dft[q]\n        last_q = self.last_descendent_dft[q]\n        next_last_q = self.next_node_dft[last_q]\n        self.parent[p] = q\n        self.parent[q] = None\n        self.parent_edge[p] = self.parent_edge[q]\n        self.parent_edge[q] = None\n        self.subtree_size[p] = size_p - self.subtree_size[q]\n        self.subtree_size[q] = size_p\n        self.next_node_dft[prev_q] = next_last_q\n        self.prev_node_dft[next_last_q] = prev_q\n        self.next_node_dft[last_q] = q\n        self.prev_node_dft[q] = last_q\n        if last_p == last_q:\n            self.last_descendent_dft[p] = prev_q\n            last_p = prev_q\n        self.prev_node_dft[p] = last_q\n        self.next_node_dft[last_q] = p\n        self.next_node_dft[last_p] = q\n        self.prev_node_dft[q] = last_p\n        self.last_descendent_dft[q] = last_p",
        "mutated": [
            "def make_root(self, q):\n    if False:\n        i = 10\n    '\\n        Make a node q the root of its containing subtree.\\n        '\n    ancestors = []\n    while q is not None:\n        ancestors.append(q)\n        q = self.parent[q]\n    ancestors.reverse()\n    for (p, q) in zip(ancestors, islice(ancestors, 1, None)):\n        size_p = self.subtree_size[p]\n        last_p = self.last_descendent_dft[p]\n        prev_q = self.prev_node_dft[q]\n        last_q = self.last_descendent_dft[q]\n        next_last_q = self.next_node_dft[last_q]\n        self.parent[p] = q\n        self.parent[q] = None\n        self.parent_edge[p] = self.parent_edge[q]\n        self.parent_edge[q] = None\n        self.subtree_size[p] = size_p - self.subtree_size[q]\n        self.subtree_size[q] = size_p\n        self.next_node_dft[prev_q] = next_last_q\n        self.prev_node_dft[next_last_q] = prev_q\n        self.next_node_dft[last_q] = q\n        self.prev_node_dft[q] = last_q\n        if last_p == last_q:\n            self.last_descendent_dft[p] = prev_q\n            last_p = prev_q\n        self.prev_node_dft[p] = last_q\n        self.next_node_dft[last_q] = p\n        self.next_node_dft[last_p] = q\n        self.prev_node_dft[q] = last_p\n        self.last_descendent_dft[q] = last_p",
            "def make_root(self, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Make a node q the root of its containing subtree.\\n        '\n    ancestors = []\n    while q is not None:\n        ancestors.append(q)\n        q = self.parent[q]\n    ancestors.reverse()\n    for (p, q) in zip(ancestors, islice(ancestors, 1, None)):\n        size_p = self.subtree_size[p]\n        last_p = self.last_descendent_dft[p]\n        prev_q = self.prev_node_dft[q]\n        last_q = self.last_descendent_dft[q]\n        next_last_q = self.next_node_dft[last_q]\n        self.parent[p] = q\n        self.parent[q] = None\n        self.parent_edge[p] = self.parent_edge[q]\n        self.parent_edge[q] = None\n        self.subtree_size[p] = size_p - self.subtree_size[q]\n        self.subtree_size[q] = size_p\n        self.next_node_dft[prev_q] = next_last_q\n        self.prev_node_dft[next_last_q] = prev_q\n        self.next_node_dft[last_q] = q\n        self.prev_node_dft[q] = last_q\n        if last_p == last_q:\n            self.last_descendent_dft[p] = prev_q\n            last_p = prev_q\n        self.prev_node_dft[p] = last_q\n        self.next_node_dft[last_q] = p\n        self.next_node_dft[last_p] = q\n        self.prev_node_dft[q] = last_p\n        self.last_descendent_dft[q] = last_p",
            "def make_root(self, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Make a node q the root of its containing subtree.\\n        '\n    ancestors = []\n    while q is not None:\n        ancestors.append(q)\n        q = self.parent[q]\n    ancestors.reverse()\n    for (p, q) in zip(ancestors, islice(ancestors, 1, None)):\n        size_p = self.subtree_size[p]\n        last_p = self.last_descendent_dft[p]\n        prev_q = self.prev_node_dft[q]\n        last_q = self.last_descendent_dft[q]\n        next_last_q = self.next_node_dft[last_q]\n        self.parent[p] = q\n        self.parent[q] = None\n        self.parent_edge[p] = self.parent_edge[q]\n        self.parent_edge[q] = None\n        self.subtree_size[p] = size_p - self.subtree_size[q]\n        self.subtree_size[q] = size_p\n        self.next_node_dft[prev_q] = next_last_q\n        self.prev_node_dft[next_last_q] = prev_q\n        self.next_node_dft[last_q] = q\n        self.prev_node_dft[q] = last_q\n        if last_p == last_q:\n            self.last_descendent_dft[p] = prev_q\n            last_p = prev_q\n        self.prev_node_dft[p] = last_q\n        self.next_node_dft[last_q] = p\n        self.next_node_dft[last_p] = q\n        self.prev_node_dft[q] = last_p\n        self.last_descendent_dft[q] = last_p",
            "def make_root(self, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Make a node q the root of its containing subtree.\\n        '\n    ancestors = []\n    while q is not None:\n        ancestors.append(q)\n        q = self.parent[q]\n    ancestors.reverse()\n    for (p, q) in zip(ancestors, islice(ancestors, 1, None)):\n        size_p = self.subtree_size[p]\n        last_p = self.last_descendent_dft[p]\n        prev_q = self.prev_node_dft[q]\n        last_q = self.last_descendent_dft[q]\n        next_last_q = self.next_node_dft[last_q]\n        self.parent[p] = q\n        self.parent[q] = None\n        self.parent_edge[p] = self.parent_edge[q]\n        self.parent_edge[q] = None\n        self.subtree_size[p] = size_p - self.subtree_size[q]\n        self.subtree_size[q] = size_p\n        self.next_node_dft[prev_q] = next_last_q\n        self.prev_node_dft[next_last_q] = prev_q\n        self.next_node_dft[last_q] = q\n        self.prev_node_dft[q] = last_q\n        if last_p == last_q:\n            self.last_descendent_dft[p] = prev_q\n            last_p = prev_q\n        self.prev_node_dft[p] = last_q\n        self.next_node_dft[last_q] = p\n        self.next_node_dft[last_p] = q\n        self.prev_node_dft[q] = last_p\n        self.last_descendent_dft[q] = last_p",
            "def make_root(self, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Make a node q the root of its containing subtree.\\n        '\n    ancestors = []\n    while q is not None:\n        ancestors.append(q)\n        q = self.parent[q]\n    ancestors.reverse()\n    for (p, q) in zip(ancestors, islice(ancestors, 1, None)):\n        size_p = self.subtree_size[p]\n        last_p = self.last_descendent_dft[p]\n        prev_q = self.prev_node_dft[q]\n        last_q = self.last_descendent_dft[q]\n        next_last_q = self.next_node_dft[last_q]\n        self.parent[p] = q\n        self.parent[q] = None\n        self.parent_edge[p] = self.parent_edge[q]\n        self.parent_edge[q] = None\n        self.subtree_size[p] = size_p - self.subtree_size[q]\n        self.subtree_size[q] = size_p\n        self.next_node_dft[prev_q] = next_last_q\n        self.prev_node_dft[next_last_q] = prev_q\n        self.next_node_dft[last_q] = q\n        self.prev_node_dft[q] = last_q\n        if last_p == last_q:\n            self.last_descendent_dft[p] = prev_q\n            last_p = prev_q\n        self.prev_node_dft[p] = last_q\n        self.next_node_dft[last_q] = p\n        self.next_node_dft[last_p] = q\n        self.prev_node_dft[q] = last_p\n        self.last_descendent_dft[q] = last_p"
        ]
    },
    {
        "func_name": "add_edge",
        "original": "def add_edge(self, i, p, q):\n    \"\"\"\n        Add an edge (p, q) to the spanning tree where q is the root of a subtree.\n        \"\"\"\n    last_p = self.last_descendent_dft[p]\n    next_last_p = self.next_node_dft[last_p]\n    size_q = self.subtree_size[q]\n    last_q = self.last_descendent_dft[q]\n    self.parent[q] = p\n    self.parent_edge[q] = i\n    self.next_node_dft[last_p] = q\n    self.prev_node_dft[q] = last_p\n    self.prev_node_dft[next_last_p] = last_q\n    self.next_node_dft[last_q] = next_last_p\n    while p is not None:\n        self.subtree_size[p] += size_q\n        if self.last_descendent_dft[p] == last_p:\n            self.last_descendent_dft[p] = last_q\n        p = self.parent[p]",
        "mutated": [
            "def add_edge(self, i, p, q):\n    if False:\n        i = 10\n    '\\n        Add an edge (p, q) to the spanning tree where q is the root of a subtree.\\n        '\n    last_p = self.last_descendent_dft[p]\n    next_last_p = self.next_node_dft[last_p]\n    size_q = self.subtree_size[q]\n    last_q = self.last_descendent_dft[q]\n    self.parent[q] = p\n    self.parent_edge[q] = i\n    self.next_node_dft[last_p] = q\n    self.prev_node_dft[q] = last_p\n    self.prev_node_dft[next_last_p] = last_q\n    self.next_node_dft[last_q] = next_last_p\n    while p is not None:\n        self.subtree_size[p] += size_q\n        if self.last_descendent_dft[p] == last_p:\n            self.last_descendent_dft[p] = last_q\n        p = self.parent[p]",
            "def add_edge(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Add an edge (p, q) to the spanning tree where q is the root of a subtree.\\n        '\n    last_p = self.last_descendent_dft[p]\n    next_last_p = self.next_node_dft[last_p]\n    size_q = self.subtree_size[q]\n    last_q = self.last_descendent_dft[q]\n    self.parent[q] = p\n    self.parent_edge[q] = i\n    self.next_node_dft[last_p] = q\n    self.prev_node_dft[q] = last_p\n    self.prev_node_dft[next_last_p] = last_q\n    self.next_node_dft[last_q] = next_last_p\n    while p is not None:\n        self.subtree_size[p] += size_q\n        if self.last_descendent_dft[p] == last_p:\n            self.last_descendent_dft[p] = last_q\n        p = self.parent[p]",
            "def add_edge(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Add an edge (p, q) to the spanning tree where q is the root of a subtree.\\n        '\n    last_p = self.last_descendent_dft[p]\n    next_last_p = self.next_node_dft[last_p]\n    size_q = self.subtree_size[q]\n    last_q = self.last_descendent_dft[q]\n    self.parent[q] = p\n    self.parent_edge[q] = i\n    self.next_node_dft[last_p] = q\n    self.prev_node_dft[q] = last_p\n    self.prev_node_dft[next_last_p] = last_q\n    self.next_node_dft[last_q] = next_last_p\n    while p is not None:\n        self.subtree_size[p] += size_q\n        if self.last_descendent_dft[p] == last_p:\n            self.last_descendent_dft[p] = last_q\n        p = self.parent[p]",
            "def add_edge(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Add an edge (p, q) to the spanning tree where q is the root of a subtree.\\n        '\n    last_p = self.last_descendent_dft[p]\n    next_last_p = self.next_node_dft[last_p]\n    size_q = self.subtree_size[q]\n    last_q = self.last_descendent_dft[q]\n    self.parent[q] = p\n    self.parent_edge[q] = i\n    self.next_node_dft[last_p] = q\n    self.prev_node_dft[q] = last_p\n    self.prev_node_dft[next_last_p] = last_q\n    self.next_node_dft[last_q] = next_last_p\n    while p is not None:\n        self.subtree_size[p] += size_q\n        if self.last_descendent_dft[p] == last_p:\n            self.last_descendent_dft[p] = last_q\n        p = self.parent[p]",
            "def add_edge(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Add an edge (p, q) to the spanning tree where q is the root of a subtree.\\n        '\n    last_p = self.last_descendent_dft[p]\n    next_last_p = self.next_node_dft[last_p]\n    size_q = self.subtree_size[q]\n    last_q = self.last_descendent_dft[q]\n    self.parent[q] = p\n    self.parent_edge[q] = i\n    self.next_node_dft[last_p] = q\n    self.prev_node_dft[q] = last_p\n    self.prev_node_dft[next_last_p] = last_q\n    self.next_node_dft[last_q] = next_last_p\n    while p is not None:\n        self.subtree_size[p] += size_q\n        if self.last_descendent_dft[p] == last_p:\n            self.last_descendent_dft[p] = last_q\n        p = self.parent[p]"
        ]
    },
    {
        "func_name": "update_potentials",
        "original": "def update_potentials(self, i, p, q):\n    \"\"\"\n        Update the potentials of the nodes in the subtree rooted at a node\n        q connected to its parent p by an edge i.\n        \"\"\"\n    if q == self.edge_targets[i]:\n        d = self.node_potentials[p] - self.edge_weights[i] - self.node_potentials[q]\n    else:\n        d = self.node_potentials[p] + self.edge_weights[i] - self.node_potentials[q]\n    for q in self.trace_subtree(q):\n        self.node_potentials[q] += d",
        "mutated": [
            "def update_potentials(self, i, p, q):\n    if False:\n        i = 10\n    '\\n        Update the potentials of the nodes in the subtree rooted at a node\\n        q connected to its parent p by an edge i.\\n        '\n    if q == self.edge_targets[i]:\n        d = self.node_potentials[p] - self.edge_weights[i] - self.node_potentials[q]\n    else:\n        d = self.node_potentials[p] + self.edge_weights[i] - self.node_potentials[q]\n    for q in self.trace_subtree(q):\n        self.node_potentials[q] += d",
            "def update_potentials(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Update the potentials of the nodes in the subtree rooted at a node\\n        q connected to its parent p by an edge i.\\n        '\n    if q == self.edge_targets[i]:\n        d = self.node_potentials[p] - self.edge_weights[i] - self.node_potentials[q]\n    else:\n        d = self.node_potentials[p] + self.edge_weights[i] - self.node_potentials[q]\n    for q in self.trace_subtree(q):\n        self.node_potentials[q] += d",
            "def update_potentials(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Update the potentials of the nodes in the subtree rooted at a node\\n        q connected to its parent p by an edge i.\\n        '\n    if q == self.edge_targets[i]:\n        d = self.node_potentials[p] - self.edge_weights[i] - self.node_potentials[q]\n    else:\n        d = self.node_potentials[p] + self.edge_weights[i] - self.node_potentials[q]\n    for q in self.trace_subtree(q):\n        self.node_potentials[q] += d",
            "def update_potentials(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Update the potentials of the nodes in the subtree rooted at a node\\n        q connected to its parent p by an edge i.\\n        '\n    if q == self.edge_targets[i]:\n        d = self.node_potentials[p] - self.edge_weights[i] - self.node_potentials[q]\n    else:\n        d = self.node_potentials[p] + self.edge_weights[i] - self.node_potentials[q]\n    for q in self.trace_subtree(q):\n        self.node_potentials[q] += d",
            "def update_potentials(self, i, p, q):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Update the potentials of the nodes in the subtree rooted at a node\\n        q connected to its parent p by an edge i.\\n        '\n    if q == self.edge_targets[i]:\n        d = self.node_potentials[p] - self.edge_weights[i] - self.node_potentials[q]\n    else:\n        d = self.node_potentials[p] + self.edge_weights[i] - self.node_potentials[q]\n    for q in self.trace_subtree(q):\n        self.node_potentials[q] += d"
        ]
    },
    {
        "func_name": "reduced_cost",
        "original": "def reduced_cost(self, i):\n    \"\"\"Returns the reduced cost of an edge i.\"\"\"\n    c = self.edge_weights[i] - self.node_potentials[self.edge_sources[i]] + self.node_potentials[self.edge_targets[i]]\n    return c if self.edge_flow[i] == 0 else -c",
        "mutated": [
            "def reduced_cost(self, i):\n    if False:\n        i = 10\n    'Returns the reduced cost of an edge i.'\n    c = self.edge_weights[i] - self.node_potentials[self.edge_sources[i]] + self.node_potentials[self.edge_targets[i]]\n    return c if self.edge_flow[i] == 0 else -c",
            "def reduced_cost(self, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the reduced cost of an edge i.'\n    c = self.edge_weights[i] - self.node_potentials[self.edge_sources[i]] + self.node_potentials[self.edge_targets[i]]\n    return c if self.edge_flow[i] == 0 else -c",
            "def reduced_cost(self, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the reduced cost of an edge i.'\n    c = self.edge_weights[i] - self.node_potentials[self.edge_sources[i]] + self.node_potentials[self.edge_targets[i]]\n    return c if self.edge_flow[i] == 0 else -c",
            "def reduced_cost(self, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the reduced cost of an edge i.'\n    c = self.edge_weights[i] - self.node_potentials[self.edge_sources[i]] + self.node_potentials[self.edge_targets[i]]\n    return c if self.edge_flow[i] == 0 else -c",
            "def reduced_cost(self, i):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the reduced cost of an edge i.'\n    c = self.edge_weights[i] - self.node_potentials[self.edge_sources[i]] + self.node_potentials[self.edge_targets[i]]\n    return c if self.edge_flow[i] == 0 else -c"
        ]
    },
    {
        "func_name": "find_entering_edges",
        "original": "def find_entering_edges(self):\n    \"\"\"Yield entering edges until none can be found.\"\"\"\n    if self.edge_count == 0:\n        return\n    B = int(ceil(sqrt(self.edge_count)))\n    M = (self.edge_count + B - 1) // B\n    m = 0\n    f = 0\n    while m < M:\n        l = f + B\n        if l <= self.edge_count:\n            edges = range(f, l)\n        else:\n            l -= self.edge_count\n            edges = chain(range(f, self.edge_count), range(l))\n        f = l\n        i = min(edges, key=self.reduced_cost)\n        c = self.reduced_cost(i)\n        if c >= 0:\n            m += 1\n        else:\n            if self.edge_flow[i] == 0:\n                p = self.edge_sources[i]\n                q = self.edge_targets[i]\n            else:\n                p = self.edge_targets[i]\n                q = self.edge_sources[i]\n            yield (i, p, q)\n            m = 0",
        "mutated": [
            "def find_entering_edges(self):\n    if False:\n        i = 10\n    'Yield entering edges until none can be found.'\n    if self.edge_count == 0:\n        return\n    B = int(ceil(sqrt(self.edge_count)))\n    M = (self.edge_count + B - 1) // B\n    m = 0\n    f = 0\n    while m < M:\n        l = f + B\n        if l <= self.edge_count:\n            edges = range(f, l)\n        else:\n            l -= self.edge_count\n            edges = chain(range(f, self.edge_count), range(l))\n        f = l\n        i = min(edges, key=self.reduced_cost)\n        c = self.reduced_cost(i)\n        if c >= 0:\n            m += 1\n        else:\n            if self.edge_flow[i] == 0:\n                p = self.edge_sources[i]\n                q = self.edge_targets[i]\n            else:\n                p = self.edge_targets[i]\n                q = self.edge_sources[i]\n            yield (i, p, q)\n            m = 0",
            "def find_entering_edges(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Yield entering edges until none can be found.'\n    if self.edge_count == 0:\n        return\n    B = int(ceil(sqrt(self.edge_count)))\n    M = (self.edge_count + B - 1) // B\n    m = 0\n    f = 0\n    while m < M:\n        l = f + B\n        if l <= self.edge_count:\n            edges = range(f, l)\n        else:\n            l -= self.edge_count\n            edges = chain(range(f, self.edge_count), range(l))\n        f = l\n        i = min(edges, key=self.reduced_cost)\n        c = self.reduced_cost(i)\n        if c >= 0:\n            m += 1\n        else:\n            if self.edge_flow[i] == 0:\n                p = self.edge_sources[i]\n                q = self.edge_targets[i]\n            else:\n                p = self.edge_targets[i]\n                q = self.edge_sources[i]\n            yield (i, p, q)\n            m = 0",
            "def find_entering_edges(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Yield entering edges until none can be found.'\n    if self.edge_count == 0:\n        return\n    B = int(ceil(sqrt(self.edge_count)))\n    M = (self.edge_count + B - 1) // B\n    m = 0\n    f = 0\n    while m < M:\n        l = f + B\n        if l <= self.edge_count:\n            edges = range(f, l)\n        else:\n            l -= self.edge_count\n            edges = chain(range(f, self.edge_count), range(l))\n        f = l\n        i = min(edges, key=self.reduced_cost)\n        c = self.reduced_cost(i)\n        if c >= 0:\n            m += 1\n        else:\n            if self.edge_flow[i] == 0:\n                p = self.edge_sources[i]\n                q = self.edge_targets[i]\n            else:\n                p = self.edge_targets[i]\n                q = self.edge_sources[i]\n            yield (i, p, q)\n            m = 0",
            "def find_entering_edges(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Yield entering edges until none can be found.'\n    if self.edge_count == 0:\n        return\n    B = int(ceil(sqrt(self.edge_count)))\n    M = (self.edge_count + B - 1) // B\n    m = 0\n    f = 0\n    while m < M:\n        l = f + B\n        if l <= self.edge_count:\n            edges = range(f, l)\n        else:\n            l -= self.edge_count\n            edges = chain(range(f, self.edge_count), range(l))\n        f = l\n        i = min(edges, key=self.reduced_cost)\n        c = self.reduced_cost(i)\n        if c >= 0:\n            m += 1\n        else:\n            if self.edge_flow[i] == 0:\n                p = self.edge_sources[i]\n                q = self.edge_targets[i]\n            else:\n                p = self.edge_targets[i]\n                q = self.edge_sources[i]\n            yield (i, p, q)\n            m = 0",
            "def find_entering_edges(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Yield entering edges until none can be found.'\n    if self.edge_count == 0:\n        return\n    B = int(ceil(sqrt(self.edge_count)))\n    M = (self.edge_count + B - 1) // B\n    m = 0\n    f = 0\n    while m < M:\n        l = f + B\n        if l <= self.edge_count:\n            edges = range(f, l)\n        else:\n            l -= self.edge_count\n            edges = chain(range(f, self.edge_count), range(l))\n        f = l\n        i = min(edges, key=self.reduced_cost)\n        c = self.reduced_cost(i)\n        if c >= 0:\n            m += 1\n        else:\n            if self.edge_flow[i] == 0:\n                p = self.edge_sources[i]\n                q = self.edge_targets[i]\n            else:\n                p = self.edge_targets[i]\n                q = self.edge_sources[i]\n            yield (i, p, q)\n            m = 0"
        ]
    },
    {
        "func_name": "residual_capacity",
        "original": "def residual_capacity(self, i, p):\n    \"\"\"Returns the residual capacity of an edge i in the direction away\n        from its endpoint p.\n        \"\"\"\n    return self.edge_capacities[i] - self.edge_flow[i] if self.edge_sources[i] == p else self.edge_flow[i]",
        "mutated": [
            "def residual_capacity(self, i, p):\n    if False:\n        i = 10\n    'Returns the residual capacity of an edge i in the direction away\\n        from its endpoint p.\\n        '\n    return self.edge_capacities[i] - self.edge_flow[i] if self.edge_sources[i] == p else self.edge_flow[i]",
            "def residual_capacity(self, i, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the residual capacity of an edge i in the direction away\\n        from its endpoint p.\\n        '\n    return self.edge_capacities[i] - self.edge_flow[i] if self.edge_sources[i] == p else self.edge_flow[i]",
            "def residual_capacity(self, i, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the residual capacity of an edge i in the direction away\\n        from its endpoint p.\\n        '\n    return self.edge_capacities[i] - self.edge_flow[i] if self.edge_sources[i] == p else self.edge_flow[i]",
            "def residual_capacity(self, i, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the residual capacity of an edge i in the direction away\\n        from its endpoint p.\\n        '\n    return self.edge_capacities[i] - self.edge_flow[i] if self.edge_sources[i] == p else self.edge_flow[i]",
            "def residual_capacity(self, i, p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the residual capacity of an edge i in the direction away\\n        from its endpoint p.\\n        '\n    return self.edge_capacities[i] - self.edge_flow[i] if self.edge_sources[i] == p else self.edge_flow[i]"
        ]
    },
    {
        "func_name": "find_leaving_edge",
        "original": "def find_leaving_edge(self, Wn, We):\n    \"\"\"Returns the leaving edge in a cycle represented by Wn and We.\"\"\"\n    (j, s) = min(zip(reversed(We), reversed(Wn)), key=lambda i_p: self.residual_capacity(*i_p))\n    t = self.edge_targets[j] if self.edge_sources[j] == s else self.edge_sources[j]\n    return (j, s, t)",
        "mutated": [
            "def find_leaving_edge(self, Wn, We):\n    if False:\n        i = 10\n    'Returns the leaving edge in a cycle represented by Wn and We.'\n    (j, s) = min(zip(reversed(We), reversed(Wn)), key=lambda i_p: self.residual_capacity(*i_p))\n    t = self.edge_targets[j] if self.edge_sources[j] == s else self.edge_sources[j]\n    return (j, s, t)",
            "def find_leaving_edge(self, Wn, We):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the leaving edge in a cycle represented by Wn and We.'\n    (j, s) = min(zip(reversed(We), reversed(Wn)), key=lambda i_p: self.residual_capacity(*i_p))\n    t = self.edge_targets[j] if self.edge_sources[j] == s else self.edge_sources[j]\n    return (j, s, t)",
            "def find_leaving_edge(self, Wn, We):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the leaving edge in a cycle represented by Wn and We.'\n    (j, s) = min(zip(reversed(We), reversed(Wn)), key=lambda i_p: self.residual_capacity(*i_p))\n    t = self.edge_targets[j] if self.edge_sources[j] == s else self.edge_sources[j]\n    return (j, s, t)",
            "def find_leaving_edge(self, Wn, We):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the leaving edge in a cycle represented by Wn and We.'\n    (j, s) = min(zip(reversed(We), reversed(Wn)), key=lambda i_p: self.residual_capacity(*i_p))\n    t = self.edge_targets[j] if self.edge_sources[j] == s else self.edge_sources[j]\n    return (j, s, t)",
            "def find_leaving_edge(self, Wn, We):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the leaving edge in a cycle represented by Wn and We.'\n    (j, s) = min(zip(reversed(We), reversed(Wn)), key=lambda i_p: self.residual_capacity(*i_p))\n    t = self.edge_targets[j] if self.edge_sources[j] == s else self.edge_sources[j]\n    return (j, s, t)"
        ]
    },
    {
        "func_name": "add_entry",
        "original": "def add_entry(e):\n    \"\"\"Add a flow dict entry.\"\"\"\n    d = flow_dict[e[0]]\n    for k in e[1:-2]:\n        try:\n            d = d[k]\n        except KeyError:\n            t = {}\n            d[k] = t\n            d = t\n    d[e[-2]] = e[-1]",
        "mutated": [
            "def add_entry(e):\n    if False:\n        i = 10\n    'Add a flow dict entry.'\n    d = flow_dict[e[0]]\n    for k in e[1:-2]:\n        try:\n            d = d[k]\n        except KeyError:\n            t = {}\n            d[k] = t\n            d = t\n    d[e[-2]] = e[-1]",
            "def add_entry(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Add a flow dict entry.'\n    d = flow_dict[e[0]]\n    for k in e[1:-2]:\n        try:\n            d = d[k]\n        except KeyError:\n            t = {}\n            d[k] = t\n            d = t\n    d[e[-2]] = e[-1]",
            "def add_entry(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Add a flow dict entry.'\n    d = flow_dict[e[0]]\n    for k in e[1:-2]:\n        try:\n            d = d[k]\n        except KeyError:\n            t = {}\n            d[k] = t\n            d = t\n    d[e[-2]] = e[-1]",
            "def add_entry(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Add a flow dict entry.'\n    d = flow_dict[e[0]]\n    for k in e[1:-2]:\n        try:\n            d = d[k]\n        except KeyError:\n            t = {}\n            d[k] = t\n            d = t\n    d[e[-2]] = e[-1]",
            "def add_entry(e):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Add a flow dict entry.'\n    d = flow_dict[e[0]]\n    for k in e[1:-2]:\n        try:\n            d = d[k]\n        except KeyError:\n            t = {}\n            d[k] = t\n            d = t\n    d[e[-2]] = e[-1]"
        ]
    },
    {
        "func_name": "network_simplex",
        "original": "@not_implemented_for('undirected')\n@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef network_simplex(G, demand='demand', capacity='capacity', weight='weight'):\n    \"\"\"Find a minimum cost flow satisfying all demands in digraph G.\n\n    This is a primal network simplex algorithm that uses the leaving\n    arc rule to prevent cycling.\n\n    G is a digraph with edge costs and capacities and in which nodes\n    have demand, i.e., they want to send or receive some amount of\n    flow. A negative demand means that the node wants to send flow, a\n    positive demand means that the node want to receive flow. A flow on\n    the digraph G satisfies all demand if the net flow into each node\n    is equal to the demand of that node.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        DiGraph on which a minimum cost flow satisfying all demands is\n        to be found.\n\n    demand : string\n        Nodes of the graph G are expected to have an attribute demand\n        that indicates how much flow a node wants to send (negative\n        demand) or receive (positive demand). Note that the sum of the\n        demands should be 0 otherwise the problem in not feasible. If\n        this attribute is not present, a node is considered to have 0\n        demand. Default value: 'demand'.\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    weight : string\n        Edges of the graph G are expected to have an attribute weight\n        that indicates the cost incurred by sending one unit of flow on\n        that edge. If not present, the weight is considered to be 0.\n        Default value: 'weight'.\n\n    Returns\n    -------\n    flowCost : integer, float\n        Cost of a minimum cost flow satisfying all demands.\n\n    flowDict : dictionary\n        Dictionary of dictionaries keyed by nodes such that\n        flowDict[u][v] is the flow edge (u, v).\n\n    Raises\n    ------\n    NetworkXError\n        This exception is raised if the input graph is not directed or\n        not connected.\n\n    NetworkXUnfeasible\n        This exception is raised in the following situations:\n\n            * The sum of the demands is not zero. Then, there is no\n              flow satisfying all demands.\n            * There is no flow satisfying all demand.\n\n    NetworkXUnbounded\n        This exception is raised if the digraph G has a cycle of\n        negative cost and infinite capacity. Then, the cost of a flow\n        satisfying all demands is unbounded below.\n\n    Notes\n    -----\n    This algorithm is not guaranteed to work if edge weights or demands\n    are floating point numbers (overflows and roundoff errors can\n    cause problems). As a workaround you can use integer numbers by\n    multiplying the relevant edge attributes by a convenient\n    constant factor (eg 100).\n\n    See also\n    --------\n    cost_of_flow, max_flow_min_cost, min_cost_flow, min_cost_flow_cost\n\n    Examples\n    --------\n    A simple example of a min cost flow problem.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_node(\"a\", demand=-5)\n    >>> G.add_node(\"d\", demand=5)\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n    >>> flowCost, flowDict = nx.network_simplex(G)\n    >>> flowCost\n    24\n    >>> flowDict\n    {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\n\n    The mincost flow algorithm can also be used to solve shortest path\n    problems. To find the shortest path between two nodes u and v,\n    give all edges an infinite capacity, give node u a demand of -1 and\n    node v a demand a 1. Then run the network simplex. The value of a\n    min cost flow will be the distance between u and v and edges\n    carrying positive flow will indicate the path.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_weighted_edges_from(\n    ...     [\n    ...         (\"s\", \"u\", 10),\n    ...         (\"s\", \"x\", 5),\n    ...         (\"u\", \"v\", 1),\n    ...         (\"u\", \"x\", 2),\n    ...         (\"v\", \"y\", 1),\n    ...         (\"x\", \"u\", 3),\n    ...         (\"x\", \"v\", 5),\n    ...         (\"x\", \"y\", 2),\n    ...         (\"y\", \"s\", 7),\n    ...         (\"y\", \"v\", 6),\n    ...     ]\n    ... )\n    >>> G.add_node(\"s\", demand=-1)\n    >>> G.add_node(\"v\", demand=1)\n    >>> flowCost, flowDict = nx.network_simplex(G)\n    >>> flowCost == nx.shortest_path_length(G, \"s\", \"v\", weight=\"weight\")\n    True\n    >>> sorted([(u, v) for u in flowDict for v in flowDict[u] if flowDict[u][v] > 0])\n    [('s', 'x'), ('u', 'v'), ('x', 'u')]\n    >>> nx.shortest_path(G, \"s\", \"v\", weight=\"weight\")\n    ['s', 'x', 'u', 'v']\n\n    It is possible to change the name of the attributes used for the\n    algorithm.\n\n    >>> G = nx.DiGraph()\n    >>> G.add_node(\"p\", spam=-4)\n    >>> G.add_node(\"q\", spam=2)\n    >>> G.add_node(\"a\", spam=-2)\n    >>> G.add_node(\"d\", spam=-1)\n    >>> G.add_node(\"t\", spam=2)\n    >>> G.add_node(\"w\", spam=3)\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\n    >>> flowCost, flowDict = nx.network_simplex(\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\n    ... )\n    >>> flowCost\n    37\n    >>> flowDict\n    {'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}\n\n    References\n    ----------\n    .. [1] Z. Kiraly, P. Kovacs.\n           Efficient implementation of minimum-cost flow algorithms.\n           Acta Universitatis Sapientiae, Informatica 4(1):67--118. 2012.\n    .. [2] R. Barr, F. Glover, D. Klingman.\n           Enhancement of spanning tree labeling procedures for network\n           optimization.\n           INFOR 17(1):16--34. 1979.\n    \"\"\"\n    if len(G) == 0:\n        raise nx.NetworkXError('graph has no nodes')\n    multigraph = G.is_multigraph()\n    DEAF = _DataEssentialsAndFunctions(G, multigraph, demand=demand, capacity=capacity, weight=weight)\n    inf = float('inf')\n    for (u, d) in zip(DEAF.node_list, DEAF.node_demands):\n        if abs(d) == inf:\n            raise nx.NetworkXError(f'node {u!r} has infinite demand')\n    for (e, w) in zip(DEAF.edge_indices, DEAF.edge_weights):\n        if abs(w) == inf:\n            raise nx.NetworkXError(f'edge {e!r} has infinite weight')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if abs(e[-1].get(weight, 0)) == inf:\n            raise nx.NetworkXError(f'edge {e[:-1]!r} has infinite weight')\n    if sum(DEAF.node_demands) != 0:\n        raise nx.NetworkXUnfeasible('total node demand is not zero')\n    for (e, c) in zip(DEAF.edge_indices, DEAF.edge_capacities):\n        if c < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e!r} has negative capacity')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if e[-1].get(capacity, inf) < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e[:-1]!r} has negative capacity')\n    for (i, d) in enumerate(DEAF.node_demands):\n        if d > 0:\n            DEAF.edge_sources.append(-1)\n            DEAF.edge_targets.append(i)\n        else:\n            DEAF.edge_sources.append(i)\n            DEAF.edge_targets.append(-1)\n    faux_inf = 3 * max(chain([sum((c for c in DEAF.edge_capacities if c < inf)), sum((abs(w) for w in DEAF.edge_weights))], (abs(d) for d in DEAF.node_demands))) or 1\n    n = len(DEAF.node_list)\n    DEAF.edge_weights.extend(repeat(faux_inf, n))\n    DEAF.edge_capacities.extend(repeat(faux_inf, n))\n    DEAF.initialize_spanning_tree(n, faux_inf)\n    for (i, p, q) in DEAF.find_entering_edges():\n        (Wn, We) = DEAF.find_cycle(i, p, q)\n        (j, s, t) = DEAF.find_leaving_edge(Wn, We)\n        DEAF.augment_flow(Wn, We, DEAF.residual_capacity(j, s))\n        if i != j:\n            if DEAF.parent[t] != s:\n                (s, t) = (t, s)\n            if We.index(i) > We.index(j):\n                (p, q) = (q, p)\n            DEAF.remove_edge(s, t)\n            DEAF.make_root(q)\n            DEAF.add_edge(i, p, q)\n            DEAF.update_potentials(i, p, q)\n    if any((DEAF.edge_flow[i] != 0 for i in range(-n, 0))):\n        raise nx.NetworkXUnfeasible('no flow satisfies all node demands')\n    if any((DEAF.edge_flow[i] * 2 >= faux_inf for i in range(DEAF.edge_count))) or any((e[-1].get(capacity, inf) == inf and e[-1].get(weight, 0) < 0 for e in nx.selfloop_edges(G, data=True))):\n        raise nx.NetworkXUnbounded('negative cycle with infinite capacity found')\n    del DEAF.edge_flow[DEAF.edge_count:]\n    flow_cost = sum((w * x for (w, x) in zip(DEAF.edge_weights, DEAF.edge_flow)))\n    flow_dict = {n: {} for n in DEAF.node_list}\n\n    def add_entry(e):\n        \"\"\"Add a flow dict entry.\"\"\"\n        d = flow_dict[e[0]]\n        for k in e[1:-2]:\n            try:\n                d = d[k]\n            except KeyError:\n                t = {}\n                d[k] = t\n                d = t\n        d[e[-2]] = e[-1]\n    DEAF.edge_sources = (DEAF.node_list[s] for s in DEAF.edge_sources)\n    DEAF.edge_targets = (DEAF.node_list[t] for t in DEAF.edge_targets)\n    if not multigraph:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True)\n    else:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_keys, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True, keys=True)\n    for e in edges:\n        if e[0] != e[1]:\n            if e[-1].get(capacity, inf) == 0:\n                add_entry(e[:-1] + (0,))\n        else:\n            w = e[-1].get(weight, 0)\n            if w >= 0:\n                add_entry(e[:-1] + (0,))\n            else:\n                c = e[-1][capacity]\n                flow_cost += w * c\n                add_entry(e[:-1] + (c,))\n    return (flow_cost, flow_dict)",
        "mutated": [
            "@not_implemented_for('undirected')\n@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef network_simplex(G, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a primal network simplex algorithm that uses the leaving\\n    arc rule to prevent cycling.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph on which a minimum cost flow satisfying all demands is\\n        to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    Returns\\n    -------\\n    flowCost : integer, float\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        Dictionary of dictionaries keyed by nodes such that\\n        flowDict[u][v] is the flow edge (u, v).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed or\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm is not guaranteed to work if edge weights or demands\\n    are floating point numbers (overflows and roundoff errors can\\n    cause problems). As a workaround you can use integer numbers by\\n    multiplying the relevant edge attributes by a convenient\\n    constant factor (eg 100).\\n\\n    See also\\n    --------\\n    cost_of_flow, max_flow_min_cost, min_cost_flow, min_cost_flow_cost\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    The mincost flow algorithm can also be used to solve shortest path\\n    problems. To find the shortest path between two nodes u and v,\\n    give all edges an infinite capacity, give node u a demand of -1 and\\n    node v a demand a 1. Then run the network simplex. The value of a\\n    min cost flow will be the distance between u and v and edges\\n    carrying positive flow will indicate the path.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_weighted_edges_from(\\n    ...     [\\n    ...         (\"s\", \"u\", 10),\\n    ...         (\"s\", \"x\", 5),\\n    ...         (\"u\", \"v\", 1),\\n    ...         (\"u\", \"x\", 2),\\n    ...         (\"v\", \"y\", 1),\\n    ...         (\"x\", \"u\", 3),\\n    ...         (\"x\", \"v\", 5),\\n    ...         (\"x\", \"y\", 2),\\n    ...         (\"y\", \"s\", 7),\\n    ...         (\"y\", \"v\", 6),\\n    ...     ]\\n    ... )\\n    >>> G.add_node(\"s\", demand=-1)\\n    >>> G.add_node(\"v\", demand=1)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost == nx.shortest_path_length(G, \"s\", \"v\", weight=\"weight\")\\n    True\\n    >>> sorted([(u, v) for u in flowDict for v in flowDict[u] if flowDict[u][v] > 0])\\n    [(\\'s\\', \\'x\\'), (\\'u\\', \\'v\\'), (\\'x\\', \\'u\\')]\\n    >>> nx.shortest_path(G, \"s\", \"v\", weight=\"weight\")\\n    [\\'s\\', \\'x\\', \\'u\\', \\'v\\']\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.network_simplex(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n\\n    References\\n    ----------\\n    .. [1] Z. Kiraly, P. Kovacs.\\n           Efficient implementation of minimum-cost flow algorithms.\\n           Acta Universitatis Sapientiae, Informatica 4(1):67--118. 2012.\\n    .. [2] R. Barr, F. Glover, D. Klingman.\\n           Enhancement of spanning tree labeling procedures for network\\n           optimization.\\n           INFOR 17(1):16--34. 1979.\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXError('graph has no nodes')\n    multigraph = G.is_multigraph()\n    DEAF = _DataEssentialsAndFunctions(G, multigraph, demand=demand, capacity=capacity, weight=weight)\n    inf = float('inf')\n    for (u, d) in zip(DEAF.node_list, DEAF.node_demands):\n        if abs(d) == inf:\n            raise nx.NetworkXError(f'node {u!r} has infinite demand')\n    for (e, w) in zip(DEAF.edge_indices, DEAF.edge_weights):\n        if abs(w) == inf:\n            raise nx.NetworkXError(f'edge {e!r} has infinite weight')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if abs(e[-1].get(weight, 0)) == inf:\n            raise nx.NetworkXError(f'edge {e[:-1]!r} has infinite weight')\n    if sum(DEAF.node_demands) != 0:\n        raise nx.NetworkXUnfeasible('total node demand is not zero')\n    for (e, c) in zip(DEAF.edge_indices, DEAF.edge_capacities):\n        if c < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e!r} has negative capacity')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if e[-1].get(capacity, inf) < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e[:-1]!r} has negative capacity')\n    for (i, d) in enumerate(DEAF.node_demands):\n        if d > 0:\n            DEAF.edge_sources.append(-1)\n            DEAF.edge_targets.append(i)\n        else:\n            DEAF.edge_sources.append(i)\n            DEAF.edge_targets.append(-1)\n    faux_inf = 3 * max(chain([sum((c for c in DEAF.edge_capacities if c < inf)), sum((abs(w) for w in DEAF.edge_weights))], (abs(d) for d in DEAF.node_demands))) or 1\n    n = len(DEAF.node_list)\n    DEAF.edge_weights.extend(repeat(faux_inf, n))\n    DEAF.edge_capacities.extend(repeat(faux_inf, n))\n    DEAF.initialize_spanning_tree(n, faux_inf)\n    for (i, p, q) in DEAF.find_entering_edges():\n        (Wn, We) = DEAF.find_cycle(i, p, q)\n        (j, s, t) = DEAF.find_leaving_edge(Wn, We)\n        DEAF.augment_flow(Wn, We, DEAF.residual_capacity(j, s))\n        if i != j:\n            if DEAF.parent[t] != s:\n                (s, t) = (t, s)\n            if We.index(i) > We.index(j):\n                (p, q) = (q, p)\n            DEAF.remove_edge(s, t)\n            DEAF.make_root(q)\n            DEAF.add_edge(i, p, q)\n            DEAF.update_potentials(i, p, q)\n    if any((DEAF.edge_flow[i] != 0 for i in range(-n, 0))):\n        raise nx.NetworkXUnfeasible('no flow satisfies all node demands')\n    if any((DEAF.edge_flow[i] * 2 >= faux_inf for i in range(DEAF.edge_count))) or any((e[-1].get(capacity, inf) == inf and e[-1].get(weight, 0) < 0 for e in nx.selfloop_edges(G, data=True))):\n        raise nx.NetworkXUnbounded('negative cycle with infinite capacity found')\n    del DEAF.edge_flow[DEAF.edge_count:]\n    flow_cost = sum((w * x for (w, x) in zip(DEAF.edge_weights, DEAF.edge_flow)))\n    flow_dict = {n: {} for n in DEAF.node_list}\n\n    def add_entry(e):\n        \"\"\"Add a flow dict entry.\"\"\"\n        d = flow_dict[e[0]]\n        for k in e[1:-2]:\n            try:\n                d = d[k]\n            except KeyError:\n                t = {}\n                d[k] = t\n                d = t\n        d[e[-2]] = e[-1]\n    DEAF.edge_sources = (DEAF.node_list[s] for s in DEAF.edge_sources)\n    DEAF.edge_targets = (DEAF.node_list[t] for t in DEAF.edge_targets)\n    if not multigraph:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True)\n    else:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_keys, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True, keys=True)\n    for e in edges:\n        if e[0] != e[1]:\n            if e[-1].get(capacity, inf) == 0:\n                add_entry(e[:-1] + (0,))\n        else:\n            w = e[-1].get(weight, 0)\n            if w >= 0:\n                add_entry(e[:-1] + (0,))\n            else:\n                c = e[-1][capacity]\n                flow_cost += w * c\n                add_entry(e[:-1] + (c,))\n    return (flow_cost, flow_dict)",
            "@not_implemented_for('undirected')\n@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef network_simplex(G, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a primal network simplex algorithm that uses the leaving\\n    arc rule to prevent cycling.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph on which a minimum cost flow satisfying all demands is\\n        to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    Returns\\n    -------\\n    flowCost : integer, float\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        Dictionary of dictionaries keyed by nodes such that\\n        flowDict[u][v] is the flow edge (u, v).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed or\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm is not guaranteed to work if edge weights or demands\\n    are floating point numbers (overflows and roundoff errors can\\n    cause problems). As a workaround you can use integer numbers by\\n    multiplying the relevant edge attributes by a convenient\\n    constant factor (eg 100).\\n\\n    See also\\n    --------\\n    cost_of_flow, max_flow_min_cost, min_cost_flow, min_cost_flow_cost\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    The mincost flow algorithm can also be used to solve shortest path\\n    problems. To find the shortest path between two nodes u and v,\\n    give all edges an infinite capacity, give node u a demand of -1 and\\n    node v a demand a 1. Then run the network simplex. The value of a\\n    min cost flow will be the distance between u and v and edges\\n    carrying positive flow will indicate the path.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_weighted_edges_from(\\n    ...     [\\n    ...         (\"s\", \"u\", 10),\\n    ...         (\"s\", \"x\", 5),\\n    ...         (\"u\", \"v\", 1),\\n    ...         (\"u\", \"x\", 2),\\n    ...         (\"v\", \"y\", 1),\\n    ...         (\"x\", \"u\", 3),\\n    ...         (\"x\", \"v\", 5),\\n    ...         (\"x\", \"y\", 2),\\n    ...         (\"y\", \"s\", 7),\\n    ...         (\"y\", \"v\", 6),\\n    ...     ]\\n    ... )\\n    >>> G.add_node(\"s\", demand=-1)\\n    >>> G.add_node(\"v\", demand=1)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost == nx.shortest_path_length(G, \"s\", \"v\", weight=\"weight\")\\n    True\\n    >>> sorted([(u, v) for u in flowDict for v in flowDict[u] if flowDict[u][v] > 0])\\n    [(\\'s\\', \\'x\\'), (\\'u\\', \\'v\\'), (\\'x\\', \\'u\\')]\\n    >>> nx.shortest_path(G, \"s\", \"v\", weight=\"weight\")\\n    [\\'s\\', \\'x\\', \\'u\\', \\'v\\']\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.network_simplex(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n\\n    References\\n    ----------\\n    .. [1] Z. Kiraly, P. Kovacs.\\n           Efficient implementation of minimum-cost flow algorithms.\\n           Acta Universitatis Sapientiae, Informatica 4(1):67--118. 2012.\\n    .. [2] R. Barr, F. Glover, D. Klingman.\\n           Enhancement of spanning tree labeling procedures for network\\n           optimization.\\n           INFOR 17(1):16--34. 1979.\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXError('graph has no nodes')\n    multigraph = G.is_multigraph()\n    DEAF = _DataEssentialsAndFunctions(G, multigraph, demand=demand, capacity=capacity, weight=weight)\n    inf = float('inf')\n    for (u, d) in zip(DEAF.node_list, DEAF.node_demands):\n        if abs(d) == inf:\n            raise nx.NetworkXError(f'node {u!r} has infinite demand')\n    for (e, w) in zip(DEAF.edge_indices, DEAF.edge_weights):\n        if abs(w) == inf:\n            raise nx.NetworkXError(f'edge {e!r} has infinite weight')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if abs(e[-1].get(weight, 0)) == inf:\n            raise nx.NetworkXError(f'edge {e[:-1]!r} has infinite weight')\n    if sum(DEAF.node_demands) != 0:\n        raise nx.NetworkXUnfeasible('total node demand is not zero')\n    for (e, c) in zip(DEAF.edge_indices, DEAF.edge_capacities):\n        if c < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e!r} has negative capacity')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if e[-1].get(capacity, inf) < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e[:-1]!r} has negative capacity')\n    for (i, d) in enumerate(DEAF.node_demands):\n        if d > 0:\n            DEAF.edge_sources.append(-1)\n            DEAF.edge_targets.append(i)\n        else:\n            DEAF.edge_sources.append(i)\n            DEAF.edge_targets.append(-1)\n    faux_inf = 3 * max(chain([sum((c for c in DEAF.edge_capacities if c < inf)), sum((abs(w) for w in DEAF.edge_weights))], (abs(d) for d in DEAF.node_demands))) or 1\n    n = len(DEAF.node_list)\n    DEAF.edge_weights.extend(repeat(faux_inf, n))\n    DEAF.edge_capacities.extend(repeat(faux_inf, n))\n    DEAF.initialize_spanning_tree(n, faux_inf)\n    for (i, p, q) in DEAF.find_entering_edges():\n        (Wn, We) = DEAF.find_cycle(i, p, q)\n        (j, s, t) = DEAF.find_leaving_edge(Wn, We)\n        DEAF.augment_flow(Wn, We, DEAF.residual_capacity(j, s))\n        if i != j:\n            if DEAF.parent[t] != s:\n                (s, t) = (t, s)\n            if We.index(i) > We.index(j):\n                (p, q) = (q, p)\n            DEAF.remove_edge(s, t)\n            DEAF.make_root(q)\n            DEAF.add_edge(i, p, q)\n            DEAF.update_potentials(i, p, q)\n    if any((DEAF.edge_flow[i] != 0 for i in range(-n, 0))):\n        raise nx.NetworkXUnfeasible('no flow satisfies all node demands')\n    if any((DEAF.edge_flow[i] * 2 >= faux_inf for i in range(DEAF.edge_count))) or any((e[-1].get(capacity, inf) == inf and e[-1].get(weight, 0) < 0 for e in nx.selfloop_edges(G, data=True))):\n        raise nx.NetworkXUnbounded('negative cycle with infinite capacity found')\n    del DEAF.edge_flow[DEAF.edge_count:]\n    flow_cost = sum((w * x for (w, x) in zip(DEAF.edge_weights, DEAF.edge_flow)))\n    flow_dict = {n: {} for n in DEAF.node_list}\n\n    def add_entry(e):\n        \"\"\"Add a flow dict entry.\"\"\"\n        d = flow_dict[e[0]]\n        for k in e[1:-2]:\n            try:\n                d = d[k]\n            except KeyError:\n                t = {}\n                d[k] = t\n                d = t\n        d[e[-2]] = e[-1]\n    DEAF.edge_sources = (DEAF.node_list[s] for s in DEAF.edge_sources)\n    DEAF.edge_targets = (DEAF.node_list[t] for t in DEAF.edge_targets)\n    if not multigraph:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True)\n    else:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_keys, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True, keys=True)\n    for e in edges:\n        if e[0] != e[1]:\n            if e[-1].get(capacity, inf) == 0:\n                add_entry(e[:-1] + (0,))\n        else:\n            w = e[-1].get(weight, 0)\n            if w >= 0:\n                add_entry(e[:-1] + (0,))\n            else:\n                c = e[-1][capacity]\n                flow_cost += w * c\n                add_entry(e[:-1] + (c,))\n    return (flow_cost, flow_dict)",
            "@not_implemented_for('undirected')\n@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef network_simplex(G, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a primal network simplex algorithm that uses the leaving\\n    arc rule to prevent cycling.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph on which a minimum cost flow satisfying all demands is\\n        to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    Returns\\n    -------\\n    flowCost : integer, float\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        Dictionary of dictionaries keyed by nodes such that\\n        flowDict[u][v] is the flow edge (u, v).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed or\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm is not guaranteed to work if edge weights or demands\\n    are floating point numbers (overflows and roundoff errors can\\n    cause problems). As a workaround you can use integer numbers by\\n    multiplying the relevant edge attributes by a convenient\\n    constant factor (eg 100).\\n\\n    See also\\n    --------\\n    cost_of_flow, max_flow_min_cost, min_cost_flow, min_cost_flow_cost\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    The mincost flow algorithm can also be used to solve shortest path\\n    problems. To find the shortest path between two nodes u and v,\\n    give all edges an infinite capacity, give node u a demand of -1 and\\n    node v a demand a 1. Then run the network simplex. The value of a\\n    min cost flow will be the distance between u and v and edges\\n    carrying positive flow will indicate the path.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_weighted_edges_from(\\n    ...     [\\n    ...         (\"s\", \"u\", 10),\\n    ...         (\"s\", \"x\", 5),\\n    ...         (\"u\", \"v\", 1),\\n    ...         (\"u\", \"x\", 2),\\n    ...         (\"v\", \"y\", 1),\\n    ...         (\"x\", \"u\", 3),\\n    ...         (\"x\", \"v\", 5),\\n    ...         (\"x\", \"y\", 2),\\n    ...         (\"y\", \"s\", 7),\\n    ...         (\"y\", \"v\", 6),\\n    ...     ]\\n    ... )\\n    >>> G.add_node(\"s\", demand=-1)\\n    >>> G.add_node(\"v\", demand=1)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost == nx.shortest_path_length(G, \"s\", \"v\", weight=\"weight\")\\n    True\\n    >>> sorted([(u, v) for u in flowDict for v in flowDict[u] if flowDict[u][v] > 0])\\n    [(\\'s\\', \\'x\\'), (\\'u\\', \\'v\\'), (\\'x\\', \\'u\\')]\\n    >>> nx.shortest_path(G, \"s\", \"v\", weight=\"weight\")\\n    [\\'s\\', \\'x\\', \\'u\\', \\'v\\']\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.network_simplex(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n\\n    References\\n    ----------\\n    .. [1] Z. Kiraly, P. Kovacs.\\n           Efficient implementation of minimum-cost flow algorithms.\\n           Acta Universitatis Sapientiae, Informatica 4(1):67--118. 2012.\\n    .. [2] R. Barr, F. Glover, D. Klingman.\\n           Enhancement of spanning tree labeling procedures for network\\n           optimization.\\n           INFOR 17(1):16--34. 1979.\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXError('graph has no nodes')\n    multigraph = G.is_multigraph()\n    DEAF = _DataEssentialsAndFunctions(G, multigraph, demand=demand, capacity=capacity, weight=weight)\n    inf = float('inf')\n    for (u, d) in zip(DEAF.node_list, DEAF.node_demands):\n        if abs(d) == inf:\n            raise nx.NetworkXError(f'node {u!r} has infinite demand')\n    for (e, w) in zip(DEAF.edge_indices, DEAF.edge_weights):\n        if abs(w) == inf:\n            raise nx.NetworkXError(f'edge {e!r} has infinite weight')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if abs(e[-1].get(weight, 0)) == inf:\n            raise nx.NetworkXError(f'edge {e[:-1]!r} has infinite weight')\n    if sum(DEAF.node_demands) != 0:\n        raise nx.NetworkXUnfeasible('total node demand is not zero')\n    for (e, c) in zip(DEAF.edge_indices, DEAF.edge_capacities):\n        if c < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e!r} has negative capacity')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if e[-1].get(capacity, inf) < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e[:-1]!r} has negative capacity')\n    for (i, d) in enumerate(DEAF.node_demands):\n        if d > 0:\n            DEAF.edge_sources.append(-1)\n            DEAF.edge_targets.append(i)\n        else:\n            DEAF.edge_sources.append(i)\n            DEAF.edge_targets.append(-1)\n    faux_inf = 3 * max(chain([sum((c for c in DEAF.edge_capacities if c < inf)), sum((abs(w) for w in DEAF.edge_weights))], (abs(d) for d in DEAF.node_demands))) or 1\n    n = len(DEAF.node_list)\n    DEAF.edge_weights.extend(repeat(faux_inf, n))\n    DEAF.edge_capacities.extend(repeat(faux_inf, n))\n    DEAF.initialize_spanning_tree(n, faux_inf)\n    for (i, p, q) in DEAF.find_entering_edges():\n        (Wn, We) = DEAF.find_cycle(i, p, q)\n        (j, s, t) = DEAF.find_leaving_edge(Wn, We)\n        DEAF.augment_flow(Wn, We, DEAF.residual_capacity(j, s))\n        if i != j:\n            if DEAF.parent[t] != s:\n                (s, t) = (t, s)\n            if We.index(i) > We.index(j):\n                (p, q) = (q, p)\n            DEAF.remove_edge(s, t)\n            DEAF.make_root(q)\n            DEAF.add_edge(i, p, q)\n            DEAF.update_potentials(i, p, q)\n    if any((DEAF.edge_flow[i] != 0 for i in range(-n, 0))):\n        raise nx.NetworkXUnfeasible('no flow satisfies all node demands')\n    if any((DEAF.edge_flow[i] * 2 >= faux_inf for i in range(DEAF.edge_count))) or any((e[-1].get(capacity, inf) == inf and e[-1].get(weight, 0) < 0 for e in nx.selfloop_edges(G, data=True))):\n        raise nx.NetworkXUnbounded('negative cycle with infinite capacity found')\n    del DEAF.edge_flow[DEAF.edge_count:]\n    flow_cost = sum((w * x for (w, x) in zip(DEAF.edge_weights, DEAF.edge_flow)))\n    flow_dict = {n: {} for n in DEAF.node_list}\n\n    def add_entry(e):\n        \"\"\"Add a flow dict entry.\"\"\"\n        d = flow_dict[e[0]]\n        for k in e[1:-2]:\n            try:\n                d = d[k]\n            except KeyError:\n                t = {}\n                d[k] = t\n                d = t\n        d[e[-2]] = e[-1]\n    DEAF.edge_sources = (DEAF.node_list[s] for s in DEAF.edge_sources)\n    DEAF.edge_targets = (DEAF.node_list[t] for t in DEAF.edge_targets)\n    if not multigraph:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True)\n    else:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_keys, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True, keys=True)\n    for e in edges:\n        if e[0] != e[1]:\n            if e[-1].get(capacity, inf) == 0:\n                add_entry(e[:-1] + (0,))\n        else:\n            w = e[-1].get(weight, 0)\n            if w >= 0:\n                add_entry(e[:-1] + (0,))\n            else:\n                c = e[-1][capacity]\n                flow_cost += w * c\n                add_entry(e[:-1] + (c,))\n    return (flow_cost, flow_dict)",
            "@not_implemented_for('undirected')\n@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef network_simplex(G, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a primal network simplex algorithm that uses the leaving\\n    arc rule to prevent cycling.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph on which a minimum cost flow satisfying all demands is\\n        to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    Returns\\n    -------\\n    flowCost : integer, float\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        Dictionary of dictionaries keyed by nodes such that\\n        flowDict[u][v] is the flow edge (u, v).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed or\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm is not guaranteed to work if edge weights or demands\\n    are floating point numbers (overflows and roundoff errors can\\n    cause problems). As a workaround you can use integer numbers by\\n    multiplying the relevant edge attributes by a convenient\\n    constant factor (eg 100).\\n\\n    See also\\n    --------\\n    cost_of_flow, max_flow_min_cost, min_cost_flow, min_cost_flow_cost\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    The mincost flow algorithm can also be used to solve shortest path\\n    problems. To find the shortest path between two nodes u and v,\\n    give all edges an infinite capacity, give node u a demand of -1 and\\n    node v a demand a 1. Then run the network simplex. The value of a\\n    min cost flow will be the distance between u and v and edges\\n    carrying positive flow will indicate the path.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_weighted_edges_from(\\n    ...     [\\n    ...         (\"s\", \"u\", 10),\\n    ...         (\"s\", \"x\", 5),\\n    ...         (\"u\", \"v\", 1),\\n    ...         (\"u\", \"x\", 2),\\n    ...         (\"v\", \"y\", 1),\\n    ...         (\"x\", \"u\", 3),\\n    ...         (\"x\", \"v\", 5),\\n    ...         (\"x\", \"y\", 2),\\n    ...         (\"y\", \"s\", 7),\\n    ...         (\"y\", \"v\", 6),\\n    ...     ]\\n    ... )\\n    >>> G.add_node(\"s\", demand=-1)\\n    >>> G.add_node(\"v\", demand=1)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost == nx.shortest_path_length(G, \"s\", \"v\", weight=\"weight\")\\n    True\\n    >>> sorted([(u, v) for u in flowDict for v in flowDict[u] if flowDict[u][v] > 0])\\n    [(\\'s\\', \\'x\\'), (\\'u\\', \\'v\\'), (\\'x\\', \\'u\\')]\\n    >>> nx.shortest_path(G, \"s\", \"v\", weight=\"weight\")\\n    [\\'s\\', \\'x\\', \\'u\\', \\'v\\']\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.network_simplex(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n\\n    References\\n    ----------\\n    .. [1] Z. Kiraly, P. Kovacs.\\n           Efficient implementation of minimum-cost flow algorithms.\\n           Acta Universitatis Sapientiae, Informatica 4(1):67--118. 2012.\\n    .. [2] R. Barr, F. Glover, D. Klingman.\\n           Enhancement of spanning tree labeling procedures for network\\n           optimization.\\n           INFOR 17(1):16--34. 1979.\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXError('graph has no nodes')\n    multigraph = G.is_multigraph()\n    DEAF = _DataEssentialsAndFunctions(G, multigraph, demand=demand, capacity=capacity, weight=weight)\n    inf = float('inf')\n    for (u, d) in zip(DEAF.node_list, DEAF.node_demands):\n        if abs(d) == inf:\n            raise nx.NetworkXError(f'node {u!r} has infinite demand')\n    for (e, w) in zip(DEAF.edge_indices, DEAF.edge_weights):\n        if abs(w) == inf:\n            raise nx.NetworkXError(f'edge {e!r} has infinite weight')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if abs(e[-1].get(weight, 0)) == inf:\n            raise nx.NetworkXError(f'edge {e[:-1]!r} has infinite weight')\n    if sum(DEAF.node_demands) != 0:\n        raise nx.NetworkXUnfeasible('total node demand is not zero')\n    for (e, c) in zip(DEAF.edge_indices, DEAF.edge_capacities):\n        if c < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e!r} has negative capacity')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if e[-1].get(capacity, inf) < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e[:-1]!r} has negative capacity')\n    for (i, d) in enumerate(DEAF.node_demands):\n        if d > 0:\n            DEAF.edge_sources.append(-1)\n            DEAF.edge_targets.append(i)\n        else:\n            DEAF.edge_sources.append(i)\n            DEAF.edge_targets.append(-1)\n    faux_inf = 3 * max(chain([sum((c for c in DEAF.edge_capacities if c < inf)), sum((abs(w) for w in DEAF.edge_weights))], (abs(d) for d in DEAF.node_demands))) or 1\n    n = len(DEAF.node_list)\n    DEAF.edge_weights.extend(repeat(faux_inf, n))\n    DEAF.edge_capacities.extend(repeat(faux_inf, n))\n    DEAF.initialize_spanning_tree(n, faux_inf)\n    for (i, p, q) in DEAF.find_entering_edges():\n        (Wn, We) = DEAF.find_cycle(i, p, q)\n        (j, s, t) = DEAF.find_leaving_edge(Wn, We)\n        DEAF.augment_flow(Wn, We, DEAF.residual_capacity(j, s))\n        if i != j:\n            if DEAF.parent[t] != s:\n                (s, t) = (t, s)\n            if We.index(i) > We.index(j):\n                (p, q) = (q, p)\n            DEAF.remove_edge(s, t)\n            DEAF.make_root(q)\n            DEAF.add_edge(i, p, q)\n            DEAF.update_potentials(i, p, q)\n    if any((DEAF.edge_flow[i] != 0 for i in range(-n, 0))):\n        raise nx.NetworkXUnfeasible('no flow satisfies all node demands')\n    if any((DEAF.edge_flow[i] * 2 >= faux_inf for i in range(DEAF.edge_count))) or any((e[-1].get(capacity, inf) == inf and e[-1].get(weight, 0) < 0 for e in nx.selfloop_edges(G, data=True))):\n        raise nx.NetworkXUnbounded('negative cycle with infinite capacity found')\n    del DEAF.edge_flow[DEAF.edge_count:]\n    flow_cost = sum((w * x for (w, x) in zip(DEAF.edge_weights, DEAF.edge_flow)))\n    flow_dict = {n: {} for n in DEAF.node_list}\n\n    def add_entry(e):\n        \"\"\"Add a flow dict entry.\"\"\"\n        d = flow_dict[e[0]]\n        for k in e[1:-2]:\n            try:\n                d = d[k]\n            except KeyError:\n                t = {}\n                d[k] = t\n                d = t\n        d[e[-2]] = e[-1]\n    DEAF.edge_sources = (DEAF.node_list[s] for s in DEAF.edge_sources)\n    DEAF.edge_targets = (DEAF.node_list[t] for t in DEAF.edge_targets)\n    if not multigraph:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True)\n    else:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_keys, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True, keys=True)\n    for e in edges:\n        if e[0] != e[1]:\n            if e[-1].get(capacity, inf) == 0:\n                add_entry(e[:-1] + (0,))\n        else:\n            w = e[-1].get(weight, 0)\n            if w >= 0:\n                add_entry(e[:-1] + (0,))\n            else:\n                c = e[-1][capacity]\n                flow_cost += w * c\n                add_entry(e[:-1] + (c,))\n    return (flow_cost, flow_dict)",
            "@not_implemented_for('undirected')\n@nx._dispatch(node_attrs='demand', edge_attrs={'capacity': float('inf'), 'weight': 0})\ndef network_simplex(G, demand='demand', capacity='capacity', weight='weight'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find a minimum cost flow satisfying all demands in digraph G.\\n\\n    This is a primal network simplex algorithm that uses the leaving\\n    arc rule to prevent cycling.\\n\\n    G is a digraph with edge costs and capacities and in which nodes\\n    have demand, i.e., they want to send or receive some amount of\\n    flow. A negative demand means that the node wants to send flow, a\\n    positive demand means that the node want to receive flow. A flow on\\n    the digraph G satisfies all demand if the net flow into each node\\n    is equal to the demand of that node.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        DiGraph on which a minimum cost flow satisfying all demands is\\n        to be found.\\n\\n    demand : string\\n        Nodes of the graph G are expected to have an attribute demand\\n        that indicates how much flow a node wants to send (negative\\n        demand) or receive (positive demand). Note that the sum of the\\n        demands should be 0 otherwise the problem in not feasible. If\\n        this attribute is not present, a node is considered to have 0\\n        demand. Default value: \\'demand\\'.\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    weight : string\\n        Edges of the graph G are expected to have an attribute weight\\n        that indicates the cost incurred by sending one unit of flow on\\n        that edge. If not present, the weight is considered to be 0.\\n        Default value: \\'weight\\'.\\n\\n    Returns\\n    -------\\n    flowCost : integer, float\\n        Cost of a minimum cost flow satisfying all demands.\\n\\n    flowDict : dictionary\\n        Dictionary of dictionaries keyed by nodes such that\\n        flowDict[u][v] is the flow edge (u, v).\\n\\n    Raises\\n    ------\\n    NetworkXError\\n        This exception is raised if the input graph is not directed or\\n        not connected.\\n\\n    NetworkXUnfeasible\\n        This exception is raised in the following situations:\\n\\n            * The sum of the demands is not zero. Then, there is no\\n              flow satisfying all demands.\\n            * There is no flow satisfying all demand.\\n\\n    NetworkXUnbounded\\n        This exception is raised if the digraph G has a cycle of\\n        negative cost and infinite capacity. Then, the cost of a flow\\n        satisfying all demands is unbounded below.\\n\\n    Notes\\n    -----\\n    This algorithm is not guaranteed to work if edge weights or demands\\n    are floating point numbers (overflows and roundoff errors can\\n    cause problems). As a workaround you can use integer numbers by\\n    multiplying the relevant edge attributes by a convenient\\n    constant factor (eg 100).\\n\\n    See also\\n    --------\\n    cost_of_flow, max_flow_min_cost, min_cost_flow, min_cost_flow_cost\\n\\n    Examples\\n    --------\\n    A simple example of a min cost flow problem.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"a\", demand=-5)\\n    >>> G.add_node(\"d\", demand=5)\\n    >>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\\n    >>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\\n    >>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\\n    >>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost\\n    24\\n    >>> flowDict\\n    {\\'a\\': {\\'b\\': 4, \\'c\\': 1}, \\'d\\': {}, \\'b\\': {\\'d\\': 4}, \\'c\\': {\\'d\\': 1}}\\n\\n    The mincost flow algorithm can also be used to solve shortest path\\n    problems. To find the shortest path between two nodes u and v,\\n    give all edges an infinite capacity, give node u a demand of -1 and\\n    node v a demand a 1. Then run the network simplex. The value of a\\n    min cost flow will be the distance between u and v and edges\\n    carrying positive flow will indicate the path.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_weighted_edges_from(\\n    ...     [\\n    ...         (\"s\", \"u\", 10),\\n    ...         (\"s\", \"x\", 5),\\n    ...         (\"u\", \"v\", 1),\\n    ...         (\"u\", \"x\", 2),\\n    ...         (\"v\", \"y\", 1),\\n    ...         (\"x\", \"u\", 3),\\n    ...         (\"x\", \"v\", 5),\\n    ...         (\"x\", \"y\", 2),\\n    ...         (\"y\", \"s\", 7),\\n    ...         (\"y\", \"v\", 6),\\n    ...     ]\\n    ... )\\n    >>> G.add_node(\"s\", demand=-1)\\n    >>> G.add_node(\"v\", demand=1)\\n    >>> flowCost, flowDict = nx.network_simplex(G)\\n    >>> flowCost == nx.shortest_path_length(G, \"s\", \"v\", weight=\"weight\")\\n    True\\n    >>> sorted([(u, v) for u in flowDict for v in flowDict[u] if flowDict[u][v] > 0])\\n    [(\\'s\\', \\'x\\'), (\\'u\\', \\'v\\'), (\\'x\\', \\'u\\')]\\n    >>> nx.shortest_path(G, \"s\", \"v\", weight=\"weight\")\\n    [\\'s\\', \\'x\\', \\'u\\', \\'v\\']\\n\\n    It is possible to change the name of the attributes used for the\\n    algorithm.\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_node(\"p\", spam=-4)\\n    >>> G.add_node(\"q\", spam=2)\\n    >>> G.add_node(\"a\", spam=-2)\\n    >>> G.add_node(\"d\", spam=-1)\\n    >>> G.add_node(\"t\", spam=2)\\n    >>> G.add_node(\"w\", spam=3)\\n    >>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\\n    >>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\\n    >>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\\n    >>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\\n    >>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\\n    >>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\\n    >>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\\n    >>> flowCost, flowDict = nx.network_simplex(\\n    ...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\\n    ... )\\n    >>> flowCost\\n    37\\n    >>> flowDict\\n    {\\'p\\': {\\'q\\': 2, \\'a\\': 2}, \\'q\\': {\\'d\\': 1}, \\'a\\': {\\'t\\': 4}, \\'d\\': {\\'w\\': 2}, \\'t\\': {\\'q\\': 1, \\'w\\': 1}, \\'w\\': {}}\\n\\n    References\\n    ----------\\n    .. [1] Z. Kiraly, P. Kovacs.\\n           Efficient implementation of minimum-cost flow algorithms.\\n           Acta Universitatis Sapientiae, Informatica 4(1):67--118. 2012.\\n    .. [2] R. Barr, F. Glover, D. Klingman.\\n           Enhancement of spanning tree labeling procedures for network\\n           optimization.\\n           INFOR 17(1):16--34. 1979.\\n    '\n    if len(G) == 0:\n        raise nx.NetworkXError('graph has no nodes')\n    multigraph = G.is_multigraph()\n    DEAF = _DataEssentialsAndFunctions(G, multigraph, demand=demand, capacity=capacity, weight=weight)\n    inf = float('inf')\n    for (u, d) in zip(DEAF.node_list, DEAF.node_demands):\n        if abs(d) == inf:\n            raise nx.NetworkXError(f'node {u!r} has infinite demand')\n    for (e, w) in zip(DEAF.edge_indices, DEAF.edge_weights):\n        if abs(w) == inf:\n            raise nx.NetworkXError(f'edge {e!r} has infinite weight')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if abs(e[-1].get(weight, 0)) == inf:\n            raise nx.NetworkXError(f'edge {e[:-1]!r} has infinite weight')\n    if sum(DEAF.node_demands) != 0:\n        raise nx.NetworkXUnfeasible('total node demand is not zero')\n    for (e, c) in zip(DEAF.edge_indices, DEAF.edge_capacities):\n        if c < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e!r} has negative capacity')\n    if not multigraph:\n        edges = nx.selfloop_edges(G, data=True)\n    else:\n        edges = nx.selfloop_edges(G, data=True, keys=True)\n    for e in edges:\n        if e[-1].get(capacity, inf) < 0:\n            raise nx.NetworkXUnfeasible(f'edge {e[:-1]!r} has negative capacity')\n    for (i, d) in enumerate(DEAF.node_demands):\n        if d > 0:\n            DEAF.edge_sources.append(-1)\n            DEAF.edge_targets.append(i)\n        else:\n            DEAF.edge_sources.append(i)\n            DEAF.edge_targets.append(-1)\n    faux_inf = 3 * max(chain([sum((c for c in DEAF.edge_capacities if c < inf)), sum((abs(w) for w in DEAF.edge_weights))], (abs(d) for d in DEAF.node_demands))) or 1\n    n = len(DEAF.node_list)\n    DEAF.edge_weights.extend(repeat(faux_inf, n))\n    DEAF.edge_capacities.extend(repeat(faux_inf, n))\n    DEAF.initialize_spanning_tree(n, faux_inf)\n    for (i, p, q) in DEAF.find_entering_edges():\n        (Wn, We) = DEAF.find_cycle(i, p, q)\n        (j, s, t) = DEAF.find_leaving_edge(Wn, We)\n        DEAF.augment_flow(Wn, We, DEAF.residual_capacity(j, s))\n        if i != j:\n            if DEAF.parent[t] != s:\n                (s, t) = (t, s)\n            if We.index(i) > We.index(j):\n                (p, q) = (q, p)\n            DEAF.remove_edge(s, t)\n            DEAF.make_root(q)\n            DEAF.add_edge(i, p, q)\n            DEAF.update_potentials(i, p, q)\n    if any((DEAF.edge_flow[i] != 0 for i in range(-n, 0))):\n        raise nx.NetworkXUnfeasible('no flow satisfies all node demands')\n    if any((DEAF.edge_flow[i] * 2 >= faux_inf for i in range(DEAF.edge_count))) or any((e[-1].get(capacity, inf) == inf and e[-1].get(weight, 0) < 0 for e in nx.selfloop_edges(G, data=True))):\n        raise nx.NetworkXUnbounded('negative cycle with infinite capacity found')\n    del DEAF.edge_flow[DEAF.edge_count:]\n    flow_cost = sum((w * x for (w, x) in zip(DEAF.edge_weights, DEAF.edge_flow)))\n    flow_dict = {n: {} for n in DEAF.node_list}\n\n    def add_entry(e):\n        \"\"\"Add a flow dict entry.\"\"\"\n        d = flow_dict[e[0]]\n        for k in e[1:-2]:\n            try:\n                d = d[k]\n            except KeyError:\n                t = {}\n                d[k] = t\n                d = t\n        d[e[-2]] = e[-1]\n    DEAF.edge_sources = (DEAF.node_list[s] for s in DEAF.edge_sources)\n    DEAF.edge_targets = (DEAF.node_list[t] for t in DEAF.edge_targets)\n    if not multigraph:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True)\n    else:\n        for e in zip(DEAF.edge_sources, DEAF.edge_targets, DEAF.edge_keys, DEAF.edge_flow):\n            add_entry(e)\n        edges = G.edges(data=True, keys=True)\n    for e in edges:\n        if e[0] != e[1]:\n            if e[-1].get(capacity, inf) == 0:\n                add_entry(e[:-1] + (0,))\n        else:\n            w = e[-1].get(weight, 0)\n            if w >= 0:\n                add_entry(e[:-1] + (0,))\n            else:\n                c = e[-1][capacity]\n                flow_cost += w * c\n                add_entry(e[:-1] + (c,))\n    return (flow_cost, flow_dict)"
        ]
    }
]