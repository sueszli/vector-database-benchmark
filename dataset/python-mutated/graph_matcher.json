[
    {
        "func_name": "_get_output_nodes",
        "original": "def _get_output_nodes(g: Graph) -> List[Node]:\n    return [n for n in g.nodes if n.op == 'output']",
        "mutated": [
            "def _get_output_nodes(g: Graph) -> List[Node]:\n    if False:\n        i = 10\n    return [n for n in g.nodes if n.op == 'output']",
            "def _get_output_nodes(g: Graph) -> List[Node]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [n for n in g.nodes if n.op == 'output']",
            "def _get_output_nodes(g: Graph) -> List[Node]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [n for n in g.nodes if n.op == 'output']",
            "def _get_output_nodes(g: Graph) -> List[Node]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [n for n in g.nodes if n.op == 'output']",
            "def _get_output_nodes(g: Graph) -> List[Node]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [n for n in g.nodes if n.op == 'output']"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, gm: GraphModule, non_matchable_functions: Set[NSNodeTargetType], non_matchable_modules: Set[NSNodeTargetType], non_matchable_methods: Set[NSNodeTargetType]):\n    self.gm: GraphModule = gm\n    self.non_matchable_functions: Set[NSNodeTargetType] = non_matchable_functions\n    self.non_matchable_modules: Set[NSNodeTargetType] = non_matchable_modules\n    self.non_matchable_methods: Set[NSNodeTargetType] = non_matchable_methods\n    self.seen_nodes: Set[Node] = set()\n    self.stack: List[Node] = []\n    for start_node in _get_output_nodes(self.gm.graph):\n        self.stack.append(start_node)",
        "mutated": [
            "def __init__(self, gm: GraphModule, non_matchable_functions: Set[NSNodeTargetType], non_matchable_modules: Set[NSNodeTargetType], non_matchable_methods: Set[NSNodeTargetType]):\n    if False:\n        i = 10\n    self.gm: GraphModule = gm\n    self.non_matchable_functions: Set[NSNodeTargetType] = non_matchable_functions\n    self.non_matchable_modules: Set[NSNodeTargetType] = non_matchable_modules\n    self.non_matchable_methods: Set[NSNodeTargetType] = non_matchable_methods\n    self.seen_nodes: Set[Node] = set()\n    self.stack: List[Node] = []\n    for start_node in _get_output_nodes(self.gm.graph):\n        self.stack.append(start_node)",
            "def __init__(self, gm: GraphModule, non_matchable_functions: Set[NSNodeTargetType], non_matchable_modules: Set[NSNodeTargetType], non_matchable_methods: Set[NSNodeTargetType]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.gm: GraphModule = gm\n    self.non_matchable_functions: Set[NSNodeTargetType] = non_matchable_functions\n    self.non_matchable_modules: Set[NSNodeTargetType] = non_matchable_modules\n    self.non_matchable_methods: Set[NSNodeTargetType] = non_matchable_methods\n    self.seen_nodes: Set[Node] = set()\n    self.stack: List[Node] = []\n    for start_node in _get_output_nodes(self.gm.graph):\n        self.stack.append(start_node)",
            "def __init__(self, gm: GraphModule, non_matchable_functions: Set[NSNodeTargetType], non_matchable_modules: Set[NSNodeTargetType], non_matchable_methods: Set[NSNodeTargetType]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.gm: GraphModule = gm\n    self.non_matchable_functions: Set[NSNodeTargetType] = non_matchable_functions\n    self.non_matchable_modules: Set[NSNodeTargetType] = non_matchable_modules\n    self.non_matchable_methods: Set[NSNodeTargetType] = non_matchable_methods\n    self.seen_nodes: Set[Node] = set()\n    self.stack: List[Node] = []\n    for start_node in _get_output_nodes(self.gm.graph):\n        self.stack.append(start_node)",
            "def __init__(self, gm: GraphModule, non_matchable_functions: Set[NSNodeTargetType], non_matchable_modules: Set[NSNodeTargetType], non_matchable_methods: Set[NSNodeTargetType]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.gm: GraphModule = gm\n    self.non_matchable_functions: Set[NSNodeTargetType] = non_matchable_functions\n    self.non_matchable_modules: Set[NSNodeTargetType] = non_matchable_modules\n    self.non_matchable_methods: Set[NSNodeTargetType] = non_matchable_methods\n    self.seen_nodes: Set[Node] = set()\n    self.stack: List[Node] = []\n    for start_node in _get_output_nodes(self.gm.graph):\n        self.stack.append(start_node)",
            "def __init__(self, gm: GraphModule, non_matchable_functions: Set[NSNodeTargetType], non_matchable_modules: Set[NSNodeTargetType], non_matchable_methods: Set[NSNodeTargetType]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.gm: GraphModule = gm\n    self.non_matchable_functions: Set[NSNodeTargetType] = non_matchable_functions\n    self.non_matchable_modules: Set[NSNodeTargetType] = non_matchable_modules\n    self.non_matchable_methods: Set[NSNodeTargetType] = non_matchable_methods\n    self.seen_nodes: Set[Node] = set()\n    self.stack: List[Node] = []\n    for start_node in _get_output_nodes(self.gm.graph):\n        self.stack.append(start_node)"
        ]
    },
    {
        "func_name": "__iter__",
        "original": "def __iter__(self):\n    return self",
        "mutated": [
            "def __iter__(self):\n    if False:\n        i = 10\n    return self",
            "def __iter__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self",
            "def __iter__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self",
            "def __iter__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self",
            "def __iter__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self"
        ]
    },
    {
        "func_name": "__next__",
        "original": "def __next__(self) -> NSSubgraph:\n    \"\"\"\n        Returns the next matchable subgraph.\n        \"\"\"\n    while len(self.stack) > 0:\n        cur_end_node = self.stack.pop()\n        if cur_end_node in self.seen_nodes:\n            continue\n        cur_start_node = cur_end_node\n        cur_base_op_node = cur_end_node\n        for (_reverse_fusion_ops, base_op_idx) in get_reversed_fusions():\n            is_match = end_node_matches_reversed_fusion(cur_end_node, _reverse_fusion_ops, self.gm, self.seen_nodes)\n            if is_match:\n                for rev_fusion_idx in range(len(_reverse_fusion_ops) - 1):\n                    self.seen_nodes.add(cur_start_node)\n                    cur_start_node = cur_start_node.args[0]\n                    rev_base_op_idx = len(_reverse_fusion_ops) - 2 - base_op_idx\n                    if rev_fusion_idx == rev_base_op_idx:\n                        cur_base_op_node = cur_start_node\n                break\n        self.seen_nodes.add(cur_start_node)\n        for arg in cur_start_node.all_input_nodes:\n            self._recursively_add_node_arg_to_stack(arg)\n        if not self._is_matchable(cur_base_op_node):\n            continue\n        if cur_end_node.op == 'call_module' and cur_start_node is cur_end_node:\n            maybe_obs = getattr_from_fqn(self.gm, cur_end_node.target)\n            if isinstance(maybe_obs, (ObserverBase, FakeQuantizeBase)):\n                continue\n        return NSSubgraph(start_node=cur_start_node, end_node=cur_end_node, base_op_node=cur_base_op_node)\n    raise StopIteration",
        "mutated": [
            "def __next__(self) -> NSSubgraph:\n    if False:\n        i = 10\n    '\\n        Returns the next matchable subgraph.\\n        '\n    while len(self.stack) > 0:\n        cur_end_node = self.stack.pop()\n        if cur_end_node in self.seen_nodes:\n            continue\n        cur_start_node = cur_end_node\n        cur_base_op_node = cur_end_node\n        for (_reverse_fusion_ops, base_op_idx) in get_reversed_fusions():\n            is_match = end_node_matches_reversed_fusion(cur_end_node, _reverse_fusion_ops, self.gm, self.seen_nodes)\n            if is_match:\n                for rev_fusion_idx in range(len(_reverse_fusion_ops) - 1):\n                    self.seen_nodes.add(cur_start_node)\n                    cur_start_node = cur_start_node.args[0]\n                    rev_base_op_idx = len(_reverse_fusion_ops) - 2 - base_op_idx\n                    if rev_fusion_idx == rev_base_op_idx:\n                        cur_base_op_node = cur_start_node\n                break\n        self.seen_nodes.add(cur_start_node)\n        for arg in cur_start_node.all_input_nodes:\n            self._recursively_add_node_arg_to_stack(arg)\n        if not self._is_matchable(cur_base_op_node):\n            continue\n        if cur_end_node.op == 'call_module' and cur_start_node is cur_end_node:\n            maybe_obs = getattr_from_fqn(self.gm, cur_end_node.target)\n            if isinstance(maybe_obs, (ObserverBase, FakeQuantizeBase)):\n                continue\n        return NSSubgraph(start_node=cur_start_node, end_node=cur_end_node, base_op_node=cur_base_op_node)\n    raise StopIteration",
            "def __next__(self) -> NSSubgraph:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns the next matchable subgraph.\\n        '\n    while len(self.stack) > 0:\n        cur_end_node = self.stack.pop()\n        if cur_end_node in self.seen_nodes:\n            continue\n        cur_start_node = cur_end_node\n        cur_base_op_node = cur_end_node\n        for (_reverse_fusion_ops, base_op_idx) in get_reversed_fusions():\n            is_match = end_node_matches_reversed_fusion(cur_end_node, _reverse_fusion_ops, self.gm, self.seen_nodes)\n            if is_match:\n                for rev_fusion_idx in range(len(_reverse_fusion_ops) - 1):\n                    self.seen_nodes.add(cur_start_node)\n                    cur_start_node = cur_start_node.args[0]\n                    rev_base_op_idx = len(_reverse_fusion_ops) - 2 - base_op_idx\n                    if rev_fusion_idx == rev_base_op_idx:\n                        cur_base_op_node = cur_start_node\n                break\n        self.seen_nodes.add(cur_start_node)\n        for arg in cur_start_node.all_input_nodes:\n            self._recursively_add_node_arg_to_stack(arg)\n        if not self._is_matchable(cur_base_op_node):\n            continue\n        if cur_end_node.op == 'call_module' and cur_start_node is cur_end_node:\n            maybe_obs = getattr_from_fqn(self.gm, cur_end_node.target)\n            if isinstance(maybe_obs, (ObserverBase, FakeQuantizeBase)):\n                continue\n        return NSSubgraph(start_node=cur_start_node, end_node=cur_end_node, base_op_node=cur_base_op_node)\n    raise StopIteration",
            "def __next__(self) -> NSSubgraph:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns the next matchable subgraph.\\n        '\n    while len(self.stack) > 0:\n        cur_end_node = self.stack.pop()\n        if cur_end_node in self.seen_nodes:\n            continue\n        cur_start_node = cur_end_node\n        cur_base_op_node = cur_end_node\n        for (_reverse_fusion_ops, base_op_idx) in get_reversed_fusions():\n            is_match = end_node_matches_reversed_fusion(cur_end_node, _reverse_fusion_ops, self.gm, self.seen_nodes)\n            if is_match:\n                for rev_fusion_idx in range(len(_reverse_fusion_ops) - 1):\n                    self.seen_nodes.add(cur_start_node)\n                    cur_start_node = cur_start_node.args[0]\n                    rev_base_op_idx = len(_reverse_fusion_ops) - 2 - base_op_idx\n                    if rev_fusion_idx == rev_base_op_idx:\n                        cur_base_op_node = cur_start_node\n                break\n        self.seen_nodes.add(cur_start_node)\n        for arg in cur_start_node.all_input_nodes:\n            self._recursively_add_node_arg_to_stack(arg)\n        if not self._is_matchable(cur_base_op_node):\n            continue\n        if cur_end_node.op == 'call_module' and cur_start_node is cur_end_node:\n            maybe_obs = getattr_from_fqn(self.gm, cur_end_node.target)\n            if isinstance(maybe_obs, (ObserverBase, FakeQuantizeBase)):\n                continue\n        return NSSubgraph(start_node=cur_start_node, end_node=cur_end_node, base_op_node=cur_base_op_node)\n    raise StopIteration",
            "def __next__(self) -> NSSubgraph:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns the next matchable subgraph.\\n        '\n    while len(self.stack) > 0:\n        cur_end_node = self.stack.pop()\n        if cur_end_node in self.seen_nodes:\n            continue\n        cur_start_node = cur_end_node\n        cur_base_op_node = cur_end_node\n        for (_reverse_fusion_ops, base_op_idx) in get_reversed_fusions():\n            is_match = end_node_matches_reversed_fusion(cur_end_node, _reverse_fusion_ops, self.gm, self.seen_nodes)\n            if is_match:\n                for rev_fusion_idx in range(len(_reverse_fusion_ops) - 1):\n                    self.seen_nodes.add(cur_start_node)\n                    cur_start_node = cur_start_node.args[0]\n                    rev_base_op_idx = len(_reverse_fusion_ops) - 2 - base_op_idx\n                    if rev_fusion_idx == rev_base_op_idx:\n                        cur_base_op_node = cur_start_node\n                break\n        self.seen_nodes.add(cur_start_node)\n        for arg in cur_start_node.all_input_nodes:\n            self._recursively_add_node_arg_to_stack(arg)\n        if not self._is_matchable(cur_base_op_node):\n            continue\n        if cur_end_node.op == 'call_module' and cur_start_node is cur_end_node:\n            maybe_obs = getattr_from_fqn(self.gm, cur_end_node.target)\n            if isinstance(maybe_obs, (ObserverBase, FakeQuantizeBase)):\n                continue\n        return NSSubgraph(start_node=cur_start_node, end_node=cur_end_node, base_op_node=cur_base_op_node)\n    raise StopIteration",
            "def __next__(self) -> NSSubgraph:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns the next matchable subgraph.\\n        '\n    while len(self.stack) > 0:\n        cur_end_node = self.stack.pop()\n        if cur_end_node in self.seen_nodes:\n            continue\n        cur_start_node = cur_end_node\n        cur_base_op_node = cur_end_node\n        for (_reverse_fusion_ops, base_op_idx) in get_reversed_fusions():\n            is_match = end_node_matches_reversed_fusion(cur_end_node, _reverse_fusion_ops, self.gm, self.seen_nodes)\n            if is_match:\n                for rev_fusion_idx in range(len(_reverse_fusion_ops) - 1):\n                    self.seen_nodes.add(cur_start_node)\n                    cur_start_node = cur_start_node.args[0]\n                    rev_base_op_idx = len(_reverse_fusion_ops) - 2 - base_op_idx\n                    if rev_fusion_idx == rev_base_op_idx:\n                        cur_base_op_node = cur_start_node\n                break\n        self.seen_nodes.add(cur_start_node)\n        for arg in cur_start_node.all_input_nodes:\n            self._recursively_add_node_arg_to_stack(arg)\n        if not self._is_matchable(cur_base_op_node):\n            continue\n        if cur_end_node.op == 'call_module' and cur_start_node is cur_end_node:\n            maybe_obs = getattr_from_fqn(self.gm, cur_end_node.target)\n            if isinstance(maybe_obs, (ObserverBase, FakeQuantizeBase)):\n                continue\n        return NSSubgraph(start_node=cur_start_node, end_node=cur_end_node, base_op_node=cur_base_op_node)\n    raise StopIteration"
        ]
    },
    {
        "func_name": "_recursively_add_node_arg_to_stack",
        "original": "def _recursively_add_node_arg_to_stack(self, arg: Any) -> None:\n    \"\"\"\n        Adds all of the nodes in this arg to the stack, properly navigating\n        through list, dicts and tuples.\n        \"\"\"\n    if isinstance(arg, Node):\n        self.stack.append(arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_list) or type(arg) is tuple:\n        for inner_arg in arg:\n            self._recursively_add_node_arg_to_stack(inner_arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_dict):\n        for value in arg.values():\n            self._recursively_add_node_arg_to_stack(value)",
        "mutated": [
            "def _recursively_add_node_arg_to_stack(self, arg: Any) -> None:\n    if False:\n        i = 10\n    '\\n        Adds all of the nodes in this arg to the stack, properly navigating\\n        through list, dicts and tuples.\\n        '\n    if isinstance(arg, Node):\n        self.stack.append(arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_list) or type(arg) is tuple:\n        for inner_arg in arg:\n            self._recursively_add_node_arg_to_stack(inner_arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_dict):\n        for value in arg.values():\n            self._recursively_add_node_arg_to_stack(value)",
            "def _recursively_add_node_arg_to_stack(self, arg: Any) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Adds all of the nodes in this arg to the stack, properly navigating\\n        through list, dicts and tuples.\\n        '\n    if isinstance(arg, Node):\n        self.stack.append(arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_list) or type(arg) is tuple:\n        for inner_arg in arg:\n            self._recursively_add_node_arg_to_stack(inner_arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_dict):\n        for value in arg.values():\n            self._recursively_add_node_arg_to_stack(value)",
            "def _recursively_add_node_arg_to_stack(self, arg: Any) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Adds all of the nodes in this arg to the stack, properly navigating\\n        through list, dicts and tuples.\\n        '\n    if isinstance(arg, Node):\n        self.stack.append(arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_list) or type(arg) is tuple:\n        for inner_arg in arg:\n            self._recursively_add_node_arg_to_stack(inner_arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_dict):\n        for value in arg.values():\n            self._recursively_add_node_arg_to_stack(value)",
            "def _recursively_add_node_arg_to_stack(self, arg: Any) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Adds all of the nodes in this arg to the stack, properly navigating\\n        through list, dicts and tuples.\\n        '\n    if isinstance(arg, Node):\n        self.stack.append(arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_list) or type(arg) is tuple:\n        for inner_arg in arg:\n            self._recursively_add_node_arg_to_stack(inner_arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_dict):\n        for value in arg.values():\n            self._recursively_add_node_arg_to_stack(value)",
            "def _recursively_add_node_arg_to_stack(self, arg: Any) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Adds all of the nodes in this arg to the stack, properly navigating\\n        through list, dicts and tuples.\\n        '\n    if isinstance(arg, Node):\n        self.stack.append(arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_list) or type(arg) is tuple:\n        for inner_arg in arg:\n            self._recursively_add_node_arg_to_stack(inner_arg)\n    elif isinstance(arg, torch.fx.immutable_collections.immutable_dict):\n        for value in arg.values():\n            self._recursively_add_node_arg_to_stack(value)"
        ]
    },
    {
        "func_name": "_is_matchable",
        "original": "def _is_matchable(self, node: Node) -> bool:\n    if node.op == 'call_function':\n        return node.target not in self.non_matchable_functions\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        target_mod = getattr_from_fqn(self.gm, node.target)\n        return not any((isinstance(target_mod, t) for t in self.non_matchable_modules))\n    elif node.op == 'call_method':\n        return node.target not in self.non_matchable_methods\n    else:\n        return False",
        "mutated": [
            "def _is_matchable(self, node: Node) -> bool:\n    if False:\n        i = 10\n    if node.op == 'call_function':\n        return node.target not in self.non_matchable_functions\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        target_mod = getattr_from_fqn(self.gm, node.target)\n        return not any((isinstance(target_mod, t) for t in self.non_matchable_modules))\n    elif node.op == 'call_method':\n        return node.target not in self.non_matchable_methods\n    else:\n        return False",
            "def _is_matchable(self, node: Node) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if node.op == 'call_function':\n        return node.target not in self.non_matchable_functions\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        target_mod = getattr_from_fqn(self.gm, node.target)\n        return not any((isinstance(target_mod, t) for t in self.non_matchable_modules))\n    elif node.op == 'call_method':\n        return node.target not in self.non_matchable_methods\n    else:\n        return False",
            "def _is_matchable(self, node: Node) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if node.op == 'call_function':\n        return node.target not in self.non_matchable_functions\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        target_mod = getattr_from_fqn(self.gm, node.target)\n        return not any((isinstance(target_mod, t) for t in self.non_matchable_modules))\n    elif node.op == 'call_method':\n        return node.target not in self.non_matchable_methods\n    else:\n        return False",
            "def _is_matchable(self, node: Node) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if node.op == 'call_function':\n        return node.target not in self.non_matchable_functions\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        target_mod = getattr_from_fqn(self.gm, node.target)\n        return not any((isinstance(target_mod, t) for t in self.non_matchable_modules))\n    elif node.op == 'call_method':\n        return node.target not in self.non_matchable_methods\n    else:\n        return False",
            "def _is_matchable(self, node: Node) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if node.op == 'call_function':\n        return node.target not in self.non_matchable_functions\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        target_mod = getattr_from_fqn(self.gm, node.target)\n        return not any((isinstance(target_mod, t) for t in self.non_matchable_modules))\n    elif node.op == 'call_method':\n        return node.target not in self.non_matchable_methods\n    else:\n        return False"
        ]
    },
    {
        "func_name": "_get_subgraph_relationship_type",
        "original": "def _get_subgraph_relationship_type(subgraph_a: NSSubgraph, subgraph_b: NSSubgraph, gm_a: GraphModule, gm_b: GraphModule, type_a_related_to_b: Set[Tuple[NSNodeTargetType, NSNodeTargetType]]) -> SubgraphTypeRelationship:\n    node_a = subgraph_a.base_op_node\n    node_b = subgraph_b.base_op_node\n    if node_a.op != node_b.op:\n        if not (node_a.op in ('call_function', 'call_method') and node_b.op in ('call_function', 'call_method')):\n            return SubgraphTypeRelationship.NOT_RELATED\n    if node_a.op in ('call_function', 'call_method'):\n        key = (node_a.target, node_b.target)\n        if key not in type_a_related_to_b:\n            if node_a.target == node_b.target:\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        if node_a.target == node_b.target:\n            node_a_has_prev = subgraph_a.base_op_node == subgraph_a.start_node\n            node_b_has_prev = subgraph_b.base_op_node == subgraph_b.start_node\n            if node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and node_b_has_prev:\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.EQUAL\n            else:\n                return SubgraphTypeRelationship.EQUAL\n        if key in type_a_related_to_b:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n        else:\n            return SubgraphTypeRelationship.NOT_RELATED\n    elif node_a.op == 'call_module':\n        assert subgraph_a.base_op_node == subgraph_a.start_node and subgraph_b.base_op_node == subgraph_b.start_node, 'Matching call_module patterns where base_op_node != start_node is not supported yet'\n        assert isinstance(node_a.target, str)\n        mod_a = getattr_from_fqn(gm_a, node_a.target)\n        assert isinstance(node_b.target, str)\n        mod_b = getattr_from_fqn(gm_b, node_b.target)\n        key = (type(mod_a), type(mod_b))\n        if key not in type_a_related_to_b:\n            if type(mod_a) == type(mod_b):\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        elif type(mod_a) == type(mod_b):\n            return SubgraphTypeRelationship.EQUAL\n        else:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n    return SubgraphTypeRelationship.NOT_RELATED",
        "mutated": [
            "def _get_subgraph_relationship_type(subgraph_a: NSSubgraph, subgraph_b: NSSubgraph, gm_a: GraphModule, gm_b: GraphModule, type_a_related_to_b: Set[Tuple[NSNodeTargetType, NSNodeTargetType]]) -> SubgraphTypeRelationship:\n    if False:\n        i = 10\n    node_a = subgraph_a.base_op_node\n    node_b = subgraph_b.base_op_node\n    if node_a.op != node_b.op:\n        if not (node_a.op in ('call_function', 'call_method') and node_b.op in ('call_function', 'call_method')):\n            return SubgraphTypeRelationship.NOT_RELATED\n    if node_a.op in ('call_function', 'call_method'):\n        key = (node_a.target, node_b.target)\n        if key not in type_a_related_to_b:\n            if node_a.target == node_b.target:\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        if node_a.target == node_b.target:\n            node_a_has_prev = subgraph_a.base_op_node == subgraph_a.start_node\n            node_b_has_prev = subgraph_b.base_op_node == subgraph_b.start_node\n            if node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and node_b_has_prev:\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.EQUAL\n            else:\n                return SubgraphTypeRelationship.EQUAL\n        if key in type_a_related_to_b:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n        else:\n            return SubgraphTypeRelationship.NOT_RELATED\n    elif node_a.op == 'call_module':\n        assert subgraph_a.base_op_node == subgraph_a.start_node and subgraph_b.base_op_node == subgraph_b.start_node, 'Matching call_module patterns where base_op_node != start_node is not supported yet'\n        assert isinstance(node_a.target, str)\n        mod_a = getattr_from_fqn(gm_a, node_a.target)\n        assert isinstance(node_b.target, str)\n        mod_b = getattr_from_fqn(gm_b, node_b.target)\n        key = (type(mod_a), type(mod_b))\n        if key not in type_a_related_to_b:\n            if type(mod_a) == type(mod_b):\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        elif type(mod_a) == type(mod_b):\n            return SubgraphTypeRelationship.EQUAL\n        else:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n    return SubgraphTypeRelationship.NOT_RELATED",
            "def _get_subgraph_relationship_type(subgraph_a: NSSubgraph, subgraph_b: NSSubgraph, gm_a: GraphModule, gm_b: GraphModule, type_a_related_to_b: Set[Tuple[NSNodeTargetType, NSNodeTargetType]]) -> SubgraphTypeRelationship:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    node_a = subgraph_a.base_op_node\n    node_b = subgraph_b.base_op_node\n    if node_a.op != node_b.op:\n        if not (node_a.op in ('call_function', 'call_method') and node_b.op in ('call_function', 'call_method')):\n            return SubgraphTypeRelationship.NOT_RELATED\n    if node_a.op in ('call_function', 'call_method'):\n        key = (node_a.target, node_b.target)\n        if key not in type_a_related_to_b:\n            if node_a.target == node_b.target:\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        if node_a.target == node_b.target:\n            node_a_has_prev = subgraph_a.base_op_node == subgraph_a.start_node\n            node_b_has_prev = subgraph_b.base_op_node == subgraph_b.start_node\n            if node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and node_b_has_prev:\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.EQUAL\n            else:\n                return SubgraphTypeRelationship.EQUAL\n        if key in type_a_related_to_b:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n        else:\n            return SubgraphTypeRelationship.NOT_RELATED\n    elif node_a.op == 'call_module':\n        assert subgraph_a.base_op_node == subgraph_a.start_node and subgraph_b.base_op_node == subgraph_b.start_node, 'Matching call_module patterns where base_op_node != start_node is not supported yet'\n        assert isinstance(node_a.target, str)\n        mod_a = getattr_from_fqn(gm_a, node_a.target)\n        assert isinstance(node_b.target, str)\n        mod_b = getattr_from_fqn(gm_b, node_b.target)\n        key = (type(mod_a), type(mod_b))\n        if key not in type_a_related_to_b:\n            if type(mod_a) == type(mod_b):\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        elif type(mod_a) == type(mod_b):\n            return SubgraphTypeRelationship.EQUAL\n        else:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n    return SubgraphTypeRelationship.NOT_RELATED",
            "def _get_subgraph_relationship_type(subgraph_a: NSSubgraph, subgraph_b: NSSubgraph, gm_a: GraphModule, gm_b: GraphModule, type_a_related_to_b: Set[Tuple[NSNodeTargetType, NSNodeTargetType]]) -> SubgraphTypeRelationship:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    node_a = subgraph_a.base_op_node\n    node_b = subgraph_b.base_op_node\n    if node_a.op != node_b.op:\n        if not (node_a.op in ('call_function', 'call_method') and node_b.op in ('call_function', 'call_method')):\n            return SubgraphTypeRelationship.NOT_RELATED\n    if node_a.op in ('call_function', 'call_method'):\n        key = (node_a.target, node_b.target)\n        if key not in type_a_related_to_b:\n            if node_a.target == node_b.target:\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        if node_a.target == node_b.target:\n            node_a_has_prev = subgraph_a.base_op_node == subgraph_a.start_node\n            node_b_has_prev = subgraph_b.base_op_node == subgraph_b.start_node\n            if node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and node_b_has_prev:\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.EQUAL\n            else:\n                return SubgraphTypeRelationship.EQUAL\n        if key in type_a_related_to_b:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n        else:\n            return SubgraphTypeRelationship.NOT_RELATED\n    elif node_a.op == 'call_module':\n        assert subgraph_a.base_op_node == subgraph_a.start_node and subgraph_b.base_op_node == subgraph_b.start_node, 'Matching call_module patterns where base_op_node != start_node is not supported yet'\n        assert isinstance(node_a.target, str)\n        mod_a = getattr_from_fqn(gm_a, node_a.target)\n        assert isinstance(node_b.target, str)\n        mod_b = getattr_from_fqn(gm_b, node_b.target)\n        key = (type(mod_a), type(mod_b))\n        if key not in type_a_related_to_b:\n            if type(mod_a) == type(mod_b):\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        elif type(mod_a) == type(mod_b):\n            return SubgraphTypeRelationship.EQUAL\n        else:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n    return SubgraphTypeRelationship.NOT_RELATED",
            "def _get_subgraph_relationship_type(subgraph_a: NSSubgraph, subgraph_b: NSSubgraph, gm_a: GraphModule, gm_b: GraphModule, type_a_related_to_b: Set[Tuple[NSNodeTargetType, NSNodeTargetType]]) -> SubgraphTypeRelationship:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    node_a = subgraph_a.base_op_node\n    node_b = subgraph_b.base_op_node\n    if node_a.op != node_b.op:\n        if not (node_a.op in ('call_function', 'call_method') and node_b.op in ('call_function', 'call_method')):\n            return SubgraphTypeRelationship.NOT_RELATED\n    if node_a.op in ('call_function', 'call_method'):\n        key = (node_a.target, node_b.target)\n        if key not in type_a_related_to_b:\n            if node_a.target == node_b.target:\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        if node_a.target == node_b.target:\n            node_a_has_prev = subgraph_a.base_op_node == subgraph_a.start_node\n            node_b_has_prev = subgraph_b.base_op_node == subgraph_b.start_node\n            if node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and node_b_has_prev:\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.EQUAL\n            else:\n                return SubgraphTypeRelationship.EQUAL\n        if key in type_a_related_to_b:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n        else:\n            return SubgraphTypeRelationship.NOT_RELATED\n    elif node_a.op == 'call_module':\n        assert subgraph_a.base_op_node == subgraph_a.start_node and subgraph_b.base_op_node == subgraph_b.start_node, 'Matching call_module patterns where base_op_node != start_node is not supported yet'\n        assert isinstance(node_a.target, str)\n        mod_a = getattr_from_fqn(gm_a, node_a.target)\n        assert isinstance(node_b.target, str)\n        mod_b = getattr_from_fqn(gm_b, node_b.target)\n        key = (type(mod_a), type(mod_b))\n        if key not in type_a_related_to_b:\n            if type(mod_a) == type(mod_b):\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        elif type(mod_a) == type(mod_b):\n            return SubgraphTypeRelationship.EQUAL\n        else:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n    return SubgraphTypeRelationship.NOT_RELATED",
            "def _get_subgraph_relationship_type(subgraph_a: NSSubgraph, subgraph_b: NSSubgraph, gm_a: GraphModule, gm_b: GraphModule, type_a_related_to_b: Set[Tuple[NSNodeTargetType, NSNodeTargetType]]) -> SubgraphTypeRelationship:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    node_a = subgraph_a.base_op_node\n    node_b = subgraph_b.base_op_node\n    if node_a.op != node_b.op:\n        if not (node_a.op in ('call_function', 'call_method') and node_b.op in ('call_function', 'call_method')):\n            return SubgraphTypeRelationship.NOT_RELATED\n    if node_a.op in ('call_function', 'call_method'):\n        key = (node_a.target, node_b.target)\n        if key not in type_a_related_to_b:\n            if node_a.target == node_b.target:\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        if node_a.target == node_b.target:\n            node_a_has_prev = subgraph_a.base_op_node == subgraph_a.start_node\n            node_b_has_prev = subgraph_b.base_op_node == subgraph_b.start_node\n            if node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and node_b_has_prev:\n                return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n            elif not node_a_has_prev and (not node_b_has_prev):\n                return SubgraphTypeRelationship.EQUAL\n            else:\n                return SubgraphTypeRelationship.EQUAL\n        if key in type_a_related_to_b:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n        else:\n            return SubgraphTypeRelationship.NOT_RELATED\n    elif node_a.op == 'call_module':\n        assert subgraph_a.base_op_node == subgraph_a.start_node and subgraph_b.base_op_node == subgraph_b.start_node, 'Matching call_module patterns where base_op_node != start_node is not supported yet'\n        assert isinstance(node_a.target, str)\n        mod_a = getattr_from_fqn(gm_a, node_a.target)\n        assert isinstance(node_b.target, str)\n        mod_b = getattr_from_fqn(gm_b, node_b.target)\n        key = (type(mod_a), type(mod_b))\n        if key not in type_a_related_to_b:\n            if type(mod_a) == type(mod_b):\n                return SubgraphTypeRelationship.EQUAL_BUT_UKNOWN\n            else:\n                return SubgraphTypeRelationship.NOT_RELATED\n        elif type(mod_a) == type(mod_b):\n            return SubgraphTypeRelationship.EQUAL\n        else:\n            return SubgraphTypeRelationship.RELATED_BUT_NOT_EQUAL\n    return SubgraphTypeRelationship.NOT_RELATED"
        ]
    },
    {
        "func_name": "_get_name_for_subgraph",
        "original": "def _get_name_for_subgraph(subgraph_a: NSSubgraph, gm_a: GraphModule, base_name_to_sets_of_related_ops: Dict[str, Set[NSNodeTargetType]], existing_names: Set[str]) -> str:\n    \"\"\"\n    Returns a unique name for a subgraph. This name is based on two things:\n    1. the name of the set containing the underlying type of the base op in the\n       subgraph (i.e. 'torch.nn.functional.linear' if this is related to a linear op)\n    2. the number of previous subgraphs with related underlying type of the base op\n\n    For example, in the graph\n\n    linear0 -> relu0 -> linear1 -> relu1\n\n    The subgraphs are (linear0, relu0) and (linear1, relu1).  If we iterate\n    from the output node backwards, the name given to (linear1, relu1) will be\n    `base_op_torch.nn.functional.linear_0`, and the name given to (linear0, relu0)\n    will be `base_op_torch.nn.functional.linear_1`.\n\n    Why are we not just using the node name? Answer: because of two requirements:\n    A. fusions must be supported\n    B. some Numeric Suite APIs can be called without having all of the models in memory\n\n    For example, let's say we need to match nodes of\n\n    (1) ... -> linear0 -> relu0 -> ...\n\n    And\n\n    (2) ... -> linear_relu0 -> ...\n\n    Without being able to inspect them together. With the current naming scheme, if\n    we iterate through both of these graphs in the same order, and assuming the rest\n    of the graphs match, both of these subgraphs will get the same name without\n    (1) and (2) knowing anything about each other.\n    \"\"\"\n    target_type = _get_node_target_type(subgraph_a.base_op_node, gm_a)\n    target_base_type = None\n    for (base_name, sets_of_related_ops) in base_name_to_sets_of_related_ops.items():\n        if target_type in sets_of_related_ops:\n            target_base_type = base_name\n    target_base_name = 'base_op_' + str(target_base_type)\n    counter = 0\n    proposed_name = target_base_name + '_' + str(counter)\n    while proposed_name in existing_names:\n        counter += 1\n        proposed_name = target_base_name + '_' + str(counter)\n    existing_names.add(proposed_name)\n    return proposed_name",
        "mutated": [
            "def _get_name_for_subgraph(subgraph_a: NSSubgraph, gm_a: GraphModule, base_name_to_sets_of_related_ops: Dict[str, Set[NSNodeTargetType]], existing_names: Set[str]) -> str:\n    if False:\n        i = 10\n    \"\\n    Returns a unique name for a subgraph. This name is based on two things:\\n    1. the name of the set containing the underlying type of the base op in the\\n       subgraph (i.e. 'torch.nn.functional.linear' if this is related to a linear op)\\n    2. the number of previous subgraphs with related underlying type of the base op\\n\\n    For example, in the graph\\n\\n    linear0 -> relu0 -> linear1 -> relu1\\n\\n    The subgraphs are (linear0, relu0) and (linear1, relu1).  If we iterate\\n    from the output node backwards, the name given to (linear1, relu1) will be\\n    `base_op_torch.nn.functional.linear_0`, and the name given to (linear0, relu0)\\n    will be `base_op_torch.nn.functional.linear_1`.\\n\\n    Why are we not just using the node name? Answer: because of two requirements:\\n    A. fusions must be supported\\n    B. some Numeric Suite APIs can be called without having all of the models in memory\\n\\n    For example, let's say we need to match nodes of\\n\\n    (1) ... -> linear0 -> relu0 -> ...\\n\\n    And\\n\\n    (2) ... -> linear_relu0 -> ...\\n\\n    Without being able to inspect them together. With the current naming scheme, if\\n    we iterate through both of these graphs in the same order, and assuming the rest\\n    of the graphs match, both of these subgraphs will get the same name without\\n    (1) and (2) knowing anything about each other.\\n    \"\n    target_type = _get_node_target_type(subgraph_a.base_op_node, gm_a)\n    target_base_type = None\n    for (base_name, sets_of_related_ops) in base_name_to_sets_of_related_ops.items():\n        if target_type in sets_of_related_ops:\n            target_base_type = base_name\n    target_base_name = 'base_op_' + str(target_base_type)\n    counter = 0\n    proposed_name = target_base_name + '_' + str(counter)\n    while proposed_name in existing_names:\n        counter += 1\n        proposed_name = target_base_name + '_' + str(counter)\n    existing_names.add(proposed_name)\n    return proposed_name",
            "def _get_name_for_subgraph(subgraph_a: NSSubgraph, gm_a: GraphModule, base_name_to_sets_of_related_ops: Dict[str, Set[NSNodeTargetType]], existing_names: Set[str]) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns a unique name for a subgraph. This name is based on two things:\\n    1. the name of the set containing the underlying type of the base op in the\\n       subgraph (i.e. 'torch.nn.functional.linear' if this is related to a linear op)\\n    2. the number of previous subgraphs with related underlying type of the base op\\n\\n    For example, in the graph\\n\\n    linear0 -> relu0 -> linear1 -> relu1\\n\\n    The subgraphs are (linear0, relu0) and (linear1, relu1).  If we iterate\\n    from the output node backwards, the name given to (linear1, relu1) will be\\n    `base_op_torch.nn.functional.linear_0`, and the name given to (linear0, relu0)\\n    will be `base_op_torch.nn.functional.linear_1`.\\n\\n    Why are we not just using the node name? Answer: because of two requirements:\\n    A. fusions must be supported\\n    B. some Numeric Suite APIs can be called without having all of the models in memory\\n\\n    For example, let's say we need to match nodes of\\n\\n    (1) ... -> linear0 -> relu0 -> ...\\n\\n    And\\n\\n    (2) ... -> linear_relu0 -> ...\\n\\n    Without being able to inspect them together. With the current naming scheme, if\\n    we iterate through both of these graphs in the same order, and assuming the rest\\n    of the graphs match, both of these subgraphs will get the same name without\\n    (1) and (2) knowing anything about each other.\\n    \"\n    target_type = _get_node_target_type(subgraph_a.base_op_node, gm_a)\n    target_base_type = None\n    for (base_name, sets_of_related_ops) in base_name_to_sets_of_related_ops.items():\n        if target_type in sets_of_related_ops:\n            target_base_type = base_name\n    target_base_name = 'base_op_' + str(target_base_type)\n    counter = 0\n    proposed_name = target_base_name + '_' + str(counter)\n    while proposed_name in existing_names:\n        counter += 1\n        proposed_name = target_base_name + '_' + str(counter)\n    existing_names.add(proposed_name)\n    return proposed_name",
            "def _get_name_for_subgraph(subgraph_a: NSSubgraph, gm_a: GraphModule, base_name_to_sets_of_related_ops: Dict[str, Set[NSNodeTargetType]], existing_names: Set[str]) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns a unique name for a subgraph. This name is based on two things:\\n    1. the name of the set containing the underlying type of the base op in the\\n       subgraph (i.e. 'torch.nn.functional.linear' if this is related to a linear op)\\n    2. the number of previous subgraphs with related underlying type of the base op\\n\\n    For example, in the graph\\n\\n    linear0 -> relu0 -> linear1 -> relu1\\n\\n    The subgraphs are (linear0, relu0) and (linear1, relu1).  If we iterate\\n    from the output node backwards, the name given to (linear1, relu1) will be\\n    `base_op_torch.nn.functional.linear_0`, and the name given to (linear0, relu0)\\n    will be `base_op_torch.nn.functional.linear_1`.\\n\\n    Why are we not just using the node name? Answer: because of two requirements:\\n    A. fusions must be supported\\n    B. some Numeric Suite APIs can be called without having all of the models in memory\\n\\n    For example, let's say we need to match nodes of\\n\\n    (1) ... -> linear0 -> relu0 -> ...\\n\\n    And\\n\\n    (2) ... -> linear_relu0 -> ...\\n\\n    Without being able to inspect them together. With the current naming scheme, if\\n    we iterate through both of these graphs in the same order, and assuming the rest\\n    of the graphs match, both of these subgraphs will get the same name without\\n    (1) and (2) knowing anything about each other.\\n    \"\n    target_type = _get_node_target_type(subgraph_a.base_op_node, gm_a)\n    target_base_type = None\n    for (base_name, sets_of_related_ops) in base_name_to_sets_of_related_ops.items():\n        if target_type in sets_of_related_ops:\n            target_base_type = base_name\n    target_base_name = 'base_op_' + str(target_base_type)\n    counter = 0\n    proposed_name = target_base_name + '_' + str(counter)\n    while proposed_name in existing_names:\n        counter += 1\n        proposed_name = target_base_name + '_' + str(counter)\n    existing_names.add(proposed_name)\n    return proposed_name",
            "def _get_name_for_subgraph(subgraph_a: NSSubgraph, gm_a: GraphModule, base_name_to_sets_of_related_ops: Dict[str, Set[NSNodeTargetType]], existing_names: Set[str]) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns a unique name for a subgraph. This name is based on two things:\\n    1. the name of the set containing the underlying type of the base op in the\\n       subgraph (i.e. 'torch.nn.functional.linear' if this is related to a linear op)\\n    2. the number of previous subgraphs with related underlying type of the base op\\n\\n    For example, in the graph\\n\\n    linear0 -> relu0 -> linear1 -> relu1\\n\\n    The subgraphs are (linear0, relu0) and (linear1, relu1).  If we iterate\\n    from the output node backwards, the name given to (linear1, relu1) will be\\n    `base_op_torch.nn.functional.linear_0`, and the name given to (linear0, relu0)\\n    will be `base_op_torch.nn.functional.linear_1`.\\n\\n    Why are we not just using the node name? Answer: because of two requirements:\\n    A. fusions must be supported\\n    B. some Numeric Suite APIs can be called without having all of the models in memory\\n\\n    For example, let's say we need to match nodes of\\n\\n    (1) ... -> linear0 -> relu0 -> ...\\n\\n    And\\n\\n    (2) ... -> linear_relu0 -> ...\\n\\n    Without being able to inspect them together. With the current naming scheme, if\\n    we iterate through both of these graphs in the same order, and assuming the rest\\n    of the graphs match, both of these subgraphs will get the same name without\\n    (1) and (2) knowing anything about each other.\\n    \"\n    target_type = _get_node_target_type(subgraph_a.base_op_node, gm_a)\n    target_base_type = None\n    for (base_name, sets_of_related_ops) in base_name_to_sets_of_related_ops.items():\n        if target_type in sets_of_related_ops:\n            target_base_type = base_name\n    target_base_name = 'base_op_' + str(target_base_type)\n    counter = 0\n    proposed_name = target_base_name + '_' + str(counter)\n    while proposed_name in existing_names:\n        counter += 1\n        proposed_name = target_base_name + '_' + str(counter)\n    existing_names.add(proposed_name)\n    return proposed_name",
            "def _get_name_for_subgraph(subgraph_a: NSSubgraph, gm_a: GraphModule, base_name_to_sets_of_related_ops: Dict[str, Set[NSNodeTargetType]], existing_names: Set[str]) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns a unique name for a subgraph. This name is based on two things:\\n    1. the name of the set containing the underlying type of the base op in the\\n       subgraph (i.e. 'torch.nn.functional.linear' if this is related to a linear op)\\n    2. the number of previous subgraphs with related underlying type of the base op\\n\\n    For example, in the graph\\n\\n    linear0 -> relu0 -> linear1 -> relu1\\n\\n    The subgraphs are (linear0, relu0) and (linear1, relu1).  If we iterate\\n    from the output node backwards, the name given to (linear1, relu1) will be\\n    `base_op_torch.nn.functional.linear_0`, and the name given to (linear0, relu0)\\n    will be `base_op_torch.nn.functional.linear_1`.\\n\\n    Why are we not just using the node name? Answer: because of two requirements:\\n    A. fusions must be supported\\n    B. some Numeric Suite APIs can be called without having all of the models in memory\\n\\n    For example, let's say we need to match nodes of\\n\\n    (1) ... -> linear0 -> relu0 -> ...\\n\\n    And\\n\\n    (2) ... -> linear_relu0 -> ...\\n\\n    Without being able to inspect them together. With the current naming scheme, if\\n    we iterate through both of these graphs in the same order, and assuming the rest\\n    of the graphs match, both of these subgraphs will get the same name without\\n    (1) and (2) knowing anything about each other.\\n    \"\n    target_type = _get_node_target_type(subgraph_a.base_op_node, gm_a)\n    target_base_type = None\n    for (base_name, sets_of_related_ops) in base_name_to_sets_of_related_ops.items():\n        if target_type in sets_of_related_ops:\n            target_base_type = base_name\n    target_base_name = 'base_op_' + str(target_base_type)\n    counter = 0\n    proposed_name = target_base_name + '_' + str(counter)\n    while proposed_name in existing_names:\n        counter += 1\n        proposed_name = target_base_name + '_' + str(counter)\n    existing_names.add(proposed_name)\n    return proposed_name"
        ]
    },
    {
        "func_name": "_get_node_target_type",
        "original": "def _get_node_target_type(node: Node, gm: GraphModule) -> Optional[NSNodeTargetType]:\n    if node.op in ('call_function', 'call_method'):\n        return node.target\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        mod = getattr_from_fqn(gm, node.target)\n        return type(mod)\n    return None",
        "mutated": [
            "def _get_node_target_type(node: Node, gm: GraphModule) -> Optional[NSNodeTargetType]:\n    if False:\n        i = 10\n    if node.op in ('call_function', 'call_method'):\n        return node.target\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        mod = getattr_from_fqn(gm, node.target)\n        return type(mod)\n    return None",
            "def _get_node_target_type(node: Node, gm: GraphModule) -> Optional[NSNodeTargetType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if node.op in ('call_function', 'call_method'):\n        return node.target\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        mod = getattr_from_fqn(gm, node.target)\n        return type(mod)\n    return None",
            "def _get_node_target_type(node: Node, gm: GraphModule) -> Optional[NSNodeTargetType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if node.op in ('call_function', 'call_method'):\n        return node.target\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        mod = getattr_from_fqn(gm, node.target)\n        return type(mod)\n    return None",
            "def _get_node_target_type(node: Node, gm: GraphModule) -> Optional[NSNodeTargetType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if node.op in ('call_function', 'call_method'):\n        return node.target\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        mod = getattr_from_fqn(gm, node.target)\n        return type(mod)\n    return None",
            "def _get_node_target_type(node: Node, gm: GraphModule) -> Optional[NSNodeTargetType]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if node.op in ('call_function', 'call_method'):\n        return node.target\n    elif node.op == 'call_module':\n        assert isinstance(node.target, str)\n        mod = getattr_from_fqn(gm, node.target)\n        return type(mod)\n    return None"
        ]
    },
    {
        "func_name": "get_matching_subgraph_pairs",
        "original": "def get_matching_subgraph_pairs(gm_a: GraphModule, gm_b: GraphModule, base_name_to_sets_of_related_ops: Optional[Dict[str, Set[NSNodeTargetType]]]=None, unmatchable_types_map: Optional[Dict[str, Set[NSNodeTargetType]]]=None) -> Dict[str, Tuple[NSSubgraph, NSSubgraph]]:\n    \"\"\"\n    Matches matchable subgraphs of graph_a to graph_b.\n\n    For a node, \"matchable\" is defined as a node which is not an observer,\n    fake_quants, quant or dequant.\n\n    A subgraph can contain one or more nodes.  A subgraph is matchable if\n    at least one node inside of it is matchable.  Currently, all nodes in\n    a subgraph must be matchable (because we assume no observers will be\n    inserted in the middle of a fusion).\n\n    A subgraph is defined by (start_node, end_node).  We assume that only\n    start_node and end_node are linked with the surrounding graph, all other\n    nodes in a subgraph are self-contained.\n\n    A pair of nodes is \"related\" if both nodes represent the same mathematical\n    operation across different quantization flavors. For example,\n    `F.linear` and `torch.ops.quantized.linear` are related, and\n    `F.linear` and `torch.nn.Conv` are not related.\n\n    For each matchable pair of nodes node_a and node_b, they will match\n    if node_a and node_b are related.\n\n    For graphs A and B, they will match iff:\n    1. the number of matchable subgraphs in A and B is equivalent\n    2. when iterating through the matchable subgraphs of A and B in the same order, each\n       corresponding pair of base nodes is related.\n\n    This enables us to find the corresponding subgraphs between\n    graphs of related models.  For example, if we had two graphs such as:\n\n    graph_a: x0 -> conv_0 (type: nn.Conv2d) -> obs_0 -> x1\n             w  -/\n             b  -/\n\n    graph_b: x0 -> quant_0 -> qconv_0 (type: nnq.Conv2d) -> dequant_0 -> x1\n           packed_params_0 -/\n\n    This function will return the following result:\n    {\n        'conv_0': (  # the name of the node in graph_b\n          (conv_0, conv_0),  # (start_node_a, end_node_a)\n          (qconv_0, qconv_0),  # (start_node_b, end_node_b)\n        ),\n    }\n\n    Or, if we have a fusion pattern,\n\n    graph_a: x0 -> linear_0 -> relu_0 -> obs_0 -> x1\n             w  -/\n             b  -/\n\n    graph_b: x0 -> quant_0 -> linear_relu_0 -> dequant_0 -> x1\n           packed_params_0 -/\n\n    This function will return the following result:\n    {\n        'linear_relu_0': (  # the name of the node in graph_b\n          (linear_0, relu_0),  # (start_node_a, end_node_a)\n          (linear_relu_0, linear_relu_0),  # (start_node_b, end_node_b)\n        ),\n    }\n    \"\"\"\n    if unmatchable_types_map is None:\n        unmatchable_types_map = get_unmatchable_types_map()\n    non_matchable_functions = unmatchable_types_map['funs_unmatchable']\n    non_matchable_modules = unmatchable_types_map['mods_unmatchable']\n    non_matchable_methods = unmatchable_types_map['meths_unmatchable']\n    graph_a_iterator = _NSGraphMatchableSubgraphsIterator(gm_a, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    graph_b_iterator = _NSGraphMatchableSubgraphsIterator(gm_b, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    results = collections.OrderedDict()\n    if base_name_to_sets_of_related_ops is None:\n        base_name_to_sets_of_related_ops = get_base_name_to_sets_of_related_ops()\n    type_a_related_to_b = get_type_a_related_to_b(base_name_to_sets_of_related_ops)\n    existing_names_a: Set[str] = set()\n    existing_names_b: Set[str] = set()\n    while True:\n        (cur_subgraph_a, cur_subgraph_b) = (None, None)\n        try:\n            cur_subgraph_a = next(graph_a_iterator)\n        except StopIteration:\n            pass\n        try:\n            cur_subgraph_b = next(graph_b_iterator)\n        except StopIteration:\n            pass\n        (type_start_a, type_start_b) = (None, None)\n        if cur_subgraph_a is not None:\n            type_start_a = _get_node_target_type(cur_subgraph_a.start_node, gm_a)\n        if cur_subgraph_b is not None:\n            type_start_b = _get_node_target_type(cur_subgraph_b.start_node, gm_b)\n        if cur_subgraph_a is not None and cur_subgraph_b is not None:\n            subgraph_relationship = _get_subgraph_relationship_type(cur_subgraph_a, cur_subgraph_b, gm_a, gm_b, type_a_related_to_b)\n            if subgraph_relationship == SubgraphTypeRelationship.NOT_RELATED:\n                msg = f'\\nThe subgraphs\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b})\\nare not related. Please ensure that the two models you pass in have the same number\\nof subgraphs, and each pair of subgraphs is related to each other.'\n                raise GraphMatchingException(msg)\n            elif subgraph_relationship == SubgraphTypeRelationship.EQUAL_BUT_UKNOWN:\n                continue\n            key_name_a = _get_name_for_subgraph(cur_subgraph_a, gm_a, base_name_to_sets_of_related_ops, existing_names_a)\n            key_name_b = _get_name_for_subgraph(cur_subgraph_b, gm_b, base_name_to_sets_of_related_ops, existing_names_b)\n            assert key_name_a == key_name_b, f'Subgraph names {key_name_a} and {key_name_b} do not match'\n            results[key_name_a] = (cur_subgraph_a, cur_subgraph_b)\n            continue\n        elif cur_subgraph_a is None and cur_subgraph_b is None:\n            break\n        else:\n            msg = f'\\nAttempting to match\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b}),\\none of which is empty. Please ensure that the two models you pass in have the same number\\nof subgraphs.'\n            raise GraphMatchingException(msg)\n    results = collections.OrderedDict(reversed(list(results.items())))\n    return results",
        "mutated": [
            "def get_matching_subgraph_pairs(gm_a: GraphModule, gm_b: GraphModule, base_name_to_sets_of_related_ops: Optional[Dict[str, Set[NSNodeTargetType]]]=None, unmatchable_types_map: Optional[Dict[str, Set[NSNodeTargetType]]]=None) -> Dict[str, Tuple[NSSubgraph, NSSubgraph]]:\n    if False:\n        i = 10\n    '\\n    Matches matchable subgraphs of graph_a to graph_b.\\n\\n    For a node, \"matchable\" is defined as a node which is not an observer,\\n    fake_quants, quant or dequant.\\n\\n    A subgraph can contain one or more nodes.  A subgraph is matchable if\\n    at least one node inside of it is matchable.  Currently, all nodes in\\n    a subgraph must be matchable (because we assume no observers will be\\n    inserted in the middle of a fusion).\\n\\n    A subgraph is defined by (start_node, end_node).  We assume that only\\n    start_node and end_node are linked with the surrounding graph, all other\\n    nodes in a subgraph are self-contained.\\n\\n    A pair of nodes is \"related\" if both nodes represent the same mathematical\\n    operation across different quantization flavors. For example,\\n    `F.linear` and `torch.ops.quantized.linear` are related, and\\n    `F.linear` and `torch.nn.Conv` are not related.\\n\\n    For each matchable pair of nodes node_a and node_b, they will match\\n    if node_a and node_b are related.\\n\\n    For graphs A and B, they will match iff:\\n    1. the number of matchable subgraphs in A and B is equivalent\\n    2. when iterating through the matchable subgraphs of A and B in the same order, each\\n       corresponding pair of base nodes is related.\\n\\n    This enables us to find the corresponding subgraphs between\\n    graphs of related models.  For example, if we had two graphs such as:\\n\\n    graph_a: x0 -> conv_0 (type: nn.Conv2d) -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> qconv_0 (type: nnq.Conv2d) -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'conv_0\\': (  # the name of the node in graph_b\\n          (conv_0, conv_0),  # (start_node_a, end_node_a)\\n          (qconv_0, qconv_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n\\n    Or, if we have a fusion pattern,\\n\\n    graph_a: x0 -> linear_0 -> relu_0 -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> linear_relu_0 -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'linear_relu_0\\': (  # the name of the node in graph_b\\n          (linear_0, relu_0),  # (start_node_a, end_node_a)\\n          (linear_relu_0, linear_relu_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n    '\n    if unmatchable_types_map is None:\n        unmatchable_types_map = get_unmatchable_types_map()\n    non_matchable_functions = unmatchable_types_map['funs_unmatchable']\n    non_matchable_modules = unmatchable_types_map['mods_unmatchable']\n    non_matchable_methods = unmatchable_types_map['meths_unmatchable']\n    graph_a_iterator = _NSGraphMatchableSubgraphsIterator(gm_a, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    graph_b_iterator = _NSGraphMatchableSubgraphsIterator(gm_b, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    results = collections.OrderedDict()\n    if base_name_to_sets_of_related_ops is None:\n        base_name_to_sets_of_related_ops = get_base_name_to_sets_of_related_ops()\n    type_a_related_to_b = get_type_a_related_to_b(base_name_to_sets_of_related_ops)\n    existing_names_a: Set[str] = set()\n    existing_names_b: Set[str] = set()\n    while True:\n        (cur_subgraph_a, cur_subgraph_b) = (None, None)\n        try:\n            cur_subgraph_a = next(graph_a_iterator)\n        except StopIteration:\n            pass\n        try:\n            cur_subgraph_b = next(graph_b_iterator)\n        except StopIteration:\n            pass\n        (type_start_a, type_start_b) = (None, None)\n        if cur_subgraph_a is not None:\n            type_start_a = _get_node_target_type(cur_subgraph_a.start_node, gm_a)\n        if cur_subgraph_b is not None:\n            type_start_b = _get_node_target_type(cur_subgraph_b.start_node, gm_b)\n        if cur_subgraph_a is not None and cur_subgraph_b is not None:\n            subgraph_relationship = _get_subgraph_relationship_type(cur_subgraph_a, cur_subgraph_b, gm_a, gm_b, type_a_related_to_b)\n            if subgraph_relationship == SubgraphTypeRelationship.NOT_RELATED:\n                msg = f'\\nThe subgraphs\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b})\\nare not related. Please ensure that the two models you pass in have the same number\\nof subgraphs, and each pair of subgraphs is related to each other.'\n                raise GraphMatchingException(msg)\n            elif subgraph_relationship == SubgraphTypeRelationship.EQUAL_BUT_UKNOWN:\n                continue\n            key_name_a = _get_name_for_subgraph(cur_subgraph_a, gm_a, base_name_to_sets_of_related_ops, existing_names_a)\n            key_name_b = _get_name_for_subgraph(cur_subgraph_b, gm_b, base_name_to_sets_of_related_ops, existing_names_b)\n            assert key_name_a == key_name_b, f'Subgraph names {key_name_a} and {key_name_b} do not match'\n            results[key_name_a] = (cur_subgraph_a, cur_subgraph_b)\n            continue\n        elif cur_subgraph_a is None and cur_subgraph_b is None:\n            break\n        else:\n            msg = f'\\nAttempting to match\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b}),\\none of which is empty. Please ensure that the two models you pass in have the same number\\nof subgraphs.'\n            raise GraphMatchingException(msg)\n    results = collections.OrderedDict(reversed(list(results.items())))\n    return results",
            "def get_matching_subgraph_pairs(gm_a: GraphModule, gm_b: GraphModule, base_name_to_sets_of_related_ops: Optional[Dict[str, Set[NSNodeTargetType]]]=None, unmatchable_types_map: Optional[Dict[str, Set[NSNodeTargetType]]]=None) -> Dict[str, Tuple[NSSubgraph, NSSubgraph]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Matches matchable subgraphs of graph_a to graph_b.\\n\\n    For a node, \"matchable\" is defined as a node which is not an observer,\\n    fake_quants, quant or dequant.\\n\\n    A subgraph can contain one or more nodes.  A subgraph is matchable if\\n    at least one node inside of it is matchable.  Currently, all nodes in\\n    a subgraph must be matchable (because we assume no observers will be\\n    inserted in the middle of a fusion).\\n\\n    A subgraph is defined by (start_node, end_node).  We assume that only\\n    start_node and end_node are linked with the surrounding graph, all other\\n    nodes in a subgraph are self-contained.\\n\\n    A pair of nodes is \"related\" if both nodes represent the same mathematical\\n    operation across different quantization flavors. For example,\\n    `F.linear` and `torch.ops.quantized.linear` are related, and\\n    `F.linear` and `torch.nn.Conv` are not related.\\n\\n    For each matchable pair of nodes node_a and node_b, they will match\\n    if node_a and node_b are related.\\n\\n    For graphs A and B, they will match iff:\\n    1. the number of matchable subgraphs in A and B is equivalent\\n    2. when iterating through the matchable subgraphs of A and B in the same order, each\\n       corresponding pair of base nodes is related.\\n\\n    This enables us to find the corresponding subgraphs between\\n    graphs of related models.  For example, if we had two graphs such as:\\n\\n    graph_a: x0 -> conv_0 (type: nn.Conv2d) -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> qconv_0 (type: nnq.Conv2d) -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'conv_0\\': (  # the name of the node in graph_b\\n          (conv_0, conv_0),  # (start_node_a, end_node_a)\\n          (qconv_0, qconv_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n\\n    Or, if we have a fusion pattern,\\n\\n    graph_a: x0 -> linear_0 -> relu_0 -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> linear_relu_0 -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'linear_relu_0\\': (  # the name of the node in graph_b\\n          (linear_0, relu_0),  # (start_node_a, end_node_a)\\n          (linear_relu_0, linear_relu_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n    '\n    if unmatchable_types_map is None:\n        unmatchable_types_map = get_unmatchable_types_map()\n    non_matchable_functions = unmatchable_types_map['funs_unmatchable']\n    non_matchable_modules = unmatchable_types_map['mods_unmatchable']\n    non_matchable_methods = unmatchable_types_map['meths_unmatchable']\n    graph_a_iterator = _NSGraphMatchableSubgraphsIterator(gm_a, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    graph_b_iterator = _NSGraphMatchableSubgraphsIterator(gm_b, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    results = collections.OrderedDict()\n    if base_name_to_sets_of_related_ops is None:\n        base_name_to_sets_of_related_ops = get_base_name_to_sets_of_related_ops()\n    type_a_related_to_b = get_type_a_related_to_b(base_name_to_sets_of_related_ops)\n    existing_names_a: Set[str] = set()\n    existing_names_b: Set[str] = set()\n    while True:\n        (cur_subgraph_a, cur_subgraph_b) = (None, None)\n        try:\n            cur_subgraph_a = next(graph_a_iterator)\n        except StopIteration:\n            pass\n        try:\n            cur_subgraph_b = next(graph_b_iterator)\n        except StopIteration:\n            pass\n        (type_start_a, type_start_b) = (None, None)\n        if cur_subgraph_a is not None:\n            type_start_a = _get_node_target_type(cur_subgraph_a.start_node, gm_a)\n        if cur_subgraph_b is not None:\n            type_start_b = _get_node_target_type(cur_subgraph_b.start_node, gm_b)\n        if cur_subgraph_a is not None and cur_subgraph_b is not None:\n            subgraph_relationship = _get_subgraph_relationship_type(cur_subgraph_a, cur_subgraph_b, gm_a, gm_b, type_a_related_to_b)\n            if subgraph_relationship == SubgraphTypeRelationship.NOT_RELATED:\n                msg = f'\\nThe subgraphs\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b})\\nare not related. Please ensure that the two models you pass in have the same number\\nof subgraphs, and each pair of subgraphs is related to each other.'\n                raise GraphMatchingException(msg)\n            elif subgraph_relationship == SubgraphTypeRelationship.EQUAL_BUT_UKNOWN:\n                continue\n            key_name_a = _get_name_for_subgraph(cur_subgraph_a, gm_a, base_name_to_sets_of_related_ops, existing_names_a)\n            key_name_b = _get_name_for_subgraph(cur_subgraph_b, gm_b, base_name_to_sets_of_related_ops, existing_names_b)\n            assert key_name_a == key_name_b, f'Subgraph names {key_name_a} and {key_name_b} do not match'\n            results[key_name_a] = (cur_subgraph_a, cur_subgraph_b)\n            continue\n        elif cur_subgraph_a is None and cur_subgraph_b is None:\n            break\n        else:\n            msg = f'\\nAttempting to match\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b}),\\none of which is empty. Please ensure that the two models you pass in have the same number\\nof subgraphs.'\n            raise GraphMatchingException(msg)\n    results = collections.OrderedDict(reversed(list(results.items())))\n    return results",
            "def get_matching_subgraph_pairs(gm_a: GraphModule, gm_b: GraphModule, base_name_to_sets_of_related_ops: Optional[Dict[str, Set[NSNodeTargetType]]]=None, unmatchable_types_map: Optional[Dict[str, Set[NSNodeTargetType]]]=None) -> Dict[str, Tuple[NSSubgraph, NSSubgraph]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Matches matchable subgraphs of graph_a to graph_b.\\n\\n    For a node, \"matchable\" is defined as a node which is not an observer,\\n    fake_quants, quant or dequant.\\n\\n    A subgraph can contain one or more nodes.  A subgraph is matchable if\\n    at least one node inside of it is matchable.  Currently, all nodes in\\n    a subgraph must be matchable (because we assume no observers will be\\n    inserted in the middle of a fusion).\\n\\n    A subgraph is defined by (start_node, end_node).  We assume that only\\n    start_node and end_node are linked with the surrounding graph, all other\\n    nodes in a subgraph are self-contained.\\n\\n    A pair of nodes is \"related\" if both nodes represent the same mathematical\\n    operation across different quantization flavors. For example,\\n    `F.linear` and `torch.ops.quantized.linear` are related, and\\n    `F.linear` and `torch.nn.Conv` are not related.\\n\\n    For each matchable pair of nodes node_a and node_b, they will match\\n    if node_a and node_b are related.\\n\\n    For graphs A and B, they will match iff:\\n    1. the number of matchable subgraphs in A and B is equivalent\\n    2. when iterating through the matchable subgraphs of A and B in the same order, each\\n       corresponding pair of base nodes is related.\\n\\n    This enables us to find the corresponding subgraphs between\\n    graphs of related models.  For example, if we had two graphs such as:\\n\\n    graph_a: x0 -> conv_0 (type: nn.Conv2d) -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> qconv_0 (type: nnq.Conv2d) -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'conv_0\\': (  # the name of the node in graph_b\\n          (conv_0, conv_0),  # (start_node_a, end_node_a)\\n          (qconv_0, qconv_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n\\n    Or, if we have a fusion pattern,\\n\\n    graph_a: x0 -> linear_0 -> relu_0 -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> linear_relu_0 -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'linear_relu_0\\': (  # the name of the node in graph_b\\n          (linear_0, relu_0),  # (start_node_a, end_node_a)\\n          (linear_relu_0, linear_relu_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n    '\n    if unmatchable_types_map is None:\n        unmatchable_types_map = get_unmatchable_types_map()\n    non_matchable_functions = unmatchable_types_map['funs_unmatchable']\n    non_matchable_modules = unmatchable_types_map['mods_unmatchable']\n    non_matchable_methods = unmatchable_types_map['meths_unmatchable']\n    graph_a_iterator = _NSGraphMatchableSubgraphsIterator(gm_a, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    graph_b_iterator = _NSGraphMatchableSubgraphsIterator(gm_b, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    results = collections.OrderedDict()\n    if base_name_to_sets_of_related_ops is None:\n        base_name_to_sets_of_related_ops = get_base_name_to_sets_of_related_ops()\n    type_a_related_to_b = get_type_a_related_to_b(base_name_to_sets_of_related_ops)\n    existing_names_a: Set[str] = set()\n    existing_names_b: Set[str] = set()\n    while True:\n        (cur_subgraph_a, cur_subgraph_b) = (None, None)\n        try:\n            cur_subgraph_a = next(graph_a_iterator)\n        except StopIteration:\n            pass\n        try:\n            cur_subgraph_b = next(graph_b_iterator)\n        except StopIteration:\n            pass\n        (type_start_a, type_start_b) = (None, None)\n        if cur_subgraph_a is not None:\n            type_start_a = _get_node_target_type(cur_subgraph_a.start_node, gm_a)\n        if cur_subgraph_b is not None:\n            type_start_b = _get_node_target_type(cur_subgraph_b.start_node, gm_b)\n        if cur_subgraph_a is not None and cur_subgraph_b is not None:\n            subgraph_relationship = _get_subgraph_relationship_type(cur_subgraph_a, cur_subgraph_b, gm_a, gm_b, type_a_related_to_b)\n            if subgraph_relationship == SubgraphTypeRelationship.NOT_RELATED:\n                msg = f'\\nThe subgraphs\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b})\\nare not related. Please ensure that the two models you pass in have the same number\\nof subgraphs, and each pair of subgraphs is related to each other.'\n                raise GraphMatchingException(msg)\n            elif subgraph_relationship == SubgraphTypeRelationship.EQUAL_BUT_UKNOWN:\n                continue\n            key_name_a = _get_name_for_subgraph(cur_subgraph_a, gm_a, base_name_to_sets_of_related_ops, existing_names_a)\n            key_name_b = _get_name_for_subgraph(cur_subgraph_b, gm_b, base_name_to_sets_of_related_ops, existing_names_b)\n            assert key_name_a == key_name_b, f'Subgraph names {key_name_a} and {key_name_b} do not match'\n            results[key_name_a] = (cur_subgraph_a, cur_subgraph_b)\n            continue\n        elif cur_subgraph_a is None and cur_subgraph_b is None:\n            break\n        else:\n            msg = f'\\nAttempting to match\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b}),\\none of which is empty. Please ensure that the two models you pass in have the same number\\nof subgraphs.'\n            raise GraphMatchingException(msg)\n    results = collections.OrderedDict(reversed(list(results.items())))\n    return results",
            "def get_matching_subgraph_pairs(gm_a: GraphModule, gm_b: GraphModule, base_name_to_sets_of_related_ops: Optional[Dict[str, Set[NSNodeTargetType]]]=None, unmatchable_types_map: Optional[Dict[str, Set[NSNodeTargetType]]]=None) -> Dict[str, Tuple[NSSubgraph, NSSubgraph]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Matches matchable subgraphs of graph_a to graph_b.\\n\\n    For a node, \"matchable\" is defined as a node which is not an observer,\\n    fake_quants, quant or dequant.\\n\\n    A subgraph can contain one or more nodes.  A subgraph is matchable if\\n    at least one node inside of it is matchable.  Currently, all nodes in\\n    a subgraph must be matchable (because we assume no observers will be\\n    inserted in the middle of a fusion).\\n\\n    A subgraph is defined by (start_node, end_node).  We assume that only\\n    start_node and end_node are linked with the surrounding graph, all other\\n    nodes in a subgraph are self-contained.\\n\\n    A pair of nodes is \"related\" if both nodes represent the same mathematical\\n    operation across different quantization flavors. For example,\\n    `F.linear` and `torch.ops.quantized.linear` are related, and\\n    `F.linear` and `torch.nn.Conv` are not related.\\n\\n    For each matchable pair of nodes node_a and node_b, they will match\\n    if node_a and node_b are related.\\n\\n    For graphs A and B, they will match iff:\\n    1. the number of matchable subgraphs in A and B is equivalent\\n    2. when iterating through the matchable subgraphs of A and B in the same order, each\\n       corresponding pair of base nodes is related.\\n\\n    This enables us to find the corresponding subgraphs between\\n    graphs of related models.  For example, if we had two graphs such as:\\n\\n    graph_a: x0 -> conv_0 (type: nn.Conv2d) -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> qconv_0 (type: nnq.Conv2d) -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'conv_0\\': (  # the name of the node in graph_b\\n          (conv_0, conv_0),  # (start_node_a, end_node_a)\\n          (qconv_0, qconv_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n\\n    Or, if we have a fusion pattern,\\n\\n    graph_a: x0 -> linear_0 -> relu_0 -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> linear_relu_0 -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'linear_relu_0\\': (  # the name of the node in graph_b\\n          (linear_0, relu_0),  # (start_node_a, end_node_a)\\n          (linear_relu_0, linear_relu_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n    '\n    if unmatchable_types_map is None:\n        unmatchable_types_map = get_unmatchable_types_map()\n    non_matchable_functions = unmatchable_types_map['funs_unmatchable']\n    non_matchable_modules = unmatchable_types_map['mods_unmatchable']\n    non_matchable_methods = unmatchable_types_map['meths_unmatchable']\n    graph_a_iterator = _NSGraphMatchableSubgraphsIterator(gm_a, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    graph_b_iterator = _NSGraphMatchableSubgraphsIterator(gm_b, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    results = collections.OrderedDict()\n    if base_name_to_sets_of_related_ops is None:\n        base_name_to_sets_of_related_ops = get_base_name_to_sets_of_related_ops()\n    type_a_related_to_b = get_type_a_related_to_b(base_name_to_sets_of_related_ops)\n    existing_names_a: Set[str] = set()\n    existing_names_b: Set[str] = set()\n    while True:\n        (cur_subgraph_a, cur_subgraph_b) = (None, None)\n        try:\n            cur_subgraph_a = next(graph_a_iterator)\n        except StopIteration:\n            pass\n        try:\n            cur_subgraph_b = next(graph_b_iterator)\n        except StopIteration:\n            pass\n        (type_start_a, type_start_b) = (None, None)\n        if cur_subgraph_a is not None:\n            type_start_a = _get_node_target_type(cur_subgraph_a.start_node, gm_a)\n        if cur_subgraph_b is not None:\n            type_start_b = _get_node_target_type(cur_subgraph_b.start_node, gm_b)\n        if cur_subgraph_a is not None and cur_subgraph_b is not None:\n            subgraph_relationship = _get_subgraph_relationship_type(cur_subgraph_a, cur_subgraph_b, gm_a, gm_b, type_a_related_to_b)\n            if subgraph_relationship == SubgraphTypeRelationship.NOT_RELATED:\n                msg = f'\\nThe subgraphs\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b})\\nare not related. Please ensure that the two models you pass in have the same number\\nof subgraphs, and each pair of subgraphs is related to each other.'\n                raise GraphMatchingException(msg)\n            elif subgraph_relationship == SubgraphTypeRelationship.EQUAL_BUT_UKNOWN:\n                continue\n            key_name_a = _get_name_for_subgraph(cur_subgraph_a, gm_a, base_name_to_sets_of_related_ops, existing_names_a)\n            key_name_b = _get_name_for_subgraph(cur_subgraph_b, gm_b, base_name_to_sets_of_related_ops, existing_names_b)\n            assert key_name_a == key_name_b, f'Subgraph names {key_name_a} and {key_name_b} do not match'\n            results[key_name_a] = (cur_subgraph_a, cur_subgraph_b)\n            continue\n        elif cur_subgraph_a is None and cur_subgraph_b is None:\n            break\n        else:\n            msg = f'\\nAttempting to match\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b}),\\none of which is empty. Please ensure that the two models you pass in have the same number\\nof subgraphs.'\n            raise GraphMatchingException(msg)\n    results = collections.OrderedDict(reversed(list(results.items())))\n    return results",
            "def get_matching_subgraph_pairs(gm_a: GraphModule, gm_b: GraphModule, base_name_to_sets_of_related_ops: Optional[Dict[str, Set[NSNodeTargetType]]]=None, unmatchable_types_map: Optional[Dict[str, Set[NSNodeTargetType]]]=None) -> Dict[str, Tuple[NSSubgraph, NSSubgraph]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Matches matchable subgraphs of graph_a to graph_b.\\n\\n    For a node, \"matchable\" is defined as a node which is not an observer,\\n    fake_quants, quant or dequant.\\n\\n    A subgraph can contain one or more nodes.  A subgraph is matchable if\\n    at least one node inside of it is matchable.  Currently, all nodes in\\n    a subgraph must be matchable (because we assume no observers will be\\n    inserted in the middle of a fusion).\\n\\n    A subgraph is defined by (start_node, end_node).  We assume that only\\n    start_node and end_node are linked with the surrounding graph, all other\\n    nodes in a subgraph are self-contained.\\n\\n    A pair of nodes is \"related\" if both nodes represent the same mathematical\\n    operation across different quantization flavors. For example,\\n    `F.linear` and `torch.ops.quantized.linear` are related, and\\n    `F.linear` and `torch.nn.Conv` are not related.\\n\\n    For each matchable pair of nodes node_a and node_b, they will match\\n    if node_a and node_b are related.\\n\\n    For graphs A and B, they will match iff:\\n    1. the number of matchable subgraphs in A and B is equivalent\\n    2. when iterating through the matchable subgraphs of A and B in the same order, each\\n       corresponding pair of base nodes is related.\\n\\n    This enables us to find the corresponding subgraphs between\\n    graphs of related models.  For example, if we had two graphs such as:\\n\\n    graph_a: x0 -> conv_0 (type: nn.Conv2d) -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> qconv_0 (type: nnq.Conv2d) -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'conv_0\\': (  # the name of the node in graph_b\\n          (conv_0, conv_0),  # (start_node_a, end_node_a)\\n          (qconv_0, qconv_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n\\n    Or, if we have a fusion pattern,\\n\\n    graph_a: x0 -> linear_0 -> relu_0 -> obs_0 -> x1\\n             w  -/\\n             b  -/\\n\\n    graph_b: x0 -> quant_0 -> linear_relu_0 -> dequant_0 -> x1\\n           packed_params_0 -/\\n\\n    This function will return the following result:\\n    {\\n        \\'linear_relu_0\\': (  # the name of the node in graph_b\\n          (linear_0, relu_0),  # (start_node_a, end_node_a)\\n          (linear_relu_0, linear_relu_0),  # (start_node_b, end_node_b)\\n        ),\\n    }\\n    '\n    if unmatchable_types_map is None:\n        unmatchable_types_map = get_unmatchable_types_map()\n    non_matchable_functions = unmatchable_types_map['funs_unmatchable']\n    non_matchable_modules = unmatchable_types_map['mods_unmatchable']\n    non_matchable_methods = unmatchable_types_map['meths_unmatchable']\n    graph_a_iterator = _NSGraphMatchableSubgraphsIterator(gm_a, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    graph_b_iterator = _NSGraphMatchableSubgraphsIterator(gm_b, non_matchable_functions, non_matchable_modules, non_matchable_methods)\n    results = collections.OrderedDict()\n    if base_name_to_sets_of_related_ops is None:\n        base_name_to_sets_of_related_ops = get_base_name_to_sets_of_related_ops()\n    type_a_related_to_b = get_type_a_related_to_b(base_name_to_sets_of_related_ops)\n    existing_names_a: Set[str] = set()\n    existing_names_b: Set[str] = set()\n    while True:\n        (cur_subgraph_a, cur_subgraph_b) = (None, None)\n        try:\n            cur_subgraph_a = next(graph_a_iterator)\n        except StopIteration:\n            pass\n        try:\n            cur_subgraph_b = next(graph_b_iterator)\n        except StopIteration:\n            pass\n        (type_start_a, type_start_b) = (None, None)\n        if cur_subgraph_a is not None:\n            type_start_a = _get_node_target_type(cur_subgraph_a.start_node, gm_a)\n        if cur_subgraph_b is not None:\n            type_start_b = _get_node_target_type(cur_subgraph_b.start_node, gm_b)\n        if cur_subgraph_a is not None and cur_subgraph_b is not None:\n            subgraph_relationship = _get_subgraph_relationship_type(cur_subgraph_a, cur_subgraph_b, gm_a, gm_b, type_a_related_to_b)\n            if subgraph_relationship == SubgraphTypeRelationship.NOT_RELATED:\n                msg = f'\\nThe subgraphs\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b})\\nare not related. Please ensure that the two models you pass in have the same number\\nof subgraphs, and each pair of subgraphs is related to each other.'\n                raise GraphMatchingException(msg)\n            elif subgraph_relationship == SubgraphTypeRelationship.EQUAL_BUT_UKNOWN:\n                continue\n            key_name_a = _get_name_for_subgraph(cur_subgraph_a, gm_a, base_name_to_sets_of_related_ops, existing_names_a)\n            key_name_b = _get_name_for_subgraph(cur_subgraph_b, gm_b, base_name_to_sets_of_related_ops, existing_names_b)\n            assert key_name_a == key_name_b, f'Subgraph names {key_name_a} and {key_name_b} do not match'\n            results[key_name_a] = (cur_subgraph_a, cur_subgraph_b)\n            continue\n        elif cur_subgraph_a is None and cur_subgraph_b is None:\n            break\n        else:\n            msg = f'\\nAttempting to match\\n({cur_subgraph_a}, {type_start_a}) and\\n({cur_subgraph_b}, {type_start_b}),\\none of which is empty. Please ensure that the two models you pass in have the same number\\nof subgraphs.'\n            raise GraphMatchingException(msg)\n    results = collections.OrderedDict(reversed(list(results.items())))\n    return results"
        ]
    }
]