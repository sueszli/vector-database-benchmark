[
    {
        "func_name": "fix_email_gateway_attachment_owner",
        "original": "def fix_email_gateway_attachment_owner(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    Realm = apps.get_model('zerver', 'Realm')\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    Client = apps.get_model('zerver', 'Client')\n    Message = apps.get_model('zerver', 'Message')\n    ArchivedMessage = apps.get_model('zerver', 'ArchivedMessage')\n    Stream = apps.get_model('zerver', 'Stream')\n    Attachment = apps.get_model('zerver', 'Attachment')\n    ArchivedAttachment = apps.get_model('zerver', 'ArchivedAttachment')\n    if not Realm.objects.exists():\n        return\n    mail_gateway_bot = UserProfile.objects.get(email__iexact=settings.EMAIL_GATEWAY_BOT)\n    (internal_client, _) = Client.objects.get_or_create(name='Internal')\n    orphan_attachments = Attachment.objects.filter(messages=None, owner_id=mail_gateway_bot.id)\n    if len(orphan_attachments) == 0:\n        return\n    print('')\n    print(f'Found {len(orphan_attachments)} email gateway attachments to reattach')\n    for attachment in orphan_attachments:\n        print(f'Looking for a message to attach {attachment.path_id}, created {attachment.create_time}')\n        possible_matches = []\n        for model_class in (Message, ArchivedMessage):\n            possible_matches.extend(model_class.objects.filter(has_attachment=False, realm_id=attachment.realm_id, sending_client_id=internal_client.id, date_sent__gte=attachment.create_time, date_sent__lte=attachment.create_time + timedelta(minutes=5), content__contains='/user_uploads/' + attachment.path_id).order_by('date_sent'))\n        if len(possible_matches) == 0:\n            print('  No matches!')\n            continue\n        message = possible_matches[0]\n        print(f'  Found {message.id} @ {message.date_sent} by {message.sender.delivery_email})')\n        if isinstance(message, ArchivedMessage):\n            fields = list(Attachment._meta.fields)\n            src_fields = [Identifier('zerver_attachment', field.column) for field in fields]\n            dst_fields = [Identifier(field.column) for field in fields]\n            with connection.cursor() as cursor:\n                raw_query = SQL('\\n                    INSERT INTO zerver_archivedattachment ({dst_fields})\\n                        SELECT {src_fields}\\n                        FROM zerver_attachment\\n                        WHERE id = {id}\\n                    ON CONFLICT (id) DO NOTHING\\n                    RETURNING id\\n                    ')\n                cursor.execute(raw_query.format(src_fields=SQL(',').join(src_fields), dst_fields=SQL(',').join(dst_fields), id=Literal(attachment.id)))\n                archived_ids = [id for (id,) in cursor.fetchall()]\n                if len(archived_ids) != 1:\n                    print('!!! Did not create one archived attachment row!')\n            attachment.delete()\n            attachment = ArchivedAttachment.objects.get(id=archived_ids[0])\n        is_message_realm_public = False\n        is_message_web_public = False\n        if message.recipient.type == 2:\n            stream = Stream.objects.get(id=message.recipient.type_id)\n            is_message_realm_public = not stream.invite_only and (not stream.is_in_zephyr_realm)\n            is_message_web_public = stream.is_web_public\n        attachment.owner_id = message.sender_id\n        attachment.is_web_public = is_message_web_public\n        attachment.is_realm_public = is_message_realm_public\n        attachment.save(update_fields=['owner_id', 'is_web_public', 'is_realm_public'])\n        if isinstance(attachment, ArchivedAttachment):\n            assert isinstance(message, ArchivedMessage)\n            with connection.cursor() as cursor:\n                raw_query = SQL(\"\\n                    INSERT INTO zerver_archivedattachment_messages\\n                           (id, archivedattachment_id, archivedmessage_id)\\n                    VALUES (nextval(pg_get_serial_sequence('zerver_attachment_messages', 'id')),\\n                            {attachment_id}, {message_id})\\n                    \")\n                cursor.execute(raw_query.format(attachment_id=Literal(attachment.id), message_id=Literal(message.id)))\n        else:\n            assert isinstance(message, Message)\n            attachment.messages.add(message)\n        message.has_attachment = True\n        message.save(update_fields=['has_attachment'])",
        "mutated": [
            "def fix_email_gateway_attachment_owner(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n    Realm = apps.get_model('zerver', 'Realm')\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    Client = apps.get_model('zerver', 'Client')\n    Message = apps.get_model('zerver', 'Message')\n    ArchivedMessage = apps.get_model('zerver', 'ArchivedMessage')\n    Stream = apps.get_model('zerver', 'Stream')\n    Attachment = apps.get_model('zerver', 'Attachment')\n    ArchivedAttachment = apps.get_model('zerver', 'ArchivedAttachment')\n    if not Realm.objects.exists():\n        return\n    mail_gateway_bot = UserProfile.objects.get(email__iexact=settings.EMAIL_GATEWAY_BOT)\n    (internal_client, _) = Client.objects.get_or_create(name='Internal')\n    orphan_attachments = Attachment.objects.filter(messages=None, owner_id=mail_gateway_bot.id)\n    if len(orphan_attachments) == 0:\n        return\n    print('')\n    print(f'Found {len(orphan_attachments)} email gateway attachments to reattach')\n    for attachment in orphan_attachments:\n        print(f'Looking for a message to attach {attachment.path_id}, created {attachment.create_time}')\n        possible_matches = []\n        for model_class in (Message, ArchivedMessage):\n            possible_matches.extend(model_class.objects.filter(has_attachment=False, realm_id=attachment.realm_id, sending_client_id=internal_client.id, date_sent__gte=attachment.create_time, date_sent__lte=attachment.create_time + timedelta(minutes=5), content__contains='/user_uploads/' + attachment.path_id).order_by('date_sent'))\n        if len(possible_matches) == 0:\n            print('  No matches!')\n            continue\n        message = possible_matches[0]\n        print(f'  Found {message.id} @ {message.date_sent} by {message.sender.delivery_email})')\n        if isinstance(message, ArchivedMessage):\n            fields = list(Attachment._meta.fields)\n            src_fields = [Identifier('zerver_attachment', field.column) for field in fields]\n            dst_fields = [Identifier(field.column) for field in fields]\n            with connection.cursor() as cursor:\n                raw_query = SQL('\\n                    INSERT INTO zerver_archivedattachment ({dst_fields})\\n                        SELECT {src_fields}\\n                        FROM zerver_attachment\\n                        WHERE id = {id}\\n                    ON CONFLICT (id) DO NOTHING\\n                    RETURNING id\\n                    ')\n                cursor.execute(raw_query.format(src_fields=SQL(',').join(src_fields), dst_fields=SQL(',').join(dst_fields), id=Literal(attachment.id)))\n                archived_ids = [id for (id,) in cursor.fetchall()]\n                if len(archived_ids) != 1:\n                    print('!!! Did not create one archived attachment row!')\n            attachment.delete()\n            attachment = ArchivedAttachment.objects.get(id=archived_ids[0])\n        is_message_realm_public = False\n        is_message_web_public = False\n        if message.recipient.type == 2:\n            stream = Stream.objects.get(id=message.recipient.type_id)\n            is_message_realm_public = not stream.invite_only and (not stream.is_in_zephyr_realm)\n            is_message_web_public = stream.is_web_public\n        attachment.owner_id = message.sender_id\n        attachment.is_web_public = is_message_web_public\n        attachment.is_realm_public = is_message_realm_public\n        attachment.save(update_fields=['owner_id', 'is_web_public', 'is_realm_public'])\n        if isinstance(attachment, ArchivedAttachment):\n            assert isinstance(message, ArchivedMessage)\n            with connection.cursor() as cursor:\n                raw_query = SQL(\"\\n                    INSERT INTO zerver_archivedattachment_messages\\n                           (id, archivedattachment_id, archivedmessage_id)\\n                    VALUES (nextval(pg_get_serial_sequence('zerver_attachment_messages', 'id')),\\n                            {attachment_id}, {message_id})\\n                    \")\n                cursor.execute(raw_query.format(attachment_id=Literal(attachment.id), message_id=Literal(message.id)))\n        else:\n            assert isinstance(message, Message)\n            attachment.messages.add(message)\n        message.has_attachment = True\n        message.save(update_fields=['has_attachment'])",
            "def fix_email_gateway_attachment_owner(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Realm = apps.get_model('zerver', 'Realm')\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    Client = apps.get_model('zerver', 'Client')\n    Message = apps.get_model('zerver', 'Message')\n    ArchivedMessage = apps.get_model('zerver', 'ArchivedMessage')\n    Stream = apps.get_model('zerver', 'Stream')\n    Attachment = apps.get_model('zerver', 'Attachment')\n    ArchivedAttachment = apps.get_model('zerver', 'ArchivedAttachment')\n    if not Realm.objects.exists():\n        return\n    mail_gateway_bot = UserProfile.objects.get(email__iexact=settings.EMAIL_GATEWAY_BOT)\n    (internal_client, _) = Client.objects.get_or_create(name='Internal')\n    orphan_attachments = Attachment.objects.filter(messages=None, owner_id=mail_gateway_bot.id)\n    if len(orphan_attachments) == 0:\n        return\n    print('')\n    print(f'Found {len(orphan_attachments)} email gateway attachments to reattach')\n    for attachment in orphan_attachments:\n        print(f'Looking for a message to attach {attachment.path_id}, created {attachment.create_time}')\n        possible_matches = []\n        for model_class in (Message, ArchivedMessage):\n            possible_matches.extend(model_class.objects.filter(has_attachment=False, realm_id=attachment.realm_id, sending_client_id=internal_client.id, date_sent__gte=attachment.create_time, date_sent__lte=attachment.create_time + timedelta(minutes=5), content__contains='/user_uploads/' + attachment.path_id).order_by('date_sent'))\n        if len(possible_matches) == 0:\n            print('  No matches!')\n            continue\n        message = possible_matches[0]\n        print(f'  Found {message.id} @ {message.date_sent} by {message.sender.delivery_email})')\n        if isinstance(message, ArchivedMessage):\n            fields = list(Attachment._meta.fields)\n            src_fields = [Identifier('zerver_attachment', field.column) for field in fields]\n            dst_fields = [Identifier(field.column) for field in fields]\n            with connection.cursor() as cursor:\n                raw_query = SQL('\\n                    INSERT INTO zerver_archivedattachment ({dst_fields})\\n                        SELECT {src_fields}\\n                        FROM zerver_attachment\\n                        WHERE id = {id}\\n                    ON CONFLICT (id) DO NOTHING\\n                    RETURNING id\\n                    ')\n                cursor.execute(raw_query.format(src_fields=SQL(',').join(src_fields), dst_fields=SQL(',').join(dst_fields), id=Literal(attachment.id)))\n                archived_ids = [id for (id,) in cursor.fetchall()]\n                if len(archived_ids) != 1:\n                    print('!!! Did not create one archived attachment row!')\n            attachment.delete()\n            attachment = ArchivedAttachment.objects.get(id=archived_ids[0])\n        is_message_realm_public = False\n        is_message_web_public = False\n        if message.recipient.type == 2:\n            stream = Stream.objects.get(id=message.recipient.type_id)\n            is_message_realm_public = not stream.invite_only and (not stream.is_in_zephyr_realm)\n            is_message_web_public = stream.is_web_public\n        attachment.owner_id = message.sender_id\n        attachment.is_web_public = is_message_web_public\n        attachment.is_realm_public = is_message_realm_public\n        attachment.save(update_fields=['owner_id', 'is_web_public', 'is_realm_public'])\n        if isinstance(attachment, ArchivedAttachment):\n            assert isinstance(message, ArchivedMessage)\n            with connection.cursor() as cursor:\n                raw_query = SQL(\"\\n                    INSERT INTO zerver_archivedattachment_messages\\n                           (id, archivedattachment_id, archivedmessage_id)\\n                    VALUES (nextval(pg_get_serial_sequence('zerver_attachment_messages', 'id')),\\n                            {attachment_id}, {message_id})\\n                    \")\n                cursor.execute(raw_query.format(attachment_id=Literal(attachment.id), message_id=Literal(message.id)))\n        else:\n            assert isinstance(message, Message)\n            attachment.messages.add(message)\n        message.has_attachment = True\n        message.save(update_fields=['has_attachment'])",
            "def fix_email_gateway_attachment_owner(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Realm = apps.get_model('zerver', 'Realm')\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    Client = apps.get_model('zerver', 'Client')\n    Message = apps.get_model('zerver', 'Message')\n    ArchivedMessage = apps.get_model('zerver', 'ArchivedMessage')\n    Stream = apps.get_model('zerver', 'Stream')\n    Attachment = apps.get_model('zerver', 'Attachment')\n    ArchivedAttachment = apps.get_model('zerver', 'ArchivedAttachment')\n    if not Realm.objects.exists():\n        return\n    mail_gateway_bot = UserProfile.objects.get(email__iexact=settings.EMAIL_GATEWAY_BOT)\n    (internal_client, _) = Client.objects.get_or_create(name='Internal')\n    orphan_attachments = Attachment.objects.filter(messages=None, owner_id=mail_gateway_bot.id)\n    if len(orphan_attachments) == 0:\n        return\n    print('')\n    print(f'Found {len(orphan_attachments)} email gateway attachments to reattach')\n    for attachment in orphan_attachments:\n        print(f'Looking for a message to attach {attachment.path_id}, created {attachment.create_time}')\n        possible_matches = []\n        for model_class in (Message, ArchivedMessage):\n            possible_matches.extend(model_class.objects.filter(has_attachment=False, realm_id=attachment.realm_id, sending_client_id=internal_client.id, date_sent__gte=attachment.create_time, date_sent__lte=attachment.create_time + timedelta(minutes=5), content__contains='/user_uploads/' + attachment.path_id).order_by('date_sent'))\n        if len(possible_matches) == 0:\n            print('  No matches!')\n            continue\n        message = possible_matches[0]\n        print(f'  Found {message.id} @ {message.date_sent} by {message.sender.delivery_email})')\n        if isinstance(message, ArchivedMessage):\n            fields = list(Attachment._meta.fields)\n            src_fields = [Identifier('zerver_attachment', field.column) for field in fields]\n            dst_fields = [Identifier(field.column) for field in fields]\n            with connection.cursor() as cursor:\n                raw_query = SQL('\\n                    INSERT INTO zerver_archivedattachment ({dst_fields})\\n                        SELECT {src_fields}\\n                        FROM zerver_attachment\\n                        WHERE id = {id}\\n                    ON CONFLICT (id) DO NOTHING\\n                    RETURNING id\\n                    ')\n                cursor.execute(raw_query.format(src_fields=SQL(',').join(src_fields), dst_fields=SQL(',').join(dst_fields), id=Literal(attachment.id)))\n                archived_ids = [id for (id,) in cursor.fetchall()]\n                if len(archived_ids) != 1:\n                    print('!!! Did not create one archived attachment row!')\n            attachment.delete()\n            attachment = ArchivedAttachment.objects.get(id=archived_ids[0])\n        is_message_realm_public = False\n        is_message_web_public = False\n        if message.recipient.type == 2:\n            stream = Stream.objects.get(id=message.recipient.type_id)\n            is_message_realm_public = not stream.invite_only and (not stream.is_in_zephyr_realm)\n            is_message_web_public = stream.is_web_public\n        attachment.owner_id = message.sender_id\n        attachment.is_web_public = is_message_web_public\n        attachment.is_realm_public = is_message_realm_public\n        attachment.save(update_fields=['owner_id', 'is_web_public', 'is_realm_public'])\n        if isinstance(attachment, ArchivedAttachment):\n            assert isinstance(message, ArchivedMessage)\n            with connection.cursor() as cursor:\n                raw_query = SQL(\"\\n                    INSERT INTO zerver_archivedattachment_messages\\n                           (id, archivedattachment_id, archivedmessage_id)\\n                    VALUES (nextval(pg_get_serial_sequence('zerver_attachment_messages', 'id')),\\n                            {attachment_id}, {message_id})\\n                    \")\n                cursor.execute(raw_query.format(attachment_id=Literal(attachment.id), message_id=Literal(message.id)))\n        else:\n            assert isinstance(message, Message)\n            attachment.messages.add(message)\n        message.has_attachment = True\n        message.save(update_fields=['has_attachment'])",
            "def fix_email_gateway_attachment_owner(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Realm = apps.get_model('zerver', 'Realm')\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    Client = apps.get_model('zerver', 'Client')\n    Message = apps.get_model('zerver', 'Message')\n    ArchivedMessage = apps.get_model('zerver', 'ArchivedMessage')\n    Stream = apps.get_model('zerver', 'Stream')\n    Attachment = apps.get_model('zerver', 'Attachment')\n    ArchivedAttachment = apps.get_model('zerver', 'ArchivedAttachment')\n    if not Realm.objects.exists():\n        return\n    mail_gateway_bot = UserProfile.objects.get(email__iexact=settings.EMAIL_GATEWAY_BOT)\n    (internal_client, _) = Client.objects.get_or_create(name='Internal')\n    orphan_attachments = Attachment.objects.filter(messages=None, owner_id=mail_gateway_bot.id)\n    if len(orphan_attachments) == 0:\n        return\n    print('')\n    print(f'Found {len(orphan_attachments)} email gateway attachments to reattach')\n    for attachment in orphan_attachments:\n        print(f'Looking for a message to attach {attachment.path_id}, created {attachment.create_time}')\n        possible_matches = []\n        for model_class in (Message, ArchivedMessage):\n            possible_matches.extend(model_class.objects.filter(has_attachment=False, realm_id=attachment.realm_id, sending_client_id=internal_client.id, date_sent__gte=attachment.create_time, date_sent__lte=attachment.create_time + timedelta(minutes=5), content__contains='/user_uploads/' + attachment.path_id).order_by('date_sent'))\n        if len(possible_matches) == 0:\n            print('  No matches!')\n            continue\n        message = possible_matches[0]\n        print(f'  Found {message.id} @ {message.date_sent} by {message.sender.delivery_email})')\n        if isinstance(message, ArchivedMessage):\n            fields = list(Attachment._meta.fields)\n            src_fields = [Identifier('zerver_attachment', field.column) for field in fields]\n            dst_fields = [Identifier(field.column) for field in fields]\n            with connection.cursor() as cursor:\n                raw_query = SQL('\\n                    INSERT INTO zerver_archivedattachment ({dst_fields})\\n                        SELECT {src_fields}\\n                        FROM zerver_attachment\\n                        WHERE id = {id}\\n                    ON CONFLICT (id) DO NOTHING\\n                    RETURNING id\\n                    ')\n                cursor.execute(raw_query.format(src_fields=SQL(',').join(src_fields), dst_fields=SQL(',').join(dst_fields), id=Literal(attachment.id)))\n                archived_ids = [id for (id,) in cursor.fetchall()]\n                if len(archived_ids) != 1:\n                    print('!!! Did not create one archived attachment row!')\n            attachment.delete()\n            attachment = ArchivedAttachment.objects.get(id=archived_ids[0])\n        is_message_realm_public = False\n        is_message_web_public = False\n        if message.recipient.type == 2:\n            stream = Stream.objects.get(id=message.recipient.type_id)\n            is_message_realm_public = not stream.invite_only and (not stream.is_in_zephyr_realm)\n            is_message_web_public = stream.is_web_public\n        attachment.owner_id = message.sender_id\n        attachment.is_web_public = is_message_web_public\n        attachment.is_realm_public = is_message_realm_public\n        attachment.save(update_fields=['owner_id', 'is_web_public', 'is_realm_public'])\n        if isinstance(attachment, ArchivedAttachment):\n            assert isinstance(message, ArchivedMessage)\n            with connection.cursor() as cursor:\n                raw_query = SQL(\"\\n                    INSERT INTO zerver_archivedattachment_messages\\n                           (id, archivedattachment_id, archivedmessage_id)\\n                    VALUES (nextval(pg_get_serial_sequence('zerver_attachment_messages', 'id')),\\n                            {attachment_id}, {message_id})\\n                    \")\n                cursor.execute(raw_query.format(attachment_id=Literal(attachment.id), message_id=Literal(message.id)))\n        else:\n            assert isinstance(message, Message)\n            attachment.messages.add(message)\n        message.has_attachment = True\n        message.save(update_fields=['has_attachment'])",
            "def fix_email_gateway_attachment_owner(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Realm = apps.get_model('zerver', 'Realm')\n    UserProfile = apps.get_model('zerver', 'UserProfile')\n    Client = apps.get_model('zerver', 'Client')\n    Message = apps.get_model('zerver', 'Message')\n    ArchivedMessage = apps.get_model('zerver', 'ArchivedMessage')\n    Stream = apps.get_model('zerver', 'Stream')\n    Attachment = apps.get_model('zerver', 'Attachment')\n    ArchivedAttachment = apps.get_model('zerver', 'ArchivedAttachment')\n    if not Realm.objects.exists():\n        return\n    mail_gateway_bot = UserProfile.objects.get(email__iexact=settings.EMAIL_GATEWAY_BOT)\n    (internal_client, _) = Client.objects.get_or_create(name='Internal')\n    orphan_attachments = Attachment.objects.filter(messages=None, owner_id=mail_gateway_bot.id)\n    if len(orphan_attachments) == 0:\n        return\n    print('')\n    print(f'Found {len(orphan_attachments)} email gateway attachments to reattach')\n    for attachment in orphan_attachments:\n        print(f'Looking for a message to attach {attachment.path_id}, created {attachment.create_time}')\n        possible_matches = []\n        for model_class in (Message, ArchivedMessage):\n            possible_matches.extend(model_class.objects.filter(has_attachment=False, realm_id=attachment.realm_id, sending_client_id=internal_client.id, date_sent__gte=attachment.create_time, date_sent__lte=attachment.create_time + timedelta(minutes=5), content__contains='/user_uploads/' + attachment.path_id).order_by('date_sent'))\n        if len(possible_matches) == 0:\n            print('  No matches!')\n            continue\n        message = possible_matches[0]\n        print(f'  Found {message.id} @ {message.date_sent} by {message.sender.delivery_email})')\n        if isinstance(message, ArchivedMessage):\n            fields = list(Attachment._meta.fields)\n            src_fields = [Identifier('zerver_attachment', field.column) for field in fields]\n            dst_fields = [Identifier(field.column) for field in fields]\n            with connection.cursor() as cursor:\n                raw_query = SQL('\\n                    INSERT INTO zerver_archivedattachment ({dst_fields})\\n                        SELECT {src_fields}\\n                        FROM zerver_attachment\\n                        WHERE id = {id}\\n                    ON CONFLICT (id) DO NOTHING\\n                    RETURNING id\\n                    ')\n                cursor.execute(raw_query.format(src_fields=SQL(',').join(src_fields), dst_fields=SQL(',').join(dst_fields), id=Literal(attachment.id)))\n                archived_ids = [id for (id,) in cursor.fetchall()]\n                if len(archived_ids) != 1:\n                    print('!!! Did not create one archived attachment row!')\n            attachment.delete()\n            attachment = ArchivedAttachment.objects.get(id=archived_ids[0])\n        is_message_realm_public = False\n        is_message_web_public = False\n        if message.recipient.type == 2:\n            stream = Stream.objects.get(id=message.recipient.type_id)\n            is_message_realm_public = not stream.invite_only and (not stream.is_in_zephyr_realm)\n            is_message_web_public = stream.is_web_public\n        attachment.owner_id = message.sender_id\n        attachment.is_web_public = is_message_web_public\n        attachment.is_realm_public = is_message_realm_public\n        attachment.save(update_fields=['owner_id', 'is_web_public', 'is_realm_public'])\n        if isinstance(attachment, ArchivedAttachment):\n            assert isinstance(message, ArchivedMessage)\n            with connection.cursor() as cursor:\n                raw_query = SQL(\"\\n                    INSERT INTO zerver_archivedattachment_messages\\n                           (id, archivedattachment_id, archivedmessage_id)\\n                    VALUES (nextval(pg_get_serial_sequence('zerver_attachment_messages', 'id')),\\n                            {attachment_id}, {message_id})\\n                    \")\n                cursor.execute(raw_query.format(attachment_id=Literal(attachment.id), message_id=Literal(message.id)))\n        else:\n            assert isinstance(message, Message)\n            attachment.messages.add(message)\n        message.has_attachment = True\n        message.save(update_fields=['has_attachment'])"
        ]
    }
]