[
    {
        "func_name": "main",
        "original": "def main():\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input_dir', help='input annotated directory')\n    parser.add_argument('output_dir', help='output dataset directory')\n    parser.add_argument('--labels', help='labels file', required=True)\n    parser.add_argument('--noviz', help='no visualization', action='store_true')\n    args = parser.parse_args()\n    if osp.exists(args.output_dir):\n        print('Output directory already exists:', args.output_dir)\n        sys.exit(1)\n    os.makedirs(args.output_dir)\n    os.makedirs(osp.join(args.output_dir, 'JPEGImages'))\n    if not args.noviz:\n        os.makedirs(osp.join(args.output_dir, 'Visualization'))\n    print('Creating dataset:', args.output_dir)\n    now = datetime.datetime.now()\n    data = dict(info=dict(description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime('%Y-%m-%d %H:%M:%S.%f')), licenses=[dict(url=None, id=0, name=None)], images=[], type='instances', annotations=[], categories=[])\n    class_name_to_id = {}\n    for (i, line) in enumerate(open(args.labels).readlines()):\n        class_id = i - 1\n        class_name = line.strip()\n        if class_id == -1:\n            assert class_name == '__ignore__'\n            continue\n        class_name_to_id[class_name] = class_id\n        data['categories'].append(dict(supercategory=None, id=class_id, name=class_name))\n    out_ann_file = osp.join(args.output_dir, 'annotations.json')\n    label_files = glob.glob(osp.join(args.input_dir, '*.json'))\n    for (image_id, filename) in enumerate(label_files):\n        print('Generating dataset from:', filename)\n        label_file = labelme.LabelFile(filename=filename)\n        base = osp.splitext(osp.basename(filename))[0]\n        out_img_file = osp.join(args.output_dir, 'JPEGImages', base + '.jpg')\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\n        imgviz.io.imsave(out_img_file, img)\n        data['images'].append(dict(license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id))\n        masks = {}\n        segmentations = collections.defaultdict(list)\n        for shape in label_file.shapes:\n            points = shape['points']\n            label = shape['label']\n            group_id = shape.get('group_id')\n            shape_type = shape.get('shape_type', 'polygon')\n            mask = labelme.utils.shape_to_mask(img.shape[:2], points, shape_type)\n            if group_id is None:\n                group_id = uuid.uuid1()\n            instance = (label, group_id)\n            if instance in masks:\n                masks[instance] = masks[instance] | mask\n            else:\n                masks[instance] = mask\n            if shape_type == 'rectangle':\n                ((x1, y1), (x2, y2)) = points\n                (x1, x2) = sorted([x1, x2])\n                (y1, y2) = sorted([y1, y2])\n                points = [x1, y1, x2, y1, x2, y2, x1, y2]\n            if shape_type == 'circle':\n                ((x1, y1), (x2, y2)) = points\n                r = np.linalg.norm([x2 - x1, y2 - y1])\n                n_points_circle = max(int(np.pi / np.arccos(1 - 1 / r)), 12)\n                i = np.arange(n_points_circle)\n                x = x1 + r * np.sin(2 * np.pi / n_points_circle * i)\n                y = y1 + r * np.cos(2 * np.pi / n_points_circle * i)\n                points = np.stack((x, y), axis=1).flatten().tolist()\n            else:\n                points = np.asarray(points).flatten().tolist()\n            segmentations[instance].append(points)\n        segmentations = dict(segmentations)\n        for (instance, mask) in masks.items():\n            (cls_name, group_id) = instance\n            if cls_name not in class_name_to_id:\n                continue\n            cls_id = class_name_to_id[cls_name]\n            mask = np.asfortranarray(mask.astype(np.uint8))\n            mask = pycocotools.mask.encode(mask)\n            area = float(pycocotools.mask.area(mask))\n            bbox = pycocotools.mask.toBbox(mask).flatten().tolist()\n            data['annotations'].append(dict(id=len(data['annotations']), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0))\n        if not args.noviz:\n            viz = img\n            if masks:\n                (labels, captions, masks) = zip(*[(class_name_to_id[cnm], cnm, msk) for ((cnm, gid), msk) in masks.items() if cnm in class_name_to_id])\n                viz = imgviz.instances2rgb(image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2)\n            out_viz_file = osp.join(args.output_dir, 'Visualization', base + '.jpg')\n            imgviz.io.imsave(out_viz_file, viz)\n    with open(out_ann_file, 'w') as f:\n        json.dump(data, f)",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input_dir', help='input annotated directory')\n    parser.add_argument('output_dir', help='output dataset directory')\n    parser.add_argument('--labels', help='labels file', required=True)\n    parser.add_argument('--noviz', help='no visualization', action='store_true')\n    args = parser.parse_args()\n    if osp.exists(args.output_dir):\n        print('Output directory already exists:', args.output_dir)\n        sys.exit(1)\n    os.makedirs(args.output_dir)\n    os.makedirs(osp.join(args.output_dir, 'JPEGImages'))\n    if not args.noviz:\n        os.makedirs(osp.join(args.output_dir, 'Visualization'))\n    print('Creating dataset:', args.output_dir)\n    now = datetime.datetime.now()\n    data = dict(info=dict(description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime('%Y-%m-%d %H:%M:%S.%f')), licenses=[dict(url=None, id=0, name=None)], images=[], type='instances', annotations=[], categories=[])\n    class_name_to_id = {}\n    for (i, line) in enumerate(open(args.labels).readlines()):\n        class_id = i - 1\n        class_name = line.strip()\n        if class_id == -1:\n            assert class_name == '__ignore__'\n            continue\n        class_name_to_id[class_name] = class_id\n        data['categories'].append(dict(supercategory=None, id=class_id, name=class_name))\n    out_ann_file = osp.join(args.output_dir, 'annotations.json')\n    label_files = glob.glob(osp.join(args.input_dir, '*.json'))\n    for (image_id, filename) in enumerate(label_files):\n        print('Generating dataset from:', filename)\n        label_file = labelme.LabelFile(filename=filename)\n        base = osp.splitext(osp.basename(filename))[0]\n        out_img_file = osp.join(args.output_dir, 'JPEGImages', base + '.jpg')\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\n        imgviz.io.imsave(out_img_file, img)\n        data['images'].append(dict(license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id))\n        masks = {}\n        segmentations = collections.defaultdict(list)\n        for shape in label_file.shapes:\n            points = shape['points']\n            label = shape['label']\n            group_id = shape.get('group_id')\n            shape_type = shape.get('shape_type', 'polygon')\n            mask = labelme.utils.shape_to_mask(img.shape[:2], points, shape_type)\n            if group_id is None:\n                group_id = uuid.uuid1()\n            instance = (label, group_id)\n            if instance in masks:\n                masks[instance] = masks[instance] | mask\n            else:\n                masks[instance] = mask\n            if shape_type == 'rectangle':\n                ((x1, y1), (x2, y2)) = points\n                (x1, x2) = sorted([x1, x2])\n                (y1, y2) = sorted([y1, y2])\n                points = [x1, y1, x2, y1, x2, y2, x1, y2]\n            if shape_type == 'circle':\n                ((x1, y1), (x2, y2)) = points\n                r = np.linalg.norm([x2 - x1, y2 - y1])\n                n_points_circle = max(int(np.pi / np.arccos(1 - 1 / r)), 12)\n                i = np.arange(n_points_circle)\n                x = x1 + r * np.sin(2 * np.pi / n_points_circle * i)\n                y = y1 + r * np.cos(2 * np.pi / n_points_circle * i)\n                points = np.stack((x, y), axis=1).flatten().tolist()\n            else:\n                points = np.asarray(points).flatten().tolist()\n            segmentations[instance].append(points)\n        segmentations = dict(segmentations)\n        for (instance, mask) in masks.items():\n            (cls_name, group_id) = instance\n            if cls_name not in class_name_to_id:\n                continue\n            cls_id = class_name_to_id[cls_name]\n            mask = np.asfortranarray(mask.astype(np.uint8))\n            mask = pycocotools.mask.encode(mask)\n            area = float(pycocotools.mask.area(mask))\n            bbox = pycocotools.mask.toBbox(mask).flatten().tolist()\n            data['annotations'].append(dict(id=len(data['annotations']), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0))\n        if not args.noviz:\n            viz = img\n            if masks:\n                (labels, captions, masks) = zip(*[(class_name_to_id[cnm], cnm, msk) for ((cnm, gid), msk) in masks.items() if cnm in class_name_to_id])\n                viz = imgviz.instances2rgb(image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2)\n            out_viz_file = osp.join(args.output_dir, 'Visualization', base + '.jpg')\n            imgviz.io.imsave(out_viz_file, viz)\n    with open(out_ann_file, 'w') as f:\n        json.dump(data, f)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input_dir', help='input annotated directory')\n    parser.add_argument('output_dir', help='output dataset directory')\n    parser.add_argument('--labels', help='labels file', required=True)\n    parser.add_argument('--noviz', help='no visualization', action='store_true')\n    args = parser.parse_args()\n    if osp.exists(args.output_dir):\n        print('Output directory already exists:', args.output_dir)\n        sys.exit(1)\n    os.makedirs(args.output_dir)\n    os.makedirs(osp.join(args.output_dir, 'JPEGImages'))\n    if not args.noviz:\n        os.makedirs(osp.join(args.output_dir, 'Visualization'))\n    print('Creating dataset:', args.output_dir)\n    now = datetime.datetime.now()\n    data = dict(info=dict(description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime('%Y-%m-%d %H:%M:%S.%f')), licenses=[dict(url=None, id=0, name=None)], images=[], type='instances', annotations=[], categories=[])\n    class_name_to_id = {}\n    for (i, line) in enumerate(open(args.labels).readlines()):\n        class_id = i - 1\n        class_name = line.strip()\n        if class_id == -1:\n            assert class_name == '__ignore__'\n            continue\n        class_name_to_id[class_name] = class_id\n        data['categories'].append(dict(supercategory=None, id=class_id, name=class_name))\n    out_ann_file = osp.join(args.output_dir, 'annotations.json')\n    label_files = glob.glob(osp.join(args.input_dir, '*.json'))\n    for (image_id, filename) in enumerate(label_files):\n        print('Generating dataset from:', filename)\n        label_file = labelme.LabelFile(filename=filename)\n        base = osp.splitext(osp.basename(filename))[0]\n        out_img_file = osp.join(args.output_dir, 'JPEGImages', base + '.jpg')\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\n        imgviz.io.imsave(out_img_file, img)\n        data['images'].append(dict(license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id))\n        masks = {}\n        segmentations = collections.defaultdict(list)\n        for shape in label_file.shapes:\n            points = shape['points']\n            label = shape['label']\n            group_id = shape.get('group_id')\n            shape_type = shape.get('shape_type', 'polygon')\n            mask = labelme.utils.shape_to_mask(img.shape[:2], points, shape_type)\n            if group_id is None:\n                group_id = uuid.uuid1()\n            instance = (label, group_id)\n            if instance in masks:\n                masks[instance] = masks[instance] | mask\n            else:\n                masks[instance] = mask\n            if shape_type == 'rectangle':\n                ((x1, y1), (x2, y2)) = points\n                (x1, x2) = sorted([x1, x2])\n                (y1, y2) = sorted([y1, y2])\n                points = [x1, y1, x2, y1, x2, y2, x1, y2]\n            if shape_type == 'circle':\n                ((x1, y1), (x2, y2)) = points\n                r = np.linalg.norm([x2 - x1, y2 - y1])\n                n_points_circle = max(int(np.pi / np.arccos(1 - 1 / r)), 12)\n                i = np.arange(n_points_circle)\n                x = x1 + r * np.sin(2 * np.pi / n_points_circle * i)\n                y = y1 + r * np.cos(2 * np.pi / n_points_circle * i)\n                points = np.stack((x, y), axis=1).flatten().tolist()\n            else:\n                points = np.asarray(points).flatten().tolist()\n            segmentations[instance].append(points)\n        segmentations = dict(segmentations)\n        for (instance, mask) in masks.items():\n            (cls_name, group_id) = instance\n            if cls_name not in class_name_to_id:\n                continue\n            cls_id = class_name_to_id[cls_name]\n            mask = np.asfortranarray(mask.astype(np.uint8))\n            mask = pycocotools.mask.encode(mask)\n            area = float(pycocotools.mask.area(mask))\n            bbox = pycocotools.mask.toBbox(mask).flatten().tolist()\n            data['annotations'].append(dict(id=len(data['annotations']), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0))\n        if not args.noviz:\n            viz = img\n            if masks:\n                (labels, captions, masks) = zip(*[(class_name_to_id[cnm], cnm, msk) for ((cnm, gid), msk) in masks.items() if cnm in class_name_to_id])\n                viz = imgviz.instances2rgb(image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2)\n            out_viz_file = osp.join(args.output_dir, 'Visualization', base + '.jpg')\n            imgviz.io.imsave(out_viz_file, viz)\n    with open(out_ann_file, 'w') as f:\n        json.dump(data, f)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input_dir', help='input annotated directory')\n    parser.add_argument('output_dir', help='output dataset directory')\n    parser.add_argument('--labels', help='labels file', required=True)\n    parser.add_argument('--noviz', help='no visualization', action='store_true')\n    args = parser.parse_args()\n    if osp.exists(args.output_dir):\n        print('Output directory already exists:', args.output_dir)\n        sys.exit(1)\n    os.makedirs(args.output_dir)\n    os.makedirs(osp.join(args.output_dir, 'JPEGImages'))\n    if not args.noviz:\n        os.makedirs(osp.join(args.output_dir, 'Visualization'))\n    print('Creating dataset:', args.output_dir)\n    now = datetime.datetime.now()\n    data = dict(info=dict(description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime('%Y-%m-%d %H:%M:%S.%f')), licenses=[dict(url=None, id=0, name=None)], images=[], type='instances', annotations=[], categories=[])\n    class_name_to_id = {}\n    for (i, line) in enumerate(open(args.labels).readlines()):\n        class_id = i - 1\n        class_name = line.strip()\n        if class_id == -1:\n            assert class_name == '__ignore__'\n            continue\n        class_name_to_id[class_name] = class_id\n        data['categories'].append(dict(supercategory=None, id=class_id, name=class_name))\n    out_ann_file = osp.join(args.output_dir, 'annotations.json')\n    label_files = glob.glob(osp.join(args.input_dir, '*.json'))\n    for (image_id, filename) in enumerate(label_files):\n        print('Generating dataset from:', filename)\n        label_file = labelme.LabelFile(filename=filename)\n        base = osp.splitext(osp.basename(filename))[0]\n        out_img_file = osp.join(args.output_dir, 'JPEGImages', base + '.jpg')\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\n        imgviz.io.imsave(out_img_file, img)\n        data['images'].append(dict(license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id))\n        masks = {}\n        segmentations = collections.defaultdict(list)\n        for shape in label_file.shapes:\n            points = shape['points']\n            label = shape['label']\n            group_id = shape.get('group_id')\n            shape_type = shape.get('shape_type', 'polygon')\n            mask = labelme.utils.shape_to_mask(img.shape[:2], points, shape_type)\n            if group_id is None:\n                group_id = uuid.uuid1()\n            instance = (label, group_id)\n            if instance in masks:\n                masks[instance] = masks[instance] | mask\n            else:\n                masks[instance] = mask\n            if shape_type == 'rectangle':\n                ((x1, y1), (x2, y2)) = points\n                (x1, x2) = sorted([x1, x2])\n                (y1, y2) = sorted([y1, y2])\n                points = [x1, y1, x2, y1, x2, y2, x1, y2]\n            if shape_type == 'circle':\n                ((x1, y1), (x2, y2)) = points\n                r = np.linalg.norm([x2 - x1, y2 - y1])\n                n_points_circle = max(int(np.pi / np.arccos(1 - 1 / r)), 12)\n                i = np.arange(n_points_circle)\n                x = x1 + r * np.sin(2 * np.pi / n_points_circle * i)\n                y = y1 + r * np.cos(2 * np.pi / n_points_circle * i)\n                points = np.stack((x, y), axis=1).flatten().tolist()\n            else:\n                points = np.asarray(points).flatten().tolist()\n            segmentations[instance].append(points)\n        segmentations = dict(segmentations)\n        for (instance, mask) in masks.items():\n            (cls_name, group_id) = instance\n            if cls_name not in class_name_to_id:\n                continue\n            cls_id = class_name_to_id[cls_name]\n            mask = np.asfortranarray(mask.astype(np.uint8))\n            mask = pycocotools.mask.encode(mask)\n            area = float(pycocotools.mask.area(mask))\n            bbox = pycocotools.mask.toBbox(mask).flatten().tolist()\n            data['annotations'].append(dict(id=len(data['annotations']), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0))\n        if not args.noviz:\n            viz = img\n            if masks:\n                (labels, captions, masks) = zip(*[(class_name_to_id[cnm], cnm, msk) for ((cnm, gid), msk) in masks.items() if cnm in class_name_to_id])\n                viz = imgviz.instances2rgb(image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2)\n            out_viz_file = osp.join(args.output_dir, 'Visualization', base + '.jpg')\n            imgviz.io.imsave(out_viz_file, viz)\n    with open(out_ann_file, 'w') as f:\n        json.dump(data, f)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input_dir', help='input annotated directory')\n    parser.add_argument('output_dir', help='output dataset directory')\n    parser.add_argument('--labels', help='labels file', required=True)\n    parser.add_argument('--noviz', help='no visualization', action='store_true')\n    args = parser.parse_args()\n    if osp.exists(args.output_dir):\n        print('Output directory already exists:', args.output_dir)\n        sys.exit(1)\n    os.makedirs(args.output_dir)\n    os.makedirs(osp.join(args.output_dir, 'JPEGImages'))\n    if not args.noviz:\n        os.makedirs(osp.join(args.output_dir, 'Visualization'))\n    print('Creating dataset:', args.output_dir)\n    now = datetime.datetime.now()\n    data = dict(info=dict(description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime('%Y-%m-%d %H:%M:%S.%f')), licenses=[dict(url=None, id=0, name=None)], images=[], type='instances', annotations=[], categories=[])\n    class_name_to_id = {}\n    for (i, line) in enumerate(open(args.labels).readlines()):\n        class_id = i - 1\n        class_name = line.strip()\n        if class_id == -1:\n            assert class_name == '__ignore__'\n            continue\n        class_name_to_id[class_name] = class_id\n        data['categories'].append(dict(supercategory=None, id=class_id, name=class_name))\n    out_ann_file = osp.join(args.output_dir, 'annotations.json')\n    label_files = glob.glob(osp.join(args.input_dir, '*.json'))\n    for (image_id, filename) in enumerate(label_files):\n        print('Generating dataset from:', filename)\n        label_file = labelme.LabelFile(filename=filename)\n        base = osp.splitext(osp.basename(filename))[0]\n        out_img_file = osp.join(args.output_dir, 'JPEGImages', base + '.jpg')\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\n        imgviz.io.imsave(out_img_file, img)\n        data['images'].append(dict(license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id))\n        masks = {}\n        segmentations = collections.defaultdict(list)\n        for shape in label_file.shapes:\n            points = shape['points']\n            label = shape['label']\n            group_id = shape.get('group_id')\n            shape_type = shape.get('shape_type', 'polygon')\n            mask = labelme.utils.shape_to_mask(img.shape[:2], points, shape_type)\n            if group_id is None:\n                group_id = uuid.uuid1()\n            instance = (label, group_id)\n            if instance in masks:\n                masks[instance] = masks[instance] | mask\n            else:\n                masks[instance] = mask\n            if shape_type == 'rectangle':\n                ((x1, y1), (x2, y2)) = points\n                (x1, x2) = sorted([x1, x2])\n                (y1, y2) = sorted([y1, y2])\n                points = [x1, y1, x2, y1, x2, y2, x1, y2]\n            if shape_type == 'circle':\n                ((x1, y1), (x2, y2)) = points\n                r = np.linalg.norm([x2 - x1, y2 - y1])\n                n_points_circle = max(int(np.pi / np.arccos(1 - 1 / r)), 12)\n                i = np.arange(n_points_circle)\n                x = x1 + r * np.sin(2 * np.pi / n_points_circle * i)\n                y = y1 + r * np.cos(2 * np.pi / n_points_circle * i)\n                points = np.stack((x, y), axis=1).flatten().tolist()\n            else:\n                points = np.asarray(points).flatten().tolist()\n            segmentations[instance].append(points)\n        segmentations = dict(segmentations)\n        for (instance, mask) in masks.items():\n            (cls_name, group_id) = instance\n            if cls_name not in class_name_to_id:\n                continue\n            cls_id = class_name_to_id[cls_name]\n            mask = np.asfortranarray(mask.astype(np.uint8))\n            mask = pycocotools.mask.encode(mask)\n            area = float(pycocotools.mask.area(mask))\n            bbox = pycocotools.mask.toBbox(mask).flatten().tolist()\n            data['annotations'].append(dict(id=len(data['annotations']), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0))\n        if not args.noviz:\n            viz = img\n            if masks:\n                (labels, captions, masks) = zip(*[(class_name_to_id[cnm], cnm, msk) for ((cnm, gid), msk) in masks.items() if cnm in class_name_to_id])\n                viz = imgviz.instances2rgb(image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2)\n            out_viz_file = osp.join(args.output_dir, 'Visualization', base + '.jpg')\n            imgviz.io.imsave(out_viz_file, viz)\n    with open(out_ann_file, 'w') as f:\n        json.dump(data, f)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument('input_dir', help='input annotated directory')\n    parser.add_argument('output_dir', help='output dataset directory')\n    parser.add_argument('--labels', help='labels file', required=True)\n    parser.add_argument('--noviz', help='no visualization', action='store_true')\n    args = parser.parse_args()\n    if osp.exists(args.output_dir):\n        print('Output directory already exists:', args.output_dir)\n        sys.exit(1)\n    os.makedirs(args.output_dir)\n    os.makedirs(osp.join(args.output_dir, 'JPEGImages'))\n    if not args.noviz:\n        os.makedirs(osp.join(args.output_dir, 'Visualization'))\n    print('Creating dataset:', args.output_dir)\n    now = datetime.datetime.now()\n    data = dict(info=dict(description=None, url=None, version=None, year=now.year, contributor=None, date_created=now.strftime('%Y-%m-%d %H:%M:%S.%f')), licenses=[dict(url=None, id=0, name=None)], images=[], type='instances', annotations=[], categories=[])\n    class_name_to_id = {}\n    for (i, line) in enumerate(open(args.labels).readlines()):\n        class_id = i - 1\n        class_name = line.strip()\n        if class_id == -1:\n            assert class_name == '__ignore__'\n            continue\n        class_name_to_id[class_name] = class_id\n        data['categories'].append(dict(supercategory=None, id=class_id, name=class_name))\n    out_ann_file = osp.join(args.output_dir, 'annotations.json')\n    label_files = glob.glob(osp.join(args.input_dir, '*.json'))\n    for (image_id, filename) in enumerate(label_files):\n        print('Generating dataset from:', filename)\n        label_file = labelme.LabelFile(filename=filename)\n        base = osp.splitext(osp.basename(filename))[0]\n        out_img_file = osp.join(args.output_dir, 'JPEGImages', base + '.jpg')\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\n        imgviz.io.imsave(out_img_file, img)\n        data['images'].append(dict(license=0, url=None, file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)), height=img.shape[0], width=img.shape[1], date_captured=None, id=image_id))\n        masks = {}\n        segmentations = collections.defaultdict(list)\n        for shape in label_file.shapes:\n            points = shape['points']\n            label = shape['label']\n            group_id = shape.get('group_id')\n            shape_type = shape.get('shape_type', 'polygon')\n            mask = labelme.utils.shape_to_mask(img.shape[:2], points, shape_type)\n            if group_id is None:\n                group_id = uuid.uuid1()\n            instance = (label, group_id)\n            if instance in masks:\n                masks[instance] = masks[instance] | mask\n            else:\n                masks[instance] = mask\n            if shape_type == 'rectangle':\n                ((x1, y1), (x2, y2)) = points\n                (x1, x2) = sorted([x1, x2])\n                (y1, y2) = sorted([y1, y2])\n                points = [x1, y1, x2, y1, x2, y2, x1, y2]\n            if shape_type == 'circle':\n                ((x1, y1), (x2, y2)) = points\n                r = np.linalg.norm([x2 - x1, y2 - y1])\n                n_points_circle = max(int(np.pi / np.arccos(1 - 1 / r)), 12)\n                i = np.arange(n_points_circle)\n                x = x1 + r * np.sin(2 * np.pi / n_points_circle * i)\n                y = y1 + r * np.cos(2 * np.pi / n_points_circle * i)\n                points = np.stack((x, y), axis=1).flatten().tolist()\n            else:\n                points = np.asarray(points).flatten().tolist()\n            segmentations[instance].append(points)\n        segmentations = dict(segmentations)\n        for (instance, mask) in masks.items():\n            (cls_name, group_id) = instance\n            if cls_name not in class_name_to_id:\n                continue\n            cls_id = class_name_to_id[cls_name]\n            mask = np.asfortranarray(mask.astype(np.uint8))\n            mask = pycocotools.mask.encode(mask)\n            area = float(pycocotools.mask.area(mask))\n            bbox = pycocotools.mask.toBbox(mask).flatten().tolist()\n            data['annotations'].append(dict(id=len(data['annotations']), image_id=image_id, category_id=cls_id, segmentation=segmentations[instance], area=area, bbox=bbox, iscrowd=0))\n        if not args.noviz:\n            viz = img\n            if masks:\n                (labels, captions, masks) = zip(*[(class_name_to_id[cnm], cnm, msk) for ((cnm, gid), msk) in masks.items() if cnm in class_name_to_id])\n                viz = imgviz.instances2rgb(image=img, labels=labels, masks=masks, captions=captions, font_size=15, line_width=2)\n            out_viz_file = osp.join(args.output_dir, 'Visualization', base + '.jpg')\n            imgviz.io.imsave(out_viz_file, viz)\n    with open(out_ann_file, 'w') as f:\n        json.dump(data, f)"
        ]
    }
]