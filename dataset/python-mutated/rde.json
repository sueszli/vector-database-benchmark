[
    {
        "func_name": "prde_normal_denom",
        "original": "def prde_normal_denom(fa, fd, G, DE):\n    \"\"\"\n    Parametric Risch Differential Equation - Normal part of the denominator.\n\n    Explanation\n    ===========\n\n    Given a derivation D on k[t] and f, g1, ..., gm in k(t) with f weakly\n    normalized with respect to t, return the tuple (a, b, G, h) such that\n    a, h in k[t], b in k<t>, G = [g1, ..., gm] in k(t)^m, and for any solution\n    c1, ..., cm in Const(k) and y in k(t) of Dy + f*y == Sum(ci*gi, (i, 1, m)),\n    q == y*h in k<t> satisfies a*Dq + b*q == Sum(ci*Gi, (i, 1, m)).\n    \"\"\"\n    (dn, ds) = splitfactor(fd, DE)\n    (Gas, Gds) = list(zip(*G))\n    gd = reduce(lambda i, j: i.lcm(j), Gds, Poly(1, DE.t))\n    (en, es) = splitfactor(gd, DE)\n    p = dn.gcd(en)\n    h = en.gcd(en.diff(DE.t)).quo(p.gcd(p.diff(DE.t)))\n    a = dn * h\n    c = a * h\n    ba = a * fa - dn * derivation(h, DE) * fd\n    (ba, bd) = ba.cancel(fd, include=True)\n    G = [(c * A).cancel(D, include=True) for (A, D) in G]\n    return (a, (ba, bd), G, h)",
        "mutated": [
            "def prde_normal_denom(fa, fd, G, DE):\n    if False:\n        i = 10\n    '\\n    Parametric Risch Differential Equation - Normal part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t] and f, g1, ..., gm in k(t) with f weakly\\n    normalized with respect to t, return the tuple (a, b, G, h) such that\\n    a, h in k[t], b in k<t>, G = [g1, ..., gm] in k(t)^m, and for any solution\\n    c1, ..., cm in Const(k) and y in k(t) of Dy + f*y == Sum(ci*gi, (i, 1, m)),\\n    q == y*h in k<t> satisfies a*Dq + b*q == Sum(ci*Gi, (i, 1, m)).\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    (Gas, Gds) = list(zip(*G))\n    gd = reduce(lambda i, j: i.lcm(j), Gds, Poly(1, DE.t))\n    (en, es) = splitfactor(gd, DE)\n    p = dn.gcd(en)\n    h = en.gcd(en.diff(DE.t)).quo(p.gcd(p.diff(DE.t)))\n    a = dn * h\n    c = a * h\n    ba = a * fa - dn * derivation(h, DE) * fd\n    (ba, bd) = ba.cancel(fd, include=True)\n    G = [(c * A).cancel(D, include=True) for (A, D) in G]\n    return (a, (ba, bd), G, h)",
            "def prde_normal_denom(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Parametric Risch Differential Equation - Normal part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t] and f, g1, ..., gm in k(t) with f weakly\\n    normalized with respect to t, return the tuple (a, b, G, h) such that\\n    a, h in k[t], b in k<t>, G = [g1, ..., gm] in k(t)^m, and for any solution\\n    c1, ..., cm in Const(k) and y in k(t) of Dy + f*y == Sum(ci*gi, (i, 1, m)),\\n    q == y*h in k<t> satisfies a*Dq + b*q == Sum(ci*Gi, (i, 1, m)).\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    (Gas, Gds) = list(zip(*G))\n    gd = reduce(lambda i, j: i.lcm(j), Gds, Poly(1, DE.t))\n    (en, es) = splitfactor(gd, DE)\n    p = dn.gcd(en)\n    h = en.gcd(en.diff(DE.t)).quo(p.gcd(p.diff(DE.t)))\n    a = dn * h\n    c = a * h\n    ba = a * fa - dn * derivation(h, DE) * fd\n    (ba, bd) = ba.cancel(fd, include=True)\n    G = [(c * A).cancel(D, include=True) for (A, D) in G]\n    return (a, (ba, bd), G, h)",
            "def prde_normal_denom(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Parametric Risch Differential Equation - Normal part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t] and f, g1, ..., gm in k(t) with f weakly\\n    normalized with respect to t, return the tuple (a, b, G, h) such that\\n    a, h in k[t], b in k<t>, G = [g1, ..., gm] in k(t)^m, and for any solution\\n    c1, ..., cm in Const(k) and y in k(t) of Dy + f*y == Sum(ci*gi, (i, 1, m)),\\n    q == y*h in k<t> satisfies a*Dq + b*q == Sum(ci*Gi, (i, 1, m)).\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    (Gas, Gds) = list(zip(*G))\n    gd = reduce(lambda i, j: i.lcm(j), Gds, Poly(1, DE.t))\n    (en, es) = splitfactor(gd, DE)\n    p = dn.gcd(en)\n    h = en.gcd(en.diff(DE.t)).quo(p.gcd(p.diff(DE.t)))\n    a = dn * h\n    c = a * h\n    ba = a * fa - dn * derivation(h, DE) * fd\n    (ba, bd) = ba.cancel(fd, include=True)\n    G = [(c * A).cancel(D, include=True) for (A, D) in G]\n    return (a, (ba, bd), G, h)",
            "def prde_normal_denom(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Parametric Risch Differential Equation - Normal part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t] and f, g1, ..., gm in k(t) with f weakly\\n    normalized with respect to t, return the tuple (a, b, G, h) such that\\n    a, h in k[t], b in k<t>, G = [g1, ..., gm] in k(t)^m, and for any solution\\n    c1, ..., cm in Const(k) and y in k(t) of Dy + f*y == Sum(ci*gi, (i, 1, m)),\\n    q == y*h in k<t> satisfies a*Dq + b*q == Sum(ci*Gi, (i, 1, m)).\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    (Gas, Gds) = list(zip(*G))\n    gd = reduce(lambda i, j: i.lcm(j), Gds, Poly(1, DE.t))\n    (en, es) = splitfactor(gd, DE)\n    p = dn.gcd(en)\n    h = en.gcd(en.diff(DE.t)).quo(p.gcd(p.diff(DE.t)))\n    a = dn * h\n    c = a * h\n    ba = a * fa - dn * derivation(h, DE) * fd\n    (ba, bd) = ba.cancel(fd, include=True)\n    G = [(c * A).cancel(D, include=True) for (A, D) in G]\n    return (a, (ba, bd), G, h)",
            "def prde_normal_denom(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Parametric Risch Differential Equation - Normal part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t] and f, g1, ..., gm in k(t) with f weakly\\n    normalized with respect to t, return the tuple (a, b, G, h) such that\\n    a, h in k[t], b in k<t>, G = [g1, ..., gm] in k(t)^m, and for any solution\\n    c1, ..., cm in Const(k) and y in k(t) of Dy + f*y == Sum(ci*gi, (i, 1, m)),\\n    q == y*h in k<t> satisfies a*Dq + b*q == Sum(ci*Gi, (i, 1, m)).\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    (Gas, Gds) = list(zip(*G))\n    gd = reduce(lambda i, j: i.lcm(j), Gds, Poly(1, DE.t))\n    (en, es) = splitfactor(gd, DE)\n    p = dn.gcd(en)\n    h = en.gcd(en.diff(DE.t)).quo(p.gcd(p.diff(DE.t)))\n    a = dn * h\n    c = a * h\n    ba = a * fa - dn * derivation(h, DE) * fd\n    (ba, bd) = ba.cancel(fd, include=True)\n    G = [(c * A).cancel(D, include=True) for (A, D) in G]\n    return (a, (ba, bd), G, h)"
        ]
    },
    {
        "func_name": "real_imag",
        "original": "def real_imag(ba, bd, gen):\n    \"\"\"\n    Helper function, to get the real and imaginary part of a rational function\n    evaluated at sqrt(-1) without actually evaluating it at sqrt(-1).\n\n    Explanation\n    ===========\n\n    Separates the even and odd power terms by checking the degree of terms wrt\n    mod 4. Returns a tuple (ba[0], ba[1], bd) where ba[0] is real part\n    of the numerator ba[1] is the imaginary part and bd is the denominator\n    of the rational function.\n    \"\"\"\n    bd = bd.as_poly(gen).as_dict()\n    ba = ba.as_poly(gen).as_dict()\n    denom_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in bd.items()]\n    denom_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in bd.items()]\n    bd_real = sum((r for r in denom_real))\n    bd_imag = sum((r for r in denom_imag))\n    num_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in ba.items()]\n    num_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in ba.items()]\n    ba_real = sum((r for r in num_real))\n    ba_imag = sum((r for r in num_imag))\n    ba = ((ba_real * bd_real + ba_imag * bd_imag).as_poly(gen), (ba_imag * bd_real - ba_real * bd_imag).as_poly(gen))\n    bd = (bd_real * bd_real + bd_imag * bd_imag).as_poly(gen)\n    return (ba[0], ba[1], bd)",
        "mutated": [
            "def real_imag(ba, bd, gen):\n    if False:\n        i = 10\n    '\\n    Helper function, to get the real and imaginary part of a rational function\\n    evaluated at sqrt(-1) without actually evaluating it at sqrt(-1).\\n\\n    Explanation\\n    ===========\\n\\n    Separates the even and odd power terms by checking the degree of terms wrt\\n    mod 4. Returns a tuple (ba[0], ba[1], bd) where ba[0] is real part\\n    of the numerator ba[1] is the imaginary part and bd is the denominator\\n    of the rational function.\\n    '\n    bd = bd.as_poly(gen).as_dict()\n    ba = ba.as_poly(gen).as_dict()\n    denom_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in bd.items()]\n    denom_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in bd.items()]\n    bd_real = sum((r for r in denom_real))\n    bd_imag = sum((r for r in denom_imag))\n    num_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in ba.items()]\n    num_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in ba.items()]\n    ba_real = sum((r for r in num_real))\n    ba_imag = sum((r for r in num_imag))\n    ba = ((ba_real * bd_real + ba_imag * bd_imag).as_poly(gen), (ba_imag * bd_real - ba_real * bd_imag).as_poly(gen))\n    bd = (bd_real * bd_real + bd_imag * bd_imag).as_poly(gen)\n    return (ba[0], ba[1], bd)",
            "def real_imag(ba, bd, gen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper function, to get the real and imaginary part of a rational function\\n    evaluated at sqrt(-1) without actually evaluating it at sqrt(-1).\\n\\n    Explanation\\n    ===========\\n\\n    Separates the even and odd power terms by checking the degree of terms wrt\\n    mod 4. Returns a tuple (ba[0], ba[1], bd) where ba[0] is real part\\n    of the numerator ba[1] is the imaginary part and bd is the denominator\\n    of the rational function.\\n    '\n    bd = bd.as_poly(gen).as_dict()\n    ba = ba.as_poly(gen).as_dict()\n    denom_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in bd.items()]\n    denom_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in bd.items()]\n    bd_real = sum((r for r in denom_real))\n    bd_imag = sum((r for r in denom_imag))\n    num_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in ba.items()]\n    num_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in ba.items()]\n    ba_real = sum((r for r in num_real))\n    ba_imag = sum((r for r in num_imag))\n    ba = ((ba_real * bd_real + ba_imag * bd_imag).as_poly(gen), (ba_imag * bd_real - ba_real * bd_imag).as_poly(gen))\n    bd = (bd_real * bd_real + bd_imag * bd_imag).as_poly(gen)\n    return (ba[0], ba[1], bd)",
            "def real_imag(ba, bd, gen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper function, to get the real and imaginary part of a rational function\\n    evaluated at sqrt(-1) without actually evaluating it at sqrt(-1).\\n\\n    Explanation\\n    ===========\\n\\n    Separates the even and odd power terms by checking the degree of terms wrt\\n    mod 4. Returns a tuple (ba[0], ba[1], bd) where ba[0] is real part\\n    of the numerator ba[1] is the imaginary part and bd is the denominator\\n    of the rational function.\\n    '\n    bd = bd.as_poly(gen).as_dict()\n    ba = ba.as_poly(gen).as_dict()\n    denom_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in bd.items()]\n    denom_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in bd.items()]\n    bd_real = sum((r for r in denom_real))\n    bd_imag = sum((r for r in denom_imag))\n    num_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in ba.items()]\n    num_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in ba.items()]\n    ba_real = sum((r for r in num_real))\n    ba_imag = sum((r for r in num_imag))\n    ba = ((ba_real * bd_real + ba_imag * bd_imag).as_poly(gen), (ba_imag * bd_real - ba_real * bd_imag).as_poly(gen))\n    bd = (bd_real * bd_real + bd_imag * bd_imag).as_poly(gen)\n    return (ba[0], ba[1], bd)",
            "def real_imag(ba, bd, gen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper function, to get the real and imaginary part of a rational function\\n    evaluated at sqrt(-1) without actually evaluating it at sqrt(-1).\\n\\n    Explanation\\n    ===========\\n\\n    Separates the even and odd power terms by checking the degree of terms wrt\\n    mod 4. Returns a tuple (ba[0], ba[1], bd) where ba[0] is real part\\n    of the numerator ba[1] is the imaginary part and bd is the denominator\\n    of the rational function.\\n    '\n    bd = bd.as_poly(gen).as_dict()\n    ba = ba.as_poly(gen).as_dict()\n    denom_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in bd.items()]\n    denom_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in bd.items()]\n    bd_real = sum((r for r in denom_real))\n    bd_imag = sum((r for r in denom_imag))\n    num_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in ba.items()]\n    num_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in ba.items()]\n    ba_real = sum((r for r in num_real))\n    ba_imag = sum((r for r in num_imag))\n    ba = ((ba_real * bd_real + ba_imag * bd_imag).as_poly(gen), (ba_imag * bd_real - ba_real * bd_imag).as_poly(gen))\n    bd = (bd_real * bd_real + bd_imag * bd_imag).as_poly(gen)\n    return (ba[0], ba[1], bd)",
            "def real_imag(ba, bd, gen):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper function, to get the real and imaginary part of a rational function\\n    evaluated at sqrt(-1) without actually evaluating it at sqrt(-1).\\n\\n    Explanation\\n    ===========\\n\\n    Separates the even and odd power terms by checking the degree of terms wrt\\n    mod 4. Returns a tuple (ba[0], ba[1], bd) where ba[0] is real part\\n    of the numerator ba[1] is the imaginary part and bd is the denominator\\n    of the rational function.\\n    '\n    bd = bd.as_poly(gen).as_dict()\n    ba = ba.as_poly(gen).as_dict()\n    denom_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in bd.items()]\n    denom_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in bd.items()]\n    bd_real = sum((r for r in denom_real))\n    bd_imag = sum((r for r in denom_imag))\n    num_real = [value if key[0] % 4 == 0 else -value if key[0] % 4 == 2 else 0 for (key, value) in ba.items()]\n    num_imag = [value if key[0] % 4 == 1 else -value if key[0] % 4 == 3 else 0 for (key, value) in ba.items()]\n    ba_real = sum((r for r in num_real))\n    ba_imag = sum((r for r in num_imag))\n    ba = ((ba_real * bd_real + ba_imag * bd_imag).as_poly(gen), (ba_imag * bd_real - ba_real * bd_imag).as_poly(gen))\n    bd = (bd_real * bd_real + bd_imag * bd_imag).as_poly(gen)\n    return (ba[0], ba[1], bd)"
        ]
    },
    {
        "func_name": "prde_special_denom",
        "original": "def prde_special_denom(a, ba, bd, G, DE, case='auto'):\n    \"\"\"\n    Parametric Risch Differential Equation - Special part of the denominator.\n\n    Explanation\n    ===========\n\n    Case is one of {'exp', 'tan', 'primitive'} for the hyperexponential,\n    hypertangent, and primitive cases, respectively.  For the hyperexponential\n    (resp. hypertangent) case, given a derivation D on k[t] and a in k[t],\n    b in k<t>, and g1, ..., gm in k(t) with Dt/t in k (resp. Dt/(t**2 + 1) in\n    k, sqrt(-1) not in k), a != 0, and gcd(a, t) == 1 (resp.\n    gcd(a, t**2 + 1) == 1), return the tuple (A, B, GG, h) such that A, B, h in\n    k[t], GG = [gg1, ..., ggm] in k(t)^m, and for any solution c1, ..., cm in\n    Const(k) and q in k<t> of a*Dq + b*q == Sum(ci*gi, (i, 1, m)), r == q*h in\n    k[t] satisfies A*Dr + B*r == Sum(ci*ggi, (i, 1, m)).\n\n    For case == 'primitive', k<t> == k[t], so it returns (a, b, G, 1) in this\n    case.\n    \"\"\"\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        p = Poly(DE.t, DE.t)\n    elif case == 'tan':\n        p = Poly(DE.t ** 2 + 1, DE.t)\n    elif case in ('primitive', 'base'):\n        B = ba.quo(bd)\n        return (a, B, G, Poly(1, DE.t))\n    else:\n        raise ValueError(\"case must be one of {'exp', 'tan', 'primitive', 'base'}, not %s.\" % case)\n    nb = order_at(ba, p, DE.t) - order_at(bd, p, DE.t)\n    nc = min([order_at(Ga, p, DE.t) - order_at(Gd, p, DE.t) for (Ga, Gd) in G])\n    n = min(0, nc - min(0, nb))\n    if not nb:\n        if case == 'exp':\n            dcoeff = DE.d.quo(Poly(DE.t, DE.t))\n            with DecrementLevel(DE):\n                (alphaa, alphad) = frac_in(-ba.eval(0) / bd.eval(0) / a.eval(0), DE.t)\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                if A is not None:\n                    (Q, m, z) = A\n                    if Q == 1:\n                        n = min(n, m)\n        elif case == 'tan':\n            dcoeff = DE.d.quo(Poly(DE.t ** 2 + 1, DE.t))\n            with DecrementLevel(DE):\n                (betaa, alphaa, alphad) = real_imag(ba, bd * a, DE.t)\n                betad = alphad\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                if recognize_log_derivative(Poly(2, DE.t) * betaa, betad, DE):\n                    A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                    B = parametric_log_deriv(betaa, betad, etaa, etad, DE)\n                    if A is not None and B is not None:\n                        (Q, s, z) = A\n                        if Q == 1:\n                            n = min(n, s / 2)\n    N = max(0, -nb)\n    pN = p ** N\n    pn = p ** (-n)\n    A = a * pN\n    B = ba * pN.quo(bd) + Poly(n, DE.t) * a * derivation(p, DE).quo(p) * pN\n    G = [(Ga * pN * pn).cancel(Gd, include=True) for (Ga, Gd) in G]\n    h = pn\n    return (A, B, G, h)",
        "mutated": [
            "def prde_special_denom(a, ba, bd, G, DE, case='auto'):\n    if False:\n        i = 10\n    \"\\n    Parametric Risch Differential Equation - Special part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Case is one of {'exp', 'tan', 'primitive'} for the hyperexponential,\\n    hypertangent, and primitive cases, respectively.  For the hyperexponential\\n    (resp. hypertangent) case, given a derivation D on k[t] and a in k[t],\\n    b in k<t>, and g1, ..., gm in k(t) with Dt/t in k (resp. Dt/(t**2 + 1) in\\n    k, sqrt(-1) not in k), a != 0, and gcd(a, t) == 1 (resp.\\n    gcd(a, t**2 + 1) == 1), return the tuple (A, B, GG, h) such that A, B, h in\\n    k[t], GG = [gg1, ..., ggm] in k(t)^m, and for any solution c1, ..., cm in\\n    Const(k) and q in k<t> of a*Dq + b*q == Sum(ci*gi, (i, 1, m)), r == q*h in\\n    k[t] satisfies A*Dr + B*r == Sum(ci*ggi, (i, 1, m)).\\n\\n    For case == 'primitive', k<t> == k[t], so it returns (a, b, G, 1) in this\\n    case.\\n    \"\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        p = Poly(DE.t, DE.t)\n    elif case == 'tan':\n        p = Poly(DE.t ** 2 + 1, DE.t)\n    elif case in ('primitive', 'base'):\n        B = ba.quo(bd)\n        return (a, B, G, Poly(1, DE.t))\n    else:\n        raise ValueError(\"case must be one of {'exp', 'tan', 'primitive', 'base'}, not %s.\" % case)\n    nb = order_at(ba, p, DE.t) - order_at(bd, p, DE.t)\n    nc = min([order_at(Ga, p, DE.t) - order_at(Gd, p, DE.t) for (Ga, Gd) in G])\n    n = min(0, nc - min(0, nb))\n    if not nb:\n        if case == 'exp':\n            dcoeff = DE.d.quo(Poly(DE.t, DE.t))\n            with DecrementLevel(DE):\n                (alphaa, alphad) = frac_in(-ba.eval(0) / bd.eval(0) / a.eval(0), DE.t)\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                if A is not None:\n                    (Q, m, z) = A\n                    if Q == 1:\n                        n = min(n, m)\n        elif case == 'tan':\n            dcoeff = DE.d.quo(Poly(DE.t ** 2 + 1, DE.t))\n            with DecrementLevel(DE):\n                (betaa, alphaa, alphad) = real_imag(ba, bd * a, DE.t)\n                betad = alphad\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                if recognize_log_derivative(Poly(2, DE.t) * betaa, betad, DE):\n                    A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                    B = parametric_log_deriv(betaa, betad, etaa, etad, DE)\n                    if A is not None and B is not None:\n                        (Q, s, z) = A\n                        if Q == 1:\n                            n = min(n, s / 2)\n    N = max(0, -nb)\n    pN = p ** N\n    pn = p ** (-n)\n    A = a * pN\n    B = ba * pN.quo(bd) + Poly(n, DE.t) * a * derivation(p, DE).quo(p) * pN\n    G = [(Ga * pN * pn).cancel(Gd, include=True) for (Ga, Gd) in G]\n    h = pn\n    return (A, B, G, h)",
            "def prde_special_denom(a, ba, bd, G, DE, case='auto'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Parametric Risch Differential Equation - Special part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Case is one of {'exp', 'tan', 'primitive'} for the hyperexponential,\\n    hypertangent, and primitive cases, respectively.  For the hyperexponential\\n    (resp. hypertangent) case, given a derivation D on k[t] and a in k[t],\\n    b in k<t>, and g1, ..., gm in k(t) with Dt/t in k (resp. Dt/(t**2 + 1) in\\n    k, sqrt(-1) not in k), a != 0, and gcd(a, t) == 1 (resp.\\n    gcd(a, t**2 + 1) == 1), return the tuple (A, B, GG, h) such that A, B, h in\\n    k[t], GG = [gg1, ..., ggm] in k(t)^m, and for any solution c1, ..., cm in\\n    Const(k) and q in k<t> of a*Dq + b*q == Sum(ci*gi, (i, 1, m)), r == q*h in\\n    k[t] satisfies A*Dr + B*r == Sum(ci*ggi, (i, 1, m)).\\n\\n    For case == 'primitive', k<t> == k[t], so it returns (a, b, G, 1) in this\\n    case.\\n    \"\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        p = Poly(DE.t, DE.t)\n    elif case == 'tan':\n        p = Poly(DE.t ** 2 + 1, DE.t)\n    elif case in ('primitive', 'base'):\n        B = ba.quo(bd)\n        return (a, B, G, Poly(1, DE.t))\n    else:\n        raise ValueError(\"case must be one of {'exp', 'tan', 'primitive', 'base'}, not %s.\" % case)\n    nb = order_at(ba, p, DE.t) - order_at(bd, p, DE.t)\n    nc = min([order_at(Ga, p, DE.t) - order_at(Gd, p, DE.t) for (Ga, Gd) in G])\n    n = min(0, nc - min(0, nb))\n    if not nb:\n        if case == 'exp':\n            dcoeff = DE.d.quo(Poly(DE.t, DE.t))\n            with DecrementLevel(DE):\n                (alphaa, alphad) = frac_in(-ba.eval(0) / bd.eval(0) / a.eval(0), DE.t)\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                if A is not None:\n                    (Q, m, z) = A\n                    if Q == 1:\n                        n = min(n, m)\n        elif case == 'tan':\n            dcoeff = DE.d.quo(Poly(DE.t ** 2 + 1, DE.t))\n            with DecrementLevel(DE):\n                (betaa, alphaa, alphad) = real_imag(ba, bd * a, DE.t)\n                betad = alphad\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                if recognize_log_derivative(Poly(2, DE.t) * betaa, betad, DE):\n                    A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                    B = parametric_log_deriv(betaa, betad, etaa, etad, DE)\n                    if A is not None and B is not None:\n                        (Q, s, z) = A\n                        if Q == 1:\n                            n = min(n, s / 2)\n    N = max(0, -nb)\n    pN = p ** N\n    pn = p ** (-n)\n    A = a * pN\n    B = ba * pN.quo(bd) + Poly(n, DE.t) * a * derivation(p, DE).quo(p) * pN\n    G = [(Ga * pN * pn).cancel(Gd, include=True) for (Ga, Gd) in G]\n    h = pn\n    return (A, B, G, h)",
            "def prde_special_denom(a, ba, bd, G, DE, case='auto'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Parametric Risch Differential Equation - Special part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Case is one of {'exp', 'tan', 'primitive'} for the hyperexponential,\\n    hypertangent, and primitive cases, respectively.  For the hyperexponential\\n    (resp. hypertangent) case, given a derivation D on k[t] and a in k[t],\\n    b in k<t>, and g1, ..., gm in k(t) with Dt/t in k (resp. Dt/(t**2 + 1) in\\n    k, sqrt(-1) not in k), a != 0, and gcd(a, t) == 1 (resp.\\n    gcd(a, t**2 + 1) == 1), return the tuple (A, B, GG, h) such that A, B, h in\\n    k[t], GG = [gg1, ..., ggm] in k(t)^m, and for any solution c1, ..., cm in\\n    Const(k) and q in k<t> of a*Dq + b*q == Sum(ci*gi, (i, 1, m)), r == q*h in\\n    k[t] satisfies A*Dr + B*r == Sum(ci*ggi, (i, 1, m)).\\n\\n    For case == 'primitive', k<t> == k[t], so it returns (a, b, G, 1) in this\\n    case.\\n    \"\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        p = Poly(DE.t, DE.t)\n    elif case == 'tan':\n        p = Poly(DE.t ** 2 + 1, DE.t)\n    elif case in ('primitive', 'base'):\n        B = ba.quo(bd)\n        return (a, B, G, Poly(1, DE.t))\n    else:\n        raise ValueError(\"case must be one of {'exp', 'tan', 'primitive', 'base'}, not %s.\" % case)\n    nb = order_at(ba, p, DE.t) - order_at(bd, p, DE.t)\n    nc = min([order_at(Ga, p, DE.t) - order_at(Gd, p, DE.t) for (Ga, Gd) in G])\n    n = min(0, nc - min(0, nb))\n    if not nb:\n        if case == 'exp':\n            dcoeff = DE.d.quo(Poly(DE.t, DE.t))\n            with DecrementLevel(DE):\n                (alphaa, alphad) = frac_in(-ba.eval(0) / bd.eval(0) / a.eval(0), DE.t)\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                if A is not None:\n                    (Q, m, z) = A\n                    if Q == 1:\n                        n = min(n, m)\n        elif case == 'tan':\n            dcoeff = DE.d.quo(Poly(DE.t ** 2 + 1, DE.t))\n            with DecrementLevel(DE):\n                (betaa, alphaa, alphad) = real_imag(ba, bd * a, DE.t)\n                betad = alphad\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                if recognize_log_derivative(Poly(2, DE.t) * betaa, betad, DE):\n                    A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                    B = parametric_log_deriv(betaa, betad, etaa, etad, DE)\n                    if A is not None and B is not None:\n                        (Q, s, z) = A\n                        if Q == 1:\n                            n = min(n, s / 2)\n    N = max(0, -nb)\n    pN = p ** N\n    pn = p ** (-n)\n    A = a * pN\n    B = ba * pN.quo(bd) + Poly(n, DE.t) * a * derivation(p, DE).quo(p) * pN\n    G = [(Ga * pN * pn).cancel(Gd, include=True) for (Ga, Gd) in G]\n    h = pn\n    return (A, B, G, h)",
            "def prde_special_denom(a, ba, bd, G, DE, case='auto'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Parametric Risch Differential Equation - Special part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Case is one of {'exp', 'tan', 'primitive'} for the hyperexponential,\\n    hypertangent, and primitive cases, respectively.  For the hyperexponential\\n    (resp. hypertangent) case, given a derivation D on k[t] and a in k[t],\\n    b in k<t>, and g1, ..., gm in k(t) with Dt/t in k (resp. Dt/(t**2 + 1) in\\n    k, sqrt(-1) not in k), a != 0, and gcd(a, t) == 1 (resp.\\n    gcd(a, t**2 + 1) == 1), return the tuple (A, B, GG, h) such that A, B, h in\\n    k[t], GG = [gg1, ..., ggm] in k(t)^m, and for any solution c1, ..., cm in\\n    Const(k) and q in k<t> of a*Dq + b*q == Sum(ci*gi, (i, 1, m)), r == q*h in\\n    k[t] satisfies A*Dr + B*r == Sum(ci*ggi, (i, 1, m)).\\n\\n    For case == 'primitive', k<t> == k[t], so it returns (a, b, G, 1) in this\\n    case.\\n    \"\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        p = Poly(DE.t, DE.t)\n    elif case == 'tan':\n        p = Poly(DE.t ** 2 + 1, DE.t)\n    elif case in ('primitive', 'base'):\n        B = ba.quo(bd)\n        return (a, B, G, Poly(1, DE.t))\n    else:\n        raise ValueError(\"case must be one of {'exp', 'tan', 'primitive', 'base'}, not %s.\" % case)\n    nb = order_at(ba, p, DE.t) - order_at(bd, p, DE.t)\n    nc = min([order_at(Ga, p, DE.t) - order_at(Gd, p, DE.t) for (Ga, Gd) in G])\n    n = min(0, nc - min(0, nb))\n    if not nb:\n        if case == 'exp':\n            dcoeff = DE.d.quo(Poly(DE.t, DE.t))\n            with DecrementLevel(DE):\n                (alphaa, alphad) = frac_in(-ba.eval(0) / bd.eval(0) / a.eval(0), DE.t)\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                if A is not None:\n                    (Q, m, z) = A\n                    if Q == 1:\n                        n = min(n, m)\n        elif case == 'tan':\n            dcoeff = DE.d.quo(Poly(DE.t ** 2 + 1, DE.t))\n            with DecrementLevel(DE):\n                (betaa, alphaa, alphad) = real_imag(ba, bd * a, DE.t)\n                betad = alphad\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                if recognize_log_derivative(Poly(2, DE.t) * betaa, betad, DE):\n                    A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                    B = parametric_log_deriv(betaa, betad, etaa, etad, DE)\n                    if A is not None and B is not None:\n                        (Q, s, z) = A\n                        if Q == 1:\n                            n = min(n, s / 2)\n    N = max(0, -nb)\n    pN = p ** N\n    pn = p ** (-n)\n    A = a * pN\n    B = ba * pN.quo(bd) + Poly(n, DE.t) * a * derivation(p, DE).quo(p) * pN\n    G = [(Ga * pN * pn).cancel(Gd, include=True) for (Ga, Gd) in G]\n    h = pn\n    return (A, B, G, h)",
            "def prde_special_denom(a, ba, bd, G, DE, case='auto'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Parametric Risch Differential Equation - Special part of the denominator.\\n\\n    Explanation\\n    ===========\\n\\n    Case is one of {'exp', 'tan', 'primitive'} for the hyperexponential,\\n    hypertangent, and primitive cases, respectively.  For the hyperexponential\\n    (resp. hypertangent) case, given a derivation D on k[t] and a in k[t],\\n    b in k<t>, and g1, ..., gm in k(t) with Dt/t in k (resp. Dt/(t**2 + 1) in\\n    k, sqrt(-1) not in k), a != 0, and gcd(a, t) == 1 (resp.\\n    gcd(a, t**2 + 1) == 1), return the tuple (A, B, GG, h) such that A, B, h in\\n    k[t], GG = [gg1, ..., ggm] in k(t)^m, and for any solution c1, ..., cm in\\n    Const(k) and q in k<t> of a*Dq + b*q == Sum(ci*gi, (i, 1, m)), r == q*h in\\n    k[t] satisfies A*Dr + B*r == Sum(ci*ggi, (i, 1, m)).\\n\\n    For case == 'primitive', k<t> == k[t], so it returns (a, b, G, 1) in this\\n    case.\\n    \"\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        p = Poly(DE.t, DE.t)\n    elif case == 'tan':\n        p = Poly(DE.t ** 2 + 1, DE.t)\n    elif case in ('primitive', 'base'):\n        B = ba.quo(bd)\n        return (a, B, G, Poly(1, DE.t))\n    else:\n        raise ValueError(\"case must be one of {'exp', 'tan', 'primitive', 'base'}, not %s.\" % case)\n    nb = order_at(ba, p, DE.t) - order_at(bd, p, DE.t)\n    nc = min([order_at(Ga, p, DE.t) - order_at(Gd, p, DE.t) for (Ga, Gd) in G])\n    n = min(0, nc - min(0, nb))\n    if not nb:\n        if case == 'exp':\n            dcoeff = DE.d.quo(Poly(DE.t, DE.t))\n            with DecrementLevel(DE):\n                (alphaa, alphad) = frac_in(-ba.eval(0) / bd.eval(0) / a.eval(0), DE.t)\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                if A is not None:\n                    (Q, m, z) = A\n                    if Q == 1:\n                        n = min(n, m)\n        elif case == 'tan':\n            dcoeff = DE.d.quo(Poly(DE.t ** 2 + 1, DE.t))\n            with DecrementLevel(DE):\n                (betaa, alphaa, alphad) = real_imag(ba, bd * a, DE.t)\n                betad = alphad\n                (etaa, etad) = frac_in(dcoeff, DE.t)\n                if recognize_log_derivative(Poly(2, DE.t) * betaa, betad, DE):\n                    A = parametric_log_deriv(alphaa, alphad, etaa, etad, DE)\n                    B = parametric_log_deriv(betaa, betad, etaa, etad, DE)\n                    if A is not None and B is not None:\n                        (Q, s, z) = A\n                        if Q == 1:\n                            n = min(n, s / 2)\n    N = max(0, -nb)\n    pN = p ** N\n    pn = p ** (-n)\n    A = a * pN\n    B = ba * pN.quo(bd) + Poly(n, DE.t) * a * derivation(p, DE).quo(p) * pN\n    G = [(Ga * pN * pn).cancel(Gd, include=True) for (Ga, Gd) in G]\n    h = pn\n    return (A, B, G, h)"
        ]
    },
    {
        "func_name": "prde_linear_constraints",
        "original": "def prde_linear_constraints(a, b, G, DE):\n    \"\"\"\n    Parametric Risch Differential Equation - Generate linear constraints on the constants.\n\n    Explanation\n    ===========\n\n    Given a derivation D on k[t], a, b, in k[t] with gcd(a, b) == 1, and\n    G = [g1, ..., gm] in k(t)^m, return Q = [q1, ..., qm] in k[t]^m and a\n    matrix M with entries in k(t) such that for any solution c1, ..., cm in\n    Const(k) and p in k[t] of a*Dp + b*p == Sum(ci*gi, (i, 1, m)),\n    (c1, ..., cm) is a solution of Mx == 0, and p and the ci satisfy\n    a*Dp + b*p == Sum(ci*qi, (i, 1, m)).\n\n    Because M has entries in k(t), and because Matrix does not play well with\n    Poly, M will be a Matrix of Basic expressions.\n    \"\"\"\n    m = len(G)\n    (Gns, Gds) = list(zip(*G))\n    d = reduce(lambda i, j: i.lcm(j), Gds)\n    d = Poly(d, field=True)\n    Q = [(ga * d.quo(gd)).div(d) for (ga, gd) in G]\n    if not all((ri.is_zero for (_, ri) in Q)):\n        N = max((ri.degree(DE.t) for (_, ri) in Q))\n        M = Matrix(N + 1, m, lambda i, j: Q[j][1].nth(i), DE.t)\n    else:\n        M = Matrix(0, m, [], DE.t)\n    (qs, _) = list(zip(*Q))\n    return (qs, M)",
        "mutated": [
            "def prde_linear_constraints(a, b, G, DE):\n    if False:\n        i = 10\n    '\\n    Parametric Risch Differential Equation - Generate linear constraints on the constants.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], a, b, in k[t] with gcd(a, b) == 1, and\\n    G = [g1, ..., gm] in k(t)^m, return Q = [q1, ..., qm] in k[t]^m and a\\n    matrix M with entries in k(t) such that for any solution c1, ..., cm in\\n    Const(k) and p in k[t] of a*Dp + b*p == Sum(ci*gi, (i, 1, m)),\\n    (c1, ..., cm) is a solution of Mx == 0, and p and the ci satisfy\\n    a*Dp + b*p == Sum(ci*qi, (i, 1, m)).\\n\\n    Because M has entries in k(t), and because Matrix does not play well with\\n    Poly, M will be a Matrix of Basic expressions.\\n    '\n    m = len(G)\n    (Gns, Gds) = list(zip(*G))\n    d = reduce(lambda i, j: i.lcm(j), Gds)\n    d = Poly(d, field=True)\n    Q = [(ga * d.quo(gd)).div(d) for (ga, gd) in G]\n    if not all((ri.is_zero for (_, ri) in Q)):\n        N = max((ri.degree(DE.t) for (_, ri) in Q))\n        M = Matrix(N + 1, m, lambda i, j: Q[j][1].nth(i), DE.t)\n    else:\n        M = Matrix(0, m, [], DE.t)\n    (qs, _) = list(zip(*Q))\n    return (qs, M)",
            "def prde_linear_constraints(a, b, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Parametric Risch Differential Equation - Generate linear constraints on the constants.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], a, b, in k[t] with gcd(a, b) == 1, and\\n    G = [g1, ..., gm] in k(t)^m, return Q = [q1, ..., qm] in k[t]^m and a\\n    matrix M with entries in k(t) such that for any solution c1, ..., cm in\\n    Const(k) and p in k[t] of a*Dp + b*p == Sum(ci*gi, (i, 1, m)),\\n    (c1, ..., cm) is a solution of Mx == 0, and p and the ci satisfy\\n    a*Dp + b*p == Sum(ci*qi, (i, 1, m)).\\n\\n    Because M has entries in k(t), and because Matrix does not play well with\\n    Poly, M will be a Matrix of Basic expressions.\\n    '\n    m = len(G)\n    (Gns, Gds) = list(zip(*G))\n    d = reduce(lambda i, j: i.lcm(j), Gds)\n    d = Poly(d, field=True)\n    Q = [(ga * d.quo(gd)).div(d) for (ga, gd) in G]\n    if not all((ri.is_zero for (_, ri) in Q)):\n        N = max((ri.degree(DE.t) for (_, ri) in Q))\n        M = Matrix(N + 1, m, lambda i, j: Q[j][1].nth(i), DE.t)\n    else:\n        M = Matrix(0, m, [], DE.t)\n    (qs, _) = list(zip(*Q))\n    return (qs, M)",
            "def prde_linear_constraints(a, b, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Parametric Risch Differential Equation - Generate linear constraints on the constants.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], a, b, in k[t] with gcd(a, b) == 1, and\\n    G = [g1, ..., gm] in k(t)^m, return Q = [q1, ..., qm] in k[t]^m and a\\n    matrix M with entries in k(t) such that for any solution c1, ..., cm in\\n    Const(k) and p in k[t] of a*Dp + b*p == Sum(ci*gi, (i, 1, m)),\\n    (c1, ..., cm) is a solution of Mx == 0, and p and the ci satisfy\\n    a*Dp + b*p == Sum(ci*qi, (i, 1, m)).\\n\\n    Because M has entries in k(t), and because Matrix does not play well with\\n    Poly, M will be a Matrix of Basic expressions.\\n    '\n    m = len(G)\n    (Gns, Gds) = list(zip(*G))\n    d = reduce(lambda i, j: i.lcm(j), Gds)\n    d = Poly(d, field=True)\n    Q = [(ga * d.quo(gd)).div(d) for (ga, gd) in G]\n    if not all((ri.is_zero for (_, ri) in Q)):\n        N = max((ri.degree(DE.t) for (_, ri) in Q))\n        M = Matrix(N + 1, m, lambda i, j: Q[j][1].nth(i), DE.t)\n    else:\n        M = Matrix(0, m, [], DE.t)\n    (qs, _) = list(zip(*Q))\n    return (qs, M)",
            "def prde_linear_constraints(a, b, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Parametric Risch Differential Equation - Generate linear constraints on the constants.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], a, b, in k[t] with gcd(a, b) == 1, and\\n    G = [g1, ..., gm] in k(t)^m, return Q = [q1, ..., qm] in k[t]^m and a\\n    matrix M with entries in k(t) such that for any solution c1, ..., cm in\\n    Const(k) and p in k[t] of a*Dp + b*p == Sum(ci*gi, (i, 1, m)),\\n    (c1, ..., cm) is a solution of Mx == 0, and p and the ci satisfy\\n    a*Dp + b*p == Sum(ci*qi, (i, 1, m)).\\n\\n    Because M has entries in k(t), and because Matrix does not play well with\\n    Poly, M will be a Matrix of Basic expressions.\\n    '\n    m = len(G)\n    (Gns, Gds) = list(zip(*G))\n    d = reduce(lambda i, j: i.lcm(j), Gds)\n    d = Poly(d, field=True)\n    Q = [(ga * d.quo(gd)).div(d) for (ga, gd) in G]\n    if not all((ri.is_zero for (_, ri) in Q)):\n        N = max((ri.degree(DE.t) for (_, ri) in Q))\n        M = Matrix(N + 1, m, lambda i, j: Q[j][1].nth(i), DE.t)\n    else:\n        M = Matrix(0, m, [], DE.t)\n    (qs, _) = list(zip(*Q))\n    return (qs, M)",
            "def prde_linear_constraints(a, b, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Parametric Risch Differential Equation - Generate linear constraints on the constants.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], a, b, in k[t] with gcd(a, b) == 1, and\\n    G = [g1, ..., gm] in k(t)^m, return Q = [q1, ..., qm] in k[t]^m and a\\n    matrix M with entries in k(t) such that for any solution c1, ..., cm in\\n    Const(k) and p in k[t] of a*Dp + b*p == Sum(ci*gi, (i, 1, m)),\\n    (c1, ..., cm) is a solution of Mx == 0, and p and the ci satisfy\\n    a*Dp + b*p == Sum(ci*qi, (i, 1, m)).\\n\\n    Because M has entries in k(t), and because Matrix does not play well with\\n    Poly, M will be a Matrix of Basic expressions.\\n    '\n    m = len(G)\n    (Gns, Gds) = list(zip(*G))\n    d = reduce(lambda i, j: i.lcm(j), Gds)\n    d = Poly(d, field=True)\n    Q = [(ga * d.quo(gd)).div(d) for (ga, gd) in G]\n    if not all((ri.is_zero for (_, ri) in Q)):\n        N = max((ri.degree(DE.t) for (_, ri) in Q))\n        M = Matrix(N + 1, m, lambda i, j: Q[j][1].nth(i), DE.t)\n    else:\n        M = Matrix(0, m, [], DE.t)\n    (qs, _) = list(zip(*Q))\n    return (qs, M)"
        ]
    },
    {
        "func_name": "poly_linear_constraints",
        "original": "def poly_linear_constraints(p, d):\n    \"\"\"\n    Given p = [p1, ..., pm] in k[t]^m and d in k[t], return\n    q = [q1, ..., qm] in k[t]^m and a matrix M with entries in k such\n    that Sum(ci*pi, (i, 1, m)), for c1, ..., cm in k, is divisible\n    by d if and only if (c1, ..., cm) is a solution of Mx = 0, in\n    which case the quotient is Sum(ci*qi, (i, 1, m)).\n    \"\"\"\n    m = len(p)\n    (q, r) = zip(*[pi.div(d) for pi in p])\n    if not all((ri.is_zero for ri in r)):\n        n = max((ri.degree() for ri in r))\n        M = Matrix(n + 1, m, lambda i, j: r[j].nth(i), d.gens)\n    else:\n        M = Matrix(0, m, [], d.gens)\n    return (q, M)",
        "mutated": [
            "def poly_linear_constraints(p, d):\n    if False:\n        i = 10\n    '\\n    Given p = [p1, ..., pm] in k[t]^m and d in k[t], return\\n    q = [q1, ..., qm] in k[t]^m and a matrix M with entries in k such\\n    that Sum(ci*pi, (i, 1, m)), for c1, ..., cm in k, is divisible\\n    by d if and only if (c1, ..., cm) is a solution of Mx = 0, in\\n    which case the quotient is Sum(ci*qi, (i, 1, m)).\\n    '\n    m = len(p)\n    (q, r) = zip(*[pi.div(d) for pi in p])\n    if not all((ri.is_zero for ri in r)):\n        n = max((ri.degree() for ri in r))\n        M = Matrix(n + 1, m, lambda i, j: r[j].nth(i), d.gens)\n    else:\n        M = Matrix(0, m, [], d.gens)\n    return (q, M)",
            "def poly_linear_constraints(p, d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given p = [p1, ..., pm] in k[t]^m and d in k[t], return\\n    q = [q1, ..., qm] in k[t]^m and a matrix M with entries in k such\\n    that Sum(ci*pi, (i, 1, m)), for c1, ..., cm in k, is divisible\\n    by d if and only if (c1, ..., cm) is a solution of Mx = 0, in\\n    which case the quotient is Sum(ci*qi, (i, 1, m)).\\n    '\n    m = len(p)\n    (q, r) = zip(*[pi.div(d) for pi in p])\n    if not all((ri.is_zero for ri in r)):\n        n = max((ri.degree() for ri in r))\n        M = Matrix(n + 1, m, lambda i, j: r[j].nth(i), d.gens)\n    else:\n        M = Matrix(0, m, [], d.gens)\n    return (q, M)",
            "def poly_linear_constraints(p, d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given p = [p1, ..., pm] in k[t]^m and d in k[t], return\\n    q = [q1, ..., qm] in k[t]^m and a matrix M with entries in k such\\n    that Sum(ci*pi, (i, 1, m)), for c1, ..., cm in k, is divisible\\n    by d if and only if (c1, ..., cm) is a solution of Mx = 0, in\\n    which case the quotient is Sum(ci*qi, (i, 1, m)).\\n    '\n    m = len(p)\n    (q, r) = zip(*[pi.div(d) for pi in p])\n    if not all((ri.is_zero for ri in r)):\n        n = max((ri.degree() for ri in r))\n        M = Matrix(n + 1, m, lambda i, j: r[j].nth(i), d.gens)\n    else:\n        M = Matrix(0, m, [], d.gens)\n    return (q, M)",
            "def poly_linear_constraints(p, d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given p = [p1, ..., pm] in k[t]^m and d in k[t], return\\n    q = [q1, ..., qm] in k[t]^m and a matrix M with entries in k such\\n    that Sum(ci*pi, (i, 1, m)), for c1, ..., cm in k, is divisible\\n    by d if and only if (c1, ..., cm) is a solution of Mx = 0, in\\n    which case the quotient is Sum(ci*qi, (i, 1, m)).\\n    '\n    m = len(p)\n    (q, r) = zip(*[pi.div(d) for pi in p])\n    if not all((ri.is_zero for ri in r)):\n        n = max((ri.degree() for ri in r))\n        M = Matrix(n + 1, m, lambda i, j: r[j].nth(i), d.gens)\n    else:\n        M = Matrix(0, m, [], d.gens)\n    return (q, M)",
            "def poly_linear_constraints(p, d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given p = [p1, ..., pm] in k[t]^m and d in k[t], return\\n    q = [q1, ..., qm] in k[t]^m and a matrix M with entries in k such\\n    that Sum(ci*pi, (i, 1, m)), for c1, ..., cm in k, is divisible\\n    by d if and only if (c1, ..., cm) is a solution of Mx = 0, in\\n    which case the quotient is Sum(ci*qi, (i, 1, m)).\\n    '\n    m = len(p)\n    (q, r) = zip(*[pi.div(d) for pi in p])\n    if not all((ri.is_zero for ri in r)):\n        n = max((ri.degree() for ri in r))\n        M = Matrix(n + 1, m, lambda i, j: r[j].nth(i), d.gens)\n    else:\n        M = Matrix(0, m, [], d.gens)\n    return (q, M)"
        ]
    },
    {
        "func_name": "constant_system",
        "original": "def constant_system(A, u, DE):\n    \"\"\"\n    Generate a system for the constant solutions.\n\n    Explanation\n    ===========\n\n    Given a differential field (K, D) with constant field C = Const(K), a Matrix\n    A, and a vector (Matrix) u with coefficients in K, returns the tuple\n    (B, v, s), where B is a Matrix with coefficients in C and v is a vector\n    (Matrix) such that either v has coefficients in C, in which case s is True\n    and the solutions in C of Ax == u are exactly all the solutions of Bx == v,\n    or v has a non-constant coefficient, in which case s is False Ax == u has no\n    constant solution.\n\n    This algorithm is used both in solving parametric problems and in\n    determining if an element a of K is a derivative of an element of K or the\n    logarithmic derivative of a K-radical using the structure theorem approach.\n\n    Because Poly does not play well with Matrix yet, this algorithm assumes that\n    all matrix entries are Basic expressions.\n    \"\"\"\n    if not A:\n        return (A, u)\n    Au = A.row_join(u)\n    (Au, _) = Au.rref()\n    (A, u) = (Au[:, :-1], Au[:, -1])\n    D = lambda x: derivation(x, DE, basic=True)\n    for (j, i) in itertools.product(range(A.cols), range(A.rows)):\n        if A[i, j].expr.has(*DE.T):\n            Ri = A[i, :]\n            DAij = D(A[i, j])\n            Rm1 = Ri.applyfunc(lambda x: D(x) / DAij)\n            um1 = D(u[i]) / DAij\n            Aj = A[:, j]\n            A = A - Aj * Rm1\n            u = u - Aj * um1\n            A = A.col_join(Rm1)\n            u = u.col_join(Matrix([um1], u.gens))\n    return (A, u)",
        "mutated": [
            "def constant_system(A, u, DE):\n    if False:\n        i = 10\n    '\\n    Generate a system for the constant solutions.\\n\\n    Explanation\\n    ===========\\n\\n    Given a differential field (K, D) with constant field C = Const(K), a Matrix\\n    A, and a vector (Matrix) u with coefficients in K, returns the tuple\\n    (B, v, s), where B is a Matrix with coefficients in C and v is a vector\\n    (Matrix) such that either v has coefficients in C, in which case s is True\\n    and the solutions in C of Ax == u are exactly all the solutions of Bx == v,\\n    or v has a non-constant coefficient, in which case s is False Ax == u has no\\n    constant solution.\\n\\n    This algorithm is used both in solving parametric problems and in\\n    determining if an element a of K is a derivative of an element of K or the\\n    logarithmic derivative of a K-radical using the structure theorem approach.\\n\\n    Because Poly does not play well with Matrix yet, this algorithm assumes that\\n    all matrix entries are Basic expressions.\\n    '\n    if not A:\n        return (A, u)\n    Au = A.row_join(u)\n    (Au, _) = Au.rref()\n    (A, u) = (Au[:, :-1], Au[:, -1])\n    D = lambda x: derivation(x, DE, basic=True)\n    for (j, i) in itertools.product(range(A.cols), range(A.rows)):\n        if A[i, j].expr.has(*DE.T):\n            Ri = A[i, :]\n            DAij = D(A[i, j])\n            Rm1 = Ri.applyfunc(lambda x: D(x) / DAij)\n            um1 = D(u[i]) / DAij\n            Aj = A[:, j]\n            A = A - Aj * Rm1\n            u = u - Aj * um1\n            A = A.col_join(Rm1)\n            u = u.col_join(Matrix([um1], u.gens))\n    return (A, u)",
            "def constant_system(A, u, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate a system for the constant solutions.\\n\\n    Explanation\\n    ===========\\n\\n    Given a differential field (K, D) with constant field C = Const(K), a Matrix\\n    A, and a vector (Matrix) u with coefficients in K, returns the tuple\\n    (B, v, s), where B is a Matrix with coefficients in C and v is a vector\\n    (Matrix) such that either v has coefficients in C, in which case s is True\\n    and the solutions in C of Ax == u are exactly all the solutions of Bx == v,\\n    or v has a non-constant coefficient, in which case s is False Ax == u has no\\n    constant solution.\\n\\n    This algorithm is used both in solving parametric problems and in\\n    determining if an element a of K is a derivative of an element of K or the\\n    logarithmic derivative of a K-radical using the structure theorem approach.\\n\\n    Because Poly does not play well with Matrix yet, this algorithm assumes that\\n    all matrix entries are Basic expressions.\\n    '\n    if not A:\n        return (A, u)\n    Au = A.row_join(u)\n    (Au, _) = Au.rref()\n    (A, u) = (Au[:, :-1], Au[:, -1])\n    D = lambda x: derivation(x, DE, basic=True)\n    for (j, i) in itertools.product(range(A.cols), range(A.rows)):\n        if A[i, j].expr.has(*DE.T):\n            Ri = A[i, :]\n            DAij = D(A[i, j])\n            Rm1 = Ri.applyfunc(lambda x: D(x) / DAij)\n            um1 = D(u[i]) / DAij\n            Aj = A[:, j]\n            A = A - Aj * Rm1\n            u = u - Aj * um1\n            A = A.col_join(Rm1)\n            u = u.col_join(Matrix([um1], u.gens))\n    return (A, u)",
            "def constant_system(A, u, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate a system for the constant solutions.\\n\\n    Explanation\\n    ===========\\n\\n    Given a differential field (K, D) with constant field C = Const(K), a Matrix\\n    A, and a vector (Matrix) u with coefficients in K, returns the tuple\\n    (B, v, s), where B is a Matrix with coefficients in C and v is a vector\\n    (Matrix) such that either v has coefficients in C, in which case s is True\\n    and the solutions in C of Ax == u are exactly all the solutions of Bx == v,\\n    or v has a non-constant coefficient, in which case s is False Ax == u has no\\n    constant solution.\\n\\n    This algorithm is used both in solving parametric problems and in\\n    determining if an element a of K is a derivative of an element of K or the\\n    logarithmic derivative of a K-radical using the structure theorem approach.\\n\\n    Because Poly does not play well with Matrix yet, this algorithm assumes that\\n    all matrix entries are Basic expressions.\\n    '\n    if not A:\n        return (A, u)\n    Au = A.row_join(u)\n    (Au, _) = Au.rref()\n    (A, u) = (Au[:, :-1], Au[:, -1])\n    D = lambda x: derivation(x, DE, basic=True)\n    for (j, i) in itertools.product(range(A.cols), range(A.rows)):\n        if A[i, j].expr.has(*DE.T):\n            Ri = A[i, :]\n            DAij = D(A[i, j])\n            Rm1 = Ri.applyfunc(lambda x: D(x) / DAij)\n            um1 = D(u[i]) / DAij\n            Aj = A[:, j]\n            A = A - Aj * Rm1\n            u = u - Aj * um1\n            A = A.col_join(Rm1)\n            u = u.col_join(Matrix([um1], u.gens))\n    return (A, u)",
            "def constant_system(A, u, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate a system for the constant solutions.\\n\\n    Explanation\\n    ===========\\n\\n    Given a differential field (K, D) with constant field C = Const(K), a Matrix\\n    A, and a vector (Matrix) u with coefficients in K, returns the tuple\\n    (B, v, s), where B is a Matrix with coefficients in C and v is a vector\\n    (Matrix) such that either v has coefficients in C, in which case s is True\\n    and the solutions in C of Ax == u are exactly all the solutions of Bx == v,\\n    or v has a non-constant coefficient, in which case s is False Ax == u has no\\n    constant solution.\\n\\n    This algorithm is used both in solving parametric problems and in\\n    determining if an element a of K is a derivative of an element of K or the\\n    logarithmic derivative of a K-radical using the structure theorem approach.\\n\\n    Because Poly does not play well with Matrix yet, this algorithm assumes that\\n    all matrix entries are Basic expressions.\\n    '\n    if not A:\n        return (A, u)\n    Au = A.row_join(u)\n    (Au, _) = Au.rref()\n    (A, u) = (Au[:, :-1], Au[:, -1])\n    D = lambda x: derivation(x, DE, basic=True)\n    for (j, i) in itertools.product(range(A.cols), range(A.rows)):\n        if A[i, j].expr.has(*DE.T):\n            Ri = A[i, :]\n            DAij = D(A[i, j])\n            Rm1 = Ri.applyfunc(lambda x: D(x) / DAij)\n            um1 = D(u[i]) / DAij\n            Aj = A[:, j]\n            A = A - Aj * Rm1\n            u = u - Aj * um1\n            A = A.col_join(Rm1)\n            u = u.col_join(Matrix([um1], u.gens))\n    return (A, u)",
            "def constant_system(A, u, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate a system for the constant solutions.\\n\\n    Explanation\\n    ===========\\n\\n    Given a differential field (K, D) with constant field C = Const(K), a Matrix\\n    A, and a vector (Matrix) u with coefficients in K, returns the tuple\\n    (B, v, s), where B is a Matrix with coefficients in C and v is a vector\\n    (Matrix) such that either v has coefficients in C, in which case s is True\\n    and the solutions in C of Ax == u are exactly all the solutions of Bx == v,\\n    or v has a non-constant coefficient, in which case s is False Ax == u has no\\n    constant solution.\\n\\n    This algorithm is used both in solving parametric problems and in\\n    determining if an element a of K is a derivative of an element of K or the\\n    logarithmic derivative of a K-radical using the structure theorem approach.\\n\\n    Because Poly does not play well with Matrix yet, this algorithm assumes that\\n    all matrix entries are Basic expressions.\\n    '\n    if not A:\n        return (A, u)\n    Au = A.row_join(u)\n    (Au, _) = Au.rref()\n    (A, u) = (Au[:, :-1], Au[:, -1])\n    D = lambda x: derivation(x, DE, basic=True)\n    for (j, i) in itertools.product(range(A.cols), range(A.rows)):\n        if A[i, j].expr.has(*DE.T):\n            Ri = A[i, :]\n            DAij = D(A[i, j])\n            Rm1 = Ri.applyfunc(lambda x: D(x) / DAij)\n            um1 = D(u[i]) / DAij\n            Aj = A[:, j]\n            A = A - Aj * Rm1\n            u = u - Aj * um1\n            A = A.col_join(Rm1)\n            u = u.col_join(Matrix([um1], u.gens))\n    return (A, u)"
        ]
    },
    {
        "func_name": "prde_spde",
        "original": "def prde_spde(a, b, Q, n, DE):\n    \"\"\"\n    Special Polynomial Differential Equation algorithm: Parametric Version.\n\n    Explanation\n    ===========\n\n    Given a derivation D on k[t], an integer n, and a, b, q1, ..., qm in k[t]\n    with deg(a) > 0 and gcd(a, b) == 1, return (A, B, Q, R, n1), with\n    Qq = [q1, ..., qm] and R = [r1, ..., rm], such that for any solution\n    c1, ..., cm in Const(k) and q in k[t] of degree at most n of\n    a*Dq + b*q == Sum(ci*gi, (i, 1, m)), p = (q - Sum(ci*ri, (i, 1, m)))/a has\n    degree at most n1 and satisfies A*Dp + B*p == Sum(ci*qi, (i, 1, m))\n    \"\"\"\n    (R, Z) = list(zip(*[gcdex_diophantine(b, a, qi) for qi in Q]))\n    A = a\n    B = b + derivation(a, DE)\n    Qq = [zi - derivation(ri, DE) for (ri, zi) in zip(R, Z)]\n    R = list(R)\n    n1 = n - a.degree(DE.t)\n    return (A, B, Qq, R, n1)",
        "mutated": [
            "def prde_spde(a, b, Q, n, DE):\n    if False:\n        i = 10\n    '\\n    Special Polynomial Differential Equation algorithm: Parametric Version.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], an integer n, and a, b, q1, ..., qm in k[t]\\n    with deg(a) > 0 and gcd(a, b) == 1, return (A, B, Q, R, n1), with\\n    Qq = [q1, ..., qm] and R = [r1, ..., rm], such that for any solution\\n    c1, ..., cm in Const(k) and q in k[t] of degree at most n of\\n    a*Dq + b*q == Sum(ci*gi, (i, 1, m)), p = (q - Sum(ci*ri, (i, 1, m)))/a has\\n    degree at most n1 and satisfies A*Dp + B*p == Sum(ci*qi, (i, 1, m))\\n    '\n    (R, Z) = list(zip(*[gcdex_diophantine(b, a, qi) for qi in Q]))\n    A = a\n    B = b + derivation(a, DE)\n    Qq = [zi - derivation(ri, DE) for (ri, zi) in zip(R, Z)]\n    R = list(R)\n    n1 = n - a.degree(DE.t)\n    return (A, B, Qq, R, n1)",
            "def prde_spde(a, b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Special Polynomial Differential Equation algorithm: Parametric Version.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], an integer n, and a, b, q1, ..., qm in k[t]\\n    with deg(a) > 0 and gcd(a, b) == 1, return (A, B, Q, R, n1), with\\n    Qq = [q1, ..., qm] and R = [r1, ..., rm], such that for any solution\\n    c1, ..., cm in Const(k) and q in k[t] of degree at most n of\\n    a*Dq + b*q == Sum(ci*gi, (i, 1, m)), p = (q - Sum(ci*ri, (i, 1, m)))/a has\\n    degree at most n1 and satisfies A*Dp + B*p == Sum(ci*qi, (i, 1, m))\\n    '\n    (R, Z) = list(zip(*[gcdex_diophantine(b, a, qi) for qi in Q]))\n    A = a\n    B = b + derivation(a, DE)\n    Qq = [zi - derivation(ri, DE) for (ri, zi) in zip(R, Z)]\n    R = list(R)\n    n1 = n - a.degree(DE.t)\n    return (A, B, Qq, R, n1)",
            "def prde_spde(a, b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Special Polynomial Differential Equation algorithm: Parametric Version.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], an integer n, and a, b, q1, ..., qm in k[t]\\n    with deg(a) > 0 and gcd(a, b) == 1, return (A, B, Q, R, n1), with\\n    Qq = [q1, ..., qm] and R = [r1, ..., rm], such that for any solution\\n    c1, ..., cm in Const(k) and q in k[t] of degree at most n of\\n    a*Dq + b*q == Sum(ci*gi, (i, 1, m)), p = (q - Sum(ci*ri, (i, 1, m)))/a has\\n    degree at most n1 and satisfies A*Dp + B*p == Sum(ci*qi, (i, 1, m))\\n    '\n    (R, Z) = list(zip(*[gcdex_diophantine(b, a, qi) for qi in Q]))\n    A = a\n    B = b + derivation(a, DE)\n    Qq = [zi - derivation(ri, DE) for (ri, zi) in zip(R, Z)]\n    R = list(R)\n    n1 = n - a.degree(DE.t)\n    return (A, B, Qq, R, n1)",
            "def prde_spde(a, b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Special Polynomial Differential Equation algorithm: Parametric Version.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], an integer n, and a, b, q1, ..., qm in k[t]\\n    with deg(a) > 0 and gcd(a, b) == 1, return (A, B, Q, R, n1), with\\n    Qq = [q1, ..., qm] and R = [r1, ..., rm], such that for any solution\\n    c1, ..., cm in Const(k) and q in k[t] of degree at most n of\\n    a*Dq + b*q == Sum(ci*gi, (i, 1, m)), p = (q - Sum(ci*ri, (i, 1, m)))/a has\\n    degree at most n1 and satisfies A*Dp + B*p == Sum(ci*qi, (i, 1, m))\\n    '\n    (R, Z) = list(zip(*[gcdex_diophantine(b, a, qi) for qi in Q]))\n    A = a\n    B = b + derivation(a, DE)\n    Qq = [zi - derivation(ri, DE) for (ri, zi) in zip(R, Z)]\n    R = list(R)\n    n1 = n - a.degree(DE.t)\n    return (A, B, Qq, R, n1)",
            "def prde_spde(a, b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Special Polynomial Differential Equation algorithm: Parametric Version.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], an integer n, and a, b, q1, ..., qm in k[t]\\n    with deg(a) > 0 and gcd(a, b) == 1, return (A, B, Q, R, n1), with\\n    Qq = [q1, ..., qm] and R = [r1, ..., rm], such that for any solution\\n    c1, ..., cm in Const(k) and q in k[t] of degree at most n of\\n    a*Dq + b*q == Sum(ci*gi, (i, 1, m)), p = (q - Sum(ci*ri, (i, 1, m)))/a has\\n    degree at most n1 and satisfies A*Dp + B*p == Sum(ci*qi, (i, 1, m))\\n    '\n    (R, Z) = list(zip(*[gcdex_diophantine(b, a, qi) for qi in Q]))\n    A = a\n    B = b + derivation(a, DE)\n    Qq = [zi - derivation(ri, DE) for (ri, zi) in zip(R, Z)]\n    R = list(R)\n    n1 = n - a.degree(DE.t)\n    return (A, B, Qq, R, n1)"
        ]
    },
    {
        "func_name": "prde_no_cancel_b_large",
        "original": "def prde_no_cancel_b_large(b, Q, n, DE):\n    \"\"\"\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) large enough.\n\n    Explanation\n    ===========\n\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\n    b != 0 and either D == d/dt or deg(b) > max(0, deg(D) - 1), returns\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\n    Dq + b*q == Sum(ci*qi, (i, 1, m)), then q = Sum(dj*hj, (j, 1, r)), where\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\n    \"\"\"\n    db = b.degree(DE.t)\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, -1, -1), range(m)):\n        si = Q[i].nth(N + db) / b.LC()\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if all((qi.is_zero for qi in Q)):\n        dc = -1\n    else:\n        dc = max([qi.degree(DE.t) for qi in Q])\n    M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n    (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n    c = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n    return (H, A)",
        "mutated": [
            "def prde_no_cancel_b_large(b, Q, n, DE):\n    if False:\n        i = 10\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) large enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    b != 0 and either D == d/dt or deg(b) > max(0, deg(D) - 1), returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)), then q = Sum(dj*hj, (j, 1, r)), where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    db = b.degree(DE.t)\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, -1, -1), range(m)):\n        si = Q[i].nth(N + db) / b.LC()\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if all((qi.is_zero for qi in Q)):\n        dc = -1\n    else:\n        dc = max([qi.degree(DE.t) for qi in Q])\n    M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n    (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n    c = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n    return (H, A)",
            "def prde_no_cancel_b_large(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) large enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    b != 0 and either D == d/dt or deg(b) > max(0, deg(D) - 1), returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)), then q = Sum(dj*hj, (j, 1, r)), where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    db = b.degree(DE.t)\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, -1, -1), range(m)):\n        si = Q[i].nth(N + db) / b.LC()\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if all((qi.is_zero for qi in Q)):\n        dc = -1\n    else:\n        dc = max([qi.degree(DE.t) for qi in Q])\n    M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n    (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n    c = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n    return (H, A)",
            "def prde_no_cancel_b_large(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) large enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    b != 0 and either D == d/dt or deg(b) > max(0, deg(D) - 1), returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)), then q = Sum(dj*hj, (j, 1, r)), where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    db = b.degree(DE.t)\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, -1, -1), range(m)):\n        si = Q[i].nth(N + db) / b.LC()\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if all((qi.is_zero for qi in Q)):\n        dc = -1\n    else:\n        dc = max([qi.degree(DE.t) for qi in Q])\n    M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n    (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n    c = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n    return (H, A)",
            "def prde_no_cancel_b_large(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) large enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    b != 0 and either D == d/dt or deg(b) > max(0, deg(D) - 1), returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)), then q = Sum(dj*hj, (j, 1, r)), where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    db = b.degree(DE.t)\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, -1, -1), range(m)):\n        si = Q[i].nth(N + db) / b.LC()\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if all((qi.is_zero for qi in Q)):\n        dc = -1\n    else:\n        dc = max([qi.degree(DE.t) for qi in Q])\n    M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n    (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n    c = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n    return (H, A)",
            "def prde_no_cancel_b_large(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) large enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    b != 0 and either D == d/dt or deg(b) > max(0, deg(D) - 1), returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)), then q = Sum(dj*hj, (j, 1, r)), where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    db = b.degree(DE.t)\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, -1, -1), range(m)):\n        si = Q[i].nth(N + db) / b.LC()\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if all((qi.is_zero for qi in Q)):\n        dc = -1\n    else:\n        dc = max([qi.degree(DE.t) for qi in Q])\n    M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n    (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n    c = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n    return (H, A)"
        ]
    },
    {
        "func_name": "prde_no_cancel_b_small",
        "original": "def prde_no_cancel_b_small(b, Q, n, DE):\n    \"\"\"\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) small enough.\n\n    Explanation\n    ===========\n\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\n    deg(b) < deg(D) - 1 and either D == d/dt or deg(D) >= 2, returns\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\n    Dq + b*q == Sum(ci*qi, (i, 1, m)) then q = Sum(dj*hj, (j, 1, r)) where\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\n    \"\"\"\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, 0, -1), range(m)):\n        si = Q[i].nth(N + DE.d.degree(DE.t) - 1) / (N * DE.d.LC())\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if b.degree(DE.t) > 0:\n        for i in range(m):\n            si = Poly(Q[i].nth(b.degree(DE.t)) / b.LC(), DE.t)\n            H[i] = H[i] + si\n            Q[i] = Q[i] - derivation(si, DE) - b * si\n        if all((qi.is_zero for qi in Q)):\n            dc = -1\n        else:\n            dc = max([qi.degree(DE.t) for qi in Q])\n        M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n        (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n        c = eye(m, DE.t)\n        A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n        return (H, A)\n    t = DE.t\n    if DE.case != 'base':\n        with DecrementLevel(DE):\n            t0 = DE.t\n            (ba, bd) = frac_in(b, t0, field=True)\n            Q0 = [frac_in(qi.TC(), t0, field=True) for qi in Q]\n            (f, B) = param_rischDE(ba, bd, Q0, DE)\n        f = [Poly(fa.as_expr() / fd.as_expr(), t, field=True) for (fa, fd) in f]\n        B = Matrix.from_Matrix(B.to_Matrix(), t)\n    else:\n        f = [Poly(1, t, field=True)]\n        B = Matrix([[qi.TC() for qi in Q] + [S.Zero]], DE.t)\n    d = max([qi.degree(DE.t) for qi in Q])\n    if d > 0:\n        M = Matrix(d, m, lambda i, j: Q[j].nth(i + 1), DE.t)\n        (A, _) = constant_system(M, zeros(d, 1, DE.t), DE)\n    else:\n        A = Matrix(0, m, [], DE.t)\n    r = len(f)\n    I = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, r + m, DE.t))\n    B = B.row_join(zeros(B.rows, m, DE.t))\n    C = I.row_join(zeros(m, r, DE.t)).row_join(-I)\n    return (f + H, A.col_join(B).col_join(C))",
        "mutated": [
            "def prde_no_cancel_b_small(b, Q, n, DE):\n    if False:\n        i = 10\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) small enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    deg(b) < deg(D) - 1 and either D == d/dt or deg(D) >= 2, returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)) then q = Sum(dj*hj, (j, 1, r)) where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, 0, -1), range(m)):\n        si = Q[i].nth(N + DE.d.degree(DE.t) - 1) / (N * DE.d.LC())\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if b.degree(DE.t) > 0:\n        for i in range(m):\n            si = Poly(Q[i].nth(b.degree(DE.t)) / b.LC(), DE.t)\n            H[i] = H[i] + si\n            Q[i] = Q[i] - derivation(si, DE) - b * si\n        if all((qi.is_zero for qi in Q)):\n            dc = -1\n        else:\n            dc = max([qi.degree(DE.t) for qi in Q])\n        M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n        (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n        c = eye(m, DE.t)\n        A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n        return (H, A)\n    t = DE.t\n    if DE.case != 'base':\n        with DecrementLevel(DE):\n            t0 = DE.t\n            (ba, bd) = frac_in(b, t0, field=True)\n            Q0 = [frac_in(qi.TC(), t0, field=True) for qi in Q]\n            (f, B) = param_rischDE(ba, bd, Q0, DE)\n        f = [Poly(fa.as_expr() / fd.as_expr(), t, field=True) for (fa, fd) in f]\n        B = Matrix.from_Matrix(B.to_Matrix(), t)\n    else:\n        f = [Poly(1, t, field=True)]\n        B = Matrix([[qi.TC() for qi in Q] + [S.Zero]], DE.t)\n    d = max([qi.degree(DE.t) for qi in Q])\n    if d > 0:\n        M = Matrix(d, m, lambda i, j: Q[j].nth(i + 1), DE.t)\n        (A, _) = constant_system(M, zeros(d, 1, DE.t), DE)\n    else:\n        A = Matrix(0, m, [], DE.t)\n    r = len(f)\n    I = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, r + m, DE.t))\n    B = B.row_join(zeros(B.rows, m, DE.t))\n    C = I.row_join(zeros(m, r, DE.t)).row_join(-I)\n    return (f + H, A.col_join(B).col_join(C))",
            "def prde_no_cancel_b_small(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) small enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    deg(b) < deg(D) - 1 and either D == d/dt or deg(D) >= 2, returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)) then q = Sum(dj*hj, (j, 1, r)) where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, 0, -1), range(m)):\n        si = Q[i].nth(N + DE.d.degree(DE.t) - 1) / (N * DE.d.LC())\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if b.degree(DE.t) > 0:\n        for i in range(m):\n            si = Poly(Q[i].nth(b.degree(DE.t)) / b.LC(), DE.t)\n            H[i] = H[i] + si\n            Q[i] = Q[i] - derivation(si, DE) - b * si\n        if all((qi.is_zero for qi in Q)):\n            dc = -1\n        else:\n            dc = max([qi.degree(DE.t) for qi in Q])\n        M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n        (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n        c = eye(m, DE.t)\n        A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n        return (H, A)\n    t = DE.t\n    if DE.case != 'base':\n        with DecrementLevel(DE):\n            t0 = DE.t\n            (ba, bd) = frac_in(b, t0, field=True)\n            Q0 = [frac_in(qi.TC(), t0, field=True) for qi in Q]\n            (f, B) = param_rischDE(ba, bd, Q0, DE)\n        f = [Poly(fa.as_expr() / fd.as_expr(), t, field=True) for (fa, fd) in f]\n        B = Matrix.from_Matrix(B.to_Matrix(), t)\n    else:\n        f = [Poly(1, t, field=True)]\n        B = Matrix([[qi.TC() for qi in Q] + [S.Zero]], DE.t)\n    d = max([qi.degree(DE.t) for qi in Q])\n    if d > 0:\n        M = Matrix(d, m, lambda i, j: Q[j].nth(i + 1), DE.t)\n        (A, _) = constant_system(M, zeros(d, 1, DE.t), DE)\n    else:\n        A = Matrix(0, m, [], DE.t)\n    r = len(f)\n    I = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, r + m, DE.t))\n    B = B.row_join(zeros(B.rows, m, DE.t))\n    C = I.row_join(zeros(m, r, DE.t)).row_join(-I)\n    return (f + H, A.col_join(B).col_join(C))",
            "def prde_no_cancel_b_small(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) small enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    deg(b) < deg(D) - 1 and either D == d/dt or deg(D) >= 2, returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)) then q = Sum(dj*hj, (j, 1, r)) where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, 0, -1), range(m)):\n        si = Q[i].nth(N + DE.d.degree(DE.t) - 1) / (N * DE.d.LC())\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if b.degree(DE.t) > 0:\n        for i in range(m):\n            si = Poly(Q[i].nth(b.degree(DE.t)) / b.LC(), DE.t)\n            H[i] = H[i] + si\n            Q[i] = Q[i] - derivation(si, DE) - b * si\n        if all((qi.is_zero for qi in Q)):\n            dc = -1\n        else:\n            dc = max([qi.degree(DE.t) for qi in Q])\n        M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n        (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n        c = eye(m, DE.t)\n        A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n        return (H, A)\n    t = DE.t\n    if DE.case != 'base':\n        with DecrementLevel(DE):\n            t0 = DE.t\n            (ba, bd) = frac_in(b, t0, field=True)\n            Q0 = [frac_in(qi.TC(), t0, field=True) for qi in Q]\n            (f, B) = param_rischDE(ba, bd, Q0, DE)\n        f = [Poly(fa.as_expr() / fd.as_expr(), t, field=True) for (fa, fd) in f]\n        B = Matrix.from_Matrix(B.to_Matrix(), t)\n    else:\n        f = [Poly(1, t, field=True)]\n        B = Matrix([[qi.TC() for qi in Q] + [S.Zero]], DE.t)\n    d = max([qi.degree(DE.t) for qi in Q])\n    if d > 0:\n        M = Matrix(d, m, lambda i, j: Q[j].nth(i + 1), DE.t)\n        (A, _) = constant_system(M, zeros(d, 1, DE.t), DE)\n    else:\n        A = Matrix(0, m, [], DE.t)\n    r = len(f)\n    I = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, r + m, DE.t))\n    B = B.row_join(zeros(B.rows, m, DE.t))\n    C = I.row_join(zeros(m, r, DE.t)).row_join(-I)\n    return (f + H, A.col_join(B).col_join(C))",
            "def prde_no_cancel_b_small(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) small enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    deg(b) < deg(D) - 1 and either D == d/dt or deg(D) >= 2, returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)) then q = Sum(dj*hj, (j, 1, r)) where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, 0, -1), range(m)):\n        si = Q[i].nth(N + DE.d.degree(DE.t) - 1) / (N * DE.d.LC())\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if b.degree(DE.t) > 0:\n        for i in range(m):\n            si = Poly(Q[i].nth(b.degree(DE.t)) / b.LC(), DE.t)\n            H[i] = H[i] + si\n            Q[i] = Q[i] - derivation(si, DE) - b * si\n        if all((qi.is_zero for qi in Q)):\n            dc = -1\n        else:\n            dc = max([qi.degree(DE.t) for qi in Q])\n        M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n        (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n        c = eye(m, DE.t)\n        A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n        return (H, A)\n    t = DE.t\n    if DE.case != 'base':\n        with DecrementLevel(DE):\n            t0 = DE.t\n            (ba, bd) = frac_in(b, t0, field=True)\n            Q0 = [frac_in(qi.TC(), t0, field=True) for qi in Q]\n            (f, B) = param_rischDE(ba, bd, Q0, DE)\n        f = [Poly(fa.as_expr() / fd.as_expr(), t, field=True) for (fa, fd) in f]\n        B = Matrix.from_Matrix(B.to_Matrix(), t)\n    else:\n        f = [Poly(1, t, field=True)]\n        B = Matrix([[qi.TC() for qi in Q] + [S.Zero]], DE.t)\n    d = max([qi.degree(DE.t) for qi in Q])\n    if d > 0:\n        M = Matrix(d, m, lambda i, j: Q[j].nth(i + 1), DE.t)\n        (A, _) = constant_system(M, zeros(d, 1, DE.t), DE)\n    else:\n        A = Matrix(0, m, [], DE.t)\n    r = len(f)\n    I = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, r + m, DE.t))\n    B = B.row_join(zeros(B.rows, m, DE.t))\n    C = I.row_join(zeros(m, r, DE.t)).row_join(-I)\n    return (f + H, A.col_join(B).col_join(C))",
            "def prde_no_cancel_b_small(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Parametric Poly Risch Differential Equation - No cancellation: deg(b) small enough.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], n in ZZ, and b, q1, ..., qm in k[t] with\\n    deg(b) < deg(D) - 1 and either D == d/dt or deg(D) >= 2, returns\\n    h1, ..., hr in k[t] and a matrix A with coefficients in Const(k) such that\\n    if c1, ..., cm in Const(k) and q in k[t] satisfy deg(q) <= n and\\n    Dq + b*q == Sum(ci*qi, (i, 1, m)) then q = Sum(dj*hj, (j, 1, r)) where\\n    d1, ..., dr in Const(k) and A*Matrix([[c1, ..., cm, d1, ..., dr]]).T == 0.\\n    '\n    m = len(Q)\n    H = [Poly(0, DE.t)] * m\n    for (N, i) in itertools.product(range(n, 0, -1), range(m)):\n        si = Q[i].nth(N + DE.d.degree(DE.t) - 1) / (N * DE.d.LC())\n        sitn = Poly(si * DE.t ** N, DE.t)\n        H[i] = H[i] + sitn\n        Q[i] = Q[i] - derivation(sitn, DE) - b * sitn\n    if b.degree(DE.t) > 0:\n        for i in range(m):\n            si = Poly(Q[i].nth(b.degree(DE.t)) / b.LC(), DE.t)\n            H[i] = H[i] + si\n            Q[i] = Q[i] - derivation(si, DE) - b * si\n        if all((qi.is_zero for qi in Q)):\n            dc = -1\n        else:\n            dc = max([qi.degree(DE.t) for qi in Q])\n        M = Matrix(dc + 1, m, lambda i, j: Q[j].nth(i), DE.t)\n        (A, u) = constant_system(M, zeros(dc + 1, 1, DE.t), DE)\n        c = eye(m, DE.t)\n        A = A.row_join(zeros(A.rows, m, DE.t)).col_join(c.row_join(-c))\n        return (H, A)\n    t = DE.t\n    if DE.case != 'base':\n        with DecrementLevel(DE):\n            t0 = DE.t\n            (ba, bd) = frac_in(b, t0, field=True)\n            Q0 = [frac_in(qi.TC(), t0, field=True) for qi in Q]\n            (f, B) = param_rischDE(ba, bd, Q0, DE)\n        f = [Poly(fa.as_expr() / fd.as_expr(), t, field=True) for (fa, fd) in f]\n        B = Matrix.from_Matrix(B.to_Matrix(), t)\n    else:\n        f = [Poly(1, t, field=True)]\n        B = Matrix([[qi.TC() for qi in Q] + [S.Zero]], DE.t)\n    d = max([qi.degree(DE.t) for qi in Q])\n    if d > 0:\n        M = Matrix(d, m, lambda i, j: Q[j].nth(i + 1), DE.t)\n        (A, _) = constant_system(M, zeros(d, 1, DE.t), DE)\n    else:\n        A = Matrix(0, m, [], DE.t)\n    r = len(f)\n    I = eye(m, DE.t)\n    A = A.row_join(zeros(A.rows, r + m, DE.t))\n    B = B.row_join(zeros(B.rows, m, DE.t))\n    C = I.row_join(zeros(m, r, DE.t)).row_join(-I)\n    return (f + H, A.col_join(B).col_join(C))"
        ]
    },
    {
        "func_name": "prde_cancel_liouvillian",
        "original": "def prde_cancel_liouvillian(b, Q, n, DE):\n    \"\"\"\n    Pg, 237.\n    \"\"\"\n    H = []\n    if DE.case == 'primitive':\n        with DecrementLevel(DE):\n            (ba, bd) = frac_in(b, DE.t, field=True)\n    for i in range(n, -1, -1):\n        if DE.case == 'exp':\n            with DecrementLevel(DE):\n                (ba, bd) = frac_in(b + (i * (derivation(DE.t, DE) / DE.t)).as_poly(b.gens), DE.t, field=True)\n        with DecrementLevel(DE):\n            Qy = [frac_in(q.nth(i), DE.t, field=True) for q in Q]\n            (fi, Ai) = param_rischDE(ba, bd, Qy, DE)\n        fi = [Poly(fa.as_expr() / fd.as_expr(), DE.t, field=True) for (fa, fd) in fi]\n        Ai = Ai.set_gens(DE.t)\n        ri = len(fi)\n        if i == n:\n            M = Ai\n        else:\n            M = Ai.col_join(M.row_join(zeros(M.rows, ri, DE.t)))\n        (Fi, hi) = ([None] * ri, [None] * ri)\n        for j in range(ri):\n            hji = fi[j] * (DE.t ** i).as_poly(fi[j].gens)\n            hi[j] = hji\n            Fi[j] = -(derivation(hji, DE) - b * hji)\n        H += hi\n        Q = Q + Fi\n    return (H, M)",
        "mutated": [
            "def prde_cancel_liouvillian(b, Q, n, DE):\n    if False:\n        i = 10\n    '\\n    Pg, 237.\\n    '\n    H = []\n    if DE.case == 'primitive':\n        with DecrementLevel(DE):\n            (ba, bd) = frac_in(b, DE.t, field=True)\n    for i in range(n, -1, -1):\n        if DE.case == 'exp':\n            with DecrementLevel(DE):\n                (ba, bd) = frac_in(b + (i * (derivation(DE.t, DE) / DE.t)).as_poly(b.gens), DE.t, field=True)\n        with DecrementLevel(DE):\n            Qy = [frac_in(q.nth(i), DE.t, field=True) for q in Q]\n            (fi, Ai) = param_rischDE(ba, bd, Qy, DE)\n        fi = [Poly(fa.as_expr() / fd.as_expr(), DE.t, field=True) for (fa, fd) in fi]\n        Ai = Ai.set_gens(DE.t)\n        ri = len(fi)\n        if i == n:\n            M = Ai\n        else:\n            M = Ai.col_join(M.row_join(zeros(M.rows, ri, DE.t)))\n        (Fi, hi) = ([None] * ri, [None] * ri)\n        for j in range(ri):\n            hji = fi[j] * (DE.t ** i).as_poly(fi[j].gens)\n            hi[j] = hji\n            Fi[j] = -(derivation(hji, DE) - b * hji)\n        H += hi\n        Q = Q + Fi\n    return (H, M)",
            "def prde_cancel_liouvillian(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Pg, 237.\\n    '\n    H = []\n    if DE.case == 'primitive':\n        with DecrementLevel(DE):\n            (ba, bd) = frac_in(b, DE.t, field=True)\n    for i in range(n, -1, -1):\n        if DE.case == 'exp':\n            with DecrementLevel(DE):\n                (ba, bd) = frac_in(b + (i * (derivation(DE.t, DE) / DE.t)).as_poly(b.gens), DE.t, field=True)\n        with DecrementLevel(DE):\n            Qy = [frac_in(q.nth(i), DE.t, field=True) for q in Q]\n            (fi, Ai) = param_rischDE(ba, bd, Qy, DE)\n        fi = [Poly(fa.as_expr() / fd.as_expr(), DE.t, field=True) for (fa, fd) in fi]\n        Ai = Ai.set_gens(DE.t)\n        ri = len(fi)\n        if i == n:\n            M = Ai\n        else:\n            M = Ai.col_join(M.row_join(zeros(M.rows, ri, DE.t)))\n        (Fi, hi) = ([None] * ri, [None] * ri)\n        for j in range(ri):\n            hji = fi[j] * (DE.t ** i).as_poly(fi[j].gens)\n            hi[j] = hji\n            Fi[j] = -(derivation(hji, DE) - b * hji)\n        H += hi\n        Q = Q + Fi\n    return (H, M)",
            "def prde_cancel_liouvillian(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Pg, 237.\\n    '\n    H = []\n    if DE.case == 'primitive':\n        with DecrementLevel(DE):\n            (ba, bd) = frac_in(b, DE.t, field=True)\n    for i in range(n, -1, -1):\n        if DE.case == 'exp':\n            with DecrementLevel(DE):\n                (ba, bd) = frac_in(b + (i * (derivation(DE.t, DE) / DE.t)).as_poly(b.gens), DE.t, field=True)\n        with DecrementLevel(DE):\n            Qy = [frac_in(q.nth(i), DE.t, field=True) for q in Q]\n            (fi, Ai) = param_rischDE(ba, bd, Qy, DE)\n        fi = [Poly(fa.as_expr() / fd.as_expr(), DE.t, field=True) for (fa, fd) in fi]\n        Ai = Ai.set_gens(DE.t)\n        ri = len(fi)\n        if i == n:\n            M = Ai\n        else:\n            M = Ai.col_join(M.row_join(zeros(M.rows, ri, DE.t)))\n        (Fi, hi) = ([None] * ri, [None] * ri)\n        for j in range(ri):\n            hji = fi[j] * (DE.t ** i).as_poly(fi[j].gens)\n            hi[j] = hji\n            Fi[j] = -(derivation(hji, DE) - b * hji)\n        H += hi\n        Q = Q + Fi\n    return (H, M)",
            "def prde_cancel_liouvillian(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Pg, 237.\\n    '\n    H = []\n    if DE.case == 'primitive':\n        with DecrementLevel(DE):\n            (ba, bd) = frac_in(b, DE.t, field=True)\n    for i in range(n, -1, -1):\n        if DE.case == 'exp':\n            with DecrementLevel(DE):\n                (ba, bd) = frac_in(b + (i * (derivation(DE.t, DE) / DE.t)).as_poly(b.gens), DE.t, field=True)\n        with DecrementLevel(DE):\n            Qy = [frac_in(q.nth(i), DE.t, field=True) for q in Q]\n            (fi, Ai) = param_rischDE(ba, bd, Qy, DE)\n        fi = [Poly(fa.as_expr() / fd.as_expr(), DE.t, field=True) for (fa, fd) in fi]\n        Ai = Ai.set_gens(DE.t)\n        ri = len(fi)\n        if i == n:\n            M = Ai\n        else:\n            M = Ai.col_join(M.row_join(zeros(M.rows, ri, DE.t)))\n        (Fi, hi) = ([None] * ri, [None] * ri)\n        for j in range(ri):\n            hji = fi[j] * (DE.t ** i).as_poly(fi[j].gens)\n            hi[j] = hji\n            Fi[j] = -(derivation(hji, DE) - b * hji)\n        H += hi\n        Q = Q + Fi\n    return (H, M)",
            "def prde_cancel_liouvillian(b, Q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Pg, 237.\\n    '\n    H = []\n    if DE.case == 'primitive':\n        with DecrementLevel(DE):\n            (ba, bd) = frac_in(b, DE.t, field=True)\n    for i in range(n, -1, -1):\n        if DE.case == 'exp':\n            with DecrementLevel(DE):\n                (ba, bd) = frac_in(b + (i * (derivation(DE.t, DE) / DE.t)).as_poly(b.gens), DE.t, field=True)\n        with DecrementLevel(DE):\n            Qy = [frac_in(q.nth(i), DE.t, field=True) for q in Q]\n            (fi, Ai) = param_rischDE(ba, bd, Qy, DE)\n        fi = [Poly(fa.as_expr() / fd.as_expr(), DE.t, field=True) for (fa, fd) in fi]\n        Ai = Ai.set_gens(DE.t)\n        ri = len(fi)\n        if i == n:\n            M = Ai\n        else:\n            M = Ai.col_join(M.row_join(zeros(M.rows, ri, DE.t)))\n        (Fi, hi) = ([None] * ri, [None] * ri)\n        for j in range(ri):\n            hji = fi[j] * (DE.t ** i).as_poly(fi[j].gens)\n            hi[j] = hji\n            Fi[j] = -(derivation(hji, DE) - b * hji)\n        H += hi\n        Q = Q + Fi\n    return (H, M)"
        ]
    },
    {
        "func_name": "param_poly_rischDE",
        "original": "def param_poly_rischDE(a, b, q, n, DE):\n    \"\"\"Polynomial solutions of a parametric Risch differential equation.\n\n    Explanation\n    ===========\n\n    Given a derivation D in k[t], a, b in k[t] relatively prime, and q\n    = [q1, ..., qm] in k[t]^m, return h = [h1, ..., hr] in k[t]^r and\n    a matrix A with m + r columns and entries in Const(k) such that\n    a*Dp + b*p = Sum(ci*qi, (i, 1, m)) has a solution p of degree <= n\n    in k[t] with c1, ..., cm in Const(k) if and only if p = Sum(dj*hj,\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\n    d1, ..., dr) is a solution of Ax == 0.\n    \"\"\"\n    m = len(q)\n    if n < 0:\n        if all((qi.is_zero for qi in q)):\n            return ([], zeros(1, m, DE.t))\n        N = max([qi.degree(DE.t) for qi in q])\n        M = Matrix(N + 1, m, lambda i, j: q[j].nth(i), DE.t)\n        (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n        return ([], A)\n    if a.is_ground:\n        a = a.LC()\n        (b, q) = (b.quo_ground(a), [qi.quo_ground(a) for qi in q])\n        if not b.is_zero and (DE.case == 'base' or b.degree() > max(0, DE.d.degree() - 1)):\n            return prde_no_cancel_b_large(b, q, n, DE)\n        elif (b.is_zero or b.degree() < DE.d.degree() - 1) and (DE.case == 'base' or DE.d.degree() >= 2):\n            return prde_no_cancel_b_small(b, q, n, DE)\n        elif DE.d.degree() >= 2 and b.degree() == DE.d.degree() - 1 and (n > -b.as_poly().LC() / DE.d.as_poly().LC()):\n            raise NotImplementedError('prde_no_cancel_b_equal() is not yet implemented.')\n        elif DE.case in ('primitive', 'exp'):\n            return prde_cancel_liouvillian(b, q, n, DE)\n        else:\n            raise NotImplementedError('non-linear and hypertangent cases have not yet been implemented')\n    (alpha, beta) = (a.one, [a.zero] * m)\n    while n >= 0:\n        (a, b, q, r, n) = prde_spde(a, b, q, n, DE)\n        beta = [betai + alpha * ri for (betai, ri) in zip(beta, r)]\n        alpha *= a\n        d = a.gcd(b)\n        if not d.is_ground:\n            break\n    (qq, M) = poly_linear_constraints(q, d)\n    (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = A.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mqq = Matrix([qq])\n    r = [(Mqq * vj)[0] for vj in V]\n    Mbeta = Matrix([beta])\n    f = [(Mbeta * vj)[0] for vj in V]\n    (g, B) = param_poly_rischDE(a.quo(d), b.quo(d), r, n, DE)\n    h = f + [alpha * gk for gk in g]\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(g), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    return (h, A)",
        "mutated": [
            "def param_poly_rischDE(a, b, q, n, DE):\n    if False:\n        i = 10\n    'Polynomial solutions of a parametric Risch differential equation.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k[t], a, b in k[t] relatively prime, and q\\n    = [q1, ..., qm] in k[t]^m, return h = [h1, ..., hr] in k[t]^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    a*Dp + b*p = Sum(ci*qi, (i, 1, m)) has a solution p of degree <= n\\n    in k[t] with c1, ..., cm in Const(k) if and only if p = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n    '\n    m = len(q)\n    if n < 0:\n        if all((qi.is_zero for qi in q)):\n            return ([], zeros(1, m, DE.t))\n        N = max([qi.degree(DE.t) for qi in q])\n        M = Matrix(N + 1, m, lambda i, j: q[j].nth(i), DE.t)\n        (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n        return ([], A)\n    if a.is_ground:\n        a = a.LC()\n        (b, q) = (b.quo_ground(a), [qi.quo_ground(a) for qi in q])\n        if not b.is_zero and (DE.case == 'base' or b.degree() > max(0, DE.d.degree() - 1)):\n            return prde_no_cancel_b_large(b, q, n, DE)\n        elif (b.is_zero or b.degree() < DE.d.degree() - 1) and (DE.case == 'base' or DE.d.degree() >= 2):\n            return prde_no_cancel_b_small(b, q, n, DE)\n        elif DE.d.degree() >= 2 and b.degree() == DE.d.degree() - 1 and (n > -b.as_poly().LC() / DE.d.as_poly().LC()):\n            raise NotImplementedError('prde_no_cancel_b_equal() is not yet implemented.')\n        elif DE.case in ('primitive', 'exp'):\n            return prde_cancel_liouvillian(b, q, n, DE)\n        else:\n            raise NotImplementedError('non-linear and hypertangent cases have not yet been implemented')\n    (alpha, beta) = (a.one, [a.zero] * m)\n    while n >= 0:\n        (a, b, q, r, n) = prde_spde(a, b, q, n, DE)\n        beta = [betai + alpha * ri for (betai, ri) in zip(beta, r)]\n        alpha *= a\n        d = a.gcd(b)\n        if not d.is_ground:\n            break\n    (qq, M) = poly_linear_constraints(q, d)\n    (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = A.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mqq = Matrix([qq])\n    r = [(Mqq * vj)[0] for vj in V]\n    Mbeta = Matrix([beta])\n    f = [(Mbeta * vj)[0] for vj in V]\n    (g, B) = param_poly_rischDE(a.quo(d), b.quo(d), r, n, DE)\n    h = f + [alpha * gk for gk in g]\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(g), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    return (h, A)",
            "def param_poly_rischDE(a, b, q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Polynomial solutions of a parametric Risch differential equation.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k[t], a, b in k[t] relatively prime, and q\\n    = [q1, ..., qm] in k[t]^m, return h = [h1, ..., hr] in k[t]^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    a*Dp + b*p = Sum(ci*qi, (i, 1, m)) has a solution p of degree <= n\\n    in k[t] with c1, ..., cm in Const(k) if and only if p = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n    '\n    m = len(q)\n    if n < 0:\n        if all((qi.is_zero for qi in q)):\n            return ([], zeros(1, m, DE.t))\n        N = max([qi.degree(DE.t) for qi in q])\n        M = Matrix(N + 1, m, lambda i, j: q[j].nth(i), DE.t)\n        (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n        return ([], A)\n    if a.is_ground:\n        a = a.LC()\n        (b, q) = (b.quo_ground(a), [qi.quo_ground(a) for qi in q])\n        if not b.is_zero and (DE.case == 'base' or b.degree() > max(0, DE.d.degree() - 1)):\n            return prde_no_cancel_b_large(b, q, n, DE)\n        elif (b.is_zero or b.degree() < DE.d.degree() - 1) and (DE.case == 'base' or DE.d.degree() >= 2):\n            return prde_no_cancel_b_small(b, q, n, DE)\n        elif DE.d.degree() >= 2 and b.degree() == DE.d.degree() - 1 and (n > -b.as_poly().LC() / DE.d.as_poly().LC()):\n            raise NotImplementedError('prde_no_cancel_b_equal() is not yet implemented.')\n        elif DE.case in ('primitive', 'exp'):\n            return prde_cancel_liouvillian(b, q, n, DE)\n        else:\n            raise NotImplementedError('non-linear and hypertangent cases have not yet been implemented')\n    (alpha, beta) = (a.one, [a.zero] * m)\n    while n >= 0:\n        (a, b, q, r, n) = prde_spde(a, b, q, n, DE)\n        beta = [betai + alpha * ri for (betai, ri) in zip(beta, r)]\n        alpha *= a\n        d = a.gcd(b)\n        if not d.is_ground:\n            break\n    (qq, M) = poly_linear_constraints(q, d)\n    (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = A.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mqq = Matrix([qq])\n    r = [(Mqq * vj)[0] for vj in V]\n    Mbeta = Matrix([beta])\n    f = [(Mbeta * vj)[0] for vj in V]\n    (g, B) = param_poly_rischDE(a.quo(d), b.quo(d), r, n, DE)\n    h = f + [alpha * gk for gk in g]\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(g), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    return (h, A)",
            "def param_poly_rischDE(a, b, q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Polynomial solutions of a parametric Risch differential equation.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k[t], a, b in k[t] relatively prime, and q\\n    = [q1, ..., qm] in k[t]^m, return h = [h1, ..., hr] in k[t]^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    a*Dp + b*p = Sum(ci*qi, (i, 1, m)) has a solution p of degree <= n\\n    in k[t] with c1, ..., cm in Const(k) if and only if p = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n    '\n    m = len(q)\n    if n < 0:\n        if all((qi.is_zero for qi in q)):\n            return ([], zeros(1, m, DE.t))\n        N = max([qi.degree(DE.t) for qi in q])\n        M = Matrix(N + 1, m, lambda i, j: q[j].nth(i), DE.t)\n        (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n        return ([], A)\n    if a.is_ground:\n        a = a.LC()\n        (b, q) = (b.quo_ground(a), [qi.quo_ground(a) for qi in q])\n        if not b.is_zero and (DE.case == 'base' or b.degree() > max(0, DE.d.degree() - 1)):\n            return prde_no_cancel_b_large(b, q, n, DE)\n        elif (b.is_zero or b.degree() < DE.d.degree() - 1) and (DE.case == 'base' or DE.d.degree() >= 2):\n            return prde_no_cancel_b_small(b, q, n, DE)\n        elif DE.d.degree() >= 2 and b.degree() == DE.d.degree() - 1 and (n > -b.as_poly().LC() / DE.d.as_poly().LC()):\n            raise NotImplementedError('prde_no_cancel_b_equal() is not yet implemented.')\n        elif DE.case in ('primitive', 'exp'):\n            return prde_cancel_liouvillian(b, q, n, DE)\n        else:\n            raise NotImplementedError('non-linear and hypertangent cases have not yet been implemented')\n    (alpha, beta) = (a.one, [a.zero] * m)\n    while n >= 0:\n        (a, b, q, r, n) = prde_spde(a, b, q, n, DE)\n        beta = [betai + alpha * ri for (betai, ri) in zip(beta, r)]\n        alpha *= a\n        d = a.gcd(b)\n        if not d.is_ground:\n            break\n    (qq, M) = poly_linear_constraints(q, d)\n    (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = A.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mqq = Matrix([qq])\n    r = [(Mqq * vj)[0] for vj in V]\n    Mbeta = Matrix([beta])\n    f = [(Mbeta * vj)[0] for vj in V]\n    (g, B) = param_poly_rischDE(a.quo(d), b.quo(d), r, n, DE)\n    h = f + [alpha * gk for gk in g]\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(g), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    return (h, A)",
            "def param_poly_rischDE(a, b, q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Polynomial solutions of a parametric Risch differential equation.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k[t], a, b in k[t] relatively prime, and q\\n    = [q1, ..., qm] in k[t]^m, return h = [h1, ..., hr] in k[t]^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    a*Dp + b*p = Sum(ci*qi, (i, 1, m)) has a solution p of degree <= n\\n    in k[t] with c1, ..., cm in Const(k) if and only if p = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n    '\n    m = len(q)\n    if n < 0:\n        if all((qi.is_zero for qi in q)):\n            return ([], zeros(1, m, DE.t))\n        N = max([qi.degree(DE.t) for qi in q])\n        M = Matrix(N + 1, m, lambda i, j: q[j].nth(i), DE.t)\n        (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n        return ([], A)\n    if a.is_ground:\n        a = a.LC()\n        (b, q) = (b.quo_ground(a), [qi.quo_ground(a) for qi in q])\n        if not b.is_zero and (DE.case == 'base' or b.degree() > max(0, DE.d.degree() - 1)):\n            return prde_no_cancel_b_large(b, q, n, DE)\n        elif (b.is_zero or b.degree() < DE.d.degree() - 1) and (DE.case == 'base' or DE.d.degree() >= 2):\n            return prde_no_cancel_b_small(b, q, n, DE)\n        elif DE.d.degree() >= 2 and b.degree() == DE.d.degree() - 1 and (n > -b.as_poly().LC() / DE.d.as_poly().LC()):\n            raise NotImplementedError('prde_no_cancel_b_equal() is not yet implemented.')\n        elif DE.case in ('primitive', 'exp'):\n            return prde_cancel_liouvillian(b, q, n, DE)\n        else:\n            raise NotImplementedError('non-linear and hypertangent cases have not yet been implemented')\n    (alpha, beta) = (a.one, [a.zero] * m)\n    while n >= 0:\n        (a, b, q, r, n) = prde_spde(a, b, q, n, DE)\n        beta = [betai + alpha * ri for (betai, ri) in zip(beta, r)]\n        alpha *= a\n        d = a.gcd(b)\n        if not d.is_ground:\n            break\n    (qq, M) = poly_linear_constraints(q, d)\n    (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = A.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mqq = Matrix([qq])\n    r = [(Mqq * vj)[0] for vj in V]\n    Mbeta = Matrix([beta])\n    f = [(Mbeta * vj)[0] for vj in V]\n    (g, B) = param_poly_rischDE(a.quo(d), b.quo(d), r, n, DE)\n    h = f + [alpha * gk for gk in g]\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(g), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    return (h, A)",
            "def param_poly_rischDE(a, b, q, n, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Polynomial solutions of a parametric Risch differential equation.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k[t], a, b in k[t] relatively prime, and q\\n    = [q1, ..., qm] in k[t]^m, return h = [h1, ..., hr] in k[t]^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    a*Dp + b*p = Sum(ci*qi, (i, 1, m)) has a solution p of degree <= n\\n    in k[t] with c1, ..., cm in Const(k) if and only if p = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n    '\n    m = len(q)\n    if n < 0:\n        if all((qi.is_zero for qi in q)):\n            return ([], zeros(1, m, DE.t))\n        N = max([qi.degree(DE.t) for qi in q])\n        M = Matrix(N + 1, m, lambda i, j: q[j].nth(i), DE.t)\n        (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n        return ([], A)\n    if a.is_ground:\n        a = a.LC()\n        (b, q) = (b.quo_ground(a), [qi.quo_ground(a) for qi in q])\n        if not b.is_zero and (DE.case == 'base' or b.degree() > max(0, DE.d.degree() - 1)):\n            return prde_no_cancel_b_large(b, q, n, DE)\n        elif (b.is_zero or b.degree() < DE.d.degree() - 1) and (DE.case == 'base' or DE.d.degree() >= 2):\n            return prde_no_cancel_b_small(b, q, n, DE)\n        elif DE.d.degree() >= 2 and b.degree() == DE.d.degree() - 1 and (n > -b.as_poly().LC() / DE.d.as_poly().LC()):\n            raise NotImplementedError('prde_no_cancel_b_equal() is not yet implemented.')\n        elif DE.case in ('primitive', 'exp'):\n            return prde_cancel_liouvillian(b, q, n, DE)\n        else:\n            raise NotImplementedError('non-linear and hypertangent cases have not yet been implemented')\n    (alpha, beta) = (a.one, [a.zero] * m)\n    while n >= 0:\n        (a, b, q, r, n) = prde_spde(a, b, q, n, DE)\n        beta = [betai + alpha * ri for (betai, ri) in zip(beta, r)]\n        alpha *= a\n        d = a.gcd(b)\n        if not d.is_ground:\n            break\n    (qq, M) = poly_linear_constraints(q, d)\n    (A, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = A.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mqq = Matrix([qq])\n    r = [(Mqq * vj)[0] for vj in V]\n    Mbeta = Matrix([beta])\n    f = [(Mbeta * vj)[0] for vj in V]\n    (g, B) = param_poly_rischDE(a.quo(d), b.quo(d), r, n, DE)\n    h = f + [alpha * gk for gk in g]\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(g), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    return (h, A)"
        ]
    },
    {
        "func_name": "param_rischDE",
        "original": "def param_rischDE(fa, fd, G, DE):\n    \"\"\"\n    Solve a Parametric Risch Differential Equation: Dy + f*y == Sum(ci*Gi, (i, 1, m)).\n\n    Explanation\n    ===========\n\n    Given a derivation D in k(t), f in k(t), and G\n    = [G1, ..., Gm] in k(t)^m, return h = [h1, ..., hr] in k(t)^r and\n    a matrix A with m + r columns and entries in Const(k) such that\n    Dy + f*y = Sum(ci*Gi, (i, 1, m)) has a solution y\n    in k(t) with c1, ..., cm in Const(k) if and only if y = Sum(dj*hj,\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\n    d1, ..., dr) is a solution of Ax == 0.\n\n    Elements of k(t) are tuples (a, d) with a and d in k[t].\n    \"\"\"\n    m = len(G)\n    (q, (fa, fd)) = weak_normalizer(fa, fd, DE)\n    gamma = q\n    G = [(q * ga).cancel(gd, include=True) for (ga, gd) in G]\n    (a, (ba, bd), G, hn) = prde_normal_denom(fa, fd, G, DE)\n    gamma *= hn\n    (A, B, G, hs) = prde_special_denom(a, ba, bd, G, DE)\n    gamma *= hs\n    g = A.gcd(B)\n    (a, b, g) = (A.quo(g), B.quo(g), [gia.cancel(gid * g, include=True) for (gia, gid) in G])\n    (q, M) = prde_linear_constraints(a, b, g, DE)\n    (M, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = M.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mq = Matrix([q])\n    r = [(Mq * vj)[0] for vj in V]\n    try:\n        n = bound_degree(a, b, r, DE, parametric=True)\n    except NotImplementedError:\n        n = 5\n    (h, B) = param_poly_rischDE(a, b, r, n, DE)\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(h), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    W = A.nullspace()\n    v = len(h)\n    shape = (len(W), m + v)\n    elements = [wl[:m] + wl[-v:] for wl in W]\n    items = [e for row in elements for e in row]\n    M = Matrix(*shape, items, DE.t)\n    N = M.nullspace()\n    C = Matrix([ni[:] for ni in N], DE.t)\n    return ([hk.cancel(gamma, include=True) for hk in h], C)",
        "mutated": [
            "def param_rischDE(fa, fd, G, DE):\n    if False:\n        i = 10\n    '\\n    Solve a Parametric Risch Differential Equation: Dy + f*y == Sum(ci*Gi, (i, 1, m)).\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k(t), f in k(t), and G\\n    = [G1, ..., Gm] in k(t)^m, return h = [h1, ..., hr] in k(t)^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    Dy + f*y = Sum(ci*Gi, (i, 1, m)) has a solution y\\n    in k(t) with c1, ..., cm in Const(k) if and only if y = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n\\n    Elements of k(t) are tuples (a, d) with a and d in k[t].\\n    '\n    m = len(G)\n    (q, (fa, fd)) = weak_normalizer(fa, fd, DE)\n    gamma = q\n    G = [(q * ga).cancel(gd, include=True) for (ga, gd) in G]\n    (a, (ba, bd), G, hn) = prde_normal_denom(fa, fd, G, DE)\n    gamma *= hn\n    (A, B, G, hs) = prde_special_denom(a, ba, bd, G, DE)\n    gamma *= hs\n    g = A.gcd(B)\n    (a, b, g) = (A.quo(g), B.quo(g), [gia.cancel(gid * g, include=True) for (gia, gid) in G])\n    (q, M) = prde_linear_constraints(a, b, g, DE)\n    (M, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = M.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mq = Matrix([q])\n    r = [(Mq * vj)[0] for vj in V]\n    try:\n        n = bound_degree(a, b, r, DE, parametric=True)\n    except NotImplementedError:\n        n = 5\n    (h, B) = param_poly_rischDE(a, b, r, n, DE)\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(h), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    W = A.nullspace()\n    v = len(h)\n    shape = (len(W), m + v)\n    elements = [wl[:m] + wl[-v:] for wl in W]\n    items = [e for row in elements for e in row]\n    M = Matrix(*shape, items, DE.t)\n    N = M.nullspace()\n    C = Matrix([ni[:] for ni in N], DE.t)\n    return ([hk.cancel(gamma, include=True) for hk in h], C)",
            "def param_rischDE(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Solve a Parametric Risch Differential Equation: Dy + f*y == Sum(ci*Gi, (i, 1, m)).\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k(t), f in k(t), and G\\n    = [G1, ..., Gm] in k(t)^m, return h = [h1, ..., hr] in k(t)^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    Dy + f*y = Sum(ci*Gi, (i, 1, m)) has a solution y\\n    in k(t) with c1, ..., cm in Const(k) if and only if y = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n\\n    Elements of k(t) are tuples (a, d) with a and d in k[t].\\n    '\n    m = len(G)\n    (q, (fa, fd)) = weak_normalizer(fa, fd, DE)\n    gamma = q\n    G = [(q * ga).cancel(gd, include=True) for (ga, gd) in G]\n    (a, (ba, bd), G, hn) = prde_normal_denom(fa, fd, G, DE)\n    gamma *= hn\n    (A, B, G, hs) = prde_special_denom(a, ba, bd, G, DE)\n    gamma *= hs\n    g = A.gcd(B)\n    (a, b, g) = (A.quo(g), B.quo(g), [gia.cancel(gid * g, include=True) for (gia, gid) in G])\n    (q, M) = prde_linear_constraints(a, b, g, DE)\n    (M, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = M.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mq = Matrix([q])\n    r = [(Mq * vj)[0] for vj in V]\n    try:\n        n = bound_degree(a, b, r, DE, parametric=True)\n    except NotImplementedError:\n        n = 5\n    (h, B) = param_poly_rischDE(a, b, r, n, DE)\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(h), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    W = A.nullspace()\n    v = len(h)\n    shape = (len(W), m + v)\n    elements = [wl[:m] + wl[-v:] for wl in W]\n    items = [e for row in elements for e in row]\n    M = Matrix(*shape, items, DE.t)\n    N = M.nullspace()\n    C = Matrix([ni[:] for ni in N], DE.t)\n    return ([hk.cancel(gamma, include=True) for hk in h], C)",
            "def param_rischDE(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Solve a Parametric Risch Differential Equation: Dy + f*y == Sum(ci*Gi, (i, 1, m)).\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k(t), f in k(t), and G\\n    = [G1, ..., Gm] in k(t)^m, return h = [h1, ..., hr] in k(t)^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    Dy + f*y = Sum(ci*Gi, (i, 1, m)) has a solution y\\n    in k(t) with c1, ..., cm in Const(k) if and only if y = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n\\n    Elements of k(t) are tuples (a, d) with a and d in k[t].\\n    '\n    m = len(G)\n    (q, (fa, fd)) = weak_normalizer(fa, fd, DE)\n    gamma = q\n    G = [(q * ga).cancel(gd, include=True) for (ga, gd) in G]\n    (a, (ba, bd), G, hn) = prde_normal_denom(fa, fd, G, DE)\n    gamma *= hn\n    (A, B, G, hs) = prde_special_denom(a, ba, bd, G, DE)\n    gamma *= hs\n    g = A.gcd(B)\n    (a, b, g) = (A.quo(g), B.quo(g), [gia.cancel(gid * g, include=True) for (gia, gid) in G])\n    (q, M) = prde_linear_constraints(a, b, g, DE)\n    (M, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = M.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mq = Matrix([q])\n    r = [(Mq * vj)[0] for vj in V]\n    try:\n        n = bound_degree(a, b, r, DE, parametric=True)\n    except NotImplementedError:\n        n = 5\n    (h, B) = param_poly_rischDE(a, b, r, n, DE)\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(h), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    W = A.nullspace()\n    v = len(h)\n    shape = (len(W), m + v)\n    elements = [wl[:m] + wl[-v:] for wl in W]\n    items = [e for row in elements for e in row]\n    M = Matrix(*shape, items, DE.t)\n    N = M.nullspace()\n    C = Matrix([ni[:] for ni in N], DE.t)\n    return ([hk.cancel(gamma, include=True) for hk in h], C)",
            "def param_rischDE(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Solve a Parametric Risch Differential Equation: Dy + f*y == Sum(ci*Gi, (i, 1, m)).\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k(t), f in k(t), and G\\n    = [G1, ..., Gm] in k(t)^m, return h = [h1, ..., hr] in k(t)^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    Dy + f*y = Sum(ci*Gi, (i, 1, m)) has a solution y\\n    in k(t) with c1, ..., cm in Const(k) if and only if y = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n\\n    Elements of k(t) are tuples (a, d) with a and d in k[t].\\n    '\n    m = len(G)\n    (q, (fa, fd)) = weak_normalizer(fa, fd, DE)\n    gamma = q\n    G = [(q * ga).cancel(gd, include=True) for (ga, gd) in G]\n    (a, (ba, bd), G, hn) = prde_normal_denom(fa, fd, G, DE)\n    gamma *= hn\n    (A, B, G, hs) = prde_special_denom(a, ba, bd, G, DE)\n    gamma *= hs\n    g = A.gcd(B)\n    (a, b, g) = (A.quo(g), B.quo(g), [gia.cancel(gid * g, include=True) for (gia, gid) in G])\n    (q, M) = prde_linear_constraints(a, b, g, DE)\n    (M, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = M.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mq = Matrix([q])\n    r = [(Mq * vj)[0] for vj in V]\n    try:\n        n = bound_degree(a, b, r, DE, parametric=True)\n    except NotImplementedError:\n        n = 5\n    (h, B) = param_poly_rischDE(a, b, r, n, DE)\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(h), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    W = A.nullspace()\n    v = len(h)\n    shape = (len(W), m + v)\n    elements = [wl[:m] + wl[-v:] for wl in W]\n    items = [e for row in elements for e in row]\n    M = Matrix(*shape, items, DE.t)\n    N = M.nullspace()\n    C = Matrix([ni[:] for ni in N], DE.t)\n    return ([hk.cancel(gamma, include=True) for hk in h], C)",
            "def param_rischDE(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Solve a Parametric Risch Differential Equation: Dy + f*y == Sum(ci*Gi, (i, 1, m)).\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D in k(t), f in k(t), and G\\n    = [G1, ..., Gm] in k(t)^m, return h = [h1, ..., hr] in k(t)^r and\\n    a matrix A with m + r columns and entries in Const(k) such that\\n    Dy + f*y = Sum(ci*Gi, (i, 1, m)) has a solution y\\n    in k(t) with c1, ..., cm in Const(k) if and only if y = Sum(dj*hj,\\n    (j, 1, r)) where d1, ..., dr are in Const(k) and (c1, ..., cm,\\n    d1, ..., dr) is a solution of Ax == 0.\\n\\n    Elements of k(t) are tuples (a, d) with a and d in k[t].\\n    '\n    m = len(G)\n    (q, (fa, fd)) = weak_normalizer(fa, fd, DE)\n    gamma = q\n    G = [(q * ga).cancel(gd, include=True) for (ga, gd) in G]\n    (a, (ba, bd), G, hn) = prde_normal_denom(fa, fd, G, DE)\n    gamma *= hn\n    (A, B, G, hs) = prde_special_denom(a, ba, bd, G, DE)\n    gamma *= hs\n    g = A.gcd(B)\n    (a, b, g) = (A.quo(g), B.quo(g), [gia.cancel(gid * g, include=True) for (gia, gid) in G])\n    (q, M) = prde_linear_constraints(a, b, g, DE)\n    (M, _) = constant_system(M, zeros(M.rows, 1, DE.t), DE)\n    V = M.nullspace()\n    if not V:\n        return ([], eye(m, DE.t))\n    Mq = Matrix([q])\n    r = [(Mq * vj)[0] for vj in V]\n    try:\n        n = bound_degree(a, b, r, DE, parametric=True)\n    except NotImplementedError:\n        n = 5\n    (h, B) = param_poly_rischDE(a, b, r, n, DE)\n    A = -eye(m, DE.t)\n    for vj in V:\n        A = A.row_join(vj)\n    A = A.row_join(zeros(m, len(h), DE.t))\n    A = A.col_join(zeros(B.rows, m, DE.t).row_join(B))\n    W = A.nullspace()\n    v = len(h)\n    shape = (len(W), m + v)\n    elements = [wl[:m] + wl[-v:] for wl in W]\n    items = [e for row in elements for e in row]\n    M = Matrix(*shape, items, DE.t)\n    N = M.nullspace()\n    C = Matrix([ni[:] for ni in N], DE.t)\n    return ([hk.cancel(gamma, include=True) for hk in h], C)"
        ]
    },
    {
        "func_name": "limited_integrate_reduce",
        "original": "def limited_integrate_reduce(fa, fd, G, DE):\n    \"\"\"\n    Simpler version of step 1 & 2 for the limited integration problem.\n\n    Explanation\n    ===========\n\n    Given a derivation D on k(t) and f, g1, ..., gn in k(t), return\n    (a, b, h, N, g, V) such that a, b, h in k[t], N is a non-negative integer,\n    g in k(t), V == [v1, ..., vm] in k(t)^m, and for any solution v in k(t),\n    c1, ..., cm in C of f == Dv + Sum(ci*wi, (i, 1, m)), p = v*h is in k<t>, and\n    p and the ci satisfy a*Dp + b*p == g + Sum(ci*vi, (i, 1, m)).  Furthermore,\n    if S1irr == Sirr, then p is in k[t], and if t is nonlinear or Liouvillian\n    over k, then deg(p) <= N.\n\n    So that the special part is always computed, this function calls the more\n    general prde_special_denom() automatically if it cannot determine that\n    S1irr == Sirr.  Furthermore, it will automatically call bound_degree() when\n    t is linear and non-Liouvillian, which for the transcendental case, implies\n    that Dt == a*t + b with for some a, b in k*.\n    \"\"\"\n    (dn, ds) = splitfactor(fd, DE)\n    E = [splitfactor(gd, DE) for (_, gd) in G]\n    (En, Es) = list(zip(*E))\n    c = reduce(lambda i, j: i.lcm(j), (dn,) + En)\n    hn = c.gcd(c.diff(DE.t))\n    a = hn\n    b = -derivation(hn, DE)\n    N = 0\n    if DE.case in ('base', 'primitive', 'exp', 'tan'):\n        hs = reduce(lambda i, j: i.lcm(j), (ds,) + Es)\n        a = hn * hs\n        b -= (hn * derivation(hs, DE)).quo(hs)\n        mu = min(order_at_oo(fa, fd, DE.t), min([order_at_oo(ga, gd, DE.t) for (ga, gd) in G]))\n        N = hn.degree(DE.t) + hs.degree(DE.t) + max(0, 1 - DE.d.degree(DE.t) - mu)\n    else:\n        raise NotImplementedError\n    V = [(-a * hn * ga).cancel(gd, include=True) for (ga, gd) in G]\n    return (a, b, a, N, (a * hn * fa).cancel(fd, include=True), V)",
        "mutated": [
            "def limited_integrate_reduce(fa, fd, G, DE):\n    if False:\n        i = 10\n    '\\n    Simpler version of step 1 & 2 for the limited integration problem.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k(t) and f, g1, ..., gn in k(t), return\\n    (a, b, h, N, g, V) such that a, b, h in k[t], N is a non-negative integer,\\n    g in k(t), V == [v1, ..., vm] in k(t)^m, and for any solution v in k(t),\\n    c1, ..., cm in C of f == Dv + Sum(ci*wi, (i, 1, m)), p = v*h is in k<t>, and\\n    p and the ci satisfy a*Dp + b*p == g + Sum(ci*vi, (i, 1, m)).  Furthermore,\\n    if S1irr == Sirr, then p is in k[t], and if t is nonlinear or Liouvillian\\n    over k, then deg(p) <= N.\\n\\n    So that the special part is always computed, this function calls the more\\n    general prde_special_denom() automatically if it cannot determine that\\n    S1irr == Sirr.  Furthermore, it will automatically call bound_degree() when\\n    t is linear and non-Liouvillian, which for the transcendental case, implies\\n    that Dt == a*t + b with for some a, b in k*.\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    E = [splitfactor(gd, DE) for (_, gd) in G]\n    (En, Es) = list(zip(*E))\n    c = reduce(lambda i, j: i.lcm(j), (dn,) + En)\n    hn = c.gcd(c.diff(DE.t))\n    a = hn\n    b = -derivation(hn, DE)\n    N = 0\n    if DE.case in ('base', 'primitive', 'exp', 'tan'):\n        hs = reduce(lambda i, j: i.lcm(j), (ds,) + Es)\n        a = hn * hs\n        b -= (hn * derivation(hs, DE)).quo(hs)\n        mu = min(order_at_oo(fa, fd, DE.t), min([order_at_oo(ga, gd, DE.t) for (ga, gd) in G]))\n        N = hn.degree(DE.t) + hs.degree(DE.t) + max(0, 1 - DE.d.degree(DE.t) - mu)\n    else:\n        raise NotImplementedError\n    V = [(-a * hn * ga).cancel(gd, include=True) for (ga, gd) in G]\n    return (a, b, a, N, (a * hn * fa).cancel(fd, include=True), V)",
            "def limited_integrate_reduce(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Simpler version of step 1 & 2 for the limited integration problem.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k(t) and f, g1, ..., gn in k(t), return\\n    (a, b, h, N, g, V) such that a, b, h in k[t], N is a non-negative integer,\\n    g in k(t), V == [v1, ..., vm] in k(t)^m, and for any solution v in k(t),\\n    c1, ..., cm in C of f == Dv + Sum(ci*wi, (i, 1, m)), p = v*h is in k<t>, and\\n    p and the ci satisfy a*Dp + b*p == g + Sum(ci*vi, (i, 1, m)).  Furthermore,\\n    if S1irr == Sirr, then p is in k[t], and if t is nonlinear or Liouvillian\\n    over k, then deg(p) <= N.\\n\\n    So that the special part is always computed, this function calls the more\\n    general prde_special_denom() automatically if it cannot determine that\\n    S1irr == Sirr.  Furthermore, it will automatically call bound_degree() when\\n    t is linear and non-Liouvillian, which for the transcendental case, implies\\n    that Dt == a*t + b with for some a, b in k*.\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    E = [splitfactor(gd, DE) for (_, gd) in G]\n    (En, Es) = list(zip(*E))\n    c = reduce(lambda i, j: i.lcm(j), (dn,) + En)\n    hn = c.gcd(c.diff(DE.t))\n    a = hn\n    b = -derivation(hn, DE)\n    N = 0\n    if DE.case in ('base', 'primitive', 'exp', 'tan'):\n        hs = reduce(lambda i, j: i.lcm(j), (ds,) + Es)\n        a = hn * hs\n        b -= (hn * derivation(hs, DE)).quo(hs)\n        mu = min(order_at_oo(fa, fd, DE.t), min([order_at_oo(ga, gd, DE.t) for (ga, gd) in G]))\n        N = hn.degree(DE.t) + hs.degree(DE.t) + max(0, 1 - DE.d.degree(DE.t) - mu)\n    else:\n        raise NotImplementedError\n    V = [(-a * hn * ga).cancel(gd, include=True) for (ga, gd) in G]\n    return (a, b, a, N, (a * hn * fa).cancel(fd, include=True), V)",
            "def limited_integrate_reduce(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Simpler version of step 1 & 2 for the limited integration problem.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k(t) and f, g1, ..., gn in k(t), return\\n    (a, b, h, N, g, V) such that a, b, h in k[t], N is a non-negative integer,\\n    g in k(t), V == [v1, ..., vm] in k(t)^m, and for any solution v in k(t),\\n    c1, ..., cm in C of f == Dv + Sum(ci*wi, (i, 1, m)), p = v*h is in k<t>, and\\n    p and the ci satisfy a*Dp + b*p == g + Sum(ci*vi, (i, 1, m)).  Furthermore,\\n    if S1irr == Sirr, then p is in k[t], and if t is nonlinear or Liouvillian\\n    over k, then deg(p) <= N.\\n\\n    So that the special part is always computed, this function calls the more\\n    general prde_special_denom() automatically if it cannot determine that\\n    S1irr == Sirr.  Furthermore, it will automatically call bound_degree() when\\n    t is linear and non-Liouvillian, which for the transcendental case, implies\\n    that Dt == a*t + b with for some a, b in k*.\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    E = [splitfactor(gd, DE) for (_, gd) in G]\n    (En, Es) = list(zip(*E))\n    c = reduce(lambda i, j: i.lcm(j), (dn,) + En)\n    hn = c.gcd(c.diff(DE.t))\n    a = hn\n    b = -derivation(hn, DE)\n    N = 0\n    if DE.case in ('base', 'primitive', 'exp', 'tan'):\n        hs = reduce(lambda i, j: i.lcm(j), (ds,) + Es)\n        a = hn * hs\n        b -= (hn * derivation(hs, DE)).quo(hs)\n        mu = min(order_at_oo(fa, fd, DE.t), min([order_at_oo(ga, gd, DE.t) for (ga, gd) in G]))\n        N = hn.degree(DE.t) + hs.degree(DE.t) + max(0, 1 - DE.d.degree(DE.t) - mu)\n    else:\n        raise NotImplementedError\n    V = [(-a * hn * ga).cancel(gd, include=True) for (ga, gd) in G]\n    return (a, b, a, N, (a * hn * fa).cancel(fd, include=True), V)",
            "def limited_integrate_reduce(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Simpler version of step 1 & 2 for the limited integration problem.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k(t) and f, g1, ..., gn in k(t), return\\n    (a, b, h, N, g, V) such that a, b, h in k[t], N is a non-negative integer,\\n    g in k(t), V == [v1, ..., vm] in k(t)^m, and for any solution v in k(t),\\n    c1, ..., cm in C of f == Dv + Sum(ci*wi, (i, 1, m)), p = v*h is in k<t>, and\\n    p and the ci satisfy a*Dp + b*p == g + Sum(ci*vi, (i, 1, m)).  Furthermore,\\n    if S1irr == Sirr, then p is in k[t], and if t is nonlinear or Liouvillian\\n    over k, then deg(p) <= N.\\n\\n    So that the special part is always computed, this function calls the more\\n    general prde_special_denom() automatically if it cannot determine that\\n    S1irr == Sirr.  Furthermore, it will automatically call bound_degree() when\\n    t is linear and non-Liouvillian, which for the transcendental case, implies\\n    that Dt == a*t + b with for some a, b in k*.\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    E = [splitfactor(gd, DE) for (_, gd) in G]\n    (En, Es) = list(zip(*E))\n    c = reduce(lambda i, j: i.lcm(j), (dn,) + En)\n    hn = c.gcd(c.diff(DE.t))\n    a = hn\n    b = -derivation(hn, DE)\n    N = 0\n    if DE.case in ('base', 'primitive', 'exp', 'tan'):\n        hs = reduce(lambda i, j: i.lcm(j), (ds,) + Es)\n        a = hn * hs\n        b -= (hn * derivation(hs, DE)).quo(hs)\n        mu = min(order_at_oo(fa, fd, DE.t), min([order_at_oo(ga, gd, DE.t) for (ga, gd) in G]))\n        N = hn.degree(DE.t) + hs.degree(DE.t) + max(0, 1 - DE.d.degree(DE.t) - mu)\n    else:\n        raise NotImplementedError\n    V = [(-a * hn * ga).cancel(gd, include=True) for (ga, gd) in G]\n    return (a, b, a, N, (a * hn * fa).cancel(fd, include=True), V)",
            "def limited_integrate_reduce(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Simpler version of step 1 & 2 for the limited integration problem.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k(t) and f, g1, ..., gn in k(t), return\\n    (a, b, h, N, g, V) such that a, b, h in k[t], N is a non-negative integer,\\n    g in k(t), V == [v1, ..., vm] in k(t)^m, and for any solution v in k(t),\\n    c1, ..., cm in C of f == Dv + Sum(ci*wi, (i, 1, m)), p = v*h is in k<t>, and\\n    p and the ci satisfy a*Dp + b*p == g + Sum(ci*vi, (i, 1, m)).  Furthermore,\\n    if S1irr == Sirr, then p is in k[t], and if t is nonlinear or Liouvillian\\n    over k, then deg(p) <= N.\\n\\n    So that the special part is always computed, this function calls the more\\n    general prde_special_denom() automatically if it cannot determine that\\n    S1irr == Sirr.  Furthermore, it will automatically call bound_degree() when\\n    t is linear and non-Liouvillian, which for the transcendental case, implies\\n    that Dt == a*t + b with for some a, b in k*.\\n    '\n    (dn, ds) = splitfactor(fd, DE)\n    E = [splitfactor(gd, DE) for (_, gd) in G]\n    (En, Es) = list(zip(*E))\n    c = reduce(lambda i, j: i.lcm(j), (dn,) + En)\n    hn = c.gcd(c.diff(DE.t))\n    a = hn\n    b = -derivation(hn, DE)\n    N = 0\n    if DE.case in ('base', 'primitive', 'exp', 'tan'):\n        hs = reduce(lambda i, j: i.lcm(j), (ds,) + Es)\n        a = hn * hs\n        b -= (hn * derivation(hs, DE)).quo(hs)\n        mu = min(order_at_oo(fa, fd, DE.t), min([order_at_oo(ga, gd, DE.t) for (ga, gd) in G]))\n        N = hn.degree(DE.t) + hs.degree(DE.t) + max(0, 1 - DE.d.degree(DE.t) - mu)\n    else:\n        raise NotImplementedError\n    V = [(-a * hn * ga).cancel(gd, include=True) for (ga, gd) in G]\n    return (a, b, a, N, (a * hn * fa).cancel(fd, include=True), V)"
        ]
    },
    {
        "func_name": "limited_integrate",
        "original": "def limited_integrate(fa, fd, G, DE):\n    \"\"\"\n    Solves the limited integration problem:  f = Dv + Sum(ci*wi, (i, 1, n))\n    \"\"\"\n    (fa, fd) = (fa * Poly(1 / fd.LC(), DE.t), fd.monic())\n    Fa = Poly(0, DE.t)\n    Fd = Poly(1, DE.t)\n    G = [(fa, fd)] + G\n    (h, A) = param_rischDE(Fa, Fd, G, DE)\n    V = A.nullspace()\n    V = [v for v in V if v[0] != 0]\n    if not V:\n        return None\n    else:\n        c0 = V[0][0]\n        v = V[0] / -c0\n        r = len(h)\n        m = len(v) - r - 1\n        C = list(v[1:m + 1])\n        y = -sum([v[m + 1 + i] * h[i][0].as_expr() / h[i][1].as_expr() for i in range(r)])\n        (y_num, y_den) = y.as_numer_denom()\n        (Ya, Yd) = (Poly(y_num, DE.t), Poly(y_den, DE.t))\n        Y = (Ya * Poly(1 / Yd.LC(), DE.t), Yd.monic())\n        return (Y, C)",
        "mutated": [
            "def limited_integrate(fa, fd, G, DE):\n    if False:\n        i = 10\n    '\\n    Solves the limited integration problem:  f = Dv + Sum(ci*wi, (i, 1, n))\\n    '\n    (fa, fd) = (fa * Poly(1 / fd.LC(), DE.t), fd.monic())\n    Fa = Poly(0, DE.t)\n    Fd = Poly(1, DE.t)\n    G = [(fa, fd)] + G\n    (h, A) = param_rischDE(Fa, Fd, G, DE)\n    V = A.nullspace()\n    V = [v for v in V if v[0] != 0]\n    if not V:\n        return None\n    else:\n        c0 = V[0][0]\n        v = V[0] / -c0\n        r = len(h)\n        m = len(v) - r - 1\n        C = list(v[1:m + 1])\n        y = -sum([v[m + 1 + i] * h[i][0].as_expr() / h[i][1].as_expr() for i in range(r)])\n        (y_num, y_den) = y.as_numer_denom()\n        (Ya, Yd) = (Poly(y_num, DE.t), Poly(y_den, DE.t))\n        Y = (Ya * Poly(1 / Yd.LC(), DE.t), Yd.monic())\n        return (Y, C)",
            "def limited_integrate(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Solves the limited integration problem:  f = Dv + Sum(ci*wi, (i, 1, n))\\n    '\n    (fa, fd) = (fa * Poly(1 / fd.LC(), DE.t), fd.monic())\n    Fa = Poly(0, DE.t)\n    Fd = Poly(1, DE.t)\n    G = [(fa, fd)] + G\n    (h, A) = param_rischDE(Fa, Fd, G, DE)\n    V = A.nullspace()\n    V = [v for v in V if v[0] != 0]\n    if not V:\n        return None\n    else:\n        c0 = V[0][0]\n        v = V[0] / -c0\n        r = len(h)\n        m = len(v) - r - 1\n        C = list(v[1:m + 1])\n        y = -sum([v[m + 1 + i] * h[i][0].as_expr() / h[i][1].as_expr() for i in range(r)])\n        (y_num, y_den) = y.as_numer_denom()\n        (Ya, Yd) = (Poly(y_num, DE.t), Poly(y_den, DE.t))\n        Y = (Ya * Poly(1 / Yd.LC(), DE.t), Yd.monic())\n        return (Y, C)",
            "def limited_integrate(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Solves the limited integration problem:  f = Dv + Sum(ci*wi, (i, 1, n))\\n    '\n    (fa, fd) = (fa * Poly(1 / fd.LC(), DE.t), fd.monic())\n    Fa = Poly(0, DE.t)\n    Fd = Poly(1, DE.t)\n    G = [(fa, fd)] + G\n    (h, A) = param_rischDE(Fa, Fd, G, DE)\n    V = A.nullspace()\n    V = [v for v in V if v[0] != 0]\n    if not V:\n        return None\n    else:\n        c0 = V[0][0]\n        v = V[0] / -c0\n        r = len(h)\n        m = len(v) - r - 1\n        C = list(v[1:m + 1])\n        y = -sum([v[m + 1 + i] * h[i][0].as_expr() / h[i][1].as_expr() for i in range(r)])\n        (y_num, y_den) = y.as_numer_denom()\n        (Ya, Yd) = (Poly(y_num, DE.t), Poly(y_den, DE.t))\n        Y = (Ya * Poly(1 / Yd.LC(), DE.t), Yd.monic())\n        return (Y, C)",
            "def limited_integrate(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Solves the limited integration problem:  f = Dv + Sum(ci*wi, (i, 1, n))\\n    '\n    (fa, fd) = (fa * Poly(1 / fd.LC(), DE.t), fd.monic())\n    Fa = Poly(0, DE.t)\n    Fd = Poly(1, DE.t)\n    G = [(fa, fd)] + G\n    (h, A) = param_rischDE(Fa, Fd, G, DE)\n    V = A.nullspace()\n    V = [v for v in V if v[0] != 0]\n    if not V:\n        return None\n    else:\n        c0 = V[0][0]\n        v = V[0] / -c0\n        r = len(h)\n        m = len(v) - r - 1\n        C = list(v[1:m + 1])\n        y = -sum([v[m + 1 + i] * h[i][0].as_expr() / h[i][1].as_expr() for i in range(r)])\n        (y_num, y_den) = y.as_numer_denom()\n        (Ya, Yd) = (Poly(y_num, DE.t), Poly(y_den, DE.t))\n        Y = (Ya * Poly(1 / Yd.LC(), DE.t), Yd.monic())\n        return (Y, C)",
            "def limited_integrate(fa, fd, G, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Solves the limited integration problem:  f = Dv + Sum(ci*wi, (i, 1, n))\\n    '\n    (fa, fd) = (fa * Poly(1 / fd.LC(), DE.t), fd.monic())\n    Fa = Poly(0, DE.t)\n    Fd = Poly(1, DE.t)\n    G = [(fa, fd)] + G\n    (h, A) = param_rischDE(Fa, Fd, G, DE)\n    V = A.nullspace()\n    V = [v for v in V if v[0] != 0]\n    if not V:\n        return None\n    else:\n        c0 = V[0][0]\n        v = V[0] / -c0\n        r = len(h)\n        m = len(v) - r - 1\n        C = list(v[1:m + 1])\n        y = -sum([v[m + 1 + i] * h[i][0].as_expr() / h[i][1].as_expr() for i in range(r)])\n        (y_num, y_den) = y.as_numer_denom()\n        (Ya, Yd) = (Poly(y_num, DE.t), Poly(y_den, DE.t))\n        Y = (Ya * Poly(1 / Yd.LC(), DE.t), Yd.monic())\n        return (Y, C)"
        ]
    },
    {
        "func_name": "parametric_log_deriv_heu",
        "original": "def parametric_log_deriv_heu(fa, fd, wa, wd, DE, c1=None):\n    \"\"\"\n    Parametric logarithmic derivative heuristic.\n\n    Explanation\n    ===========\n\n    Given a derivation D on k[t], f in k(t), and a hyperexponential monomial\n    theta over k(t), raises either NotImplementedError, in which case the\n    heuristic failed, or returns None, in which case it has proven that no\n    solution exists, or returns a solution (n, m, v) of the equation\n    n*f == Dv/v + m*Dtheta/theta, with v in k(t)* and n, m in ZZ with n != 0.\n\n    If this heuristic fails, the structure theorem approach will need to be\n    used.\n\n    The argument w == Dtheta/theta\n    \"\"\"\n    c1 = c1 or Dummy('c1')\n    (p, a) = fa.div(fd)\n    (q, b) = wa.div(wd)\n    B = max(0, derivation(DE.t, DE).degree(DE.t) - 1)\n    C = max(p.degree(DE.t), q.degree(DE.t))\n    if q.degree(DE.t) > B:\n        eqs = [p.nth(i) - c1 * q.nth(i) for i in range(B + 1, C + 1)]\n        s = solve(eqs, c1)\n        if not s or not s[c1].is_Rational:\n            return None\n        (M, N) = s[c1].as_numer_denom()\n        M_poly = M.as_poly(q.gens)\n        N_poly = N.as_poly(q.gens)\n        nfmwa = N_poly * fa * wd - M_poly * wa * fd\n        nfmwd = fd * wd\n        Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE, 'auto')\n        if Qv is None:\n            return None\n        (Q, v) = Qv\n        if Q.is_zero or v.is_zero:\n            return None\n        return (Q * N, Q * M, v)\n    if p.degree(DE.t) > B:\n        return None\n    c = lcm(fd.as_poly(DE.t).LC(), wd.as_poly(DE.t).LC())\n    l = fd.monic().lcm(wd.monic()) * Poly(c, DE.t)\n    (ln, ls) = splitfactor(l, DE)\n    z = ls * ln.gcd(ln.diff(DE.t))\n    if not z.has(DE.t):\n        return None\n    (u1, r1) = (fa * l.quo(fd)).div(z)\n    (u2, r2) = (wa * l.quo(wd)).div(z)\n    eqs = [r1.nth(i) - c1 * r2.nth(i) for i in range(z.degree(DE.t))]\n    s = solve(eqs, c1)\n    if not s or not s[c1].is_Rational:\n        return None\n    (M, N) = s[c1].as_numer_denom()\n    nfmwa = N.as_poly(DE.t) * fa * wd - M.as_poly(DE.t) * wa * fd\n    nfmwd = fd * wd\n    Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE)\n    if Qv is None:\n        return None\n    (Q, v) = Qv\n    if Q.is_zero or v.is_zero:\n        return None\n    return (Q * N, Q * M, v)",
        "mutated": [
            "def parametric_log_deriv_heu(fa, fd, wa, wd, DE, c1=None):\n    if False:\n        i = 10\n    '\\n    Parametric logarithmic derivative heuristic.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], f in k(t), and a hyperexponential monomial\\n    theta over k(t), raises either NotImplementedError, in which case the\\n    heuristic failed, or returns None, in which case it has proven that no\\n    solution exists, or returns a solution (n, m, v) of the equation\\n    n*f == Dv/v + m*Dtheta/theta, with v in k(t)* and n, m in ZZ with n != 0.\\n\\n    If this heuristic fails, the structure theorem approach will need to be\\n    used.\\n\\n    The argument w == Dtheta/theta\\n    '\n    c1 = c1 or Dummy('c1')\n    (p, a) = fa.div(fd)\n    (q, b) = wa.div(wd)\n    B = max(0, derivation(DE.t, DE).degree(DE.t) - 1)\n    C = max(p.degree(DE.t), q.degree(DE.t))\n    if q.degree(DE.t) > B:\n        eqs = [p.nth(i) - c1 * q.nth(i) for i in range(B + 1, C + 1)]\n        s = solve(eqs, c1)\n        if not s or not s[c1].is_Rational:\n            return None\n        (M, N) = s[c1].as_numer_denom()\n        M_poly = M.as_poly(q.gens)\n        N_poly = N.as_poly(q.gens)\n        nfmwa = N_poly * fa * wd - M_poly * wa * fd\n        nfmwd = fd * wd\n        Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE, 'auto')\n        if Qv is None:\n            return None\n        (Q, v) = Qv\n        if Q.is_zero or v.is_zero:\n            return None\n        return (Q * N, Q * M, v)\n    if p.degree(DE.t) > B:\n        return None\n    c = lcm(fd.as_poly(DE.t).LC(), wd.as_poly(DE.t).LC())\n    l = fd.monic().lcm(wd.monic()) * Poly(c, DE.t)\n    (ln, ls) = splitfactor(l, DE)\n    z = ls * ln.gcd(ln.diff(DE.t))\n    if not z.has(DE.t):\n        return None\n    (u1, r1) = (fa * l.quo(fd)).div(z)\n    (u2, r2) = (wa * l.quo(wd)).div(z)\n    eqs = [r1.nth(i) - c1 * r2.nth(i) for i in range(z.degree(DE.t))]\n    s = solve(eqs, c1)\n    if not s or not s[c1].is_Rational:\n        return None\n    (M, N) = s[c1].as_numer_denom()\n    nfmwa = N.as_poly(DE.t) * fa * wd - M.as_poly(DE.t) * wa * fd\n    nfmwd = fd * wd\n    Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE)\n    if Qv is None:\n        return None\n    (Q, v) = Qv\n    if Q.is_zero or v.is_zero:\n        return None\n    return (Q * N, Q * M, v)",
            "def parametric_log_deriv_heu(fa, fd, wa, wd, DE, c1=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Parametric logarithmic derivative heuristic.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], f in k(t), and a hyperexponential monomial\\n    theta over k(t), raises either NotImplementedError, in which case the\\n    heuristic failed, or returns None, in which case it has proven that no\\n    solution exists, or returns a solution (n, m, v) of the equation\\n    n*f == Dv/v + m*Dtheta/theta, with v in k(t)* and n, m in ZZ with n != 0.\\n\\n    If this heuristic fails, the structure theorem approach will need to be\\n    used.\\n\\n    The argument w == Dtheta/theta\\n    '\n    c1 = c1 or Dummy('c1')\n    (p, a) = fa.div(fd)\n    (q, b) = wa.div(wd)\n    B = max(0, derivation(DE.t, DE).degree(DE.t) - 1)\n    C = max(p.degree(DE.t), q.degree(DE.t))\n    if q.degree(DE.t) > B:\n        eqs = [p.nth(i) - c1 * q.nth(i) for i in range(B + 1, C + 1)]\n        s = solve(eqs, c1)\n        if not s or not s[c1].is_Rational:\n            return None\n        (M, N) = s[c1].as_numer_denom()\n        M_poly = M.as_poly(q.gens)\n        N_poly = N.as_poly(q.gens)\n        nfmwa = N_poly * fa * wd - M_poly * wa * fd\n        nfmwd = fd * wd\n        Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE, 'auto')\n        if Qv is None:\n            return None\n        (Q, v) = Qv\n        if Q.is_zero or v.is_zero:\n            return None\n        return (Q * N, Q * M, v)\n    if p.degree(DE.t) > B:\n        return None\n    c = lcm(fd.as_poly(DE.t).LC(), wd.as_poly(DE.t).LC())\n    l = fd.monic().lcm(wd.monic()) * Poly(c, DE.t)\n    (ln, ls) = splitfactor(l, DE)\n    z = ls * ln.gcd(ln.diff(DE.t))\n    if not z.has(DE.t):\n        return None\n    (u1, r1) = (fa * l.quo(fd)).div(z)\n    (u2, r2) = (wa * l.quo(wd)).div(z)\n    eqs = [r1.nth(i) - c1 * r2.nth(i) for i in range(z.degree(DE.t))]\n    s = solve(eqs, c1)\n    if not s or not s[c1].is_Rational:\n        return None\n    (M, N) = s[c1].as_numer_denom()\n    nfmwa = N.as_poly(DE.t) * fa * wd - M.as_poly(DE.t) * wa * fd\n    nfmwd = fd * wd\n    Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE)\n    if Qv is None:\n        return None\n    (Q, v) = Qv\n    if Q.is_zero or v.is_zero:\n        return None\n    return (Q * N, Q * M, v)",
            "def parametric_log_deriv_heu(fa, fd, wa, wd, DE, c1=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Parametric logarithmic derivative heuristic.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], f in k(t), and a hyperexponential monomial\\n    theta over k(t), raises either NotImplementedError, in which case the\\n    heuristic failed, or returns None, in which case it has proven that no\\n    solution exists, or returns a solution (n, m, v) of the equation\\n    n*f == Dv/v + m*Dtheta/theta, with v in k(t)* and n, m in ZZ with n != 0.\\n\\n    If this heuristic fails, the structure theorem approach will need to be\\n    used.\\n\\n    The argument w == Dtheta/theta\\n    '\n    c1 = c1 or Dummy('c1')\n    (p, a) = fa.div(fd)\n    (q, b) = wa.div(wd)\n    B = max(0, derivation(DE.t, DE).degree(DE.t) - 1)\n    C = max(p.degree(DE.t), q.degree(DE.t))\n    if q.degree(DE.t) > B:\n        eqs = [p.nth(i) - c1 * q.nth(i) for i in range(B + 1, C + 1)]\n        s = solve(eqs, c1)\n        if not s or not s[c1].is_Rational:\n            return None\n        (M, N) = s[c1].as_numer_denom()\n        M_poly = M.as_poly(q.gens)\n        N_poly = N.as_poly(q.gens)\n        nfmwa = N_poly * fa * wd - M_poly * wa * fd\n        nfmwd = fd * wd\n        Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE, 'auto')\n        if Qv is None:\n            return None\n        (Q, v) = Qv\n        if Q.is_zero or v.is_zero:\n            return None\n        return (Q * N, Q * M, v)\n    if p.degree(DE.t) > B:\n        return None\n    c = lcm(fd.as_poly(DE.t).LC(), wd.as_poly(DE.t).LC())\n    l = fd.monic().lcm(wd.monic()) * Poly(c, DE.t)\n    (ln, ls) = splitfactor(l, DE)\n    z = ls * ln.gcd(ln.diff(DE.t))\n    if not z.has(DE.t):\n        return None\n    (u1, r1) = (fa * l.quo(fd)).div(z)\n    (u2, r2) = (wa * l.quo(wd)).div(z)\n    eqs = [r1.nth(i) - c1 * r2.nth(i) for i in range(z.degree(DE.t))]\n    s = solve(eqs, c1)\n    if not s or not s[c1].is_Rational:\n        return None\n    (M, N) = s[c1].as_numer_denom()\n    nfmwa = N.as_poly(DE.t) * fa * wd - M.as_poly(DE.t) * wa * fd\n    nfmwd = fd * wd\n    Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE)\n    if Qv is None:\n        return None\n    (Q, v) = Qv\n    if Q.is_zero or v.is_zero:\n        return None\n    return (Q * N, Q * M, v)",
            "def parametric_log_deriv_heu(fa, fd, wa, wd, DE, c1=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Parametric logarithmic derivative heuristic.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], f in k(t), and a hyperexponential monomial\\n    theta over k(t), raises either NotImplementedError, in which case the\\n    heuristic failed, or returns None, in which case it has proven that no\\n    solution exists, or returns a solution (n, m, v) of the equation\\n    n*f == Dv/v + m*Dtheta/theta, with v in k(t)* and n, m in ZZ with n != 0.\\n\\n    If this heuristic fails, the structure theorem approach will need to be\\n    used.\\n\\n    The argument w == Dtheta/theta\\n    '\n    c1 = c1 or Dummy('c1')\n    (p, a) = fa.div(fd)\n    (q, b) = wa.div(wd)\n    B = max(0, derivation(DE.t, DE).degree(DE.t) - 1)\n    C = max(p.degree(DE.t), q.degree(DE.t))\n    if q.degree(DE.t) > B:\n        eqs = [p.nth(i) - c1 * q.nth(i) for i in range(B + 1, C + 1)]\n        s = solve(eqs, c1)\n        if not s or not s[c1].is_Rational:\n            return None\n        (M, N) = s[c1].as_numer_denom()\n        M_poly = M.as_poly(q.gens)\n        N_poly = N.as_poly(q.gens)\n        nfmwa = N_poly * fa * wd - M_poly * wa * fd\n        nfmwd = fd * wd\n        Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE, 'auto')\n        if Qv is None:\n            return None\n        (Q, v) = Qv\n        if Q.is_zero or v.is_zero:\n            return None\n        return (Q * N, Q * M, v)\n    if p.degree(DE.t) > B:\n        return None\n    c = lcm(fd.as_poly(DE.t).LC(), wd.as_poly(DE.t).LC())\n    l = fd.monic().lcm(wd.monic()) * Poly(c, DE.t)\n    (ln, ls) = splitfactor(l, DE)\n    z = ls * ln.gcd(ln.diff(DE.t))\n    if not z.has(DE.t):\n        return None\n    (u1, r1) = (fa * l.quo(fd)).div(z)\n    (u2, r2) = (wa * l.quo(wd)).div(z)\n    eqs = [r1.nth(i) - c1 * r2.nth(i) for i in range(z.degree(DE.t))]\n    s = solve(eqs, c1)\n    if not s or not s[c1].is_Rational:\n        return None\n    (M, N) = s[c1].as_numer_denom()\n    nfmwa = N.as_poly(DE.t) * fa * wd - M.as_poly(DE.t) * wa * fd\n    nfmwd = fd * wd\n    Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE)\n    if Qv is None:\n        return None\n    (Q, v) = Qv\n    if Q.is_zero or v.is_zero:\n        return None\n    return (Q * N, Q * M, v)",
            "def parametric_log_deriv_heu(fa, fd, wa, wd, DE, c1=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Parametric logarithmic derivative heuristic.\\n\\n    Explanation\\n    ===========\\n\\n    Given a derivation D on k[t], f in k(t), and a hyperexponential monomial\\n    theta over k(t), raises either NotImplementedError, in which case the\\n    heuristic failed, or returns None, in which case it has proven that no\\n    solution exists, or returns a solution (n, m, v) of the equation\\n    n*f == Dv/v + m*Dtheta/theta, with v in k(t)* and n, m in ZZ with n != 0.\\n\\n    If this heuristic fails, the structure theorem approach will need to be\\n    used.\\n\\n    The argument w == Dtheta/theta\\n    '\n    c1 = c1 or Dummy('c1')\n    (p, a) = fa.div(fd)\n    (q, b) = wa.div(wd)\n    B = max(0, derivation(DE.t, DE).degree(DE.t) - 1)\n    C = max(p.degree(DE.t), q.degree(DE.t))\n    if q.degree(DE.t) > B:\n        eqs = [p.nth(i) - c1 * q.nth(i) for i in range(B + 1, C + 1)]\n        s = solve(eqs, c1)\n        if not s or not s[c1].is_Rational:\n            return None\n        (M, N) = s[c1].as_numer_denom()\n        M_poly = M.as_poly(q.gens)\n        N_poly = N.as_poly(q.gens)\n        nfmwa = N_poly * fa * wd - M_poly * wa * fd\n        nfmwd = fd * wd\n        Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE, 'auto')\n        if Qv is None:\n            return None\n        (Q, v) = Qv\n        if Q.is_zero or v.is_zero:\n            return None\n        return (Q * N, Q * M, v)\n    if p.degree(DE.t) > B:\n        return None\n    c = lcm(fd.as_poly(DE.t).LC(), wd.as_poly(DE.t).LC())\n    l = fd.monic().lcm(wd.monic()) * Poly(c, DE.t)\n    (ln, ls) = splitfactor(l, DE)\n    z = ls * ln.gcd(ln.diff(DE.t))\n    if not z.has(DE.t):\n        return None\n    (u1, r1) = (fa * l.quo(fd)).div(z)\n    (u2, r2) = (wa * l.quo(wd)).div(z)\n    eqs = [r1.nth(i) - c1 * r2.nth(i) for i in range(z.degree(DE.t))]\n    s = solve(eqs, c1)\n    if not s or not s[c1].is_Rational:\n        return None\n    (M, N) = s[c1].as_numer_denom()\n    nfmwa = N.as_poly(DE.t) * fa * wd - M.as_poly(DE.t) * wa * fd\n    nfmwd = fd * wd\n    Qv = is_log_deriv_k_t_radical_in_field(nfmwa, nfmwd, DE)\n    if Qv is None:\n        return None\n    (Q, v) = Qv\n    if Q.is_zero or v.is_zero:\n        return None\n    return (Q * N, Q * M, v)"
        ]
    },
    {
        "func_name": "parametric_log_deriv",
        "original": "def parametric_log_deriv(fa, fd, wa, wd, DE):\n    A = parametric_log_deriv_heu(fa, fd, wa, wd, DE)\n    return A",
        "mutated": [
            "def parametric_log_deriv(fa, fd, wa, wd, DE):\n    if False:\n        i = 10\n    A = parametric_log_deriv_heu(fa, fd, wa, wd, DE)\n    return A",
            "def parametric_log_deriv(fa, fd, wa, wd, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    A = parametric_log_deriv_heu(fa, fd, wa, wd, DE)\n    return A",
            "def parametric_log_deriv(fa, fd, wa, wd, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    A = parametric_log_deriv_heu(fa, fd, wa, wd, DE)\n    return A",
            "def parametric_log_deriv(fa, fd, wa, wd, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    A = parametric_log_deriv_heu(fa, fd, wa, wd, DE)\n    return A",
            "def parametric_log_deriv(fa, fd, wa, wd, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    A = parametric_log_deriv_heu(fa, fd, wa, wd, DE)\n    return A"
        ]
    },
    {
        "func_name": "is_deriv_k",
        "original": "def is_deriv_k(fa, fd, DE):\n    \"\"\"\n    Checks if Df/f is the derivative of an element of k(t).\n\n    Explanation\n    ===========\n\n    a in k(t) is the derivative of an element of k(t) if there exists b in k(t)\n    such that a = Db.  Either returns (ans, u), such that Df/f == Du, or None,\n    which means that Df/f is not the derivative of an element of k(t).  ans is\n    a list of tuples such that Add(*[i*j for i, j in ans]) == u.  This is useful\n    for seeing exactly which elements of k(t) produce u.\n\n    This function uses the structure theorem approach, which says that for any\n    f in K, Df/f is the derivative of a element of K if and only if there are ri\n    in QQ such that::\n\n            ---               ---       Dt\n            \\\\    r  * Dt   +  \\\\    r  *   i      Df\n            /     i     i     /     i   ---   =  --.\n            ---               ---        t        f\n         i in L            i in E         i\n               K/C(x)            K/C(x)\n\n\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\n    and L_K/C(x) are disjoint.\n\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\n    recursively using this same function.  Therefore, it is required to pass\n    them as indices to D (or T).  E_args are the arguments of the\n    hyperexponentials indexed by E_K (i.e., if i is in E_K, then T[i] ==\n    exp(E_args[i])).  This is needed to compute the final answer u such that\n    Df/f == Du.\n\n    log(f) will be the same as u up to a additive constant.  This is because\n    they will both behave the same as monomials. For example, both log(x) and\n    log(2*x) == log(x) + log(2) satisfy Dt == 1/x, because log(2) is constant.\n    Therefore, the term const is returned.  const is such that\n    log(const) + f == u.  This is calculated by dividing the arguments of one\n    logarithm from the other.  Therefore, it is necessary to pass the arguments\n    of the logarithmic terms in L_args.\n\n    To handle the case where we are given Df/f, not f, use is_deriv_k_in_field().\n\n    See also\n    ========\n    is_log_deriv_k_t_radical_in_field, is_log_deriv_k_t_radical\n\n    \"\"\"\n    (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE), fd * fa)\n    (dfa, dfd) = dfa.cancel(dfd, include=True)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        terms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Add(*[Mul(i, j) for (i, j) in ans])\n        argterms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        l = []\n        ld = []\n        for (i, j) in zip(argterms, u):\n            (i, d) = i.as_numer_denom()\n            (icoeff, iterms) = sqf_list(i)\n            l.append(Mul(*[Pow(icoeff, j)] + [Pow(b, e * j) for (b, e) in iterms]))\n            (dcoeff, dterms) = sqf_list(d)\n            ld.append(Mul(*[Pow(dcoeff, j)] + [Pow(b, e * j) for (b, e) in dterms]))\n        const = cancel(fa.as_expr() / fd.as_expr() / Mul(*l) * Mul(*ld))\n        return (ans, result, const)",
        "mutated": [
            "def is_deriv_k(fa, fd, DE):\n    if False:\n        i = 10\n    '\\n    Checks if Df/f is the derivative of an element of k(t).\\n\\n    Explanation\\n    ===========\\n\\n    a in k(t) is the derivative of an element of k(t) if there exists b in k(t)\\n    such that a = Db.  Either returns (ans, u), such that Df/f == Du, or None,\\n    which means that Df/f is not the derivative of an element of k(t).  ans is\\n    a list of tuples such that Add(*[i*j for i, j in ans]) == u.  This is useful\\n    for seeing exactly which elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df/f is the derivative of a element of K if and only if there are ri\\n    in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i      Df\\n            /     i     i     /     i   ---   =  --.\\n            ---               ---        t        f\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  E_args are the arguments of the\\n    hyperexponentials indexed by E_K (i.e., if i is in E_K, then T[i] ==\\n    exp(E_args[i])).  This is needed to compute the final answer u such that\\n    Df/f == Du.\\n\\n    log(f) will be the same as u up to a additive constant.  This is because\\n    they will both behave the same as monomials. For example, both log(x) and\\n    log(2*x) == log(x) + log(2) satisfy Dt == 1/x, because log(2) is constant.\\n    Therefore, the term const is returned.  const is such that\\n    log(const) + f == u.  This is calculated by dividing the arguments of one\\n    logarithm from the other.  Therefore, it is necessary to pass the arguments\\n    of the logarithmic terms in L_args.\\n\\n    To handle the case where we are given Df/f, not f, use is_deriv_k_in_field().\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical_in_field, is_log_deriv_k_t_radical\\n\\n    '\n    (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE), fd * fa)\n    (dfa, dfd) = dfa.cancel(dfd, include=True)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        terms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Add(*[Mul(i, j) for (i, j) in ans])\n        argterms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        l = []\n        ld = []\n        for (i, j) in zip(argterms, u):\n            (i, d) = i.as_numer_denom()\n            (icoeff, iterms) = sqf_list(i)\n            l.append(Mul(*[Pow(icoeff, j)] + [Pow(b, e * j) for (b, e) in iterms]))\n            (dcoeff, dterms) = sqf_list(d)\n            ld.append(Mul(*[Pow(dcoeff, j)] + [Pow(b, e * j) for (b, e) in dterms]))\n        const = cancel(fa.as_expr() / fd.as_expr() / Mul(*l) * Mul(*ld))\n        return (ans, result, const)",
            "def is_deriv_k(fa, fd, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Checks if Df/f is the derivative of an element of k(t).\\n\\n    Explanation\\n    ===========\\n\\n    a in k(t) is the derivative of an element of k(t) if there exists b in k(t)\\n    such that a = Db.  Either returns (ans, u), such that Df/f == Du, or None,\\n    which means that Df/f is not the derivative of an element of k(t).  ans is\\n    a list of tuples such that Add(*[i*j for i, j in ans]) == u.  This is useful\\n    for seeing exactly which elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df/f is the derivative of a element of K if and only if there are ri\\n    in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i      Df\\n            /     i     i     /     i   ---   =  --.\\n            ---               ---        t        f\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  E_args are the arguments of the\\n    hyperexponentials indexed by E_K (i.e., if i is in E_K, then T[i] ==\\n    exp(E_args[i])).  This is needed to compute the final answer u such that\\n    Df/f == Du.\\n\\n    log(f) will be the same as u up to a additive constant.  This is because\\n    they will both behave the same as monomials. For example, both log(x) and\\n    log(2*x) == log(x) + log(2) satisfy Dt == 1/x, because log(2) is constant.\\n    Therefore, the term const is returned.  const is such that\\n    log(const) + f == u.  This is calculated by dividing the arguments of one\\n    logarithm from the other.  Therefore, it is necessary to pass the arguments\\n    of the logarithmic terms in L_args.\\n\\n    To handle the case where we are given Df/f, not f, use is_deriv_k_in_field().\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical_in_field, is_log_deriv_k_t_radical\\n\\n    '\n    (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE), fd * fa)\n    (dfa, dfd) = dfa.cancel(dfd, include=True)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        terms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Add(*[Mul(i, j) for (i, j) in ans])\n        argterms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        l = []\n        ld = []\n        for (i, j) in zip(argterms, u):\n            (i, d) = i.as_numer_denom()\n            (icoeff, iterms) = sqf_list(i)\n            l.append(Mul(*[Pow(icoeff, j)] + [Pow(b, e * j) for (b, e) in iterms]))\n            (dcoeff, dterms) = sqf_list(d)\n            ld.append(Mul(*[Pow(dcoeff, j)] + [Pow(b, e * j) for (b, e) in dterms]))\n        const = cancel(fa.as_expr() / fd.as_expr() / Mul(*l) * Mul(*ld))\n        return (ans, result, const)",
            "def is_deriv_k(fa, fd, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Checks if Df/f is the derivative of an element of k(t).\\n\\n    Explanation\\n    ===========\\n\\n    a in k(t) is the derivative of an element of k(t) if there exists b in k(t)\\n    such that a = Db.  Either returns (ans, u), such that Df/f == Du, or None,\\n    which means that Df/f is not the derivative of an element of k(t).  ans is\\n    a list of tuples such that Add(*[i*j for i, j in ans]) == u.  This is useful\\n    for seeing exactly which elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df/f is the derivative of a element of K if and only if there are ri\\n    in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i      Df\\n            /     i     i     /     i   ---   =  --.\\n            ---               ---        t        f\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  E_args are the arguments of the\\n    hyperexponentials indexed by E_K (i.e., if i is in E_K, then T[i] ==\\n    exp(E_args[i])).  This is needed to compute the final answer u such that\\n    Df/f == Du.\\n\\n    log(f) will be the same as u up to a additive constant.  This is because\\n    they will both behave the same as monomials. For example, both log(x) and\\n    log(2*x) == log(x) + log(2) satisfy Dt == 1/x, because log(2) is constant.\\n    Therefore, the term const is returned.  const is such that\\n    log(const) + f == u.  This is calculated by dividing the arguments of one\\n    logarithm from the other.  Therefore, it is necessary to pass the arguments\\n    of the logarithmic terms in L_args.\\n\\n    To handle the case where we are given Df/f, not f, use is_deriv_k_in_field().\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical_in_field, is_log_deriv_k_t_radical\\n\\n    '\n    (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE), fd * fa)\n    (dfa, dfd) = dfa.cancel(dfd, include=True)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        terms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Add(*[Mul(i, j) for (i, j) in ans])\n        argterms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        l = []\n        ld = []\n        for (i, j) in zip(argterms, u):\n            (i, d) = i.as_numer_denom()\n            (icoeff, iterms) = sqf_list(i)\n            l.append(Mul(*[Pow(icoeff, j)] + [Pow(b, e * j) for (b, e) in iterms]))\n            (dcoeff, dterms) = sqf_list(d)\n            ld.append(Mul(*[Pow(dcoeff, j)] + [Pow(b, e * j) for (b, e) in dterms]))\n        const = cancel(fa.as_expr() / fd.as_expr() / Mul(*l) * Mul(*ld))\n        return (ans, result, const)",
            "def is_deriv_k(fa, fd, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Checks if Df/f is the derivative of an element of k(t).\\n\\n    Explanation\\n    ===========\\n\\n    a in k(t) is the derivative of an element of k(t) if there exists b in k(t)\\n    such that a = Db.  Either returns (ans, u), such that Df/f == Du, or None,\\n    which means that Df/f is not the derivative of an element of k(t).  ans is\\n    a list of tuples such that Add(*[i*j for i, j in ans]) == u.  This is useful\\n    for seeing exactly which elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df/f is the derivative of a element of K if and only if there are ri\\n    in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i      Df\\n            /     i     i     /     i   ---   =  --.\\n            ---               ---        t        f\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  E_args are the arguments of the\\n    hyperexponentials indexed by E_K (i.e., if i is in E_K, then T[i] ==\\n    exp(E_args[i])).  This is needed to compute the final answer u such that\\n    Df/f == Du.\\n\\n    log(f) will be the same as u up to a additive constant.  This is because\\n    they will both behave the same as monomials. For example, both log(x) and\\n    log(2*x) == log(x) + log(2) satisfy Dt == 1/x, because log(2) is constant.\\n    Therefore, the term const is returned.  const is such that\\n    log(const) + f == u.  This is calculated by dividing the arguments of one\\n    logarithm from the other.  Therefore, it is necessary to pass the arguments\\n    of the logarithmic terms in L_args.\\n\\n    To handle the case where we are given Df/f, not f, use is_deriv_k_in_field().\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical_in_field, is_log_deriv_k_t_radical\\n\\n    '\n    (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE), fd * fa)\n    (dfa, dfd) = dfa.cancel(dfd, include=True)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        terms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Add(*[Mul(i, j) for (i, j) in ans])\n        argterms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        l = []\n        ld = []\n        for (i, j) in zip(argterms, u):\n            (i, d) = i.as_numer_denom()\n            (icoeff, iterms) = sqf_list(i)\n            l.append(Mul(*[Pow(icoeff, j)] + [Pow(b, e * j) for (b, e) in iterms]))\n            (dcoeff, dterms) = sqf_list(d)\n            ld.append(Mul(*[Pow(dcoeff, j)] + [Pow(b, e * j) for (b, e) in dterms]))\n        const = cancel(fa.as_expr() / fd.as_expr() / Mul(*l) * Mul(*ld))\n        return (ans, result, const)",
            "def is_deriv_k(fa, fd, DE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Checks if Df/f is the derivative of an element of k(t).\\n\\n    Explanation\\n    ===========\\n\\n    a in k(t) is the derivative of an element of k(t) if there exists b in k(t)\\n    such that a = Db.  Either returns (ans, u), such that Df/f == Du, or None,\\n    which means that Df/f is not the derivative of an element of k(t).  ans is\\n    a list of tuples such that Add(*[i*j for i, j in ans]) == u.  This is useful\\n    for seeing exactly which elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df/f is the derivative of a element of K if and only if there are ri\\n    in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i      Df\\n            /     i     i     /     i   ---   =  --.\\n            ---               ---        t        f\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  E_args are the arguments of the\\n    hyperexponentials indexed by E_K (i.e., if i is in E_K, then T[i] ==\\n    exp(E_args[i])).  This is needed to compute the final answer u such that\\n    Df/f == Du.\\n\\n    log(f) will be the same as u up to a additive constant.  This is because\\n    they will both behave the same as monomials. For example, both log(x) and\\n    log(2*x) == log(x) + log(2) satisfy Dt == 1/x, because log(2) is constant.\\n    Therefore, the term const is returned.  const is such that\\n    log(const) + f == u.  This is calculated by dividing the arguments of one\\n    logarithm from the other.  Therefore, it is necessary to pass the arguments\\n    of the logarithmic terms in L_args.\\n\\n    To handle the case where we are given Df/f, not f, use is_deriv_k_in_field().\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical_in_field, is_log_deriv_k_t_radical\\n\\n    '\n    (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE), fd * fa)\n    (dfa, dfd) = dfa.cancel(dfd, include=True)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        terms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Add(*[Mul(i, j) for (i, j) in ans])\n        argterms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        l = []\n        ld = []\n        for (i, j) in zip(argterms, u):\n            (i, d) = i.as_numer_denom()\n            (icoeff, iterms) = sqf_list(i)\n            l.append(Mul(*[Pow(icoeff, j)] + [Pow(b, e * j) for (b, e) in iterms]))\n            (dcoeff, dterms) = sqf_list(d)\n            ld.append(Mul(*[Pow(dcoeff, j)] + [Pow(b, e * j) for (b, e) in dterms]))\n        const = cancel(fa.as_expr() / fd.as_expr() / Mul(*l) * Mul(*ld))\n        return (ans, result, const)"
        ]
    },
    {
        "func_name": "is_log_deriv_k_t_radical",
        "original": "def is_log_deriv_k_t_radical(fa, fd, DE, Df=True):\n    \"\"\"\n    Checks if Df is the logarithmic derivative of a k(t)-radical.\n\n    Explanation\n    ===========\n\n    b in k(t) can be written as the logarithmic derivative of a k(t) radical if\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*b == Du/u.\n    Either returns (ans, u, n, const) or None, which means that Df cannot be\n    written as the logarithmic derivative of a k(t)-radical.  ans is a list of\n    tuples such that Mul(*[i**j for i, j in ans]) == u.  This is useful for\n    seeing exactly what elements of k(t) produce u.\n\n    This function uses the structure theorem approach, which says that for any\n    f in K, Df is the logarithmic derivative of a K-radical if and only if there\n    are ri in QQ such that::\n\n            ---               ---       Dt\n            \\\\    r  * Dt   +  \\\\    r  *   i\n            /     i     i     /     i   ---   =  Df.\n            ---               ---        t\n         i in L            i in E         i\n               K/C(x)            K/C(x)\n\n\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\n    and L_K/C(x) are disjoint.\n\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\n    recursively using this same function.  Therefore, it is required to pass\n    them as indices to D (or T).  L_args are the arguments of the logarithms\n    indexed by L_K (i.e., if i is in L_K, then T[i] == log(L_args[i])).  This is\n    needed to compute the final answer u such that n*f == Du/u.\n\n    exp(f) will be the same as u up to a multiplicative constant.  This is\n    because they will both behave the same as monomials.  For example, both\n    exp(x) and exp(x + 1) == E*exp(x) satisfy Dt == t. Therefore, the term const\n    is returned.  const is such that exp(const)*f == u.  This is calculated by\n    subtracting the arguments of one exponential from the other.  Therefore, it\n    is necessary to pass the arguments of the exponential terms in E_args.\n\n    To handle the case where we are given Df, not f, use\n    is_log_deriv_k_t_radical_in_field().\n\n    See also\n    ========\n\n    is_log_deriv_k_t_radical_in_field, is_deriv_k\n\n    \"\"\"\n    if Df:\n        (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE)).cancel(fd ** 2, include=True)\n    else:\n        (dfa, dfd) = (fa, fd)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in u])\n        u *= n\n        terms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Mul(*[Pow(i, j) for (i, j) in ans])\n        argterms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        const = cancel(fa.as_expr() / fd.as_expr() - Add(*[Mul(i, j / n) for (i, j) in zip(argterms, u)]))\n        return (ans, result, n, const)",
        "mutated": [
            "def is_log_deriv_k_t_radical(fa, fd, DE, Df=True):\n    if False:\n        i = 10\n    '\\n    Checks if Df is the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    b in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*b == Du/u.\\n    Either returns (ans, u, n, const) or None, which means that Df cannot be\\n    written as the logarithmic derivative of a k(t)-radical.  ans is a list of\\n    tuples such that Mul(*[i**j for i, j in ans]) == u.  This is useful for\\n    seeing exactly what elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df is the logarithmic derivative of a K-radical if and only if there\\n    are ri in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i\\n            /     i     i     /     i   ---   =  Df.\\n            ---               ---        t\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  L_args are the arguments of the logarithms\\n    indexed by L_K (i.e., if i is in L_K, then T[i] == log(L_args[i])).  This is\\n    needed to compute the final answer u such that n*f == Du/u.\\n\\n    exp(f) will be the same as u up to a multiplicative constant.  This is\\n    because they will both behave the same as monomials.  For example, both\\n    exp(x) and exp(x + 1) == E*exp(x) satisfy Dt == t. Therefore, the term const\\n    is returned.  const is such that exp(const)*f == u.  This is calculated by\\n    subtracting the arguments of one exponential from the other.  Therefore, it\\n    is necessary to pass the arguments of the exponential terms in E_args.\\n\\n    To handle the case where we are given Df, not f, use\\n    is_log_deriv_k_t_radical_in_field().\\n\\n    See also\\n    ========\\n\\n    is_log_deriv_k_t_radical_in_field, is_deriv_k\\n\\n    '\n    if Df:\n        (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE)).cancel(fd ** 2, include=True)\n    else:\n        (dfa, dfd) = (fa, fd)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in u])\n        u *= n\n        terms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Mul(*[Pow(i, j) for (i, j) in ans])\n        argterms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        const = cancel(fa.as_expr() / fd.as_expr() - Add(*[Mul(i, j / n) for (i, j) in zip(argterms, u)]))\n        return (ans, result, n, const)",
            "def is_log_deriv_k_t_radical(fa, fd, DE, Df=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Checks if Df is the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    b in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*b == Du/u.\\n    Either returns (ans, u, n, const) or None, which means that Df cannot be\\n    written as the logarithmic derivative of a k(t)-radical.  ans is a list of\\n    tuples such that Mul(*[i**j for i, j in ans]) == u.  This is useful for\\n    seeing exactly what elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df is the logarithmic derivative of a K-radical if and only if there\\n    are ri in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i\\n            /     i     i     /     i   ---   =  Df.\\n            ---               ---        t\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  L_args are the arguments of the logarithms\\n    indexed by L_K (i.e., if i is in L_K, then T[i] == log(L_args[i])).  This is\\n    needed to compute the final answer u such that n*f == Du/u.\\n\\n    exp(f) will be the same as u up to a multiplicative constant.  This is\\n    because they will both behave the same as monomials.  For example, both\\n    exp(x) and exp(x + 1) == E*exp(x) satisfy Dt == t. Therefore, the term const\\n    is returned.  const is such that exp(const)*f == u.  This is calculated by\\n    subtracting the arguments of one exponential from the other.  Therefore, it\\n    is necessary to pass the arguments of the exponential terms in E_args.\\n\\n    To handle the case where we are given Df, not f, use\\n    is_log_deriv_k_t_radical_in_field().\\n\\n    See also\\n    ========\\n\\n    is_log_deriv_k_t_radical_in_field, is_deriv_k\\n\\n    '\n    if Df:\n        (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE)).cancel(fd ** 2, include=True)\n    else:\n        (dfa, dfd) = (fa, fd)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in u])\n        u *= n\n        terms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Mul(*[Pow(i, j) for (i, j) in ans])\n        argterms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        const = cancel(fa.as_expr() / fd.as_expr() - Add(*[Mul(i, j / n) for (i, j) in zip(argterms, u)]))\n        return (ans, result, n, const)",
            "def is_log_deriv_k_t_radical(fa, fd, DE, Df=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Checks if Df is the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    b in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*b == Du/u.\\n    Either returns (ans, u, n, const) or None, which means that Df cannot be\\n    written as the logarithmic derivative of a k(t)-radical.  ans is a list of\\n    tuples such that Mul(*[i**j for i, j in ans]) == u.  This is useful for\\n    seeing exactly what elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df is the logarithmic derivative of a K-radical if and only if there\\n    are ri in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i\\n            /     i     i     /     i   ---   =  Df.\\n            ---               ---        t\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  L_args are the arguments of the logarithms\\n    indexed by L_K (i.e., if i is in L_K, then T[i] == log(L_args[i])).  This is\\n    needed to compute the final answer u such that n*f == Du/u.\\n\\n    exp(f) will be the same as u up to a multiplicative constant.  This is\\n    because they will both behave the same as monomials.  For example, both\\n    exp(x) and exp(x + 1) == E*exp(x) satisfy Dt == t. Therefore, the term const\\n    is returned.  const is such that exp(const)*f == u.  This is calculated by\\n    subtracting the arguments of one exponential from the other.  Therefore, it\\n    is necessary to pass the arguments of the exponential terms in E_args.\\n\\n    To handle the case where we are given Df, not f, use\\n    is_log_deriv_k_t_radical_in_field().\\n\\n    See also\\n    ========\\n\\n    is_log_deriv_k_t_radical_in_field, is_deriv_k\\n\\n    '\n    if Df:\n        (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE)).cancel(fd ** 2, include=True)\n    else:\n        (dfa, dfd) = (fa, fd)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in u])\n        u *= n\n        terms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Mul(*[Pow(i, j) for (i, j) in ans])\n        argterms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        const = cancel(fa.as_expr() / fd.as_expr() - Add(*[Mul(i, j / n) for (i, j) in zip(argterms, u)]))\n        return (ans, result, n, const)",
            "def is_log_deriv_k_t_radical(fa, fd, DE, Df=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Checks if Df is the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    b in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*b == Du/u.\\n    Either returns (ans, u, n, const) or None, which means that Df cannot be\\n    written as the logarithmic derivative of a k(t)-radical.  ans is a list of\\n    tuples such that Mul(*[i**j for i, j in ans]) == u.  This is useful for\\n    seeing exactly what elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df is the logarithmic derivative of a K-radical if and only if there\\n    are ri in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i\\n            /     i     i     /     i   ---   =  Df.\\n            ---               ---        t\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  L_args are the arguments of the logarithms\\n    indexed by L_K (i.e., if i is in L_K, then T[i] == log(L_args[i])).  This is\\n    needed to compute the final answer u such that n*f == Du/u.\\n\\n    exp(f) will be the same as u up to a multiplicative constant.  This is\\n    because they will both behave the same as monomials.  For example, both\\n    exp(x) and exp(x + 1) == E*exp(x) satisfy Dt == t. Therefore, the term const\\n    is returned.  const is such that exp(const)*f == u.  This is calculated by\\n    subtracting the arguments of one exponential from the other.  Therefore, it\\n    is necessary to pass the arguments of the exponential terms in E_args.\\n\\n    To handle the case where we are given Df, not f, use\\n    is_log_deriv_k_t_radical_in_field().\\n\\n    See also\\n    ========\\n\\n    is_log_deriv_k_t_radical_in_field, is_deriv_k\\n\\n    '\n    if Df:\n        (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE)).cancel(fd ** 2, include=True)\n    else:\n        (dfa, dfd) = (fa, fd)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in u])\n        u *= n\n        terms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Mul(*[Pow(i, j) for (i, j) in ans])\n        argterms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        const = cancel(fa.as_expr() / fd.as_expr() - Add(*[Mul(i, j / n) for (i, j) in zip(argterms, u)]))\n        return (ans, result, n, const)",
            "def is_log_deriv_k_t_radical(fa, fd, DE, Df=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Checks if Df is the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    b in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*b == Du/u.\\n    Either returns (ans, u, n, const) or None, which means that Df cannot be\\n    written as the logarithmic derivative of a k(t)-radical.  ans is a list of\\n    tuples such that Mul(*[i**j for i, j in ans]) == u.  This is useful for\\n    seeing exactly what elements of k(t) produce u.\\n\\n    This function uses the structure theorem approach, which says that for any\\n    f in K, Df is the logarithmic derivative of a K-radical if and only if there\\n    are ri in QQ such that::\\n\\n            ---               ---       Dt\\n            \\\\    r  * Dt   +  \\\\    r  *   i\\n            /     i     i     /     i   ---   =  Df.\\n            ---               ---        t\\n         i in L            i in E         i\\n               K/C(x)            K/C(x)\\n\\n\\n    Where C = Const(K), L_K/C(x) = { i in {1, ..., n} such that t_i is\\n    transcendental over C(x)(t_1, ..., t_i-1) and Dt_i = Da_i/a_i, for some a_i\\n    in C(x)(t_1, ..., t_i-1)* } (i.e., the set of all indices of logarithmic\\n    monomials of K over C(x)), and E_K/C(x) = { i in {1, ..., n} such that t_i\\n    is transcendental over C(x)(t_1, ..., t_i-1) and Dt_i/t_i = Da_i, for some\\n    a_i in C(x)(t_1, ..., t_i-1) } (i.e., the set of all indices of\\n    hyperexponential monomials of K over C(x)).  If K is an elementary extension\\n    over C(x), then the cardinality of L_K/C(x) U E_K/C(x) is exactly the\\n    transcendence degree of K over C(x).  Furthermore, because Const_D(K) ==\\n    Const_D(C(x)) == C, deg(Dt_i) == 1 when t_i is in E_K/C(x) and\\n    deg(Dt_i) == 0 when t_i is in L_K/C(x), implying in particular that E_K/C(x)\\n    and L_K/C(x) are disjoint.\\n\\n    The sets L_K/C(x) and E_K/C(x) must, by their nature, be computed\\n    recursively using this same function.  Therefore, it is required to pass\\n    them as indices to D (or T).  L_args are the arguments of the logarithms\\n    indexed by L_K (i.e., if i is in L_K, then T[i] == log(L_args[i])).  This is\\n    needed to compute the final answer u such that n*f == Du/u.\\n\\n    exp(f) will be the same as u up to a multiplicative constant.  This is\\n    because they will both behave the same as monomials.  For example, both\\n    exp(x) and exp(x + 1) == E*exp(x) satisfy Dt == t. Therefore, the term const\\n    is returned.  const is such that exp(const)*f == u.  This is calculated by\\n    subtracting the arguments of one exponential from the other.  Therefore, it\\n    is necessary to pass the arguments of the exponential terms in E_args.\\n\\n    To handle the case where we are given Df, not f, use\\n    is_log_deriv_k_t_radical_in_field().\\n\\n    See also\\n    ========\\n\\n    is_log_deriv_k_t_radical_in_field, is_deriv_k\\n\\n    '\n    if Df:\n        (dfa, dfd) = (fd * derivation(fa, DE) - fa * derivation(fd, DE)).cancel(fd ** 2, include=True)\n    else:\n        (dfa, dfd) = (fa, fd)\n    if len(DE.exts) != len(DE.D):\n        if [i for i in DE.cases if i == 'tan'] or {i for i in DE.cases if i == 'primitive'} - set(DE.indices('log')):\n            raise NotImplementedError('Real version of the structure theorems with hypertangent support is not yet implemented.')\n        raise NotImplementedError('Nonelementary extensions not supported in the structure theorems.')\n    E_part = [DE.D[i].quo(Poly(DE.T[i], DE.T[i])).as_expr() for i in DE.indices('exp')]\n    L_part = [DE.D[i].as_expr() for i in DE.indices('log')]\n    dum = Dummy()\n    lhs = Matrix([E_part + L_part], dum)\n    rhs = Matrix([dfa.as_expr() / dfd.as_expr()], dum)\n    (A, u) = constant_system(lhs, rhs, DE)\n    u = u.to_Matrix()\n    if not A or not all((derivation(i, DE, basic=True).is_zero for i in u)):\n        return None\n    elif not all((i.is_Rational for i in u)):\n        raise NotImplementedError('Cannot work with non-rational coefficients in this case.')\n    else:\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in u])\n        u *= n\n        terms = [DE.T[i] for i in DE.indices('exp')] + [DE.extargs[i] for i in DE.indices('log')]\n        ans = list(zip(terms, u))\n        result = Mul(*[Pow(i, j) for (i, j) in ans])\n        argterms = [DE.extargs[i] for i in DE.indices('exp')] + [DE.T[i] for i in DE.indices('log')]\n        const = cancel(fa.as_expr() / fd.as_expr() - Add(*[Mul(i, j / n) for (i, j) in zip(argterms, u)]))\n        return (ans, result, n, const)"
        ]
    },
    {
        "func_name": "is_log_deriv_k_t_radical_in_field",
        "original": "def is_log_deriv_k_t_radical_in_field(fa, fd, DE, case='auto', z=None):\n    \"\"\"\n    Checks if f can be written as the logarithmic derivative of a k(t)-radical.\n\n    Explanation\n    ===========\n\n    It differs from is_log_deriv_k_t_radical(fa, fd, DE, Df=False)\n    for any given fa, fd, DE in that it finds the solution in the\n    given field not in some (possibly unspecified extension) and\n    \"in_field\" with the function name is used to indicate that.\n\n    f in k(t) can be written as the logarithmic derivative of a k(t) radical if\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*f == Du/u.\n    Either returns (n, u) or None, which means that f cannot be written as the\n    logarithmic derivative of a k(t)-radical.\n\n    case is one of {'primitive', 'exp', 'tan', 'auto'} for the primitive,\n    hyperexponential, and hypertangent cases, respectively.  If case is 'auto',\n    it will attempt to determine the type of the derivation automatically.\n\n    See also\n    ========\n    is_log_deriv_k_t_radical, is_deriv_k\n\n    \"\"\"\n    (fa, fd) = fa.cancel(fd, include=True)\n    (n, s) = splitfactor(fd, DE)\n    if not s.is_one:\n        pass\n    z = z or Dummy('z')\n    (H, b) = residue_reduce(fa, fd, DE, z=z)\n    if not b:\n        return None\n    roots = [(i, i.real_roots()) for (i, _) in H]\n    if not all((len(j) == i.degree() and all((k.is_Rational for k in j)) for (i, j) in roots)):\n        return None\n    (respolys, residues) = list(zip(*roots)) or [[], []]\n    residueterms = [(H[j][1].subs(z, i), i) for j in range(len(H)) for i in residues[j]]\n    p = cancel(fa.as_expr() / fd.as_expr() - residue_reduce_derivation(H, DE, z))\n    p = p.as_poly(DE.t)\n    if p is None:\n        return None\n    if p.degree(DE.t) >= max(1, DE.d.degree(DE.t)):\n        return None\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        (wa, wd) = derivation(DE.t, DE).cancel(Poly(DE.t, DE.t), include=True)\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t, cancel=True)\n            (wa, wd) = frac_in((wa, wd), DE.t)\n            A = parametric_log_deriv(pa, pd, wa, wd, DE)\n        if A is None:\n            return None\n        (n, e, u) = A\n        u *= DE.t ** e\n    elif case == 'primitive':\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t)\n            A = is_log_deriv_k_t_radical_in_field(pa, pd, DE, case='auto')\n        if A is None:\n            return None\n        (n, u) = A\n    elif case == 'base':\n        if not fd.is_sqf or fa.degree() >= fd.degree():\n            return None\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for (_, i) in residueterms], 1)\n        u = Mul(*[Pow(i, j * n) for (i, j) in residueterms])\n        return (n, u)\n    elif case == 'tan':\n        raise NotImplementedError('The hypertangent case is not yet implemented for is_log_deriv_k_t_radical_in_field()')\n    elif case in ('other_linear', 'other_nonlinear'):\n        raise ValueError('The %s case is not supported in this function.' % case)\n    else:\n        raise ValueError(\"case must be one of {'primitive', 'exp', 'tan', 'base', 'auto'}, not %s\" % case)\n    common_denom = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in [j for (_, j) in residueterms]] + [n], 1)\n    residueterms = [(i, j * common_denom) for (i, j) in residueterms]\n    m = common_denom // n\n    if common_denom != n * m:\n        raise ValueError('Inexact division')\n    u = cancel(u ** m * Mul(*[Pow(i, j) for (i, j) in residueterms]))\n    return (common_denom, u)",
        "mutated": [
            "def is_log_deriv_k_t_radical_in_field(fa, fd, DE, case='auto', z=None):\n    if False:\n        i = 10\n    '\\n    Checks if f can be written as the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    It differs from is_log_deriv_k_t_radical(fa, fd, DE, Df=False)\\n    for any given fa, fd, DE in that it finds the solution in the\\n    given field not in some (possibly unspecified extension) and\\n    \"in_field\" with the function name is used to indicate that.\\n\\n    f in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*f == Du/u.\\n    Either returns (n, u) or None, which means that f cannot be written as the\\n    logarithmic derivative of a k(t)-radical.\\n\\n    case is one of {\\'primitive\\', \\'exp\\', \\'tan\\', \\'auto\\'} for the primitive,\\n    hyperexponential, and hypertangent cases, respectively.  If case is \\'auto\\',\\n    it will attempt to determine the type of the derivation automatically.\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical, is_deriv_k\\n\\n    '\n    (fa, fd) = fa.cancel(fd, include=True)\n    (n, s) = splitfactor(fd, DE)\n    if not s.is_one:\n        pass\n    z = z or Dummy('z')\n    (H, b) = residue_reduce(fa, fd, DE, z=z)\n    if not b:\n        return None\n    roots = [(i, i.real_roots()) for (i, _) in H]\n    if not all((len(j) == i.degree() and all((k.is_Rational for k in j)) for (i, j) in roots)):\n        return None\n    (respolys, residues) = list(zip(*roots)) or [[], []]\n    residueterms = [(H[j][1].subs(z, i), i) for j in range(len(H)) for i in residues[j]]\n    p = cancel(fa.as_expr() / fd.as_expr() - residue_reduce_derivation(H, DE, z))\n    p = p.as_poly(DE.t)\n    if p is None:\n        return None\n    if p.degree(DE.t) >= max(1, DE.d.degree(DE.t)):\n        return None\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        (wa, wd) = derivation(DE.t, DE).cancel(Poly(DE.t, DE.t), include=True)\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t, cancel=True)\n            (wa, wd) = frac_in((wa, wd), DE.t)\n            A = parametric_log_deriv(pa, pd, wa, wd, DE)\n        if A is None:\n            return None\n        (n, e, u) = A\n        u *= DE.t ** e\n    elif case == 'primitive':\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t)\n            A = is_log_deriv_k_t_radical_in_field(pa, pd, DE, case='auto')\n        if A is None:\n            return None\n        (n, u) = A\n    elif case == 'base':\n        if not fd.is_sqf or fa.degree() >= fd.degree():\n            return None\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for (_, i) in residueterms], 1)\n        u = Mul(*[Pow(i, j * n) for (i, j) in residueterms])\n        return (n, u)\n    elif case == 'tan':\n        raise NotImplementedError('The hypertangent case is not yet implemented for is_log_deriv_k_t_radical_in_field()')\n    elif case in ('other_linear', 'other_nonlinear'):\n        raise ValueError('The %s case is not supported in this function.' % case)\n    else:\n        raise ValueError(\"case must be one of {'primitive', 'exp', 'tan', 'base', 'auto'}, not %s\" % case)\n    common_denom = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in [j for (_, j) in residueterms]] + [n], 1)\n    residueterms = [(i, j * common_denom) for (i, j) in residueterms]\n    m = common_denom // n\n    if common_denom != n * m:\n        raise ValueError('Inexact division')\n    u = cancel(u ** m * Mul(*[Pow(i, j) for (i, j) in residueterms]))\n    return (common_denom, u)",
            "def is_log_deriv_k_t_radical_in_field(fa, fd, DE, case='auto', z=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Checks if f can be written as the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    It differs from is_log_deriv_k_t_radical(fa, fd, DE, Df=False)\\n    for any given fa, fd, DE in that it finds the solution in the\\n    given field not in some (possibly unspecified extension) and\\n    \"in_field\" with the function name is used to indicate that.\\n\\n    f in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*f == Du/u.\\n    Either returns (n, u) or None, which means that f cannot be written as the\\n    logarithmic derivative of a k(t)-radical.\\n\\n    case is one of {\\'primitive\\', \\'exp\\', \\'tan\\', \\'auto\\'} for the primitive,\\n    hyperexponential, and hypertangent cases, respectively.  If case is \\'auto\\',\\n    it will attempt to determine the type of the derivation automatically.\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical, is_deriv_k\\n\\n    '\n    (fa, fd) = fa.cancel(fd, include=True)\n    (n, s) = splitfactor(fd, DE)\n    if not s.is_one:\n        pass\n    z = z or Dummy('z')\n    (H, b) = residue_reduce(fa, fd, DE, z=z)\n    if not b:\n        return None\n    roots = [(i, i.real_roots()) for (i, _) in H]\n    if not all((len(j) == i.degree() and all((k.is_Rational for k in j)) for (i, j) in roots)):\n        return None\n    (respolys, residues) = list(zip(*roots)) or [[], []]\n    residueterms = [(H[j][1].subs(z, i), i) for j in range(len(H)) for i in residues[j]]\n    p = cancel(fa.as_expr() / fd.as_expr() - residue_reduce_derivation(H, DE, z))\n    p = p.as_poly(DE.t)\n    if p is None:\n        return None\n    if p.degree(DE.t) >= max(1, DE.d.degree(DE.t)):\n        return None\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        (wa, wd) = derivation(DE.t, DE).cancel(Poly(DE.t, DE.t), include=True)\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t, cancel=True)\n            (wa, wd) = frac_in((wa, wd), DE.t)\n            A = parametric_log_deriv(pa, pd, wa, wd, DE)\n        if A is None:\n            return None\n        (n, e, u) = A\n        u *= DE.t ** e\n    elif case == 'primitive':\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t)\n            A = is_log_deriv_k_t_radical_in_field(pa, pd, DE, case='auto')\n        if A is None:\n            return None\n        (n, u) = A\n    elif case == 'base':\n        if not fd.is_sqf or fa.degree() >= fd.degree():\n            return None\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for (_, i) in residueterms], 1)\n        u = Mul(*[Pow(i, j * n) for (i, j) in residueterms])\n        return (n, u)\n    elif case == 'tan':\n        raise NotImplementedError('The hypertangent case is not yet implemented for is_log_deriv_k_t_radical_in_field()')\n    elif case in ('other_linear', 'other_nonlinear'):\n        raise ValueError('The %s case is not supported in this function.' % case)\n    else:\n        raise ValueError(\"case must be one of {'primitive', 'exp', 'tan', 'base', 'auto'}, not %s\" % case)\n    common_denom = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in [j for (_, j) in residueterms]] + [n], 1)\n    residueterms = [(i, j * common_denom) for (i, j) in residueterms]\n    m = common_denom // n\n    if common_denom != n * m:\n        raise ValueError('Inexact division')\n    u = cancel(u ** m * Mul(*[Pow(i, j) for (i, j) in residueterms]))\n    return (common_denom, u)",
            "def is_log_deriv_k_t_radical_in_field(fa, fd, DE, case='auto', z=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Checks if f can be written as the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    It differs from is_log_deriv_k_t_radical(fa, fd, DE, Df=False)\\n    for any given fa, fd, DE in that it finds the solution in the\\n    given field not in some (possibly unspecified extension) and\\n    \"in_field\" with the function name is used to indicate that.\\n\\n    f in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*f == Du/u.\\n    Either returns (n, u) or None, which means that f cannot be written as the\\n    logarithmic derivative of a k(t)-radical.\\n\\n    case is one of {\\'primitive\\', \\'exp\\', \\'tan\\', \\'auto\\'} for the primitive,\\n    hyperexponential, and hypertangent cases, respectively.  If case is \\'auto\\',\\n    it will attempt to determine the type of the derivation automatically.\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical, is_deriv_k\\n\\n    '\n    (fa, fd) = fa.cancel(fd, include=True)\n    (n, s) = splitfactor(fd, DE)\n    if not s.is_one:\n        pass\n    z = z or Dummy('z')\n    (H, b) = residue_reduce(fa, fd, DE, z=z)\n    if not b:\n        return None\n    roots = [(i, i.real_roots()) for (i, _) in H]\n    if not all((len(j) == i.degree() and all((k.is_Rational for k in j)) for (i, j) in roots)):\n        return None\n    (respolys, residues) = list(zip(*roots)) or [[], []]\n    residueterms = [(H[j][1].subs(z, i), i) for j in range(len(H)) for i in residues[j]]\n    p = cancel(fa.as_expr() / fd.as_expr() - residue_reduce_derivation(H, DE, z))\n    p = p.as_poly(DE.t)\n    if p is None:\n        return None\n    if p.degree(DE.t) >= max(1, DE.d.degree(DE.t)):\n        return None\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        (wa, wd) = derivation(DE.t, DE).cancel(Poly(DE.t, DE.t), include=True)\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t, cancel=True)\n            (wa, wd) = frac_in((wa, wd), DE.t)\n            A = parametric_log_deriv(pa, pd, wa, wd, DE)\n        if A is None:\n            return None\n        (n, e, u) = A\n        u *= DE.t ** e\n    elif case == 'primitive':\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t)\n            A = is_log_deriv_k_t_radical_in_field(pa, pd, DE, case='auto')\n        if A is None:\n            return None\n        (n, u) = A\n    elif case == 'base':\n        if not fd.is_sqf or fa.degree() >= fd.degree():\n            return None\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for (_, i) in residueterms], 1)\n        u = Mul(*[Pow(i, j * n) for (i, j) in residueterms])\n        return (n, u)\n    elif case == 'tan':\n        raise NotImplementedError('The hypertangent case is not yet implemented for is_log_deriv_k_t_radical_in_field()')\n    elif case in ('other_linear', 'other_nonlinear'):\n        raise ValueError('The %s case is not supported in this function.' % case)\n    else:\n        raise ValueError(\"case must be one of {'primitive', 'exp', 'tan', 'base', 'auto'}, not %s\" % case)\n    common_denom = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in [j for (_, j) in residueterms]] + [n], 1)\n    residueterms = [(i, j * common_denom) for (i, j) in residueterms]\n    m = common_denom // n\n    if common_denom != n * m:\n        raise ValueError('Inexact division')\n    u = cancel(u ** m * Mul(*[Pow(i, j) for (i, j) in residueterms]))\n    return (common_denom, u)",
            "def is_log_deriv_k_t_radical_in_field(fa, fd, DE, case='auto', z=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Checks if f can be written as the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    It differs from is_log_deriv_k_t_radical(fa, fd, DE, Df=False)\\n    for any given fa, fd, DE in that it finds the solution in the\\n    given field not in some (possibly unspecified extension) and\\n    \"in_field\" with the function name is used to indicate that.\\n\\n    f in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*f == Du/u.\\n    Either returns (n, u) or None, which means that f cannot be written as the\\n    logarithmic derivative of a k(t)-radical.\\n\\n    case is one of {\\'primitive\\', \\'exp\\', \\'tan\\', \\'auto\\'} for the primitive,\\n    hyperexponential, and hypertangent cases, respectively.  If case is \\'auto\\',\\n    it will attempt to determine the type of the derivation automatically.\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical, is_deriv_k\\n\\n    '\n    (fa, fd) = fa.cancel(fd, include=True)\n    (n, s) = splitfactor(fd, DE)\n    if not s.is_one:\n        pass\n    z = z or Dummy('z')\n    (H, b) = residue_reduce(fa, fd, DE, z=z)\n    if not b:\n        return None\n    roots = [(i, i.real_roots()) for (i, _) in H]\n    if not all((len(j) == i.degree() and all((k.is_Rational for k in j)) for (i, j) in roots)):\n        return None\n    (respolys, residues) = list(zip(*roots)) or [[], []]\n    residueterms = [(H[j][1].subs(z, i), i) for j in range(len(H)) for i in residues[j]]\n    p = cancel(fa.as_expr() / fd.as_expr() - residue_reduce_derivation(H, DE, z))\n    p = p.as_poly(DE.t)\n    if p is None:\n        return None\n    if p.degree(DE.t) >= max(1, DE.d.degree(DE.t)):\n        return None\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        (wa, wd) = derivation(DE.t, DE).cancel(Poly(DE.t, DE.t), include=True)\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t, cancel=True)\n            (wa, wd) = frac_in((wa, wd), DE.t)\n            A = parametric_log_deriv(pa, pd, wa, wd, DE)\n        if A is None:\n            return None\n        (n, e, u) = A\n        u *= DE.t ** e\n    elif case == 'primitive':\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t)\n            A = is_log_deriv_k_t_radical_in_field(pa, pd, DE, case='auto')\n        if A is None:\n            return None\n        (n, u) = A\n    elif case == 'base':\n        if not fd.is_sqf or fa.degree() >= fd.degree():\n            return None\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for (_, i) in residueterms], 1)\n        u = Mul(*[Pow(i, j * n) for (i, j) in residueterms])\n        return (n, u)\n    elif case == 'tan':\n        raise NotImplementedError('The hypertangent case is not yet implemented for is_log_deriv_k_t_radical_in_field()')\n    elif case in ('other_linear', 'other_nonlinear'):\n        raise ValueError('The %s case is not supported in this function.' % case)\n    else:\n        raise ValueError(\"case must be one of {'primitive', 'exp', 'tan', 'base', 'auto'}, not %s\" % case)\n    common_denom = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in [j for (_, j) in residueterms]] + [n], 1)\n    residueterms = [(i, j * common_denom) for (i, j) in residueterms]\n    m = common_denom // n\n    if common_denom != n * m:\n        raise ValueError('Inexact division')\n    u = cancel(u ** m * Mul(*[Pow(i, j) for (i, j) in residueterms]))\n    return (common_denom, u)",
            "def is_log_deriv_k_t_radical_in_field(fa, fd, DE, case='auto', z=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Checks if f can be written as the logarithmic derivative of a k(t)-radical.\\n\\n    Explanation\\n    ===========\\n\\n    It differs from is_log_deriv_k_t_radical(fa, fd, DE, Df=False)\\n    for any given fa, fd, DE in that it finds the solution in the\\n    given field not in some (possibly unspecified extension) and\\n    \"in_field\" with the function name is used to indicate that.\\n\\n    f in k(t) can be written as the logarithmic derivative of a k(t) radical if\\n    there exist n in ZZ and u in k(t) with n, u != 0 such that n*f == Du/u.\\n    Either returns (n, u) or None, which means that f cannot be written as the\\n    logarithmic derivative of a k(t)-radical.\\n\\n    case is one of {\\'primitive\\', \\'exp\\', \\'tan\\', \\'auto\\'} for the primitive,\\n    hyperexponential, and hypertangent cases, respectively.  If case is \\'auto\\',\\n    it will attempt to determine the type of the derivation automatically.\\n\\n    See also\\n    ========\\n    is_log_deriv_k_t_radical, is_deriv_k\\n\\n    '\n    (fa, fd) = fa.cancel(fd, include=True)\n    (n, s) = splitfactor(fd, DE)\n    if not s.is_one:\n        pass\n    z = z or Dummy('z')\n    (H, b) = residue_reduce(fa, fd, DE, z=z)\n    if not b:\n        return None\n    roots = [(i, i.real_roots()) for (i, _) in H]\n    if not all((len(j) == i.degree() and all((k.is_Rational for k in j)) for (i, j) in roots)):\n        return None\n    (respolys, residues) = list(zip(*roots)) or [[], []]\n    residueterms = [(H[j][1].subs(z, i), i) for j in range(len(H)) for i in residues[j]]\n    p = cancel(fa.as_expr() / fd.as_expr() - residue_reduce_derivation(H, DE, z))\n    p = p.as_poly(DE.t)\n    if p is None:\n        return None\n    if p.degree(DE.t) >= max(1, DE.d.degree(DE.t)):\n        return None\n    if case == 'auto':\n        case = DE.case\n    if case == 'exp':\n        (wa, wd) = derivation(DE.t, DE).cancel(Poly(DE.t, DE.t), include=True)\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t, cancel=True)\n            (wa, wd) = frac_in((wa, wd), DE.t)\n            A = parametric_log_deriv(pa, pd, wa, wd, DE)\n        if A is None:\n            return None\n        (n, e, u) = A\n        u *= DE.t ** e\n    elif case == 'primitive':\n        with DecrementLevel(DE):\n            (pa, pd) = frac_in(p, DE.t)\n            A = is_log_deriv_k_t_radical_in_field(pa, pd, DE, case='auto')\n        if A is None:\n            return None\n        (n, u) = A\n    elif case == 'base':\n        if not fd.is_sqf or fa.degree() >= fd.degree():\n            return None\n        n = S.One * reduce(ilcm, [i.as_numer_denom()[1] for (_, i) in residueterms], 1)\n        u = Mul(*[Pow(i, j * n) for (i, j) in residueterms])\n        return (n, u)\n    elif case == 'tan':\n        raise NotImplementedError('The hypertangent case is not yet implemented for is_log_deriv_k_t_radical_in_field()')\n    elif case in ('other_linear', 'other_nonlinear'):\n        raise ValueError('The %s case is not supported in this function.' % case)\n    else:\n        raise ValueError(\"case must be one of {'primitive', 'exp', 'tan', 'base', 'auto'}, not %s\" % case)\n    common_denom = S.One * reduce(ilcm, [i.as_numer_denom()[1] for i in [j for (_, j) in residueterms]] + [n], 1)\n    residueterms = [(i, j * common_denom) for (i, j) in residueterms]\n    m = common_denom // n\n    if common_denom != n * m:\n        raise ValueError('Inexact division')\n    u = cancel(u ** m * Mul(*[Pow(i, j) for (i, j) in residueterms]))\n    return (common_denom, u)"
        ]
    }
]