[
    {
        "func_name": "Initialize",
        "original": "def Initialize(self):\n    \"\"\"Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.\"\"\"\n    self.SetStartDate(2014, 3, 24)\n    self.SetEndDate(2014, 3, 31)\n    self.UniverseSettings.Resolution = Resolution.Daily\n    self.AddUniverse(CoarseFundamental, 'custom-data-universe', self.Selection)\n    self._selectionTime = [datetime(2014, 3, 24), datetime(2014, 3, 25), datetime(2014, 3, 26), datetime(2014, 3, 27), datetime(2014, 3, 28), datetime(2014, 3, 29), datetime(2014, 3, 30), datetime(2014, 3, 31)]",
        "mutated": [
            "def Initialize(self):\n    if False:\n        i = 10\n    'Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'\n    self.SetStartDate(2014, 3, 24)\n    self.SetEndDate(2014, 3, 31)\n    self.UniverseSettings.Resolution = Resolution.Daily\n    self.AddUniverse(CoarseFundamental, 'custom-data-universe', self.Selection)\n    self._selectionTime = [datetime(2014, 3, 24), datetime(2014, 3, 25), datetime(2014, 3, 26), datetime(2014, 3, 27), datetime(2014, 3, 28), datetime(2014, 3, 29), datetime(2014, 3, 30), datetime(2014, 3, 31)]",
            "def Initialize(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'\n    self.SetStartDate(2014, 3, 24)\n    self.SetEndDate(2014, 3, 31)\n    self.UniverseSettings.Resolution = Resolution.Daily\n    self.AddUniverse(CoarseFundamental, 'custom-data-universe', self.Selection)\n    self._selectionTime = [datetime(2014, 3, 24), datetime(2014, 3, 25), datetime(2014, 3, 26), datetime(2014, 3, 27), datetime(2014, 3, 28), datetime(2014, 3, 29), datetime(2014, 3, 30), datetime(2014, 3, 31)]",
            "def Initialize(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'\n    self.SetStartDate(2014, 3, 24)\n    self.SetEndDate(2014, 3, 31)\n    self.UniverseSettings.Resolution = Resolution.Daily\n    self.AddUniverse(CoarseFundamental, 'custom-data-universe', self.Selection)\n    self._selectionTime = [datetime(2014, 3, 24), datetime(2014, 3, 25), datetime(2014, 3, 26), datetime(2014, 3, 27), datetime(2014, 3, 28), datetime(2014, 3, 29), datetime(2014, 3, 30), datetime(2014, 3, 31)]",
            "def Initialize(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'\n    self.SetStartDate(2014, 3, 24)\n    self.SetEndDate(2014, 3, 31)\n    self.UniverseSettings.Resolution = Resolution.Daily\n    self.AddUniverse(CoarseFundamental, 'custom-data-universe', self.Selection)\n    self._selectionTime = [datetime(2014, 3, 24), datetime(2014, 3, 25), datetime(2014, 3, 26), datetime(2014, 3, 27), datetime(2014, 3, 28), datetime(2014, 3, 29), datetime(2014, 3, 30), datetime(2014, 3, 31)]",
            "def Initialize(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'\n    self.SetStartDate(2014, 3, 24)\n    self.SetEndDate(2014, 3, 31)\n    self.UniverseSettings.Resolution = Resolution.Daily\n    self.AddUniverse(CoarseFundamental, 'custom-data-universe', self.Selection)\n    self._selectionTime = [datetime(2014, 3, 24), datetime(2014, 3, 25), datetime(2014, 3, 26), datetime(2014, 3, 27), datetime(2014, 3, 28), datetime(2014, 3, 29), datetime(2014, 3, 30), datetime(2014, 3, 31)]"
        ]
    },
    {
        "func_name": "Selection",
        "original": "def Selection(self, coarse):\n    self.Debug(f'Universe selection called: {self.Time} Count: {len(coarse)}')\n    expectedTime = self._selectionTime.pop(0)\n    if expectedTime != self.Time:\n        raise ValueError(f'Unexpected selection time {self.Time} expected {expectedTime}')\n    sortedByDollarVolume = sorted(coarse, key=lambda x: x.DollarVolume, reverse=True)\n    underlyingSymbols = [x.Symbol for x in sortedByDollarVolume[:10]]\n    customSymbols = []\n    for symbol in underlyingSymbols:\n        customSymbols.append(Symbol.CreateBase(MyPyCustomData, symbol))\n    return underlyingSymbols + customSymbols",
        "mutated": [
            "def Selection(self, coarse):\n    if False:\n        i = 10\n    self.Debug(f'Universe selection called: {self.Time} Count: {len(coarse)}')\n    expectedTime = self._selectionTime.pop(0)\n    if expectedTime != self.Time:\n        raise ValueError(f'Unexpected selection time {self.Time} expected {expectedTime}')\n    sortedByDollarVolume = sorted(coarse, key=lambda x: x.DollarVolume, reverse=True)\n    underlyingSymbols = [x.Symbol for x in sortedByDollarVolume[:10]]\n    customSymbols = []\n    for symbol in underlyingSymbols:\n        customSymbols.append(Symbol.CreateBase(MyPyCustomData, symbol))\n    return underlyingSymbols + customSymbols",
            "def Selection(self, coarse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.Debug(f'Universe selection called: {self.Time} Count: {len(coarse)}')\n    expectedTime = self._selectionTime.pop(0)\n    if expectedTime != self.Time:\n        raise ValueError(f'Unexpected selection time {self.Time} expected {expectedTime}')\n    sortedByDollarVolume = sorted(coarse, key=lambda x: x.DollarVolume, reverse=True)\n    underlyingSymbols = [x.Symbol for x in sortedByDollarVolume[:10]]\n    customSymbols = []\n    for symbol in underlyingSymbols:\n        customSymbols.append(Symbol.CreateBase(MyPyCustomData, symbol))\n    return underlyingSymbols + customSymbols",
            "def Selection(self, coarse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.Debug(f'Universe selection called: {self.Time} Count: {len(coarse)}')\n    expectedTime = self._selectionTime.pop(0)\n    if expectedTime != self.Time:\n        raise ValueError(f'Unexpected selection time {self.Time} expected {expectedTime}')\n    sortedByDollarVolume = sorted(coarse, key=lambda x: x.DollarVolume, reverse=True)\n    underlyingSymbols = [x.Symbol for x in sortedByDollarVolume[:10]]\n    customSymbols = []\n    for symbol in underlyingSymbols:\n        customSymbols.append(Symbol.CreateBase(MyPyCustomData, symbol))\n    return underlyingSymbols + customSymbols",
            "def Selection(self, coarse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.Debug(f'Universe selection called: {self.Time} Count: {len(coarse)}')\n    expectedTime = self._selectionTime.pop(0)\n    if expectedTime != self.Time:\n        raise ValueError(f'Unexpected selection time {self.Time} expected {expectedTime}')\n    sortedByDollarVolume = sorted(coarse, key=lambda x: x.DollarVolume, reverse=True)\n    underlyingSymbols = [x.Symbol for x in sortedByDollarVolume[:10]]\n    customSymbols = []\n    for symbol in underlyingSymbols:\n        customSymbols.append(Symbol.CreateBase(MyPyCustomData, symbol))\n    return underlyingSymbols + customSymbols",
            "def Selection(self, coarse):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.Debug(f'Universe selection called: {self.Time} Count: {len(coarse)}')\n    expectedTime = self._selectionTime.pop(0)\n    if expectedTime != self.Time:\n        raise ValueError(f'Unexpected selection time {self.Time} expected {expectedTime}')\n    sortedByDollarVolume = sorted(coarse, key=lambda x: x.DollarVolume, reverse=True)\n    underlyingSymbols = [x.Symbol for x in sortedByDollarVolume[:10]]\n    customSymbols = []\n    for symbol in underlyingSymbols:\n        customSymbols.append(Symbol.CreateBase(MyPyCustomData, symbol))\n    return underlyingSymbols + customSymbols"
        ]
    },
    {
        "func_name": "OnData",
        "original": "def OnData(self, data):\n    \"\"\"OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\n\n        Arguments:\n            data: Slice object keyed by symbol containing the stock data\n        \"\"\"\n    if not self.Portfolio.Invested:\n        customData = data.Get(MyPyCustomData)\n        symbols = [symbol for symbol in data.Keys if symbol.SecurityType is SecurityType.Equity]\n        for symbol in symbols:\n            self.SetHoldings(symbol, 1 / len(symbols))\n            if len([x for x in customData.Keys if x.Underlying == symbol]) == 0:\n                raise ValueError(f'Custom data was not found for symbol {symbol}')",
        "mutated": [
            "def OnData(self, data):\n    if False:\n        i = 10\n    'OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\\n\\n        Arguments:\\n            data: Slice object keyed by symbol containing the stock data\\n        '\n    if not self.Portfolio.Invested:\n        customData = data.Get(MyPyCustomData)\n        symbols = [symbol for symbol in data.Keys if symbol.SecurityType is SecurityType.Equity]\n        for symbol in symbols:\n            self.SetHoldings(symbol, 1 / len(symbols))\n            if len([x for x in customData.Keys if x.Underlying == symbol]) == 0:\n                raise ValueError(f'Custom data was not found for symbol {symbol}')",
            "def OnData(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\\n\\n        Arguments:\\n            data: Slice object keyed by symbol containing the stock data\\n        '\n    if not self.Portfolio.Invested:\n        customData = data.Get(MyPyCustomData)\n        symbols = [symbol for symbol in data.Keys if symbol.SecurityType is SecurityType.Equity]\n        for symbol in symbols:\n            self.SetHoldings(symbol, 1 / len(symbols))\n            if len([x for x in customData.Keys if x.Underlying == symbol]) == 0:\n                raise ValueError(f'Custom data was not found for symbol {symbol}')",
            "def OnData(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\\n\\n        Arguments:\\n            data: Slice object keyed by symbol containing the stock data\\n        '\n    if not self.Portfolio.Invested:\n        customData = data.Get(MyPyCustomData)\n        symbols = [symbol for symbol in data.Keys if symbol.SecurityType is SecurityType.Equity]\n        for symbol in symbols:\n            self.SetHoldings(symbol, 1 / len(symbols))\n            if len([x for x in customData.Keys if x.Underlying == symbol]) == 0:\n                raise ValueError(f'Custom data was not found for symbol {symbol}')",
            "def OnData(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\\n\\n        Arguments:\\n            data: Slice object keyed by symbol containing the stock data\\n        '\n    if not self.Portfolio.Invested:\n        customData = data.Get(MyPyCustomData)\n        symbols = [symbol for symbol in data.Keys if symbol.SecurityType is SecurityType.Equity]\n        for symbol in symbols:\n            self.SetHoldings(symbol, 1 / len(symbols))\n            if len([x for x in customData.Keys if x.Underlying == symbol]) == 0:\n                raise ValueError(f'Custom data was not found for symbol {symbol}')",
            "def OnData(self, data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\\n\\n        Arguments:\\n            data: Slice object keyed by symbol containing the stock data\\n        '\n    if not self.Portfolio.Invested:\n        customData = data.Get(MyPyCustomData)\n        symbols = [symbol for symbol in data.Keys if symbol.SecurityType is SecurityType.Equity]\n        for symbol in symbols:\n            self.SetHoldings(symbol, 1 / len(symbols))\n            if len([x for x in customData.Keys if x.Underlying == symbol]) == 0:\n                raise ValueError(f'Custom data was not found for symbol {symbol}')"
        ]
    },
    {
        "func_name": "GetSource",
        "original": "def GetSource(self, config, date, isLiveMode):\n    source = f'{Globals.DataFolder}/equity/usa/daily/{LeanData.GenerateZipFileName(config.Symbol, date, config.Resolution, config.TickType)}'\n    return SubscriptionDataSource(source, SubscriptionTransportMedium.LocalFile, FileFormat.Csv)",
        "mutated": [
            "def GetSource(self, config, date, isLiveMode):\n    if False:\n        i = 10\n    source = f'{Globals.DataFolder}/equity/usa/daily/{LeanData.GenerateZipFileName(config.Symbol, date, config.Resolution, config.TickType)}'\n    return SubscriptionDataSource(source, SubscriptionTransportMedium.LocalFile, FileFormat.Csv)",
            "def GetSource(self, config, date, isLiveMode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    source = f'{Globals.DataFolder}/equity/usa/daily/{LeanData.GenerateZipFileName(config.Symbol, date, config.Resolution, config.TickType)}'\n    return SubscriptionDataSource(source, SubscriptionTransportMedium.LocalFile, FileFormat.Csv)",
            "def GetSource(self, config, date, isLiveMode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    source = f'{Globals.DataFolder}/equity/usa/daily/{LeanData.GenerateZipFileName(config.Symbol, date, config.Resolution, config.TickType)}'\n    return SubscriptionDataSource(source, SubscriptionTransportMedium.LocalFile, FileFormat.Csv)",
            "def GetSource(self, config, date, isLiveMode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    source = f'{Globals.DataFolder}/equity/usa/daily/{LeanData.GenerateZipFileName(config.Symbol, date, config.Resolution, config.TickType)}'\n    return SubscriptionDataSource(source, SubscriptionTransportMedium.LocalFile, FileFormat.Csv)",
            "def GetSource(self, config, date, isLiveMode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    source = f'{Globals.DataFolder}/equity/usa/daily/{LeanData.GenerateZipFileName(config.Symbol, date, config.Resolution, config.TickType)}'\n    return SubscriptionDataSource(source, SubscriptionTransportMedium.LocalFile, FileFormat.Csv)"
        ]
    },
    {
        "func_name": "Reader",
        "original": "def Reader(self, config, line, date, isLiveMode):\n    csv = line.split(',')\n    _scaleFactor = 1 / 10000\n    custom = MyPyCustomData()\n    custom.Symbol = config.Symbol\n    custom.Time = datetime.strptime(csv[0], '%Y%m%d %H:%M')\n    custom.Open = float(csv[1]) * _scaleFactor\n    custom.High = float(csv[2]) * _scaleFactor\n    custom.Low = float(csv[3]) * _scaleFactor\n    custom.Close = float(csv[4]) * _scaleFactor\n    custom.Value = float(csv[4]) * _scaleFactor\n    custom.Period = Time.OneDay\n    custom.EndTime = custom.Time + custom.Period\n    return custom",
        "mutated": [
            "def Reader(self, config, line, date, isLiveMode):\n    if False:\n        i = 10\n    csv = line.split(',')\n    _scaleFactor = 1 / 10000\n    custom = MyPyCustomData()\n    custom.Symbol = config.Symbol\n    custom.Time = datetime.strptime(csv[0], '%Y%m%d %H:%M')\n    custom.Open = float(csv[1]) * _scaleFactor\n    custom.High = float(csv[2]) * _scaleFactor\n    custom.Low = float(csv[3]) * _scaleFactor\n    custom.Close = float(csv[4]) * _scaleFactor\n    custom.Value = float(csv[4]) * _scaleFactor\n    custom.Period = Time.OneDay\n    custom.EndTime = custom.Time + custom.Period\n    return custom",
            "def Reader(self, config, line, date, isLiveMode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    csv = line.split(',')\n    _scaleFactor = 1 / 10000\n    custom = MyPyCustomData()\n    custom.Symbol = config.Symbol\n    custom.Time = datetime.strptime(csv[0], '%Y%m%d %H:%M')\n    custom.Open = float(csv[1]) * _scaleFactor\n    custom.High = float(csv[2]) * _scaleFactor\n    custom.Low = float(csv[3]) * _scaleFactor\n    custom.Close = float(csv[4]) * _scaleFactor\n    custom.Value = float(csv[4]) * _scaleFactor\n    custom.Period = Time.OneDay\n    custom.EndTime = custom.Time + custom.Period\n    return custom",
            "def Reader(self, config, line, date, isLiveMode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    csv = line.split(',')\n    _scaleFactor = 1 / 10000\n    custom = MyPyCustomData()\n    custom.Symbol = config.Symbol\n    custom.Time = datetime.strptime(csv[0], '%Y%m%d %H:%M')\n    custom.Open = float(csv[1]) * _scaleFactor\n    custom.High = float(csv[2]) * _scaleFactor\n    custom.Low = float(csv[3]) * _scaleFactor\n    custom.Close = float(csv[4]) * _scaleFactor\n    custom.Value = float(csv[4]) * _scaleFactor\n    custom.Period = Time.OneDay\n    custom.EndTime = custom.Time + custom.Period\n    return custom",
            "def Reader(self, config, line, date, isLiveMode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    csv = line.split(',')\n    _scaleFactor = 1 / 10000\n    custom = MyPyCustomData()\n    custom.Symbol = config.Symbol\n    custom.Time = datetime.strptime(csv[0], '%Y%m%d %H:%M')\n    custom.Open = float(csv[1]) * _scaleFactor\n    custom.High = float(csv[2]) * _scaleFactor\n    custom.Low = float(csv[3]) * _scaleFactor\n    custom.Close = float(csv[4]) * _scaleFactor\n    custom.Value = float(csv[4]) * _scaleFactor\n    custom.Period = Time.OneDay\n    custom.EndTime = custom.Time + custom.Period\n    return custom",
            "def Reader(self, config, line, date, isLiveMode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    csv = line.split(',')\n    _scaleFactor = 1 / 10000\n    custom = MyPyCustomData()\n    custom.Symbol = config.Symbol\n    custom.Time = datetime.strptime(csv[0], '%Y%m%d %H:%M')\n    custom.Open = float(csv[1]) * _scaleFactor\n    custom.High = float(csv[2]) * _scaleFactor\n    custom.Low = float(csv[3]) * _scaleFactor\n    custom.Close = float(csv[4]) * _scaleFactor\n    custom.Value = float(csv[4]) * _scaleFactor\n    custom.Period = Time.OneDay\n    custom.EndTime = custom.Time + custom.Period\n    return custom"
        ]
    }
]