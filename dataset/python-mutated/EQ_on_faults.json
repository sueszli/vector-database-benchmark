[
    {
        "func_name": "__init__",
        "original": "def __init__(self, Run_Name, M_min, mfd_param, faults_names, faults_area, faults_length, faults_width, faults_slip_rates, scenarios, faults_shear_mod, path, pathlog, sample, selected_ScL, dimention_used, use_all_ScL_data, faults_mecanism, bg_ratio, size_of_increment, mfd_hyp, count_reruns, faults_lon, faults_lat, Mmax_range, calculation_log_file, branch, param):\n    self.Run_Name = Run_Name\n    self.M_min = M_min\n    self.mfd_param = mfd_param\n    self.faults_names = faults_names\n    self.faults_area = faults_area\n    self.faults_length = faults_length\n    self.faults_width = faults_width\n    self.faults_slip_rates = faults_slip_rates\n    self.scenarios = scenarios\n    self.faults_shear_mod = faults_shear_mod\n    self.path = path\n    self.pathlog = pathlog\n    self.sample = sample\n    self.selected_ScL = selected_ScL\n    self.dimention_used = dimention_used\n    self.use_all_ScL_data = use_all_ScL_data\n    self.faults_mecanism = faults_mecanism\n    self.bg_ratio = bg_ratio\n    self.size_of_increment = size_of_increment\n    self.mfd_hyp = mfd_hyp\n    self.count_reruns = count_reruns\n    self.faults_lon = faults_lon\n    self.faults_lat = faults_lat\n    self.Mmax_range = Mmax_range\n    self.calculation_log_file = calculation_log_file\n    self.branch = branch\n    self.param = param\n    self.initialize()",
        "mutated": [
            "def __init__(self, Run_Name, M_min, mfd_param, faults_names, faults_area, faults_length, faults_width, faults_slip_rates, scenarios, faults_shear_mod, path, pathlog, sample, selected_ScL, dimention_used, use_all_ScL_data, faults_mecanism, bg_ratio, size_of_increment, mfd_hyp, count_reruns, faults_lon, faults_lat, Mmax_range, calculation_log_file, branch, param):\n    if False:\n        i = 10\n    self.Run_Name = Run_Name\n    self.M_min = M_min\n    self.mfd_param = mfd_param\n    self.faults_names = faults_names\n    self.faults_area = faults_area\n    self.faults_length = faults_length\n    self.faults_width = faults_width\n    self.faults_slip_rates = faults_slip_rates\n    self.scenarios = scenarios\n    self.faults_shear_mod = faults_shear_mod\n    self.path = path\n    self.pathlog = pathlog\n    self.sample = sample\n    self.selected_ScL = selected_ScL\n    self.dimention_used = dimention_used\n    self.use_all_ScL_data = use_all_ScL_data\n    self.faults_mecanism = faults_mecanism\n    self.bg_ratio = bg_ratio\n    self.size_of_increment = size_of_increment\n    self.mfd_hyp = mfd_hyp\n    self.count_reruns = count_reruns\n    self.faults_lon = faults_lon\n    self.faults_lat = faults_lat\n    self.Mmax_range = Mmax_range\n    self.calculation_log_file = calculation_log_file\n    self.branch = branch\n    self.param = param\n    self.initialize()",
            "def __init__(self, Run_Name, M_min, mfd_param, faults_names, faults_area, faults_length, faults_width, faults_slip_rates, scenarios, faults_shear_mod, path, pathlog, sample, selected_ScL, dimention_used, use_all_ScL_data, faults_mecanism, bg_ratio, size_of_increment, mfd_hyp, count_reruns, faults_lon, faults_lat, Mmax_range, calculation_log_file, branch, param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.Run_Name = Run_Name\n    self.M_min = M_min\n    self.mfd_param = mfd_param\n    self.faults_names = faults_names\n    self.faults_area = faults_area\n    self.faults_length = faults_length\n    self.faults_width = faults_width\n    self.faults_slip_rates = faults_slip_rates\n    self.scenarios = scenarios\n    self.faults_shear_mod = faults_shear_mod\n    self.path = path\n    self.pathlog = pathlog\n    self.sample = sample\n    self.selected_ScL = selected_ScL\n    self.dimention_used = dimention_used\n    self.use_all_ScL_data = use_all_ScL_data\n    self.faults_mecanism = faults_mecanism\n    self.bg_ratio = bg_ratio\n    self.size_of_increment = size_of_increment\n    self.mfd_hyp = mfd_hyp\n    self.count_reruns = count_reruns\n    self.faults_lon = faults_lon\n    self.faults_lat = faults_lat\n    self.Mmax_range = Mmax_range\n    self.calculation_log_file = calculation_log_file\n    self.branch = branch\n    self.param = param\n    self.initialize()",
            "def __init__(self, Run_Name, M_min, mfd_param, faults_names, faults_area, faults_length, faults_width, faults_slip_rates, scenarios, faults_shear_mod, path, pathlog, sample, selected_ScL, dimention_used, use_all_ScL_data, faults_mecanism, bg_ratio, size_of_increment, mfd_hyp, count_reruns, faults_lon, faults_lat, Mmax_range, calculation_log_file, branch, param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.Run_Name = Run_Name\n    self.M_min = M_min\n    self.mfd_param = mfd_param\n    self.faults_names = faults_names\n    self.faults_area = faults_area\n    self.faults_length = faults_length\n    self.faults_width = faults_width\n    self.faults_slip_rates = faults_slip_rates\n    self.scenarios = scenarios\n    self.faults_shear_mod = faults_shear_mod\n    self.path = path\n    self.pathlog = pathlog\n    self.sample = sample\n    self.selected_ScL = selected_ScL\n    self.dimention_used = dimention_used\n    self.use_all_ScL_data = use_all_ScL_data\n    self.faults_mecanism = faults_mecanism\n    self.bg_ratio = bg_ratio\n    self.size_of_increment = size_of_increment\n    self.mfd_hyp = mfd_hyp\n    self.count_reruns = count_reruns\n    self.faults_lon = faults_lon\n    self.faults_lat = faults_lat\n    self.Mmax_range = Mmax_range\n    self.calculation_log_file = calculation_log_file\n    self.branch = branch\n    self.param = param\n    self.initialize()",
            "def __init__(self, Run_Name, M_min, mfd_param, faults_names, faults_area, faults_length, faults_width, faults_slip_rates, scenarios, faults_shear_mod, path, pathlog, sample, selected_ScL, dimention_used, use_all_ScL_data, faults_mecanism, bg_ratio, size_of_increment, mfd_hyp, count_reruns, faults_lon, faults_lat, Mmax_range, calculation_log_file, branch, param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.Run_Name = Run_Name\n    self.M_min = M_min\n    self.mfd_param = mfd_param\n    self.faults_names = faults_names\n    self.faults_area = faults_area\n    self.faults_length = faults_length\n    self.faults_width = faults_width\n    self.faults_slip_rates = faults_slip_rates\n    self.scenarios = scenarios\n    self.faults_shear_mod = faults_shear_mod\n    self.path = path\n    self.pathlog = pathlog\n    self.sample = sample\n    self.selected_ScL = selected_ScL\n    self.dimention_used = dimention_used\n    self.use_all_ScL_data = use_all_ScL_data\n    self.faults_mecanism = faults_mecanism\n    self.bg_ratio = bg_ratio\n    self.size_of_increment = size_of_increment\n    self.mfd_hyp = mfd_hyp\n    self.count_reruns = count_reruns\n    self.faults_lon = faults_lon\n    self.faults_lat = faults_lat\n    self.Mmax_range = Mmax_range\n    self.calculation_log_file = calculation_log_file\n    self.branch = branch\n    self.param = param\n    self.initialize()",
            "def __init__(self, Run_Name, M_min, mfd_param, faults_names, faults_area, faults_length, faults_width, faults_slip_rates, scenarios, faults_shear_mod, path, pathlog, sample, selected_ScL, dimention_used, use_all_ScL_data, faults_mecanism, bg_ratio, size_of_increment, mfd_hyp, count_reruns, faults_lon, faults_lat, Mmax_range, calculation_log_file, branch, param):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.Run_Name = Run_Name\n    self.M_min = M_min\n    self.mfd_param = mfd_param\n    self.faults_names = faults_names\n    self.faults_area = faults_area\n    self.faults_length = faults_length\n    self.faults_width = faults_width\n    self.faults_slip_rates = faults_slip_rates\n    self.scenarios = scenarios\n    self.faults_shear_mod = faults_shear_mod\n    self.path = path\n    self.pathlog = pathlog\n    self.sample = sample\n    self.selected_ScL = selected_ScL\n    self.dimention_used = dimention_used\n    self.use_all_ScL_data = use_all_ScL_data\n    self.faults_mecanism = faults_mecanism\n    self.bg_ratio = bg_ratio\n    self.size_of_increment = size_of_increment\n    self.mfd_hyp = mfd_hyp\n    self.count_reruns = count_reruns\n    self.faults_lon = faults_lon\n    self.faults_lat = faults_lat\n    self.Mmax_range = Mmax_range\n    self.calculation_log_file = calculation_log_file\n    self.branch = branch\n    self.param = param\n    self.initialize()"
        ]
    },
    {
        "func_name": "initialize",
        "original": "def initialize(self):\n    faults_shear_mod = self.faults_shear_mod\n    mfd_param = self.mfd_param\n    M_min = self.M_min\n    Mmax_range = self.Mmax_range\n    inti_core_time = time.time()\n    faults_names = self.faults_names\n    faults_areas = self.faults_area\n    faults_length = self.faults_length\n    faults_width = self.faults_width\n    faults_slip_rates = self.faults_slip_rates\n    log_calculation_file = open(self.pathlog + '/calculation_sample_' + str(self.sample) + '.txt', 'w')\n    log_sliprep_file = self.pathlog + '/sliprep_sample_' + str(self.sample) + '.pkl'\n    re_use = True\n    scenarios_names = self.scenarios\n    run_name = self.Run_Name\n    model_name = self.branch['model']\n    scl_name = self.branch['scl'][0] + '_' + self.branch['scl'][1] + '_' + self.branch['scl'][2]\n    set_name = self.branch['set']\n    f_mmax = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_mmax_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_mmax):\n        re_use = False\n    if re_use == False:\n        print('Building scenarios and Mmax')\n        '##################################################################\\n            # finds the faults belonging to each scenario\\n            ##################################################################'\n        index_faults_in_scenario = []\n        for scenario in scenarios_names:\n            i_scenario = []\n            for i in range(len(scenario)):\n                i_scenario = i_scenario + list(np.where(np.array(faults_names) == scenario['f_%s' % str(i + 1)]))\n            i_scenario = np.reshape(i_scenario, (1, len(scenario)))\n            index_faults_in_scenario.append(i_scenario)\n        self.index_faults_in_scenario = index_faults_in_scenario\n        faults_alone = []\n        faults_isolated = []\n        len_max_section_scenario = 0\n        for indexes in index_faults_in_scenario:\n            if len(indexes[0]) > len_max_section_scenario:\n                len_max_section_scenario = len(indexes[0])\n        index_fault = 0\n        for fault_name in faults_names:\n            fault_alone_bool = True\n            fault_isolated_bool = True\n            for indexes in index_faults_in_scenario:\n                if index_fault in indexes[0]:\n                    fault_alone_bool = False\n                    if len(indexes[0]) > len_max_section_scenario / 2.0:\n                        fault_isolated_bool = False\n            if fault_isolated_bool == True and fault_alone_bool == False:\n                faults_isolated.append(index_fault)\n            if fault_alone_bool == True:\n                faults_alone.append(index_fault)\n            index_fault += 1\n        '##################################################################\\n            # area and length of each scenario\\n            ##################################################################'\n        scenario_area = []\n        index_faults_in_scenario_for_scl = []\n        for indexes_i in index_faults_in_scenario:\n            list_of_points = []\n            index_for_scenario = []\n            for index_fault in indexes_i[0]:\n                list_i = str(self.faults_lon[index_fault][0]) + str(self.faults_lon[index_fault][-1]) + str(self.faults_lat[index_fault][0]) + str(self.faults_lat[index_fault][-1])\n                if not list_i in list_of_points:\n                    list_of_points.append(list_i)\n                    index_for_scenario.append(index_fault)\n            index_faults_in_scenario_for_scl.append(index_for_scenario)\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_area = np.sum(np.take(faults_areas, i))\n            scenario_area.append(scenario_i_area)\n        scenario_length = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_length = np.sum(np.take(faults_length, i))\n            scenario_length.append(scenario_i_length)\n        scenario_width = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_width = np.mean(np.take(faults_width, i))\n            scenario_width.append(scenario_i_width)\n        '\\n            check the max dimention for a single fault according to the\\n            aspect ratio\\n            '\n        (f_len_ar, f_width_ar, f_area_ar) = ([], [], [])\n        ar = self.param['main']['parameters']['aspect_ratio']\n        for (l, w) in zip(self.faults_length, self.faults_width):\n            if l < w * ar:\n                f_len_ar.append(l)\n                f_width_ar.append(l * ar)\n                f_area_ar.append(l * l * ar)\n            else:\n                f_len_ar.append(l)\n                f_width_ar.append(w)\n                f_area_ar.append(l * w)\n        '##################################################################\\n            #####################################################################\\n            #\\n            # setting up the coefficients for the scalling law\\n            # and calculate the Mmax\\n            #\\n            #####################################################################\\n            ##################################################################'\n        Mmaxmin = Mmax_range[0]\n        Mmaxmax = Mmax_range[1]\n        Mmax = -1.0\n        loop_Mmax = 1\n        while Mmax < Mmaxmin or Mmax > Mmaxmax:\n            log_Mmax_file = open(self.param['dirpath'] + run_name + '/LOG/' + model_name + '_Log_Mmax_sample_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.txt', 'w')\n            if loop_Mmax == 1:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, self.sample)\n            else:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, 10)\n            Mmax_faults = Mmaxs.Mmax_faults\n            Mmax_scenario = Mmaxs.Mmax_scenario\n            final_fault_length = Mmaxs.final_fault_length\n            final_scenario_length = Mmaxs.final_scenario_length\n            index_fault = 0\n            for Mmax_i in Mmax_faults:\n                line = faults_names[index_fault] + '\\t' + str(round(faults_length[index_fault] / 1000.0, 1)) + '\\t' + final_fault_length[index_fault] + '\\t' + str(round(self.faults_width[index_fault], 1)) + '\\t' + str(round(self.faults_area[index_fault] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_fault += 1\n            index_scenario = 0\n            for Mmax_i in Mmax_scenario:\n                line = str(scenarios_names[index_scenario]) + '\\t' + str(round(scenario_length[index_scenario] / 1000.0, 1)) + '\\t' + final_scenario_length[index_scenario] + '\\t' + str(round(scenario_width[index_scenario], 1)) + '\\t' + str(round(scenario_area[index_scenario] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_scenario += 1\n            log_Mmax_file.close()\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            loop_Mmax += 1\n            if loop_Mmax == 30:\n                print('An Mmax incompatible with the ruptures is imposed!! Change it in run.info or change the rupture.txt file')\n        if loop_Mmax >= 3:\n            print('Mmax imposed: ' + str(Mmax))\n            self.calculation_log_file.write('\\nMmax imposed: ' + str(Mmax))\n        with open(f_mmax, 'wb') as f:\n            dump_to_file = [Mmax_faults, Mmax_scenario, final_fault_length, final_scenario_length, faults_alone, faults_isolated, index_faults_in_scenario, scenario_area]\n            pickle.dump(dump_to_file, f)\n        print('\\t - scenario and max built')\n    else:\n        print('Reloading Mmax from data file')\n        with open(f_mmax, 'rb') as f:\n            load_from_file = pickle.load(f)\n            Mmax_faults = load_from_file[0]\n            Mmax_scenario = load_from_file[1]\n            final_fault_length = load_from_file[2]\n            final_scenario_length = load_from_file[3]\n            faults_alone = load_from_file[4]\n            faults_isolated = load_from_file[5]\n            index_faults_in_scenario = load_from_file[6]\n            scenario_area = load_from_file[7]\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            print('\\t - scenario and max loaded')\n    '##################################################################\\n        #etablish the magnitude bin (0.1)\\n        ##################################################################'\n    bin_mag = np.linspace(M_min, Mmax, int(round(Mmax - M_min, 1) * 10.0 + 1))\n    '#####################################################################\\n        # initializing incremental reccurence of the earthquakes for each rupture and each bin)\\n        #####################################################################'\n    rup_rates = {}\n    index_rup = []\n    for i in range(len(faults_names)):\n        rup_rates.update({str(i): {'rup_id': i, 'rup_name': faults_names[i], 'involved_faults': [i], 'Mmax': Mmax_faults[i], 'area': faults_areas[i], 'rates': np.zeros(len(bin_mag))}})\n        index_rup.append(i)\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            rup_rates.update({str(i_end + j): {'rup_id': i_end + j, 'rup_name': scenarios_names[j], 'involved_faults': index_faults_in_scenario[j][0], 'Mmax': Mmax_scenario[j], 'area': scenario_area[j], 'rates': np.zeros(len(bin_mag))}})\n            index_rup.append(i_end + j)\n    if str(self.sample) == '1':\n        log_rup_file = open(self.pathlog + '/ruptures.txt', 'w')\n        log_rup_file.write('rup_id\\tinvolved_faults\\n')\n        for i in range(len(rup_rates)):\n            log_rup_file.write(str(rup_rates.get(str(i)).get('rup_id')) + '\\t')\n            for j in rup_rates.get(str(i)).get('involved_faults'):\n                log_rup_file.write(str(j) + ' ')\n            log_rup_file.write('\\n')\n        log_rup_file.close()\n    self.index_faults_in_scenario = index_faults_in_scenario\n    '#####################################################################\\n        # For each bin, find which fault and which scenario populates it.\\n        #####################################################################'\n    f_bin_pop = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_bin_pop_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_bin_pop):\n        re_use = False\n    rup_in_bin = populate_bins.pop(bin_mag, index_rup, rup_rates, M_min, re_use, f_bin_pop)\n    '##################################################################\\n        # Definition of the background - how much is not on the faults\\n        ##################################################################'\n    bin_mag_fault_prop = [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0]\n    fault_prop_inc = self.bg_ratio\n    bin_mag_fault_prop.append(10.0)\n    fault_prop_inc = np.append(np.array(fault_prop_inc), 1.0)\n    fault_prop = interp1d(bin_mag_fault_prop, fault_prop_inc)\n    self.fault_prop = fault_prop\n    '##################################################################\\n        #Calculation of the total moment rate sum(slip-rate)*sum(area) + moment in the background\\n        ##################################################################'\n    Total_moment_faults_rate_init = 0.0\n    index_fault = 0\n    for fault_area in faults_areas:\n        Total_moment_faults_rate_init += faults_shear_mod[index_fault] * fault_area * faults_slip_rates[index_fault]\n        index_fault += 1\n    log_calculation_file.write('Moment_rate_fault_initial calculated using muAs' + '\\t' + str(Total_moment_faults_rate_init) + '\\t' + 'N.m' + '\\n')\n    Total_moment_rate_fault = 0.0\n    '##################################################################\\n        #etablish the target regional distribution\\n        ##################################################################'\n    if self.mfd_hyp == 'GR':\n        p_MFD = mfd_shape.GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'tapered_GR':\n        mfd_param['M_corner'] = Mmax - 0.4\n        p_MFD = mfd_shape.tapered_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'double_GR':\n        p_MFD = mfd_shape.double_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'YC':\n        p_MFD = mfd_shape.YC(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_marmara':\n        p_MFD = mfd_shape.YC_marmara(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_modified':\n        p_MFD = mfd_shape.YC_modified(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'UCERF_DV':\n        p_MFD = mfd_shape.UCERF_DV(bin_mag)\n    else:\n        print('Error : Unknown MFD name!')\n    p_MFD = p_MFD / sum(p_MFD)\n    '##################################################################\\n        # Converting in term of moment\\n        ##################################################################'\n    p_MFD_MO = []\n    index_mag = 0\n    for mag in bin_mag:\n        M0 = mag_to_M0(mag)\n        p_MFD_MO.append(fault_prop(mag) * p_MFD[index_mag] * M0)\n        index_mag += 1\n    p_MFD_MO = p_MFD_MO / sum(p_MFD_MO)\n    '##################################################################\\n        # Adding the moment rate of the background to the Total_moment_rate_init\\n        ##################################################################'\n    Total_moment_rate_init = Total_moment_faults_rate_init\n    index_mag = 0\n    for mag in bin_mag:\n        moment_rate_fault_bin = p_MFD_MO[index_mag] * Total_moment_faults_rate_init\n        moment_rate_BG_bin = (1 - fault_prop(mag)) * moment_rate_fault_bin / fault_prop(mag)\n        Total_moment_rate_init += moment_rate_BG_bin\n        index_mag += 1\n    '##################################################################\\n        # Etablish the target of moment rate per bin\\n        ##################################################################'\n    target_moment_per_bin = p_MFD_MO * Total_moment_faults_rate_init\n    '##################################################################\\n        # Create the sliprate budget dictionary\\n        # This matrix contain a list of the fault name. each name is repeted\\n        # by a number of time depending of the slip-rate of the fault.\\n        ##################################################################'\n    size_of_increment = float(self.size_of_increment) * 0.001\n    if self.count_reruns != 1:\n        size_of_increment = size_of_increment / (float(self.count_reruns) * 1.5 - 1.0)\n    faults_budget = {}\n    for index_fault in range(len(faults_names)):\n        nb_dsr = int(round(faults_slip_rates[index_fault] / size_of_increment, 0))\n        if nb_dsr == 0:\n            nb_dsr = 1\n        faults_budget.update({index_fault: nb_dsr})\n    min_budget = float(min(faults_budget.values())) + 1\n    max_budget = float(max(faults_budget.values()))\n    while max_budget / min_budget > 50.0:\n        min_budget *= 2.0\n    '##################################################################\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        #   Populate the bin of magnitude of each fault and each scenario\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        ##################################################################'\n    M_slip_repartition = {}\n    for (fault, i) in zip(faults_names, range(len(faults_names))):\n        dic_tmp = {}\n        for rup_i in range(len(rup_rates)):\n            if i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                dic_tmp.update({str(rup_i): 0})\n        dic_tmp.update({'NMS': 0})\n        M_slip_repartition.update({str(fault): dic_tmp})\n    moment_rate_in_bin = np.zeros(len(bin_mag))\n    model_MFD = []\n    number_of_loops = 0\n    number_of_loops_before = 0\n    number_of_loops_for_nothing = 0\n    number_of_loops_for_nothing_before = 0\n    number_of_loops_last_checked = -1\n    empty_bins = []\n    empty_rups = []\n    bin_target_reached = []\n    len_faults_budget = []\n    aseismic_count = 0\n    color_mag = []\n    '######################\\n        #####   MAIN LOOP   #####\\n        ######################'\n    TARGET = []\n    nb_ss_to_spend = float(sum(faults_budget.values()))\n    sum_fault_budget = nb_ss_to_spend\n    print('Number of dsr to spend : ' + str(nb_ss_to_spend))\n    print('Min of sdr :', min(faults_budget.values()))\n    print('Max of sdr :', max(faults_budget.values()))\n    self.calculation_log_file.write('\\nnumber of dsr to spend : ' + str(nb_ss_to_spend) + '\\n')\n    print_percent = True\n    do_the_target = True\n    bool_target_set = False\n    uniform_spending = self.param['main']['parameters']['uniform_spending']\n    if uniform_spending in ['True', 'true']:\n        uniform_spending = True\n    else:\n        uniform_spending = False\n    deep_analysis = self.param['main']['parameters']['deep_analysis']\n    if deep_analysis in ['True', 'true']:\n        deep_analysis = True\n    else:\n        deep_analysis = False\n    faster_rup_weight = self.param['main']['parameters']['faster_rup_weight']\n    if faster_rup_weight in ['True', 'true']:\n        faster_rup_weight = True\n    else:\n        faster_rup_weight = False\n    option_fast = self.param['main']['parameters']['option_fast']\n    if option_fast in ['True', 'true']:\n        option_fast = True\n    else:\n        option_fast = False\n    local_MFD = self.param['main']['parameters']['local_MFD']\n    if local_MFD in ['True', 'true']:\n        f_mfd_area = self.param['main']['local_MFD_file']\n        (local_mfds, associated_rup, associated_weight) = core_utils.link_rup_mfd_area(rup_rates, f_mfd_area, self.faults_lon, self.faults_lat, bin_mag, self.bg_ratio)\n    time_weight_rupt = 0.0\n    time_clean_w_rupt = 0.0\n    time_target_building = 0.0\n    time_checking_target_reach = 0.0\n    time_spending_dsr = 0.0\n    time_checking_empty_bin = 0.0\n    time_checking_empty_faults = 0.0\n    budget_init = int(sum_fault_budget)\n    if faster_rup_weight == True:\n        nb_weigthings_rup_sampling = int(self.param['main']['parameters']['nb_weigthings_rup_sampling'])\n        if 'type_weigthings_rup_sampling' in self.param['main']['parameters'].keys():\n            type_weigthings_rup_sampling = self.param['main']['parameters']['type_weigthings_rup_sampling']\n        else:\n            type_weigthings_rup_sampling = 'lin'\n        if type_weigthings_rup_sampling == 'log':\n            weigthing_built = [int(i) for i in np.logspace(0.0, np.log10(budget_init), nb_weigthings_rup_sampling)]\n        if type_weigthings_rup_sampling == 'lin':\n            weigthing_built = [int(i) for i in np.linspace(0.0, budget_init, nb_weigthings_rup_sampling)]\n    else:\n        weigthing_built = [int(i) for i in range(budget_init)]\n    weigthing_built.reverse()\n    weigth_rup_sample = 0\n    slip_rate_use_per_fault = np.zeros(len(faults_names))\n    moment_rate_required = 0.0\n    moment_rate_left = Total_moment_faults_rate_init\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    rate_in_model = np.zeros(len(bin_mag))\n    test_mean_picked = []\n    most_likely_pick = []\n    n_w_work = 0\n    n_w_crash = 0\n    loop_last_rup_w = 0\n    picked_empty_rup = 0\n    old_percent = '0000'\n    while sum_fault_budget > 0:\n        ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n        if ratio_done > 0.01:\n            (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n        number_of_loops += 1\n        if len(empty_bins) != len(bin_mag):\n            ' Calculate the new target shape in each bin in terms of moment rate '\n            tmp = time.time()\n            target_i = target.get_new_target(number_of_loops, moment_rate_in_bin, p_MFD_MO, target_moment_per_bin, bin_mag, empty_bins, bin_target_reached, rup_in_bin)\n            time_target_building += time.time() - tmp\n            if sum(target_i) == 0.0:\n                target_i = p_MFD_MO\n            try:\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            except:\n                print(target_i)\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            if deep_analysis == True:\n                percent = round((1.0 - float(sum_fault_budget) / float(nb_ss_to_spend)) * 100.0)\n                percent = '{:04d}'.format(percent)\n                if percent != old_percent:\n                    old_percent = percent\n                    print('\\nnumber_of_loops', number_of_loops)\n                    print('budget left : ', sum_fault_budget, ' | ', percent, '%')\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time building target at time i : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_weight_rupt)\n                    print('time weighting rupture pick : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_clean_w_rupt)\n                    print('time cleaning weighting rupture weigth : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_target_reach)\n                    print('time checking target reach : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_bin)\n                    print('time checking empty bins : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_faults)\n                    print('time checking empty faults : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time spending dsr : ', time_str)\n                    time_str = core_utils.seconds_to_str(time.time() - inti_core_time)\n                    print('total core time : ', time_str)\n                    tot_core_time = time.time() - inti_core_time\n                    unaccounted_t = tot_core_time - (time_target_building + time_weight_rupt + time_clean_w_rupt + time_checking_target_reach + time_checking_empty_bin + time_checking_empty_faults + time_spending_dsr)\n                    time_str = core_utils.seconds_to_str(unaccounted_t)\n                    print('unaccounted time : ', time_str)\n                    print('max target : ', round(max(target_i), 4), '| last bin w : ', str(round(target_i[-1], 6)))\n                    print('Empty mag bins:')\n                    print(empty_bins)\n                    budget_last_bin = 0\n                    for rup_i in rup_in_bin[-1]:\n                        if not str(rup_i) in empty_rups:\n                            for f_i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                                budget_last_bin += faults_budget[f_i]\n                    print('fault budget last bin :', budget_last_bin)\n                    (fig, (ax0, ax1)) = plt.subplots(ncols=2)\n                    ax0.plot(bin_mag, target_i, label='target_i', marker='x')\n                    ax0.plot(bin_mag, p_MFD_MO, label='p_MFD_MO', marker='x')\n                    ax0.legend()\n                    ax1.plot(bin_mag, target_moment_per_bin, label='target_moment_per_bin', marker='x')\n                    ax1.plot(bin_mag, moment_rate_in_bin, label='moment_rate_in_bin', marker='x')\n                    ax1.set_yscale('log')\n                    ax1.legend()\n                    plt.savefig(self.pathlog + '/Log_tmp_' + str(self.sample) + '.png', dpi=80, transparent=True)\n                    plt.close()\n            'Pick the bin of magnitude to fill according to the current distribution '\n            target_i = target_i / sum(target_i)\n            picked_bin = np.random.choice(len(bin_mag), 1, p=target_i)[0]\n            mag = bin_mag[picked_bin]\n            tmp = time.time()\n            if not picked_bin in empty_bins:\n                empty_in_bin = set(rup_in_bin[picked_bin]) & set(empty_rups)\n                if len(empty_in_bin) == len(rup_in_bin[picked_bin]):\n                    empty_bins.append(picked_bin)\n            time_checking_empty_bin += time.time() - tmp\n            if not picked_bin in empty_bins:\n                tmp = time.time()\n                'Calculate the weight for sampling of the fault or scenario'\n                do_rup_weight = False\n                if number_of_loops == 1:\n                    do_rup_weight = True\n                if sum_fault_budget < weigthing_built[weigth_rup_sample]:\n                    do_rup_weight = True\n                if do_rup_weight == True:\n                    loop_last_rup_w = number_of_loops\n                    weigth_rup_sample += 1\n                    if faster_rup_weight == True:\n                        list_of_bins = range(len(bin_mag))\n                    else:\n                        list_of_bins = [picked_bin]\n                    w_rup_binmag = []\n                    for index_mag in list_of_bins:\n                        if index_mag in empty_bins:\n                            w_rup_binmag.append([])\n                        else:\n                            weight_rup_i = core_utils.weight_fault_sampling(index_mag, rup_in_bin, faults_names, faults_slip_rates, slip_rate_use_per_fault, faults_alone, scenarios_names, faults_isolated, index_faults_in_scenario, rup_rates, empty_rups)\n                            if local_MFD == True:\n                                factor_on_weight = core_utils.check_local_mfd(rup_rates, rup_in_bin[index_mag], index_mag, bin_mag, local_mfds, associated_rup, associated_weight)\n                                weight_rup_i = np.array([i * w for (i, w) in zip(weight_rup_i, factor_on_weight)])\n                                weight_rup_i /= weight_rup_i.sum()\n                            if sum(weight_rup_i) != 0.0:\n                                weight_rup_i = [float(i) / sum(weight_rup_i) for i in weight_rup_i]\n                            w_rup_binmag.append(weight_rup_i)\n                    time_weight_rupt += time.time() - tmp\n                    tmp = time.time()\n                    for index_mag in list_of_bins:\n                        if not index_mag in empty_bins:\n                            weight_rup = w_rup_binmag[index_mag]\n                            if set(rup_in_bin[index_mag]) & set(empty_rups):\n                                i = 0\n                                for i_rup in rup_in_bin[index_mag]:\n                                    if str(i_rup) in empty_rups:\n                                        weight_rup[i] = 0.0\n                                    i += 1\n                            weight_rup = list(weight_rup)\n                            sum_weight_rup = sum(weight_rup)\n                            if sum(weight_rup) == 0.0:\n                                empty_bins.append(index_mag)\n                            if not index_mag in empty_bins:\n                                if sum_weight_rup != 1.0:\n                                    weight_rup = [float(i) / sum_weight_rup for i in weight_rup]\n                                if math.isnan(sum(weight_rup)):\n                                    print('WARNING : sum rup weight is nan')\n                                    nb_nans = 0\n                                    id = 0\n                                    for i in weight_rup:\n                                        if math.isnan(i):\n                                            nb_nans += 1\n                                        weight_rup[id] = 0.0\n                                        id += 1\n                            w_rup_binmag[index_mag] = weight_rup\n                    time_clean_w_rupt += time.time() - tmp\n                if faster_rup_weight == True:\n                    weight_rup = w_rup_binmag[picked_bin]\n                else:\n                    weight_rup = w_rup_binmag[0]\n                try:\n                    i_picked = np.where(np.random.multinomial(1, weight_rup) == 1)[0][0]\n                    picked_rup = rup_in_bin[picked_bin][i_picked]\n                except ValueError:\n                    print(\"rupt weights didn't work. sum:\", sum(weight_rup))\n                    picked_rup = np.random.choice(rup_in_bin[picked_bin])\n                    n_w_crash += 1\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                if bool_target_set == False:\n                    tmp = time.time()\n                    last_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-3:]:\n                        if not bin_i in empty_bins:\n                            last_bins_empty = False\n                    if last_bins_empty == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        bool_target_set = True\n                        print('set target - limit on the largest magnitudes')\n                    if moment_rate_left <= (1.0 - 1e-05) * moment_rate_required:\n                        self.calculation_log_file.write('\\n Not enough moment left ')\n                        for rup_i in rup_in_bin[-3] + rup_in_bin[-2] + rup_in_bin[-1]:\n                            if not str(rup_i) in empty_rups:\n                                empty_rups.append(str(rup_i))\n                        rup_in_bin[-3] = []\n                        rup_in_bin[-2] = []\n                        rup_in_bin[-1] = []\n                        bool_target_set = True\n                        print('set target - moment rate is limiting')\n                    antelast_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-2:]:\n                        if not bin_i in empty_bins:\n                            antelast_bins_empty = False\n                    if antelast_bins_empty == True and bool_target_set == False:\n                        if moment_rate_in_bin[-3] >= 2.0 * (moment_rate_in_bin[-2] + moment_rate_in_bin[-1]):\n                            self.calculation_log_file.write('\\n antepenultimate bin getting too high')\n                            for rup_i in rup_in_bin[-3]:\n                                if not str(rup_i) in empty_rups:\n                                    empty_rups.append(str(rup_i))\n                            empty_bins.append(range(len(bin_mag))[-3])\n                            bool_target_set = True\n                            print('set target - antepenultimate bin getting too high')\n                    if number_of_loops > number_of_loops_last_checked + 50.0:\n                        number_of_loops_last_checked = number_of_loops\n                        moment_rate_left = Total_moment_faults_rate_init - Total_moment_rate_fault\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        rate_Mmax_check = np.mean(rate_tot_model[-3:])\n                        moment_rate_required = 0.0\n                        for index_mag in range(len(bin_mag) - 3):\n                            rate_Mi_check = rate_tot_model[index_mag]\n                            target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-2]\n                            moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            moment_rate_required = 0.0\n                            for index_mag in range(len(bin_mag) - 3):\n                                rate_Mi_check = rate_tot_model[index_mag]\n                                target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-3]\n                                moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                    time_checking_target_reach += time.time() - tmp\n                    if do_the_target == True and bool_target_set == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        do_the_target = False\n                        print('- target set - ')\n                        self.calculation_log_file.write('\\n- target set - ')\n                        rate_at_target_setting = rate_tot_model\n                        rate_Mmax = np.mean(rate_tot_model[-3:])\n                        TARGET = []\n                        for t_mag_bin in range(len(bin_mag)):\n                            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            TARGET = []\n                            for t_mag_bin in range(len(bin_mag)):\n                                rate_Mi = rate_tot_model[t_mag_bin]\n                                TARGET.append(rate_Mmax * p_MFD[picked_bin] / p_MFD[-3])\n                if picked_bin in bin_target_reached:\n                    print('WHAT ARE YOU DOING HERE?', bin_mag[picked_bin])\n                    exit()\n                ' spending the slip_rate increment '\n                tmp = time.time()\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                sr_to_spend = True\n                shear_mod = 0\n                for index in index_fault:\n                    shear_mod += faults_shear_mod[index]\n                    if faults_budget[index] <= 0.0:\n                        sr_to_spend = False\n                if sr_to_spend == False:\n                    if not str(picked_rup) in empty_rups:\n                        empty_rups.append(str(picked_rup))\n                    else:\n                        picked_empty_rup += 1\n                if sr_to_spend == True:\n                    shear_mod = shear_mod / float(len(index_fault))\n                    area = rup_rates.get(str(picked_rup)).get('area')\n                    displacement = mag_to_M0(mag) / (shear_mod * area)\n                    rate_i = size_of_increment / displacement\n                    if option_fast == True:\n                        min_budget_local = min([faults_budget[i] for i in index_fault])\n                        nb_loop_spending = int(min_budget_local / min_budget)\n                        if nb_loop_spending < 1:\n                            nb_loop_spending = 1\n                    else:\n                        nb_loop_spending = 1\n                    if bool_target_set == True:\n                        rate_Mi = rate_in_model[picked_bin]\n                        target_mfd_i = TARGET[picked_bin] * fault_prop(bin_mag[picked_bin])\n                        if rate_Mi < target_mfd_i:\n                            if uniform_spending == True or len(index_fault) == 1:\n                                moment_rate_i = 0.0\n                                for index in index_fault:\n                                    for loop_spending in range(nb_loop_spending):\n                                        M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                    faults_budget[index] += -1 * nb_loop_spending\n                                    sum_fault_budget += -1 * nb_loop_spending\n                                    slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                                rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                            else:\n                                moment_rate_i = 0.0\n                                for loop_spending in range(nb_loop_spending):\n                                    (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                    rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                    rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                    moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                            moment_rate_in_bin[picked_bin] += moment_rate_i\n                            Total_moment_rate_fault += moment_rate_i\n                        else:\n                            rup_in_bin[picked_bin] = []\n                            if not picked_bin in bin_target_reached:\n                                bin_target_reached.append(picked_bin)\n                    else:\n                        if uniform_spending == True or len(index_fault) == 1:\n                            moment_rate_i = 0.0\n                            for index in index_fault:\n                                for loop_spending in range(nb_loop_spending):\n                                    M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                faults_budget[index] += -1 * nb_loop_spending\n                                sum_fault_budget += -1 * nb_loop_spending\n                                slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                            rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                            rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                            moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                        else:\n                            moment_rate_i = 0.0\n                            for loop_spending in range(nb_loop_spending):\n                                (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                        moment_rate_in_bin[picked_bin] += moment_rate_i\n                        Total_moment_rate_fault += moment_rate_i\n                time_spending_dsr += time.time() - tmp\n            elif not picked_bin in empty_bins:\n                empty_bins.append(picked_bin)\n            tmp = time.time()\n            if number_of_loops > number_of_loops_before + 500:\n                number_of_loops_before = number_of_loops\n                for index_mag in range(len(bin_mag)):\n                    if not index_mag in empty_bins:\n                        nb_rup_not_empty = 0\n                        for i_rup in rup_in_bin[index_mag]:\n                            if nb_rup_not_empty == 0:\n                                rup_is_empty = False\n                                for index_fault in rup_rates.get(str(i_rup)).get('involved_faults'):\n                                    if faults_budget[index_fault] <= 0:\n                                        rup_is_empty = True\n                                if rup_is_empty == False:\n                                    nb_rup_not_empty += 1\n                        if nb_rup_not_empty == 0:\n                            empty_bins.append(index_mag)\n            time_checking_empty_bin += time.time() - tmp\n            tmp = time.time()\n            len_faults_budget.append(sum_fault_budget)\n            if len(len_faults_budget) > 3:\n                if len_faults_budget[-2] == len_faults_budget[-1]:\n                    number_of_loops_for_nothing += 1\n                if number_of_loops_for_nothing_before < number_of_loops_for_nothing - 100:\n                    number_of_loops_for_nothing_before = number_of_loops_for_nothing\n                    if len_faults_budget[-1] == len_faults_budget[-10]:\n                        rup_still_used = [i for i in rup_in_bin[picked_bin] if not i in empty_rups]\n                        fault_still_used = []\n                        for rup_i in rup_still_used:\n                            fault_still_used += list(rup_rates.get(str(rup_i)).get('involved_faults'))\n                        fault_still_used = set(fault_still_used)\n                        for (fault, index_fault) in zip(faults_names, range(len(faults_names))):\n                            if not index_fault in fault_still_used and faults_budget[index_fault] > 0:\n                                while faults_budget[index_fault] > 0:\n                                    ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                                    if ratio_done > 0.01:\n                                        (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                                    faults_budget[index_fault] += -1\n                                    sum_fault_budget += -1\n                                    M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                                    aseismic_count += 1\n            time_checking_empty_faults += time.time() - tmp\n        else:\n            print('-target filled-')\n            self.calculation_log_file.write('\\n-target filled-')\n            while sum_fault_budget != 0:\n                ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                if ratio_done > 0.01:\n                    (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                for index_fault in range(len(faults_names)):\n                    if faults_budget[index_fault] > 0:\n                        faults_budget[index_fault] += -1\n                        sum_fault_budget += -1\n                        M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                        aseismic_count += 1\n    ' check if the TARGET as been set.\\n        if not, build it for comparing'\n    if TARGET == []:\n        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n        print('- target set at the end- ')\n        self.calculation_log_file.write('\\n- target set at the end - ')\n        rate_at_target_setting = rate_tot_model\n        rate_Mmax = np.mean(rate_tot_model[-3:])\n        for t_mag_bin in range(len(bin_mag)):\n            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n    '##################################################################\\n        #\\n        # Definition of the background seismicity\\n        #\\n        ##################################################################'\n    (rate_f_in_model, rate_bg_in_model) = rates.get_rate_faults_n_bg(rup_rates, fault_prop, bin_mag)\n    EQ_rate_BG = rate_bg_in_model\n    '##################################################################\\n        # printing\\n        ##################################################################'\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    model_MFD.append(rate_tot_model)\n    colors = ['gainsboro', 'darkgray', 'dimgray', 'dimgray', 'black', 'red']\n    index_color = 0\n    for MFD_i in model_MFD:\n        plt.plot(bin_mag, MFD_i, color=colors[index_color])\n        index_color += 1\n    if do_the_target == True:\n        rate_at_target_setting = model_MFD[-1]\n    plt.plot(bin_mag, rate_at_target_setting, ':g')\n    plt.plot(bin_mag, TARGET, ':b')\n    plt.scatter(bin_mag[-3:], rate_tot_model[-3:], c='k')\n    plt.yscale('log')\n    plt.savefig(self.pathlog + '/Log_target_fit_' + str(self.sample) + '.png', dpi=180, transparent=True)\n    plt.close()\n    index_5 = 0\n    while bin_mag[index_mag] < 5.0:\n        index_5 += 1\n    self.ratio_test = np.mean([abs(TARGET[index_5 + 0] / rate_tot_model[index_5 + 0]), abs(TARGET[index_5 + 1] / rate_tot_model[index_5 + 1]), abs(TARGET[index_5 + 2] / rate_tot_model[index_5 + 2]), abs(TARGET[index_5 + 3] / rate_tot_model[index_5 + 3]), abs(TARGET[index_5 + 4] / rate_tot_model[index_5 + 4])])\n    MFD_to_test = rate_tot_model / sum(rate_tot_model)\n    target_to_test = TARGET / sum(TARGET)\n    array_absolute_ratio = []\n    for index_mag in range(len(bin_mag)):\n        array_absolute_ratio.append(abs(MFD_to_test[index_mag] / target_to_test[index_mag]))\n    self.ratio_test = np.mean(array_absolute_ratio)\n    print('ratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    self.calculation_log_file.write('\\nratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    '##################################################################\\n        #\\n        # OUTPUT for Source_model_creator\\n        #\\n        ##################################################################'\n    self.OQ_entry_faults = []\n    self.OQ_entry_scenarios = []\n    for i in range(len(faults_names)):\n        self.OQ_entry_faults.append(rup_rates.get(str(i)).get('rates'))\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            self.OQ_entry_scenarios.append(rup_rates.get(str(i_end + j)).get('rates'))\n    self.faults_names = faults_names\n    self.scenarios_names = scenarios_names\n    self.EQ_rate_BG = EQ_rate_BG\n    self.bin_mag = bin_mag\n    self.rup_rates = rup_rates\n    self.M_slip_repartition = M_slip_repartition\n    log_calculation_file.write('Moment_rate_faults_final calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.write('Ratio of NMS slip rate counted in the iterative process: ' + '\\t' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))) + '\\t %\\n')\n    log_calculation_file.write('Moment_rate_model calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.close()\n    self.ratio_NMS = round(100.0 * (1.0 - Total_moment_rate_fault / Total_moment_faults_rate_init))\n    print('ratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    self.calculation_log_file.write('\\nratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    f = open(log_sliprep_file, 'wb')\n    pickle.dump(M_slip_repartition, f)\n    f.close()",
        "mutated": [
            "def initialize(self):\n    if False:\n        i = 10\n    faults_shear_mod = self.faults_shear_mod\n    mfd_param = self.mfd_param\n    M_min = self.M_min\n    Mmax_range = self.Mmax_range\n    inti_core_time = time.time()\n    faults_names = self.faults_names\n    faults_areas = self.faults_area\n    faults_length = self.faults_length\n    faults_width = self.faults_width\n    faults_slip_rates = self.faults_slip_rates\n    log_calculation_file = open(self.pathlog + '/calculation_sample_' + str(self.sample) + '.txt', 'w')\n    log_sliprep_file = self.pathlog + '/sliprep_sample_' + str(self.sample) + '.pkl'\n    re_use = True\n    scenarios_names = self.scenarios\n    run_name = self.Run_Name\n    model_name = self.branch['model']\n    scl_name = self.branch['scl'][0] + '_' + self.branch['scl'][1] + '_' + self.branch['scl'][2]\n    set_name = self.branch['set']\n    f_mmax = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_mmax_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_mmax):\n        re_use = False\n    if re_use == False:\n        print('Building scenarios and Mmax')\n        '##################################################################\\n            # finds the faults belonging to each scenario\\n            ##################################################################'\n        index_faults_in_scenario = []\n        for scenario in scenarios_names:\n            i_scenario = []\n            for i in range(len(scenario)):\n                i_scenario = i_scenario + list(np.where(np.array(faults_names) == scenario['f_%s' % str(i + 1)]))\n            i_scenario = np.reshape(i_scenario, (1, len(scenario)))\n            index_faults_in_scenario.append(i_scenario)\n        self.index_faults_in_scenario = index_faults_in_scenario\n        faults_alone = []\n        faults_isolated = []\n        len_max_section_scenario = 0\n        for indexes in index_faults_in_scenario:\n            if len(indexes[0]) > len_max_section_scenario:\n                len_max_section_scenario = len(indexes[0])\n        index_fault = 0\n        for fault_name in faults_names:\n            fault_alone_bool = True\n            fault_isolated_bool = True\n            for indexes in index_faults_in_scenario:\n                if index_fault in indexes[0]:\n                    fault_alone_bool = False\n                    if len(indexes[0]) > len_max_section_scenario / 2.0:\n                        fault_isolated_bool = False\n            if fault_isolated_bool == True and fault_alone_bool == False:\n                faults_isolated.append(index_fault)\n            if fault_alone_bool == True:\n                faults_alone.append(index_fault)\n            index_fault += 1\n        '##################################################################\\n            # area and length of each scenario\\n            ##################################################################'\n        scenario_area = []\n        index_faults_in_scenario_for_scl = []\n        for indexes_i in index_faults_in_scenario:\n            list_of_points = []\n            index_for_scenario = []\n            for index_fault in indexes_i[0]:\n                list_i = str(self.faults_lon[index_fault][0]) + str(self.faults_lon[index_fault][-1]) + str(self.faults_lat[index_fault][0]) + str(self.faults_lat[index_fault][-1])\n                if not list_i in list_of_points:\n                    list_of_points.append(list_i)\n                    index_for_scenario.append(index_fault)\n            index_faults_in_scenario_for_scl.append(index_for_scenario)\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_area = np.sum(np.take(faults_areas, i))\n            scenario_area.append(scenario_i_area)\n        scenario_length = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_length = np.sum(np.take(faults_length, i))\n            scenario_length.append(scenario_i_length)\n        scenario_width = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_width = np.mean(np.take(faults_width, i))\n            scenario_width.append(scenario_i_width)\n        '\\n            check the max dimention for a single fault according to the\\n            aspect ratio\\n            '\n        (f_len_ar, f_width_ar, f_area_ar) = ([], [], [])\n        ar = self.param['main']['parameters']['aspect_ratio']\n        for (l, w) in zip(self.faults_length, self.faults_width):\n            if l < w * ar:\n                f_len_ar.append(l)\n                f_width_ar.append(l * ar)\n                f_area_ar.append(l * l * ar)\n            else:\n                f_len_ar.append(l)\n                f_width_ar.append(w)\n                f_area_ar.append(l * w)\n        '##################################################################\\n            #####################################################################\\n            #\\n            # setting up the coefficients for the scalling law\\n            # and calculate the Mmax\\n            #\\n            #####################################################################\\n            ##################################################################'\n        Mmaxmin = Mmax_range[0]\n        Mmaxmax = Mmax_range[1]\n        Mmax = -1.0\n        loop_Mmax = 1\n        while Mmax < Mmaxmin or Mmax > Mmaxmax:\n            log_Mmax_file = open(self.param['dirpath'] + run_name + '/LOG/' + model_name + '_Log_Mmax_sample_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.txt', 'w')\n            if loop_Mmax == 1:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, self.sample)\n            else:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, 10)\n            Mmax_faults = Mmaxs.Mmax_faults\n            Mmax_scenario = Mmaxs.Mmax_scenario\n            final_fault_length = Mmaxs.final_fault_length\n            final_scenario_length = Mmaxs.final_scenario_length\n            index_fault = 0\n            for Mmax_i in Mmax_faults:\n                line = faults_names[index_fault] + '\\t' + str(round(faults_length[index_fault] / 1000.0, 1)) + '\\t' + final_fault_length[index_fault] + '\\t' + str(round(self.faults_width[index_fault], 1)) + '\\t' + str(round(self.faults_area[index_fault] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_fault += 1\n            index_scenario = 0\n            for Mmax_i in Mmax_scenario:\n                line = str(scenarios_names[index_scenario]) + '\\t' + str(round(scenario_length[index_scenario] / 1000.0, 1)) + '\\t' + final_scenario_length[index_scenario] + '\\t' + str(round(scenario_width[index_scenario], 1)) + '\\t' + str(round(scenario_area[index_scenario] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_scenario += 1\n            log_Mmax_file.close()\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            loop_Mmax += 1\n            if loop_Mmax == 30:\n                print('An Mmax incompatible with the ruptures is imposed!! Change it in run.info or change the rupture.txt file')\n        if loop_Mmax >= 3:\n            print('Mmax imposed: ' + str(Mmax))\n            self.calculation_log_file.write('\\nMmax imposed: ' + str(Mmax))\n        with open(f_mmax, 'wb') as f:\n            dump_to_file = [Mmax_faults, Mmax_scenario, final_fault_length, final_scenario_length, faults_alone, faults_isolated, index_faults_in_scenario, scenario_area]\n            pickle.dump(dump_to_file, f)\n        print('\\t - scenario and max built')\n    else:\n        print('Reloading Mmax from data file')\n        with open(f_mmax, 'rb') as f:\n            load_from_file = pickle.load(f)\n            Mmax_faults = load_from_file[0]\n            Mmax_scenario = load_from_file[1]\n            final_fault_length = load_from_file[2]\n            final_scenario_length = load_from_file[3]\n            faults_alone = load_from_file[4]\n            faults_isolated = load_from_file[5]\n            index_faults_in_scenario = load_from_file[6]\n            scenario_area = load_from_file[7]\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            print('\\t - scenario and max loaded')\n    '##################################################################\\n        #etablish the magnitude bin (0.1)\\n        ##################################################################'\n    bin_mag = np.linspace(M_min, Mmax, int(round(Mmax - M_min, 1) * 10.0 + 1))\n    '#####################################################################\\n        # initializing incremental reccurence of the earthquakes for each rupture and each bin)\\n        #####################################################################'\n    rup_rates = {}\n    index_rup = []\n    for i in range(len(faults_names)):\n        rup_rates.update({str(i): {'rup_id': i, 'rup_name': faults_names[i], 'involved_faults': [i], 'Mmax': Mmax_faults[i], 'area': faults_areas[i], 'rates': np.zeros(len(bin_mag))}})\n        index_rup.append(i)\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            rup_rates.update({str(i_end + j): {'rup_id': i_end + j, 'rup_name': scenarios_names[j], 'involved_faults': index_faults_in_scenario[j][0], 'Mmax': Mmax_scenario[j], 'area': scenario_area[j], 'rates': np.zeros(len(bin_mag))}})\n            index_rup.append(i_end + j)\n    if str(self.sample) == '1':\n        log_rup_file = open(self.pathlog + '/ruptures.txt', 'w')\n        log_rup_file.write('rup_id\\tinvolved_faults\\n')\n        for i in range(len(rup_rates)):\n            log_rup_file.write(str(rup_rates.get(str(i)).get('rup_id')) + '\\t')\n            for j in rup_rates.get(str(i)).get('involved_faults'):\n                log_rup_file.write(str(j) + ' ')\n            log_rup_file.write('\\n')\n        log_rup_file.close()\n    self.index_faults_in_scenario = index_faults_in_scenario\n    '#####################################################################\\n        # For each bin, find which fault and which scenario populates it.\\n        #####################################################################'\n    f_bin_pop = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_bin_pop_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_bin_pop):\n        re_use = False\n    rup_in_bin = populate_bins.pop(bin_mag, index_rup, rup_rates, M_min, re_use, f_bin_pop)\n    '##################################################################\\n        # Definition of the background - how much is not on the faults\\n        ##################################################################'\n    bin_mag_fault_prop = [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0]\n    fault_prop_inc = self.bg_ratio\n    bin_mag_fault_prop.append(10.0)\n    fault_prop_inc = np.append(np.array(fault_prop_inc), 1.0)\n    fault_prop = interp1d(bin_mag_fault_prop, fault_prop_inc)\n    self.fault_prop = fault_prop\n    '##################################################################\\n        #Calculation of the total moment rate sum(slip-rate)*sum(area) + moment in the background\\n        ##################################################################'\n    Total_moment_faults_rate_init = 0.0\n    index_fault = 0\n    for fault_area in faults_areas:\n        Total_moment_faults_rate_init += faults_shear_mod[index_fault] * fault_area * faults_slip_rates[index_fault]\n        index_fault += 1\n    log_calculation_file.write('Moment_rate_fault_initial calculated using muAs' + '\\t' + str(Total_moment_faults_rate_init) + '\\t' + 'N.m' + '\\n')\n    Total_moment_rate_fault = 0.0\n    '##################################################################\\n        #etablish the target regional distribution\\n        ##################################################################'\n    if self.mfd_hyp == 'GR':\n        p_MFD = mfd_shape.GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'tapered_GR':\n        mfd_param['M_corner'] = Mmax - 0.4\n        p_MFD = mfd_shape.tapered_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'double_GR':\n        p_MFD = mfd_shape.double_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'YC':\n        p_MFD = mfd_shape.YC(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_marmara':\n        p_MFD = mfd_shape.YC_marmara(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_modified':\n        p_MFD = mfd_shape.YC_modified(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'UCERF_DV':\n        p_MFD = mfd_shape.UCERF_DV(bin_mag)\n    else:\n        print('Error : Unknown MFD name!')\n    p_MFD = p_MFD / sum(p_MFD)\n    '##################################################################\\n        # Converting in term of moment\\n        ##################################################################'\n    p_MFD_MO = []\n    index_mag = 0\n    for mag in bin_mag:\n        M0 = mag_to_M0(mag)\n        p_MFD_MO.append(fault_prop(mag) * p_MFD[index_mag] * M0)\n        index_mag += 1\n    p_MFD_MO = p_MFD_MO / sum(p_MFD_MO)\n    '##################################################################\\n        # Adding the moment rate of the background to the Total_moment_rate_init\\n        ##################################################################'\n    Total_moment_rate_init = Total_moment_faults_rate_init\n    index_mag = 0\n    for mag in bin_mag:\n        moment_rate_fault_bin = p_MFD_MO[index_mag] * Total_moment_faults_rate_init\n        moment_rate_BG_bin = (1 - fault_prop(mag)) * moment_rate_fault_bin / fault_prop(mag)\n        Total_moment_rate_init += moment_rate_BG_bin\n        index_mag += 1\n    '##################################################################\\n        # Etablish the target of moment rate per bin\\n        ##################################################################'\n    target_moment_per_bin = p_MFD_MO * Total_moment_faults_rate_init\n    '##################################################################\\n        # Create the sliprate budget dictionary\\n        # This matrix contain a list of the fault name. each name is repeted\\n        # by a number of time depending of the slip-rate of the fault.\\n        ##################################################################'\n    size_of_increment = float(self.size_of_increment) * 0.001\n    if self.count_reruns != 1:\n        size_of_increment = size_of_increment / (float(self.count_reruns) * 1.5 - 1.0)\n    faults_budget = {}\n    for index_fault in range(len(faults_names)):\n        nb_dsr = int(round(faults_slip_rates[index_fault] / size_of_increment, 0))\n        if nb_dsr == 0:\n            nb_dsr = 1\n        faults_budget.update({index_fault: nb_dsr})\n    min_budget = float(min(faults_budget.values())) + 1\n    max_budget = float(max(faults_budget.values()))\n    while max_budget / min_budget > 50.0:\n        min_budget *= 2.0\n    '##################################################################\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        #   Populate the bin of magnitude of each fault and each scenario\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        ##################################################################'\n    M_slip_repartition = {}\n    for (fault, i) in zip(faults_names, range(len(faults_names))):\n        dic_tmp = {}\n        for rup_i in range(len(rup_rates)):\n            if i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                dic_tmp.update({str(rup_i): 0})\n        dic_tmp.update({'NMS': 0})\n        M_slip_repartition.update({str(fault): dic_tmp})\n    moment_rate_in_bin = np.zeros(len(bin_mag))\n    model_MFD = []\n    number_of_loops = 0\n    number_of_loops_before = 0\n    number_of_loops_for_nothing = 0\n    number_of_loops_for_nothing_before = 0\n    number_of_loops_last_checked = -1\n    empty_bins = []\n    empty_rups = []\n    bin_target_reached = []\n    len_faults_budget = []\n    aseismic_count = 0\n    color_mag = []\n    '######################\\n        #####   MAIN LOOP   #####\\n        ######################'\n    TARGET = []\n    nb_ss_to_spend = float(sum(faults_budget.values()))\n    sum_fault_budget = nb_ss_to_spend\n    print('Number of dsr to spend : ' + str(nb_ss_to_spend))\n    print('Min of sdr :', min(faults_budget.values()))\n    print('Max of sdr :', max(faults_budget.values()))\n    self.calculation_log_file.write('\\nnumber of dsr to spend : ' + str(nb_ss_to_spend) + '\\n')\n    print_percent = True\n    do_the_target = True\n    bool_target_set = False\n    uniform_spending = self.param['main']['parameters']['uniform_spending']\n    if uniform_spending in ['True', 'true']:\n        uniform_spending = True\n    else:\n        uniform_spending = False\n    deep_analysis = self.param['main']['parameters']['deep_analysis']\n    if deep_analysis in ['True', 'true']:\n        deep_analysis = True\n    else:\n        deep_analysis = False\n    faster_rup_weight = self.param['main']['parameters']['faster_rup_weight']\n    if faster_rup_weight in ['True', 'true']:\n        faster_rup_weight = True\n    else:\n        faster_rup_weight = False\n    option_fast = self.param['main']['parameters']['option_fast']\n    if option_fast in ['True', 'true']:\n        option_fast = True\n    else:\n        option_fast = False\n    local_MFD = self.param['main']['parameters']['local_MFD']\n    if local_MFD in ['True', 'true']:\n        f_mfd_area = self.param['main']['local_MFD_file']\n        (local_mfds, associated_rup, associated_weight) = core_utils.link_rup_mfd_area(rup_rates, f_mfd_area, self.faults_lon, self.faults_lat, bin_mag, self.bg_ratio)\n    time_weight_rupt = 0.0\n    time_clean_w_rupt = 0.0\n    time_target_building = 0.0\n    time_checking_target_reach = 0.0\n    time_spending_dsr = 0.0\n    time_checking_empty_bin = 0.0\n    time_checking_empty_faults = 0.0\n    budget_init = int(sum_fault_budget)\n    if faster_rup_weight == True:\n        nb_weigthings_rup_sampling = int(self.param['main']['parameters']['nb_weigthings_rup_sampling'])\n        if 'type_weigthings_rup_sampling' in self.param['main']['parameters'].keys():\n            type_weigthings_rup_sampling = self.param['main']['parameters']['type_weigthings_rup_sampling']\n        else:\n            type_weigthings_rup_sampling = 'lin'\n        if type_weigthings_rup_sampling == 'log':\n            weigthing_built = [int(i) for i in np.logspace(0.0, np.log10(budget_init), nb_weigthings_rup_sampling)]\n        if type_weigthings_rup_sampling == 'lin':\n            weigthing_built = [int(i) for i in np.linspace(0.0, budget_init, nb_weigthings_rup_sampling)]\n    else:\n        weigthing_built = [int(i) for i in range(budget_init)]\n    weigthing_built.reverse()\n    weigth_rup_sample = 0\n    slip_rate_use_per_fault = np.zeros(len(faults_names))\n    moment_rate_required = 0.0\n    moment_rate_left = Total_moment_faults_rate_init\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    rate_in_model = np.zeros(len(bin_mag))\n    test_mean_picked = []\n    most_likely_pick = []\n    n_w_work = 0\n    n_w_crash = 0\n    loop_last_rup_w = 0\n    picked_empty_rup = 0\n    old_percent = '0000'\n    while sum_fault_budget > 0:\n        ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n        if ratio_done > 0.01:\n            (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n        number_of_loops += 1\n        if len(empty_bins) != len(bin_mag):\n            ' Calculate the new target shape in each bin in terms of moment rate '\n            tmp = time.time()\n            target_i = target.get_new_target(number_of_loops, moment_rate_in_bin, p_MFD_MO, target_moment_per_bin, bin_mag, empty_bins, bin_target_reached, rup_in_bin)\n            time_target_building += time.time() - tmp\n            if sum(target_i) == 0.0:\n                target_i = p_MFD_MO\n            try:\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            except:\n                print(target_i)\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            if deep_analysis == True:\n                percent = round((1.0 - float(sum_fault_budget) / float(nb_ss_to_spend)) * 100.0)\n                percent = '{:04d}'.format(percent)\n                if percent != old_percent:\n                    old_percent = percent\n                    print('\\nnumber_of_loops', number_of_loops)\n                    print('budget left : ', sum_fault_budget, ' | ', percent, '%')\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time building target at time i : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_weight_rupt)\n                    print('time weighting rupture pick : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_clean_w_rupt)\n                    print('time cleaning weighting rupture weigth : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_target_reach)\n                    print('time checking target reach : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_bin)\n                    print('time checking empty bins : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_faults)\n                    print('time checking empty faults : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time spending dsr : ', time_str)\n                    time_str = core_utils.seconds_to_str(time.time() - inti_core_time)\n                    print('total core time : ', time_str)\n                    tot_core_time = time.time() - inti_core_time\n                    unaccounted_t = tot_core_time - (time_target_building + time_weight_rupt + time_clean_w_rupt + time_checking_target_reach + time_checking_empty_bin + time_checking_empty_faults + time_spending_dsr)\n                    time_str = core_utils.seconds_to_str(unaccounted_t)\n                    print('unaccounted time : ', time_str)\n                    print('max target : ', round(max(target_i), 4), '| last bin w : ', str(round(target_i[-1], 6)))\n                    print('Empty mag bins:')\n                    print(empty_bins)\n                    budget_last_bin = 0\n                    for rup_i in rup_in_bin[-1]:\n                        if not str(rup_i) in empty_rups:\n                            for f_i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                                budget_last_bin += faults_budget[f_i]\n                    print('fault budget last bin :', budget_last_bin)\n                    (fig, (ax0, ax1)) = plt.subplots(ncols=2)\n                    ax0.plot(bin_mag, target_i, label='target_i', marker='x')\n                    ax0.plot(bin_mag, p_MFD_MO, label='p_MFD_MO', marker='x')\n                    ax0.legend()\n                    ax1.plot(bin_mag, target_moment_per_bin, label='target_moment_per_bin', marker='x')\n                    ax1.plot(bin_mag, moment_rate_in_bin, label='moment_rate_in_bin', marker='x')\n                    ax1.set_yscale('log')\n                    ax1.legend()\n                    plt.savefig(self.pathlog + '/Log_tmp_' + str(self.sample) + '.png', dpi=80, transparent=True)\n                    plt.close()\n            'Pick the bin of magnitude to fill according to the current distribution '\n            target_i = target_i / sum(target_i)\n            picked_bin = np.random.choice(len(bin_mag), 1, p=target_i)[0]\n            mag = bin_mag[picked_bin]\n            tmp = time.time()\n            if not picked_bin in empty_bins:\n                empty_in_bin = set(rup_in_bin[picked_bin]) & set(empty_rups)\n                if len(empty_in_bin) == len(rup_in_bin[picked_bin]):\n                    empty_bins.append(picked_bin)\n            time_checking_empty_bin += time.time() - tmp\n            if not picked_bin in empty_bins:\n                tmp = time.time()\n                'Calculate the weight for sampling of the fault or scenario'\n                do_rup_weight = False\n                if number_of_loops == 1:\n                    do_rup_weight = True\n                if sum_fault_budget < weigthing_built[weigth_rup_sample]:\n                    do_rup_weight = True\n                if do_rup_weight == True:\n                    loop_last_rup_w = number_of_loops\n                    weigth_rup_sample += 1\n                    if faster_rup_weight == True:\n                        list_of_bins = range(len(bin_mag))\n                    else:\n                        list_of_bins = [picked_bin]\n                    w_rup_binmag = []\n                    for index_mag in list_of_bins:\n                        if index_mag in empty_bins:\n                            w_rup_binmag.append([])\n                        else:\n                            weight_rup_i = core_utils.weight_fault_sampling(index_mag, rup_in_bin, faults_names, faults_slip_rates, slip_rate_use_per_fault, faults_alone, scenarios_names, faults_isolated, index_faults_in_scenario, rup_rates, empty_rups)\n                            if local_MFD == True:\n                                factor_on_weight = core_utils.check_local_mfd(rup_rates, rup_in_bin[index_mag], index_mag, bin_mag, local_mfds, associated_rup, associated_weight)\n                                weight_rup_i = np.array([i * w for (i, w) in zip(weight_rup_i, factor_on_weight)])\n                                weight_rup_i /= weight_rup_i.sum()\n                            if sum(weight_rup_i) != 0.0:\n                                weight_rup_i = [float(i) / sum(weight_rup_i) for i in weight_rup_i]\n                            w_rup_binmag.append(weight_rup_i)\n                    time_weight_rupt += time.time() - tmp\n                    tmp = time.time()\n                    for index_mag in list_of_bins:\n                        if not index_mag in empty_bins:\n                            weight_rup = w_rup_binmag[index_mag]\n                            if set(rup_in_bin[index_mag]) & set(empty_rups):\n                                i = 0\n                                for i_rup in rup_in_bin[index_mag]:\n                                    if str(i_rup) in empty_rups:\n                                        weight_rup[i] = 0.0\n                                    i += 1\n                            weight_rup = list(weight_rup)\n                            sum_weight_rup = sum(weight_rup)\n                            if sum(weight_rup) == 0.0:\n                                empty_bins.append(index_mag)\n                            if not index_mag in empty_bins:\n                                if sum_weight_rup != 1.0:\n                                    weight_rup = [float(i) / sum_weight_rup for i in weight_rup]\n                                if math.isnan(sum(weight_rup)):\n                                    print('WARNING : sum rup weight is nan')\n                                    nb_nans = 0\n                                    id = 0\n                                    for i in weight_rup:\n                                        if math.isnan(i):\n                                            nb_nans += 1\n                                        weight_rup[id] = 0.0\n                                        id += 1\n                            w_rup_binmag[index_mag] = weight_rup\n                    time_clean_w_rupt += time.time() - tmp\n                if faster_rup_weight == True:\n                    weight_rup = w_rup_binmag[picked_bin]\n                else:\n                    weight_rup = w_rup_binmag[0]\n                try:\n                    i_picked = np.where(np.random.multinomial(1, weight_rup) == 1)[0][0]\n                    picked_rup = rup_in_bin[picked_bin][i_picked]\n                except ValueError:\n                    print(\"rupt weights didn't work. sum:\", sum(weight_rup))\n                    picked_rup = np.random.choice(rup_in_bin[picked_bin])\n                    n_w_crash += 1\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                if bool_target_set == False:\n                    tmp = time.time()\n                    last_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-3:]:\n                        if not bin_i in empty_bins:\n                            last_bins_empty = False\n                    if last_bins_empty == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        bool_target_set = True\n                        print('set target - limit on the largest magnitudes')\n                    if moment_rate_left <= (1.0 - 1e-05) * moment_rate_required:\n                        self.calculation_log_file.write('\\n Not enough moment left ')\n                        for rup_i in rup_in_bin[-3] + rup_in_bin[-2] + rup_in_bin[-1]:\n                            if not str(rup_i) in empty_rups:\n                                empty_rups.append(str(rup_i))\n                        rup_in_bin[-3] = []\n                        rup_in_bin[-2] = []\n                        rup_in_bin[-1] = []\n                        bool_target_set = True\n                        print('set target - moment rate is limiting')\n                    antelast_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-2:]:\n                        if not bin_i in empty_bins:\n                            antelast_bins_empty = False\n                    if antelast_bins_empty == True and bool_target_set == False:\n                        if moment_rate_in_bin[-3] >= 2.0 * (moment_rate_in_bin[-2] + moment_rate_in_bin[-1]):\n                            self.calculation_log_file.write('\\n antepenultimate bin getting too high')\n                            for rup_i in rup_in_bin[-3]:\n                                if not str(rup_i) in empty_rups:\n                                    empty_rups.append(str(rup_i))\n                            empty_bins.append(range(len(bin_mag))[-3])\n                            bool_target_set = True\n                            print('set target - antepenultimate bin getting too high')\n                    if number_of_loops > number_of_loops_last_checked + 50.0:\n                        number_of_loops_last_checked = number_of_loops\n                        moment_rate_left = Total_moment_faults_rate_init - Total_moment_rate_fault\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        rate_Mmax_check = np.mean(rate_tot_model[-3:])\n                        moment_rate_required = 0.0\n                        for index_mag in range(len(bin_mag) - 3):\n                            rate_Mi_check = rate_tot_model[index_mag]\n                            target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-2]\n                            moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            moment_rate_required = 0.0\n                            for index_mag in range(len(bin_mag) - 3):\n                                rate_Mi_check = rate_tot_model[index_mag]\n                                target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-3]\n                                moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                    time_checking_target_reach += time.time() - tmp\n                    if do_the_target == True and bool_target_set == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        do_the_target = False\n                        print('- target set - ')\n                        self.calculation_log_file.write('\\n- target set - ')\n                        rate_at_target_setting = rate_tot_model\n                        rate_Mmax = np.mean(rate_tot_model[-3:])\n                        TARGET = []\n                        for t_mag_bin in range(len(bin_mag)):\n                            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            TARGET = []\n                            for t_mag_bin in range(len(bin_mag)):\n                                rate_Mi = rate_tot_model[t_mag_bin]\n                                TARGET.append(rate_Mmax * p_MFD[picked_bin] / p_MFD[-3])\n                if picked_bin in bin_target_reached:\n                    print('WHAT ARE YOU DOING HERE?', bin_mag[picked_bin])\n                    exit()\n                ' spending the slip_rate increment '\n                tmp = time.time()\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                sr_to_spend = True\n                shear_mod = 0\n                for index in index_fault:\n                    shear_mod += faults_shear_mod[index]\n                    if faults_budget[index] <= 0.0:\n                        sr_to_spend = False\n                if sr_to_spend == False:\n                    if not str(picked_rup) in empty_rups:\n                        empty_rups.append(str(picked_rup))\n                    else:\n                        picked_empty_rup += 1\n                if sr_to_spend == True:\n                    shear_mod = shear_mod / float(len(index_fault))\n                    area = rup_rates.get(str(picked_rup)).get('area')\n                    displacement = mag_to_M0(mag) / (shear_mod * area)\n                    rate_i = size_of_increment / displacement\n                    if option_fast == True:\n                        min_budget_local = min([faults_budget[i] for i in index_fault])\n                        nb_loop_spending = int(min_budget_local / min_budget)\n                        if nb_loop_spending < 1:\n                            nb_loop_spending = 1\n                    else:\n                        nb_loop_spending = 1\n                    if bool_target_set == True:\n                        rate_Mi = rate_in_model[picked_bin]\n                        target_mfd_i = TARGET[picked_bin] * fault_prop(bin_mag[picked_bin])\n                        if rate_Mi < target_mfd_i:\n                            if uniform_spending == True or len(index_fault) == 1:\n                                moment_rate_i = 0.0\n                                for index in index_fault:\n                                    for loop_spending in range(nb_loop_spending):\n                                        M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                    faults_budget[index] += -1 * nb_loop_spending\n                                    sum_fault_budget += -1 * nb_loop_spending\n                                    slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                                rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                            else:\n                                moment_rate_i = 0.0\n                                for loop_spending in range(nb_loop_spending):\n                                    (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                    rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                    rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                    moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                            moment_rate_in_bin[picked_bin] += moment_rate_i\n                            Total_moment_rate_fault += moment_rate_i\n                        else:\n                            rup_in_bin[picked_bin] = []\n                            if not picked_bin in bin_target_reached:\n                                bin_target_reached.append(picked_bin)\n                    else:\n                        if uniform_spending == True or len(index_fault) == 1:\n                            moment_rate_i = 0.0\n                            for index in index_fault:\n                                for loop_spending in range(nb_loop_spending):\n                                    M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                faults_budget[index] += -1 * nb_loop_spending\n                                sum_fault_budget += -1 * nb_loop_spending\n                                slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                            rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                            rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                            moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                        else:\n                            moment_rate_i = 0.0\n                            for loop_spending in range(nb_loop_spending):\n                                (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                        moment_rate_in_bin[picked_bin] += moment_rate_i\n                        Total_moment_rate_fault += moment_rate_i\n                time_spending_dsr += time.time() - tmp\n            elif not picked_bin in empty_bins:\n                empty_bins.append(picked_bin)\n            tmp = time.time()\n            if number_of_loops > number_of_loops_before + 500:\n                number_of_loops_before = number_of_loops\n                for index_mag in range(len(bin_mag)):\n                    if not index_mag in empty_bins:\n                        nb_rup_not_empty = 0\n                        for i_rup in rup_in_bin[index_mag]:\n                            if nb_rup_not_empty == 0:\n                                rup_is_empty = False\n                                for index_fault in rup_rates.get(str(i_rup)).get('involved_faults'):\n                                    if faults_budget[index_fault] <= 0:\n                                        rup_is_empty = True\n                                if rup_is_empty == False:\n                                    nb_rup_not_empty += 1\n                        if nb_rup_not_empty == 0:\n                            empty_bins.append(index_mag)\n            time_checking_empty_bin += time.time() - tmp\n            tmp = time.time()\n            len_faults_budget.append(sum_fault_budget)\n            if len(len_faults_budget) > 3:\n                if len_faults_budget[-2] == len_faults_budget[-1]:\n                    number_of_loops_for_nothing += 1\n                if number_of_loops_for_nothing_before < number_of_loops_for_nothing - 100:\n                    number_of_loops_for_nothing_before = number_of_loops_for_nothing\n                    if len_faults_budget[-1] == len_faults_budget[-10]:\n                        rup_still_used = [i for i in rup_in_bin[picked_bin] if not i in empty_rups]\n                        fault_still_used = []\n                        for rup_i in rup_still_used:\n                            fault_still_used += list(rup_rates.get(str(rup_i)).get('involved_faults'))\n                        fault_still_used = set(fault_still_used)\n                        for (fault, index_fault) in zip(faults_names, range(len(faults_names))):\n                            if not index_fault in fault_still_used and faults_budget[index_fault] > 0:\n                                while faults_budget[index_fault] > 0:\n                                    ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                                    if ratio_done > 0.01:\n                                        (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                                    faults_budget[index_fault] += -1\n                                    sum_fault_budget += -1\n                                    M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                                    aseismic_count += 1\n            time_checking_empty_faults += time.time() - tmp\n        else:\n            print('-target filled-')\n            self.calculation_log_file.write('\\n-target filled-')\n            while sum_fault_budget != 0:\n                ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                if ratio_done > 0.01:\n                    (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                for index_fault in range(len(faults_names)):\n                    if faults_budget[index_fault] > 0:\n                        faults_budget[index_fault] += -1\n                        sum_fault_budget += -1\n                        M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                        aseismic_count += 1\n    ' check if the TARGET as been set.\\n        if not, build it for comparing'\n    if TARGET == []:\n        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n        print('- target set at the end- ')\n        self.calculation_log_file.write('\\n- target set at the end - ')\n        rate_at_target_setting = rate_tot_model\n        rate_Mmax = np.mean(rate_tot_model[-3:])\n        for t_mag_bin in range(len(bin_mag)):\n            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n    '##################################################################\\n        #\\n        # Definition of the background seismicity\\n        #\\n        ##################################################################'\n    (rate_f_in_model, rate_bg_in_model) = rates.get_rate_faults_n_bg(rup_rates, fault_prop, bin_mag)\n    EQ_rate_BG = rate_bg_in_model\n    '##################################################################\\n        # printing\\n        ##################################################################'\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    model_MFD.append(rate_tot_model)\n    colors = ['gainsboro', 'darkgray', 'dimgray', 'dimgray', 'black', 'red']\n    index_color = 0\n    for MFD_i in model_MFD:\n        plt.plot(bin_mag, MFD_i, color=colors[index_color])\n        index_color += 1\n    if do_the_target == True:\n        rate_at_target_setting = model_MFD[-1]\n    plt.plot(bin_mag, rate_at_target_setting, ':g')\n    plt.plot(bin_mag, TARGET, ':b')\n    plt.scatter(bin_mag[-3:], rate_tot_model[-3:], c='k')\n    plt.yscale('log')\n    plt.savefig(self.pathlog + '/Log_target_fit_' + str(self.sample) + '.png', dpi=180, transparent=True)\n    plt.close()\n    index_5 = 0\n    while bin_mag[index_mag] < 5.0:\n        index_5 += 1\n    self.ratio_test = np.mean([abs(TARGET[index_5 + 0] / rate_tot_model[index_5 + 0]), abs(TARGET[index_5 + 1] / rate_tot_model[index_5 + 1]), abs(TARGET[index_5 + 2] / rate_tot_model[index_5 + 2]), abs(TARGET[index_5 + 3] / rate_tot_model[index_5 + 3]), abs(TARGET[index_5 + 4] / rate_tot_model[index_5 + 4])])\n    MFD_to_test = rate_tot_model / sum(rate_tot_model)\n    target_to_test = TARGET / sum(TARGET)\n    array_absolute_ratio = []\n    for index_mag in range(len(bin_mag)):\n        array_absolute_ratio.append(abs(MFD_to_test[index_mag] / target_to_test[index_mag]))\n    self.ratio_test = np.mean(array_absolute_ratio)\n    print('ratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    self.calculation_log_file.write('\\nratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    '##################################################################\\n        #\\n        # OUTPUT for Source_model_creator\\n        #\\n        ##################################################################'\n    self.OQ_entry_faults = []\n    self.OQ_entry_scenarios = []\n    for i in range(len(faults_names)):\n        self.OQ_entry_faults.append(rup_rates.get(str(i)).get('rates'))\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            self.OQ_entry_scenarios.append(rup_rates.get(str(i_end + j)).get('rates'))\n    self.faults_names = faults_names\n    self.scenarios_names = scenarios_names\n    self.EQ_rate_BG = EQ_rate_BG\n    self.bin_mag = bin_mag\n    self.rup_rates = rup_rates\n    self.M_slip_repartition = M_slip_repartition\n    log_calculation_file.write('Moment_rate_faults_final calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.write('Ratio of NMS slip rate counted in the iterative process: ' + '\\t' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))) + '\\t %\\n')\n    log_calculation_file.write('Moment_rate_model calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.close()\n    self.ratio_NMS = round(100.0 * (1.0 - Total_moment_rate_fault / Total_moment_faults_rate_init))\n    print('ratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    self.calculation_log_file.write('\\nratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    f = open(log_sliprep_file, 'wb')\n    pickle.dump(M_slip_repartition, f)\n    f.close()",
            "def initialize(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    faults_shear_mod = self.faults_shear_mod\n    mfd_param = self.mfd_param\n    M_min = self.M_min\n    Mmax_range = self.Mmax_range\n    inti_core_time = time.time()\n    faults_names = self.faults_names\n    faults_areas = self.faults_area\n    faults_length = self.faults_length\n    faults_width = self.faults_width\n    faults_slip_rates = self.faults_slip_rates\n    log_calculation_file = open(self.pathlog + '/calculation_sample_' + str(self.sample) + '.txt', 'w')\n    log_sliprep_file = self.pathlog + '/sliprep_sample_' + str(self.sample) + '.pkl'\n    re_use = True\n    scenarios_names = self.scenarios\n    run_name = self.Run_Name\n    model_name = self.branch['model']\n    scl_name = self.branch['scl'][0] + '_' + self.branch['scl'][1] + '_' + self.branch['scl'][2]\n    set_name = self.branch['set']\n    f_mmax = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_mmax_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_mmax):\n        re_use = False\n    if re_use == False:\n        print('Building scenarios and Mmax')\n        '##################################################################\\n            # finds the faults belonging to each scenario\\n            ##################################################################'\n        index_faults_in_scenario = []\n        for scenario in scenarios_names:\n            i_scenario = []\n            for i in range(len(scenario)):\n                i_scenario = i_scenario + list(np.where(np.array(faults_names) == scenario['f_%s' % str(i + 1)]))\n            i_scenario = np.reshape(i_scenario, (1, len(scenario)))\n            index_faults_in_scenario.append(i_scenario)\n        self.index_faults_in_scenario = index_faults_in_scenario\n        faults_alone = []\n        faults_isolated = []\n        len_max_section_scenario = 0\n        for indexes in index_faults_in_scenario:\n            if len(indexes[0]) > len_max_section_scenario:\n                len_max_section_scenario = len(indexes[0])\n        index_fault = 0\n        for fault_name in faults_names:\n            fault_alone_bool = True\n            fault_isolated_bool = True\n            for indexes in index_faults_in_scenario:\n                if index_fault in indexes[0]:\n                    fault_alone_bool = False\n                    if len(indexes[0]) > len_max_section_scenario / 2.0:\n                        fault_isolated_bool = False\n            if fault_isolated_bool == True and fault_alone_bool == False:\n                faults_isolated.append(index_fault)\n            if fault_alone_bool == True:\n                faults_alone.append(index_fault)\n            index_fault += 1\n        '##################################################################\\n            # area and length of each scenario\\n            ##################################################################'\n        scenario_area = []\n        index_faults_in_scenario_for_scl = []\n        for indexes_i in index_faults_in_scenario:\n            list_of_points = []\n            index_for_scenario = []\n            for index_fault in indexes_i[0]:\n                list_i = str(self.faults_lon[index_fault][0]) + str(self.faults_lon[index_fault][-1]) + str(self.faults_lat[index_fault][0]) + str(self.faults_lat[index_fault][-1])\n                if not list_i in list_of_points:\n                    list_of_points.append(list_i)\n                    index_for_scenario.append(index_fault)\n            index_faults_in_scenario_for_scl.append(index_for_scenario)\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_area = np.sum(np.take(faults_areas, i))\n            scenario_area.append(scenario_i_area)\n        scenario_length = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_length = np.sum(np.take(faults_length, i))\n            scenario_length.append(scenario_i_length)\n        scenario_width = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_width = np.mean(np.take(faults_width, i))\n            scenario_width.append(scenario_i_width)\n        '\\n            check the max dimention for a single fault according to the\\n            aspect ratio\\n            '\n        (f_len_ar, f_width_ar, f_area_ar) = ([], [], [])\n        ar = self.param['main']['parameters']['aspect_ratio']\n        for (l, w) in zip(self.faults_length, self.faults_width):\n            if l < w * ar:\n                f_len_ar.append(l)\n                f_width_ar.append(l * ar)\n                f_area_ar.append(l * l * ar)\n            else:\n                f_len_ar.append(l)\n                f_width_ar.append(w)\n                f_area_ar.append(l * w)\n        '##################################################################\\n            #####################################################################\\n            #\\n            # setting up the coefficients for the scalling law\\n            # and calculate the Mmax\\n            #\\n            #####################################################################\\n            ##################################################################'\n        Mmaxmin = Mmax_range[0]\n        Mmaxmax = Mmax_range[1]\n        Mmax = -1.0\n        loop_Mmax = 1\n        while Mmax < Mmaxmin or Mmax > Mmaxmax:\n            log_Mmax_file = open(self.param['dirpath'] + run_name + '/LOG/' + model_name + '_Log_Mmax_sample_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.txt', 'w')\n            if loop_Mmax == 1:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, self.sample)\n            else:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, 10)\n            Mmax_faults = Mmaxs.Mmax_faults\n            Mmax_scenario = Mmaxs.Mmax_scenario\n            final_fault_length = Mmaxs.final_fault_length\n            final_scenario_length = Mmaxs.final_scenario_length\n            index_fault = 0\n            for Mmax_i in Mmax_faults:\n                line = faults_names[index_fault] + '\\t' + str(round(faults_length[index_fault] / 1000.0, 1)) + '\\t' + final_fault_length[index_fault] + '\\t' + str(round(self.faults_width[index_fault], 1)) + '\\t' + str(round(self.faults_area[index_fault] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_fault += 1\n            index_scenario = 0\n            for Mmax_i in Mmax_scenario:\n                line = str(scenarios_names[index_scenario]) + '\\t' + str(round(scenario_length[index_scenario] / 1000.0, 1)) + '\\t' + final_scenario_length[index_scenario] + '\\t' + str(round(scenario_width[index_scenario], 1)) + '\\t' + str(round(scenario_area[index_scenario] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_scenario += 1\n            log_Mmax_file.close()\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            loop_Mmax += 1\n            if loop_Mmax == 30:\n                print('An Mmax incompatible with the ruptures is imposed!! Change it in run.info or change the rupture.txt file')\n        if loop_Mmax >= 3:\n            print('Mmax imposed: ' + str(Mmax))\n            self.calculation_log_file.write('\\nMmax imposed: ' + str(Mmax))\n        with open(f_mmax, 'wb') as f:\n            dump_to_file = [Mmax_faults, Mmax_scenario, final_fault_length, final_scenario_length, faults_alone, faults_isolated, index_faults_in_scenario, scenario_area]\n            pickle.dump(dump_to_file, f)\n        print('\\t - scenario and max built')\n    else:\n        print('Reloading Mmax from data file')\n        with open(f_mmax, 'rb') as f:\n            load_from_file = pickle.load(f)\n            Mmax_faults = load_from_file[0]\n            Mmax_scenario = load_from_file[1]\n            final_fault_length = load_from_file[2]\n            final_scenario_length = load_from_file[3]\n            faults_alone = load_from_file[4]\n            faults_isolated = load_from_file[5]\n            index_faults_in_scenario = load_from_file[6]\n            scenario_area = load_from_file[7]\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            print('\\t - scenario and max loaded')\n    '##################################################################\\n        #etablish the magnitude bin (0.1)\\n        ##################################################################'\n    bin_mag = np.linspace(M_min, Mmax, int(round(Mmax - M_min, 1) * 10.0 + 1))\n    '#####################################################################\\n        # initializing incremental reccurence of the earthquakes for each rupture and each bin)\\n        #####################################################################'\n    rup_rates = {}\n    index_rup = []\n    for i in range(len(faults_names)):\n        rup_rates.update({str(i): {'rup_id': i, 'rup_name': faults_names[i], 'involved_faults': [i], 'Mmax': Mmax_faults[i], 'area': faults_areas[i], 'rates': np.zeros(len(bin_mag))}})\n        index_rup.append(i)\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            rup_rates.update({str(i_end + j): {'rup_id': i_end + j, 'rup_name': scenarios_names[j], 'involved_faults': index_faults_in_scenario[j][0], 'Mmax': Mmax_scenario[j], 'area': scenario_area[j], 'rates': np.zeros(len(bin_mag))}})\n            index_rup.append(i_end + j)\n    if str(self.sample) == '1':\n        log_rup_file = open(self.pathlog + '/ruptures.txt', 'w')\n        log_rup_file.write('rup_id\\tinvolved_faults\\n')\n        for i in range(len(rup_rates)):\n            log_rup_file.write(str(rup_rates.get(str(i)).get('rup_id')) + '\\t')\n            for j in rup_rates.get(str(i)).get('involved_faults'):\n                log_rup_file.write(str(j) + ' ')\n            log_rup_file.write('\\n')\n        log_rup_file.close()\n    self.index_faults_in_scenario = index_faults_in_scenario\n    '#####################################################################\\n        # For each bin, find which fault and which scenario populates it.\\n        #####################################################################'\n    f_bin_pop = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_bin_pop_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_bin_pop):\n        re_use = False\n    rup_in_bin = populate_bins.pop(bin_mag, index_rup, rup_rates, M_min, re_use, f_bin_pop)\n    '##################################################################\\n        # Definition of the background - how much is not on the faults\\n        ##################################################################'\n    bin_mag_fault_prop = [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0]\n    fault_prop_inc = self.bg_ratio\n    bin_mag_fault_prop.append(10.0)\n    fault_prop_inc = np.append(np.array(fault_prop_inc), 1.0)\n    fault_prop = interp1d(bin_mag_fault_prop, fault_prop_inc)\n    self.fault_prop = fault_prop\n    '##################################################################\\n        #Calculation of the total moment rate sum(slip-rate)*sum(area) + moment in the background\\n        ##################################################################'\n    Total_moment_faults_rate_init = 0.0\n    index_fault = 0\n    for fault_area in faults_areas:\n        Total_moment_faults_rate_init += faults_shear_mod[index_fault] * fault_area * faults_slip_rates[index_fault]\n        index_fault += 1\n    log_calculation_file.write('Moment_rate_fault_initial calculated using muAs' + '\\t' + str(Total_moment_faults_rate_init) + '\\t' + 'N.m' + '\\n')\n    Total_moment_rate_fault = 0.0\n    '##################################################################\\n        #etablish the target regional distribution\\n        ##################################################################'\n    if self.mfd_hyp == 'GR':\n        p_MFD = mfd_shape.GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'tapered_GR':\n        mfd_param['M_corner'] = Mmax - 0.4\n        p_MFD = mfd_shape.tapered_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'double_GR':\n        p_MFD = mfd_shape.double_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'YC':\n        p_MFD = mfd_shape.YC(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_marmara':\n        p_MFD = mfd_shape.YC_marmara(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_modified':\n        p_MFD = mfd_shape.YC_modified(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'UCERF_DV':\n        p_MFD = mfd_shape.UCERF_DV(bin_mag)\n    else:\n        print('Error : Unknown MFD name!')\n    p_MFD = p_MFD / sum(p_MFD)\n    '##################################################################\\n        # Converting in term of moment\\n        ##################################################################'\n    p_MFD_MO = []\n    index_mag = 0\n    for mag in bin_mag:\n        M0 = mag_to_M0(mag)\n        p_MFD_MO.append(fault_prop(mag) * p_MFD[index_mag] * M0)\n        index_mag += 1\n    p_MFD_MO = p_MFD_MO / sum(p_MFD_MO)\n    '##################################################################\\n        # Adding the moment rate of the background to the Total_moment_rate_init\\n        ##################################################################'\n    Total_moment_rate_init = Total_moment_faults_rate_init\n    index_mag = 0\n    for mag in bin_mag:\n        moment_rate_fault_bin = p_MFD_MO[index_mag] * Total_moment_faults_rate_init\n        moment_rate_BG_bin = (1 - fault_prop(mag)) * moment_rate_fault_bin / fault_prop(mag)\n        Total_moment_rate_init += moment_rate_BG_bin\n        index_mag += 1\n    '##################################################################\\n        # Etablish the target of moment rate per bin\\n        ##################################################################'\n    target_moment_per_bin = p_MFD_MO * Total_moment_faults_rate_init\n    '##################################################################\\n        # Create the sliprate budget dictionary\\n        # This matrix contain a list of the fault name. each name is repeted\\n        # by a number of time depending of the slip-rate of the fault.\\n        ##################################################################'\n    size_of_increment = float(self.size_of_increment) * 0.001\n    if self.count_reruns != 1:\n        size_of_increment = size_of_increment / (float(self.count_reruns) * 1.5 - 1.0)\n    faults_budget = {}\n    for index_fault in range(len(faults_names)):\n        nb_dsr = int(round(faults_slip_rates[index_fault] / size_of_increment, 0))\n        if nb_dsr == 0:\n            nb_dsr = 1\n        faults_budget.update({index_fault: nb_dsr})\n    min_budget = float(min(faults_budget.values())) + 1\n    max_budget = float(max(faults_budget.values()))\n    while max_budget / min_budget > 50.0:\n        min_budget *= 2.0\n    '##################################################################\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        #   Populate the bin of magnitude of each fault and each scenario\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        ##################################################################'\n    M_slip_repartition = {}\n    for (fault, i) in zip(faults_names, range(len(faults_names))):\n        dic_tmp = {}\n        for rup_i in range(len(rup_rates)):\n            if i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                dic_tmp.update({str(rup_i): 0})\n        dic_tmp.update({'NMS': 0})\n        M_slip_repartition.update({str(fault): dic_tmp})\n    moment_rate_in_bin = np.zeros(len(bin_mag))\n    model_MFD = []\n    number_of_loops = 0\n    number_of_loops_before = 0\n    number_of_loops_for_nothing = 0\n    number_of_loops_for_nothing_before = 0\n    number_of_loops_last_checked = -1\n    empty_bins = []\n    empty_rups = []\n    bin_target_reached = []\n    len_faults_budget = []\n    aseismic_count = 0\n    color_mag = []\n    '######################\\n        #####   MAIN LOOP   #####\\n        ######################'\n    TARGET = []\n    nb_ss_to_spend = float(sum(faults_budget.values()))\n    sum_fault_budget = nb_ss_to_spend\n    print('Number of dsr to spend : ' + str(nb_ss_to_spend))\n    print('Min of sdr :', min(faults_budget.values()))\n    print('Max of sdr :', max(faults_budget.values()))\n    self.calculation_log_file.write('\\nnumber of dsr to spend : ' + str(nb_ss_to_spend) + '\\n')\n    print_percent = True\n    do_the_target = True\n    bool_target_set = False\n    uniform_spending = self.param['main']['parameters']['uniform_spending']\n    if uniform_spending in ['True', 'true']:\n        uniform_spending = True\n    else:\n        uniform_spending = False\n    deep_analysis = self.param['main']['parameters']['deep_analysis']\n    if deep_analysis in ['True', 'true']:\n        deep_analysis = True\n    else:\n        deep_analysis = False\n    faster_rup_weight = self.param['main']['parameters']['faster_rup_weight']\n    if faster_rup_weight in ['True', 'true']:\n        faster_rup_weight = True\n    else:\n        faster_rup_weight = False\n    option_fast = self.param['main']['parameters']['option_fast']\n    if option_fast in ['True', 'true']:\n        option_fast = True\n    else:\n        option_fast = False\n    local_MFD = self.param['main']['parameters']['local_MFD']\n    if local_MFD in ['True', 'true']:\n        f_mfd_area = self.param['main']['local_MFD_file']\n        (local_mfds, associated_rup, associated_weight) = core_utils.link_rup_mfd_area(rup_rates, f_mfd_area, self.faults_lon, self.faults_lat, bin_mag, self.bg_ratio)\n    time_weight_rupt = 0.0\n    time_clean_w_rupt = 0.0\n    time_target_building = 0.0\n    time_checking_target_reach = 0.0\n    time_spending_dsr = 0.0\n    time_checking_empty_bin = 0.0\n    time_checking_empty_faults = 0.0\n    budget_init = int(sum_fault_budget)\n    if faster_rup_weight == True:\n        nb_weigthings_rup_sampling = int(self.param['main']['parameters']['nb_weigthings_rup_sampling'])\n        if 'type_weigthings_rup_sampling' in self.param['main']['parameters'].keys():\n            type_weigthings_rup_sampling = self.param['main']['parameters']['type_weigthings_rup_sampling']\n        else:\n            type_weigthings_rup_sampling = 'lin'\n        if type_weigthings_rup_sampling == 'log':\n            weigthing_built = [int(i) for i in np.logspace(0.0, np.log10(budget_init), nb_weigthings_rup_sampling)]\n        if type_weigthings_rup_sampling == 'lin':\n            weigthing_built = [int(i) for i in np.linspace(0.0, budget_init, nb_weigthings_rup_sampling)]\n    else:\n        weigthing_built = [int(i) for i in range(budget_init)]\n    weigthing_built.reverse()\n    weigth_rup_sample = 0\n    slip_rate_use_per_fault = np.zeros(len(faults_names))\n    moment_rate_required = 0.0\n    moment_rate_left = Total_moment_faults_rate_init\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    rate_in_model = np.zeros(len(bin_mag))\n    test_mean_picked = []\n    most_likely_pick = []\n    n_w_work = 0\n    n_w_crash = 0\n    loop_last_rup_w = 0\n    picked_empty_rup = 0\n    old_percent = '0000'\n    while sum_fault_budget > 0:\n        ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n        if ratio_done > 0.01:\n            (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n        number_of_loops += 1\n        if len(empty_bins) != len(bin_mag):\n            ' Calculate the new target shape in each bin in terms of moment rate '\n            tmp = time.time()\n            target_i = target.get_new_target(number_of_loops, moment_rate_in_bin, p_MFD_MO, target_moment_per_bin, bin_mag, empty_bins, bin_target_reached, rup_in_bin)\n            time_target_building += time.time() - tmp\n            if sum(target_i) == 0.0:\n                target_i = p_MFD_MO\n            try:\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            except:\n                print(target_i)\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            if deep_analysis == True:\n                percent = round((1.0 - float(sum_fault_budget) / float(nb_ss_to_spend)) * 100.0)\n                percent = '{:04d}'.format(percent)\n                if percent != old_percent:\n                    old_percent = percent\n                    print('\\nnumber_of_loops', number_of_loops)\n                    print('budget left : ', sum_fault_budget, ' | ', percent, '%')\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time building target at time i : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_weight_rupt)\n                    print('time weighting rupture pick : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_clean_w_rupt)\n                    print('time cleaning weighting rupture weigth : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_target_reach)\n                    print('time checking target reach : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_bin)\n                    print('time checking empty bins : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_faults)\n                    print('time checking empty faults : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time spending dsr : ', time_str)\n                    time_str = core_utils.seconds_to_str(time.time() - inti_core_time)\n                    print('total core time : ', time_str)\n                    tot_core_time = time.time() - inti_core_time\n                    unaccounted_t = tot_core_time - (time_target_building + time_weight_rupt + time_clean_w_rupt + time_checking_target_reach + time_checking_empty_bin + time_checking_empty_faults + time_spending_dsr)\n                    time_str = core_utils.seconds_to_str(unaccounted_t)\n                    print('unaccounted time : ', time_str)\n                    print('max target : ', round(max(target_i), 4), '| last bin w : ', str(round(target_i[-1], 6)))\n                    print('Empty mag bins:')\n                    print(empty_bins)\n                    budget_last_bin = 0\n                    for rup_i in rup_in_bin[-1]:\n                        if not str(rup_i) in empty_rups:\n                            for f_i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                                budget_last_bin += faults_budget[f_i]\n                    print('fault budget last bin :', budget_last_bin)\n                    (fig, (ax0, ax1)) = plt.subplots(ncols=2)\n                    ax0.plot(bin_mag, target_i, label='target_i', marker='x')\n                    ax0.plot(bin_mag, p_MFD_MO, label='p_MFD_MO', marker='x')\n                    ax0.legend()\n                    ax1.plot(bin_mag, target_moment_per_bin, label='target_moment_per_bin', marker='x')\n                    ax1.plot(bin_mag, moment_rate_in_bin, label='moment_rate_in_bin', marker='x')\n                    ax1.set_yscale('log')\n                    ax1.legend()\n                    plt.savefig(self.pathlog + '/Log_tmp_' + str(self.sample) + '.png', dpi=80, transparent=True)\n                    plt.close()\n            'Pick the bin of magnitude to fill according to the current distribution '\n            target_i = target_i / sum(target_i)\n            picked_bin = np.random.choice(len(bin_mag), 1, p=target_i)[0]\n            mag = bin_mag[picked_bin]\n            tmp = time.time()\n            if not picked_bin in empty_bins:\n                empty_in_bin = set(rup_in_bin[picked_bin]) & set(empty_rups)\n                if len(empty_in_bin) == len(rup_in_bin[picked_bin]):\n                    empty_bins.append(picked_bin)\n            time_checking_empty_bin += time.time() - tmp\n            if not picked_bin in empty_bins:\n                tmp = time.time()\n                'Calculate the weight for sampling of the fault or scenario'\n                do_rup_weight = False\n                if number_of_loops == 1:\n                    do_rup_weight = True\n                if sum_fault_budget < weigthing_built[weigth_rup_sample]:\n                    do_rup_weight = True\n                if do_rup_weight == True:\n                    loop_last_rup_w = number_of_loops\n                    weigth_rup_sample += 1\n                    if faster_rup_weight == True:\n                        list_of_bins = range(len(bin_mag))\n                    else:\n                        list_of_bins = [picked_bin]\n                    w_rup_binmag = []\n                    for index_mag in list_of_bins:\n                        if index_mag in empty_bins:\n                            w_rup_binmag.append([])\n                        else:\n                            weight_rup_i = core_utils.weight_fault_sampling(index_mag, rup_in_bin, faults_names, faults_slip_rates, slip_rate_use_per_fault, faults_alone, scenarios_names, faults_isolated, index_faults_in_scenario, rup_rates, empty_rups)\n                            if local_MFD == True:\n                                factor_on_weight = core_utils.check_local_mfd(rup_rates, rup_in_bin[index_mag], index_mag, bin_mag, local_mfds, associated_rup, associated_weight)\n                                weight_rup_i = np.array([i * w for (i, w) in zip(weight_rup_i, factor_on_weight)])\n                                weight_rup_i /= weight_rup_i.sum()\n                            if sum(weight_rup_i) != 0.0:\n                                weight_rup_i = [float(i) / sum(weight_rup_i) for i in weight_rup_i]\n                            w_rup_binmag.append(weight_rup_i)\n                    time_weight_rupt += time.time() - tmp\n                    tmp = time.time()\n                    for index_mag in list_of_bins:\n                        if not index_mag in empty_bins:\n                            weight_rup = w_rup_binmag[index_mag]\n                            if set(rup_in_bin[index_mag]) & set(empty_rups):\n                                i = 0\n                                for i_rup in rup_in_bin[index_mag]:\n                                    if str(i_rup) in empty_rups:\n                                        weight_rup[i] = 0.0\n                                    i += 1\n                            weight_rup = list(weight_rup)\n                            sum_weight_rup = sum(weight_rup)\n                            if sum(weight_rup) == 0.0:\n                                empty_bins.append(index_mag)\n                            if not index_mag in empty_bins:\n                                if sum_weight_rup != 1.0:\n                                    weight_rup = [float(i) / sum_weight_rup for i in weight_rup]\n                                if math.isnan(sum(weight_rup)):\n                                    print('WARNING : sum rup weight is nan')\n                                    nb_nans = 0\n                                    id = 0\n                                    for i in weight_rup:\n                                        if math.isnan(i):\n                                            nb_nans += 1\n                                        weight_rup[id] = 0.0\n                                        id += 1\n                            w_rup_binmag[index_mag] = weight_rup\n                    time_clean_w_rupt += time.time() - tmp\n                if faster_rup_weight == True:\n                    weight_rup = w_rup_binmag[picked_bin]\n                else:\n                    weight_rup = w_rup_binmag[0]\n                try:\n                    i_picked = np.where(np.random.multinomial(1, weight_rup) == 1)[0][0]\n                    picked_rup = rup_in_bin[picked_bin][i_picked]\n                except ValueError:\n                    print(\"rupt weights didn't work. sum:\", sum(weight_rup))\n                    picked_rup = np.random.choice(rup_in_bin[picked_bin])\n                    n_w_crash += 1\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                if bool_target_set == False:\n                    tmp = time.time()\n                    last_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-3:]:\n                        if not bin_i in empty_bins:\n                            last_bins_empty = False\n                    if last_bins_empty == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        bool_target_set = True\n                        print('set target - limit on the largest magnitudes')\n                    if moment_rate_left <= (1.0 - 1e-05) * moment_rate_required:\n                        self.calculation_log_file.write('\\n Not enough moment left ')\n                        for rup_i in rup_in_bin[-3] + rup_in_bin[-2] + rup_in_bin[-1]:\n                            if not str(rup_i) in empty_rups:\n                                empty_rups.append(str(rup_i))\n                        rup_in_bin[-3] = []\n                        rup_in_bin[-2] = []\n                        rup_in_bin[-1] = []\n                        bool_target_set = True\n                        print('set target - moment rate is limiting')\n                    antelast_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-2:]:\n                        if not bin_i in empty_bins:\n                            antelast_bins_empty = False\n                    if antelast_bins_empty == True and bool_target_set == False:\n                        if moment_rate_in_bin[-3] >= 2.0 * (moment_rate_in_bin[-2] + moment_rate_in_bin[-1]):\n                            self.calculation_log_file.write('\\n antepenultimate bin getting too high')\n                            for rup_i in rup_in_bin[-3]:\n                                if not str(rup_i) in empty_rups:\n                                    empty_rups.append(str(rup_i))\n                            empty_bins.append(range(len(bin_mag))[-3])\n                            bool_target_set = True\n                            print('set target - antepenultimate bin getting too high')\n                    if number_of_loops > number_of_loops_last_checked + 50.0:\n                        number_of_loops_last_checked = number_of_loops\n                        moment_rate_left = Total_moment_faults_rate_init - Total_moment_rate_fault\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        rate_Mmax_check = np.mean(rate_tot_model[-3:])\n                        moment_rate_required = 0.0\n                        for index_mag in range(len(bin_mag) - 3):\n                            rate_Mi_check = rate_tot_model[index_mag]\n                            target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-2]\n                            moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            moment_rate_required = 0.0\n                            for index_mag in range(len(bin_mag) - 3):\n                                rate_Mi_check = rate_tot_model[index_mag]\n                                target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-3]\n                                moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                    time_checking_target_reach += time.time() - tmp\n                    if do_the_target == True and bool_target_set == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        do_the_target = False\n                        print('- target set - ')\n                        self.calculation_log_file.write('\\n- target set - ')\n                        rate_at_target_setting = rate_tot_model\n                        rate_Mmax = np.mean(rate_tot_model[-3:])\n                        TARGET = []\n                        for t_mag_bin in range(len(bin_mag)):\n                            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            TARGET = []\n                            for t_mag_bin in range(len(bin_mag)):\n                                rate_Mi = rate_tot_model[t_mag_bin]\n                                TARGET.append(rate_Mmax * p_MFD[picked_bin] / p_MFD[-3])\n                if picked_bin in bin_target_reached:\n                    print('WHAT ARE YOU DOING HERE?', bin_mag[picked_bin])\n                    exit()\n                ' spending the slip_rate increment '\n                tmp = time.time()\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                sr_to_spend = True\n                shear_mod = 0\n                for index in index_fault:\n                    shear_mod += faults_shear_mod[index]\n                    if faults_budget[index] <= 0.0:\n                        sr_to_spend = False\n                if sr_to_spend == False:\n                    if not str(picked_rup) in empty_rups:\n                        empty_rups.append(str(picked_rup))\n                    else:\n                        picked_empty_rup += 1\n                if sr_to_spend == True:\n                    shear_mod = shear_mod / float(len(index_fault))\n                    area = rup_rates.get(str(picked_rup)).get('area')\n                    displacement = mag_to_M0(mag) / (shear_mod * area)\n                    rate_i = size_of_increment / displacement\n                    if option_fast == True:\n                        min_budget_local = min([faults_budget[i] for i in index_fault])\n                        nb_loop_spending = int(min_budget_local / min_budget)\n                        if nb_loop_spending < 1:\n                            nb_loop_spending = 1\n                    else:\n                        nb_loop_spending = 1\n                    if bool_target_set == True:\n                        rate_Mi = rate_in_model[picked_bin]\n                        target_mfd_i = TARGET[picked_bin] * fault_prop(bin_mag[picked_bin])\n                        if rate_Mi < target_mfd_i:\n                            if uniform_spending == True or len(index_fault) == 1:\n                                moment_rate_i = 0.0\n                                for index in index_fault:\n                                    for loop_spending in range(nb_loop_spending):\n                                        M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                    faults_budget[index] += -1 * nb_loop_spending\n                                    sum_fault_budget += -1 * nb_loop_spending\n                                    slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                                rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                            else:\n                                moment_rate_i = 0.0\n                                for loop_spending in range(nb_loop_spending):\n                                    (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                    rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                    rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                    moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                            moment_rate_in_bin[picked_bin] += moment_rate_i\n                            Total_moment_rate_fault += moment_rate_i\n                        else:\n                            rup_in_bin[picked_bin] = []\n                            if not picked_bin in bin_target_reached:\n                                bin_target_reached.append(picked_bin)\n                    else:\n                        if uniform_spending == True or len(index_fault) == 1:\n                            moment_rate_i = 0.0\n                            for index in index_fault:\n                                for loop_spending in range(nb_loop_spending):\n                                    M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                faults_budget[index] += -1 * nb_loop_spending\n                                sum_fault_budget += -1 * nb_loop_spending\n                                slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                            rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                            rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                            moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                        else:\n                            moment_rate_i = 0.0\n                            for loop_spending in range(nb_loop_spending):\n                                (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                        moment_rate_in_bin[picked_bin] += moment_rate_i\n                        Total_moment_rate_fault += moment_rate_i\n                time_spending_dsr += time.time() - tmp\n            elif not picked_bin in empty_bins:\n                empty_bins.append(picked_bin)\n            tmp = time.time()\n            if number_of_loops > number_of_loops_before + 500:\n                number_of_loops_before = number_of_loops\n                for index_mag in range(len(bin_mag)):\n                    if not index_mag in empty_bins:\n                        nb_rup_not_empty = 0\n                        for i_rup in rup_in_bin[index_mag]:\n                            if nb_rup_not_empty == 0:\n                                rup_is_empty = False\n                                for index_fault in rup_rates.get(str(i_rup)).get('involved_faults'):\n                                    if faults_budget[index_fault] <= 0:\n                                        rup_is_empty = True\n                                if rup_is_empty == False:\n                                    nb_rup_not_empty += 1\n                        if nb_rup_not_empty == 0:\n                            empty_bins.append(index_mag)\n            time_checking_empty_bin += time.time() - tmp\n            tmp = time.time()\n            len_faults_budget.append(sum_fault_budget)\n            if len(len_faults_budget) > 3:\n                if len_faults_budget[-2] == len_faults_budget[-1]:\n                    number_of_loops_for_nothing += 1\n                if number_of_loops_for_nothing_before < number_of_loops_for_nothing - 100:\n                    number_of_loops_for_nothing_before = number_of_loops_for_nothing\n                    if len_faults_budget[-1] == len_faults_budget[-10]:\n                        rup_still_used = [i for i in rup_in_bin[picked_bin] if not i in empty_rups]\n                        fault_still_used = []\n                        for rup_i in rup_still_used:\n                            fault_still_used += list(rup_rates.get(str(rup_i)).get('involved_faults'))\n                        fault_still_used = set(fault_still_used)\n                        for (fault, index_fault) in zip(faults_names, range(len(faults_names))):\n                            if not index_fault in fault_still_used and faults_budget[index_fault] > 0:\n                                while faults_budget[index_fault] > 0:\n                                    ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                                    if ratio_done > 0.01:\n                                        (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                                    faults_budget[index_fault] += -1\n                                    sum_fault_budget += -1\n                                    M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                                    aseismic_count += 1\n            time_checking_empty_faults += time.time() - tmp\n        else:\n            print('-target filled-')\n            self.calculation_log_file.write('\\n-target filled-')\n            while sum_fault_budget != 0:\n                ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                if ratio_done > 0.01:\n                    (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                for index_fault in range(len(faults_names)):\n                    if faults_budget[index_fault] > 0:\n                        faults_budget[index_fault] += -1\n                        sum_fault_budget += -1\n                        M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                        aseismic_count += 1\n    ' check if the TARGET as been set.\\n        if not, build it for comparing'\n    if TARGET == []:\n        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n        print('- target set at the end- ')\n        self.calculation_log_file.write('\\n- target set at the end - ')\n        rate_at_target_setting = rate_tot_model\n        rate_Mmax = np.mean(rate_tot_model[-3:])\n        for t_mag_bin in range(len(bin_mag)):\n            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n    '##################################################################\\n        #\\n        # Definition of the background seismicity\\n        #\\n        ##################################################################'\n    (rate_f_in_model, rate_bg_in_model) = rates.get_rate_faults_n_bg(rup_rates, fault_prop, bin_mag)\n    EQ_rate_BG = rate_bg_in_model\n    '##################################################################\\n        # printing\\n        ##################################################################'\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    model_MFD.append(rate_tot_model)\n    colors = ['gainsboro', 'darkgray', 'dimgray', 'dimgray', 'black', 'red']\n    index_color = 0\n    for MFD_i in model_MFD:\n        plt.plot(bin_mag, MFD_i, color=colors[index_color])\n        index_color += 1\n    if do_the_target == True:\n        rate_at_target_setting = model_MFD[-1]\n    plt.plot(bin_mag, rate_at_target_setting, ':g')\n    plt.plot(bin_mag, TARGET, ':b')\n    plt.scatter(bin_mag[-3:], rate_tot_model[-3:], c='k')\n    plt.yscale('log')\n    plt.savefig(self.pathlog + '/Log_target_fit_' + str(self.sample) + '.png', dpi=180, transparent=True)\n    plt.close()\n    index_5 = 0\n    while bin_mag[index_mag] < 5.0:\n        index_5 += 1\n    self.ratio_test = np.mean([abs(TARGET[index_5 + 0] / rate_tot_model[index_5 + 0]), abs(TARGET[index_5 + 1] / rate_tot_model[index_5 + 1]), abs(TARGET[index_5 + 2] / rate_tot_model[index_5 + 2]), abs(TARGET[index_5 + 3] / rate_tot_model[index_5 + 3]), abs(TARGET[index_5 + 4] / rate_tot_model[index_5 + 4])])\n    MFD_to_test = rate_tot_model / sum(rate_tot_model)\n    target_to_test = TARGET / sum(TARGET)\n    array_absolute_ratio = []\n    for index_mag in range(len(bin_mag)):\n        array_absolute_ratio.append(abs(MFD_to_test[index_mag] / target_to_test[index_mag]))\n    self.ratio_test = np.mean(array_absolute_ratio)\n    print('ratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    self.calculation_log_file.write('\\nratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    '##################################################################\\n        #\\n        # OUTPUT for Source_model_creator\\n        #\\n        ##################################################################'\n    self.OQ_entry_faults = []\n    self.OQ_entry_scenarios = []\n    for i in range(len(faults_names)):\n        self.OQ_entry_faults.append(rup_rates.get(str(i)).get('rates'))\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            self.OQ_entry_scenarios.append(rup_rates.get(str(i_end + j)).get('rates'))\n    self.faults_names = faults_names\n    self.scenarios_names = scenarios_names\n    self.EQ_rate_BG = EQ_rate_BG\n    self.bin_mag = bin_mag\n    self.rup_rates = rup_rates\n    self.M_slip_repartition = M_slip_repartition\n    log_calculation_file.write('Moment_rate_faults_final calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.write('Ratio of NMS slip rate counted in the iterative process: ' + '\\t' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))) + '\\t %\\n')\n    log_calculation_file.write('Moment_rate_model calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.close()\n    self.ratio_NMS = round(100.0 * (1.0 - Total_moment_rate_fault / Total_moment_faults_rate_init))\n    print('ratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    self.calculation_log_file.write('\\nratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    f = open(log_sliprep_file, 'wb')\n    pickle.dump(M_slip_repartition, f)\n    f.close()",
            "def initialize(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    faults_shear_mod = self.faults_shear_mod\n    mfd_param = self.mfd_param\n    M_min = self.M_min\n    Mmax_range = self.Mmax_range\n    inti_core_time = time.time()\n    faults_names = self.faults_names\n    faults_areas = self.faults_area\n    faults_length = self.faults_length\n    faults_width = self.faults_width\n    faults_slip_rates = self.faults_slip_rates\n    log_calculation_file = open(self.pathlog + '/calculation_sample_' + str(self.sample) + '.txt', 'w')\n    log_sliprep_file = self.pathlog + '/sliprep_sample_' + str(self.sample) + '.pkl'\n    re_use = True\n    scenarios_names = self.scenarios\n    run_name = self.Run_Name\n    model_name = self.branch['model']\n    scl_name = self.branch['scl'][0] + '_' + self.branch['scl'][1] + '_' + self.branch['scl'][2]\n    set_name = self.branch['set']\n    f_mmax = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_mmax_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_mmax):\n        re_use = False\n    if re_use == False:\n        print('Building scenarios and Mmax')\n        '##################################################################\\n            # finds the faults belonging to each scenario\\n            ##################################################################'\n        index_faults_in_scenario = []\n        for scenario in scenarios_names:\n            i_scenario = []\n            for i in range(len(scenario)):\n                i_scenario = i_scenario + list(np.where(np.array(faults_names) == scenario['f_%s' % str(i + 1)]))\n            i_scenario = np.reshape(i_scenario, (1, len(scenario)))\n            index_faults_in_scenario.append(i_scenario)\n        self.index_faults_in_scenario = index_faults_in_scenario\n        faults_alone = []\n        faults_isolated = []\n        len_max_section_scenario = 0\n        for indexes in index_faults_in_scenario:\n            if len(indexes[0]) > len_max_section_scenario:\n                len_max_section_scenario = len(indexes[0])\n        index_fault = 0\n        for fault_name in faults_names:\n            fault_alone_bool = True\n            fault_isolated_bool = True\n            for indexes in index_faults_in_scenario:\n                if index_fault in indexes[0]:\n                    fault_alone_bool = False\n                    if len(indexes[0]) > len_max_section_scenario / 2.0:\n                        fault_isolated_bool = False\n            if fault_isolated_bool == True and fault_alone_bool == False:\n                faults_isolated.append(index_fault)\n            if fault_alone_bool == True:\n                faults_alone.append(index_fault)\n            index_fault += 1\n        '##################################################################\\n            # area and length of each scenario\\n            ##################################################################'\n        scenario_area = []\n        index_faults_in_scenario_for_scl = []\n        for indexes_i in index_faults_in_scenario:\n            list_of_points = []\n            index_for_scenario = []\n            for index_fault in indexes_i[0]:\n                list_i = str(self.faults_lon[index_fault][0]) + str(self.faults_lon[index_fault][-1]) + str(self.faults_lat[index_fault][0]) + str(self.faults_lat[index_fault][-1])\n                if not list_i in list_of_points:\n                    list_of_points.append(list_i)\n                    index_for_scenario.append(index_fault)\n            index_faults_in_scenario_for_scl.append(index_for_scenario)\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_area = np.sum(np.take(faults_areas, i))\n            scenario_area.append(scenario_i_area)\n        scenario_length = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_length = np.sum(np.take(faults_length, i))\n            scenario_length.append(scenario_i_length)\n        scenario_width = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_width = np.mean(np.take(faults_width, i))\n            scenario_width.append(scenario_i_width)\n        '\\n            check the max dimention for a single fault according to the\\n            aspect ratio\\n            '\n        (f_len_ar, f_width_ar, f_area_ar) = ([], [], [])\n        ar = self.param['main']['parameters']['aspect_ratio']\n        for (l, w) in zip(self.faults_length, self.faults_width):\n            if l < w * ar:\n                f_len_ar.append(l)\n                f_width_ar.append(l * ar)\n                f_area_ar.append(l * l * ar)\n            else:\n                f_len_ar.append(l)\n                f_width_ar.append(w)\n                f_area_ar.append(l * w)\n        '##################################################################\\n            #####################################################################\\n            #\\n            # setting up the coefficients for the scalling law\\n            # and calculate the Mmax\\n            #\\n            #####################################################################\\n            ##################################################################'\n        Mmaxmin = Mmax_range[0]\n        Mmaxmax = Mmax_range[1]\n        Mmax = -1.0\n        loop_Mmax = 1\n        while Mmax < Mmaxmin or Mmax > Mmaxmax:\n            log_Mmax_file = open(self.param['dirpath'] + run_name + '/LOG/' + model_name + '_Log_Mmax_sample_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.txt', 'w')\n            if loop_Mmax == 1:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, self.sample)\n            else:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, 10)\n            Mmax_faults = Mmaxs.Mmax_faults\n            Mmax_scenario = Mmaxs.Mmax_scenario\n            final_fault_length = Mmaxs.final_fault_length\n            final_scenario_length = Mmaxs.final_scenario_length\n            index_fault = 0\n            for Mmax_i in Mmax_faults:\n                line = faults_names[index_fault] + '\\t' + str(round(faults_length[index_fault] / 1000.0, 1)) + '\\t' + final_fault_length[index_fault] + '\\t' + str(round(self.faults_width[index_fault], 1)) + '\\t' + str(round(self.faults_area[index_fault] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_fault += 1\n            index_scenario = 0\n            for Mmax_i in Mmax_scenario:\n                line = str(scenarios_names[index_scenario]) + '\\t' + str(round(scenario_length[index_scenario] / 1000.0, 1)) + '\\t' + final_scenario_length[index_scenario] + '\\t' + str(round(scenario_width[index_scenario], 1)) + '\\t' + str(round(scenario_area[index_scenario] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_scenario += 1\n            log_Mmax_file.close()\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            loop_Mmax += 1\n            if loop_Mmax == 30:\n                print('An Mmax incompatible with the ruptures is imposed!! Change it in run.info or change the rupture.txt file')\n        if loop_Mmax >= 3:\n            print('Mmax imposed: ' + str(Mmax))\n            self.calculation_log_file.write('\\nMmax imposed: ' + str(Mmax))\n        with open(f_mmax, 'wb') as f:\n            dump_to_file = [Mmax_faults, Mmax_scenario, final_fault_length, final_scenario_length, faults_alone, faults_isolated, index_faults_in_scenario, scenario_area]\n            pickle.dump(dump_to_file, f)\n        print('\\t - scenario and max built')\n    else:\n        print('Reloading Mmax from data file')\n        with open(f_mmax, 'rb') as f:\n            load_from_file = pickle.load(f)\n            Mmax_faults = load_from_file[0]\n            Mmax_scenario = load_from_file[1]\n            final_fault_length = load_from_file[2]\n            final_scenario_length = load_from_file[3]\n            faults_alone = load_from_file[4]\n            faults_isolated = load_from_file[5]\n            index_faults_in_scenario = load_from_file[6]\n            scenario_area = load_from_file[7]\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            print('\\t - scenario and max loaded')\n    '##################################################################\\n        #etablish the magnitude bin (0.1)\\n        ##################################################################'\n    bin_mag = np.linspace(M_min, Mmax, int(round(Mmax - M_min, 1) * 10.0 + 1))\n    '#####################################################################\\n        # initializing incremental reccurence of the earthquakes for each rupture and each bin)\\n        #####################################################################'\n    rup_rates = {}\n    index_rup = []\n    for i in range(len(faults_names)):\n        rup_rates.update({str(i): {'rup_id': i, 'rup_name': faults_names[i], 'involved_faults': [i], 'Mmax': Mmax_faults[i], 'area': faults_areas[i], 'rates': np.zeros(len(bin_mag))}})\n        index_rup.append(i)\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            rup_rates.update({str(i_end + j): {'rup_id': i_end + j, 'rup_name': scenarios_names[j], 'involved_faults': index_faults_in_scenario[j][0], 'Mmax': Mmax_scenario[j], 'area': scenario_area[j], 'rates': np.zeros(len(bin_mag))}})\n            index_rup.append(i_end + j)\n    if str(self.sample) == '1':\n        log_rup_file = open(self.pathlog + '/ruptures.txt', 'w')\n        log_rup_file.write('rup_id\\tinvolved_faults\\n')\n        for i in range(len(rup_rates)):\n            log_rup_file.write(str(rup_rates.get(str(i)).get('rup_id')) + '\\t')\n            for j in rup_rates.get(str(i)).get('involved_faults'):\n                log_rup_file.write(str(j) + ' ')\n            log_rup_file.write('\\n')\n        log_rup_file.close()\n    self.index_faults_in_scenario = index_faults_in_scenario\n    '#####################################################################\\n        # For each bin, find which fault and which scenario populates it.\\n        #####################################################################'\n    f_bin_pop = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_bin_pop_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_bin_pop):\n        re_use = False\n    rup_in_bin = populate_bins.pop(bin_mag, index_rup, rup_rates, M_min, re_use, f_bin_pop)\n    '##################################################################\\n        # Definition of the background - how much is not on the faults\\n        ##################################################################'\n    bin_mag_fault_prop = [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0]\n    fault_prop_inc = self.bg_ratio\n    bin_mag_fault_prop.append(10.0)\n    fault_prop_inc = np.append(np.array(fault_prop_inc), 1.0)\n    fault_prop = interp1d(bin_mag_fault_prop, fault_prop_inc)\n    self.fault_prop = fault_prop\n    '##################################################################\\n        #Calculation of the total moment rate sum(slip-rate)*sum(area) + moment in the background\\n        ##################################################################'\n    Total_moment_faults_rate_init = 0.0\n    index_fault = 0\n    for fault_area in faults_areas:\n        Total_moment_faults_rate_init += faults_shear_mod[index_fault] * fault_area * faults_slip_rates[index_fault]\n        index_fault += 1\n    log_calculation_file.write('Moment_rate_fault_initial calculated using muAs' + '\\t' + str(Total_moment_faults_rate_init) + '\\t' + 'N.m' + '\\n')\n    Total_moment_rate_fault = 0.0\n    '##################################################################\\n        #etablish the target regional distribution\\n        ##################################################################'\n    if self.mfd_hyp == 'GR':\n        p_MFD = mfd_shape.GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'tapered_GR':\n        mfd_param['M_corner'] = Mmax - 0.4\n        p_MFD = mfd_shape.tapered_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'double_GR':\n        p_MFD = mfd_shape.double_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'YC':\n        p_MFD = mfd_shape.YC(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_marmara':\n        p_MFD = mfd_shape.YC_marmara(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_modified':\n        p_MFD = mfd_shape.YC_modified(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'UCERF_DV':\n        p_MFD = mfd_shape.UCERF_DV(bin_mag)\n    else:\n        print('Error : Unknown MFD name!')\n    p_MFD = p_MFD / sum(p_MFD)\n    '##################################################################\\n        # Converting in term of moment\\n        ##################################################################'\n    p_MFD_MO = []\n    index_mag = 0\n    for mag in bin_mag:\n        M0 = mag_to_M0(mag)\n        p_MFD_MO.append(fault_prop(mag) * p_MFD[index_mag] * M0)\n        index_mag += 1\n    p_MFD_MO = p_MFD_MO / sum(p_MFD_MO)\n    '##################################################################\\n        # Adding the moment rate of the background to the Total_moment_rate_init\\n        ##################################################################'\n    Total_moment_rate_init = Total_moment_faults_rate_init\n    index_mag = 0\n    for mag in bin_mag:\n        moment_rate_fault_bin = p_MFD_MO[index_mag] * Total_moment_faults_rate_init\n        moment_rate_BG_bin = (1 - fault_prop(mag)) * moment_rate_fault_bin / fault_prop(mag)\n        Total_moment_rate_init += moment_rate_BG_bin\n        index_mag += 1\n    '##################################################################\\n        # Etablish the target of moment rate per bin\\n        ##################################################################'\n    target_moment_per_bin = p_MFD_MO * Total_moment_faults_rate_init\n    '##################################################################\\n        # Create the sliprate budget dictionary\\n        # This matrix contain a list of the fault name. each name is repeted\\n        # by a number of time depending of the slip-rate of the fault.\\n        ##################################################################'\n    size_of_increment = float(self.size_of_increment) * 0.001\n    if self.count_reruns != 1:\n        size_of_increment = size_of_increment / (float(self.count_reruns) * 1.5 - 1.0)\n    faults_budget = {}\n    for index_fault in range(len(faults_names)):\n        nb_dsr = int(round(faults_slip_rates[index_fault] / size_of_increment, 0))\n        if nb_dsr == 0:\n            nb_dsr = 1\n        faults_budget.update({index_fault: nb_dsr})\n    min_budget = float(min(faults_budget.values())) + 1\n    max_budget = float(max(faults_budget.values()))\n    while max_budget / min_budget > 50.0:\n        min_budget *= 2.0\n    '##################################################################\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        #   Populate the bin of magnitude of each fault and each scenario\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        ##################################################################'\n    M_slip_repartition = {}\n    for (fault, i) in zip(faults_names, range(len(faults_names))):\n        dic_tmp = {}\n        for rup_i in range(len(rup_rates)):\n            if i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                dic_tmp.update({str(rup_i): 0})\n        dic_tmp.update({'NMS': 0})\n        M_slip_repartition.update({str(fault): dic_tmp})\n    moment_rate_in_bin = np.zeros(len(bin_mag))\n    model_MFD = []\n    number_of_loops = 0\n    number_of_loops_before = 0\n    number_of_loops_for_nothing = 0\n    number_of_loops_for_nothing_before = 0\n    number_of_loops_last_checked = -1\n    empty_bins = []\n    empty_rups = []\n    bin_target_reached = []\n    len_faults_budget = []\n    aseismic_count = 0\n    color_mag = []\n    '######################\\n        #####   MAIN LOOP   #####\\n        ######################'\n    TARGET = []\n    nb_ss_to_spend = float(sum(faults_budget.values()))\n    sum_fault_budget = nb_ss_to_spend\n    print('Number of dsr to spend : ' + str(nb_ss_to_spend))\n    print('Min of sdr :', min(faults_budget.values()))\n    print('Max of sdr :', max(faults_budget.values()))\n    self.calculation_log_file.write('\\nnumber of dsr to spend : ' + str(nb_ss_to_spend) + '\\n')\n    print_percent = True\n    do_the_target = True\n    bool_target_set = False\n    uniform_spending = self.param['main']['parameters']['uniform_spending']\n    if uniform_spending in ['True', 'true']:\n        uniform_spending = True\n    else:\n        uniform_spending = False\n    deep_analysis = self.param['main']['parameters']['deep_analysis']\n    if deep_analysis in ['True', 'true']:\n        deep_analysis = True\n    else:\n        deep_analysis = False\n    faster_rup_weight = self.param['main']['parameters']['faster_rup_weight']\n    if faster_rup_weight in ['True', 'true']:\n        faster_rup_weight = True\n    else:\n        faster_rup_weight = False\n    option_fast = self.param['main']['parameters']['option_fast']\n    if option_fast in ['True', 'true']:\n        option_fast = True\n    else:\n        option_fast = False\n    local_MFD = self.param['main']['parameters']['local_MFD']\n    if local_MFD in ['True', 'true']:\n        f_mfd_area = self.param['main']['local_MFD_file']\n        (local_mfds, associated_rup, associated_weight) = core_utils.link_rup_mfd_area(rup_rates, f_mfd_area, self.faults_lon, self.faults_lat, bin_mag, self.bg_ratio)\n    time_weight_rupt = 0.0\n    time_clean_w_rupt = 0.0\n    time_target_building = 0.0\n    time_checking_target_reach = 0.0\n    time_spending_dsr = 0.0\n    time_checking_empty_bin = 0.0\n    time_checking_empty_faults = 0.0\n    budget_init = int(sum_fault_budget)\n    if faster_rup_weight == True:\n        nb_weigthings_rup_sampling = int(self.param['main']['parameters']['nb_weigthings_rup_sampling'])\n        if 'type_weigthings_rup_sampling' in self.param['main']['parameters'].keys():\n            type_weigthings_rup_sampling = self.param['main']['parameters']['type_weigthings_rup_sampling']\n        else:\n            type_weigthings_rup_sampling = 'lin'\n        if type_weigthings_rup_sampling == 'log':\n            weigthing_built = [int(i) for i in np.logspace(0.0, np.log10(budget_init), nb_weigthings_rup_sampling)]\n        if type_weigthings_rup_sampling == 'lin':\n            weigthing_built = [int(i) for i in np.linspace(0.0, budget_init, nb_weigthings_rup_sampling)]\n    else:\n        weigthing_built = [int(i) for i in range(budget_init)]\n    weigthing_built.reverse()\n    weigth_rup_sample = 0\n    slip_rate_use_per_fault = np.zeros(len(faults_names))\n    moment_rate_required = 0.0\n    moment_rate_left = Total_moment_faults_rate_init\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    rate_in_model = np.zeros(len(bin_mag))\n    test_mean_picked = []\n    most_likely_pick = []\n    n_w_work = 0\n    n_w_crash = 0\n    loop_last_rup_w = 0\n    picked_empty_rup = 0\n    old_percent = '0000'\n    while sum_fault_budget > 0:\n        ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n        if ratio_done > 0.01:\n            (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n        number_of_loops += 1\n        if len(empty_bins) != len(bin_mag):\n            ' Calculate the new target shape in each bin in terms of moment rate '\n            tmp = time.time()\n            target_i = target.get_new_target(number_of_loops, moment_rate_in_bin, p_MFD_MO, target_moment_per_bin, bin_mag, empty_bins, bin_target_reached, rup_in_bin)\n            time_target_building += time.time() - tmp\n            if sum(target_i) == 0.0:\n                target_i = p_MFD_MO\n            try:\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            except:\n                print(target_i)\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            if deep_analysis == True:\n                percent = round((1.0 - float(sum_fault_budget) / float(nb_ss_to_spend)) * 100.0)\n                percent = '{:04d}'.format(percent)\n                if percent != old_percent:\n                    old_percent = percent\n                    print('\\nnumber_of_loops', number_of_loops)\n                    print('budget left : ', sum_fault_budget, ' | ', percent, '%')\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time building target at time i : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_weight_rupt)\n                    print('time weighting rupture pick : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_clean_w_rupt)\n                    print('time cleaning weighting rupture weigth : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_target_reach)\n                    print('time checking target reach : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_bin)\n                    print('time checking empty bins : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_faults)\n                    print('time checking empty faults : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time spending dsr : ', time_str)\n                    time_str = core_utils.seconds_to_str(time.time() - inti_core_time)\n                    print('total core time : ', time_str)\n                    tot_core_time = time.time() - inti_core_time\n                    unaccounted_t = tot_core_time - (time_target_building + time_weight_rupt + time_clean_w_rupt + time_checking_target_reach + time_checking_empty_bin + time_checking_empty_faults + time_spending_dsr)\n                    time_str = core_utils.seconds_to_str(unaccounted_t)\n                    print('unaccounted time : ', time_str)\n                    print('max target : ', round(max(target_i), 4), '| last bin w : ', str(round(target_i[-1], 6)))\n                    print('Empty mag bins:')\n                    print(empty_bins)\n                    budget_last_bin = 0\n                    for rup_i in rup_in_bin[-1]:\n                        if not str(rup_i) in empty_rups:\n                            for f_i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                                budget_last_bin += faults_budget[f_i]\n                    print('fault budget last bin :', budget_last_bin)\n                    (fig, (ax0, ax1)) = plt.subplots(ncols=2)\n                    ax0.plot(bin_mag, target_i, label='target_i', marker='x')\n                    ax0.plot(bin_mag, p_MFD_MO, label='p_MFD_MO', marker='x')\n                    ax0.legend()\n                    ax1.plot(bin_mag, target_moment_per_bin, label='target_moment_per_bin', marker='x')\n                    ax1.plot(bin_mag, moment_rate_in_bin, label='moment_rate_in_bin', marker='x')\n                    ax1.set_yscale('log')\n                    ax1.legend()\n                    plt.savefig(self.pathlog + '/Log_tmp_' + str(self.sample) + '.png', dpi=80, transparent=True)\n                    plt.close()\n            'Pick the bin of magnitude to fill according to the current distribution '\n            target_i = target_i / sum(target_i)\n            picked_bin = np.random.choice(len(bin_mag), 1, p=target_i)[0]\n            mag = bin_mag[picked_bin]\n            tmp = time.time()\n            if not picked_bin in empty_bins:\n                empty_in_bin = set(rup_in_bin[picked_bin]) & set(empty_rups)\n                if len(empty_in_bin) == len(rup_in_bin[picked_bin]):\n                    empty_bins.append(picked_bin)\n            time_checking_empty_bin += time.time() - tmp\n            if not picked_bin in empty_bins:\n                tmp = time.time()\n                'Calculate the weight for sampling of the fault or scenario'\n                do_rup_weight = False\n                if number_of_loops == 1:\n                    do_rup_weight = True\n                if sum_fault_budget < weigthing_built[weigth_rup_sample]:\n                    do_rup_weight = True\n                if do_rup_weight == True:\n                    loop_last_rup_w = number_of_loops\n                    weigth_rup_sample += 1\n                    if faster_rup_weight == True:\n                        list_of_bins = range(len(bin_mag))\n                    else:\n                        list_of_bins = [picked_bin]\n                    w_rup_binmag = []\n                    for index_mag in list_of_bins:\n                        if index_mag in empty_bins:\n                            w_rup_binmag.append([])\n                        else:\n                            weight_rup_i = core_utils.weight_fault_sampling(index_mag, rup_in_bin, faults_names, faults_slip_rates, slip_rate_use_per_fault, faults_alone, scenarios_names, faults_isolated, index_faults_in_scenario, rup_rates, empty_rups)\n                            if local_MFD == True:\n                                factor_on_weight = core_utils.check_local_mfd(rup_rates, rup_in_bin[index_mag], index_mag, bin_mag, local_mfds, associated_rup, associated_weight)\n                                weight_rup_i = np.array([i * w for (i, w) in zip(weight_rup_i, factor_on_weight)])\n                                weight_rup_i /= weight_rup_i.sum()\n                            if sum(weight_rup_i) != 0.0:\n                                weight_rup_i = [float(i) / sum(weight_rup_i) for i in weight_rup_i]\n                            w_rup_binmag.append(weight_rup_i)\n                    time_weight_rupt += time.time() - tmp\n                    tmp = time.time()\n                    for index_mag in list_of_bins:\n                        if not index_mag in empty_bins:\n                            weight_rup = w_rup_binmag[index_mag]\n                            if set(rup_in_bin[index_mag]) & set(empty_rups):\n                                i = 0\n                                for i_rup in rup_in_bin[index_mag]:\n                                    if str(i_rup) in empty_rups:\n                                        weight_rup[i] = 0.0\n                                    i += 1\n                            weight_rup = list(weight_rup)\n                            sum_weight_rup = sum(weight_rup)\n                            if sum(weight_rup) == 0.0:\n                                empty_bins.append(index_mag)\n                            if not index_mag in empty_bins:\n                                if sum_weight_rup != 1.0:\n                                    weight_rup = [float(i) / sum_weight_rup for i in weight_rup]\n                                if math.isnan(sum(weight_rup)):\n                                    print('WARNING : sum rup weight is nan')\n                                    nb_nans = 0\n                                    id = 0\n                                    for i in weight_rup:\n                                        if math.isnan(i):\n                                            nb_nans += 1\n                                        weight_rup[id] = 0.0\n                                        id += 1\n                            w_rup_binmag[index_mag] = weight_rup\n                    time_clean_w_rupt += time.time() - tmp\n                if faster_rup_weight == True:\n                    weight_rup = w_rup_binmag[picked_bin]\n                else:\n                    weight_rup = w_rup_binmag[0]\n                try:\n                    i_picked = np.where(np.random.multinomial(1, weight_rup) == 1)[0][0]\n                    picked_rup = rup_in_bin[picked_bin][i_picked]\n                except ValueError:\n                    print(\"rupt weights didn't work. sum:\", sum(weight_rup))\n                    picked_rup = np.random.choice(rup_in_bin[picked_bin])\n                    n_w_crash += 1\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                if bool_target_set == False:\n                    tmp = time.time()\n                    last_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-3:]:\n                        if not bin_i in empty_bins:\n                            last_bins_empty = False\n                    if last_bins_empty == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        bool_target_set = True\n                        print('set target - limit on the largest magnitudes')\n                    if moment_rate_left <= (1.0 - 1e-05) * moment_rate_required:\n                        self.calculation_log_file.write('\\n Not enough moment left ')\n                        for rup_i in rup_in_bin[-3] + rup_in_bin[-2] + rup_in_bin[-1]:\n                            if not str(rup_i) in empty_rups:\n                                empty_rups.append(str(rup_i))\n                        rup_in_bin[-3] = []\n                        rup_in_bin[-2] = []\n                        rup_in_bin[-1] = []\n                        bool_target_set = True\n                        print('set target - moment rate is limiting')\n                    antelast_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-2:]:\n                        if not bin_i in empty_bins:\n                            antelast_bins_empty = False\n                    if antelast_bins_empty == True and bool_target_set == False:\n                        if moment_rate_in_bin[-3] >= 2.0 * (moment_rate_in_bin[-2] + moment_rate_in_bin[-1]):\n                            self.calculation_log_file.write('\\n antepenultimate bin getting too high')\n                            for rup_i in rup_in_bin[-3]:\n                                if not str(rup_i) in empty_rups:\n                                    empty_rups.append(str(rup_i))\n                            empty_bins.append(range(len(bin_mag))[-3])\n                            bool_target_set = True\n                            print('set target - antepenultimate bin getting too high')\n                    if number_of_loops > number_of_loops_last_checked + 50.0:\n                        number_of_loops_last_checked = number_of_loops\n                        moment_rate_left = Total_moment_faults_rate_init - Total_moment_rate_fault\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        rate_Mmax_check = np.mean(rate_tot_model[-3:])\n                        moment_rate_required = 0.0\n                        for index_mag in range(len(bin_mag) - 3):\n                            rate_Mi_check = rate_tot_model[index_mag]\n                            target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-2]\n                            moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            moment_rate_required = 0.0\n                            for index_mag in range(len(bin_mag) - 3):\n                                rate_Mi_check = rate_tot_model[index_mag]\n                                target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-3]\n                                moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                    time_checking_target_reach += time.time() - tmp\n                    if do_the_target == True and bool_target_set == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        do_the_target = False\n                        print('- target set - ')\n                        self.calculation_log_file.write('\\n- target set - ')\n                        rate_at_target_setting = rate_tot_model\n                        rate_Mmax = np.mean(rate_tot_model[-3:])\n                        TARGET = []\n                        for t_mag_bin in range(len(bin_mag)):\n                            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            TARGET = []\n                            for t_mag_bin in range(len(bin_mag)):\n                                rate_Mi = rate_tot_model[t_mag_bin]\n                                TARGET.append(rate_Mmax * p_MFD[picked_bin] / p_MFD[-3])\n                if picked_bin in bin_target_reached:\n                    print('WHAT ARE YOU DOING HERE?', bin_mag[picked_bin])\n                    exit()\n                ' spending the slip_rate increment '\n                tmp = time.time()\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                sr_to_spend = True\n                shear_mod = 0\n                for index in index_fault:\n                    shear_mod += faults_shear_mod[index]\n                    if faults_budget[index] <= 0.0:\n                        sr_to_spend = False\n                if sr_to_spend == False:\n                    if not str(picked_rup) in empty_rups:\n                        empty_rups.append(str(picked_rup))\n                    else:\n                        picked_empty_rup += 1\n                if sr_to_spend == True:\n                    shear_mod = shear_mod / float(len(index_fault))\n                    area = rup_rates.get(str(picked_rup)).get('area')\n                    displacement = mag_to_M0(mag) / (shear_mod * area)\n                    rate_i = size_of_increment / displacement\n                    if option_fast == True:\n                        min_budget_local = min([faults_budget[i] for i in index_fault])\n                        nb_loop_spending = int(min_budget_local / min_budget)\n                        if nb_loop_spending < 1:\n                            nb_loop_spending = 1\n                    else:\n                        nb_loop_spending = 1\n                    if bool_target_set == True:\n                        rate_Mi = rate_in_model[picked_bin]\n                        target_mfd_i = TARGET[picked_bin] * fault_prop(bin_mag[picked_bin])\n                        if rate_Mi < target_mfd_i:\n                            if uniform_spending == True or len(index_fault) == 1:\n                                moment_rate_i = 0.0\n                                for index in index_fault:\n                                    for loop_spending in range(nb_loop_spending):\n                                        M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                    faults_budget[index] += -1 * nb_loop_spending\n                                    sum_fault_budget += -1 * nb_loop_spending\n                                    slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                                rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                            else:\n                                moment_rate_i = 0.0\n                                for loop_spending in range(nb_loop_spending):\n                                    (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                    rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                    rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                    moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                            moment_rate_in_bin[picked_bin] += moment_rate_i\n                            Total_moment_rate_fault += moment_rate_i\n                        else:\n                            rup_in_bin[picked_bin] = []\n                            if not picked_bin in bin_target_reached:\n                                bin_target_reached.append(picked_bin)\n                    else:\n                        if uniform_spending == True or len(index_fault) == 1:\n                            moment_rate_i = 0.0\n                            for index in index_fault:\n                                for loop_spending in range(nb_loop_spending):\n                                    M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                faults_budget[index] += -1 * nb_loop_spending\n                                sum_fault_budget += -1 * nb_loop_spending\n                                slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                            rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                            rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                            moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                        else:\n                            moment_rate_i = 0.0\n                            for loop_spending in range(nb_loop_spending):\n                                (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                        moment_rate_in_bin[picked_bin] += moment_rate_i\n                        Total_moment_rate_fault += moment_rate_i\n                time_spending_dsr += time.time() - tmp\n            elif not picked_bin in empty_bins:\n                empty_bins.append(picked_bin)\n            tmp = time.time()\n            if number_of_loops > number_of_loops_before + 500:\n                number_of_loops_before = number_of_loops\n                for index_mag in range(len(bin_mag)):\n                    if not index_mag in empty_bins:\n                        nb_rup_not_empty = 0\n                        for i_rup in rup_in_bin[index_mag]:\n                            if nb_rup_not_empty == 0:\n                                rup_is_empty = False\n                                for index_fault in rup_rates.get(str(i_rup)).get('involved_faults'):\n                                    if faults_budget[index_fault] <= 0:\n                                        rup_is_empty = True\n                                if rup_is_empty == False:\n                                    nb_rup_not_empty += 1\n                        if nb_rup_not_empty == 0:\n                            empty_bins.append(index_mag)\n            time_checking_empty_bin += time.time() - tmp\n            tmp = time.time()\n            len_faults_budget.append(sum_fault_budget)\n            if len(len_faults_budget) > 3:\n                if len_faults_budget[-2] == len_faults_budget[-1]:\n                    number_of_loops_for_nothing += 1\n                if number_of_loops_for_nothing_before < number_of_loops_for_nothing - 100:\n                    number_of_loops_for_nothing_before = number_of_loops_for_nothing\n                    if len_faults_budget[-1] == len_faults_budget[-10]:\n                        rup_still_used = [i for i in rup_in_bin[picked_bin] if not i in empty_rups]\n                        fault_still_used = []\n                        for rup_i in rup_still_used:\n                            fault_still_used += list(rup_rates.get(str(rup_i)).get('involved_faults'))\n                        fault_still_used = set(fault_still_used)\n                        for (fault, index_fault) in zip(faults_names, range(len(faults_names))):\n                            if not index_fault in fault_still_used and faults_budget[index_fault] > 0:\n                                while faults_budget[index_fault] > 0:\n                                    ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                                    if ratio_done > 0.01:\n                                        (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                                    faults_budget[index_fault] += -1\n                                    sum_fault_budget += -1\n                                    M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                                    aseismic_count += 1\n            time_checking_empty_faults += time.time() - tmp\n        else:\n            print('-target filled-')\n            self.calculation_log_file.write('\\n-target filled-')\n            while sum_fault_budget != 0:\n                ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                if ratio_done > 0.01:\n                    (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                for index_fault in range(len(faults_names)):\n                    if faults_budget[index_fault] > 0:\n                        faults_budget[index_fault] += -1\n                        sum_fault_budget += -1\n                        M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                        aseismic_count += 1\n    ' check if the TARGET as been set.\\n        if not, build it for comparing'\n    if TARGET == []:\n        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n        print('- target set at the end- ')\n        self.calculation_log_file.write('\\n- target set at the end - ')\n        rate_at_target_setting = rate_tot_model\n        rate_Mmax = np.mean(rate_tot_model[-3:])\n        for t_mag_bin in range(len(bin_mag)):\n            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n    '##################################################################\\n        #\\n        # Definition of the background seismicity\\n        #\\n        ##################################################################'\n    (rate_f_in_model, rate_bg_in_model) = rates.get_rate_faults_n_bg(rup_rates, fault_prop, bin_mag)\n    EQ_rate_BG = rate_bg_in_model\n    '##################################################################\\n        # printing\\n        ##################################################################'\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    model_MFD.append(rate_tot_model)\n    colors = ['gainsboro', 'darkgray', 'dimgray', 'dimgray', 'black', 'red']\n    index_color = 0\n    for MFD_i in model_MFD:\n        plt.plot(bin_mag, MFD_i, color=colors[index_color])\n        index_color += 1\n    if do_the_target == True:\n        rate_at_target_setting = model_MFD[-1]\n    plt.plot(bin_mag, rate_at_target_setting, ':g')\n    plt.plot(bin_mag, TARGET, ':b')\n    plt.scatter(bin_mag[-3:], rate_tot_model[-3:], c='k')\n    plt.yscale('log')\n    plt.savefig(self.pathlog + '/Log_target_fit_' + str(self.sample) + '.png', dpi=180, transparent=True)\n    plt.close()\n    index_5 = 0\n    while bin_mag[index_mag] < 5.0:\n        index_5 += 1\n    self.ratio_test = np.mean([abs(TARGET[index_5 + 0] / rate_tot_model[index_5 + 0]), abs(TARGET[index_5 + 1] / rate_tot_model[index_5 + 1]), abs(TARGET[index_5 + 2] / rate_tot_model[index_5 + 2]), abs(TARGET[index_5 + 3] / rate_tot_model[index_5 + 3]), abs(TARGET[index_5 + 4] / rate_tot_model[index_5 + 4])])\n    MFD_to_test = rate_tot_model / sum(rate_tot_model)\n    target_to_test = TARGET / sum(TARGET)\n    array_absolute_ratio = []\n    for index_mag in range(len(bin_mag)):\n        array_absolute_ratio.append(abs(MFD_to_test[index_mag] / target_to_test[index_mag]))\n    self.ratio_test = np.mean(array_absolute_ratio)\n    print('ratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    self.calculation_log_file.write('\\nratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    '##################################################################\\n        #\\n        # OUTPUT for Source_model_creator\\n        #\\n        ##################################################################'\n    self.OQ_entry_faults = []\n    self.OQ_entry_scenarios = []\n    for i in range(len(faults_names)):\n        self.OQ_entry_faults.append(rup_rates.get(str(i)).get('rates'))\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            self.OQ_entry_scenarios.append(rup_rates.get(str(i_end + j)).get('rates'))\n    self.faults_names = faults_names\n    self.scenarios_names = scenarios_names\n    self.EQ_rate_BG = EQ_rate_BG\n    self.bin_mag = bin_mag\n    self.rup_rates = rup_rates\n    self.M_slip_repartition = M_slip_repartition\n    log_calculation_file.write('Moment_rate_faults_final calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.write('Ratio of NMS slip rate counted in the iterative process: ' + '\\t' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))) + '\\t %\\n')\n    log_calculation_file.write('Moment_rate_model calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.close()\n    self.ratio_NMS = round(100.0 * (1.0 - Total_moment_rate_fault / Total_moment_faults_rate_init))\n    print('ratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    self.calculation_log_file.write('\\nratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    f = open(log_sliprep_file, 'wb')\n    pickle.dump(M_slip_repartition, f)\n    f.close()",
            "def initialize(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    faults_shear_mod = self.faults_shear_mod\n    mfd_param = self.mfd_param\n    M_min = self.M_min\n    Mmax_range = self.Mmax_range\n    inti_core_time = time.time()\n    faults_names = self.faults_names\n    faults_areas = self.faults_area\n    faults_length = self.faults_length\n    faults_width = self.faults_width\n    faults_slip_rates = self.faults_slip_rates\n    log_calculation_file = open(self.pathlog + '/calculation_sample_' + str(self.sample) + '.txt', 'w')\n    log_sliprep_file = self.pathlog + '/sliprep_sample_' + str(self.sample) + '.pkl'\n    re_use = True\n    scenarios_names = self.scenarios\n    run_name = self.Run_Name\n    model_name = self.branch['model']\n    scl_name = self.branch['scl'][0] + '_' + self.branch['scl'][1] + '_' + self.branch['scl'][2]\n    set_name = self.branch['set']\n    f_mmax = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_mmax_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_mmax):\n        re_use = False\n    if re_use == False:\n        print('Building scenarios and Mmax')\n        '##################################################################\\n            # finds the faults belonging to each scenario\\n            ##################################################################'\n        index_faults_in_scenario = []\n        for scenario in scenarios_names:\n            i_scenario = []\n            for i in range(len(scenario)):\n                i_scenario = i_scenario + list(np.where(np.array(faults_names) == scenario['f_%s' % str(i + 1)]))\n            i_scenario = np.reshape(i_scenario, (1, len(scenario)))\n            index_faults_in_scenario.append(i_scenario)\n        self.index_faults_in_scenario = index_faults_in_scenario\n        faults_alone = []\n        faults_isolated = []\n        len_max_section_scenario = 0\n        for indexes in index_faults_in_scenario:\n            if len(indexes[0]) > len_max_section_scenario:\n                len_max_section_scenario = len(indexes[0])\n        index_fault = 0\n        for fault_name in faults_names:\n            fault_alone_bool = True\n            fault_isolated_bool = True\n            for indexes in index_faults_in_scenario:\n                if index_fault in indexes[0]:\n                    fault_alone_bool = False\n                    if len(indexes[0]) > len_max_section_scenario / 2.0:\n                        fault_isolated_bool = False\n            if fault_isolated_bool == True and fault_alone_bool == False:\n                faults_isolated.append(index_fault)\n            if fault_alone_bool == True:\n                faults_alone.append(index_fault)\n            index_fault += 1\n        '##################################################################\\n            # area and length of each scenario\\n            ##################################################################'\n        scenario_area = []\n        index_faults_in_scenario_for_scl = []\n        for indexes_i in index_faults_in_scenario:\n            list_of_points = []\n            index_for_scenario = []\n            for index_fault in indexes_i[0]:\n                list_i = str(self.faults_lon[index_fault][0]) + str(self.faults_lon[index_fault][-1]) + str(self.faults_lat[index_fault][0]) + str(self.faults_lat[index_fault][-1])\n                if not list_i in list_of_points:\n                    list_of_points.append(list_i)\n                    index_for_scenario.append(index_fault)\n            index_faults_in_scenario_for_scl.append(index_for_scenario)\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_area = np.sum(np.take(faults_areas, i))\n            scenario_area.append(scenario_i_area)\n        scenario_length = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_length = np.sum(np.take(faults_length, i))\n            scenario_length.append(scenario_i_length)\n        scenario_width = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_width = np.mean(np.take(faults_width, i))\n            scenario_width.append(scenario_i_width)\n        '\\n            check the max dimention for a single fault according to the\\n            aspect ratio\\n            '\n        (f_len_ar, f_width_ar, f_area_ar) = ([], [], [])\n        ar = self.param['main']['parameters']['aspect_ratio']\n        for (l, w) in zip(self.faults_length, self.faults_width):\n            if l < w * ar:\n                f_len_ar.append(l)\n                f_width_ar.append(l * ar)\n                f_area_ar.append(l * l * ar)\n            else:\n                f_len_ar.append(l)\n                f_width_ar.append(w)\n                f_area_ar.append(l * w)\n        '##################################################################\\n            #####################################################################\\n            #\\n            # setting up the coefficients for the scalling law\\n            # and calculate the Mmax\\n            #\\n            #####################################################################\\n            ##################################################################'\n        Mmaxmin = Mmax_range[0]\n        Mmaxmax = Mmax_range[1]\n        Mmax = -1.0\n        loop_Mmax = 1\n        while Mmax < Mmaxmin or Mmax > Mmaxmax:\n            log_Mmax_file = open(self.param['dirpath'] + run_name + '/LOG/' + model_name + '_Log_Mmax_sample_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.txt', 'w')\n            if loop_Mmax == 1:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, self.sample)\n            else:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, 10)\n            Mmax_faults = Mmaxs.Mmax_faults\n            Mmax_scenario = Mmaxs.Mmax_scenario\n            final_fault_length = Mmaxs.final_fault_length\n            final_scenario_length = Mmaxs.final_scenario_length\n            index_fault = 0\n            for Mmax_i in Mmax_faults:\n                line = faults_names[index_fault] + '\\t' + str(round(faults_length[index_fault] / 1000.0, 1)) + '\\t' + final_fault_length[index_fault] + '\\t' + str(round(self.faults_width[index_fault], 1)) + '\\t' + str(round(self.faults_area[index_fault] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_fault += 1\n            index_scenario = 0\n            for Mmax_i in Mmax_scenario:\n                line = str(scenarios_names[index_scenario]) + '\\t' + str(round(scenario_length[index_scenario] / 1000.0, 1)) + '\\t' + final_scenario_length[index_scenario] + '\\t' + str(round(scenario_width[index_scenario], 1)) + '\\t' + str(round(scenario_area[index_scenario] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_scenario += 1\n            log_Mmax_file.close()\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            loop_Mmax += 1\n            if loop_Mmax == 30:\n                print('An Mmax incompatible with the ruptures is imposed!! Change it in run.info or change the rupture.txt file')\n        if loop_Mmax >= 3:\n            print('Mmax imposed: ' + str(Mmax))\n            self.calculation_log_file.write('\\nMmax imposed: ' + str(Mmax))\n        with open(f_mmax, 'wb') as f:\n            dump_to_file = [Mmax_faults, Mmax_scenario, final_fault_length, final_scenario_length, faults_alone, faults_isolated, index_faults_in_scenario, scenario_area]\n            pickle.dump(dump_to_file, f)\n        print('\\t - scenario and max built')\n    else:\n        print('Reloading Mmax from data file')\n        with open(f_mmax, 'rb') as f:\n            load_from_file = pickle.load(f)\n            Mmax_faults = load_from_file[0]\n            Mmax_scenario = load_from_file[1]\n            final_fault_length = load_from_file[2]\n            final_scenario_length = load_from_file[3]\n            faults_alone = load_from_file[4]\n            faults_isolated = load_from_file[5]\n            index_faults_in_scenario = load_from_file[6]\n            scenario_area = load_from_file[7]\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            print('\\t - scenario and max loaded')\n    '##################################################################\\n        #etablish the magnitude bin (0.1)\\n        ##################################################################'\n    bin_mag = np.linspace(M_min, Mmax, int(round(Mmax - M_min, 1) * 10.0 + 1))\n    '#####################################################################\\n        # initializing incremental reccurence of the earthquakes for each rupture and each bin)\\n        #####################################################################'\n    rup_rates = {}\n    index_rup = []\n    for i in range(len(faults_names)):\n        rup_rates.update({str(i): {'rup_id': i, 'rup_name': faults_names[i], 'involved_faults': [i], 'Mmax': Mmax_faults[i], 'area': faults_areas[i], 'rates': np.zeros(len(bin_mag))}})\n        index_rup.append(i)\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            rup_rates.update({str(i_end + j): {'rup_id': i_end + j, 'rup_name': scenarios_names[j], 'involved_faults': index_faults_in_scenario[j][0], 'Mmax': Mmax_scenario[j], 'area': scenario_area[j], 'rates': np.zeros(len(bin_mag))}})\n            index_rup.append(i_end + j)\n    if str(self.sample) == '1':\n        log_rup_file = open(self.pathlog + '/ruptures.txt', 'w')\n        log_rup_file.write('rup_id\\tinvolved_faults\\n')\n        for i in range(len(rup_rates)):\n            log_rup_file.write(str(rup_rates.get(str(i)).get('rup_id')) + '\\t')\n            for j in rup_rates.get(str(i)).get('involved_faults'):\n                log_rup_file.write(str(j) + ' ')\n            log_rup_file.write('\\n')\n        log_rup_file.close()\n    self.index_faults_in_scenario = index_faults_in_scenario\n    '#####################################################################\\n        # For each bin, find which fault and which scenario populates it.\\n        #####################################################################'\n    f_bin_pop = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_bin_pop_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_bin_pop):\n        re_use = False\n    rup_in_bin = populate_bins.pop(bin_mag, index_rup, rup_rates, M_min, re_use, f_bin_pop)\n    '##################################################################\\n        # Definition of the background - how much is not on the faults\\n        ##################################################################'\n    bin_mag_fault_prop = [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0]\n    fault_prop_inc = self.bg_ratio\n    bin_mag_fault_prop.append(10.0)\n    fault_prop_inc = np.append(np.array(fault_prop_inc), 1.0)\n    fault_prop = interp1d(bin_mag_fault_prop, fault_prop_inc)\n    self.fault_prop = fault_prop\n    '##################################################################\\n        #Calculation of the total moment rate sum(slip-rate)*sum(area) + moment in the background\\n        ##################################################################'\n    Total_moment_faults_rate_init = 0.0\n    index_fault = 0\n    for fault_area in faults_areas:\n        Total_moment_faults_rate_init += faults_shear_mod[index_fault] * fault_area * faults_slip_rates[index_fault]\n        index_fault += 1\n    log_calculation_file.write('Moment_rate_fault_initial calculated using muAs' + '\\t' + str(Total_moment_faults_rate_init) + '\\t' + 'N.m' + '\\n')\n    Total_moment_rate_fault = 0.0\n    '##################################################################\\n        #etablish the target regional distribution\\n        ##################################################################'\n    if self.mfd_hyp == 'GR':\n        p_MFD = mfd_shape.GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'tapered_GR':\n        mfd_param['M_corner'] = Mmax - 0.4\n        p_MFD = mfd_shape.tapered_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'double_GR':\n        p_MFD = mfd_shape.double_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'YC':\n        p_MFD = mfd_shape.YC(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_marmara':\n        p_MFD = mfd_shape.YC_marmara(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_modified':\n        p_MFD = mfd_shape.YC_modified(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'UCERF_DV':\n        p_MFD = mfd_shape.UCERF_DV(bin_mag)\n    else:\n        print('Error : Unknown MFD name!')\n    p_MFD = p_MFD / sum(p_MFD)\n    '##################################################################\\n        # Converting in term of moment\\n        ##################################################################'\n    p_MFD_MO = []\n    index_mag = 0\n    for mag in bin_mag:\n        M0 = mag_to_M0(mag)\n        p_MFD_MO.append(fault_prop(mag) * p_MFD[index_mag] * M0)\n        index_mag += 1\n    p_MFD_MO = p_MFD_MO / sum(p_MFD_MO)\n    '##################################################################\\n        # Adding the moment rate of the background to the Total_moment_rate_init\\n        ##################################################################'\n    Total_moment_rate_init = Total_moment_faults_rate_init\n    index_mag = 0\n    for mag in bin_mag:\n        moment_rate_fault_bin = p_MFD_MO[index_mag] * Total_moment_faults_rate_init\n        moment_rate_BG_bin = (1 - fault_prop(mag)) * moment_rate_fault_bin / fault_prop(mag)\n        Total_moment_rate_init += moment_rate_BG_bin\n        index_mag += 1\n    '##################################################################\\n        # Etablish the target of moment rate per bin\\n        ##################################################################'\n    target_moment_per_bin = p_MFD_MO * Total_moment_faults_rate_init\n    '##################################################################\\n        # Create the sliprate budget dictionary\\n        # This matrix contain a list of the fault name. each name is repeted\\n        # by a number of time depending of the slip-rate of the fault.\\n        ##################################################################'\n    size_of_increment = float(self.size_of_increment) * 0.001\n    if self.count_reruns != 1:\n        size_of_increment = size_of_increment / (float(self.count_reruns) * 1.5 - 1.0)\n    faults_budget = {}\n    for index_fault in range(len(faults_names)):\n        nb_dsr = int(round(faults_slip_rates[index_fault] / size_of_increment, 0))\n        if nb_dsr == 0:\n            nb_dsr = 1\n        faults_budget.update({index_fault: nb_dsr})\n    min_budget = float(min(faults_budget.values())) + 1\n    max_budget = float(max(faults_budget.values()))\n    while max_budget / min_budget > 50.0:\n        min_budget *= 2.0\n    '##################################################################\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        #   Populate the bin of magnitude of each fault and each scenario\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        ##################################################################'\n    M_slip_repartition = {}\n    for (fault, i) in zip(faults_names, range(len(faults_names))):\n        dic_tmp = {}\n        for rup_i in range(len(rup_rates)):\n            if i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                dic_tmp.update({str(rup_i): 0})\n        dic_tmp.update({'NMS': 0})\n        M_slip_repartition.update({str(fault): dic_tmp})\n    moment_rate_in_bin = np.zeros(len(bin_mag))\n    model_MFD = []\n    number_of_loops = 0\n    number_of_loops_before = 0\n    number_of_loops_for_nothing = 0\n    number_of_loops_for_nothing_before = 0\n    number_of_loops_last_checked = -1\n    empty_bins = []\n    empty_rups = []\n    bin_target_reached = []\n    len_faults_budget = []\n    aseismic_count = 0\n    color_mag = []\n    '######################\\n        #####   MAIN LOOP   #####\\n        ######################'\n    TARGET = []\n    nb_ss_to_spend = float(sum(faults_budget.values()))\n    sum_fault_budget = nb_ss_to_spend\n    print('Number of dsr to spend : ' + str(nb_ss_to_spend))\n    print('Min of sdr :', min(faults_budget.values()))\n    print('Max of sdr :', max(faults_budget.values()))\n    self.calculation_log_file.write('\\nnumber of dsr to spend : ' + str(nb_ss_to_spend) + '\\n')\n    print_percent = True\n    do_the_target = True\n    bool_target_set = False\n    uniform_spending = self.param['main']['parameters']['uniform_spending']\n    if uniform_spending in ['True', 'true']:\n        uniform_spending = True\n    else:\n        uniform_spending = False\n    deep_analysis = self.param['main']['parameters']['deep_analysis']\n    if deep_analysis in ['True', 'true']:\n        deep_analysis = True\n    else:\n        deep_analysis = False\n    faster_rup_weight = self.param['main']['parameters']['faster_rup_weight']\n    if faster_rup_weight in ['True', 'true']:\n        faster_rup_weight = True\n    else:\n        faster_rup_weight = False\n    option_fast = self.param['main']['parameters']['option_fast']\n    if option_fast in ['True', 'true']:\n        option_fast = True\n    else:\n        option_fast = False\n    local_MFD = self.param['main']['parameters']['local_MFD']\n    if local_MFD in ['True', 'true']:\n        f_mfd_area = self.param['main']['local_MFD_file']\n        (local_mfds, associated_rup, associated_weight) = core_utils.link_rup_mfd_area(rup_rates, f_mfd_area, self.faults_lon, self.faults_lat, bin_mag, self.bg_ratio)\n    time_weight_rupt = 0.0\n    time_clean_w_rupt = 0.0\n    time_target_building = 0.0\n    time_checking_target_reach = 0.0\n    time_spending_dsr = 0.0\n    time_checking_empty_bin = 0.0\n    time_checking_empty_faults = 0.0\n    budget_init = int(sum_fault_budget)\n    if faster_rup_weight == True:\n        nb_weigthings_rup_sampling = int(self.param['main']['parameters']['nb_weigthings_rup_sampling'])\n        if 'type_weigthings_rup_sampling' in self.param['main']['parameters'].keys():\n            type_weigthings_rup_sampling = self.param['main']['parameters']['type_weigthings_rup_sampling']\n        else:\n            type_weigthings_rup_sampling = 'lin'\n        if type_weigthings_rup_sampling == 'log':\n            weigthing_built = [int(i) for i in np.logspace(0.0, np.log10(budget_init), nb_weigthings_rup_sampling)]\n        if type_weigthings_rup_sampling == 'lin':\n            weigthing_built = [int(i) for i in np.linspace(0.0, budget_init, nb_weigthings_rup_sampling)]\n    else:\n        weigthing_built = [int(i) for i in range(budget_init)]\n    weigthing_built.reverse()\n    weigth_rup_sample = 0\n    slip_rate_use_per_fault = np.zeros(len(faults_names))\n    moment_rate_required = 0.0\n    moment_rate_left = Total_moment_faults_rate_init\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    rate_in_model = np.zeros(len(bin_mag))\n    test_mean_picked = []\n    most_likely_pick = []\n    n_w_work = 0\n    n_w_crash = 0\n    loop_last_rup_w = 0\n    picked_empty_rup = 0\n    old_percent = '0000'\n    while sum_fault_budget > 0:\n        ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n        if ratio_done > 0.01:\n            (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n        number_of_loops += 1\n        if len(empty_bins) != len(bin_mag):\n            ' Calculate the new target shape in each bin in terms of moment rate '\n            tmp = time.time()\n            target_i = target.get_new_target(number_of_loops, moment_rate_in_bin, p_MFD_MO, target_moment_per_bin, bin_mag, empty_bins, bin_target_reached, rup_in_bin)\n            time_target_building += time.time() - tmp\n            if sum(target_i) == 0.0:\n                target_i = p_MFD_MO\n            try:\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            except:\n                print(target_i)\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            if deep_analysis == True:\n                percent = round((1.0 - float(sum_fault_budget) / float(nb_ss_to_spend)) * 100.0)\n                percent = '{:04d}'.format(percent)\n                if percent != old_percent:\n                    old_percent = percent\n                    print('\\nnumber_of_loops', number_of_loops)\n                    print('budget left : ', sum_fault_budget, ' | ', percent, '%')\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time building target at time i : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_weight_rupt)\n                    print('time weighting rupture pick : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_clean_w_rupt)\n                    print('time cleaning weighting rupture weigth : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_target_reach)\n                    print('time checking target reach : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_bin)\n                    print('time checking empty bins : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_faults)\n                    print('time checking empty faults : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time spending dsr : ', time_str)\n                    time_str = core_utils.seconds_to_str(time.time() - inti_core_time)\n                    print('total core time : ', time_str)\n                    tot_core_time = time.time() - inti_core_time\n                    unaccounted_t = tot_core_time - (time_target_building + time_weight_rupt + time_clean_w_rupt + time_checking_target_reach + time_checking_empty_bin + time_checking_empty_faults + time_spending_dsr)\n                    time_str = core_utils.seconds_to_str(unaccounted_t)\n                    print('unaccounted time : ', time_str)\n                    print('max target : ', round(max(target_i), 4), '| last bin w : ', str(round(target_i[-1], 6)))\n                    print('Empty mag bins:')\n                    print(empty_bins)\n                    budget_last_bin = 0\n                    for rup_i in rup_in_bin[-1]:\n                        if not str(rup_i) in empty_rups:\n                            for f_i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                                budget_last_bin += faults_budget[f_i]\n                    print('fault budget last bin :', budget_last_bin)\n                    (fig, (ax0, ax1)) = plt.subplots(ncols=2)\n                    ax0.plot(bin_mag, target_i, label='target_i', marker='x')\n                    ax0.plot(bin_mag, p_MFD_MO, label='p_MFD_MO', marker='x')\n                    ax0.legend()\n                    ax1.plot(bin_mag, target_moment_per_bin, label='target_moment_per_bin', marker='x')\n                    ax1.plot(bin_mag, moment_rate_in_bin, label='moment_rate_in_bin', marker='x')\n                    ax1.set_yscale('log')\n                    ax1.legend()\n                    plt.savefig(self.pathlog + '/Log_tmp_' + str(self.sample) + '.png', dpi=80, transparent=True)\n                    plt.close()\n            'Pick the bin of magnitude to fill according to the current distribution '\n            target_i = target_i / sum(target_i)\n            picked_bin = np.random.choice(len(bin_mag), 1, p=target_i)[0]\n            mag = bin_mag[picked_bin]\n            tmp = time.time()\n            if not picked_bin in empty_bins:\n                empty_in_bin = set(rup_in_bin[picked_bin]) & set(empty_rups)\n                if len(empty_in_bin) == len(rup_in_bin[picked_bin]):\n                    empty_bins.append(picked_bin)\n            time_checking_empty_bin += time.time() - tmp\n            if not picked_bin in empty_bins:\n                tmp = time.time()\n                'Calculate the weight for sampling of the fault or scenario'\n                do_rup_weight = False\n                if number_of_loops == 1:\n                    do_rup_weight = True\n                if sum_fault_budget < weigthing_built[weigth_rup_sample]:\n                    do_rup_weight = True\n                if do_rup_weight == True:\n                    loop_last_rup_w = number_of_loops\n                    weigth_rup_sample += 1\n                    if faster_rup_weight == True:\n                        list_of_bins = range(len(bin_mag))\n                    else:\n                        list_of_bins = [picked_bin]\n                    w_rup_binmag = []\n                    for index_mag in list_of_bins:\n                        if index_mag in empty_bins:\n                            w_rup_binmag.append([])\n                        else:\n                            weight_rup_i = core_utils.weight_fault_sampling(index_mag, rup_in_bin, faults_names, faults_slip_rates, slip_rate_use_per_fault, faults_alone, scenarios_names, faults_isolated, index_faults_in_scenario, rup_rates, empty_rups)\n                            if local_MFD == True:\n                                factor_on_weight = core_utils.check_local_mfd(rup_rates, rup_in_bin[index_mag], index_mag, bin_mag, local_mfds, associated_rup, associated_weight)\n                                weight_rup_i = np.array([i * w for (i, w) in zip(weight_rup_i, factor_on_weight)])\n                                weight_rup_i /= weight_rup_i.sum()\n                            if sum(weight_rup_i) != 0.0:\n                                weight_rup_i = [float(i) / sum(weight_rup_i) for i in weight_rup_i]\n                            w_rup_binmag.append(weight_rup_i)\n                    time_weight_rupt += time.time() - tmp\n                    tmp = time.time()\n                    for index_mag in list_of_bins:\n                        if not index_mag in empty_bins:\n                            weight_rup = w_rup_binmag[index_mag]\n                            if set(rup_in_bin[index_mag]) & set(empty_rups):\n                                i = 0\n                                for i_rup in rup_in_bin[index_mag]:\n                                    if str(i_rup) in empty_rups:\n                                        weight_rup[i] = 0.0\n                                    i += 1\n                            weight_rup = list(weight_rup)\n                            sum_weight_rup = sum(weight_rup)\n                            if sum(weight_rup) == 0.0:\n                                empty_bins.append(index_mag)\n                            if not index_mag in empty_bins:\n                                if sum_weight_rup != 1.0:\n                                    weight_rup = [float(i) / sum_weight_rup for i in weight_rup]\n                                if math.isnan(sum(weight_rup)):\n                                    print('WARNING : sum rup weight is nan')\n                                    nb_nans = 0\n                                    id = 0\n                                    for i in weight_rup:\n                                        if math.isnan(i):\n                                            nb_nans += 1\n                                        weight_rup[id] = 0.0\n                                        id += 1\n                            w_rup_binmag[index_mag] = weight_rup\n                    time_clean_w_rupt += time.time() - tmp\n                if faster_rup_weight == True:\n                    weight_rup = w_rup_binmag[picked_bin]\n                else:\n                    weight_rup = w_rup_binmag[0]\n                try:\n                    i_picked = np.where(np.random.multinomial(1, weight_rup) == 1)[0][0]\n                    picked_rup = rup_in_bin[picked_bin][i_picked]\n                except ValueError:\n                    print(\"rupt weights didn't work. sum:\", sum(weight_rup))\n                    picked_rup = np.random.choice(rup_in_bin[picked_bin])\n                    n_w_crash += 1\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                if bool_target_set == False:\n                    tmp = time.time()\n                    last_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-3:]:\n                        if not bin_i in empty_bins:\n                            last_bins_empty = False\n                    if last_bins_empty == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        bool_target_set = True\n                        print('set target - limit on the largest magnitudes')\n                    if moment_rate_left <= (1.0 - 1e-05) * moment_rate_required:\n                        self.calculation_log_file.write('\\n Not enough moment left ')\n                        for rup_i in rup_in_bin[-3] + rup_in_bin[-2] + rup_in_bin[-1]:\n                            if not str(rup_i) in empty_rups:\n                                empty_rups.append(str(rup_i))\n                        rup_in_bin[-3] = []\n                        rup_in_bin[-2] = []\n                        rup_in_bin[-1] = []\n                        bool_target_set = True\n                        print('set target - moment rate is limiting')\n                    antelast_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-2:]:\n                        if not bin_i in empty_bins:\n                            antelast_bins_empty = False\n                    if antelast_bins_empty == True and bool_target_set == False:\n                        if moment_rate_in_bin[-3] >= 2.0 * (moment_rate_in_bin[-2] + moment_rate_in_bin[-1]):\n                            self.calculation_log_file.write('\\n antepenultimate bin getting too high')\n                            for rup_i in rup_in_bin[-3]:\n                                if not str(rup_i) in empty_rups:\n                                    empty_rups.append(str(rup_i))\n                            empty_bins.append(range(len(bin_mag))[-3])\n                            bool_target_set = True\n                            print('set target - antepenultimate bin getting too high')\n                    if number_of_loops > number_of_loops_last_checked + 50.0:\n                        number_of_loops_last_checked = number_of_loops\n                        moment_rate_left = Total_moment_faults_rate_init - Total_moment_rate_fault\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        rate_Mmax_check = np.mean(rate_tot_model[-3:])\n                        moment_rate_required = 0.0\n                        for index_mag in range(len(bin_mag) - 3):\n                            rate_Mi_check = rate_tot_model[index_mag]\n                            target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-2]\n                            moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            moment_rate_required = 0.0\n                            for index_mag in range(len(bin_mag) - 3):\n                                rate_Mi_check = rate_tot_model[index_mag]\n                                target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-3]\n                                moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                    time_checking_target_reach += time.time() - tmp\n                    if do_the_target == True and bool_target_set == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        do_the_target = False\n                        print('- target set - ')\n                        self.calculation_log_file.write('\\n- target set - ')\n                        rate_at_target_setting = rate_tot_model\n                        rate_Mmax = np.mean(rate_tot_model[-3:])\n                        TARGET = []\n                        for t_mag_bin in range(len(bin_mag)):\n                            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            TARGET = []\n                            for t_mag_bin in range(len(bin_mag)):\n                                rate_Mi = rate_tot_model[t_mag_bin]\n                                TARGET.append(rate_Mmax * p_MFD[picked_bin] / p_MFD[-3])\n                if picked_bin in bin_target_reached:\n                    print('WHAT ARE YOU DOING HERE?', bin_mag[picked_bin])\n                    exit()\n                ' spending the slip_rate increment '\n                tmp = time.time()\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                sr_to_spend = True\n                shear_mod = 0\n                for index in index_fault:\n                    shear_mod += faults_shear_mod[index]\n                    if faults_budget[index] <= 0.0:\n                        sr_to_spend = False\n                if sr_to_spend == False:\n                    if not str(picked_rup) in empty_rups:\n                        empty_rups.append(str(picked_rup))\n                    else:\n                        picked_empty_rup += 1\n                if sr_to_spend == True:\n                    shear_mod = shear_mod / float(len(index_fault))\n                    area = rup_rates.get(str(picked_rup)).get('area')\n                    displacement = mag_to_M0(mag) / (shear_mod * area)\n                    rate_i = size_of_increment / displacement\n                    if option_fast == True:\n                        min_budget_local = min([faults_budget[i] for i in index_fault])\n                        nb_loop_spending = int(min_budget_local / min_budget)\n                        if nb_loop_spending < 1:\n                            nb_loop_spending = 1\n                    else:\n                        nb_loop_spending = 1\n                    if bool_target_set == True:\n                        rate_Mi = rate_in_model[picked_bin]\n                        target_mfd_i = TARGET[picked_bin] * fault_prop(bin_mag[picked_bin])\n                        if rate_Mi < target_mfd_i:\n                            if uniform_spending == True or len(index_fault) == 1:\n                                moment_rate_i = 0.0\n                                for index in index_fault:\n                                    for loop_spending in range(nb_loop_spending):\n                                        M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                    faults_budget[index] += -1 * nb_loop_spending\n                                    sum_fault_budget += -1 * nb_loop_spending\n                                    slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                                rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                            else:\n                                moment_rate_i = 0.0\n                                for loop_spending in range(nb_loop_spending):\n                                    (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                    rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                    rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                    moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                            moment_rate_in_bin[picked_bin] += moment_rate_i\n                            Total_moment_rate_fault += moment_rate_i\n                        else:\n                            rup_in_bin[picked_bin] = []\n                            if not picked_bin in bin_target_reached:\n                                bin_target_reached.append(picked_bin)\n                    else:\n                        if uniform_spending == True or len(index_fault) == 1:\n                            moment_rate_i = 0.0\n                            for index in index_fault:\n                                for loop_spending in range(nb_loop_spending):\n                                    M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                faults_budget[index] += -1 * nb_loop_spending\n                                sum_fault_budget += -1 * nb_loop_spending\n                                slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                            rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                            rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                            moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                        else:\n                            moment_rate_i = 0.0\n                            for loop_spending in range(nb_loop_spending):\n                                (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                        moment_rate_in_bin[picked_bin] += moment_rate_i\n                        Total_moment_rate_fault += moment_rate_i\n                time_spending_dsr += time.time() - tmp\n            elif not picked_bin in empty_bins:\n                empty_bins.append(picked_bin)\n            tmp = time.time()\n            if number_of_loops > number_of_loops_before + 500:\n                number_of_loops_before = number_of_loops\n                for index_mag in range(len(bin_mag)):\n                    if not index_mag in empty_bins:\n                        nb_rup_not_empty = 0\n                        for i_rup in rup_in_bin[index_mag]:\n                            if nb_rup_not_empty == 0:\n                                rup_is_empty = False\n                                for index_fault in rup_rates.get(str(i_rup)).get('involved_faults'):\n                                    if faults_budget[index_fault] <= 0:\n                                        rup_is_empty = True\n                                if rup_is_empty == False:\n                                    nb_rup_not_empty += 1\n                        if nb_rup_not_empty == 0:\n                            empty_bins.append(index_mag)\n            time_checking_empty_bin += time.time() - tmp\n            tmp = time.time()\n            len_faults_budget.append(sum_fault_budget)\n            if len(len_faults_budget) > 3:\n                if len_faults_budget[-2] == len_faults_budget[-1]:\n                    number_of_loops_for_nothing += 1\n                if number_of_loops_for_nothing_before < number_of_loops_for_nothing - 100:\n                    number_of_loops_for_nothing_before = number_of_loops_for_nothing\n                    if len_faults_budget[-1] == len_faults_budget[-10]:\n                        rup_still_used = [i for i in rup_in_bin[picked_bin] if not i in empty_rups]\n                        fault_still_used = []\n                        for rup_i in rup_still_used:\n                            fault_still_used += list(rup_rates.get(str(rup_i)).get('involved_faults'))\n                        fault_still_used = set(fault_still_used)\n                        for (fault, index_fault) in zip(faults_names, range(len(faults_names))):\n                            if not index_fault in fault_still_used and faults_budget[index_fault] > 0:\n                                while faults_budget[index_fault] > 0:\n                                    ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                                    if ratio_done > 0.01:\n                                        (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                                    faults_budget[index_fault] += -1\n                                    sum_fault_budget += -1\n                                    M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                                    aseismic_count += 1\n            time_checking_empty_faults += time.time() - tmp\n        else:\n            print('-target filled-')\n            self.calculation_log_file.write('\\n-target filled-')\n            while sum_fault_budget != 0:\n                ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                if ratio_done > 0.01:\n                    (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                for index_fault in range(len(faults_names)):\n                    if faults_budget[index_fault] > 0:\n                        faults_budget[index_fault] += -1\n                        sum_fault_budget += -1\n                        M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                        aseismic_count += 1\n    ' check if the TARGET as been set.\\n        if not, build it for comparing'\n    if TARGET == []:\n        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n        print('- target set at the end- ')\n        self.calculation_log_file.write('\\n- target set at the end - ')\n        rate_at_target_setting = rate_tot_model\n        rate_Mmax = np.mean(rate_tot_model[-3:])\n        for t_mag_bin in range(len(bin_mag)):\n            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n    '##################################################################\\n        #\\n        # Definition of the background seismicity\\n        #\\n        ##################################################################'\n    (rate_f_in_model, rate_bg_in_model) = rates.get_rate_faults_n_bg(rup_rates, fault_prop, bin_mag)\n    EQ_rate_BG = rate_bg_in_model\n    '##################################################################\\n        # printing\\n        ##################################################################'\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    model_MFD.append(rate_tot_model)\n    colors = ['gainsboro', 'darkgray', 'dimgray', 'dimgray', 'black', 'red']\n    index_color = 0\n    for MFD_i in model_MFD:\n        plt.plot(bin_mag, MFD_i, color=colors[index_color])\n        index_color += 1\n    if do_the_target == True:\n        rate_at_target_setting = model_MFD[-1]\n    plt.plot(bin_mag, rate_at_target_setting, ':g')\n    plt.plot(bin_mag, TARGET, ':b')\n    plt.scatter(bin_mag[-3:], rate_tot_model[-3:], c='k')\n    plt.yscale('log')\n    plt.savefig(self.pathlog + '/Log_target_fit_' + str(self.sample) + '.png', dpi=180, transparent=True)\n    plt.close()\n    index_5 = 0\n    while bin_mag[index_mag] < 5.0:\n        index_5 += 1\n    self.ratio_test = np.mean([abs(TARGET[index_5 + 0] / rate_tot_model[index_5 + 0]), abs(TARGET[index_5 + 1] / rate_tot_model[index_5 + 1]), abs(TARGET[index_5 + 2] / rate_tot_model[index_5 + 2]), abs(TARGET[index_5 + 3] / rate_tot_model[index_5 + 3]), abs(TARGET[index_5 + 4] / rate_tot_model[index_5 + 4])])\n    MFD_to_test = rate_tot_model / sum(rate_tot_model)\n    target_to_test = TARGET / sum(TARGET)\n    array_absolute_ratio = []\n    for index_mag in range(len(bin_mag)):\n        array_absolute_ratio.append(abs(MFD_to_test[index_mag] / target_to_test[index_mag]))\n    self.ratio_test = np.mean(array_absolute_ratio)\n    print('ratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    self.calculation_log_file.write('\\nratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    '##################################################################\\n        #\\n        # OUTPUT for Source_model_creator\\n        #\\n        ##################################################################'\n    self.OQ_entry_faults = []\n    self.OQ_entry_scenarios = []\n    for i in range(len(faults_names)):\n        self.OQ_entry_faults.append(rup_rates.get(str(i)).get('rates'))\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            self.OQ_entry_scenarios.append(rup_rates.get(str(i_end + j)).get('rates'))\n    self.faults_names = faults_names\n    self.scenarios_names = scenarios_names\n    self.EQ_rate_BG = EQ_rate_BG\n    self.bin_mag = bin_mag\n    self.rup_rates = rup_rates\n    self.M_slip_repartition = M_slip_repartition\n    log_calculation_file.write('Moment_rate_faults_final calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.write('Ratio of NMS slip rate counted in the iterative process: ' + '\\t' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))) + '\\t %\\n')\n    log_calculation_file.write('Moment_rate_model calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.close()\n    self.ratio_NMS = round(100.0 * (1.0 - Total_moment_rate_fault / Total_moment_faults_rate_init))\n    print('ratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    self.calculation_log_file.write('\\nratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    f = open(log_sliprep_file, 'wb')\n    pickle.dump(M_slip_repartition, f)\n    f.close()",
            "def initialize(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    faults_shear_mod = self.faults_shear_mod\n    mfd_param = self.mfd_param\n    M_min = self.M_min\n    Mmax_range = self.Mmax_range\n    inti_core_time = time.time()\n    faults_names = self.faults_names\n    faults_areas = self.faults_area\n    faults_length = self.faults_length\n    faults_width = self.faults_width\n    faults_slip_rates = self.faults_slip_rates\n    log_calculation_file = open(self.pathlog + '/calculation_sample_' + str(self.sample) + '.txt', 'w')\n    log_sliprep_file = self.pathlog + '/sliprep_sample_' + str(self.sample) + '.pkl'\n    re_use = True\n    scenarios_names = self.scenarios\n    run_name = self.Run_Name\n    model_name = self.branch['model']\n    scl_name = self.branch['scl'][0] + '_' + self.branch['scl'][1] + '_' + self.branch['scl'][2]\n    set_name = self.branch['set']\n    f_mmax = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_mmax_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_mmax):\n        re_use = False\n    if re_use == False:\n        print('Building scenarios and Mmax')\n        '##################################################################\\n            # finds the faults belonging to each scenario\\n            ##################################################################'\n        index_faults_in_scenario = []\n        for scenario in scenarios_names:\n            i_scenario = []\n            for i in range(len(scenario)):\n                i_scenario = i_scenario + list(np.where(np.array(faults_names) == scenario['f_%s' % str(i + 1)]))\n            i_scenario = np.reshape(i_scenario, (1, len(scenario)))\n            index_faults_in_scenario.append(i_scenario)\n        self.index_faults_in_scenario = index_faults_in_scenario\n        faults_alone = []\n        faults_isolated = []\n        len_max_section_scenario = 0\n        for indexes in index_faults_in_scenario:\n            if len(indexes[0]) > len_max_section_scenario:\n                len_max_section_scenario = len(indexes[0])\n        index_fault = 0\n        for fault_name in faults_names:\n            fault_alone_bool = True\n            fault_isolated_bool = True\n            for indexes in index_faults_in_scenario:\n                if index_fault in indexes[0]:\n                    fault_alone_bool = False\n                    if len(indexes[0]) > len_max_section_scenario / 2.0:\n                        fault_isolated_bool = False\n            if fault_isolated_bool == True and fault_alone_bool == False:\n                faults_isolated.append(index_fault)\n            if fault_alone_bool == True:\n                faults_alone.append(index_fault)\n            index_fault += 1\n        '##################################################################\\n            # area and length of each scenario\\n            ##################################################################'\n        scenario_area = []\n        index_faults_in_scenario_for_scl = []\n        for indexes_i in index_faults_in_scenario:\n            list_of_points = []\n            index_for_scenario = []\n            for index_fault in indexes_i[0]:\n                list_i = str(self.faults_lon[index_fault][0]) + str(self.faults_lon[index_fault][-1]) + str(self.faults_lat[index_fault][0]) + str(self.faults_lat[index_fault][-1])\n                if not list_i in list_of_points:\n                    list_of_points.append(list_i)\n                    index_for_scenario.append(index_fault)\n            index_faults_in_scenario_for_scl.append(index_for_scenario)\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_area = np.sum(np.take(faults_areas, i))\n            scenario_area.append(scenario_i_area)\n        scenario_length = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_length = np.sum(np.take(faults_length, i))\n            scenario_length.append(scenario_i_length)\n        scenario_width = []\n        for i in index_faults_in_scenario_for_scl:\n            scenario_i_width = np.mean(np.take(faults_width, i))\n            scenario_width.append(scenario_i_width)\n        '\\n            check the max dimention for a single fault according to the\\n            aspect ratio\\n            '\n        (f_len_ar, f_width_ar, f_area_ar) = ([], [], [])\n        ar = self.param['main']['parameters']['aspect_ratio']\n        for (l, w) in zip(self.faults_length, self.faults_width):\n            if l < w * ar:\n                f_len_ar.append(l)\n                f_width_ar.append(l * ar)\n                f_area_ar.append(l * l * ar)\n            else:\n                f_len_ar.append(l)\n                f_width_ar.append(w)\n                f_area_ar.append(l * w)\n        '##################################################################\\n            #####################################################################\\n            #\\n            # setting up the coefficients for the scalling law\\n            # and calculate the Mmax\\n            #\\n            #####################################################################\\n            ##################################################################'\n        Mmaxmin = Mmax_range[0]\n        Mmaxmax = Mmax_range[1]\n        Mmax = -1.0\n        loop_Mmax = 1\n        while Mmax < Mmaxmin or Mmax > Mmaxmax:\n            log_Mmax_file = open(self.param['dirpath'] + run_name + '/LOG/' + model_name + '_Log_Mmax_sample_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.txt', 'w')\n            if loop_Mmax == 1:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, self.sample)\n            else:\n                Mmaxs = scalling_laws.Calc_Mmax(f_area_ar, scenario_area, f_len_ar, scenario_length, f_width_ar, scenario_width, self.selected_ScL, self.dimention_used, self.use_all_ScL_data, self.faults_mecanism, index_faults_in_scenario, 10)\n            Mmax_faults = Mmaxs.Mmax_faults\n            Mmax_scenario = Mmaxs.Mmax_scenario\n            final_fault_length = Mmaxs.final_fault_length\n            final_scenario_length = Mmaxs.final_scenario_length\n            index_fault = 0\n            for Mmax_i in Mmax_faults:\n                line = faults_names[index_fault] + '\\t' + str(round(faults_length[index_fault] / 1000.0, 1)) + '\\t' + final_fault_length[index_fault] + '\\t' + str(round(self.faults_width[index_fault], 1)) + '\\t' + str(round(self.faults_area[index_fault] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_fault += 1\n            index_scenario = 0\n            for Mmax_i in Mmax_scenario:\n                line = str(scenarios_names[index_scenario]) + '\\t' + str(round(scenario_length[index_scenario] / 1000.0, 1)) + '\\t' + final_scenario_length[index_scenario] + '\\t' + str(round(scenario_width[index_scenario], 1)) + '\\t' + str(round(scenario_area[index_scenario] / 1000000.0, 1)) + '\\t' + str(Mmax_i) + '\\n'\n                log_Mmax_file.write(line)\n                index_scenario += 1\n            log_Mmax_file.close()\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            loop_Mmax += 1\n            if loop_Mmax == 30:\n                print('An Mmax incompatible with the ruptures is imposed!! Change it in run.info or change the rupture.txt file')\n        if loop_Mmax >= 3:\n            print('Mmax imposed: ' + str(Mmax))\n            self.calculation_log_file.write('\\nMmax imposed: ' + str(Mmax))\n        with open(f_mmax, 'wb') as f:\n            dump_to_file = [Mmax_faults, Mmax_scenario, final_fault_length, final_scenario_length, faults_alone, faults_isolated, index_faults_in_scenario, scenario_area]\n            pickle.dump(dump_to_file, f)\n        print('\\t - scenario and max built')\n    else:\n        print('Reloading Mmax from data file')\n        with open(f_mmax, 'rb') as f:\n            load_from_file = pickle.load(f)\n            Mmax_faults = load_from_file[0]\n            Mmax_scenario = load_from_file[1]\n            final_fault_length = load_from_file[2]\n            final_scenario_length = load_from_file[3]\n            faults_alone = load_from_file[4]\n            faults_isolated = load_from_file[5]\n            index_faults_in_scenario = load_from_file[6]\n            scenario_area = load_from_file[7]\n            if np.size(scenarios_names) == 0:\n                Mmax = max(Mmax_faults)\n            else:\n                Mmax = max((max(Mmax_faults), max(Mmax_scenario)))\n            print('\\t - scenario and max loaded')\n    '##################################################################\\n        #etablish the magnitude bin (0.1)\\n        ##################################################################'\n    bin_mag = np.linspace(M_min, Mmax, int(round(Mmax - M_min, 1) * 10.0 + 1))\n    '#####################################################################\\n        # initializing incremental reccurence of the earthquakes for each rupture and each bin)\\n        #####################################################################'\n    rup_rates = {}\n    index_rup = []\n    for i in range(len(faults_names)):\n        rup_rates.update({str(i): {'rup_id': i, 'rup_name': faults_names[i], 'involved_faults': [i], 'Mmax': Mmax_faults[i], 'area': faults_areas[i], 'rates': np.zeros(len(bin_mag))}})\n        index_rup.append(i)\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            rup_rates.update({str(i_end + j): {'rup_id': i_end + j, 'rup_name': scenarios_names[j], 'involved_faults': index_faults_in_scenario[j][0], 'Mmax': Mmax_scenario[j], 'area': scenario_area[j], 'rates': np.zeros(len(bin_mag))}})\n            index_rup.append(i_end + j)\n    if str(self.sample) == '1':\n        log_rup_file = open(self.pathlog + '/ruptures.txt', 'w')\n        log_rup_file.write('rup_id\\tinvolved_faults\\n')\n        for i in range(len(rup_rates)):\n            log_rup_file.write(str(rup_rates.get(str(i)).get('rup_id')) + '\\t')\n            for j in rup_rates.get(str(i)).get('involved_faults'):\n                log_rup_file.write(str(j) + ' ')\n            log_rup_file.write('\\n')\n        log_rup_file.close()\n    self.index_faults_in_scenario = index_faults_in_scenario\n    '#####################################################################\\n        # For each bin, find which fault and which scenario populates it.\\n        #####################################################################'\n    f_bin_pop = self.param['dirpath'] + run_name + '/LOG/' + model_name + '_bin_pop_' + scl_name + '_' + set_name + '_' + str(self.sample) + '.pkl'\n    if not os.path.isfile(f_bin_pop):\n        re_use = False\n    rup_in_bin = populate_bins.pop(bin_mag, index_rup, rup_rates, M_min, re_use, f_bin_pop)\n    '##################################################################\\n        # Definition of the background - how much is not on the faults\\n        ##################################################################'\n    bin_mag_fault_prop = [4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0]\n    fault_prop_inc = self.bg_ratio\n    bin_mag_fault_prop.append(10.0)\n    fault_prop_inc = np.append(np.array(fault_prop_inc), 1.0)\n    fault_prop = interp1d(bin_mag_fault_prop, fault_prop_inc)\n    self.fault_prop = fault_prop\n    '##################################################################\\n        #Calculation of the total moment rate sum(slip-rate)*sum(area) + moment in the background\\n        ##################################################################'\n    Total_moment_faults_rate_init = 0.0\n    index_fault = 0\n    for fault_area in faults_areas:\n        Total_moment_faults_rate_init += faults_shear_mod[index_fault] * fault_area * faults_slip_rates[index_fault]\n        index_fault += 1\n    log_calculation_file.write('Moment_rate_fault_initial calculated using muAs' + '\\t' + str(Total_moment_faults_rate_init) + '\\t' + 'N.m' + '\\n')\n    Total_moment_rate_fault = 0.0\n    '##################################################################\\n        #etablish the target regional distribution\\n        ##################################################################'\n    if self.mfd_hyp == 'GR':\n        p_MFD = mfd_shape.GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'tapered_GR':\n        mfd_param['M_corner'] = Mmax - 0.4\n        p_MFD = mfd_shape.tapered_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'double_GR':\n        p_MFD = mfd_shape.double_GR(mfd_param, bin_mag)\n    elif self.mfd_hyp == 'YC':\n        p_MFD = mfd_shape.YC(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_marmara':\n        p_MFD = mfd_shape.YC_marmara(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'YC_modified':\n        p_MFD = mfd_shape.YC_modified(mfd_param, bin_mag, Mmax)\n    elif self.mfd_hyp == 'UCERF_DV':\n        p_MFD = mfd_shape.UCERF_DV(bin_mag)\n    else:\n        print('Error : Unknown MFD name!')\n    p_MFD = p_MFD / sum(p_MFD)\n    '##################################################################\\n        # Converting in term of moment\\n        ##################################################################'\n    p_MFD_MO = []\n    index_mag = 0\n    for mag in bin_mag:\n        M0 = mag_to_M0(mag)\n        p_MFD_MO.append(fault_prop(mag) * p_MFD[index_mag] * M0)\n        index_mag += 1\n    p_MFD_MO = p_MFD_MO / sum(p_MFD_MO)\n    '##################################################################\\n        # Adding the moment rate of the background to the Total_moment_rate_init\\n        ##################################################################'\n    Total_moment_rate_init = Total_moment_faults_rate_init\n    index_mag = 0\n    for mag in bin_mag:\n        moment_rate_fault_bin = p_MFD_MO[index_mag] * Total_moment_faults_rate_init\n        moment_rate_BG_bin = (1 - fault_prop(mag)) * moment_rate_fault_bin / fault_prop(mag)\n        Total_moment_rate_init += moment_rate_BG_bin\n        index_mag += 1\n    '##################################################################\\n        # Etablish the target of moment rate per bin\\n        ##################################################################'\n    target_moment_per_bin = p_MFD_MO * Total_moment_faults_rate_init\n    '##################################################################\\n        # Create the sliprate budget dictionary\\n        # This matrix contain a list of the fault name. each name is repeted\\n        # by a number of time depending of the slip-rate of the fault.\\n        ##################################################################'\n    size_of_increment = float(self.size_of_increment) * 0.001\n    if self.count_reruns != 1:\n        size_of_increment = size_of_increment / (float(self.count_reruns) * 1.5 - 1.0)\n    faults_budget = {}\n    for index_fault in range(len(faults_names)):\n        nb_dsr = int(round(faults_slip_rates[index_fault] / size_of_increment, 0))\n        if nb_dsr == 0:\n            nb_dsr = 1\n        faults_budget.update({index_fault: nb_dsr})\n    min_budget = float(min(faults_budget.values())) + 1\n    max_budget = float(max(faults_budget.values()))\n    while max_budget / min_budget > 50.0:\n        min_budget *= 2.0\n    '##################################################################\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        #   Populate the bin of magnitude of each fault and each scenario\\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\\n        ##################################################################'\n    M_slip_repartition = {}\n    for (fault, i) in zip(faults_names, range(len(faults_names))):\n        dic_tmp = {}\n        for rup_i in range(len(rup_rates)):\n            if i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                dic_tmp.update({str(rup_i): 0})\n        dic_tmp.update({'NMS': 0})\n        M_slip_repartition.update({str(fault): dic_tmp})\n    moment_rate_in_bin = np.zeros(len(bin_mag))\n    model_MFD = []\n    number_of_loops = 0\n    number_of_loops_before = 0\n    number_of_loops_for_nothing = 0\n    number_of_loops_for_nothing_before = 0\n    number_of_loops_last_checked = -1\n    empty_bins = []\n    empty_rups = []\n    bin_target_reached = []\n    len_faults_budget = []\n    aseismic_count = 0\n    color_mag = []\n    '######################\\n        #####   MAIN LOOP   #####\\n        ######################'\n    TARGET = []\n    nb_ss_to_spend = float(sum(faults_budget.values()))\n    sum_fault_budget = nb_ss_to_spend\n    print('Number of dsr to spend : ' + str(nb_ss_to_spend))\n    print('Min of sdr :', min(faults_budget.values()))\n    print('Max of sdr :', max(faults_budget.values()))\n    self.calculation_log_file.write('\\nnumber of dsr to spend : ' + str(nb_ss_to_spend) + '\\n')\n    print_percent = True\n    do_the_target = True\n    bool_target_set = False\n    uniform_spending = self.param['main']['parameters']['uniform_spending']\n    if uniform_spending in ['True', 'true']:\n        uniform_spending = True\n    else:\n        uniform_spending = False\n    deep_analysis = self.param['main']['parameters']['deep_analysis']\n    if deep_analysis in ['True', 'true']:\n        deep_analysis = True\n    else:\n        deep_analysis = False\n    faster_rup_weight = self.param['main']['parameters']['faster_rup_weight']\n    if faster_rup_weight in ['True', 'true']:\n        faster_rup_weight = True\n    else:\n        faster_rup_weight = False\n    option_fast = self.param['main']['parameters']['option_fast']\n    if option_fast in ['True', 'true']:\n        option_fast = True\n    else:\n        option_fast = False\n    local_MFD = self.param['main']['parameters']['local_MFD']\n    if local_MFD in ['True', 'true']:\n        f_mfd_area = self.param['main']['local_MFD_file']\n        (local_mfds, associated_rup, associated_weight) = core_utils.link_rup_mfd_area(rup_rates, f_mfd_area, self.faults_lon, self.faults_lat, bin_mag, self.bg_ratio)\n    time_weight_rupt = 0.0\n    time_clean_w_rupt = 0.0\n    time_target_building = 0.0\n    time_checking_target_reach = 0.0\n    time_spending_dsr = 0.0\n    time_checking_empty_bin = 0.0\n    time_checking_empty_faults = 0.0\n    budget_init = int(sum_fault_budget)\n    if faster_rup_weight == True:\n        nb_weigthings_rup_sampling = int(self.param['main']['parameters']['nb_weigthings_rup_sampling'])\n        if 'type_weigthings_rup_sampling' in self.param['main']['parameters'].keys():\n            type_weigthings_rup_sampling = self.param['main']['parameters']['type_weigthings_rup_sampling']\n        else:\n            type_weigthings_rup_sampling = 'lin'\n        if type_weigthings_rup_sampling == 'log':\n            weigthing_built = [int(i) for i in np.logspace(0.0, np.log10(budget_init), nb_weigthings_rup_sampling)]\n        if type_weigthings_rup_sampling == 'lin':\n            weigthing_built = [int(i) for i in np.linspace(0.0, budget_init, nb_weigthings_rup_sampling)]\n    else:\n        weigthing_built = [int(i) for i in range(budget_init)]\n    weigthing_built.reverse()\n    weigth_rup_sample = 0\n    slip_rate_use_per_fault = np.zeros(len(faults_names))\n    moment_rate_required = 0.0\n    moment_rate_left = Total_moment_faults_rate_init\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    rate_in_model = np.zeros(len(bin_mag))\n    test_mean_picked = []\n    most_likely_pick = []\n    n_w_work = 0\n    n_w_crash = 0\n    loop_last_rup_w = 0\n    picked_empty_rup = 0\n    old_percent = '0000'\n    while sum_fault_budget > 0:\n        ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n        if ratio_done > 0.01:\n            (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n        number_of_loops += 1\n        if len(empty_bins) != len(bin_mag):\n            ' Calculate the new target shape in each bin in terms of moment rate '\n            tmp = time.time()\n            target_i = target.get_new_target(number_of_loops, moment_rate_in_bin, p_MFD_MO, target_moment_per_bin, bin_mag, empty_bins, bin_target_reached, rup_in_bin)\n            time_target_building += time.time() - tmp\n            if sum(target_i) == 0.0:\n                target_i = p_MFD_MO\n            try:\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            except:\n                print(target_i)\n                most_likely_pick.append(bin_mag[list(target_i).index(max(list(target_i)))])\n            if deep_analysis == True:\n                percent = round((1.0 - float(sum_fault_budget) / float(nb_ss_to_spend)) * 100.0)\n                percent = '{:04d}'.format(percent)\n                if percent != old_percent:\n                    old_percent = percent\n                    print('\\nnumber_of_loops', number_of_loops)\n                    print('budget left : ', sum_fault_budget, ' | ', percent, '%')\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time building target at time i : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_weight_rupt)\n                    print('time weighting rupture pick : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_clean_w_rupt)\n                    print('time cleaning weighting rupture weigth : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_target_reach)\n                    print('time checking target reach : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_bin)\n                    print('time checking empty bins : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_checking_empty_faults)\n                    print('time checking empty faults : ', time_str)\n                    time_str = core_utils.seconds_to_str(time_target_building)\n                    print('time spending dsr : ', time_str)\n                    time_str = core_utils.seconds_to_str(time.time() - inti_core_time)\n                    print('total core time : ', time_str)\n                    tot_core_time = time.time() - inti_core_time\n                    unaccounted_t = tot_core_time - (time_target_building + time_weight_rupt + time_clean_w_rupt + time_checking_target_reach + time_checking_empty_bin + time_checking_empty_faults + time_spending_dsr)\n                    time_str = core_utils.seconds_to_str(unaccounted_t)\n                    print('unaccounted time : ', time_str)\n                    print('max target : ', round(max(target_i), 4), '| last bin w : ', str(round(target_i[-1], 6)))\n                    print('Empty mag bins:')\n                    print(empty_bins)\n                    budget_last_bin = 0\n                    for rup_i in rup_in_bin[-1]:\n                        if not str(rup_i) in empty_rups:\n                            for f_i in rup_rates.get(str(rup_i)).get('involved_faults'):\n                                budget_last_bin += faults_budget[f_i]\n                    print('fault budget last bin :', budget_last_bin)\n                    (fig, (ax0, ax1)) = plt.subplots(ncols=2)\n                    ax0.plot(bin_mag, target_i, label='target_i', marker='x')\n                    ax0.plot(bin_mag, p_MFD_MO, label='p_MFD_MO', marker='x')\n                    ax0.legend()\n                    ax1.plot(bin_mag, target_moment_per_bin, label='target_moment_per_bin', marker='x')\n                    ax1.plot(bin_mag, moment_rate_in_bin, label='moment_rate_in_bin', marker='x')\n                    ax1.set_yscale('log')\n                    ax1.legend()\n                    plt.savefig(self.pathlog + '/Log_tmp_' + str(self.sample) + '.png', dpi=80, transparent=True)\n                    plt.close()\n            'Pick the bin of magnitude to fill according to the current distribution '\n            target_i = target_i / sum(target_i)\n            picked_bin = np.random.choice(len(bin_mag), 1, p=target_i)[0]\n            mag = bin_mag[picked_bin]\n            tmp = time.time()\n            if not picked_bin in empty_bins:\n                empty_in_bin = set(rup_in_bin[picked_bin]) & set(empty_rups)\n                if len(empty_in_bin) == len(rup_in_bin[picked_bin]):\n                    empty_bins.append(picked_bin)\n            time_checking_empty_bin += time.time() - tmp\n            if not picked_bin in empty_bins:\n                tmp = time.time()\n                'Calculate the weight for sampling of the fault or scenario'\n                do_rup_weight = False\n                if number_of_loops == 1:\n                    do_rup_weight = True\n                if sum_fault_budget < weigthing_built[weigth_rup_sample]:\n                    do_rup_weight = True\n                if do_rup_weight == True:\n                    loop_last_rup_w = number_of_loops\n                    weigth_rup_sample += 1\n                    if faster_rup_weight == True:\n                        list_of_bins = range(len(bin_mag))\n                    else:\n                        list_of_bins = [picked_bin]\n                    w_rup_binmag = []\n                    for index_mag in list_of_bins:\n                        if index_mag in empty_bins:\n                            w_rup_binmag.append([])\n                        else:\n                            weight_rup_i = core_utils.weight_fault_sampling(index_mag, rup_in_bin, faults_names, faults_slip_rates, slip_rate_use_per_fault, faults_alone, scenarios_names, faults_isolated, index_faults_in_scenario, rup_rates, empty_rups)\n                            if local_MFD == True:\n                                factor_on_weight = core_utils.check_local_mfd(rup_rates, rup_in_bin[index_mag], index_mag, bin_mag, local_mfds, associated_rup, associated_weight)\n                                weight_rup_i = np.array([i * w for (i, w) in zip(weight_rup_i, factor_on_weight)])\n                                weight_rup_i /= weight_rup_i.sum()\n                            if sum(weight_rup_i) != 0.0:\n                                weight_rup_i = [float(i) / sum(weight_rup_i) for i in weight_rup_i]\n                            w_rup_binmag.append(weight_rup_i)\n                    time_weight_rupt += time.time() - tmp\n                    tmp = time.time()\n                    for index_mag in list_of_bins:\n                        if not index_mag in empty_bins:\n                            weight_rup = w_rup_binmag[index_mag]\n                            if set(rup_in_bin[index_mag]) & set(empty_rups):\n                                i = 0\n                                for i_rup in rup_in_bin[index_mag]:\n                                    if str(i_rup) in empty_rups:\n                                        weight_rup[i] = 0.0\n                                    i += 1\n                            weight_rup = list(weight_rup)\n                            sum_weight_rup = sum(weight_rup)\n                            if sum(weight_rup) == 0.0:\n                                empty_bins.append(index_mag)\n                            if not index_mag in empty_bins:\n                                if sum_weight_rup != 1.0:\n                                    weight_rup = [float(i) / sum_weight_rup for i in weight_rup]\n                                if math.isnan(sum(weight_rup)):\n                                    print('WARNING : sum rup weight is nan')\n                                    nb_nans = 0\n                                    id = 0\n                                    for i in weight_rup:\n                                        if math.isnan(i):\n                                            nb_nans += 1\n                                        weight_rup[id] = 0.0\n                                        id += 1\n                            w_rup_binmag[index_mag] = weight_rup\n                    time_clean_w_rupt += time.time() - tmp\n                if faster_rup_weight == True:\n                    weight_rup = w_rup_binmag[picked_bin]\n                else:\n                    weight_rup = w_rup_binmag[0]\n                try:\n                    i_picked = np.where(np.random.multinomial(1, weight_rup) == 1)[0][0]\n                    picked_rup = rup_in_bin[picked_bin][i_picked]\n                except ValueError:\n                    print(\"rupt weights didn't work. sum:\", sum(weight_rup))\n                    picked_rup = np.random.choice(rup_in_bin[picked_bin])\n                    n_w_crash += 1\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                if bool_target_set == False:\n                    tmp = time.time()\n                    last_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-3:]:\n                        if not bin_i in empty_bins:\n                            last_bins_empty = False\n                    if last_bins_empty == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        bool_target_set = True\n                        print('set target - limit on the largest magnitudes')\n                    if moment_rate_left <= (1.0 - 1e-05) * moment_rate_required:\n                        self.calculation_log_file.write('\\n Not enough moment left ')\n                        for rup_i in rup_in_bin[-3] + rup_in_bin[-2] + rup_in_bin[-1]:\n                            if not str(rup_i) in empty_rups:\n                                empty_rups.append(str(rup_i))\n                        rup_in_bin[-3] = []\n                        rup_in_bin[-2] = []\n                        rup_in_bin[-1] = []\n                        bool_target_set = True\n                        print('set target - moment rate is limiting')\n                    antelast_bins_empty = True\n                    for bin_i in range(len(bin_mag))[-2:]:\n                        if not bin_i in empty_bins:\n                            antelast_bins_empty = False\n                    if antelast_bins_empty == True and bool_target_set == False:\n                        if moment_rate_in_bin[-3] >= 2.0 * (moment_rate_in_bin[-2] + moment_rate_in_bin[-1]):\n                            self.calculation_log_file.write('\\n antepenultimate bin getting too high')\n                            for rup_i in rup_in_bin[-3]:\n                                if not str(rup_i) in empty_rups:\n                                    empty_rups.append(str(rup_i))\n                            empty_bins.append(range(len(bin_mag))[-3])\n                            bool_target_set = True\n                            print('set target - antepenultimate bin getting too high')\n                    if number_of_loops > number_of_loops_last_checked + 50.0:\n                        number_of_loops_last_checked = number_of_loops\n                        moment_rate_left = Total_moment_faults_rate_init - Total_moment_rate_fault\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        rate_Mmax_check = np.mean(rate_tot_model[-3:])\n                        moment_rate_required = 0.0\n                        for index_mag in range(len(bin_mag) - 3):\n                            rate_Mi_check = rate_tot_model[index_mag]\n                            target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-2]\n                            moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            moment_rate_required = 0.0\n                            for index_mag in range(len(bin_mag) - 3):\n                                rate_Mi_check = rate_tot_model[index_mag]\n                                target_GR_i_check = rate_Mmax_check * p_MFD[index_mag] / p_MFD[-3]\n                                moment_rate_required += (mag_to_M0(bin_mag[index_mag]) * target_GR_i_check - mag_to_M0(bin_mag[index_mag]) * rate_Mi_check) * fault_prop(bin_mag[picked_bin])\n                    time_checking_target_reach += time.time() - tmp\n                    if do_the_target == True and bool_target_set == True:\n                        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n                        do_the_target = False\n                        print('- target set - ')\n                        self.calculation_log_file.write('\\n- target set - ')\n                        rate_at_target_setting = rate_tot_model\n                        rate_Mmax = np.mean(rate_tot_model[-3:])\n                        TARGET = []\n                        for t_mag_bin in range(len(bin_mag)):\n                            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n                        if self.mfd_hyp == 'UCERF_DV_':\n                            rate_Mmax = rate_tot_model[-1]\n                            TARGET = []\n                            for t_mag_bin in range(len(bin_mag)):\n                                rate_Mi = rate_tot_model[t_mag_bin]\n                                TARGET.append(rate_Mmax * p_MFD[picked_bin] / p_MFD[-3])\n                if picked_bin in bin_target_reached:\n                    print('WHAT ARE YOU DOING HERE?', bin_mag[picked_bin])\n                    exit()\n                ' spending the slip_rate increment '\n                tmp = time.time()\n                index_fault = rup_rates.get(str(picked_rup)).get('involved_faults')\n                sr_to_spend = True\n                shear_mod = 0\n                for index in index_fault:\n                    shear_mod += faults_shear_mod[index]\n                    if faults_budget[index] <= 0.0:\n                        sr_to_spend = False\n                if sr_to_spend == False:\n                    if not str(picked_rup) in empty_rups:\n                        empty_rups.append(str(picked_rup))\n                    else:\n                        picked_empty_rup += 1\n                if sr_to_spend == True:\n                    shear_mod = shear_mod / float(len(index_fault))\n                    area = rup_rates.get(str(picked_rup)).get('area')\n                    displacement = mag_to_M0(mag) / (shear_mod * area)\n                    rate_i = size_of_increment / displacement\n                    if option_fast == True:\n                        min_budget_local = min([faults_budget[i] for i in index_fault])\n                        nb_loop_spending = int(min_budget_local / min_budget)\n                        if nb_loop_spending < 1:\n                            nb_loop_spending = 1\n                    else:\n                        nb_loop_spending = 1\n                    if bool_target_set == True:\n                        rate_Mi = rate_in_model[picked_bin]\n                        target_mfd_i = TARGET[picked_bin] * fault_prop(bin_mag[picked_bin])\n                        if rate_Mi < target_mfd_i:\n                            if uniform_spending == True or len(index_fault) == 1:\n                                moment_rate_i = 0.0\n                                for index in index_fault:\n                                    for loop_spending in range(nb_loop_spending):\n                                        M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                    faults_budget[index] += -1 * nb_loop_spending\n                                    sum_fault_budget += -1 * nb_loop_spending\n                                    slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                                rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                            else:\n                                moment_rate_i = 0.0\n                                for loop_spending in range(nb_loop_spending):\n                                    (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                    rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                    rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                    moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                            moment_rate_in_bin[picked_bin] += moment_rate_i\n                            Total_moment_rate_fault += moment_rate_i\n                        else:\n                            rup_in_bin[picked_bin] = []\n                            if not picked_bin in bin_target_reached:\n                                bin_target_reached.append(picked_bin)\n                    else:\n                        if uniform_spending == True or len(index_fault) == 1:\n                            moment_rate_i = 0.0\n                            for index in index_fault:\n                                for loop_spending in range(nb_loop_spending):\n                                    M_slip_repartition[str(faults_names[index])][str(picked_rup)] += 1\n                                faults_budget[index] += -1 * nb_loop_spending\n                                sum_fault_budget += -1 * nb_loop_spending\n                                slip_rate_use_per_fault[index] += size_of_increment * nb_loop_spending\n                            rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_loop_spending\n                            rate_in_model[picked_bin] += rate_i * nb_loop_spending\n                            moment_rate_i += mag_to_M0(mag) * rate_i * nb_loop_spending\n                        else:\n                            moment_rate_i = 0.0\n                            for loop_spending in range(nb_loop_spending):\n                                (M_slip_repartition, faults_budget, slip_rate_use_per_fault, nb_sdr_used, sum_fault_budget) = core_utils.variable_spending(index_fault, M_slip_repartition, faults_budget, slip_rate_use_per_fault, size_of_increment, faults_slip_rates, picked_rup, faults_names, sum_fault_budget)\n                                rup_rates[str(picked_rup)]['rates'][picked_bin] += rate_i * nb_sdr_used\n                                rate_in_model[picked_bin] += rate_i * nb_sdr_used\n                                moment_rate_i += mag_to_M0(mag) * rate_i * nb_sdr_used\n                        moment_rate_in_bin[picked_bin] += moment_rate_i\n                        Total_moment_rate_fault += moment_rate_i\n                time_spending_dsr += time.time() - tmp\n            elif not picked_bin in empty_bins:\n                empty_bins.append(picked_bin)\n            tmp = time.time()\n            if number_of_loops > number_of_loops_before + 500:\n                number_of_loops_before = number_of_loops\n                for index_mag in range(len(bin_mag)):\n                    if not index_mag in empty_bins:\n                        nb_rup_not_empty = 0\n                        for i_rup in rup_in_bin[index_mag]:\n                            if nb_rup_not_empty == 0:\n                                rup_is_empty = False\n                                for index_fault in rup_rates.get(str(i_rup)).get('involved_faults'):\n                                    if faults_budget[index_fault] <= 0:\n                                        rup_is_empty = True\n                                if rup_is_empty == False:\n                                    nb_rup_not_empty += 1\n                        if nb_rup_not_empty == 0:\n                            empty_bins.append(index_mag)\n            time_checking_empty_bin += time.time() - tmp\n            tmp = time.time()\n            len_faults_budget.append(sum_fault_budget)\n            if len(len_faults_budget) > 3:\n                if len_faults_budget[-2] == len_faults_budget[-1]:\n                    number_of_loops_for_nothing += 1\n                if number_of_loops_for_nothing_before < number_of_loops_for_nothing - 100:\n                    number_of_loops_for_nothing_before = number_of_loops_for_nothing\n                    if len_faults_budget[-1] == len_faults_budget[-10]:\n                        rup_still_used = [i for i in rup_in_bin[picked_bin] if not i in empty_rups]\n                        fault_still_used = []\n                        for rup_i in rup_still_used:\n                            fault_still_used += list(rup_rates.get(str(rup_i)).get('involved_faults'))\n                        fault_still_used = set(fault_still_used)\n                        for (fault, index_fault) in zip(faults_names, range(len(faults_names))):\n                            if not index_fault in fault_still_used and faults_budget[index_fault] > 0:\n                                while faults_budget[index_fault] > 0:\n                                    ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                                    if ratio_done > 0.01:\n                                        (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                                    faults_budget[index_fault] += -1\n                                    sum_fault_budget += -1\n                                    M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                                    aseismic_count += 1\n            time_checking_empty_faults += time.time() - tmp\n        else:\n            print('-target filled-')\n            self.calculation_log_file.write('\\n-target filled-')\n            while sum_fault_budget != 0:\n                ratio_done = 1.0 - float(sum_fault_budget) / nb_ss_to_spend\n                if ratio_done > 0.01:\n                    (model_MFD, self.calculation_log_file, print_percent) = core_utils.progress(model_MFD, self.calculation_log_file, ratio_done, print_percent, rup_rates, fault_prop, bin_mag)\n                for index_fault in range(len(faults_names)):\n                    if faults_budget[index_fault] > 0:\n                        faults_budget[index_fault] += -1\n                        sum_fault_budget += -1\n                        M_slip_repartition[str(faults_names[index_fault])]['NMS'] += 1\n                        aseismic_count += 1\n    ' check if the TARGET as been set.\\n        if not, build it for comparing'\n    if TARGET == []:\n        rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n        print('- target set at the end- ')\n        self.calculation_log_file.write('\\n- target set at the end - ')\n        rate_at_target_setting = rate_tot_model\n        rate_Mmax = np.mean(rate_tot_model[-3:])\n        for t_mag_bin in range(len(bin_mag)):\n            TARGET.append(rate_Mmax * p_MFD[t_mag_bin] / p_MFD[-2])\n    '##################################################################\\n        #\\n        # Definition of the background seismicity\\n        #\\n        ##################################################################'\n    (rate_f_in_model, rate_bg_in_model) = rates.get_rate_faults_n_bg(rup_rates, fault_prop, bin_mag)\n    EQ_rate_BG = rate_bg_in_model\n    '##################################################################\\n        # printing\\n        ##################################################################'\n    rate_tot_model = rates.get_rate_model(rup_rates, fault_prop, bin_mag)\n    model_MFD.append(rate_tot_model)\n    colors = ['gainsboro', 'darkgray', 'dimgray', 'dimgray', 'black', 'red']\n    index_color = 0\n    for MFD_i in model_MFD:\n        plt.plot(bin_mag, MFD_i, color=colors[index_color])\n        index_color += 1\n    if do_the_target == True:\n        rate_at_target_setting = model_MFD[-1]\n    plt.plot(bin_mag, rate_at_target_setting, ':g')\n    plt.plot(bin_mag, TARGET, ':b')\n    plt.scatter(bin_mag[-3:], rate_tot_model[-3:], c='k')\n    plt.yscale('log')\n    plt.savefig(self.pathlog + '/Log_target_fit_' + str(self.sample) + '.png', dpi=180, transparent=True)\n    plt.close()\n    index_5 = 0\n    while bin_mag[index_mag] < 5.0:\n        index_5 += 1\n    self.ratio_test = np.mean([abs(TARGET[index_5 + 0] / rate_tot_model[index_5 + 0]), abs(TARGET[index_5 + 1] / rate_tot_model[index_5 + 1]), abs(TARGET[index_5 + 2] / rate_tot_model[index_5 + 2]), abs(TARGET[index_5 + 3] / rate_tot_model[index_5 + 3]), abs(TARGET[index_5 + 4] / rate_tot_model[index_5 + 4])])\n    MFD_to_test = rate_tot_model / sum(rate_tot_model)\n    target_to_test = TARGET / sum(TARGET)\n    array_absolute_ratio = []\n    for index_mag in range(len(bin_mag)):\n        array_absolute_ratio.append(abs(MFD_to_test[index_mag] / target_to_test[index_mag]))\n    self.ratio_test = np.mean(array_absolute_ratio)\n    print('ratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    self.calculation_log_file.write('\\nratio between the target and the shape of the model : ' + str(round(self.ratio_test, 2)))\n    '##################################################################\\n        #\\n        # OUTPUT for Source_model_creator\\n        #\\n        ##################################################################'\n    self.OQ_entry_faults = []\n    self.OQ_entry_scenarios = []\n    for i in range(len(faults_names)):\n        self.OQ_entry_faults.append(rup_rates.get(str(i)).get('rates'))\n    i_end = i + 1\n    if np.size(scenarios_names) != 0:\n        for j in range(len(scenarios_names)):\n            self.OQ_entry_scenarios.append(rup_rates.get(str(i_end + j)).get('rates'))\n    self.faults_names = faults_names\n    self.scenarios_names = scenarios_names\n    self.EQ_rate_BG = EQ_rate_BG\n    self.bin_mag = bin_mag\n    self.rup_rates = rup_rates\n    self.M_slip_repartition = M_slip_repartition\n    log_calculation_file.write('Moment_rate_faults_final calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.write('Ratio of NMS slip rate counted in the iterative process: ' + '\\t' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))) + '\\t %\\n')\n    log_calculation_file.write('Moment_rate_model calculated using 10^(1.5M+9.1)' + '\\t' + str(Total_moment_rate_fault) + '\\t' + 'N.m' + '\\n')\n    log_calculation_file.close()\n    self.ratio_NMS = round(100.0 * (1.0 - Total_moment_rate_fault / Total_moment_faults_rate_init))\n    print('ratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    self.calculation_log_file.write('\\nratio of NMS : ' + str(round(100.0 * (aseismic_count / nb_ss_to_spend))))\n    f = open(log_sliprep_file, 'wb')\n    pickle.dump(M_slip_repartition, f)\n    f.close()"
        ]
    }
]