[
    {
        "func_name": "synth_cnotdihedral_general",
        "original": "def synth_cnotdihedral_general(elem):\n    \"\"\"Decompose a CNOTDihedral element into a QuantumCircuit.\n\n    Decompose a general CNOTDihedral elements.\n    The number of CNOT gates is not necessarily optimal.\n    For a decomposition of a 1-qubit or 2-qubit element, call\n    synth_cnotdihedral_two_qubits.\n\n    Args:\n        elem (CNOTDihedral): a CNOTDihedral element.\n\n    Return:\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\n\n    Raises:\n        QiskitError: if the element could not be decomposed into a circuit.\n\n    Reference:\n        1. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\n           *Scalable randomised benchmarking of non-Clifford gates*,\n           npj Quantum Inf 2, 16012 (2016).\n    \"\"\"\n    num_qubits = elem.num_qubits\n    circuit = QuantumCircuit(num_qubits)\n    elem_cpy = elem.copy()\n    if not np.allclose(np.linalg.det(elem_cpy.linear) % 2, 1):\n        raise QiskitError('Linear part is not invertible.')\n    for i in range(num_qubits):\n        if elem.shift[i]:\n            circuit.x(i)\n            elem_cpy._append_x(i)\n    for i in range(num_qubits):\n        if not elem_cpy.linear[i][i]:\n            for j in range(i + 1, num_qubits):\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(j, i)\n                    circuit.cx(i, j)\n                    circuit.cx(j, i)\n                    elem_cpy._append_cx(j, i)\n                    elem_cpy._append_cx(i, j)\n                    elem_cpy._append_cx(j, i)\n                    break\n        for j in range(num_qubits):\n            if j != i:\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(i, j)\n                    elem_cpy._append_cx(i, j)\n    if not (elem_cpy.shift == np.zeros(num_qubits)).all() or not (elem_cpy.linear == np.eye(num_qubits)).all():\n        raise QiskitError('Cannot do Gauss elimination on linear part.')\n    new_elem = elem_cpy.copy()\n    new_elem.poly.weight_0 = 0\n    new_elem.poly.weight_1 = np.zeros(num_qubits, dtype=np.int8)\n    new_elem.poly.weight_2 = np.zeros(int(num_qubits * (num_qubits - 1) / 2), dtype=np.int8)\n    new_elem.poly.weight_3 = np.zeros(int(num_qubits * (num_qubits - 1) * (num_qubits - 2) / 6), dtype=np.int8)\n    new_circuit = QuantumCircuit(num_qubits)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            for k in range(j + 1, num_qubits):\n                if elem_cpy.poly.get_term([i, j, k]) != 0:\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_elem._append_phase(1, k)\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n                    new_circuit.p(np.pi / 4, [k])\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            tpow1 = elem_cpy.poly.get_term([i, j])\n            tpow2 = new_elem.poly.get_term([i, j])\n            tpow = (tpow2 - tpow1) / 2 % 4\n            if tpow != 0:\n                new_elem._append_cx(i, j)\n                new_elem._append_phase(tpow, j)\n                new_elem._append_cx(i, j)\n                new_circuit.cx(i, j)\n                new_circuit.p(tpow * np.pi / 4, [j])\n                new_circuit.cx(i, j)\n    for i in range(num_qubits):\n        tpow1 = elem_cpy.poly.get_term([i])\n        tpow2 = new_elem.poly.get_term([i])\n        tpow = (tpow1 - tpow2) % 8\n        if tpow != 0:\n            new_elem._append_phase(tpow, i)\n            new_circuit.p(tpow * np.pi / 4, [i])\n    if elem.poly != new_elem.poly:\n        raise QiskitError('Could not recover phase polynomial.')\n    inv_circuit = circuit.inverse()\n    return new_circuit.compose(inv_circuit)",
        "mutated": [
            "def synth_cnotdihedral_general(elem):\n    if False:\n        i = 10\n    'Decompose a CNOTDihedral element into a QuantumCircuit.\\n\\n    Decompose a general CNOTDihedral elements.\\n    The number of CNOT gates is not necessarily optimal.\\n    For a decomposition of a 1-qubit or 2-qubit element, call\\n    synth_cnotdihedral_two_qubits.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element could not be decomposed into a circuit.\\n\\n    Reference:\\n        1. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\\n           *Scalable randomised benchmarking of non-Clifford gates*,\\n           npj Quantum Inf 2, 16012 (2016).\\n    '\n    num_qubits = elem.num_qubits\n    circuit = QuantumCircuit(num_qubits)\n    elem_cpy = elem.copy()\n    if not np.allclose(np.linalg.det(elem_cpy.linear) % 2, 1):\n        raise QiskitError('Linear part is not invertible.')\n    for i in range(num_qubits):\n        if elem.shift[i]:\n            circuit.x(i)\n            elem_cpy._append_x(i)\n    for i in range(num_qubits):\n        if not elem_cpy.linear[i][i]:\n            for j in range(i + 1, num_qubits):\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(j, i)\n                    circuit.cx(i, j)\n                    circuit.cx(j, i)\n                    elem_cpy._append_cx(j, i)\n                    elem_cpy._append_cx(i, j)\n                    elem_cpy._append_cx(j, i)\n                    break\n        for j in range(num_qubits):\n            if j != i:\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(i, j)\n                    elem_cpy._append_cx(i, j)\n    if not (elem_cpy.shift == np.zeros(num_qubits)).all() or not (elem_cpy.linear == np.eye(num_qubits)).all():\n        raise QiskitError('Cannot do Gauss elimination on linear part.')\n    new_elem = elem_cpy.copy()\n    new_elem.poly.weight_0 = 0\n    new_elem.poly.weight_1 = np.zeros(num_qubits, dtype=np.int8)\n    new_elem.poly.weight_2 = np.zeros(int(num_qubits * (num_qubits - 1) / 2), dtype=np.int8)\n    new_elem.poly.weight_3 = np.zeros(int(num_qubits * (num_qubits - 1) * (num_qubits - 2) / 6), dtype=np.int8)\n    new_circuit = QuantumCircuit(num_qubits)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            for k in range(j + 1, num_qubits):\n                if elem_cpy.poly.get_term([i, j, k]) != 0:\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_elem._append_phase(1, k)\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n                    new_circuit.p(np.pi / 4, [k])\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            tpow1 = elem_cpy.poly.get_term([i, j])\n            tpow2 = new_elem.poly.get_term([i, j])\n            tpow = (tpow2 - tpow1) / 2 % 4\n            if tpow != 0:\n                new_elem._append_cx(i, j)\n                new_elem._append_phase(tpow, j)\n                new_elem._append_cx(i, j)\n                new_circuit.cx(i, j)\n                new_circuit.p(tpow * np.pi / 4, [j])\n                new_circuit.cx(i, j)\n    for i in range(num_qubits):\n        tpow1 = elem_cpy.poly.get_term([i])\n        tpow2 = new_elem.poly.get_term([i])\n        tpow = (tpow1 - tpow2) % 8\n        if tpow != 0:\n            new_elem._append_phase(tpow, i)\n            new_circuit.p(tpow * np.pi / 4, [i])\n    if elem.poly != new_elem.poly:\n        raise QiskitError('Could not recover phase polynomial.')\n    inv_circuit = circuit.inverse()\n    return new_circuit.compose(inv_circuit)",
            "def synth_cnotdihedral_general(elem):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Decompose a CNOTDihedral element into a QuantumCircuit.\\n\\n    Decompose a general CNOTDihedral elements.\\n    The number of CNOT gates is not necessarily optimal.\\n    For a decomposition of a 1-qubit or 2-qubit element, call\\n    synth_cnotdihedral_two_qubits.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element could not be decomposed into a circuit.\\n\\n    Reference:\\n        1. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\\n           *Scalable randomised benchmarking of non-Clifford gates*,\\n           npj Quantum Inf 2, 16012 (2016).\\n    '\n    num_qubits = elem.num_qubits\n    circuit = QuantumCircuit(num_qubits)\n    elem_cpy = elem.copy()\n    if not np.allclose(np.linalg.det(elem_cpy.linear) % 2, 1):\n        raise QiskitError('Linear part is not invertible.')\n    for i in range(num_qubits):\n        if elem.shift[i]:\n            circuit.x(i)\n            elem_cpy._append_x(i)\n    for i in range(num_qubits):\n        if not elem_cpy.linear[i][i]:\n            for j in range(i + 1, num_qubits):\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(j, i)\n                    circuit.cx(i, j)\n                    circuit.cx(j, i)\n                    elem_cpy._append_cx(j, i)\n                    elem_cpy._append_cx(i, j)\n                    elem_cpy._append_cx(j, i)\n                    break\n        for j in range(num_qubits):\n            if j != i:\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(i, j)\n                    elem_cpy._append_cx(i, j)\n    if not (elem_cpy.shift == np.zeros(num_qubits)).all() or not (elem_cpy.linear == np.eye(num_qubits)).all():\n        raise QiskitError('Cannot do Gauss elimination on linear part.')\n    new_elem = elem_cpy.copy()\n    new_elem.poly.weight_0 = 0\n    new_elem.poly.weight_1 = np.zeros(num_qubits, dtype=np.int8)\n    new_elem.poly.weight_2 = np.zeros(int(num_qubits * (num_qubits - 1) / 2), dtype=np.int8)\n    new_elem.poly.weight_3 = np.zeros(int(num_qubits * (num_qubits - 1) * (num_qubits - 2) / 6), dtype=np.int8)\n    new_circuit = QuantumCircuit(num_qubits)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            for k in range(j + 1, num_qubits):\n                if elem_cpy.poly.get_term([i, j, k]) != 0:\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_elem._append_phase(1, k)\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n                    new_circuit.p(np.pi / 4, [k])\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            tpow1 = elem_cpy.poly.get_term([i, j])\n            tpow2 = new_elem.poly.get_term([i, j])\n            tpow = (tpow2 - tpow1) / 2 % 4\n            if tpow != 0:\n                new_elem._append_cx(i, j)\n                new_elem._append_phase(tpow, j)\n                new_elem._append_cx(i, j)\n                new_circuit.cx(i, j)\n                new_circuit.p(tpow * np.pi / 4, [j])\n                new_circuit.cx(i, j)\n    for i in range(num_qubits):\n        tpow1 = elem_cpy.poly.get_term([i])\n        tpow2 = new_elem.poly.get_term([i])\n        tpow = (tpow1 - tpow2) % 8\n        if tpow != 0:\n            new_elem._append_phase(tpow, i)\n            new_circuit.p(tpow * np.pi / 4, [i])\n    if elem.poly != new_elem.poly:\n        raise QiskitError('Could not recover phase polynomial.')\n    inv_circuit = circuit.inverse()\n    return new_circuit.compose(inv_circuit)",
            "def synth_cnotdihedral_general(elem):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Decompose a CNOTDihedral element into a QuantumCircuit.\\n\\n    Decompose a general CNOTDihedral elements.\\n    The number of CNOT gates is not necessarily optimal.\\n    For a decomposition of a 1-qubit or 2-qubit element, call\\n    synth_cnotdihedral_two_qubits.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element could not be decomposed into a circuit.\\n\\n    Reference:\\n        1. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\\n           *Scalable randomised benchmarking of non-Clifford gates*,\\n           npj Quantum Inf 2, 16012 (2016).\\n    '\n    num_qubits = elem.num_qubits\n    circuit = QuantumCircuit(num_qubits)\n    elem_cpy = elem.copy()\n    if not np.allclose(np.linalg.det(elem_cpy.linear) % 2, 1):\n        raise QiskitError('Linear part is not invertible.')\n    for i in range(num_qubits):\n        if elem.shift[i]:\n            circuit.x(i)\n            elem_cpy._append_x(i)\n    for i in range(num_qubits):\n        if not elem_cpy.linear[i][i]:\n            for j in range(i + 1, num_qubits):\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(j, i)\n                    circuit.cx(i, j)\n                    circuit.cx(j, i)\n                    elem_cpy._append_cx(j, i)\n                    elem_cpy._append_cx(i, j)\n                    elem_cpy._append_cx(j, i)\n                    break\n        for j in range(num_qubits):\n            if j != i:\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(i, j)\n                    elem_cpy._append_cx(i, j)\n    if not (elem_cpy.shift == np.zeros(num_qubits)).all() or not (elem_cpy.linear == np.eye(num_qubits)).all():\n        raise QiskitError('Cannot do Gauss elimination on linear part.')\n    new_elem = elem_cpy.copy()\n    new_elem.poly.weight_0 = 0\n    new_elem.poly.weight_1 = np.zeros(num_qubits, dtype=np.int8)\n    new_elem.poly.weight_2 = np.zeros(int(num_qubits * (num_qubits - 1) / 2), dtype=np.int8)\n    new_elem.poly.weight_3 = np.zeros(int(num_qubits * (num_qubits - 1) * (num_qubits - 2) / 6), dtype=np.int8)\n    new_circuit = QuantumCircuit(num_qubits)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            for k in range(j + 1, num_qubits):\n                if elem_cpy.poly.get_term([i, j, k]) != 0:\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_elem._append_phase(1, k)\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n                    new_circuit.p(np.pi / 4, [k])\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            tpow1 = elem_cpy.poly.get_term([i, j])\n            tpow2 = new_elem.poly.get_term([i, j])\n            tpow = (tpow2 - tpow1) / 2 % 4\n            if tpow != 0:\n                new_elem._append_cx(i, j)\n                new_elem._append_phase(tpow, j)\n                new_elem._append_cx(i, j)\n                new_circuit.cx(i, j)\n                new_circuit.p(tpow * np.pi / 4, [j])\n                new_circuit.cx(i, j)\n    for i in range(num_qubits):\n        tpow1 = elem_cpy.poly.get_term([i])\n        tpow2 = new_elem.poly.get_term([i])\n        tpow = (tpow1 - tpow2) % 8\n        if tpow != 0:\n            new_elem._append_phase(tpow, i)\n            new_circuit.p(tpow * np.pi / 4, [i])\n    if elem.poly != new_elem.poly:\n        raise QiskitError('Could not recover phase polynomial.')\n    inv_circuit = circuit.inverse()\n    return new_circuit.compose(inv_circuit)",
            "def synth_cnotdihedral_general(elem):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Decompose a CNOTDihedral element into a QuantumCircuit.\\n\\n    Decompose a general CNOTDihedral elements.\\n    The number of CNOT gates is not necessarily optimal.\\n    For a decomposition of a 1-qubit or 2-qubit element, call\\n    synth_cnotdihedral_two_qubits.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element could not be decomposed into a circuit.\\n\\n    Reference:\\n        1. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\\n           *Scalable randomised benchmarking of non-Clifford gates*,\\n           npj Quantum Inf 2, 16012 (2016).\\n    '\n    num_qubits = elem.num_qubits\n    circuit = QuantumCircuit(num_qubits)\n    elem_cpy = elem.copy()\n    if not np.allclose(np.linalg.det(elem_cpy.linear) % 2, 1):\n        raise QiskitError('Linear part is not invertible.')\n    for i in range(num_qubits):\n        if elem.shift[i]:\n            circuit.x(i)\n            elem_cpy._append_x(i)\n    for i in range(num_qubits):\n        if not elem_cpy.linear[i][i]:\n            for j in range(i + 1, num_qubits):\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(j, i)\n                    circuit.cx(i, j)\n                    circuit.cx(j, i)\n                    elem_cpy._append_cx(j, i)\n                    elem_cpy._append_cx(i, j)\n                    elem_cpy._append_cx(j, i)\n                    break\n        for j in range(num_qubits):\n            if j != i:\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(i, j)\n                    elem_cpy._append_cx(i, j)\n    if not (elem_cpy.shift == np.zeros(num_qubits)).all() or not (elem_cpy.linear == np.eye(num_qubits)).all():\n        raise QiskitError('Cannot do Gauss elimination on linear part.')\n    new_elem = elem_cpy.copy()\n    new_elem.poly.weight_0 = 0\n    new_elem.poly.weight_1 = np.zeros(num_qubits, dtype=np.int8)\n    new_elem.poly.weight_2 = np.zeros(int(num_qubits * (num_qubits - 1) / 2), dtype=np.int8)\n    new_elem.poly.weight_3 = np.zeros(int(num_qubits * (num_qubits - 1) * (num_qubits - 2) / 6), dtype=np.int8)\n    new_circuit = QuantumCircuit(num_qubits)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            for k in range(j + 1, num_qubits):\n                if elem_cpy.poly.get_term([i, j, k]) != 0:\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_elem._append_phase(1, k)\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n                    new_circuit.p(np.pi / 4, [k])\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            tpow1 = elem_cpy.poly.get_term([i, j])\n            tpow2 = new_elem.poly.get_term([i, j])\n            tpow = (tpow2 - tpow1) / 2 % 4\n            if tpow != 0:\n                new_elem._append_cx(i, j)\n                new_elem._append_phase(tpow, j)\n                new_elem._append_cx(i, j)\n                new_circuit.cx(i, j)\n                new_circuit.p(tpow * np.pi / 4, [j])\n                new_circuit.cx(i, j)\n    for i in range(num_qubits):\n        tpow1 = elem_cpy.poly.get_term([i])\n        tpow2 = new_elem.poly.get_term([i])\n        tpow = (tpow1 - tpow2) % 8\n        if tpow != 0:\n            new_elem._append_phase(tpow, i)\n            new_circuit.p(tpow * np.pi / 4, [i])\n    if elem.poly != new_elem.poly:\n        raise QiskitError('Could not recover phase polynomial.')\n    inv_circuit = circuit.inverse()\n    return new_circuit.compose(inv_circuit)",
            "def synth_cnotdihedral_general(elem):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Decompose a CNOTDihedral element into a QuantumCircuit.\\n\\n    Decompose a general CNOTDihedral elements.\\n    The number of CNOT gates is not necessarily optimal.\\n    For a decomposition of a 1-qubit or 2-qubit element, call\\n    synth_cnotdihedral_two_qubits.\\n\\n    Args:\\n        elem (CNOTDihedral): a CNOTDihedral element.\\n\\n    Return:\\n        QuantumCircuit: a circuit implementation of the CNOTDihedral element.\\n\\n    Raises:\\n        QiskitError: if the element could not be decomposed into a circuit.\\n\\n    Reference:\\n        1. Andrew W. Cross, Easwar Magesan, Lev S. Bishop, John A. Smolin and Jay M. Gambetta,\\n           *Scalable randomised benchmarking of non-Clifford gates*,\\n           npj Quantum Inf 2, 16012 (2016).\\n    '\n    num_qubits = elem.num_qubits\n    circuit = QuantumCircuit(num_qubits)\n    elem_cpy = elem.copy()\n    if not np.allclose(np.linalg.det(elem_cpy.linear) % 2, 1):\n        raise QiskitError('Linear part is not invertible.')\n    for i in range(num_qubits):\n        if elem.shift[i]:\n            circuit.x(i)\n            elem_cpy._append_x(i)\n    for i in range(num_qubits):\n        if not elem_cpy.linear[i][i]:\n            for j in range(i + 1, num_qubits):\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(j, i)\n                    circuit.cx(i, j)\n                    circuit.cx(j, i)\n                    elem_cpy._append_cx(j, i)\n                    elem_cpy._append_cx(i, j)\n                    elem_cpy._append_cx(j, i)\n                    break\n        for j in range(num_qubits):\n            if j != i:\n                if elem_cpy.linear[j][i]:\n                    circuit.cx(i, j)\n                    elem_cpy._append_cx(i, j)\n    if not (elem_cpy.shift == np.zeros(num_qubits)).all() or not (elem_cpy.linear == np.eye(num_qubits)).all():\n        raise QiskitError('Cannot do Gauss elimination on linear part.')\n    new_elem = elem_cpy.copy()\n    new_elem.poly.weight_0 = 0\n    new_elem.poly.weight_1 = np.zeros(num_qubits, dtype=np.int8)\n    new_elem.poly.weight_2 = np.zeros(int(num_qubits * (num_qubits - 1) / 2), dtype=np.int8)\n    new_elem.poly.weight_3 = np.zeros(int(num_qubits * (num_qubits - 1) * (num_qubits - 2) / 6), dtype=np.int8)\n    new_circuit = QuantumCircuit(num_qubits)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            for k in range(j + 1, num_qubits):\n                if elem_cpy.poly.get_term([i, j, k]) != 0:\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_elem._append_phase(1, k)\n                    new_elem._append_cx(i, k)\n                    new_elem._append_cx(j, k)\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n                    new_circuit.p(np.pi / 4, [k])\n                    new_circuit.cx(i, k)\n                    new_circuit.cx(j, k)\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            tpow1 = elem_cpy.poly.get_term([i, j])\n            tpow2 = new_elem.poly.get_term([i, j])\n            tpow = (tpow2 - tpow1) / 2 % 4\n            if tpow != 0:\n                new_elem._append_cx(i, j)\n                new_elem._append_phase(tpow, j)\n                new_elem._append_cx(i, j)\n                new_circuit.cx(i, j)\n                new_circuit.p(tpow * np.pi / 4, [j])\n                new_circuit.cx(i, j)\n    for i in range(num_qubits):\n        tpow1 = elem_cpy.poly.get_term([i])\n        tpow2 = new_elem.poly.get_term([i])\n        tpow = (tpow1 - tpow2) % 8\n        if tpow != 0:\n            new_elem._append_phase(tpow, i)\n            new_circuit.p(tpow * np.pi / 4, [i])\n    if elem.poly != new_elem.poly:\n        raise QiskitError('Could not recover phase polynomial.')\n    inv_circuit = circuit.inverse()\n    return new_circuit.compose(inv_circuit)"
        ]
    }
]