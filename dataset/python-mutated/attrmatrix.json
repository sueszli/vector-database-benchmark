[
    {
        "func_name": "value",
        "original": "def value(u):\n    return u",
        "mutated": [
            "def value(u):\n    if False:\n        i = 10\n    return u",
            "def value(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return u",
            "def value(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return u",
            "def value(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return u",
            "def value(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return u"
        ]
    },
    {
        "func_name": "value",
        "original": "def value(u):\n    return G.nodes[u][node_attr]",
        "mutated": [
            "def value(u):\n    if False:\n        i = 10\n    return G.nodes[u][node_attr]",
            "def value(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return G.nodes[u][node_attr]",
            "def value(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return G.nodes[u][node_attr]",
            "def value(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return G.nodes[u][node_attr]",
            "def value(u):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return G.nodes[u][node_attr]"
        ]
    },
    {
        "func_name": "_node_value",
        "original": "def _node_value(G, node_attr):\n    \"\"\"Returns a function that returns a value from G.nodes[u].\n\n    We return a function expecting a node as its sole argument. Then, in the\n    simplest scenario, the returned function will return G.nodes[u][node_attr].\n    However, we also handle the case when `node_attr` is None or when it is a\n    function itself.\n\n    Parameters\n    ----------\n    G : graph\n        A NetworkX graph\n\n    node_attr : {None, str, callable}\n        Specification of how the value of the node attribute should be obtained\n        from the node attribute dictionary.\n\n    Returns\n    -------\n    value : function\n        A function expecting a node as its sole argument. The function will\n        returns a value from G.nodes[u] that depends on `edge_attr`.\n\n    \"\"\"\n    if node_attr is None:\n\n        def value(u):\n            return u\n    elif not callable(node_attr):\n\n        def value(u):\n            return G.nodes[u][node_attr]\n    else:\n        value = node_attr\n    return value",
        "mutated": [
            "def _node_value(G, node_attr):\n    if False:\n        i = 10\n    'Returns a function that returns a value from G.nodes[u].\\n\\n    We return a function expecting a node as its sole argument. Then, in the\\n    simplest scenario, the returned function will return G.nodes[u][node_attr].\\n    However, we also handle the case when `node_attr` is None or when it is a\\n    function itself.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph\\n\\n    node_attr : {None, str, callable}\\n        Specification of how the value of the node attribute should be obtained\\n        from the node attribute dictionary.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting a node as its sole argument. The function will\\n        returns a value from G.nodes[u] that depends on `edge_attr`.\\n\\n    '\n    if node_attr is None:\n\n        def value(u):\n            return u\n    elif not callable(node_attr):\n\n        def value(u):\n            return G.nodes[u][node_attr]\n    else:\n        value = node_attr\n    return value",
            "def _node_value(G, node_attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a function that returns a value from G.nodes[u].\\n\\n    We return a function expecting a node as its sole argument. Then, in the\\n    simplest scenario, the returned function will return G.nodes[u][node_attr].\\n    However, we also handle the case when `node_attr` is None or when it is a\\n    function itself.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph\\n\\n    node_attr : {None, str, callable}\\n        Specification of how the value of the node attribute should be obtained\\n        from the node attribute dictionary.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting a node as its sole argument. The function will\\n        returns a value from G.nodes[u] that depends on `edge_attr`.\\n\\n    '\n    if node_attr is None:\n\n        def value(u):\n            return u\n    elif not callable(node_attr):\n\n        def value(u):\n            return G.nodes[u][node_attr]\n    else:\n        value = node_attr\n    return value",
            "def _node_value(G, node_attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a function that returns a value from G.nodes[u].\\n\\n    We return a function expecting a node as its sole argument. Then, in the\\n    simplest scenario, the returned function will return G.nodes[u][node_attr].\\n    However, we also handle the case when `node_attr` is None or when it is a\\n    function itself.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph\\n\\n    node_attr : {None, str, callable}\\n        Specification of how the value of the node attribute should be obtained\\n        from the node attribute dictionary.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting a node as its sole argument. The function will\\n        returns a value from G.nodes[u] that depends on `edge_attr`.\\n\\n    '\n    if node_attr is None:\n\n        def value(u):\n            return u\n    elif not callable(node_attr):\n\n        def value(u):\n            return G.nodes[u][node_attr]\n    else:\n        value = node_attr\n    return value",
            "def _node_value(G, node_attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a function that returns a value from G.nodes[u].\\n\\n    We return a function expecting a node as its sole argument. Then, in the\\n    simplest scenario, the returned function will return G.nodes[u][node_attr].\\n    However, we also handle the case when `node_attr` is None or when it is a\\n    function itself.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph\\n\\n    node_attr : {None, str, callable}\\n        Specification of how the value of the node attribute should be obtained\\n        from the node attribute dictionary.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting a node as its sole argument. The function will\\n        returns a value from G.nodes[u] that depends on `edge_attr`.\\n\\n    '\n    if node_attr is None:\n\n        def value(u):\n            return u\n    elif not callable(node_attr):\n\n        def value(u):\n            return G.nodes[u][node_attr]\n    else:\n        value = node_attr\n    return value",
            "def _node_value(G, node_attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a function that returns a value from G.nodes[u].\\n\\n    We return a function expecting a node as its sole argument. Then, in the\\n    simplest scenario, the returned function will return G.nodes[u][node_attr].\\n    However, we also handle the case when `node_attr` is None or when it is a\\n    function itself.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        A NetworkX graph\\n\\n    node_attr : {None, str, callable}\\n        Specification of how the value of the node attribute should be obtained\\n        from the node attribute dictionary.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting a node as its sole argument. The function will\\n        returns a value from G.nodes[u] that depends on `edge_attr`.\\n\\n    '\n    if node_attr is None:\n\n        def value(u):\n            return u\n    elif not callable(node_attr):\n\n        def value(u):\n            return G.nodes[u][node_attr]\n    else:\n        value = node_attr\n    return value"
        ]
    },
    {
        "func_name": "value",
        "original": "def value(u, v):\n    return len(G[u][v])",
        "mutated": [
            "def value(u, v):\n    if False:\n        i = 10\n    return len(G[u][v])",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return len(G[u][v])",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return len(G[u][v])",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return len(G[u][v])",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return len(G[u][v])"
        ]
    },
    {
        "func_name": "value",
        "original": "def value(u, v):\n    return 1",
        "mutated": [
            "def value(u, v):\n    if False:\n        i = 10\n    return 1",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 1",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 1",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 1",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 1"
        ]
    },
    {
        "func_name": "value",
        "original": "def value(u, v):\n    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))",
        "mutated": [
            "def value(u, v):\n    if False:\n        i = 10\n    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))"
        ]
    },
    {
        "func_name": "value",
        "original": "def value(u, v):\n    return G[u][v].get(edge_attr, 1)",
        "mutated": [
            "def value(u, v):\n    if False:\n        i = 10\n    return G[u][v].get(edge_attr, 1)",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return G[u][v].get(edge_attr, 1)",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return G[u][v].get(edge_attr, 1)",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return G[u][v].get(edge_attr, 1)",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return G[u][v].get(edge_attr, 1)"
        ]
    },
    {
        "func_name": "value",
        "original": "def value(u, v):\n    return sum((d[edge_attr] for d in G[u][v].values()))",
        "mutated": [
            "def value(u, v):\n    if False:\n        i = 10\n    return sum((d[edge_attr] for d in G[u][v].values()))",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return sum((d[edge_attr] for d in G[u][v].values()))",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return sum((d[edge_attr] for d in G[u][v].values()))",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return sum((d[edge_attr] for d in G[u][v].values()))",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return sum((d[edge_attr] for d in G[u][v].values()))"
        ]
    },
    {
        "func_name": "value",
        "original": "def value(u, v):\n    return G[u][v][edge_attr]",
        "mutated": [
            "def value(u, v):\n    if False:\n        i = 10\n    return G[u][v][edge_attr]",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return G[u][v][edge_attr]",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return G[u][v][edge_attr]",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return G[u][v][edge_attr]",
            "def value(u, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return G[u][v][edge_attr]"
        ]
    },
    {
        "func_name": "_edge_value",
        "original": "def _edge_value(G, edge_attr):\n    \"\"\"Returns a function that returns a value from G[u][v].\n\n    Suppose there exists an edge between u and v.  Then we return a function\n    expecting u and v as arguments.  For Graph and DiGraph, G[u][v] is\n    the edge attribute dictionary, and the function (essentially) returns\n    G[u][v][edge_attr].  However, we also handle cases when `edge_attr` is None\n    and when it is a function itself. For MultiGraph and MultiDiGraph, G[u][v]\n    is a dictionary of all edges between u and v.  In this case, the returned\n    function sums the value of `edge_attr` for every edge between u and v.\n\n    Parameters\n    ----------\n    G : graph\n       A NetworkX graph\n\n    edge_attr : {None, str, callable}\n        Specification of how the value of the edge attribute should be obtained\n        from the edge attribute dictionary, G[u][v].  For multigraphs, G[u][v]\n        is a dictionary of all the edges between u and v.  This allows for\n        special treatment of multiedges.\n\n    Returns\n    -------\n    value : function\n        A function expecting two nodes as parameters. The nodes should\n        represent the from- and to- node of an edge. The function will\n        return a value from G[u][v] that depends on `edge_attr`.\n\n    \"\"\"\n    if edge_attr is None:\n        if G.is_multigraph():\n\n            def value(u, v):\n                return len(G[u][v])\n        else:\n\n            def value(u, v):\n                return 1\n    elif not callable(edge_attr):\n        if edge_attr == 'weight':\n            if G.is_multigraph():\n\n                def value(u, v):\n                    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))\n            else:\n\n                def value(u, v):\n                    return G[u][v].get(edge_attr, 1)\n        elif G.is_multigraph():\n\n            def value(u, v):\n                return sum((d[edge_attr] for d in G[u][v].values()))\n        else:\n\n            def value(u, v):\n                return G[u][v][edge_attr]\n    else:\n        value = edge_attr\n    return value",
        "mutated": [
            "def _edge_value(G, edge_attr):\n    if False:\n        i = 10\n    'Returns a function that returns a value from G[u][v].\\n\\n    Suppose there exists an edge between u and v.  Then we return a function\\n    expecting u and v as arguments.  For Graph and DiGraph, G[u][v] is\\n    the edge attribute dictionary, and the function (essentially) returns\\n    G[u][v][edge_attr].  However, we also handle cases when `edge_attr` is None\\n    and when it is a function itself. For MultiGraph and MultiDiGraph, G[u][v]\\n    is a dictionary of all edges between u and v.  In this case, the returned\\n    function sums the value of `edge_attr` for every edge between u and v.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX graph\\n\\n    edge_attr : {None, str, callable}\\n        Specification of how the value of the edge attribute should be obtained\\n        from the edge attribute dictionary, G[u][v].  For multigraphs, G[u][v]\\n        is a dictionary of all the edges between u and v.  This allows for\\n        special treatment of multiedges.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting two nodes as parameters. The nodes should\\n        represent the from- and to- node of an edge. The function will\\n        return a value from G[u][v] that depends on `edge_attr`.\\n\\n    '\n    if edge_attr is None:\n        if G.is_multigraph():\n\n            def value(u, v):\n                return len(G[u][v])\n        else:\n\n            def value(u, v):\n                return 1\n    elif not callable(edge_attr):\n        if edge_attr == 'weight':\n            if G.is_multigraph():\n\n                def value(u, v):\n                    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))\n            else:\n\n                def value(u, v):\n                    return G[u][v].get(edge_attr, 1)\n        elif G.is_multigraph():\n\n            def value(u, v):\n                return sum((d[edge_attr] for d in G[u][v].values()))\n        else:\n\n            def value(u, v):\n                return G[u][v][edge_attr]\n    else:\n        value = edge_attr\n    return value",
            "def _edge_value(G, edge_attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a function that returns a value from G[u][v].\\n\\n    Suppose there exists an edge between u and v.  Then we return a function\\n    expecting u and v as arguments.  For Graph and DiGraph, G[u][v] is\\n    the edge attribute dictionary, and the function (essentially) returns\\n    G[u][v][edge_attr].  However, we also handle cases when `edge_attr` is None\\n    and when it is a function itself. For MultiGraph and MultiDiGraph, G[u][v]\\n    is a dictionary of all edges between u and v.  In this case, the returned\\n    function sums the value of `edge_attr` for every edge between u and v.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX graph\\n\\n    edge_attr : {None, str, callable}\\n        Specification of how the value of the edge attribute should be obtained\\n        from the edge attribute dictionary, G[u][v].  For multigraphs, G[u][v]\\n        is a dictionary of all the edges between u and v.  This allows for\\n        special treatment of multiedges.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting two nodes as parameters. The nodes should\\n        represent the from- and to- node of an edge. The function will\\n        return a value from G[u][v] that depends on `edge_attr`.\\n\\n    '\n    if edge_attr is None:\n        if G.is_multigraph():\n\n            def value(u, v):\n                return len(G[u][v])\n        else:\n\n            def value(u, v):\n                return 1\n    elif not callable(edge_attr):\n        if edge_attr == 'weight':\n            if G.is_multigraph():\n\n                def value(u, v):\n                    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))\n            else:\n\n                def value(u, v):\n                    return G[u][v].get(edge_attr, 1)\n        elif G.is_multigraph():\n\n            def value(u, v):\n                return sum((d[edge_attr] for d in G[u][v].values()))\n        else:\n\n            def value(u, v):\n                return G[u][v][edge_attr]\n    else:\n        value = edge_attr\n    return value",
            "def _edge_value(G, edge_attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a function that returns a value from G[u][v].\\n\\n    Suppose there exists an edge between u and v.  Then we return a function\\n    expecting u and v as arguments.  For Graph and DiGraph, G[u][v] is\\n    the edge attribute dictionary, and the function (essentially) returns\\n    G[u][v][edge_attr].  However, we also handle cases when `edge_attr` is None\\n    and when it is a function itself. For MultiGraph and MultiDiGraph, G[u][v]\\n    is a dictionary of all edges between u and v.  In this case, the returned\\n    function sums the value of `edge_attr` for every edge between u and v.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX graph\\n\\n    edge_attr : {None, str, callable}\\n        Specification of how the value of the edge attribute should be obtained\\n        from the edge attribute dictionary, G[u][v].  For multigraphs, G[u][v]\\n        is a dictionary of all the edges between u and v.  This allows for\\n        special treatment of multiedges.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting two nodes as parameters. The nodes should\\n        represent the from- and to- node of an edge. The function will\\n        return a value from G[u][v] that depends on `edge_attr`.\\n\\n    '\n    if edge_attr is None:\n        if G.is_multigraph():\n\n            def value(u, v):\n                return len(G[u][v])\n        else:\n\n            def value(u, v):\n                return 1\n    elif not callable(edge_attr):\n        if edge_attr == 'weight':\n            if G.is_multigraph():\n\n                def value(u, v):\n                    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))\n            else:\n\n                def value(u, v):\n                    return G[u][v].get(edge_attr, 1)\n        elif G.is_multigraph():\n\n            def value(u, v):\n                return sum((d[edge_attr] for d in G[u][v].values()))\n        else:\n\n            def value(u, v):\n                return G[u][v][edge_attr]\n    else:\n        value = edge_attr\n    return value",
            "def _edge_value(G, edge_attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a function that returns a value from G[u][v].\\n\\n    Suppose there exists an edge between u and v.  Then we return a function\\n    expecting u and v as arguments.  For Graph and DiGraph, G[u][v] is\\n    the edge attribute dictionary, and the function (essentially) returns\\n    G[u][v][edge_attr].  However, we also handle cases when `edge_attr` is None\\n    and when it is a function itself. For MultiGraph and MultiDiGraph, G[u][v]\\n    is a dictionary of all edges between u and v.  In this case, the returned\\n    function sums the value of `edge_attr` for every edge between u and v.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX graph\\n\\n    edge_attr : {None, str, callable}\\n        Specification of how the value of the edge attribute should be obtained\\n        from the edge attribute dictionary, G[u][v].  For multigraphs, G[u][v]\\n        is a dictionary of all the edges between u and v.  This allows for\\n        special treatment of multiedges.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting two nodes as parameters. The nodes should\\n        represent the from- and to- node of an edge. The function will\\n        return a value from G[u][v] that depends on `edge_attr`.\\n\\n    '\n    if edge_attr is None:\n        if G.is_multigraph():\n\n            def value(u, v):\n                return len(G[u][v])\n        else:\n\n            def value(u, v):\n                return 1\n    elif not callable(edge_attr):\n        if edge_attr == 'weight':\n            if G.is_multigraph():\n\n                def value(u, v):\n                    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))\n            else:\n\n                def value(u, v):\n                    return G[u][v].get(edge_attr, 1)\n        elif G.is_multigraph():\n\n            def value(u, v):\n                return sum((d[edge_attr] for d in G[u][v].values()))\n        else:\n\n            def value(u, v):\n                return G[u][v][edge_attr]\n    else:\n        value = edge_attr\n    return value",
            "def _edge_value(G, edge_attr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a function that returns a value from G[u][v].\\n\\n    Suppose there exists an edge between u and v.  Then we return a function\\n    expecting u and v as arguments.  For Graph and DiGraph, G[u][v] is\\n    the edge attribute dictionary, and the function (essentially) returns\\n    G[u][v][edge_attr].  However, we also handle cases when `edge_attr` is None\\n    and when it is a function itself. For MultiGraph and MultiDiGraph, G[u][v]\\n    is a dictionary of all edges between u and v.  In this case, the returned\\n    function sums the value of `edge_attr` for every edge between u and v.\\n\\n    Parameters\\n    ----------\\n    G : graph\\n       A NetworkX graph\\n\\n    edge_attr : {None, str, callable}\\n        Specification of how the value of the edge attribute should be obtained\\n        from the edge attribute dictionary, G[u][v].  For multigraphs, G[u][v]\\n        is a dictionary of all the edges between u and v.  This allows for\\n        special treatment of multiedges.\\n\\n    Returns\\n    -------\\n    value : function\\n        A function expecting two nodes as parameters. The nodes should\\n        represent the from- and to- node of an edge. The function will\\n        return a value from G[u][v] that depends on `edge_attr`.\\n\\n    '\n    if edge_attr is None:\n        if G.is_multigraph():\n\n            def value(u, v):\n                return len(G[u][v])\n        else:\n\n            def value(u, v):\n                return 1\n    elif not callable(edge_attr):\n        if edge_attr == 'weight':\n            if G.is_multigraph():\n\n                def value(u, v):\n                    return sum((d.get(edge_attr, 1) for d in G[u][v].values()))\n            else:\n\n                def value(u, v):\n                    return G[u][v].get(edge_attr, 1)\n        elif G.is_multigraph():\n\n            def value(u, v):\n                return sum((d[edge_attr] for d in G[u][v].values()))\n        else:\n\n            def value(u, v):\n                return G[u][v][edge_attr]\n    else:\n        value = edge_attr\n    return value"
        ]
    },
    {
        "func_name": "attr_matrix",
        "original": "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None, order=None):\n    \"\"\"Returns the attribute matrix using attributes from `G` as a numpy array.\n\n    If only `G` is passed in, then the adjacency matrix is constructed.\n\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\n    the elements of A represent the rows and columns of the constructed matrix.\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\n    node attribute `node_attr` for u and v, respectively, then the value of\n    the edge attribute is added to the matrix element at (ua, va).\n\n    Parameters\n    ----------\n    G : graph\n        The NetworkX graph used to construct the attribute matrix.\n\n    edge_attr : str, optional\n        Each element of the matrix represents a running total of the\n        specified edge attribute for edges whose node attributes correspond\n        to the rows/cols of the matrix. The attribute must be present for\n        all edges in the graph. If no attribute is specified, then we\n        just count the number of edges whose node attributes correspond\n        to the matrix element.\n\n    node_attr : str, optional\n        Each row and column in the matrix represents a particular value\n        of the node attribute.  The attribute must be present for all nodes\n        in the graph. Note, the values of this attribute should be reliably\n        hashable. So, float values are not recommended. If no attribute is\n        specified, then the rows and columns will be the nodes of the graph.\n\n    normalized : bool, optional\n        If True, then each row is normalized by the summation of its values.\n\n    rc_order : list, optional\n        A list of the node attribute values. This list specifies the ordering\n        of rows and columns of the array. If no ordering is provided, then\n        the ordering will be random (and also, a return value).\n\n    Other Parameters\n    ----------------\n    dtype : NumPy data-type, optional\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\n        dtypes can yield unexpected results if the array is to be normalized.\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\n        default is used.\n\n    order : {'C', 'F'}, optional\n        Whether to store multidimensional data in C- or Fortran-contiguous\n        (row- or column-wise) order in memory. This parameter is passed to\n        numpy.zeros(). If unspecified, the NumPy default is used.\n\n    Returns\n    -------\n    M : 2D NumPy ndarray\n        The attribute matrix.\n\n    ordering : list\n        If `rc_order` was specified, then only the attribute matrix is returned.\n        However, if `rc_order` was None, then the ordering used to construct\n        the matrix is returned as well.\n\n    Examples\n    --------\n    Construct an adjacency matrix:\n\n    >>> G = nx.Graph()\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\n    >>> G.add_edge(0, 2, thickness=2)\n    >>> G.add_edge(1, 2, thickness=3)\n    >>> nx.attr_matrix(G, rc_order=[0, 1, 2])\n    array([[0., 1., 1.],\n           [1., 0., 1.],\n           [1., 1., 0.]])\n\n    Alternatively, we can obtain the matrix describing edge thickness.\n\n    >>> nx.attr_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\n    array([[0., 1., 2.],\n           [1., 0., 3.],\n           [2., 3., 0.]])\n\n    We can also color the nodes and ask for the probability distribution over\n    all edges (u,v) describing:\n\n        Pr(v has color Y | u has color X)\n\n    >>> G.nodes[0][\"color\"] = \"red\"\n    >>> G.nodes[1][\"color\"] = \"red\"\n    >>> G.nodes[2][\"color\"] = \"blue\"\n    >>> rc = [\"red\", \"blue\"]\n    >>> nx.attr_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\n    array([[0.33333333, 0.66666667],\n           [1.        , 0.        ]])\n\n    For example, the above tells us that for all edges (u,v):\n\n        Pr( v is red  | u is red)  = 1/3\n        Pr( v is blue | u is red)  = 2/3\n\n        Pr( v is red  | u is blue) = 1\n        Pr( v is blue | u is blue) = 0\n\n    Finally, we can obtain the total weights listed by the node colors.\n\n    >>> nx.attr_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\n    array([[3., 2.],\n           [2., 0.]])\n\n    Thus, the total weight over all edges (u,v) with u and v having colors:\n\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\n        (blue, blue) is 0   # there are no edges with blue endpoints\n\n    \"\"\"\n    import numpy as np\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = np.zeros((N, N), dtype=dtype, order=order)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M /= M.sum(axis=1).reshape((N, 1))\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
        "mutated": [
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None, order=None):\n    if False:\n        i = 10\n    'Returns the attribute matrix using attributes from `G` as a numpy array.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the attribute matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    order : {\\'C\\', \\'F\\'}, optional\\n        Whether to store multidimensional data in C- or Fortran-contiguous\\n        (row- or column-wise) order in memory. This parameter is passed to\\n        numpy.zeros(). If unspecified, the NumPy default is used.\\n\\n    Returns\\n    -------\\n    M : 2D NumPy ndarray\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the attribute matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> nx.attr_matrix(G, rc_order=[0, 1, 2])\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> nx.attr_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = np.zeros((N, N), dtype=dtype, order=order)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M /= M.sum(axis=1).reshape((N, 1))\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the attribute matrix using attributes from `G` as a numpy array.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the attribute matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    order : {\\'C\\', \\'F\\'}, optional\\n        Whether to store multidimensional data in C- or Fortran-contiguous\\n        (row- or column-wise) order in memory. This parameter is passed to\\n        numpy.zeros(). If unspecified, the NumPy default is used.\\n\\n    Returns\\n    -------\\n    M : 2D NumPy ndarray\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the attribute matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> nx.attr_matrix(G, rc_order=[0, 1, 2])\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> nx.attr_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = np.zeros((N, N), dtype=dtype, order=order)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M /= M.sum(axis=1).reshape((N, 1))\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the attribute matrix using attributes from `G` as a numpy array.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the attribute matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    order : {\\'C\\', \\'F\\'}, optional\\n        Whether to store multidimensional data in C- or Fortran-contiguous\\n        (row- or column-wise) order in memory. This parameter is passed to\\n        numpy.zeros(). If unspecified, the NumPy default is used.\\n\\n    Returns\\n    -------\\n    M : 2D NumPy ndarray\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the attribute matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> nx.attr_matrix(G, rc_order=[0, 1, 2])\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> nx.attr_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = np.zeros((N, N), dtype=dtype, order=order)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M /= M.sum(axis=1).reshape((N, 1))\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the attribute matrix using attributes from `G` as a numpy array.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the attribute matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    order : {\\'C\\', \\'F\\'}, optional\\n        Whether to store multidimensional data in C- or Fortran-contiguous\\n        (row- or column-wise) order in memory. This parameter is passed to\\n        numpy.zeros(). If unspecified, the NumPy default is used.\\n\\n    Returns\\n    -------\\n    M : 2D NumPy ndarray\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the attribute matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> nx.attr_matrix(G, rc_order=[0, 1, 2])\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> nx.attr_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = np.zeros((N, N), dtype=dtype, order=order)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M /= M.sum(axis=1).reshape((N, 1))\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None, order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the attribute matrix using attributes from `G` as a numpy array.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the attribute matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    order : {\\'C\\', \\'F\\'}, optional\\n        Whether to store multidimensional data in C- or Fortran-contiguous\\n        (row- or column-wise) order in memory. This parameter is passed to\\n        numpy.zeros(). If unspecified, the NumPy default is used.\\n\\n    Returns\\n    -------\\n    M : 2D NumPy ndarray\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the attribute matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> nx.attr_matrix(G, rc_order=[0, 1, 2])\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> nx.attr_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> nx.attr_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = np.zeros((N, N), dtype=dtype, order=order)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M /= M.sum(axis=1).reshape((N, 1))\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M"
        ]
    },
    {
        "func_name": "attr_sparse_matrix",
        "original": "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_sparse_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None):\n    \"\"\"Returns a SciPy sparse array using attributes from G.\n\n    If only `G` is passed in, then the adjacency matrix is constructed.\n\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\n    the elements of A represent the rows and columns of the constructed matrix.\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\n    node attribute `node_attr` for u and v, respectively, then the value of\n    the edge attribute is added to the matrix element at (ua, va).\n\n    Parameters\n    ----------\n    G : graph\n        The NetworkX graph used to construct the NumPy matrix.\n\n    edge_attr : str, optional\n        Each element of the matrix represents a running total of the\n        specified edge attribute for edges whose node attributes correspond\n        to the rows/cols of the matrix. The attribute must be present for\n        all edges in the graph. If no attribute is specified, then we\n        just count the number of edges whose node attributes correspond\n        to the matrix element.\n\n    node_attr : str, optional\n        Each row and column in the matrix represents a particular value\n        of the node attribute.  The attribute must be present for all nodes\n        in the graph. Note, the values of this attribute should be reliably\n        hashable. So, float values are not recommended. If no attribute is\n        specified, then the rows and columns will be the nodes of the graph.\n\n    normalized : bool, optional\n        If True, then each row is normalized by the summation of its values.\n\n    rc_order : list, optional\n        A list of the node attribute values. This list specifies the ordering\n        of rows and columns of the array. If no ordering is provided, then\n        the ordering will be random (and also, a return value).\n\n    Other Parameters\n    ----------------\n    dtype : NumPy data-type, optional\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\n        dtypes can yield unexpected results if the array is to be normalized.\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\n        default is used.\n\n    Returns\n    -------\n    M : SciPy sparse array\n        The attribute matrix.\n\n    ordering : list\n        If `rc_order` was specified, then only the matrix is returned.\n        However, if `rc_order` was None, then the ordering used to construct\n        the matrix is returned as well.\n\n    Examples\n    --------\n    Construct an adjacency matrix:\n\n    >>> G = nx.Graph()\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\n    >>> G.add_edge(0, 2, thickness=2)\n    >>> G.add_edge(1, 2, thickness=3)\n    >>> M = nx.attr_sparse_matrix(G, rc_order=[0, 1, 2])\n    >>> M.toarray()\n    array([[0., 1., 1.],\n           [1., 0., 1.],\n           [1., 1., 0.]])\n\n    Alternatively, we can obtain the matrix describing edge thickness.\n\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\n    >>> M.toarray()\n    array([[0., 1., 2.],\n           [1., 0., 3.],\n           [2., 3., 0.]])\n\n    We can also color the nodes and ask for the probability distribution over\n    all edges (u,v) describing:\n\n        Pr(v has color Y | u has color X)\n\n    >>> G.nodes[0][\"color\"] = \"red\"\n    >>> G.nodes[1][\"color\"] = \"red\"\n    >>> G.nodes[2][\"color\"] = \"blue\"\n    >>> rc = [\"red\", \"blue\"]\n    >>> M = nx.attr_sparse_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\n    >>> M.toarray()\n    array([[0.33333333, 0.66666667],\n           [1.        , 0.        ]])\n\n    For example, the above tells us that for all edges (u,v):\n\n        Pr( v is red  | u is red)  = 1/3\n        Pr( v is blue | u is red)  = 2/3\n\n        Pr( v is red  | u is blue) = 1\n        Pr( v is blue | u is blue) = 0\n\n    Finally, we can obtain the total weights listed by the node colors.\n\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\n    >>> M.toarray()\n    array([[3., 2.],\n           [2., 0.]])\n\n    Thus, the total weight over all edges (u,v) with u and v having colors:\n\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\n        (blue, blue) is 0   # there are no edges with blue endpoints\n\n    \"\"\"\n    import numpy as np\n    import scipy as sp\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = sp.sparse.lil_array((N, N), dtype=dtype)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M *= 1 / M.sum(axis=1)[:, np.newaxis]\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
        "mutated": [
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_sparse_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None):\n    if False:\n        i = 10\n    'Returns a SciPy sparse array using attributes from G.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the NumPy matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    Returns\\n    -------\\n    M : SciPy sparse array\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> M = nx.attr_sparse_matrix(G, rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> M = nx.attr_sparse_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    >>> M.toarray()\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    >>> M.toarray()\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    import scipy as sp\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = sp.sparse.lil_array((N, N), dtype=dtype)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M *= 1 / M.sum(axis=1)[:, np.newaxis]\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_sparse_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a SciPy sparse array using attributes from G.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the NumPy matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    Returns\\n    -------\\n    M : SciPy sparse array\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> M = nx.attr_sparse_matrix(G, rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> M = nx.attr_sparse_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    >>> M.toarray()\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    >>> M.toarray()\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    import scipy as sp\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = sp.sparse.lil_array((N, N), dtype=dtype)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M *= 1 / M.sum(axis=1)[:, np.newaxis]\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_sparse_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a SciPy sparse array using attributes from G.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the NumPy matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    Returns\\n    -------\\n    M : SciPy sparse array\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> M = nx.attr_sparse_matrix(G, rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> M = nx.attr_sparse_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    >>> M.toarray()\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    >>> M.toarray()\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    import scipy as sp\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = sp.sparse.lil_array((N, N), dtype=dtype)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M *= 1 / M.sum(axis=1)[:, np.newaxis]\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_sparse_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a SciPy sparse array using attributes from G.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the NumPy matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    Returns\\n    -------\\n    M : SciPy sparse array\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> M = nx.attr_sparse_matrix(G, rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> M = nx.attr_sparse_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    >>> M.toarray()\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    >>> M.toarray()\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    import scipy as sp\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = sp.sparse.lil_array((N, N), dtype=dtype)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M *= 1 / M.sum(axis=1)[:, np.newaxis]\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M",
            "@nx._dispatch(edge_attrs={'edge_attr': None}, node_attrs='node_attr')\ndef attr_sparse_matrix(G, edge_attr=None, node_attr=None, normalized=False, rc_order=None, dtype=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a SciPy sparse array using attributes from G.\\n\\n    If only `G` is passed in, then the adjacency matrix is constructed.\\n\\n    Let A be a discrete set of values for the node attribute `node_attr`. Then\\n    the elements of A represent the rows and columns of the constructed matrix.\\n    Now, iterate through every edge e=(u,v) in `G` and consider the value\\n    of the edge attribute `edge_attr`.  If ua and va are the values of the\\n    node attribute `node_attr` for u and v, respectively, then the value of\\n    the edge attribute is added to the matrix element at (ua, va).\\n\\n    Parameters\\n    ----------\\n    G : graph\\n        The NetworkX graph used to construct the NumPy matrix.\\n\\n    edge_attr : str, optional\\n        Each element of the matrix represents a running total of the\\n        specified edge attribute for edges whose node attributes correspond\\n        to the rows/cols of the matrix. The attribute must be present for\\n        all edges in the graph. If no attribute is specified, then we\\n        just count the number of edges whose node attributes correspond\\n        to the matrix element.\\n\\n    node_attr : str, optional\\n        Each row and column in the matrix represents a particular value\\n        of the node attribute.  The attribute must be present for all nodes\\n        in the graph. Note, the values of this attribute should be reliably\\n        hashable. So, float values are not recommended. If no attribute is\\n        specified, then the rows and columns will be the nodes of the graph.\\n\\n    normalized : bool, optional\\n        If True, then each row is normalized by the summation of its values.\\n\\n    rc_order : list, optional\\n        A list of the node attribute values. This list specifies the ordering\\n        of rows and columns of the array. If no ordering is provided, then\\n        the ordering will be random (and also, a return value).\\n\\n    Other Parameters\\n    ----------------\\n    dtype : NumPy data-type, optional\\n        A valid NumPy dtype used to initialize the array. Keep in mind certain\\n        dtypes can yield unexpected results if the array is to be normalized.\\n        The parameter is passed to numpy.zeros(). If unspecified, the NumPy\\n        default is used.\\n\\n    Returns\\n    -------\\n    M : SciPy sparse array\\n        The attribute matrix.\\n\\n    ordering : list\\n        If `rc_order` was specified, then only the matrix is returned.\\n        However, if `rc_order` was None, then the ordering used to construct\\n        the matrix is returned as well.\\n\\n    Examples\\n    --------\\n    Construct an adjacency matrix:\\n\\n    >>> G = nx.Graph()\\n    >>> G.add_edge(0, 1, thickness=1, weight=3)\\n    >>> G.add_edge(0, 2, thickness=2)\\n    >>> G.add_edge(1, 2, thickness=3)\\n    >>> M = nx.attr_sparse_matrix(G, rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 1.],\\n           [1., 0., 1.],\\n           [1., 1., 0.]])\\n\\n    Alternatively, we can obtain the matrix describing edge thickness.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\\n    >>> M.toarray()\\n    array([[0., 1., 2.],\\n           [1., 0., 3.],\\n           [2., 3., 0.]])\\n\\n    We can also color the nodes and ask for the probability distribution over\\n    all edges (u,v) describing:\\n\\n        Pr(v has color Y | u has color X)\\n\\n    >>> G.nodes[0][\"color\"] = \"red\"\\n    >>> G.nodes[1][\"color\"] = \"red\"\\n    >>> G.nodes[2][\"color\"] = \"blue\"\\n    >>> rc = [\"red\", \"blue\"]\\n    >>> M = nx.attr_sparse_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\\n    >>> M.toarray()\\n    array([[0.33333333, 0.66666667],\\n           [1.        , 0.        ]])\\n\\n    For example, the above tells us that for all edges (u,v):\\n\\n        Pr( v is red  | u is red)  = 1/3\\n        Pr( v is blue | u is red)  = 2/3\\n\\n        Pr( v is red  | u is blue) = 1\\n        Pr( v is blue | u is blue) = 0\\n\\n    Finally, we can obtain the total weights listed by the node colors.\\n\\n    >>> M = nx.attr_sparse_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\\n    >>> M.toarray()\\n    array([[3., 2.],\\n           [2., 0.]])\\n\\n    Thus, the total weight over all edges (u,v) with u and v having colors:\\n\\n        (red, red)   is 3   # the sole contribution is from edge (0,1)\\n        (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\\n        (blue, red)  is 2   # same as (red, blue) since graph is undirected\\n        (blue, blue) is 0   # there are no edges with blue endpoints\\n\\n    '\n    import numpy as np\n    import scipy as sp\n    edge_value = _edge_value(G, edge_attr)\n    node_value = _node_value(G, node_attr)\n    if rc_order is None:\n        ordering = list({node_value(n) for n in G})\n    else:\n        ordering = rc_order\n    N = len(ordering)\n    undirected = not G.is_directed()\n    index = dict(zip(ordering, range(N)))\n    M = sp.sparse.lil_array((N, N), dtype=dtype)\n    seen = set()\n    for (u, nbrdict) in G.adjacency():\n        for v in nbrdict:\n            (i, j) = (index[node_value(u)], index[node_value(v)])\n            if v not in seen:\n                M[i, j] += edge_value(u, v)\n                if undirected:\n                    M[j, i] = M[i, j]\n        if undirected:\n            seen.add(u)\n    if normalized:\n        M *= 1 / M.sum(axis=1)[:, np.newaxis]\n    if rc_order is None:\n        return (M, ordering)\n    else:\n        return M"
        ]
    }
]