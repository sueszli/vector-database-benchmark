[
    {
        "func_name": "gomory_hu_tree",
        "original": "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs={'capacity': float('inf')})\ndef gomory_hu_tree(G, capacity='capacity', flow_func=None):\n    \"\"\"Returns the Gomory-Hu tree of an undirected graph G.\n\n    A Gomory-Hu tree of an undirected graph with capacities is a\n    weighted tree that represents the minimum s-t cuts for all s-t\n    pairs in the graph.\n\n    It only requires `n-1` minimum cut computations instead of the\n    obvious `n(n-1)/2`. The tree represents all s-t cuts as the\n    minimum cut value among any pair of nodes is the minimum edge\n    weight in the shortest path between the two nodes in the\n    Gomory-Hu tree.\n\n    The Gomory-Hu tree also has the property that removing the\n    edge with the minimum weight in the shortest path between\n    any two nodes leaves two connected components that form\n    a partition of the nodes in G that defines the minimum s-t\n    cut.\n\n    See Examples section below for details.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        Undirected graph\n\n    capacity : string\n        Edges of the graph G are expected to have an attribute capacity\n        that indicates how much flow the edge can support. If this\n        attribute is not present, the edge is considered to have\n        infinite capacity. Default value: 'capacity'.\n\n    flow_func : function\n        Function to perform the underlying flow computations. Default value\n        :func:`edmonds_karp`. This function performs better in sparse graphs\n        with right tailed degree distributions.\n        :func:`shortest_augmenting_path` will perform better in denser\n        graphs.\n\n    Returns\n    -------\n    Tree : NetworkX graph\n        A NetworkX graph representing the Gomory-Hu tree of the input graph.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        Raised if the input graph is directed.\n\n    NetworkXError\n        Raised if the input graph is an empty Graph.\n\n    Examples\n    --------\n    >>> G = nx.karate_club_graph()\n    >>> nx.set_edge_attributes(G, 1, \"capacity\")\n    >>> T = nx.gomory_hu_tree(G)\n    >>> # The value of the minimum cut between any pair\n    ... # of nodes in G is the minimum edge weight in the\n    ... # shortest path between the two nodes in the\n    ... # Gomory-Hu tree.\n    ... def minimum_edge_weight_in_shortest_path(T, u, v):\n    ...     path = nx.shortest_path(T, u, v, weight=\"weight\")\n    ...     return min((T[u][v][\"weight\"], (u, v)) for (u, v) in zip(path, path[1:]))\n    >>> u, v = 0, 33\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\n    >>> cut_value\n    10\n    >>> nx.minimum_cut_value(G, u, v)\n    10\n    >>> # The Gomory-Hu tree also has the property that removing the\n    ... # edge with the minimum weight in the shortest path between\n    ... # any two nodes leaves two connected components that form\n    ... # a partition of the nodes in G that defines the minimum s-t\n    ... # cut.\n    ... cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\n    >>> T.remove_edge(*edge)\n    >>> U, V = list(nx.connected_components(T))\n    >>> # Thus U and V form a partition that defines a minimum cut\n    ... # between u and v in G. You can compute the edge cut set,\n    ... # that is, the set of edges that if removed from G will\n    ... # disconnect u from v in G, with this information:\n    ... cutset = set()\n    >>> for x, nbrs in ((n, G[n]) for n in U):\n    ...     cutset.update((x, y) for y in nbrs if y in V)\n    >>> # Because we have set the capacities of all edges to 1\n    ... # the cutset contains ten edges\n    ... len(cutset)\n    10\n    >>> # You can use any maximum flow algorithm for the underlying\n    ... # flow computations using the argument flow_func\n    ... from networkx.algorithms import flow\n    >>> T = nx.gomory_hu_tree(G, flow_func=flow.boykov_kolmogorov)\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\n    >>> cut_value\n    10\n    >>> nx.minimum_cut_value(G, u, v, flow_func=flow.boykov_kolmogorov)\n    10\n\n    Notes\n    -----\n    This implementation is based on Gusfield approach [1]_ to compute\n    Gomory-Hu trees, which does not require node contractions and has\n    the same computational complexity than the original method.\n\n    See also\n    --------\n    :func:`minimum_cut`\n    :func:`maximum_flow`\n\n    References\n    ----------\n    .. [1] Gusfield D: Very simple methods for all pairs network flow analysis.\n           SIAM J Comput 19(1):143-155, 1990.\n\n    \"\"\"\n    if flow_func is None:\n        flow_func = default_flow_func\n    if len(G) == 0:\n        msg = 'Empty Graph does not have a Gomory-Hu tree representation'\n        raise nx.NetworkXError(msg)\n    tree = {}\n    labels = {}\n    iter_nodes = iter(G)\n    root = next(iter_nodes)\n    for n in iter_nodes:\n        tree[n] = root\n    R = build_residual_network(G, capacity)\n    for source in tree:\n        target = tree[source]\n        (cut_value, partition) = nx.minimum_cut(G, source, target, capacity=capacity, flow_func=flow_func, residual=R)\n        labels[source, target] = cut_value\n        for node in partition[0]:\n            if node != source and node in tree and (tree[node] == target):\n                tree[node] = source\n                labels[node, source] = labels.get((node, target), cut_value)\n        if target != root and tree[target] in partition[0]:\n            labels[source, tree[target]] = labels[target, tree[target]]\n            labels[target, source] = cut_value\n            tree[source] = tree[target]\n            tree[target] = source\n    T = nx.Graph()\n    T.add_nodes_from(G)\n    T.add_weighted_edges_from(((u, v, labels[u, v]) for (u, v) in tree.items()))\n    return T",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs={'capacity': float('inf')})\ndef gomory_hu_tree(G, capacity='capacity', flow_func=None):\n    if False:\n        i = 10\n    'Returns the Gomory-Hu tree of an undirected graph G.\\n\\n    A Gomory-Hu tree of an undirected graph with capacities is a\\n    weighted tree that represents the minimum s-t cuts for all s-t\\n    pairs in the graph.\\n\\n    It only requires `n-1` minimum cut computations instead of the\\n    obvious `n(n-1)/2`. The tree represents all s-t cuts as the\\n    minimum cut value among any pair of nodes is the minimum edge\\n    weight in the shortest path between the two nodes in the\\n    Gomory-Hu tree.\\n\\n    The Gomory-Hu tree also has the property that removing the\\n    edge with the minimum weight in the shortest path between\\n    any two nodes leaves two connected components that form\\n    a partition of the nodes in G that defines the minimum s-t\\n    cut.\\n\\n    See Examples section below for details.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    flow_func : function\\n        Function to perform the underlying flow computations. Default value\\n        :func:`edmonds_karp`. This function performs better in sparse graphs\\n        with right tailed degree distributions.\\n        :func:`shortest_augmenting_path` will perform better in denser\\n        graphs.\\n\\n    Returns\\n    -------\\n    Tree : NetworkX graph\\n        A NetworkX graph representing the Gomory-Hu tree of the input graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        Raised if the input graph is directed.\\n\\n    NetworkXError\\n        Raised if the input graph is an empty Graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> nx.set_edge_attributes(G, 1, \"capacity\")\\n    >>> T = nx.gomory_hu_tree(G)\\n    >>> # The value of the minimum cut between any pair\\n    ... # of nodes in G is the minimum edge weight in the\\n    ... # shortest path between the two nodes in the\\n    ... # Gomory-Hu tree.\\n    ... def minimum_edge_weight_in_shortest_path(T, u, v):\\n    ...     path = nx.shortest_path(T, u, v, weight=\"weight\")\\n    ...     return min((T[u][v][\"weight\"], (u, v)) for (u, v) in zip(path, path[1:]))\\n    >>> u, v = 0, 33\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v)\\n    10\\n    >>> # The Gomory-Hu tree also has the property that removing the\\n    ... # edge with the minimum weight in the shortest path between\\n    ... # any two nodes leaves two connected components that form\\n    ... # a partition of the nodes in G that defines the minimum s-t\\n    ... # cut.\\n    ... cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> T.remove_edge(*edge)\\n    >>> U, V = list(nx.connected_components(T))\\n    >>> # Thus U and V form a partition that defines a minimum cut\\n    ... # between u and v in G. You can compute the edge cut set,\\n    ... # that is, the set of edges that if removed from G will\\n    ... # disconnect u from v in G, with this information:\\n    ... cutset = set()\\n    >>> for x, nbrs in ((n, G[n]) for n in U):\\n    ...     cutset.update((x, y) for y in nbrs if y in V)\\n    >>> # Because we have set the capacities of all edges to 1\\n    ... # the cutset contains ten edges\\n    ... len(cutset)\\n    10\\n    >>> # You can use any maximum flow algorithm for the underlying\\n    ... # flow computations using the argument flow_func\\n    ... from networkx.algorithms import flow\\n    >>> T = nx.gomory_hu_tree(G, flow_func=flow.boykov_kolmogorov)\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v, flow_func=flow.boykov_kolmogorov)\\n    10\\n\\n    Notes\\n    -----\\n    This implementation is based on Gusfield approach [1]_ to compute\\n    Gomory-Hu trees, which does not require node contractions and has\\n    the same computational complexity than the original method.\\n\\n    See also\\n    --------\\n    :func:`minimum_cut`\\n    :func:`maximum_flow`\\n\\n    References\\n    ----------\\n    .. [1] Gusfield D: Very simple methods for all pairs network flow analysis.\\n           SIAM J Comput 19(1):143-155, 1990.\\n\\n    '\n    if flow_func is None:\n        flow_func = default_flow_func\n    if len(G) == 0:\n        msg = 'Empty Graph does not have a Gomory-Hu tree representation'\n        raise nx.NetworkXError(msg)\n    tree = {}\n    labels = {}\n    iter_nodes = iter(G)\n    root = next(iter_nodes)\n    for n in iter_nodes:\n        tree[n] = root\n    R = build_residual_network(G, capacity)\n    for source in tree:\n        target = tree[source]\n        (cut_value, partition) = nx.minimum_cut(G, source, target, capacity=capacity, flow_func=flow_func, residual=R)\n        labels[source, target] = cut_value\n        for node in partition[0]:\n            if node != source and node in tree and (tree[node] == target):\n                tree[node] = source\n                labels[node, source] = labels.get((node, target), cut_value)\n        if target != root and tree[target] in partition[0]:\n            labels[source, tree[target]] = labels[target, tree[target]]\n            labels[target, source] = cut_value\n            tree[source] = tree[target]\n            tree[target] = source\n    T = nx.Graph()\n    T.add_nodes_from(G)\n    T.add_weighted_edges_from(((u, v, labels[u, v]) for (u, v) in tree.items()))\n    return T",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs={'capacity': float('inf')})\ndef gomory_hu_tree(G, capacity='capacity', flow_func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the Gomory-Hu tree of an undirected graph G.\\n\\n    A Gomory-Hu tree of an undirected graph with capacities is a\\n    weighted tree that represents the minimum s-t cuts for all s-t\\n    pairs in the graph.\\n\\n    It only requires `n-1` minimum cut computations instead of the\\n    obvious `n(n-1)/2`. The tree represents all s-t cuts as the\\n    minimum cut value among any pair of nodes is the minimum edge\\n    weight in the shortest path between the two nodes in the\\n    Gomory-Hu tree.\\n\\n    The Gomory-Hu tree also has the property that removing the\\n    edge with the minimum weight in the shortest path between\\n    any two nodes leaves two connected components that form\\n    a partition of the nodes in G that defines the minimum s-t\\n    cut.\\n\\n    See Examples section below for details.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    flow_func : function\\n        Function to perform the underlying flow computations. Default value\\n        :func:`edmonds_karp`. This function performs better in sparse graphs\\n        with right tailed degree distributions.\\n        :func:`shortest_augmenting_path` will perform better in denser\\n        graphs.\\n\\n    Returns\\n    -------\\n    Tree : NetworkX graph\\n        A NetworkX graph representing the Gomory-Hu tree of the input graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        Raised if the input graph is directed.\\n\\n    NetworkXError\\n        Raised if the input graph is an empty Graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> nx.set_edge_attributes(G, 1, \"capacity\")\\n    >>> T = nx.gomory_hu_tree(G)\\n    >>> # The value of the minimum cut between any pair\\n    ... # of nodes in G is the minimum edge weight in the\\n    ... # shortest path between the two nodes in the\\n    ... # Gomory-Hu tree.\\n    ... def minimum_edge_weight_in_shortest_path(T, u, v):\\n    ...     path = nx.shortest_path(T, u, v, weight=\"weight\")\\n    ...     return min((T[u][v][\"weight\"], (u, v)) for (u, v) in zip(path, path[1:]))\\n    >>> u, v = 0, 33\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v)\\n    10\\n    >>> # The Gomory-Hu tree also has the property that removing the\\n    ... # edge with the minimum weight in the shortest path between\\n    ... # any two nodes leaves two connected components that form\\n    ... # a partition of the nodes in G that defines the minimum s-t\\n    ... # cut.\\n    ... cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> T.remove_edge(*edge)\\n    >>> U, V = list(nx.connected_components(T))\\n    >>> # Thus U and V form a partition that defines a minimum cut\\n    ... # between u and v in G. You can compute the edge cut set,\\n    ... # that is, the set of edges that if removed from G will\\n    ... # disconnect u from v in G, with this information:\\n    ... cutset = set()\\n    >>> for x, nbrs in ((n, G[n]) for n in U):\\n    ...     cutset.update((x, y) for y in nbrs if y in V)\\n    >>> # Because we have set the capacities of all edges to 1\\n    ... # the cutset contains ten edges\\n    ... len(cutset)\\n    10\\n    >>> # You can use any maximum flow algorithm for the underlying\\n    ... # flow computations using the argument flow_func\\n    ... from networkx.algorithms import flow\\n    >>> T = nx.gomory_hu_tree(G, flow_func=flow.boykov_kolmogorov)\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v, flow_func=flow.boykov_kolmogorov)\\n    10\\n\\n    Notes\\n    -----\\n    This implementation is based on Gusfield approach [1]_ to compute\\n    Gomory-Hu trees, which does not require node contractions and has\\n    the same computational complexity than the original method.\\n\\n    See also\\n    --------\\n    :func:`minimum_cut`\\n    :func:`maximum_flow`\\n\\n    References\\n    ----------\\n    .. [1] Gusfield D: Very simple methods for all pairs network flow analysis.\\n           SIAM J Comput 19(1):143-155, 1990.\\n\\n    '\n    if flow_func is None:\n        flow_func = default_flow_func\n    if len(G) == 0:\n        msg = 'Empty Graph does not have a Gomory-Hu tree representation'\n        raise nx.NetworkXError(msg)\n    tree = {}\n    labels = {}\n    iter_nodes = iter(G)\n    root = next(iter_nodes)\n    for n in iter_nodes:\n        tree[n] = root\n    R = build_residual_network(G, capacity)\n    for source in tree:\n        target = tree[source]\n        (cut_value, partition) = nx.minimum_cut(G, source, target, capacity=capacity, flow_func=flow_func, residual=R)\n        labels[source, target] = cut_value\n        for node in partition[0]:\n            if node != source and node in tree and (tree[node] == target):\n                tree[node] = source\n                labels[node, source] = labels.get((node, target), cut_value)\n        if target != root and tree[target] in partition[0]:\n            labels[source, tree[target]] = labels[target, tree[target]]\n            labels[target, source] = cut_value\n            tree[source] = tree[target]\n            tree[target] = source\n    T = nx.Graph()\n    T.add_nodes_from(G)\n    T.add_weighted_edges_from(((u, v, labels[u, v]) for (u, v) in tree.items()))\n    return T",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs={'capacity': float('inf')})\ndef gomory_hu_tree(G, capacity='capacity', flow_func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the Gomory-Hu tree of an undirected graph G.\\n\\n    A Gomory-Hu tree of an undirected graph with capacities is a\\n    weighted tree that represents the minimum s-t cuts for all s-t\\n    pairs in the graph.\\n\\n    It only requires `n-1` minimum cut computations instead of the\\n    obvious `n(n-1)/2`. The tree represents all s-t cuts as the\\n    minimum cut value among any pair of nodes is the minimum edge\\n    weight in the shortest path between the two nodes in the\\n    Gomory-Hu tree.\\n\\n    The Gomory-Hu tree also has the property that removing the\\n    edge with the minimum weight in the shortest path between\\n    any two nodes leaves two connected components that form\\n    a partition of the nodes in G that defines the minimum s-t\\n    cut.\\n\\n    See Examples section below for details.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    flow_func : function\\n        Function to perform the underlying flow computations. Default value\\n        :func:`edmonds_karp`. This function performs better in sparse graphs\\n        with right tailed degree distributions.\\n        :func:`shortest_augmenting_path` will perform better in denser\\n        graphs.\\n\\n    Returns\\n    -------\\n    Tree : NetworkX graph\\n        A NetworkX graph representing the Gomory-Hu tree of the input graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        Raised if the input graph is directed.\\n\\n    NetworkXError\\n        Raised if the input graph is an empty Graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> nx.set_edge_attributes(G, 1, \"capacity\")\\n    >>> T = nx.gomory_hu_tree(G)\\n    >>> # The value of the minimum cut between any pair\\n    ... # of nodes in G is the minimum edge weight in the\\n    ... # shortest path between the two nodes in the\\n    ... # Gomory-Hu tree.\\n    ... def minimum_edge_weight_in_shortest_path(T, u, v):\\n    ...     path = nx.shortest_path(T, u, v, weight=\"weight\")\\n    ...     return min((T[u][v][\"weight\"], (u, v)) for (u, v) in zip(path, path[1:]))\\n    >>> u, v = 0, 33\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v)\\n    10\\n    >>> # The Gomory-Hu tree also has the property that removing the\\n    ... # edge with the minimum weight in the shortest path between\\n    ... # any two nodes leaves two connected components that form\\n    ... # a partition of the nodes in G that defines the minimum s-t\\n    ... # cut.\\n    ... cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> T.remove_edge(*edge)\\n    >>> U, V = list(nx.connected_components(T))\\n    >>> # Thus U and V form a partition that defines a minimum cut\\n    ... # between u and v in G. You can compute the edge cut set,\\n    ... # that is, the set of edges that if removed from G will\\n    ... # disconnect u from v in G, with this information:\\n    ... cutset = set()\\n    >>> for x, nbrs in ((n, G[n]) for n in U):\\n    ...     cutset.update((x, y) for y in nbrs if y in V)\\n    >>> # Because we have set the capacities of all edges to 1\\n    ... # the cutset contains ten edges\\n    ... len(cutset)\\n    10\\n    >>> # You can use any maximum flow algorithm for the underlying\\n    ... # flow computations using the argument flow_func\\n    ... from networkx.algorithms import flow\\n    >>> T = nx.gomory_hu_tree(G, flow_func=flow.boykov_kolmogorov)\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v, flow_func=flow.boykov_kolmogorov)\\n    10\\n\\n    Notes\\n    -----\\n    This implementation is based on Gusfield approach [1]_ to compute\\n    Gomory-Hu trees, which does not require node contractions and has\\n    the same computational complexity than the original method.\\n\\n    See also\\n    --------\\n    :func:`minimum_cut`\\n    :func:`maximum_flow`\\n\\n    References\\n    ----------\\n    .. [1] Gusfield D: Very simple methods for all pairs network flow analysis.\\n           SIAM J Comput 19(1):143-155, 1990.\\n\\n    '\n    if flow_func is None:\n        flow_func = default_flow_func\n    if len(G) == 0:\n        msg = 'Empty Graph does not have a Gomory-Hu tree representation'\n        raise nx.NetworkXError(msg)\n    tree = {}\n    labels = {}\n    iter_nodes = iter(G)\n    root = next(iter_nodes)\n    for n in iter_nodes:\n        tree[n] = root\n    R = build_residual_network(G, capacity)\n    for source in tree:\n        target = tree[source]\n        (cut_value, partition) = nx.minimum_cut(G, source, target, capacity=capacity, flow_func=flow_func, residual=R)\n        labels[source, target] = cut_value\n        for node in partition[0]:\n            if node != source and node in tree and (tree[node] == target):\n                tree[node] = source\n                labels[node, source] = labels.get((node, target), cut_value)\n        if target != root and tree[target] in partition[0]:\n            labels[source, tree[target]] = labels[target, tree[target]]\n            labels[target, source] = cut_value\n            tree[source] = tree[target]\n            tree[target] = source\n    T = nx.Graph()\n    T.add_nodes_from(G)\n    T.add_weighted_edges_from(((u, v, labels[u, v]) for (u, v) in tree.items()))\n    return T",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs={'capacity': float('inf')})\ndef gomory_hu_tree(G, capacity='capacity', flow_func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the Gomory-Hu tree of an undirected graph G.\\n\\n    A Gomory-Hu tree of an undirected graph with capacities is a\\n    weighted tree that represents the minimum s-t cuts for all s-t\\n    pairs in the graph.\\n\\n    It only requires `n-1` minimum cut computations instead of the\\n    obvious `n(n-1)/2`. The tree represents all s-t cuts as the\\n    minimum cut value among any pair of nodes is the minimum edge\\n    weight in the shortest path between the two nodes in the\\n    Gomory-Hu tree.\\n\\n    The Gomory-Hu tree also has the property that removing the\\n    edge with the minimum weight in the shortest path between\\n    any two nodes leaves two connected components that form\\n    a partition of the nodes in G that defines the minimum s-t\\n    cut.\\n\\n    See Examples section below for details.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    flow_func : function\\n        Function to perform the underlying flow computations. Default value\\n        :func:`edmonds_karp`. This function performs better in sparse graphs\\n        with right tailed degree distributions.\\n        :func:`shortest_augmenting_path` will perform better in denser\\n        graphs.\\n\\n    Returns\\n    -------\\n    Tree : NetworkX graph\\n        A NetworkX graph representing the Gomory-Hu tree of the input graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        Raised if the input graph is directed.\\n\\n    NetworkXError\\n        Raised if the input graph is an empty Graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> nx.set_edge_attributes(G, 1, \"capacity\")\\n    >>> T = nx.gomory_hu_tree(G)\\n    >>> # The value of the minimum cut between any pair\\n    ... # of nodes in G is the minimum edge weight in the\\n    ... # shortest path between the two nodes in the\\n    ... # Gomory-Hu tree.\\n    ... def minimum_edge_weight_in_shortest_path(T, u, v):\\n    ...     path = nx.shortest_path(T, u, v, weight=\"weight\")\\n    ...     return min((T[u][v][\"weight\"], (u, v)) for (u, v) in zip(path, path[1:]))\\n    >>> u, v = 0, 33\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v)\\n    10\\n    >>> # The Gomory-Hu tree also has the property that removing the\\n    ... # edge with the minimum weight in the shortest path between\\n    ... # any two nodes leaves two connected components that form\\n    ... # a partition of the nodes in G that defines the minimum s-t\\n    ... # cut.\\n    ... cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> T.remove_edge(*edge)\\n    >>> U, V = list(nx.connected_components(T))\\n    >>> # Thus U and V form a partition that defines a minimum cut\\n    ... # between u and v in G. You can compute the edge cut set,\\n    ... # that is, the set of edges that if removed from G will\\n    ... # disconnect u from v in G, with this information:\\n    ... cutset = set()\\n    >>> for x, nbrs in ((n, G[n]) for n in U):\\n    ...     cutset.update((x, y) for y in nbrs if y in V)\\n    >>> # Because we have set the capacities of all edges to 1\\n    ... # the cutset contains ten edges\\n    ... len(cutset)\\n    10\\n    >>> # You can use any maximum flow algorithm for the underlying\\n    ... # flow computations using the argument flow_func\\n    ... from networkx.algorithms import flow\\n    >>> T = nx.gomory_hu_tree(G, flow_func=flow.boykov_kolmogorov)\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v, flow_func=flow.boykov_kolmogorov)\\n    10\\n\\n    Notes\\n    -----\\n    This implementation is based on Gusfield approach [1]_ to compute\\n    Gomory-Hu trees, which does not require node contractions and has\\n    the same computational complexity than the original method.\\n\\n    See also\\n    --------\\n    :func:`minimum_cut`\\n    :func:`maximum_flow`\\n\\n    References\\n    ----------\\n    .. [1] Gusfield D: Very simple methods for all pairs network flow analysis.\\n           SIAM J Comput 19(1):143-155, 1990.\\n\\n    '\n    if flow_func is None:\n        flow_func = default_flow_func\n    if len(G) == 0:\n        msg = 'Empty Graph does not have a Gomory-Hu tree representation'\n        raise nx.NetworkXError(msg)\n    tree = {}\n    labels = {}\n    iter_nodes = iter(G)\n    root = next(iter_nodes)\n    for n in iter_nodes:\n        tree[n] = root\n    R = build_residual_network(G, capacity)\n    for source in tree:\n        target = tree[source]\n        (cut_value, partition) = nx.minimum_cut(G, source, target, capacity=capacity, flow_func=flow_func, residual=R)\n        labels[source, target] = cut_value\n        for node in partition[0]:\n            if node != source and node in tree and (tree[node] == target):\n                tree[node] = source\n                labels[node, source] = labels.get((node, target), cut_value)\n        if target != root and tree[target] in partition[0]:\n            labels[source, tree[target]] = labels[target, tree[target]]\n            labels[target, source] = cut_value\n            tree[source] = tree[target]\n            tree[target] = source\n    T = nx.Graph()\n    T.add_nodes_from(G)\n    T.add_weighted_edges_from(((u, v, labels[u, v]) for (u, v) in tree.items()))\n    return T",
            "@not_implemented_for('directed')\n@nx._dispatch(edge_attrs={'capacity': float('inf')})\ndef gomory_hu_tree(G, capacity='capacity', flow_func=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the Gomory-Hu tree of an undirected graph G.\\n\\n    A Gomory-Hu tree of an undirected graph with capacities is a\\n    weighted tree that represents the minimum s-t cuts for all s-t\\n    pairs in the graph.\\n\\n    It only requires `n-1` minimum cut computations instead of the\\n    obvious `n(n-1)/2`. The tree represents all s-t cuts as the\\n    minimum cut value among any pair of nodes is the minimum edge\\n    weight in the shortest path between the two nodes in the\\n    Gomory-Hu tree.\\n\\n    The Gomory-Hu tree also has the property that removing the\\n    edge with the minimum weight in the shortest path between\\n    any two nodes leaves two connected components that form\\n    a partition of the nodes in G that defines the minimum s-t\\n    cut.\\n\\n    See Examples section below for details.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        Undirected graph\\n\\n    capacity : string\\n        Edges of the graph G are expected to have an attribute capacity\\n        that indicates how much flow the edge can support. If this\\n        attribute is not present, the edge is considered to have\\n        infinite capacity. Default value: \\'capacity\\'.\\n\\n    flow_func : function\\n        Function to perform the underlying flow computations. Default value\\n        :func:`edmonds_karp`. This function performs better in sparse graphs\\n        with right tailed degree distributions.\\n        :func:`shortest_augmenting_path` will perform better in denser\\n        graphs.\\n\\n    Returns\\n    -------\\n    Tree : NetworkX graph\\n        A NetworkX graph representing the Gomory-Hu tree of the input graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        Raised if the input graph is directed.\\n\\n    NetworkXError\\n        Raised if the input graph is an empty Graph.\\n\\n    Examples\\n    --------\\n    >>> G = nx.karate_club_graph()\\n    >>> nx.set_edge_attributes(G, 1, \"capacity\")\\n    >>> T = nx.gomory_hu_tree(G)\\n    >>> # The value of the minimum cut between any pair\\n    ... # of nodes in G is the minimum edge weight in the\\n    ... # shortest path between the two nodes in the\\n    ... # Gomory-Hu tree.\\n    ... def minimum_edge_weight_in_shortest_path(T, u, v):\\n    ...     path = nx.shortest_path(T, u, v, weight=\"weight\")\\n    ...     return min((T[u][v][\"weight\"], (u, v)) for (u, v) in zip(path, path[1:]))\\n    >>> u, v = 0, 33\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v)\\n    10\\n    >>> # The Gomory-Hu tree also has the property that removing the\\n    ... # edge with the minimum weight in the shortest path between\\n    ... # any two nodes leaves two connected components that form\\n    ... # a partition of the nodes in G that defines the minimum s-t\\n    ... # cut.\\n    ... cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> T.remove_edge(*edge)\\n    >>> U, V = list(nx.connected_components(T))\\n    >>> # Thus U and V form a partition that defines a minimum cut\\n    ... # between u and v in G. You can compute the edge cut set,\\n    ... # that is, the set of edges that if removed from G will\\n    ... # disconnect u from v in G, with this information:\\n    ... cutset = set()\\n    >>> for x, nbrs in ((n, G[n]) for n in U):\\n    ...     cutset.update((x, y) for y in nbrs if y in V)\\n    >>> # Because we have set the capacities of all edges to 1\\n    ... # the cutset contains ten edges\\n    ... len(cutset)\\n    10\\n    >>> # You can use any maximum flow algorithm for the underlying\\n    ... # flow computations using the argument flow_func\\n    ... from networkx.algorithms import flow\\n    >>> T = nx.gomory_hu_tree(G, flow_func=flow.boykov_kolmogorov)\\n    >>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\\n    >>> cut_value\\n    10\\n    >>> nx.minimum_cut_value(G, u, v, flow_func=flow.boykov_kolmogorov)\\n    10\\n\\n    Notes\\n    -----\\n    This implementation is based on Gusfield approach [1]_ to compute\\n    Gomory-Hu trees, which does not require node contractions and has\\n    the same computational complexity than the original method.\\n\\n    See also\\n    --------\\n    :func:`minimum_cut`\\n    :func:`maximum_flow`\\n\\n    References\\n    ----------\\n    .. [1] Gusfield D: Very simple methods for all pairs network flow analysis.\\n           SIAM J Comput 19(1):143-155, 1990.\\n\\n    '\n    if flow_func is None:\n        flow_func = default_flow_func\n    if len(G) == 0:\n        msg = 'Empty Graph does not have a Gomory-Hu tree representation'\n        raise nx.NetworkXError(msg)\n    tree = {}\n    labels = {}\n    iter_nodes = iter(G)\n    root = next(iter_nodes)\n    for n in iter_nodes:\n        tree[n] = root\n    R = build_residual_network(G, capacity)\n    for source in tree:\n        target = tree[source]\n        (cut_value, partition) = nx.minimum_cut(G, source, target, capacity=capacity, flow_func=flow_func, residual=R)\n        labels[source, target] = cut_value\n        for node in partition[0]:\n            if node != source and node in tree and (tree[node] == target):\n                tree[node] = source\n                labels[node, source] = labels.get((node, target), cut_value)\n        if target != root and tree[target] in partition[0]:\n            labels[source, tree[target]] = labels[target, tree[target]]\n            labels[target, source] = cut_value\n            tree[source] = tree[target]\n            tree[target] = source\n    T = nx.Graph()\n    T.add_nodes_from(G)\n    T.add_weighted_edges_from(((u, v, labels[u, v]) for (u, v) in tree.items()))\n    return T"
        ]
    }
]