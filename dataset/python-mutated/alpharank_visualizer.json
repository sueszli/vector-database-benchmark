[
    {
        "func_name": "__init__",
        "original": "def __init__(self, payoff_tables, rhos, rho_m, pi, state_labels, num_top_profiles=None):\n    \"\"\"Initializes a network plotting object.\n\n    Args:\n      payoff_tables: List of game payoff tables, one for each agent identity.\n        Each payoff_table may be either a 2D numpy array, or a\n        _PayoffTableInterface object.\n      rhos: Fixation probabilities.\n      rho_m: Neutral fixation probability.\n      pi: Stationary distribution of fixation Markov chain defined by rhos.\n      state_labels: Labels corresponding to Markov states. For the\n        single-population case, state_labels should be a list of pure strategy\n        names. For the multi-population case, it\n                    should be a dict with (key,value) pairs: (population\n                      index,list of strategy names)\n      num_top_profiles: Set to (int) to show only the graph nodes corresponding\n        to the top k elements of stationary distribution, or None to show all.\n    \"\"\"\n    self.fig = plt.figure(figsize=(10, 10))\n    self.num_populations = len(payoff_tables)\n    payoffs_are_hpt_format = utils.check_payoffs_are_hpt(payoff_tables)\n    self.num_strats_per_population = utils.get_num_strats_per_population(payoff_tables, payoffs_are_hpt_format)\n    self.rhos = rhos\n    self.rho_m = rho_m\n    self.pi = pi\n    self.num_profiles = len(pi)\n    self.state_labels = state_labels\n    self.first_run = True\n    self.num_top_profiles = num_top_profiles\n    if self.num_top_profiles:\n        if self.num_top_profiles > self.num_profiles:\n            self.num_top_profiles = self.num_profiles\n        self.nodes_to_skip = list(self.pi.argsort()[:self.num_profiles - self.num_top_profiles])\n    else:\n        self.nodes_to_skip = []\n    self._reset_cycle_counter()",
        "mutated": [
            "def __init__(self, payoff_tables, rhos, rho_m, pi, state_labels, num_top_profiles=None):\n    if False:\n        i = 10\n    'Initializes a network plotting object.\\n\\n    Args:\\n      payoff_tables: List of game payoff tables, one for each agent identity.\\n        Each payoff_table may be either a 2D numpy array, or a\\n        _PayoffTableInterface object.\\n      rhos: Fixation probabilities.\\n      rho_m: Neutral fixation probability.\\n      pi: Stationary distribution of fixation Markov chain defined by rhos.\\n      state_labels: Labels corresponding to Markov states. For the\\n        single-population case, state_labels should be a list of pure strategy\\n        names. For the multi-population case, it\\n                    should be a dict with (key,value) pairs: (population\\n                      index,list of strategy names)\\n      num_top_profiles: Set to (int) to show only the graph nodes corresponding\\n        to the top k elements of stationary distribution, or None to show all.\\n    '\n    self.fig = plt.figure(figsize=(10, 10))\n    self.num_populations = len(payoff_tables)\n    payoffs_are_hpt_format = utils.check_payoffs_are_hpt(payoff_tables)\n    self.num_strats_per_population = utils.get_num_strats_per_population(payoff_tables, payoffs_are_hpt_format)\n    self.rhos = rhos\n    self.rho_m = rho_m\n    self.pi = pi\n    self.num_profiles = len(pi)\n    self.state_labels = state_labels\n    self.first_run = True\n    self.num_top_profiles = num_top_profiles\n    if self.num_top_profiles:\n        if self.num_top_profiles > self.num_profiles:\n            self.num_top_profiles = self.num_profiles\n        self.nodes_to_skip = list(self.pi.argsort()[:self.num_profiles - self.num_top_profiles])\n    else:\n        self.nodes_to_skip = []\n    self._reset_cycle_counter()",
            "def __init__(self, payoff_tables, rhos, rho_m, pi, state_labels, num_top_profiles=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initializes a network plotting object.\\n\\n    Args:\\n      payoff_tables: List of game payoff tables, one for each agent identity.\\n        Each payoff_table may be either a 2D numpy array, or a\\n        _PayoffTableInterface object.\\n      rhos: Fixation probabilities.\\n      rho_m: Neutral fixation probability.\\n      pi: Stationary distribution of fixation Markov chain defined by rhos.\\n      state_labels: Labels corresponding to Markov states. For the\\n        single-population case, state_labels should be a list of pure strategy\\n        names. For the multi-population case, it\\n                    should be a dict with (key,value) pairs: (population\\n                      index,list of strategy names)\\n      num_top_profiles: Set to (int) to show only the graph nodes corresponding\\n        to the top k elements of stationary distribution, or None to show all.\\n    '\n    self.fig = plt.figure(figsize=(10, 10))\n    self.num_populations = len(payoff_tables)\n    payoffs_are_hpt_format = utils.check_payoffs_are_hpt(payoff_tables)\n    self.num_strats_per_population = utils.get_num_strats_per_population(payoff_tables, payoffs_are_hpt_format)\n    self.rhos = rhos\n    self.rho_m = rho_m\n    self.pi = pi\n    self.num_profiles = len(pi)\n    self.state_labels = state_labels\n    self.first_run = True\n    self.num_top_profiles = num_top_profiles\n    if self.num_top_profiles:\n        if self.num_top_profiles > self.num_profiles:\n            self.num_top_profiles = self.num_profiles\n        self.nodes_to_skip = list(self.pi.argsort()[:self.num_profiles - self.num_top_profiles])\n    else:\n        self.nodes_to_skip = []\n    self._reset_cycle_counter()",
            "def __init__(self, payoff_tables, rhos, rho_m, pi, state_labels, num_top_profiles=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initializes a network plotting object.\\n\\n    Args:\\n      payoff_tables: List of game payoff tables, one for each agent identity.\\n        Each payoff_table may be either a 2D numpy array, or a\\n        _PayoffTableInterface object.\\n      rhos: Fixation probabilities.\\n      rho_m: Neutral fixation probability.\\n      pi: Stationary distribution of fixation Markov chain defined by rhos.\\n      state_labels: Labels corresponding to Markov states. For the\\n        single-population case, state_labels should be a list of pure strategy\\n        names. For the multi-population case, it\\n                    should be a dict with (key,value) pairs: (population\\n                      index,list of strategy names)\\n      num_top_profiles: Set to (int) to show only the graph nodes corresponding\\n        to the top k elements of stationary distribution, or None to show all.\\n    '\n    self.fig = plt.figure(figsize=(10, 10))\n    self.num_populations = len(payoff_tables)\n    payoffs_are_hpt_format = utils.check_payoffs_are_hpt(payoff_tables)\n    self.num_strats_per_population = utils.get_num_strats_per_population(payoff_tables, payoffs_are_hpt_format)\n    self.rhos = rhos\n    self.rho_m = rho_m\n    self.pi = pi\n    self.num_profiles = len(pi)\n    self.state_labels = state_labels\n    self.first_run = True\n    self.num_top_profiles = num_top_profiles\n    if self.num_top_profiles:\n        if self.num_top_profiles > self.num_profiles:\n            self.num_top_profiles = self.num_profiles\n        self.nodes_to_skip = list(self.pi.argsort()[:self.num_profiles - self.num_top_profiles])\n    else:\n        self.nodes_to_skip = []\n    self._reset_cycle_counter()",
            "def __init__(self, payoff_tables, rhos, rho_m, pi, state_labels, num_top_profiles=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initializes a network plotting object.\\n\\n    Args:\\n      payoff_tables: List of game payoff tables, one for each agent identity.\\n        Each payoff_table may be either a 2D numpy array, or a\\n        _PayoffTableInterface object.\\n      rhos: Fixation probabilities.\\n      rho_m: Neutral fixation probability.\\n      pi: Stationary distribution of fixation Markov chain defined by rhos.\\n      state_labels: Labels corresponding to Markov states. For the\\n        single-population case, state_labels should be a list of pure strategy\\n        names. For the multi-population case, it\\n                    should be a dict with (key,value) pairs: (population\\n                      index,list of strategy names)\\n      num_top_profiles: Set to (int) to show only the graph nodes corresponding\\n        to the top k elements of stationary distribution, or None to show all.\\n    '\n    self.fig = plt.figure(figsize=(10, 10))\n    self.num_populations = len(payoff_tables)\n    payoffs_are_hpt_format = utils.check_payoffs_are_hpt(payoff_tables)\n    self.num_strats_per_population = utils.get_num_strats_per_population(payoff_tables, payoffs_are_hpt_format)\n    self.rhos = rhos\n    self.rho_m = rho_m\n    self.pi = pi\n    self.num_profiles = len(pi)\n    self.state_labels = state_labels\n    self.first_run = True\n    self.num_top_profiles = num_top_profiles\n    if self.num_top_profiles:\n        if self.num_top_profiles > self.num_profiles:\n            self.num_top_profiles = self.num_profiles\n        self.nodes_to_skip = list(self.pi.argsort()[:self.num_profiles - self.num_top_profiles])\n    else:\n        self.nodes_to_skip = []\n    self._reset_cycle_counter()",
            "def __init__(self, payoff_tables, rhos, rho_m, pi, state_labels, num_top_profiles=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initializes a network plotting object.\\n\\n    Args:\\n      payoff_tables: List of game payoff tables, one for each agent identity.\\n        Each payoff_table may be either a 2D numpy array, or a\\n        _PayoffTableInterface object.\\n      rhos: Fixation probabilities.\\n      rho_m: Neutral fixation probability.\\n      pi: Stationary distribution of fixation Markov chain defined by rhos.\\n      state_labels: Labels corresponding to Markov states. For the\\n        single-population case, state_labels should be a list of pure strategy\\n        names. For the multi-population case, it\\n                    should be a dict with (key,value) pairs: (population\\n                      index,list of strategy names)\\n      num_top_profiles: Set to (int) to show only the graph nodes corresponding\\n        to the top k elements of stationary distribution, or None to show all.\\n    '\n    self.fig = plt.figure(figsize=(10, 10))\n    self.num_populations = len(payoff_tables)\n    payoffs_are_hpt_format = utils.check_payoffs_are_hpt(payoff_tables)\n    self.num_strats_per_population = utils.get_num_strats_per_population(payoff_tables, payoffs_are_hpt_format)\n    self.rhos = rhos\n    self.rho_m = rho_m\n    self.pi = pi\n    self.num_profiles = len(pi)\n    self.state_labels = state_labels\n    self.first_run = True\n    self.num_top_profiles = num_top_profiles\n    if self.num_top_profiles:\n        if self.num_top_profiles > self.num_profiles:\n            self.num_top_profiles = self.num_profiles\n        self.nodes_to_skip = list(self.pi.argsort()[:self.num_profiles - self.num_top_profiles])\n    else:\n        self.nodes_to_skip = []\n    self._reset_cycle_counter()"
        ]
    },
    {
        "func_name": "_reset_cycle_counter",
        "original": "def _reset_cycle_counter(self):\n    self.i_cycle_to_show = -1",
        "mutated": [
            "def _reset_cycle_counter(self):\n    if False:\n        i = 10\n    self.i_cycle_to_show = -1",
            "def _reset_cycle_counter(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.i_cycle_to_show = -1",
            "def _reset_cycle_counter(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.i_cycle_to_show = -1",
            "def _reset_cycle_counter(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.i_cycle_to_show = -1",
            "def _reset_cycle_counter(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.i_cycle_to_show = -1"
        ]
    },
    {
        "func_name": "_draw_network",
        "original": "def _draw_network(self):\n    \"\"\"Draws the NetworkX object representing the underlying graph.\"\"\"\n    plt.clf()\n    if self.num_populations == 1:\n        node_sizes = 5000\n        node_border_width = 1.0\n    else:\n        node_sizes = 15000\n        node_border_width = 3.0\n    (vmin, vmax) = (0, np.max(self.pi) + 0.1)\n    nx.draw_networkx_nodes(self.g, self.pos, node_size=node_sizes, node_color=self.node_colors, edgecolors='k', cmap=plt.cm.Blues, vmin=vmin, vmax=vmax, linewidths=node_border_width)\n    nx.draw_networkx_edges(self.g, self.pos, node_size=node_sizes, arrowstyle='->', arrowsize=10, edge_color=self.edge_colors, edge_cmap=plt.cm.Blues, width=5)\n    nx.draw_networkx_edge_labels(self.g, self.pos, edge_labels=self.edge_labels)\n    if self.num_populations > 1:\n        subnode_separation = 0.1\n        subgraph = nx.Graph()\n        for i_population in range(self.num_populations):\n            subgraph.add_node(i_population)\n    for i_strat_profile in self.g:\n        (x, y) = self.pos[i_strat_profile]\n        if self.num_populations == 1:\n            node_text = '$\\\\pi_{' + self.state_labels[i_strat_profile] + '}=$'\n            node_text += str(np.round(self.pi[i_strat_profile], decimals=2))\n        else:\n            node_text = ''\n        txt = plt.text(x, y, node_text, horizontalalignment='center', verticalalignment='center', fontsize=12)\n        txt.set_path_effects([PathEffects.withStroke(linewidth=3, foreground='w')])\n        if self.num_populations > 1:\n            sub_pos = nx.circular_layout(subgraph)\n            subnode_labels = dict()\n            strat_profile = utils.get_strat_profile_from_id(self.num_strats_per_population, i_strat_profile)\n            for i_population in subgraph.nodes():\n                i_strat = strat_profile[i_population]\n                subnode_labels[i_population] = '$s^{' + str(i_population + 1) + '}='\n                subnode_labels[i_population] += self.state_labels[i_population][i_strat] + '$'\n                sub_pos[i_population] = -sub_pos[i_population] * subnode_separation + self.pos[i_strat_profile]\n            nx.draw(subgraph, pos=sub_pos, with_labels=True, width=0.0, node_color='w', labels=subnode_labels, node_size=2500)",
        "mutated": [
            "def _draw_network(self):\n    if False:\n        i = 10\n    'Draws the NetworkX object representing the underlying graph.'\n    plt.clf()\n    if self.num_populations == 1:\n        node_sizes = 5000\n        node_border_width = 1.0\n    else:\n        node_sizes = 15000\n        node_border_width = 3.0\n    (vmin, vmax) = (0, np.max(self.pi) + 0.1)\n    nx.draw_networkx_nodes(self.g, self.pos, node_size=node_sizes, node_color=self.node_colors, edgecolors='k', cmap=plt.cm.Blues, vmin=vmin, vmax=vmax, linewidths=node_border_width)\n    nx.draw_networkx_edges(self.g, self.pos, node_size=node_sizes, arrowstyle='->', arrowsize=10, edge_color=self.edge_colors, edge_cmap=plt.cm.Blues, width=5)\n    nx.draw_networkx_edge_labels(self.g, self.pos, edge_labels=self.edge_labels)\n    if self.num_populations > 1:\n        subnode_separation = 0.1\n        subgraph = nx.Graph()\n        for i_population in range(self.num_populations):\n            subgraph.add_node(i_population)\n    for i_strat_profile in self.g:\n        (x, y) = self.pos[i_strat_profile]\n        if self.num_populations == 1:\n            node_text = '$\\\\pi_{' + self.state_labels[i_strat_profile] + '}=$'\n            node_text += str(np.round(self.pi[i_strat_profile], decimals=2))\n        else:\n            node_text = ''\n        txt = plt.text(x, y, node_text, horizontalalignment='center', verticalalignment='center', fontsize=12)\n        txt.set_path_effects([PathEffects.withStroke(linewidth=3, foreground='w')])\n        if self.num_populations > 1:\n            sub_pos = nx.circular_layout(subgraph)\n            subnode_labels = dict()\n            strat_profile = utils.get_strat_profile_from_id(self.num_strats_per_population, i_strat_profile)\n            for i_population in subgraph.nodes():\n                i_strat = strat_profile[i_population]\n                subnode_labels[i_population] = '$s^{' + str(i_population + 1) + '}='\n                subnode_labels[i_population] += self.state_labels[i_population][i_strat] + '$'\n                sub_pos[i_population] = -sub_pos[i_population] * subnode_separation + self.pos[i_strat_profile]\n            nx.draw(subgraph, pos=sub_pos, with_labels=True, width=0.0, node_color='w', labels=subnode_labels, node_size=2500)",
            "def _draw_network(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Draws the NetworkX object representing the underlying graph.'\n    plt.clf()\n    if self.num_populations == 1:\n        node_sizes = 5000\n        node_border_width = 1.0\n    else:\n        node_sizes = 15000\n        node_border_width = 3.0\n    (vmin, vmax) = (0, np.max(self.pi) + 0.1)\n    nx.draw_networkx_nodes(self.g, self.pos, node_size=node_sizes, node_color=self.node_colors, edgecolors='k', cmap=plt.cm.Blues, vmin=vmin, vmax=vmax, linewidths=node_border_width)\n    nx.draw_networkx_edges(self.g, self.pos, node_size=node_sizes, arrowstyle='->', arrowsize=10, edge_color=self.edge_colors, edge_cmap=plt.cm.Blues, width=5)\n    nx.draw_networkx_edge_labels(self.g, self.pos, edge_labels=self.edge_labels)\n    if self.num_populations > 1:\n        subnode_separation = 0.1\n        subgraph = nx.Graph()\n        for i_population in range(self.num_populations):\n            subgraph.add_node(i_population)\n    for i_strat_profile in self.g:\n        (x, y) = self.pos[i_strat_profile]\n        if self.num_populations == 1:\n            node_text = '$\\\\pi_{' + self.state_labels[i_strat_profile] + '}=$'\n            node_text += str(np.round(self.pi[i_strat_profile], decimals=2))\n        else:\n            node_text = ''\n        txt = plt.text(x, y, node_text, horizontalalignment='center', verticalalignment='center', fontsize=12)\n        txt.set_path_effects([PathEffects.withStroke(linewidth=3, foreground='w')])\n        if self.num_populations > 1:\n            sub_pos = nx.circular_layout(subgraph)\n            subnode_labels = dict()\n            strat_profile = utils.get_strat_profile_from_id(self.num_strats_per_population, i_strat_profile)\n            for i_population in subgraph.nodes():\n                i_strat = strat_profile[i_population]\n                subnode_labels[i_population] = '$s^{' + str(i_population + 1) + '}='\n                subnode_labels[i_population] += self.state_labels[i_population][i_strat] + '$'\n                sub_pos[i_population] = -sub_pos[i_population] * subnode_separation + self.pos[i_strat_profile]\n            nx.draw(subgraph, pos=sub_pos, with_labels=True, width=0.0, node_color='w', labels=subnode_labels, node_size=2500)",
            "def _draw_network(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Draws the NetworkX object representing the underlying graph.'\n    plt.clf()\n    if self.num_populations == 1:\n        node_sizes = 5000\n        node_border_width = 1.0\n    else:\n        node_sizes = 15000\n        node_border_width = 3.0\n    (vmin, vmax) = (0, np.max(self.pi) + 0.1)\n    nx.draw_networkx_nodes(self.g, self.pos, node_size=node_sizes, node_color=self.node_colors, edgecolors='k', cmap=plt.cm.Blues, vmin=vmin, vmax=vmax, linewidths=node_border_width)\n    nx.draw_networkx_edges(self.g, self.pos, node_size=node_sizes, arrowstyle='->', arrowsize=10, edge_color=self.edge_colors, edge_cmap=plt.cm.Blues, width=5)\n    nx.draw_networkx_edge_labels(self.g, self.pos, edge_labels=self.edge_labels)\n    if self.num_populations > 1:\n        subnode_separation = 0.1\n        subgraph = nx.Graph()\n        for i_population in range(self.num_populations):\n            subgraph.add_node(i_population)\n    for i_strat_profile in self.g:\n        (x, y) = self.pos[i_strat_profile]\n        if self.num_populations == 1:\n            node_text = '$\\\\pi_{' + self.state_labels[i_strat_profile] + '}=$'\n            node_text += str(np.round(self.pi[i_strat_profile], decimals=2))\n        else:\n            node_text = ''\n        txt = plt.text(x, y, node_text, horizontalalignment='center', verticalalignment='center', fontsize=12)\n        txt.set_path_effects([PathEffects.withStroke(linewidth=3, foreground='w')])\n        if self.num_populations > 1:\n            sub_pos = nx.circular_layout(subgraph)\n            subnode_labels = dict()\n            strat_profile = utils.get_strat_profile_from_id(self.num_strats_per_population, i_strat_profile)\n            for i_population in subgraph.nodes():\n                i_strat = strat_profile[i_population]\n                subnode_labels[i_population] = '$s^{' + str(i_population + 1) + '}='\n                subnode_labels[i_population] += self.state_labels[i_population][i_strat] + '$'\n                sub_pos[i_population] = -sub_pos[i_population] * subnode_separation + self.pos[i_strat_profile]\n            nx.draw(subgraph, pos=sub_pos, with_labels=True, width=0.0, node_color='w', labels=subnode_labels, node_size=2500)",
            "def _draw_network(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Draws the NetworkX object representing the underlying graph.'\n    plt.clf()\n    if self.num_populations == 1:\n        node_sizes = 5000\n        node_border_width = 1.0\n    else:\n        node_sizes = 15000\n        node_border_width = 3.0\n    (vmin, vmax) = (0, np.max(self.pi) + 0.1)\n    nx.draw_networkx_nodes(self.g, self.pos, node_size=node_sizes, node_color=self.node_colors, edgecolors='k', cmap=plt.cm.Blues, vmin=vmin, vmax=vmax, linewidths=node_border_width)\n    nx.draw_networkx_edges(self.g, self.pos, node_size=node_sizes, arrowstyle='->', arrowsize=10, edge_color=self.edge_colors, edge_cmap=plt.cm.Blues, width=5)\n    nx.draw_networkx_edge_labels(self.g, self.pos, edge_labels=self.edge_labels)\n    if self.num_populations > 1:\n        subnode_separation = 0.1\n        subgraph = nx.Graph()\n        for i_population in range(self.num_populations):\n            subgraph.add_node(i_population)\n    for i_strat_profile in self.g:\n        (x, y) = self.pos[i_strat_profile]\n        if self.num_populations == 1:\n            node_text = '$\\\\pi_{' + self.state_labels[i_strat_profile] + '}=$'\n            node_text += str(np.round(self.pi[i_strat_profile], decimals=2))\n        else:\n            node_text = ''\n        txt = plt.text(x, y, node_text, horizontalalignment='center', verticalalignment='center', fontsize=12)\n        txt.set_path_effects([PathEffects.withStroke(linewidth=3, foreground='w')])\n        if self.num_populations > 1:\n            sub_pos = nx.circular_layout(subgraph)\n            subnode_labels = dict()\n            strat_profile = utils.get_strat_profile_from_id(self.num_strats_per_population, i_strat_profile)\n            for i_population in subgraph.nodes():\n                i_strat = strat_profile[i_population]\n                subnode_labels[i_population] = '$s^{' + str(i_population + 1) + '}='\n                subnode_labels[i_population] += self.state_labels[i_population][i_strat] + '$'\n                sub_pos[i_population] = -sub_pos[i_population] * subnode_separation + self.pos[i_strat_profile]\n            nx.draw(subgraph, pos=sub_pos, with_labels=True, width=0.0, node_color='w', labels=subnode_labels, node_size=2500)",
            "def _draw_network(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Draws the NetworkX object representing the underlying graph.'\n    plt.clf()\n    if self.num_populations == 1:\n        node_sizes = 5000\n        node_border_width = 1.0\n    else:\n        node_sizes = 15000\n        node_border_width = 3.0\n    (vmin, vmax) = (0, np.max(self.pi) + 0.1)\n    nx.draw_networkx_nodes(self.g, self.pos, node_size=node_sizes, node_color=self.node_colors, edgecolors='k', cmap=plt.cm.Blues, vmin=vmin, vmax=vmax, linewidths=node_border_width)\n    nx.draw_networkx_edges(self.g, self.pos, node_size=node_sizes, arrowstyle='->', arrowsize=10, edge_color=self.edge_colors, edge_cmap=plt.cm.Blues, width=5)\n    nx.draw_networkx_edge_labels(self.g, self.pos, edge_labels=self.edge_labels)\n    if self.num_populations > 1:\n        subnode_separation = 0.1\n        subgraph = nx.Graph()\n        for i_population in range(self.num_populations):\n            subgraph.add_node(i_population)\n    for i_strat_profile in self.g:\n        (x, y) = self.pos[i_strat_profile]\n        if self.num_populations == 1:\n            node_text = '$\\\\pi_{' + self.state_labels[i_strat_profile] + '}=$'\n            node_text += str(np.round(self.pi[i_strat_profile], decimals=2))\n        else:\n            node_text = ''\n        txt = plt.text(x, y, node_text, horizontalalignment='center', verticalalignment='center', fontsize=12)\n        txt.set_path_effects([PathEffects.withStroke(linewidth=3, foreground='w')])\n        if self.num_populations > 1:\n            sub_pos = nx.circular_layout(subgraph)\n            subnode_labels = dict()\n            strat_profile = utils.get_strat_profile_from_id(self.num_strats_per_population, i_strat_profile)\n            for i_population in subgraph.nodes():\n                i_strat = strat_profile[i_population]\n                subnode_labels[i_population] = '$s^{' + str(i_population + 1) + '}='\n                subnode_labels[i_population] += self.state_labels[i_population][i_strat] + '$'\n                sub_pos[i_population] = -sub_pos[i_population] * subnode_separation + self.pos[i_strat_profile]\n            nx.draw(subgraph, pos=sub_pos, with_labels=True, width=0.0, node_color='w', labels=subnode_labels, node_size=2500)"
        ]
    },
    {
        "func_name": "compute_and_draw_network",
        "original": "def compute_and_draw_network(self):\n    \"\"\"Computes the various node/edge connections of the graph and draws it.\"\"\"\n    if np.max(self.rhos) < self.rho_m:\n        print('All node-to-node fixation probabilities (not including self-cycles are lower than neutral. Thus, no graph will be drawn.')\n        return\n    self.g = nx.MultiDiGraph()\n    self.edge_labels = {}\n    self.edge_alphas = []\n    rho_max = np.max(self.rhos / self.rho_m)\n    rho_m_alpha = 0.1\n    for i in range(self.num_profiles):\n        for j in range(self.num_profiles):\n            if j not in self.nodes_to_skip and i not in self.nodes_to_skip:\n                rate = self.rhos[i][j] / self.rho_m\n                if rate > 1:\n                    alpha = np.clip(rho_m_alpha + (1 - rho_m_alpha) * rate / rho_max, None, 1.0)\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                elif np.isclose(rate, 1):\n                    alpha = rho_m_alpha\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                if i != j and rate > 1:\n                    edge_string = '$' + str(np.round(rate, decimals=2)) + '\\\\rho_m$'\n                else:\n                    edge_string = ''\n                self.edge_labels[i, j] = edge_string\n    self.node_colors = [self.pi[node] for node in self.g.nodes()]\n    self.cycles = list(nx.simple_cycles(self.g))\n    self.num_cycles = len(self.cycles)\n    if self.i_cycle_to_show >= 0:\n        all_cycle_edges = [zip(nodes, nodes[1:] + nodes[:1]) for nodes in self.cycles]\n        cur_cycle_edges = all_cycle_edges[self.i_cycle_to_show]\n        self.edge_colors = []\n        for (u, v) in self.g.edges():\n            if (u, v) in cur_cycle_edges:\n                self.edge_colors.append([1.0, 0.0, 0.0])\n            else:\n                self.edge_colors.append([1.0 - self.g[u][v][0]['weight']] * 3)\n    else:\n        self.edge_colors = [[1.0 - self.g[u][v][0]['weight']] * 3 for (u, v) in self.g.edges()]\n        self.edge_alphas = [self.g[u][v][0]['weight'] for (u, v) in self.g.edges()]\n    ax = plt.gca()\n    self.pos = nx.layout.circular_layout(self.g)\n    all_x = [node_pos[0] for (node, node_pos) in self.pos.items()]\n    all_y = [node_pos[1] for (node, node_pos) in self.pos.items()]\n    min_x = np.min(all_x)\n    max_x = np.max(all_x)\n    min_y = np.min(all_y)\n    max_y = np.max(all_y)\n    for (_, node_pos) in self.pos.items():\n        node_pos[0] -= (max_x + min_x) / 2\n        node_pos[1] -= (max_y + min_y) / 2\n    self._draw_network()\n    if self.first_run:\n        ax.autoscale_view()\n    ax.set_axis_off()\n    ax.set_aspect('equal')\n    plt.ylim(-1.3, 1.3)\n    plt.xlim(-1.3, 1.3)\n    if self.first_run:\n        self.first_run = False\n        plt.axis('off')\n        plt.show()",
        "mutated": [
            "def compute_and_draw_network(self):\n    if False:\n        i = 10\n    'Computes the various node/edge connections of the graph and draws it.'\n    if np.max(self.rhos) < self.rho_m:\n        print('All node-to-node fixation probabilities (not including self-cycles are lower than neutral. Thus, no graph will be drawn.')\n        return\n    self.g = nx.MultiDiGraph()\n    self.edge_labels = {}\n    self.edge_alphas = []\n    rho_max = np.max(self.rhos / self.rho_m)\n    rho_m_alpha = 0.1\n    for i in range(self.num_profiles):\n        for j in range(self.num_profiles):\n            if j not in self.nodes_to_skip and i not in self.nodes_to_skip:\n                rate = self.rhos[i][j] / self.rho_m\n                if rate > 1:\n                    alpha = np.clip(rho_m_alpha + (1 - rho_m_alpha) * rate / rho_max, None, 1.0)\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                elif np.isclose(rate, 1):\n                    alpha = rho_m_alpha\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                if i != j and rate > 1:\n                    edge_string = '$' + str(np.round(rate, decimals=2)) + '\\\\rho_m$'\n                else:\n                    edge_string = ''\n                self.edge_labels[i, j] = edge_string\n    self.node_colors = [self.pi[node] for node in self.g.nodes()]\n    self.cycles = list(nx.simple_cycles(self.g))\n    self.num_cycles = len(self.cycles)\n    if self.i_cycle_to_show >= 0:\n        all_cycle_edges = [zip(nodes, nodes[1:] + nodes[:1]) for nodes in self.cycles]\n        cur_cycle_edges = all_cycle_edges[self.i_cycle_to_show]\n        self.edge_colors = []\n        for (u, v) in self.g.edges():\n            if (u, v) in cur_cycle_edges:\n                self.edge_colors.append([1.0, 0.0, 0.0])\n            else:\n                self.edge_colors.append([1.0 - self.g[u][v][0]['weight']] * 3)\n    else:\n        self.edge_colors = [[1.0 - self.g[u][v][0]['weight']] * 3 for (u, v) in self.g.edges()]\n        self.edge_alphas = [self.g[u][v][0]['weight'] for (u, v) in self.g.edges()]\n    ax = plt.gca()\n    self.pos = nx.layout.circular_layout(self.g)\n    all_x = [node_pos[0] for (node, node_pos) in self.pos.items()]\n    all_y = [node_pos[1] for (node, node_pos) in self.pos.items()]\n    min_x = np.min(all_x)\n    max_x = np.max(all_x)\n    min_y = np.min(all_y)\n    max_y = np.max(all_y)\n    for (_, node_pos) in self.pos.items():\n        node_pos[0] -= (max_x + min_x) / 2\n        node_pos[1] -= (max_y + min_y) / 2\n    self._draw_network()\n    if self.first_run:\n        ax.autoscale_view()\n    ax.set_axis_off()\n    ax.set_aspect('equal')\n    plt.ylim(-1.3, 1.3)\n    plt.xlim(-1.3, 1.3)\n    if self.first_run:\n        self.first_run = False\n        plt.axis('off')\n        plt.show()",
            "def compute_and_draw_network(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes the various node/edge connections of the graph and draws it.'\n    if np.max(self.rhos) < self.rho_m:\n        print('All node-to-node fixation probabilities (not including self-cycles are lower than neutral. Thus, no graph will be drawn.')\n        return\n    self.g = nx.MultiDiGraph()\n    self.edge_labels = {}\n    self.edge_alphas = []\n    rho_max = np.max(self.rhos / self.rho_m)\n    rho_m_alpha = 0.1\n    for i in range(self.num_profiles):\n        for j in range(self.num_profiles):\n            if j not in self.nodes_to_skip and i not in self.nodes_to_skip:\n                rate = self.rhos[i][j] / self.rho_m\n                if rate > 1:\n                    alpha = np.clip(rho_m_alpha + (1 - rho_m_alpha) * rate / rho_max, None, 1.0)\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                elif np.isclose(rate, 1):\n                    alpha = rho_m_alpha\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                if i != j and rate > 1:\n                    edge_string = '$' + str(np.round(rate, decimals=2)) + '\\\\rho_m$'\n                else:\n                    edge_string = ''\n                self.edge_labels[i, j] = edge_string\n    self.node_colors = [self.pi[node] for node in self.g.nodes()]\n    self.cycles = list(nx.simple_cycles(self.g))\n    self.num_cycles = len(self.cycles)\n    if self.i_cycle_to_show >= 0:\n        all_cycle_edges = [zip(nodes, nodes[1:] + nodes[:1]) for nodes in self.cycles]\n        cur_cycle_edges = all_cycle_edges[self.i_cycle_to_show]\n        self.edge_colors = []\n        for (u, v) in self.g.edges():\n            if (u, v) in cur_cycle_edges:\n                self.edge_colors.append([1.0, 0.0, 0.0])\n            else:\n                self.edge_colors.append([1.0 - self.g[u][v][0]['weight']] * 3)\n    else:\n        self.edge_colors = [[1.0 - self.g[u][v][0]['weight']] * 3 for (u, v) in self.g.edges()]\n        self.edge_alphas = [self.g[u][v][0]['weight'] for (u, v) in self.g.edges()]\n    ax = plt.gca()\n    self.pos = nx.layout.circular_layout(self.g)\n    all_x = [node_pos[0] for (node, node_pos) in self.pos.items()]\n    all_y = [node_pos[1] for (node, node_pos) in self.pos.items()]\n    min_x = np.min(all_x)\n    max_x = np.max(all_x)\n    min_y = np.min(all_y)\n    max_y = np.max(all_y)\n    for (_, node_pos) in self.pos.items():\n        node_pos[0] -= (max_x + min_x) / 2\n        node_pos[1] -= (max_y + min_y) / 2\n    self._draw_network()\n    if self.first_run:\n        ax.autoscale_view()\n    ax.set_axis_off()\n    ax.set_aspect('equal')\n    plt.ylim(-1.3, 1.3)\n    plt.xlim(-1.3, 1.3)\n    if self.first_run:\n        self.first_run = False\n        plt.axis('off')\n        plt.show()",
            "def compute_and_draw_network(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes the various node/edge connections of the graph and draws it.'\n    if np.max(self.rhos) < self.rho_m:\n        print('All node-to-node fixation probabilities (not including self-cycles are lower than neutral. Thus, no graph will be drawn.')\n        return\n    self.g = nx.MultiDiGraph()\n    self.edge_labels = {}\n    self.edge_alphas = []\n    rho_max = np.max(self.rhos / self.rho_m)\n    rho_m_alpha = 0.1\n    for i in range(self.num_profiles):\n        for j in range(self.num_profiles):\n            if j not in self.nodes_to_skip and i not in self.nodes_to_skip:\n                rate = self.rhos[i][j] / self.rho_m\n                if rate > 1:\n                    alpha = np.clip(rho_m_alpha + (1 - rho_m_alpha) * rate / rho_max, None, 1.0)\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                elif np.isclose(rate, 1):\n                    alpha = rho_m_alpha\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                if i != j and rate > 1:\n                    edge_string = '$' + str(np.round(rate, decimals=2)) + '\\\\rho_m$'\n                else:\n                    edge_string = ''\n                self.edge_labels[i, j] = edge_string\n    self.node_colors = [self.pi[node] for node in self.g.nodes()]\n    self.cycles = list(nx.simple_cycles(self.g))\n    self.num_cycles = len(self.cycles)\n    if self.i_cycle_to_show >= 0:\n        all_cycle_edges = [zip(nodes, nodes[1:] + nodes[:1]) for nodes in self.cycles]\n        cur_cycle_edges = all_cycle_edges[self.i_cycle_to_show]\n        self.edge_colors = []\n        for (u, v) in self.g.edges():\n            if (u, v) in cur_cycle_edges:\n                self.edge_colors.append([1.0, 0.0, 0.0])\n            else:\n                self.edge_colors.append([1.0 - self.g[u][v][0]['weight']] * 3)\n    else:\n        self.edge_colors = [[1.0 - self.g[u][v][0]['weight']] * 3 for (u, v) in self.g.edges()]\n        self.edge_alphas = [self.g[u][v][0]['weight'] for (u, v) in self.g.edges()]\n    ax = plt.gca()\n    self.pos = nx.layout.circular_layout(self.g)\n    all_x = [node_pos[0] for (node, node_pos) in self.pos.items()]\n    all_y = [node_pos[1] for (node, node_pos) in self.pos.items()]\n    min_x = np.min(all_x)\n    max_x = np.max(all_x)\n    min_y = np.min(all_y)\n    max_y = np.max(all_y)\n    for (_, node_pos) in self.pos.items():\n        node_pos[0] -= (max_x + min_x) / 2\n        node_pos[1] -= (max_y + min_y) / 2\n    self._draw_network()\n    if self.first_run:\n        ax.autoscale_view()\n    ax.set_axis_off()\n    ax.set_aspect('equal')\n    plt.ylim(-1.3, 1.3)\n    plt.xlim(-1.3, 1.3)\n    if self.first_run:\n        self.first_run = False\n        plt.axis('off')\n        plt.show()",
            "def compute_and_draw_network(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes the various node/edge connections of the graph and draws it.'\n    if np.max(self.rhos) < self.rho_m:\n        print('All node-to-node fixation probabilities (not including self-cycles are lower than neutral. Thus, no graph will be drawn.')\n        return\n    self.g = nx.MultiDiGraph()\n    self.edge_labels = {}\n    self.edge_alphas = []\n    rho_max = np.max(self.rhos / self.rho_m)\n    rho_m_alpha = 0.1\n    for i in range(self.num_profiles):\n        for j in range(self.num_profiles):\n            if j not in self.nodes_to_skip and i not in self.nodes_to_skip:\n                rate = self.rhos[i][j] / self.rho_m\n                if rate > 1:\n                    alpha = np.clip(rho_m_alpha + (1 - rho_m_alpha) * rate / rho_max, None, 1.0)\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                elif np.isclose(rate, 1):\n                    alpha = rho_m_alpha\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                if i != j and rate > 1:\n                    edge_string = '$' + str(np.round(rate, decimals=2)) + '\\\\rho_m$'\n                else:\n                    edge_string = ''\n                self.edge_labels[i, j] = edge_string\n    self.node_colors = [self.pi[node] for node in self.g.nodes()]\n    self.cycles = list(nx.simple_cycles(self.g))\n    self.num_cycles = len(self.cycles)\n    if self.i_cycle_to_show >= 0:\n        all_cycle_edges = [zip(nodes, nodes[1:] + nodes[:1]) for nodes in self.cycles]\n        cur_cycle_edges = all_cycle_edges[self.i_cycle_to_show]\n        self.edge_colors = []\n        for (u, v) in self.g.edges():\n            if (u, v) in cur_cycle_edges:\n                self.edge_colors.append([1.0, 0.0, 0.0])\n            else:\n                self.edge_colors.append([1.0 - self.g[u][v][0]['weight']] * 3)\n    else:\n        self.edge_colors = [[1.0 - self.g[u][v][0]['weight']] * 3 for (u, v) in self.g.edges()]\n        self.edge_alphas = [self.g[u][v][0]['weight'] for (u, v) in self.g.edges()]\n    ax = plt.gca()\n    self.pos = nx.layout.circular_layout(self.g)\n    all_x = [node_pos[0] for (node, node_pos) in self.pos.items()]\n    all_y = [node_pos[1] for (node, node_pos) in self.pos.items()]\n    min_x = np.min(all_x)\n    max_x = np.max(all_x)\n    min_y = np.min(all_y)\n    max_y = np.max(all_y)\n    for (_, node_pos) in self.pos.items():\n        node_pos[0] -= (max_x + min_x) / 2\n        node_pos[1] -= (max_y + min_y) / 2\n    self._draw_network()\n    if self.first_run:\n        ax.autoscale_view()\n    ax.set_axis_off()\n    ax.set_aspect('equal')\n    plt.ylim(-1.3, 1.3)\n    plt.xlim(-1.3, 1.3)\n    if self.first_run:\n        self.first_run = False\n        plt.axis('off')\n        plt.show()",
            "def compute_and_draw_network(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes the various node/edge connections of the graph and draws it.'\n    if np.max(self.rhos) < self.rho_m:\n        print('All node-to-node fixation probabilities (not including self-cycles are lower than neutral. Thus, no graph will be drawn.')\n        return\n    self.g = nx.MultiDiGraph()\n    self.edge_labels = {}\n    self.edge_alphas = []\n    rho_max = np.max(self.rhos / self.rho_m)\n    rho_m_alpha = 0.1\n    for i in range(self.num_profiles):\n        for j in range(self.num_profiles):\n            if j not in self.nodes_to_skip and i not in self.nodes_to_skip:\n                rate = self.rhos[i][j] / self.rho_m\n                if rate > 1:\n                    alpha = np.clip(rho_m_alpha + (1 - rho_m_alpha) * rate / rho_max, None, 1.0)\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                elif np.isclose(rate, 1):\n                    alpha = rho_m_alpha\n                    self.g.add_edge(i, j, weight=alpha, label='{:.01f}'.format(rate))\n                    self.edge_alphas.append(alpha)\n                if i != j and rate > 1:\n                    edge_string = '$' + str(np.round(rate, decimals=2)) + '\\\\rho_m$'\n                else:\n                    edge_string = ''\n                self.edge_labels[i, j] = edge_string\n    self.node_colors = [self.pi[node] for node in self.g.nodes()]\n    self.cycles = list(nx.simple_cycles(self.g))\n    self.num_cycles = len(self.cycles)\n    if self.i_cycle_to_show >= 0:\n        all_cycle_edges = [zip(nodes, nodes[1:] + nodes[:1]) for nodes in self.cycles]\n        cur_cycle_edges = all_cycle_edges[self.i_cycle_to_show]\n        self.edge_colors = []\n        for (u, v) in self.g.edges():\n            if (u, v) in cur_cycle_edges:\n                self.edge_colors.append([1.0, 0.0, 0.0])\n            else:\n                self.edge_colors.append([1.0 - self.g[u][v][0]['weight']] * 3)\n    else:\n        self.edge_colors = [[1.0 - self.g[u][v][0]['weight']] * 3 for (u, v) in self.g.edges()]\n        self.edge_alphas = [self.g[u][v][0]['weight'] for (u, v) in self.g.edges()]\n    ax = plt.gca()\n    self.pos = nx.layout.circular_layout(self.g)\n    all_x = [node_pos[0] for (node, node_pos) in self.pos.items()]\n    all_y = [node_pos[1] for (node, node_pos) in self.pos.items()]\n    min_x = np.min(all_x)\n    max_x = np.max(all_x)\n    min_y = np.min(all_y)\n    max_y = np.max(all_y)\n    for (_, node_pos) in self.pos.items():\n        node_pos[0] -= (max_x + min_x) / 2\n        node_pos[1] -= (max_y + min_y) / 2\n    self._draw_network()\n    if self.first_run:\n        ax.autoscale_view()\n    ax.set_axis_off()\n    ax.set_aspect('equal')\n    plt.ylim(-1.3, 1.3)\n    plt.xlim(-1.3, 1.3)\n    if self.first_run:\n        self.first_run = False\n        plt.axis('off')\n        plt.show()"
        ]
    },
    {
        "func_name": "_draw_pie",
        "original": "def _draw_pie(ax, ratios, colors, x_center=0, y_center=0, size=100, clip_on=True, zorder=0):\n    \"\"\"Plots a pie chart.\n\n  Args:\n    ax: plot axis.\n    ratios: list indicating size of each pie slice, with elements summing to 1.\n    colors: list indicating color of each pie slice.\n    x_center: x coordinate of pie center.\n    y_center: y coordinate of pie center.\n    size: pie size.\n    clip_on: control clipping of pie (e.g., to show it when it's out of axis).\n    zorder: plot z order (e.g., to show pie on top of other plot elements).\n  \"\"\"\n    xy = []\n    start = 0.0\n    for ratio in ratios:\n        x = [0] + np.cos(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        y = [0] + np.sin(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        xy.append(list(zip(x, y)))\n        start += ratio\n    for (i, xyi) in enumerate(xy):\n        ax.scatter([x_center], [y_center], marker=xyi, s=size, facecolor=colors[i], edgecolors='none', clip_on=clip_on, zorder=zorder)",
        "mutated": [
            "def _draw_pie(ax, ratios, colors, x_center=0, y_center=0, size=100, clip_on=True, zorder=0):\n    if False:\n        i = 10\n    \"Plots a pie chart.\\n\\n  Args:\\n    ax: plot axis.\\n    ratios: list indicating size of each pie slice, with elements summing to 1.\\n    colors: list indicating color of each pie slice.\\n    x_center: x coordinate of pie center.\\n    y_center: y coordinate of pie center.\\n    size: pie size.\\n    clip_on: control clipping of pie (e.g., to show it when it's out of axis).\\n    zorder: plot z order (e.g., to show pie on top of other plot elements).\\n  \"\n    xy = []\n    start = 0.0\n    for ratio in ratios:\n        x = [0] + np.cos(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        y = [0] + np.sin(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        xy.append(list(zip(x, y)))\n        start += ratio\n    for (i, xyi) in enumerate(xy):\n        ax.scatter([x_center], [y_center], marker=xyi, s=size, facecolor=colors[i], edgecolors='none', clip_on=clip_on, zorder=zorder)",
            "def _draw_pie(ax, ratios, colors, x_center=0, y_center=0, size=100, clip_on=True, zorder=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Plots a pie chart.\\n\\n  Args:\\n    ax: plot axis.\\n    ratios: list indicating size of each pie slice, with elements summing to 1.\\n    colors: list indicating color of each pie slice.\\n    x_center: x coordinate of pie center.\\n    y_center: y coordinate of pie center.\\n    size: pie size.\\n    clip_on: control clipping of pie (e.g., to show it when it's out of axis).\\n    zorder: plot z order (e.g., to show pie on top of other plot elements).\\n  \"\n    xy = []\n    start = 0.0\n    for ratio in ratios:\n        x = [0] + np.cos(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        y = [0] + np.sin(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        xy.append(list(zip(x, y)))\n        start += ratio\n    for (i, xyi) in enumerate(xy):\n        ax.scatter([x_center], [y_center], marker=xyi, s=size, facecolor=colors[i], edgecolors='none', clip_on=clip_on, zorder=zorder)",
            "def _draw_pie(ax, ratios, colors, x_center=0, y_center=0, size=100, clip_on=True, zorder=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Plots a pie chart.\\n\\n  Args:\\n    ax: plot axis.\\n    ratios: list indicating size of each pie slice, with elements summing to 1.\\n    colors: list indicating color of each pie slice.\\n    x_center: x coordinate of pie center.\\n    y_center: y coordinate of pie center.\\n    size: pie size.\\n    clip_on: control clipping of pie (e.g., to show it when it's out of axis).\\n    zorder: plot z order (e.g., to show pie on top of other plot elements).\\n  \"\n    xy = []\n    start = 0.0\n    for ratio in ratios:\n        x = [0] + np.cos(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        y = [0] + np.sin(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        xy.append(list(zip(x, y)))\n        start += ratio\n    for (i, xyi) in enumerate(xy):\n        ax.scatter([x_center], [y_center], marker=xyi, s=size, facecolor=colors[i], edgecolors='none', clip_on=clip_on, zorder=zorder)",
            "def _draw_pie(ax, ratios, colors, x_center=0, y_center=0, size=100, clip_on=True, zorder=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Plots a pie chart.\\n\\n  Args:\\n    ax: plot axis.\\n    ratios: list indicating size of each pie slice, with elements summing to 1.\\n    colors: list indicating color of each pie slice.\\n    x_center: x coordinate of pie center.\\n    y_center: y coordinate of pie center.\\n    size: pie size.\\n    clip_on: control clipping of pie (e.g., to show it when it's out of axis).\\n    zorder: plot z order (e.g., to show pie on top of other plot elements).\\n  \"\n    xy = []\n    start = 0.0\n    for ratio in ratios:\n        x = [0] + np.cos(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        y = [0] + np.sin(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        xy.append(list(zip(x, y)))\n        start += ratio\n    for (i, xyi) in enumerate(xy):\n        ax.scatter([x_center], [y_center], marker=xyi, s=size, facecolor=colors[i], edgecolors='none', clip_on=clip_on, zorder=zorder)",
            "def _draw_pie(ax, ratios, colors, x_center=0, y_center=0, size=100, clip_on=True, zorder=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Plots a pie chart.\\n\\n  Args:\\n    ax: plot axis.\\n    ratios: list indicating size of each pie slice, with elements summing to 1.\\n    colors: list indicating color of each pie slice.\\n    x_center: x coordinate of pie center.\\n    y_center: y coordinate of pie center.\\n    size: pie size.\\n    clip_on: control clipping of pie (e.g., to show it when it's out of axis).\\n    zorder: plot z order (e.g., to show pie on top of other plot elements).\\n  \"\n    xy = []\n    start = 0.0\n    for ratio in ratios:\n        x = [0] + np.cos(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        y = [0] + np.sin(np.linspace(2 * np.pi * start, 2 * np.pi * (start + ratio), 30)).tolist()\n        xy.append(list(zip(x, y)))\n        start += ratio\n    for (i, xyi) in enumerate(xy):\n        ax.scatter([x_center], [y_center], marker=xyi, s=size, facecolor=colors[i], edgecolors='none', clip_on=clip_on, zorder=zorder)"
        ]
    },
    {
        "func_name": "generate_sorted_masses_strats",
        "original": "def generate_sorted_masses_strats(pi_list, curr_alpha_idx, strats_to_go):\n    \"\"\"Generates a sorted list of (mass, strats) tuples.\n\n  Args:\n    pi_list: List of stationary distributions, pi\n    curr_alpha_idx: Index in alpha_list for which to start clustering\n    strats_to_go: List of strategies that still need to be ordered\n\n  Returns:\n    Sorted list of (mass, strats) tuples.\n  \"\"\"\n    if curr_alpha_idx > 0:\n        sorted_masses_strats = list()\n        masses_to_strats = utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go])\n        for (mass, strats) in sorted(masses_to_strats.items(), reverse=True):\n            if len(strats) > 1:\n                to_append = generate_sorted_masses_strats(pi_list, curr_alpha_idx - 1, strats)\n                to_append = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_append]\n                sorted_masses_strats.extend(to_append)\n            else:\n                sorted_masses_strats.append((mass, [strats_to_go[strats[0]]]))\n        return sorted_masses_strats\n    else:\n        to_return = sorted(utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go]).items(), reverse=True)\n        to_return = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_return]\n        return to_return",
        "mutated": [
            "def generate_sorted_masses_strats(pi_list, curr_alpha_idx, strats_to_go):\n    if False:\n        i = 10\n    'Generates a sorted list of (mass, strats) tuples.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi\\n    curr_alpha_idx: Index in alpha_list for which to start clustering\\n    strats_to_go: List of strategies that still need to be ordered\\n\\n  Returns:\\n    Sorted list of (mass, strats) tuples.\\n  '\n    if curr_alpha_idx > 0:\n        sorted_masses_strats = list()\n        masses_to_strats = utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go])\n        for (mass, strats) in sorted(masses_to_strats.items(), reverse=True):\n            if len(strats) > 1:\n                to_append = generate_sorted_masses_strats(pi_list, curr_alpha_idx - 1, strats)\n                to_append = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_append]\n                sorted_masses_strats.extend(to_append)\n            else:\n                sorted_masses_strats.append((mass, [strats_to_go[strats[0]]]))\n        return sorted_masses_strats\n    else:\n        to_return = sorted(utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go]).items(), reverse=True)\n        to_return = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_return]\n        return to_return",
            "def generate_sorted_masses_strats(pi_list, curr_alpha_idx, strats_to_go):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Generates a sorted list of (mass, strats) tuples.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi\\n    curr_alpha_idx: Index in alpha_list for which to start clustering\\n    strats_to_go: List of strategies that still need to be ordered\\n\\n  Returns:\\n    Sorted list of (mass, strats) tuples.\\n  '\n    if curr_alpha_idx > 0:\n        sorted_masses_strats = list()\n        masses_to_strats = utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go])\n        for (mass, strats) in sorted(masses_to_strats.items(), reverse=True):\n            if len(strats) > 1:\n                to_append = generate_sorted_masses_strats(pi_list, curr_alpha_idx - 1, strats)\n                to_append = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_append]\n                sorted_masses_strats.extend(to_append)\n            else:\n                sorted_masses_strats.append((mass, [strats_to_go[strats[0]]]))\n        return sorted_masses_strats\n    else:\n        to_return = sorted(utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go]).items(), reverse=True)\n        to_return = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_return]\n        return to_return",
            "def generate_sorted_masses_strats(pi_list, curr_alpha_idx, strats_to_go):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Generates a sorted list of (mass, strats) tuples.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi\\n    curr_alpha_idx: Index in alpha_list for which to start clustering\\n    strats_to_go: List of strategies that still need to be ordered\\n\\n  Returns:\\n    Sorted list of (mass, strats) tuples.\\n  '\n    if curr_alpha_idx > 0:\n        sorted_masses_strats = list()\n        masses_to_strats = utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go])\n        for (mass, strats) in sorted(masses_to_strats.items(), reverse=True):\n            if len(strats) > 1:\n                to_append = generate_sorted_masses_strats(pi_list, curr_alpha_idx - 1, strats)\n                to_append = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_append]\n                sorted_masses_strats.extend(to_append)\n            else:\n                sorted_masses_strats.append((mass, [strats_to_go[strats[0]]]))\n        return sorted_masses_strats\n    else:\n        to_return = sorted(utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go]).items(), reverse=True)\n        to_return = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_return]\n        return to_return",
            "def generate_sorted_masses_strats(pi_list, curr_alpha_idx, strats_to_go):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Generates a sorted list of (mass, strats) tuples.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi\\n    curr_alpha_idx: Index in alpha_list for which to start clustering\\n    strats_to_go: List of strategies that still need to be ordered\\n\\n  Returns:\\n    Sorted list of (mass, strats) tuples.\\n  '\n    if curr_alpha_idx > 0:\n        sorted_masses_strats = list()\n        masses_to_strats = utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go])\n        for (mass, strats) in sorted(masses_to_strats.items(), reverse=True):\n            if len(strats) > 1:\n                to_append = generate_sorted_masses_strats(pi_list, curr_alpha_idx - 1, strats)\n                to_append = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_append]\n                sorted_masses_strats.extend(to_append)\n            else:\n                sorted_masses_strats.append((mass, [strats_to_go[strats[0]]]))\n        return sorted_masses_strats\n    else:\n        to_return = sorted(utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go]).items(), reverse=True)\n        to_return = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_return]\n        return to_return",
            "def generate_sorted_masses_strats(pi_list, curr_alpha_idx, strats_to_go):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Generates a sorted list of (mass, strats) tuples.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi\\n    curr_alpha_idx: Index in alpha_list for which to start clustering\\n    strats_to_go: List of strategies that still need to be ordered\\n\\n  Returns:\\n    Sorted list of (mass, strats) tuples.\\n  '\n    if curr_alpha_idx > 0:\n        sorted_masses_strats = list()\n        masses_to_strats = utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go])\n        for (mass, strats) in sorted(masses_to_strats.items(), reverse=True):\n            if len(strats) > 1:\n                to_append = generate_sorted_masses_strats(pi_list, curr_alpha_idx - 1, strats)\n                to_append = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_append]\n                sorted_masses_strats.extend(to_append)\n            else:\n                sorted_masses_strats.append((mass, [strats_to_go[strats[0]]]))\n        return sorted_masses_strats\n    else:\n        to_return = sorted(utils.cluster_strats(pi_list[curr_alpha_idx, strats_to_go]).items(), reverse=True)\n        to_return = [(mass, [strats_to_go[s] for s in strats_list]) for (mass, strats_list) in to_return]\n        return to_return"
        ]
    },
    {
        "func_name": "plot_pi_vs_alpha",
        "original": "def plot_pi_vs_alpha(pi_list, alpha_list, num_populations, num_strats_per_population, strat_labels, num_strats_to_label, plot_semilogx=True, xlabel='Ranking-intensity $\\\\alpha$', ylabel='Strategy mass in stationary distribution $\\\\pi$', legend_sort_clusters=False):\n    \"\"\"Plots stationary distributions, pi, against selection intensities, alpha.\n\n  Args:\n    pi_list: List of stationary distributions, pi.\n    alpha_list: List of selection intensities, alpha.\n    num_populations: The number of populations.\n    num_strats_per_population: List of the number of strategies per population.\n    strat_labels: Human-readable strategy labels.\n    num_strats_to_label: The number of top strategies to label in the legend.\n    plot_semilogx: Boolean set to enable/disable semilogx plot.\n    xlabel: Plot xlabel.\n    ylabel: Plot ylabel.\n    legend_sort_clusters: If true, strategies in the same cluster are sorted in\n      the legend according to orderings for earlier alpha values. Primarily for\n      visualization purposes! Rankings for lower alpha values should be\n      interpreted carefully.\n  \"\"\"\n    masses_to_strats = utils.cluster_strats(pi_list[-1, :])\n    num_strat_profiles = np.shape(pi_list)[1]\n    num_strats_to_label = min(num_strats_to_label, num_strat_profiles)\n    cmap = plt.get_cmap('Paired')\n    colors = [cmap(i) for i in np.linspace(0, 1, num_strat_profiles)]\n    plt.figure(facecolor='w')\n    axes = plt.gca()\n    legend_line_objects = []\n    legend_labels = []\n    rank = 1\n    num_strats_printed = 0\n    add_legend_entries = True\n    if legend_sort_clusters:\n        sorted_masses_strats = generate_sorted_masses_strats(pi_list, pi_list.shape[0] - 1, range(pi_list.shape[1]))\n    else:\n        sorted_masses_strats = sorted(masses_to_strats.items(), reverse=True)\n    for (mass, strats) in sorted_masses_strats:\n        for profile_id in strats:\n            if num_populations == 1:\n                strat_profile = profile_id\n            else:\n                strat_profile = utils.get_strat_profile_from_id(num_strats_per_population, profile_id)\n            if plot_semilogx:\n                series = plt.semilogx(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            else:\n                series = plt.plot(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            if add_legend_entries:\n                if num_strats_printed >= num_strats_to_label:\n                    series = plt.semilogx(np.NaN, np.NaN, '-', color='none')\n                    label = '...'\n                    add_legend_entries = False\n                else:\n                    label = utils.get_label_from_strat_profile(num_populations, strat_profile, strat_labels)\n                legend_labels.append(label)\n                legend_line_objects.append(series[0])\n            num_strats_printed += 1\n        rank += 1\n    for (mass, strats) in iter(masses_to_strats.items()):\n        _draw_pie(axes, ratios=[1 / len(strats)] * len(strats), colors=[colors[i] for i in strats], x_center=alpha_list[-1], y_center=mass, size=200, clip_on=False, zorder=10)\n    max_mass = np.amax(pi_list)\n    axes_y_max = np.ceil(10.0 * max_mass) / 10\n    axes_y_max = np.clip(axes_y_max, 0.0, 1.0)\n    box_x_min = alpha_list[-1] * 0.7\n    box_y_min = np.min(pi_list[-1, :]) - 0.05 * axes_y_max\n    width = 0.7 * alpha_list[-1]\n    height = np.max(pi_list[-1, :]) - np.min(pi_list[-1, :]) + 0.05 * axes_y_max * 2\n    axes.add_patch(patches.Rectangle((box_x_min, box_y_min), width, height, edgecolor='b', facecolor=(1, 0, 0, 0), clip_on=False, linewidth=5, zorder=20))\n    axes.set_xlim(np.min(alpha_list), np.max(alpha_list))\n    axes.set_ylim([0.0, axes_y_max])\n    axes.set_xlabel(xlabel)\n    axes.set_ylabel(ylabel)\n    axes.set_axisbelow(True)\n    box = axes.get_position()\n    axes.set_position([box.x0, box.y0, box.width * 0.8, box.height])\n    axes.legend(legend_line_objects, legend_labels, loc='center left', bbox_to_anchor=(1.05, 0.5))\n    plt.grid()\n    plt.show()",
        "mutated": [
            "def plot_pi_vs_alpha(pi_list, alpha_list, num_populations, num_strats_per_population, strat_labels, num_strats_to_label, plot_semilogx=True, xlabel='Ranking-intensity $\\\\alpha$', ylabel='Strategy mass in stationary distribution $\\\\pi$', legend_sort_clusters=False):\n    if False:\n        i = 10\n    'Plots stationary distributions, pi, against selection intensities, alpha.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi.\\n    alpha_list: List of selection intensities, alpha.\\n    num_populations: The number of populations.\\n    num_strats_per_population: List of the number of strategies per population.\\n    strat_labels: Human-readable strategy labels.\\n    num_strats_to_label: The number of top strategies to label in the legend.\\n    plot_semilogx: Boolean set to enable/disable semilogx plot.\\n    xlabel: Plot xlabel.\\n    ylabel: Plot ylabel.\\n    legend_sort_clusters: If true, strategies in the same cluster are sorted in\\n      the legend according to orderings for earlier alpha values. Primarily for\\n      visualization purposes! Rankings for lower alpha values should be\\n      interpreted carefully.\\n  '\n    masses_to_strats = utils.cluster_strats(pi_list[-1, :])\n    num_strat_profiles = np.shape(pi_list)[1]\n    num_strats_to_label = min(num_strats_to_label, num_strat_profiles)\n    cmap = plt.get_cmap('Paired')\n    colors = [cmap(i) for i in np.linspace(0, 1, num_strat_profiles)]\n    plt.figure(facecolor='w')\n    axes = plt.gca()\n    legend_line_objects = []\n    legend_labels = []\n    rank = 1\n    num_strats_printed = 0\n    add_legend_entries = True\n    if legend_sort_clusters:\n        sorted_masses_strats = generate_sorted_masses_strats(pi_list, pi_list.shape[0] - 1, range(pi_list.shape[1]))\n    else:\n        sorted_masses_strats = sorted(masses_to_strats.items(), reverse=True)\n    for (mass, strats) in sorted_masses_strats:\n        for profile_id in strats:\n            if num_populations == 1:\n                strat_profile = profile_id\n            else:\n                strat_profile = utils.get_strat_profile_from_id(num_strats_per_population, profile_id)\n            if plot_semilogx:\n                series = plt.semilogx(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            else:\n                series = plt.plot(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            if add_legend_entries:\n                if num_strats_printed >= num_strats_to_label:\n                    series = plt.semilogx(np.NaN, np.NaN, '-', color='none')\n                    label = '...'\n                    add_legend_entries = False\n                else:\n                    label = utils.get_label_from_strat_profile(num_populations, strat_profile, strat_labels)\n                legend_labels.append(label)\n                legend_line_objects.append(series[0])\n            num_strats_printed += 1\n        rank += 1\n    for (mass, strats) in iter(masses_to_strats.items()):\n        _draw_pie(axes, ratios=[1 / len(strats)] * len(strats), colors=[colors[i] for i in strats], x_center=alpha_list[-1], y_center=mass, size=200, clip_on=False, zorder=10)\n    max_mass = np.amax(pi_list)\n    axes_y_max = np.ceil(10.0 * max_mass) / 10\n    axes_y_max = np.clip(axes_y_max, 0.0, 1.0)\n    box_x_min = alpha_list[-1] * 0.7\n    box_y_min = np.min(pi_list[-1, :]) - 0.05 * axes_y_max\n    width = 0.7 * alpha_list[-1]\n    height = np.max(pi_list[-1, :]) - np.min(pi_list[-1, :]) + 0.05 * axes_y_max * 2\n    axes.add_patch(patches.Rectangle((box_x_min, box_y_min), width, height, edgecolor='b', facecolor=(1, 0, 0, 0), clip_on=False, linewidth=5, zorder=20))\n    axes.set_xlim(np.min(alpha_list), np.max(alpha_list))\n    axes.set_ylim([0.0, axes_y_max])\n    axes.set_xlabel(xlabel)\n    axes.set_ylabel(ylabel)\n    axes.set_axisbelow(True)\n    box = axes.get_position()\n    axes.set_position([box.x0, box.y0, box.width * 0.8, box.height])\n    axes.legend(legend_line_objects, legend_labels, loc='center left', bbox_to_anchor=(1.05, 0.5))\n    plt.grid()\n    plt.show()",
            "def plot_pi_vs_alpha(pi_list, alpha_list, num_populations, num_strats_per_population, strat_labels, num_strats_to_label, plot_semilogx=True, xlabel='Ranking-intensity $\\\\alpha$', ylabel='Strategy mass in stationary distribution $\\\\pi$', legend_sort_clusters=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Plots stationary distributions, pi, against selection intensities, alpha.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi.\\n    alpha_list: List of selection intensities, alpha.\\n    num_populations: The number of populations.\\n    num_strats_per_population: List of the number of strategies per population.\\n    strat_labels: Human-readable strategy labels.\\n    num_strats_to_label: The number of top strategies to label in the legend.\\n    plot_semilogx: Boolean set to enable/disable semilogx plot.\\n    xlabel: Plot xlabel.\\n    ylabel: Plot ylabel.\\n    legend_sort_clusters: If true, strategies in the same cluster are sorted in\\n      the legend according to orderings for earlier alpha values. Primarily for\\n      visualization purposes! Rankings for lower alpha values should be\\n      interpreted carefully.\\n  '\n    masses_to_strats = utils.cluster_strats(pi_list[-1, :])\n    num_strat_profiles = np.shape(pi_list)[1]\n    num_strats_to_label = min(num_strats_to_label, num_strat_profiles)\n    cmap = plt.get_cmap('Paired')\n    colors = [cmap(i) for i in np.linspace(0, 1, num_strat_profiles)]\n    plt.figure(facecolor='w')\n    axes = plt.gca()\n    legend_line_objects = []\n    legend_labels = []\n    rank = 1\n    num_strats_printed = 0\n    add_legend_entries = True\n    if legend_sort_clusters:\n        sorted_masses_strats = generate_sorted_masses_strats(pi_list, pi_list.shape[0] - 1, range(pi_list.shape[1]))\n    else:\n        sorted_masses_strats = sorted(masses_to_strats.items(), reverse=True)\n    for (mass, strats) in sorted_masses_strats:\n        for profile_id in strats:\n            if num_populations == 1:\n                strat_profile = profile_id\n            else:\n                strat_profile = utils.get_strat_profile_from_id(num_strats_per_population, profile_id)\n            if plot_semilogx:\n                series = plt.semilogx(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            else:\n                series = plt.plot(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            if add_legend_entries:\n                if num_strats_printed >= num_strats_to_label:\n                    series = plt.semilogx(np.NaN, np.NaN, '-', color='none')\n                    label = '...'\n                    add_legend_entries = False\n                else:\n                    label = utils.get_label_from_strat_profile(num_populations, strat_profile, strat_labels)\n                legend_labels.append(label)\n                legend_line_objects.append(series[0])\n            num_strats_printed += 1\n        rank += 1\n    for (mass, strats) in iter(masses_to_strats.items()):\n        _draw_pie(axes, ratios=[1 / len(strats)] * len(strats), colors=[colors[i] for i in strats], x_center=alpha_list[-1], y_center=mass, size=200, clip_on=False, zorder=10)\n    max_mass = np.amax(pi_list)\n    axes_y_max = np.ceil(10.0 * max_mass) / 10\n    axes_y_max = np.clip(axes_y_max, 0.0, 1.0)\n    box_x_min = alpha_list[-1] * 0.7\n    box_y_min = np.min(pi_list[-1, :]) - 0.05 * axes_y_max\n    width = 0.7 * alpha_list[-1]\n    height = np.max(pi_list[-1, :]) - np.min(pi_list[-1, :]) + 0.05 * axes_y_max * 2\n    axes.add_patch(patches.Rectangle((box_x_min, box_y_min), width, height, edgecolor='b', facecolor=(1, 0, 0, 0), clip_on=False, linewidth=5, zorder=20))\n    axes.set_xlim(np.min(alpha_list), np.max(alpha_list))\n    axes.set_ylim([0.0, axes_y_max])\n    axes.set_xlabel(xlabel)\n    axes.set_ylabel(ylabel)\n    axes.set_axisbelow(True)\n    box = axes.get_position()\n    axes.set_position([box.x0, box.y0, box.width * 0.8, box.height])\n    axes.legend(legend_line_objects, legend_labels, loc='center left', bbox_to_anchor=(1.05, 0.5))\n    plt.grid()\n    plt.show()",
            "def plot_pi_vs_alpha(pi_list, alpha_list, num_populations, num_strats_per_population, strat_labels, num_strats_to_label, plot_semilogx=True, xlabel='Ranking-intensity $\\\\alpha$', ylabel='Strategy mass in stationary distribution $\\\\pi$', legend_sort_clusters=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Plots stationary distributions, pi, against selection intensities, alpha.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi.\\n    alpha_list: List of selection intensities, alpha.\\n    num_populations: The number of populations.\\n    num_strats_per_population: List of the number of strategies per population.\\n    strat_labels: Human-readable strategy labels.\\n    num_strats_to_label: The number of top strategies to label in the legend.\\n    plot_semilogx: Boolean set to enable/disable semilogx plot.\\n    xlabel: Plot xlabel.\\n    ylabel: Plot ylabel.\\n    legend_sort_clusters: If true, strategies in the same cluster are sorted in\\n      the legend according to orderings for earlier alpha values. Primarily for\\n      visualization purposes! Rankings for lower alpha values should be\\n      interpreted carefully.\\n  '\n    masses_to_strats = utils.cluster_strats(pi_list[-1, :])\n    num_strat_profiles = np.shape(pi_list)[1]\n    num_strats_to_label = min(num_strats_to_label, num_strat_profiles)\n    cmap = plt.get_cmap('Paired')\n    colors = [cmap(i) for i in np.linspace(0, 1, num_strat_profiles)]\n    plt.figure(facecolor='w')\n    axes = plt.gca()\n    legend_line_objects = []\n    legend_labels = []\n    rank = 1\n    num_strats_printed = 0\n    add_legend_entries = True\n    if legend_sort_clusters:\n        sorted_masses_strats = generate_sorted_masses_strats(pi_list, pi_list.shape[0] - 1, range(pi_list.shape[1]))\n    else:\n        sorted_masses_strats = sorted(masses_to_strats.items(), reverse=True)\n    for (mass, strats) in sorted_masses_strats:\n        for profile_id in strats:\n            if num_populations == 1:\n                strat_profile = profile_id\n            else:\n                strat_profile = utils.get_strat_profile_from_id(num_strats_per_population, profile_id)\n            if plot_semilogx:\n                series = plt.semilogx(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            else:\n                series = plt.plot(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            if add_legend_entries:\n                if num_strats_printed >= num_strats_to_label:\n                    series = plt.semilogx(np.NaN, np.NaN, '-', color='none')\n                    label = '...'\n                    add_legend_entries = False\n                else:\n                    label = utils.get_label_from_strat_profile(num_populations, strat_profile, strat_labels)\n                legend_labels.append(label)\n                legend_line_objects.append(series[0])\n            num_strats_printed += 1\n        rank += 1\n    for (mass, strats) in iter(masses_to_strats.items()):\n        _draw_pie(axes, ratios=[1 / len(strats)] * len(strats), colors=[colors[i] for i in strats], x_center=alpha_list[-1], y_center=mass, size=200, clip_on=False, zorder=10)\n    max_mass = np.amax(pi_list)\n    axes_y_max = np.ceil(10.0 * max_mass) / 10\n    axes_y_max = np.clip(axes_y_max, 0.0, 1.0)\n    box_x_min = alpha_list[-1] * 0.7\n    box_y_min = np.min(pi_list[-1, :]) - 0.05 * axes_y_max\n    width = 0.7 * alpha_list[-1]\n    height = np.max(pi_list[-1, :]) - np.min(pi_list[-1, :]) + 0.05 * axes_y_max * 2\n    axes.add_patch(patches.Rectangle((box_x_min, box_y_min), width, height, edgecolor='b', facecolor=(1, 0, 0, 0), clip_on=False, linewidth=5, zorder=20))\n    axes.set_xlim(np.min(alpha_list), np.max(alpha_list))\n    axes.set_ylim([0.0, axes_y_max])\n    axes.set_xlabel(xlabel)\n    axes.set_ylabel(ylabel)\n    axes.set_axisbelow(True)\n    box = axes.get_position()\n    axes.set_position([box.x0, box.y0, box.width * 0.8, box.height])\n    axes.legend(legend_line_objects, legend_labels, loc='center left', bbox_to_anchor=(1.05, 0.5))\n    plt.grid()\n    plt.show()",
            "def plot_pi_vs_alpha(pi_list, alpha_list, num_populations, num_strats_per_population, strat_labels, num_strats_to_label, plot_semilogx=True, xlabel='Ranking-intensity $\\\\alpha$', ylabel='Strategy mass in stationary distribution $\\\\pi$', legend_sort_clusters=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Plots stationary distributions, pi, against selection intensities, alpha.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi.\\n    alpha_list: List of selection intensities, alpha.\\n    num_populations: The number of populations.\\n    num_strats_per_population: List of the number of strategies per population.\\n    strat_labels: Human-readable strategy labels.\\n    num_strats_to_label: The number of top strategies to label in the legend.\\n    plot_semilogx: Boolean set to enable/disable semilogx plot.\\n    xlabel: Plot xlabel.\\n    ylabel: Plot ylabel.\\n    legend_sort_clusters: If true, strategies in the same cluster are sorted in\\n      the legend according to orderings for earlier alpha values. Primarily for\\n      visualization purposes! Rankings for lower alpha values should be\\n      interpreted carefully.\\n  '\n    masses_to_strats = utils.cluster_strats(pi_list[-1, :])\n    num_strat_profiles = np.shape(pi_list)[1]\n    num_strats_to_label = min(num_strats_to_label, num_strat_profiles)\n    cmap = plt.get_cmap('Paired')\n    colors = [cmap(i) for i in np.linspace(0, 1, num_strat_profiles)]\n    plt.figure(facecolor='w')\n    axes = plt.gca()\n    legend_line_objects = []\n    legend_labels = []\n    rank = 1\n    num_strats_printed = 0\n    add_legend_entries = True\n    if legend_sort_clusters:\n        sorted_masses_strats = generate_sorted_masses_strats(pi_list, pi_list.shape[0] - 1, range(pi_list.shape[1]))\n    else:\n        sorted_masses_strats = sorted(masses_to_strats.items(), reverse=True)\n    for (mass, strats) in sorted_masses_strats:\n        for profile_id in strats:\n            if num_populations == 1:\n                strat_profile = profile_id\n            else:\n                strat_profile = utils.get_strat_profile_from_id(num_strats_per_population, profile_id)\n            if plot_semilogx:\n                series = plt.semilogx(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            else:\n                series = plt.plot(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            if add_legend_entries:\n                if num_strats_printed >= num_strats_to_label:\n                    series = plt.semilogx(np.NaN, np.NaN, '-', color='none')\n                    label = '...'\n                    add_legend_entries = False\n                else:\n                    label = utils.get_label_from_strat_profile(num_populations, strat_profile, strat_labels)\n                legend_labels.append(label)\n                legend_line_objects.append(series[0])\n            num_strats_printed += 1\n        rank += 1\n    for (mass, strats) in iter(masses_to_strats.items()):\n        _draw_pie(axes, ratios=[1 / len(strats)] * len(strats), colors=[colors[i] for i in strats], x_center=alpha_list[-1], y_center=mass, size=200, clip_on=False, zorder=10)\n    max_mass = np.amax(pi_list)\n    axes_y_max = np.ceil(10.0 * max_mass) / 10\n    axes_y_max = np.clip(axes_y_max, 0.0, 1.0)\n    box_x_min = alpha_list[-1] * 0.7\n    box_y_min = np.min(pi_list[-1, :]) - 0.05 * axes_y_max\n    width = 0.7 * alpha_list[-1]\n    height = np.max(pi_list[-1, :]) - np.min(pi_list[-1, :]) + 0.05 * axes_y_max * 2\n    axes.add_patch(patches.Rectangle((box_x_min, box_y_min), width, height, edgecolor='b', facecolor=(1, 0, 0, 0), clip_on=False, linewidth=5, zorder=20))\n    axes.set_xlim(np.min(alpha_list), np.max(alpha_list))\n    axes.set_ylim([0.0, axes_y_max])\n    axes.set_xlabel(xlabel)\n    axes.set_ylabel(ylabel)\n    axes.set_axisbelow(True)\n    box = axes.get_position()\n    axes.set_position([box.x0, box.y0, box.width * 0.8, box.height])\n    axes.legend(legend_line_objects, legend_labels, loc='center left', bbox_to_anchor=(1.05, 0.5))\n    plt.grid()\n    plt.show()",
            "def plot_pi_vs_alpha(pi_list, alpha_list, num_populations, num_strats_per_population, strat_labels, num_strats_to_label, plot_semilogx=True, xlabel='Ranking-intensity $\\\\alpha$', ylabel='Strategy mass in stationary distribution $\\\\pi$', legend_sort_clusters=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Plots stationary distributions, pi, against selection intensities, alpha.\\n\\n  Args:\\n    pi_list: List of stationary distributions, pi.\\n    alpha_list: List of selection intensities, alpha.\\n    num_populations: The number of populations.\\n    num_strats_per_population: List of the number of strategies per population.\\n    strat_labels: Human-readable strategy labels.\\n    num_strats_to_label: The number of top strategies to label in the legend.\\n    plot_semilogx: Boolean set to enable/disable semilogx plot.\\n    xlabel: Plot xlabel.\\n    ylabel: Plot ylabel.\\n    legend_sort_clusters: If true, strategies in the same cluster are sorted in\\n      the legend according to orderings for earlier alpha values. Primarily for\\n      visualization purposes! Rankings for lower alpha values should be\\n      interpreted carefully.\\n  '\n    masses_to_strats = utils.cluster_strats(pi_list[-1, :])\n    num_strat_profiles = np.shape(pi_list)[1]\n    num_strats_to_label = min(num_strats_to_label, num_strat_profiles)\n    cmap = plt.get_cmap('Paired')\n    colors = [cmap(i) for i in np.linspace(0, 1, num_strat_profiles)]\n    plt.figure(facecolor='w')\n    axes = plt.gca()\n    legend_line_objects = []\n    legend_labels = []\n    rank = 1\n    num_strats_printed = 0\n    add_legend_entries = True\n    if legend_sort_clusters:\n        sorted_masses_strats = generate_sorted_masses_strats(pi_list, pi_list.shape[0] - 1, range(pi_list.shape[1]))\n    else:\n        sorted_masses_strats = sorted(masses_to_strats.items(), reverse=True)\n    for (mass, strats) in sorted_masses_strats:\n        for profile_id in strats:\n            if num_populations == 1:\n                strat_profile = profile_id\n            else:\n                strat_profile = utils.get_strat_profile_from_id(num_strats_per_population, profile_id)\n            if plot_semilogx:\n                series = plt.semilogx(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            else:\n                series = plt.plot(alpha_list, pi_list[:, profile_id], color=colors[profile_id], linewidth=2)\n            if add_legend_entries:\n                if num_strats_printed >= num_strats_to_label:\n                    series = plt.semilogx(np.NaN, np.NaN, '-', color='none')\n                    label = '...'\n                    add_legend_entries = False\n                else:\n                    label = utils.get_label_from_strat_profile(num_populations, strat_profile, strat_labels)\n                legend_labels.append(label)\n                legend_line_objects.append(series[0])\n            num_strats_printed += 1\n        rank += 1\n    for (mass, strats) in iter(masses_to_strats.items()):\n        _draw_pie(axes, ratios=[1 / len(strats)] * len(strats), colors=[colors[i] for i in strats], x_center=alpha_list[-1], y_center=mass, size=200, clip_on=False, zorder=10)\n    max_mass = np.amax(pi_list)\n    axes_y_max = np.ceil(10.0 * max_mass) / 10\n    axes_y_max = np.clip(axes_y_max, 0.0, 1.0)\n    box_x_min = alpha_list[-1] * 0.7\n    box_y_min = np.min(pi_list[-1, :]) - 0.05 * axes_y_max\n    width = 0.7 * alpha_list[-1]\n    height = np.max(pi_list[-1, :]) - np.min(pi_list[-1, :]) + 0.05 * axes_y_max * 2\n    axes.add_patch(patches.Rectangle((box_x_min, box_y_min), width, height, edgecolor='b', facecolor=(1, 0, 0, 0), clip_on=False, linewidth=5, zorder=20))\n    axes.set_xlim(np.min(alpha_list), np.max(alpha_list))\n    axes.set_ylim([0.0, axes_y_max])\n    axes.set_xlabel(xlabel)\n    axes.set_ylabel(ylabel)\n    axes.set_axisbelow(True)\n    box = axes.get_position()\n    axes.set_position([box.x0, box.y0, box.width * 0.8, box.height])\n    axes.legend(legend_line_objects, legend_labels, loc='center left', bbox_to_anchor=(1.05, 0.5))\n    plt.grid()\n    plt.show()"
        ]
    }
]