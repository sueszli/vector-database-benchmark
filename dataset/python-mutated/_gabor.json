[
    {
        "func_name": "_sigma_prefactor",
        "original": "def _sigma_prefactor(bandwidth):\n    b = bandwidth\n    return 1.0 / np.pi * math.sqrt(math.log(2) / 2.0) * (2.0 ** b + 1) / (2.0 ** b - 1)",
        "mutated": [
            "def _sigma_prefactor(bandwidth):\n    if False:\n        i = 10\n    b = bandwidth\n    return 1.0 / np.pi * math.sqrt(math.log(2) / 2.0) * (2.0 ** b + 1) / (2.0 ** b - 1)",
            "def _sigma_prefactor(bandwidth):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    b = bandwidth\n    return 1.0 / np.pi * math.sqrt(math.log(2) / 2.0) * (2.0 ** b + 1) / (2.0 ** b - 1)",
            "def _sigma_prefactor(bandwidth):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    b = bandwidth\n    return 1.0 / np.pi * math.sqrt(math.log(2) / 2.0) * (2.0 ** b + 1) / (2.0 ** b - 1)",
            "def _sigma_prefactor(bandwidth):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    b = bandwidth\n    return 1.0 / np.pi * math.sqrt(math.log(2) / 2.0) * (2.0 ** b + 1) / (2.0 ** b - 1)",
            "def _sigma_prefactor(bandwidth):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    b = bandwidth\n    return 1.0 / np.pi * math.sqrt(math.log(2) / 2.0) * (2.0 ** b + 1) / (2.0 ** b - 1)"
        ]
    },
    {
        "func_name": "gabor_kernel",
        "original": "def gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, dtype=np.complex128):\n    \"\"\"Return complex 2D Gabor filter kernel.\n\n    Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.\n    Harmonic function consists of an imaginary sine function and a real\n    cosine function. Spatial frequency is inversely proportional to the\n    wavelength of the harmonic and to the standard deviation of a Gaussian\n    kernel. The bandwidth is also inversely proportional to the standard\n    deviation.\n\n    Parameters\n    ----------\n    frequency : float\n        Spatial frequency of the harmonic function. Specified in pixels.\n    theta : float, optional\n        Orientation in radians. If 0, the harmonic is in the x-direction.\n    bandwidth : float, optional\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\n        and ``sigma_y`` will decrease with increasing frequency. This value is\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\n    sigma_x, sigma_y : float, optional\n        Standard deviation in x- and y-directions. These directions apply to\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\n        direction.\n    n_stds : scalar, optional\n        The linear size of the kernel is n_stds (3 by default) standard\n        deviations\n    offset : float, optional\n        Phase offset of harmonic function in radians.\n    dtype : {np.complex64, np.complex128}\n        Specifies if the filter is single or double precision complex.\n\n    Returns\n    -------\n    g : complex array\n        Complex filter kernel.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\n\n    Examples\n    --------\n    >>> from skimage.filters import gabor_kernel\n    >>> from skimage import io\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\n\n    >>> gk = gabor_kernel(frequency=0.2)\n    >>> plt.figure()        # doctest: +SKIP\n    >>> io.imshow(gk.real)  # doctest: +SKIP\n    >>> io.show()           # doctest: +SKIP\n\n    >>> # more ripples (equivalent to increasing the size of the\n    >>> # Gaussian spread)\n    >>> gk = gabor_kernel(frequency=0.2, bandwidth=0.1)\n    >>> plt.figure()        # doctest: +SKIP\n    >>> io.imshow(gk.real)  # doctest: +SKIP\n    >>> io.show()           # doctest: +SKIP\n    \"\"\"\n    if sigma_x is None:\n        sigma_x = _sigma_prefactor(bandwidth) / frequency\n    if sigma_y is None:\n        sigma_y = _sigma_prefactor(bandwidth) / frequency\n    if np.dtype(dtype).kind != 'c':\n        raise ValueError('dtype must be complex')\n    ct = math.cos(theta)\n    st = math.sin(theta)\n    x0 = math.ceil(max(abs(n_stds * sigma_x * ct), abs(n_stds * sigma_y * st), 1))\n    y0 = math.ceil(max(abs(n_stds * sigma_y * ct), abs(n_stds * sigma_x * st), 1))\n    (y, x) = np.meshgrid(np.arange(-y0, y0 + 1), np.arange(-x0, x0 + 1), indexing='ij', sparse=True)\n    rotx = x * ct + y * st\n    roty = -x * st + y * ct\n    g = np.empty(roty.shape, dtype=dtype)\n    np.exp(-0.5 * (rotx ** 2 / sigma_x ** 2 + roty ** 2 / sigma_y ** 2) + 1j * (2 * np.pi * frequency * rotx + offset), out=g)\n    g *= 1 / (2 * np.pi * sigma_x * sigma_y)\n    return g",
        "mutated": [
            "def gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, dtype=np.complex128):\n    if False:\n        i = 10\n    'Return complex 2D Gabor filter kernel.\\n\\n    Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.\\n    Harmonic function consists of an imaginary sine function and a real\\n    cosine function. Spatial frequency is inversely proportional to the\\n    wavelength of the harmonic and to the standard deviation of a Gaussian\\n    kernel. The bandwidth is also inversely proportional to the standard\\n    deviation.\\n\\n    Parameters\\n    ----------\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    dtype : {np.complex64, np.complex128}\\n        Specifies if the filter is single or double precision complex.\\n\\n    Returns\\n    -------\\n    g : complex array\\n        Complex filter kernel.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor_kernel\\n    >>> from skimage import io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> gk = gabor_kernel(frequency=0.2)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n\\n    >>> # more ripples (equivalent to increasing the size of the\\n    >>> # Gaussian spread)\\n    >>> gk = gabor_kernel(frequency=0.2, bandwidth=0.1)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n    '\n    if sigma_x is None:\n        sigma_x = _sigma_prefactor(bandwidth) / frequency\n    if sigma_y is None:\n        sigma_y = _sigma_prefactor(bandwidth) / frequency\n    if np.dtype(dtype).kind != 'c':\n        raise ValueError('dtype must be complex')\n    ct = math.cos(theta)\n    st = math.sin(theta)\n    x0 = math.ceil(max(abs(n_stds * sigma_x * ct), abs(n_stds * sigma_y * st), 1))\n    y0 = math.ceil(max(abs(n_stds * sigma_y * ct), abs(n_stds * sigma_x * st), 1))\n    (y, x) = np.meshgrid(np.arange(-y0, y0 + 1), np.arange(-x0, x0 + 1), indexing='ij', sparse=True)\n    rotx = x * ct + y * st\n    roty = -x * st + y * ct\n    g = np.empty(roty.shape, dtype=dtype)\n    np.exp(-0.5 * (rotx ** 2 / sigma_x ** 2 + roty ** 2 / sigma_y ** 2) + 1j * (2 * np.pi * frequency * rotx + offset), out=g)\n    g *= 1 / (2 * np.pi * sigma_x * sigma_y)\n    return g",
            "def gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, dtype=np.complex128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return complex 2D Gabor filter kernel.\\n\\n    Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.\\n    Harmonic function consists of an imaginary sine function and a real\\n    cosine function. Spatial frequency is inversely proportional to the\\n    wavelength of the harmonic and to the standard deviation of a Gaussian\\n    kernel. The bandwidth is also inversely proportional to the standard\\n    deviation.\\n\\n    Parameters\\n    ----------\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    dtype : {np.complex64, np.complex128}\\n        Specifies if the filter is single or double precision complex.\\n\\n    Returns\\n    -------\\n    g : complex array\\n        Complex filter kernel.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor_kernel\\n    >>> from skimage import io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> gk = gabor_kernel(frequency=0.2)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n\\n    >>> # more ripples (equivalent to increasing the size of the\\n    >>> # Gaussian spread)\\n    >>> gk = gabor_kernel(frequency=0.2, bandwidth=0.1)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n    '\n    if sigma_x is None:\n        sigma_x = _sigma_prefactor(bandwidth) / frequency\n    if sigma_y is None:\n        sigma_y = _sigma_prefactor(bandwidth) / frequency\n    if np.dtype(dtype).kind != 'c':\n        raise ValueError('dtype must be complex')\n    ct = math.cos(theta)\n    st = math.sin(theta)\n    x0 = math.ceil(max(abs(n_stds * sigma_x * ct), abs(n_stds * sigma_y * st), 1))\n    y0 = math.ceil(max(abs(n_stds * sigma_y * ct), abs(n_stds * sigma_x * st), 1))\n    (y, x) = np.meshgrid(np.arange(-y0, y0 + 1), np.arange(-x0, x0 + 1), indexing='ij', sparse=True)\n    rotx = x * ct + y * st\n    roty = -x * st + y * ct\n    g = np.empty(roty.shape, dtype=dtype)\n    np.exp(-0.5 * (rotx ** 2 / sigma_x ** 2 + roty ** 2 / sigma_y ** 2) + 1j * (2 * np.pi * frequency * rotx + offset), out=g)\n    g *= 1 / (2 * np.pi * sigma_x * sigma_y)\n    return g",
            "def gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, dtype=np.complex128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return complex 2D Gabor filter kernel.\\n\\n    Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.\\n    Harmonic function consists of an imaginary sine function and a real\\n    cosine function. Spatial frequency is inversely proportional to the\\n    wavelength of the harmonic and to the standard deviation of a Gaussian\\n    kernel. The bandwidth is also inversely proportional to the standard\\n    deviation.\\n\\n    Parameters\\n    ----------\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    dtype : {np.complex64, np.complex128}\\n        Specifies if the filter is single or double precision complex.\\n\\n    Returns\\n    -------\\n    g : complex array\\n        Complex filter kernel.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor_kernel\\n    >>> from skimage import io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> gk = gabor_kernel(frequency=0.2)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n\\n    >>> # more ripples (equivalent to increasing the size of the\\n    >>> # Gaussian spread)\\n    >>> gk = gabor_kernel(frequency=0.2, bandwidth=0.1)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n    '\n    if sigma_x is None:\n        sigma_x = _sigma_prefactor(bandwidth) / frequency\n    if sigma_y is None:\n        sigma_y = _sigma_prefactor(bandwidth) / frequency\n    if np.dtype(dtype).kind != 'c':\n        raise ValueError('dtype must be complex')\n    ct = math.cos(theta)\n    st = math.sin(theta)\n    x0 = math.ceil(max(abs(n_stds * sigma_x * ct), abs(n_stds * sigma_y * st), 1))\n    y0 = math.ceil(max(abs(n_stds * sigma_y * ct), abs(n_stds * sigma_x * st), 1))\n    (y, x) = np.meshgrid(np.arange(-y0, y0 + 1), np.arange(-x0, x0 + 1), indexing='ij', sparse=True)\n    rotx = x * ct + y * st\n    roty = -x * st + y * ct\n    g = np.empty(roty.shape, dtype=dtype)\n    np.exp(-0.5 * (rotx ** 2 / sigma_x ** 2 + roty ** 2 / sigma_y ** 2) + 1j * (2 * np.pi * frequency * rotx + offset), out=g)\n    g *= 1 / (2 * np.pi * sigma_x * sigma_y)\n    return g",
            "def gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, dtype=np.complex128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return complex 2D Gabor filter kernel.\\n\\n    Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.\\n    Harmonic function consists of an imaginary sine function and a real\\n    cosine function. Spatial frequency is inversely proportional to the\\n    wavelength of the harmonic and to the standard deviation of a Gaussian\\n    kernel. The bandwidth is also inversely proportional to the standard\\n    deviation.\\n\\n    Parameters\\n    ----------\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    dtype : {np.complex64, np.complex128}\\n        Specifies if the filter is single or double precision complex.\\n\\n    Returns\\n    -------\\n    g : complex array\\n        Complex filter kernel.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor_kernel\\n    >>> from skimage import io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> gk = gabor_kernel(frequency=0.2)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n\\n    >>> # more ripples (equivalent to increasing the size of the\\n    >>> # Gaussian spread)\\n    >>> gk = gabor_kernel(frequency=0.2, bandwidth=0.1)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n    '\n    if sigma_x is None:\n        sigma_x = _sigma_prefactor(bandwidth) / frequency\n    if sigma_y is None:\n        sigma_y = _sigma_prefactor(bandwidth) / frequency\n    if np.dtype(dtype).kind != 'c':\n        raise ValueError('dtype must be complex')\n    ct = math.cos(theta)\n    st = math.sin(theta)\n    x0 = math.ceil(max(abs(n_stds * sigma_x * ct), abs(n_stds * sigma_y * st), 1))\n    y0 = math.ceil(max(abs(n_stds * sigma_y * ct), abs(n_stds * sigma_x * st), 1))\n    (y, x) = np.meshgrid(np.arange(-y0, y0 + 1), np.arange(-x0, x0 + 1), indexing='ij', sparse=True)\n    rotx = x * ct + y * st\n    roty = -x * st + y * ct\n    g = np.empty(roty.shape, dtype=dtype)\n    np.exp(-0.5 * (rotx ** 2 / sigma_x ** 2 + roty ** 2 / sigma_y ** 2) + 1j * (2 * np.pi * frequency * rotx + offset), out=g)\n    g *= 1 / (2 * np.pi * sigma_x * sigma_y)\n    return g",
            "def gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, dtype=np.complex128):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return complex 2D Gabor filter kernel.\\n\\n    Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.\\n    Harmonic function consists of an imaginary sine function and a real\\n    cosine function. Spatial frequency is inversely proportional to the\\n    wavelength of the harmonic and to the standard deviation of a Gaussian\\n    kernel. The bandwidth is also inversely proportional to the standard\\n    deviation.\\n\\n    Parameters\\n    ----------\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    dtype : {np.complex64, np.complex128}\\n        Specifies if the filter is single or double precision complex.\\n\\n    Returns\\n    -------\\n    g : complex array\\n        Complex filter kernel.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor_kernel\\n    >>> from skimage import io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> gk = gabor_kernel(frequency=0.2)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n\\n    >>> # more ripples (equivalent to increasing the size of the\\n    >>> # Gaussian spread)\\n    >>> gk = gabor_kernel(frequency=0.2, bandwidth=0.1)\\n    >>> plt.figure()        # doctest: +SKIP\\n    >>> io.imshow(gk.real)  # doctest: +SKIP\\n    >>> io.show()           # doctest: +SKIP\\n    '\n    if sigma_x is None:\n        sigma_x = _sigma_prefactor(bandwidth) / frequency\n    if sigma_y is None:\n        sigma_y = _sigma_prefactor(bandwidth) / frequency\n    if np.dtype(dtype).kind != 'c':\n        raise ValueError('dtype must be complex')\n    ct = math.cos(theta)\n    st = math.sin(theta)\n    x0 = math.ceil(max(abs(n_stds * sigma_x * ct), abs(n_stds * sigma_y * st), 1))\n    y0 = math.ceil(max(abs(n_stds * sigma_y * ct), abs(n_stds * sigma_x * st), 1))\n    (y, x) = np.meshgrid(np.arange(-y0, y0 + 1), np.arange(-x0, x0 + 1), indexing='ij', sparse=True)\n    rotx = x * ct + y * st\n    roty = -x * st + y * ct\n    g = np.empty(roty.shape, dtype=dtype)\n    np.exp(-0.5 * (rotx ** 2 / sigma_x ** 2 + roty ** 2 / sigma_y ** 2) + 1j * (2 * np.pi * frequency * rotx + offset), out=g)\n    g *= 1 / (2 * np.pi * sigma_x * sigma_y)\n    return g"
        ]
    },
    {
        "func_name": "gabor",
        "original": "def gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0):\n    \"\"\"Return real and imaginary responses to Gabor filter.\n\n    The real and imaginary parts of the Gabor filter kernel are applied to the\n    image and the response is returned as a pair of arrays.\n\n    Gabor filter is a linear filter with a Gaussian kernel which is modulated\n    by a sinusoidal plane wave. Frequency and orientation representations of\n    the Gabor filter are similar to those of the human visual system.\n    Gabor filter banks are commonly used in computer vision and image\n    processing. They are especially suitable for edge detection and texture\n    classification.\n\n    Parameters\n    ----------\n    image : 2-D array\n        Input image.\n    frequency : float\n        Spatial frequency of the harmonic function. Specified in pixels.\n    theta : float, optional\n        Orientation in radians. If 0, the harmonic is in the x-direction.\n    bandwidth : float, optional\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\n        and ``sigma_y`` will decrease with increasing frequency. This value is\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\n    sigma_x, sigma_y : float, optional\n        Standard deviation in x- and y-directions. These directions apply to\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\n        direction.\n    n_stds : scalar, optional\n        The linear size of the kernel is n_stds (3 by default) standard\n        deviations.\n    offset : float, optional\n        Phase offset of harmonic function in radians.\n    mode : {'constant', 'nearest', 'reflect', 'mirror', 'wrap'}, optional\n        Mode used to convolve image with a kernel, passed to `ndi.convolve`\n    cval : scalar, optional\n        Value to fill past edges of input if ``mode`` of convolution is\n        'constant'. The parameter is passed to `ndi.convolve`.\n\n    Returns\n    -------\n    real, imag : arrays\n        Filtered images using the real and imaginary parts of the Gabor filter\n        kernel. Images are of the same dimensions as the input one.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\n\n    Examples\n    --------\n    >>> from skimage.filters import gabor\n    >>> from skimage import data, io\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\n\n    >>> image = data.coins()\n    >>> # detecting edges in a coin image\n    >>> filt_real, filt_imag = gabor(image, frequency=0.6)\n    >>> plt.figure()            # doctest: +SKIP\n    >>> io.imshow(filt_real)    # doctest: +SKIP\n    >>> io.show()               # doctest: +SKIP\n\n    >>> # less sensitivity to finer details with the lower frequency kernel\n    >>> filt_real, filt_imag = gabor(image, frequency=0.1)\n    >>> plt.figure()            # doctest: +SKIP\n    >>> io.imshow(filt_real)    # doctest: +SKIP\n    >>> io.show()               # doctest: +SKIP\n    \"\"\"\n    check_nD(image, 2)\n    if image.dtype.kind == 'f':\n        float_dtype = _supported_float_type(image.dtype)\n        image = image.astype(float_dtype, copy=False)\n        kernel_dtype = np.promote_types(image.dtype, np.complex64)\n    else:\n        kernel_dtype = np.complex128\n    g = gabor_kernel(frequency, theta, bandwidth, sigma_x, sigma_y, n_stds, offset, dtype=kernel_dtype)\n    filtered_real = ndi.convolve(image, np.real(g), mode=mode, cval=cval)\n    filtered_imag = ndi.convolve(image, np.imag(g), mode=mode, cval=cval)\n    return (filtered_real, filtered_imag)",
        "mutated": [
            "def gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0):\n    if False:\n        i = 10\n    \"Return real and imaginary responses to Gabor filter.\\n\\n    The real and imaginary parts of the Gabor filter kernel are applied to the\\n    image and the response is returned as a pair of arrays.\\n\\n    Gabor filter is a linear filter with a Gaussian kernel which is modulated\\n    by a sinusoidal plane wave. Frequency and orientation representations of\\n    the Gabor filter are similar to those of the human visual system.\\n    Gabor filter banks are commonly used in computer vision and image\\n    processing. They are especially suitable for edge detection and texture\\n    classification.\\n\\n    Parameters\\n    ----------\\n    image : 2-D array\\n        Input image.\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations.\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    mode : {'constant', 'nearest', 'reflect', 'mirror', 'wrap'}, optional\\n        Mode used to convolve image with a kernel, passed to `ndi.convolve`\\n    cval : scalar, optional\\n        Value to fill past edges of input if ``mode`` of convolution is\\n        'constant'. The parameter is passed to `ndi.convolve`.\\n\\n    Returns\\n    -------\\n    real, imag : arrays\\n        Filtered images using the real and imaginary parts of the Gabor filter\\n        kernel. Images are of the same dimensions as the input one.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor\\n    >>> from skimage import data, io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> image = data.coins()\\n    >>> # detecting edges in a coin image\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.6)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n\\n    >>> # less sensitivity to finer details with the lower frequency kernel\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.1)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n    \"\n    check_nD(image, 2)\n    if image.dtype.kind == 'f':\n        float_dtype = _supported_float_type(image.dtype)\n        image = image.astype(float_dtype, copy=False)\n        kernel_dtype = np.promote_types(image.dtype, np.complex64)\n    else:\n        kernel_dtype = np.complex128\n    g = gabor_kernel(frequency, theta, bandwidth, sigma_x, sigma_y, n_stds, offset, dtype=kernel_dtype)\n    filtered_real = ndi.convolve(image, np.real(g), mode=mode, cval=cval)\n    filtered_imag = ndi.convolve(image, np.imag(g), mode=mode, cval=cval)\n    return (filtered_real, filtered_imag)",
            "def gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Return real and imaginary responses to Gabor filter.\\n\\n    The real and imaginary parts of the Gabor filter kernel are applied to the\\n    image and the response is returned as a pair of arrays.\\n\\n    Gabor filter is a linear filter with a Gaussian kernel which is modulated\\n    by a sinusoidal plane wave. Frequency and orientation representations of\\n    the Gabor filter are similar to those of the human visual system.\\n    Gabor filter banks are commonly used in computer vision and image\\n    processing. They are especially suitable for edge detection and texture\\n    classification.\\n\\n    Parameters\\n    ----------\\n    image : 2-D array\\n        Input image.\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations.\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    mode : {'constant', 'nearest', 'reflect', 'mirror', 'wrap'}, optional\\n        Mode used to convolve image with a kernel, passed to `ndi.convolve`\\n    cval : scalar, optional\\n        Value to fill past edges of input if ``mode`` of convolution is\\n        'constant'. The parameter is passed to `ndi.convolve`.\\n\\n    Returns\\n    -------\\n    real, imag : arrays\\n        Filtered images using the real and imaginary parts of the Gabor filter\\n        kernel. Images are of the same dimensions as the input one.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor\\n    >>> from skimage import data, io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> image = data.coins()\\n    >>> # detecting edges in a coin image\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.6)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n\\n    >>> # less sensitivity to finer details with the lower frequency kernel\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.1)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n    \"\n    check_nD(image, 2)\n    if image.dtype.kind == 'f':\n        float_dtype = _supported_float_type(image.dtype)\n        image = image.astype(float_dtype, copy=False)\n        kernel_dtype = np.promote_types(image.dtype, np.complex64)\n    else:\n        kernel_dtype = np.complex128\n    g = gabor_kernel(frequency, theta, bandwidth, sigma_x, sigma_y, n_stds, offset, dtype=kernel_dtype)\n    filtered_real = ndi.convolve(image, np.real(g), mode=mode, cval=cval)\n    filtered_imag = ndi.convolve(image, np.imag(g), mode=mode, cval=cval)\n    return (filtered_real, filtered_imag)",
            "def gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Return real and imaginary responses to Gabor filter.\\n\\n    The real and imaginary parts of the Gabor filter kernel are applied to the\\n    image and the response is returned as a pair of arrays.\\n\\n    Gabor filter is a linear filter with a Gaussian kernel which is modulated\\n    by a sinusoidal plane wave. Frequency and orientation representations of\\n    the Gabor filter are similar to those of the human visual system.\\n    Gabor filter banks are commonly used in computer vision and image\\n    processing. They are especially suitable for edge detection and texture\\n    classification.\\n\\n    Parameters\\n    ----------\\n    image : 2-D array\\n        Input image.\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations.\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    mode : {'constant', 'nearest', 'reflect', 'mirror', 'wrap'}, optional\\n        Mode used to convolve image with a kernel, passed to `ndi.convolve`\\n    cval : scalar, optional\\n        Value to fill past edges of input if ``mode`` of convolution is\\n        'constant'. The parameter is passed to `ndi.convolve`.\\n\\n    Returns\\n    -------\\n    real, imag : arrays\\n        Filtered images using the real and imaginary parts of the Gabor filter\\n        kernel. Images are of the same dimensions as the input one.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor\\n    >>> from skimage import data, io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> image = data.coins()\\n    >>> # detecting edges in a coin image\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.6)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n\\n    >>> # less sensitivity to finer details with the lower frequency kernel\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.1)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n    \"\n    check_nD(image, 2)\n    if image.dtype.kind == 'f':\n        float_dtype = _supported_float_type(image.dtype)\n        image = image.astype(float_dtype, copy=False)\n        kernel_dtype = np.promote_types(image.dtype, np.complex64)\n    else:\n        kernel_dtype = np.complex128\n    g = gabor_kernel(frequency, theta, bandwidth, sigma_x, sigma_y, n_stds, offset, dtype=kernel_dtype)\n    filtered_real = ndi.convolve(image, np.real(g), mode=mode, cval=cval)\n    filtered_imag = ndi.convolve(image, np.imag(g), mode=mode, cval=cval)\n    return (filtered_real, filtered_imag)",
            "def gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Return real and imaginary responses to Gabor filter.\\n\\n    The real and imaginary parts of the Gabor filter kernel are applied to the\\n    image and the response is returned as a pair of arrays.\\n\\n    Gabor filter is a linear filter with a Gaussian kernel which is modulated\\n    by a sinusoidal plane wave. Frequency and orientation representations of\\n    the Gabor filter are similar to those of the human visual system.\\n    Gabor filter banks are commonly used in computer vision and image\\n    processing. They are especially suitable for edge detection and texture\\n    classification.\\n\\n    Parameters\\n    ----------\\n    image : 2-D array\\n        Input image.\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations.\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    mode : {'constant', 'nearest', 'reflect', 'mirror', 'wrap'}, optional\\n        Mode used to convolve image with a kernel, passed to `ndi.convolve`\\n    cval : scalar, optional\\n        Value to fill past edges of input if ``mode`` of convolution is\\n        'constant'. The parameter is passed to `ndi.convolve`.\\n\\n    Returns\\n    -------\\n    real, imag : arrays\\n        Filtered images using the real and imaginary parts of the Gabor filter\\n        kernel. Images are of the same dimensions as the input one.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor\\n    >>> from skimage import data, io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> image = data.coins()\\n    >>> # detecting edges in a coin image\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.6)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n\\n    >>> # less sensitivity to finer details with the lower frequency kernel\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.1)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n    \"\n    check_nD(image, 2)\n    if image.dtype.kind == 'f':\n        float_dtype = _supported_float_type(image.dtype)\n        image = image.astype(float_dtype, copy=False)\n        kernel_dtype = np.promote_types(image.dtype, np.complex64)\n    else:\n        kernel_dtype = np.complex128\n    g = gabor_kernel(frequency, theta, bandwidth, sigma_x, sigma_y, n_stds, offset, dtype=kernel_dtype)\n    filtered_real = ndi.convolve(image, np.real(g), mode=mode, cval=cval)\n    filtered_imag = ndi.convolve(image, np.imag(g), mode=mode, cval=cval)\n    return (filtered_real, filtered_imag)",
            "def gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Return real and imaginary responses to Gabor filter.\\n\\n    The real and imaginary parts of the Gabor filter kernel are applied to the\\n    image and the response is returned as a pair of arrays.\\n\\n    Gabor filter is a linear filter with a Gaussian kernel which is modulated\\n    by a sinusoidal plane wave. Frequency and orientation representations of\\n    the Gabor filter are similar to those of the human visual system.\\n    Gabor filter banks are commonly used in computer vision and image\\n    processing. They are especially suitable for edge detection and texture\\n    classification.\\n\\n    Parameters\\n    ----------\\n    image : 2-D array\\n        Input image.\\n    frequency : float\\n        Spatial frequency of the harmonic function. Specified in pixels.\\n    theta : float, optional\\n        Orientation in radians. If 0, the harmonic is in the x-direction.\\n    bandwidth : float, optional\\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\\n        and ``sigma_y`` will decrease with increasing frequency. This value is\\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\\n    sigma_x, sigma_y : float, optional\\n        Standard deviation in x- and y-directions. These directions apply to\\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\\n        direction.\\n    n_stds : scalar, optional\\n        The linear size of the kernel is n_stds (3 by default) standard\\n        deviations.\\n    offset : float, optional\\n        Phase offset of harmonic function in radians.\\n    mode : {'constant', 'nearest', 'reflect', 'mirror', 'wrap'}, optional\\n        Mode used to convolve image with a kernel, passed to `ndi.convolve`\\n    cval : scalar, optional\\n        Value to fill past edges of input if ``mode`` of convolution is\\n        'constant'. The parameter is passed to `ndi.convolve`.\\n\\n    Returns\\n    -------\\n    real, imag : arrays\\n        Filtered images using the real and imaginary parts of the Gabor filter\\n        kernel. Images are of the same dimensions as the input one.\\n\\n    References\\n    ----------\\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\\n\\n    Examples\\n    --------\\n    >>> from skimage.filters import gabor\\n    >>> from skimage import data, io\\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\\n\\n    >>> image = data.coins()\\n    >>> # detecting edges in a coin image\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.6)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n\\n    >>> # less sensitivity to finer details with the lower frequency kernel\\n    >>> filt_real, filt_imag = gabor(image, frequency=0.1)\\n    >>> plt.figure()            # doctest: +SKIP\\n    >>> io.imshow(filt_real)    # doctest: +SKIP\\n    >>> io.show()               # doctest: +SKIP\\n    \"\n    check_nD(image, 2)\n    if image.dtype.kind == 'f':\n        float_dtype = _supported_float_type(image.dtype)\n        image = image.astype(float_dtype, copy=False)\n        kernel_dtype = np.promote_types(image.dtype, np.complex64)\n    else:\n        kernel_dtype = np.complex128\n    g = gabor_kernel(frequency, theta, bandwidth, sigma_x, sigma_y, n_stds, offset, dtype=kernel_dtype)\n    filtered_real = ndi.convolve(image, np.real(g), mode=mode, cval=cval)\n    filtered_imag = ndi.convolve(image, np.imag(g), mode=mode, cval=cval)\n    return (filtered_real, filtered_imag)"
        ]
    }
]