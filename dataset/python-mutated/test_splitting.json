[
    {
        "func_name": "test_histogram_split",
        "original": "@pytest.mark.parametrize('n_bins', [3, 32, 256])\ndef test_histogram_split(n_bins):\n    rng = np.random.RandomState(42)\n    feature_idx = 0\n    l2_regularization = 0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(int(10000.0), 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned.T[feature_idx]\n    sample_indices = np.arange(binned_feature.shape[0], dtype=np.uint32)\n    ordered_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_hessians = ordered_hessians\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    for true_bin in range(1, n_bins - 2):\n        for sign in [-1, 1]:\n            ordered_gradients = np.full_like(binned_feature, sign, dtype=G_H_DTYPE)\n            ordered_gradients[binned_feature <= true_bin] *= -1\n            all_gradients = ordered_gradients\n            sum_gradients = all_gradients.sum()\n            builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n            n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n            has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n            monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n            is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n            missing_values_bin_idx = n_bins - 1\n            splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n            histograms = builder.compute_histograms_brute(sample_indices)\n            value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n            split_info = splitter.find_node_split(sample_indices.shape[0], histograms, sum_gradients, sum_hessians, value)\n            assert split_info.bin_idx == true_bin\n            assert split_info.gain >= 0\n            assert split_info.feature_idx == feature_idx\n            assert split_info.n_samples_left + split_info.n_samples_right == sample_indices.shape[0]\n            assert split_info.n_samples_left == split_info.sum_hessian_left",
        "mutated": [
            "@pytest.mark.parametrize('n_bins', [3, 32, 256])\ndef test_histogram_split(n_bins):\n    if False:\n        i = 10\n    rng = np.random.RandomState(42)\n    feature_idx = 0\n    l2_regularization = 0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(int(10000.0), 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned.T[feature_idx]\n    sample_indices = np.arange(binned_feature.shape[0], dtype=np.uint32)\n    ordered_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_hessians = ordered_hessians\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    for true_bin in range(1, n_bins - 2):\n        for sign in [-1, 1]:\n            ordered_gradients = np.full_like(binned_feature, sign, dtype=G_H_DTYPE)\n            ordered_gradients[binned_feature <= true_bin] *= -1\n            all_gradients = ordered_gradients\n            sum_gradients = all_gradients.sum()\n            builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n            n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n            has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n            monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n            is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n            missing_values_bin_idx = n_bins - 1\n            splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n            histograms = builder.compute_histograms_brute(sample_indices)\n            value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n            split_info = splitter.find_node_split(sample_indices.shape[0], histograms, sum_gradients, sum_hessians, value)\n            assert split_info.bin_idx == true_bin\n            assert split_info.gain >= 0\n            assert split_info.feature_idx == feature_idx\n            assert split_info.n_samples_left + split_info.n_samples_right == sample_indices.shape[0]\n            assert split_info.n_samples_left == split_info.sum_hessian_left",
            "@pytest.mark.parametrize('n_bins', [3, 32, 256])\ndef test_histogram_split(n_bins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rng = np.random.RandomState(42)\n    feature_idx = 0\n    l2_regularization = 0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(int(10000.0), 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned.T[feature_idx]\n    sample_indices = np.arange(binned_feature.shape[0], dtype=np.uint32)\n    ordered_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_hessians = ordered_hessians\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    for true_bin in range(1, n_bins - 2):\n        for sign in [-1, 1]:\n            ordered_gradients = np.full_like(binned_feature, sign, dtype=G_H_DTYPE)\n            ordered_gradients[binned_feature <= true_bin] *= -1\n            all_gradients = ordered_gradients\n            sum_gradients = all_gradients.sum()\n            builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n            n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n            has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n            monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n            is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n            missing_values_bin_idx = n_bins - 1\n            splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n            histograms = builder.compute_histograms_brute(sample_indices)\n            value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n            split_info = splitter.find_node_split(sample_indices.shape[0], histograms, sum_gradients, sum_hessians, value)\n            assert split_info.bin_idx == true_bin\n            assert split_info.gain >= 0\n            assert split_info.feature_idx == feature_idx\n            assert split_info.n_samples_left + split_info.n_samples_right == sample_indices.shape[0]\n            assert split_info.n_samples_left == split_info.sum_hessian_left",
            "@pytest.mark.parametrize('n_bins', [3, 32, 256])\ndef test_histogram_split(n_bins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rng = np.random.RandomState(42)\n    feature_idx = 0\n    l2_regularization = 0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(int(10000.0), 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned.T[feature_idx]\n    sample_indices = np.arange(binned_feature.shape[0], dtype=np.uint32)\n    ordered_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_hessians = ordered_hessians\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    for true_bin in range(1, n_bins - 2):\n        for sign in [-1, 1]:\n            ordered_gradients = np.full_like(binned_feature, sign, dtype=G_H_DTYPE)\n            ordered_gradients[binned_feature <= true_bin] *= -1\n            all_gradients = ordered_gradients\n            sum_gradients = all_gradients.sum()\n            builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n            n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n            has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n            monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n            is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n            missing_values_bin_idx = n_bins - 1\n            splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n            histograms = builder.compute_histograms_brute(sample_indices)\n            value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n            split_info = splitter.find_node_split(sample_indices.shape[0], histograms, sum_gradients, sum_hessians, value)\n            assert split_info.bin_idx == true_bin\n            assert split_info.gain >= 0\n            assert split_info.feature_idx == feature_idx\n            assert split_info.n_samples_left + split_info.n_samples_right == sample_indices.shape[0]\n            assert split_info.n_samples_left == split_info.sum_hessian_left",
            "@pytest.mark.parametrize('n_bins', [3, 32, 256])\ndef test_histogram_split(n_bins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rng = np.random.RandomState(42)\n    feature_idx = 0\n    l2_regularization = 0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(int(10000.0), 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned.T[feature_idx]\n    sample_indices = np.arange(binned_feature.shape[0], dtype=np.uint32)\n    ordered_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_hessians = ordered_hessians\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    for true_bin in range(1, n_bins - 2):\n        for sign in [-1, 1]:\n            ordered_gradients = np.full_like(binned_feature, sign, dtype=G_H_DTYPE)\n            ordered_gradients[binned_feature <= true_bin] *= -1\n            all_gradients = ordered_gradients\n            sum_gradients = all_gradients.sum()\n            builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n            n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n            has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n            monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n            is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n            missing_values_bin_idx = n_bins - 1\n            splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n            histograms = builder.compute_histograms_brute(sample_indices)\n            value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n            split_info = splitter.find_node_split(sample_indices.shape[0], histograms, sum_gradients, sum_hessians, value)\n            assert split_info.bin_idx == true_bin\n            assert split_info.gain >= 0\n            assert split_info.feature_idx == feature_idx\n            assert split_info.n_samples_left + split_info.n_samples_right == sample_indices.shape[0]\n            assert split_info.n_samples_left == split_info.sum_hessian_left",
            "@pytest.mark.parametrize('n_bins', [3, 32, 256])\ndef test_histogram_split(n_bins):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rng = np.random.RandomState(42)\n    feature_idx = 0\n    l2_regularization = 0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(int(10000.0), 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned.T[feature_idx]\n    sample_indices = np.arange(binned_feature.shape[0], dtype=np.uint32)\n    ordered_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_hessians = ordered_hessians\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    for true_bin in range(1, n_bins - 2):\n        for sign in [-1, 1]:\n            ordered_gradients = np.full_like(binned_feature, sign, dtype=G_H_DTYPE)\n            ordered_gradients[binned_feature <= true_bin] *= -1\n            all_gradients = ordered_gradients\n            sum_gradients = all_gradients.sum()\n            builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n            n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n            has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n            monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n            is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n            missing_values_bin_idx = n_bins - 1\n            splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n            histograms = builder.compute_histograms_brute(sample_indices)\n            value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n            split_info = splitter.find_node_split(sample_indices.shape[0], histograms, sum_gradients, sum_hessians, value)\n            assert split_info.bin_idx == true_bin\n            assert split_info.gain >= 0\n            assert split_info.feature_idx == feature_idx\n            assert split_info.n_samples_left + split_info.n_samples_right == sample_indices.shape[0]\n            assert split_info.n_samples_left == split_info.sum_hessian_left"
        ]
    },
    {
        "func_name": "test_gradient_and_hessian_sanity",
        "original": "@skip_if_32bit\n@pytest.mark.parametrize('constant_hessian', [True, False])\ndef test_gradient_and_hessian_sanity(constant_hessian):\n    rng = np.random.RandomState(42)\n    n_bins = 10\n    n_features = 20\n    n_samples = 500\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = rng.randint(0, n_bins, size=(n_samples, n_features), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    if constant_hessian:\n        all_hessians = np.ones(1, dtype=G_H_DTYPE)\n        sum_hessians = 1 * n_samples\n    else:\n        all_hessians = rng.lognormal(size=n_samples).astype(G_H_DTYPE)\n        sum_hessians = all_hessians.sum()\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, constant_hessian, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, constant_hessian)\n    hists_parent = builder.compute_histograms_brute(sample_indices)\n    value_parent = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_parent = splitter.find_node_split(n_samples, hists_parent, sum_gradients, sum_hessians, value_parent)\n    (sample_indices_left, sample_indices_right, _) = splitter.split_indices(si_parent, sample_indices)\n    hists_left = builder.compute_histograms_brute(sample_indices_left)\n    value_left = compute_node_value(si_parent.sum_gradient_left, si_parent.sum_hessian_left, -np.inf, np.inf, l2_regularization)\n    hists_right = builder.compute_histograms_brute(sample_indices_right)\n    value_right = compute_node_value(si_parent.sum_gradient_right, si_parent.sum_hessian_right, -np.inf, np.inf, l2_regularization)\n    si_left = splitter.find_node_split(n_samples, hists_left, si_parent.sum_gradient_left, si_parent.sum_hessian_left, value_left)\n    si_right = splitter.find_node_split(n_samples, hists_right, si_parent.sum_gradient_right, si_parent.sum_hessian_right, value_right)\n    for (si, indices) in ((si_parent, sample_indices), (si_left, sample_indices_left), (si_right, sample_indices_right)):\n        gradient = si.sum_gradient_right + si.sum_gradient_left\n        expected_gradient = all_gradients[indices].sum()\n        hessian = si.sum_hessian_right + si.sum_hessian_left\n        if constant_hessian:\n            expected_hessian = indices.shape[0] * all_hessians[0]\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.isclose(gradient, expected_gradient)\n        assert np.isclose(hessian, expected_hessian)\n    hists_parent = np.asarray(hists_parent, dtype=HISTOGRAM_DTYPE)\n    hists_left = np.asarray(hists_left, dtype=HISTOGRAM_DTYPE)\n    hists_right = np.asarray(hists_right, dtype=HISTOGRAM_DTYPE)\n    for (hists, indices) in ((hists_parent, sample_indices), (hists_left, sample_indices_left), (hists_right, sample_indices_right)):\n        gradients = hists['sum_gradients'].sum(axis=1)\n        expected_gradient = all_gradients[indices].sum()\n        hessians = hists['sum_hessians'].sum(axis=1)\n        if constant_hessian:\n            expected_hessian = 0.0\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.allclose(gradients, expected_gradient)\n        assert np.allclose(hessians, expected_hessian)",
        "mutated": [
            "@skip_if_32bit\n@pytest.mark.parametrize('constant_hessian', [True, False])\ndef test_gradient_and_hessian_sanity(constant_hessian):\n    if False:\n        i = 10\n    rng = np.random.RandomState(42)\n    n_bins = 10\n    n_features = 20\n    n_samples = 500\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = rng.randint(0, n_bins, size=(n_samples, n_features), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    if constant_hessian:\n        all_hessians = np.ones(1, dtype=G_H_DTYPE)\n        sum_hessians = 1 * n_samples\n    else:\n        all_hessians = rng.lognormal(size=n_samples).astype(G_H_DTYPE)\n        sum_hessians = all_hessians.sum()\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, constant_hessian, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, constant_hessian)\n    hists_parent = builder.compute_histograms_brute(sample_indices)\n    value_parent = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_parent = splitter.find_node_split(n_samples, hists_parent, sum_gradients, sum_hessians, value_parent)\n    (sample_indices_left, sample_indices_right, _) = splitter.split_indices(si_parent, sample_indices)\n    hists_left = builder.compute_histograms_brute(sample_indices_left)\n    value_left = compute_node_value(si_parent.sum_gradient_left, si_parent.sum_hessian_left, -np.inf, np.inf, l2_regularization)\n    hists_right = builder.compute_histograms_brute(sample_indices_right)\n    value_right = compute_node_value(si_parent.sum_gradient_right, si_parent.sum_hessian_right, -np.inf, np.inf, l2_regularization)\n    si_left = splitter.find_node_split(n_samples, hists_left, si_parent.sum_gradient_left, si_parent.sum_hessian_left, value_left)\n    si_right = splitter.find_node_split(n_samples, hists_right, si_parent.sum_gradient_right, si_parent.sum_hessian_right, value_right)\n    for (si, indices) in ((si_parent, sample_indices), (si_left, sample_indices_left), (si_right, sample_indices_right)):\n        gradient = si.sum_gradient_right + si.sum_gradient_left\n        expected_gradient = all_gradients[indices].sum()\n        hessian = si.sum_hessian_right + si.sum_hessian_left\n        if constant_hessian:\n            expected_hessian = indices.shape[0] * all_hessians[0]\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.isclose(gradient, expected_gradient)\n        assert np.isclose(hessian, expected_hessian)\n    hists_parent = np.asarray(hists_parent, dtype=HISTOGRAM_DTYPE)\n    hists_left = np.asarray(hists_left, dtype=HISTOGRAM_DTYPE)\n    hists_right = np.asarray(hists_right, dtype=HISTOGRAM_DTYPE)\n    for (hists, indices) in ((hists_parent, sample_indices), (hists_left, sample_indices_left), (hists_right, sample_indices_right)):\n        gradients = hists['sum_gradients'].sum(axis=1)\n        expected_gradient = all_gradients[indices].sum()\n        hessians = hists['sum_hessians'].sum(axis=1)\n        if constant_hessian:\n            expected_hessian = 0.0\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.allclose(gradients, expected_gradient)\n        assert np.allclose(hessians, expected_hessian)",
            "@skip_if_32bit\n@pytest.mark.parametrize('constant_hessian', [True, False])\ndef test_gradient_and_hessian_sanity(constant_hessian):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rng = np.random.RandomState(42)\n    n_bins = 10\n    n_features = 20\n    n_samples = 500\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = rng.randint(0, n_bins, size=(n_samples, n_features), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    if constant_hessian:\n        all_hessians = np.ones(1, dtype=G_H_DTYPE)\n        sum_hessians = 1 * n_samples\n    else:\n        all_hessians = rng.lognormal(size=n_samples).astype(G_H_DTYPE)\n        sum_hessians = all_hessians.sum()\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, constant_hessian, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, constant_hessian)\n    hists_parent = builder.compute_histograms_brute(sample_indices)\n    value_parent = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_parent = splitter.find_node_split(n_samples, hists_parent, sum_gradients, sum_hessians, value_parent)\n    (sample_indices_left, sample_indices_right, _) = splitter.split_indices(si_parent, sample_indices)\n    hists_left = builder.compute_histograms_brute(sample_indices_left)\n    value_left = compute_node_value(si_parent.sum_gradient_left, si_parent.sum_hessian_left, -np.inf, np.inf, l2_regularization)\n    hists_right = builder.compute_histograms_brute(sample_indices_right)\n    value_right = compute_node_value(si_parent.sum_gradient_right, si_parent.sum_hessian_right, -np.inf, np.inf, l2_regularization)\n    si_left = splitter.find_node_split(n_samples, hists_left, si_parent.sum_gradient_left, si_parent.sum_hessian_left, value_left)\n    si_right = splitter.find_node_split(n_samples, hists_right, si_parent.sum_gradient_right, si_parent.sum_hessian_right, value_right)\n    for (si, indices) in ((si_parent, sample_indices), (si_left, sample_indices_left), (si_right, sample_indices_right)):\n        gradient = si.sum_gradient_right + si.sum_gradient_left\n        expected_gradient = all_gradients[indices].sum()\n        hessian = si.sum_hessian_right + si.sum_hessian_left\n        if constant_hessian:\n            expected_hessian = indices.shape[0] * all_hessians[0]\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.isclose(gradient, expected_gradient)\n        assert np.isclose(hessian, expected_hessian)\n    hists_parent = np.asarray(hists_parent, dtype=HISTOGRAM_DTYPE)\n    hists_left = np.asarray(hists_left, dtype=HISTOGRAM_DTYPE)\n    hists_right = np.asarray(hists_right, dtype=HISTOGRAM_DTYPE)\n    for (hists, indices) in ((hists_parent, sample_indices), (hists_left, sample_indices_left), (hists_right, sample_indices_right)):\n        gradients = hists['sum_gradients'].sum(axis=1)\n        expected_gradient = all_gradients[indices].sum()\n        hessians = hists['sum_hessians'].sum(axis=1)\n        if constant_hessian:\n            expected_hessian = 0.0\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.allclose(gradients, expected_gradient)\n        assert np.allclose(hessians, expected_hessian)",
            "@skip_if_32bit\n@pytest.mark.parametrize('constant_hessian', [True, False])\ndef test_gradient_and_hessian_sanity(constant_hessian):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rng = np.random.RandomState(42)\n    n_bins = 10\n    n_features = 20\n    n_samples = 500\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = rng.randint(0, n_bins, size=(n_samples, n_features), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    if constant_hessian:\n        all_hessians = np.ones(1, dtype=G_H_DTYPE)\n        sum_hessians = 1 * n_samples\n    else:\n        all_hessians = rng.lognormal(size=n_samples).astype(G_H_DTYPE)\n        sum_hessians = all_hessians.sum()\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, constant_hessian, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, constant_hessian)\n    hists_parent = builder.compute_histograms_brute(sample_indices)\n    value_parent = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_parent = splitter.find_node_split(n_samples, hists_parent, sum_gradients, sum_hessians, value_parent)\n    (sample_indices_left, sample_indices_right, _) = splitter.split_indices(si_parent, sample_indices)\n    hists_left = builder.compute_histograms_brute(sample_indices_left)\n    value_left = compute_node_value(si_parent.sum_gradient_left, si_parent.sum_hessian_left, -np.inf, np.inf, l2_regularization)\n    hists_right = builder.compute_histograms_brute(sample_indices_right)\n    value_right = compute_node_value(si_parent.sum_gradient_right, si_parent.sum_hessian_right, -np.inf, np.inf, l2_regularization)\n    si_left = splitter.find_node_split(n_samples, hists_left, si_parent.sum_gradient_left, si_parent.sum_hessian_left, value_left)\n    si_right = splitter.find_node_split(n_samples, hists_right, si_parent.sum_gradient_right, si_parent.sum_hessian_right, value_right)\n    for (si, indices) in ((si_parent, sample_indices), (si_left, sample_indices_left), (si_right, sample_indices_right)):\n        gradient = si.sum_gradient_right + si.sum_gradient_left\n        expected_gradient = all_gradients[indices].sum()\n        hessian = si.sum_hessian_right + si.sum_hessian_left\n        if constant_hessian:\n            expected_hessian = indices.shape[0] * all_hessians[0]\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.isclose(gradient, expected_gradient)\n        assert np.isclose(hessian, expected_hessian)\n    hists_parent = np.asarray(hists_parent, dtype=HISTOGRAM_DTYPE)\n    hists_left = np.asarray(hists_left, dtype=HISTOGRAM_DTYPE)\n    hists_right = np.asarray(hists_right, dtype=HISTOGRAM_DTYPE)\n    for (hists, indices) in ((hists_parent, sample_indices), (hists_left, sample_indices_left), (hists_right, sample_indices_right)):\n        gradients = hists['sum_gradients'].sum(axis=1)\n        expected_gradient = all_gradients[indices].sum()\n        hessians = hists['sum_hessians'].sum(axis=1)\n        if constant_hessian:\n            expected_hessian = 0.0\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.allclose(gradients, expected_gradient)\n        assert np.allclose(hessians, expected_hessian)",
            "@skip_if_32bit\n@pytest.mark.parametrize('constant_hessian', [True, False])\ndef test_gradient_and_hessian_sanity(constant_hessian):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rng = np.random.RandomState(42)\n    n_bins = 10\n    n_features = 20\n    n_samples = 500\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = rng.randint(0, n_bins, size=(n_samples, n_features), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    if constant_hessian:\n        all_hessians = np.ones(1, dtype=G_H_DTYPE)\n        sum_hessians = 1 * n_samples\n    else:\n        all_hessians = rng.lognormal(size=n_samples).astype(G_H_DTYPE)\n        sum_hessians = all_hessians.sum()\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, constant_hessian, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, constant_hessian)\n    hists_parent = builder.compute_histograms_brute(sample_indices)\n    value_parent = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_parent = splitter.find_node_split(n_samples, hists_parent, sum_gradients, sum_hessians, value_parent)\n    (sample_indices_left, sample_indices_right, _) = splitter.split_indices(si_parent, sample_indices)\n    hists_left = builder.compute_histograms_brute(sample_indices_left)\n    value_left = compute_node_value(si_parent.sum_gradient_left, si_parent.sum_hessian_left, -np.inf, np.inf, l2_regularization)\n    hists_right = builder.compute_histograms_brute(sample_indices_right)\n    value_right = compute_node_value(si_parent.sum_gradient_right, si_parent.sum_hessian_right, -np.inf, np.inf, l2_regularization)\n    si_left = splitter.find_node_split(n_samples, hists_left, si_parent.sum_gradient_left, si_parent.sum_hessian_left, value_left)\n    si_right = splitter.find_node_split(n_samples, hists_right, si_parent.sum_gradient_right, si_parent.sum_hessian_right, value_right)\n    for (si, indices) in ((si_parent, sample_indices), (si_left, sample_indices_left), (si_right, sample_indices_right)):\n        gradient = si.sum_gradient_right + si.sum_gradient_left\n        expected_gradient = all_gradients[indices].sum()\n        hessian = si.sum_hessian_right + si.sum_hessian_left\n        if constant_hessian:\n            expected_hessian = indices.shape[0] * all_hessians[0]\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.isclose(gradient, expected_gradient)\n        assert np.isclose(hessian, expected_hessian)\n    hists_parent = np.asarray(hists_parent, dtype=HISTOGRAM_DTYPE)\n    hists_left = np.asarray(hists_left, dtype=HISTOGRAM_DTYPE)\n    hists_right = np.asarray(hists_right, dtype=HISTOGRAM_DTYPE)\n    for (hists, indices) in ((hists_parent, sample_indices), (hists_left, sample_indices_left), (hists_right, sample_indices_right)):\n        gradients = hists['sum_gradients'].sum(axis=1)\n        expected_gradient = all_gradients[indices].sum()\n        hessians = hists['sum_hessians'].sum(axis=1)\n        if constant_hessian:\n            expected_hessian = 0.0\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.allclose(gradients, expected_gradient)\n        assert np.allclose(hessians, expected_hessian)",
            "@skip_if_32bit\n@pytest.mark.parametrize('constant_hessian', [True, False])\ndef test_gradient_and_hessian_sanity(constant_hessian):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rng = np.random.RandomState(42)\n    n_bins = 10\n    n_features = 20\n    n_samples = 500\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = rng.randint(0, n_bins, size=(n_samples, n_features), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    if constant_hessian:\n        all_hessians = np.ones(1, dtype=G_H_DTYPE)\n        sum_hessians = 1 * n_samples\n    else:\n        all_hessians = rng.lognormal(size=n_samples).astype(G_H_DTYPE)\n        sum_hessians = all_hessians.sum()\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, constant_hessian, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, constant_hessian)\n    hists_parent = builder.compute_histograms_brute(sample_indices)\n    value_parent = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_parent = splitter.find_node_split(n_samples, hists_parent, sum_gradients, sum_hessians, value_parent)\n    (sample_indices_left, sample_indices_right, _) = splitter.split_indices(si_parent, sample_indices)\n    hists_left = builder.compute_histograms_brute(sample_indices_left)\n    value_left = compute_node_value(si_parent.sum_gradient_left, si_parent.sum_hessian_left, -np.inf, np.inf, l2_regularization)\n    hists_right = builder.compute_histograms_brute(sample_indices_right)\n    value_right = compute_node_value(si_parent.sum_gradient_right, si_parent.sum_hessian_right, -np.inf, np.inf, l2_regularization)\n    si_left = splitter.find_node_split(n_samples, hists_left, si_parent.sum_gradient_left, si_parent.sum_hessian_left, value_left)\n    si_right = splitter.find_node_split(n_samples, hists_right, si_parent.sum_gradient_right, si_parent.sum_hessian_right, value_right)\n    for (si, indices) in ((si_parent, sample_indices), (si_left, sample_indices_left), (si_right, sample_indices_right)):\n        gradient = si.sum_gradient_right + si.sum_gradient_left\n        expected_gradient = all_gradients[indices].sum()\n        hessian = si.sum_hessian_right + si.sum_hessian_left\n        if constant_hessian:\n            expected_hessian = indices.shape[0] * all_hessians[0]\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.isclose(gradient, expected_gradient)\n        assert np.isclose(hessian, expected_hessian)\n    hists_parent = np.asarray(hists_parent, dtype=HISTOGRAM_DTYPE)\n    hists_left = np.asarray(hists_left, dtype=HISTOGRAM_DTYPE)\n    hists_right = np.asarray(hists_right, dtype=HISTOGRAM_DTYPE)\n    for (hists, indices) in ((hists_parent, sample_indices), (hists_left, sample_indices_left), (hists_right, sample_indices_right)):\n        gradients = hists['sum_gradients'].sum(axis=1)\n        expected_gradient = all_gradients[indices].sum()\n        hessians = hists['sum_hessians'].sum(axis=1)\n        if constant_hessian:\n            expected_hessian = 0.0\n        else:\n            expected_hessian = all_hessians[indices].sum()\n        assert np.allclose(gradients, expected_gradient)\n        assert np.allclose(hessians, expected_hessian)"
        ]
    },
    {
        "func_name": "test_split_indices",
        "original": "def test_split_indices():\n    rng = np.random.RandomState(421)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = [[0, 0], [0, 3], [0, 4], [0, 0], [0, 0], [0, 0], [0, 0], [0, 4], [0, 0], [0, 4]]\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    assert np.all(sample_indices == splitter.partition)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert si_root.feature_idx == 1\n    assert si_root.bin_idx == 3\n    (samples_left, samples_right, position_right) = splitter.split_indices(si_root, splitter.partition)\n    assert set(samples_left) == set([0, 1, 3, 4, 5, 6, 8])\n    assert set(samples_right) == set([2, 7, 9])\n    assert list(samples_left) == list(splitter.partition[:position_right])\n    assert list(samples_right) == list(splitter.partition[position_right:])\n    assert samples_left.shape[0] == si_root.n_samples_left\n    assert samples_right.shape[0] == si_root.n_samples_right",
        "mutated": [
            "def test_split_indices():\n    if False:\n        i = 10\n    rng = np.random.RandomState(421)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = [[0, 0], [0, 3], [0, 4], [0, 0], [0, 0], [0, 0], [0, 0], [0, 4], [0, 0], [0, 4]]\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    assert np.all(sample_indices == splitter.partition)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert si_root.feature_idx == 1\n    assert si_root.bin_idx == 3\n    (samples_left, samples_right, position_right) = splitter.split_indices(si_root, splitter.partition)\n    assert set(samples_left) == set([0, 1, 3, 4, 5, 6, 8])\n    assert set(samples_right) == set([2, 7, 9])\n    assert list(samples_left) == list(splitter.partition[:position_right])\n    assert list(samples_right) == list(splitter.partition[position_right:])\n    assert samples_left.shape[0] == si_root.n_samples_left\n    assert samples_right.shape[0] == si_root.n_samples_right",
            "def test_split_indices():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rng = np.random.RandomState(421)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = [[0, 0], [0, 3], [0, 4], [0, 0], [0, 0], [0, 0], [0, 0], [0, 4], [0, 0], [0, 4]]\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    assert np.all(sample_indices == splitter.partition)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert si_root.feature_idx == 1\n    assert si_root.bin_idx == 3\n    (samples_left, samples_right, position_right) = splitter.split_indices(si_root, splitter.partition)\n    assert set(samples_left) == set([0, 1, 3, 4, 5, 6, 8])\n    assert set(samples_right) == set([2, 7, 9])\n    assert list(samples_left) == list(splitter.partition[:position_right])\n    assert list(samples_right) == list(splitter.partition[position_right:])\n    assert samples_left.shape[0] == si_root.n_samples_left\n    assert samples_right.shape[0] == si_root.n_samples_right",
            "def test_split_indices():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rng = np.random.RandomState(421)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = [[0, 0], [0, 3], [0, 4], [0, 0], [0, 0], [0, 0], [0, 0], [0, 4], [0, 0], [0, 4]]\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    assert np.all(sample_indices == splitter.partition)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert si_root.feature_idx == 1\n    assert si_root.bin_idx == 3\n    (samples_left, samples_right, position_right) = splitter.split_indices(si_root, splitter.partition)\n    assert set(samples_left) == set([0, 1, 3, 4, 5, 6, 8])\n    assert set(samples_right) == set([2, 7, 9])\n    assert list(samples_left) == list(splitter.partition[:position_right])\n    assert list(samples_right) == list(splitter.partition[position_right:])\n    assert samples_left.shape[0] == si_root.n_samples_left\n    assert samples_right.shape[0] == si_root.n_samples_right",
            "def test_split_indices():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rng = np.random.RandomState(421)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = [[0, 0], [0, 3], [0, 4], [0, 0], [0, 0], [0, 0], [0, 0], [0, 4], [0, 0], [0, 4]]\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    assert np.all(sample_indices == splitter.partition)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert si_root.feature_idx == 1\n    assert si_root.bin_idx == 3\n    (samples_left, samples_right, position_right) = splitter.split_indices(si_root, splitter.partition)\n    assert set(samples_left) == set([0, 1, 3, 4, 5, 6, 8])\n    assert set(samples_right) == set([2, 7, 9])\n    assert list(samples_left) == list(splitter.partition[:position_right])\n    assert list(samples_right) == list(splitter.partition[position_right:])\n    assert samples_left.shape[0] == si_root.n_samples_left\n    assert samples_right.shape[0] == si_root.n_samples_right",
            "def test_split_indices():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rng = np.random.RandomState(421)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    X_binned = [[0, 0], [0, 3], [0, 4], [0, 0], [0, 0], [0, 0], [0, 0], [0, 4], [0, 0], [0, 4]]\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.randn(n_samples).astype(G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    assert np.all(sample_indices == splitter.partition)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert si_root.feature_idx == 1\n    assert si_root.bin_idx == 3\n    (samples_left, samples_right, position_right) = splitter.split_indices(si_root, splitter.partition)\n    assert set(samples_left) == set([0, 1, 3, 4, 5, 6, 8])\n    assert set(samples_right) == set([2, 7, 9])\n    assert list(samples_left) == list(splitter.partition[:position_right])\n    assert list(samples_right) == list(splitter.partition[position_right:])\n    assert samples_left.shape[0] == si_root.n_samples_left\n    assert samples_right.shape[0] == si_root.n_samples_right"
        ]
    },
    {
        "func_name": "test_min_gain_to_split",
        "original": "def test_min_gain_to_split():\n    rng = np.random.RandomState(42)\n    l2_regularization = 0\n    min_hessian_to_split = 0\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    n_bins = 255\n    n_samples = 100\n    X_binned = np.asfortranarray(rng.randint(0, n_bins, size=(n_samples, 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned[:, 0]\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_gradients = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
        "mutated": [
            "def test_min_gain_to_split():\n    if False:\n        i = 10\n    rng = np.random.RandomState(42)\n    l2_regularization = 0\n    min_hessian_to_split = 0\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    n_bins = 255\n    n_samples = 100\n    X_binned = np.asfortranarray(rng.randint(0, n_bins, size=(n_samples, 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned[:, 0]\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_gradients = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
            "def test_min_gain_to_split():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rng = np.random.RandomState(42)\n    l2_regularization = 0\n    min_hessian_to_split = 0\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    n_bins = 255\n    n_samples = 100\n    X_binned = np.asfortranarray(rng.randint(0, n_bins, size=(n_samples, 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned[:, 0]\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_gradients = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
            "def test_min_gain_to_split():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rng = np.random.RandomState(42)\n    l2_regularization = 0\n    min_hessian_to_split = 0\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    n_bins = 255\n    n_samples = 100\n    X_binned = np.asfortranarray(rng.randint(0, n_bins, size=(n_samples, 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned[:, 0]\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_gradients = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
            "def test_min_gain_to_split():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rng = np.random.RandomState(42)\n    l2_regularization = 0\n    min_hessian_to_split = 0\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    n_bins = 255\n    n_samples = 100\n    X_binned = np.asfortranarray(rng.randint(0, n_bins, size=(n_samples, 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned[:, 0]\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_gradients = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
            "def test_min_gain_to_split():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rng = np.random.RandomState(42)\n    l2_regularization = 0\n    min_hessian_to_split = 0\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    n_bins = 255\n    n_samples = 100\n    X_binned = np.asfortranarray(rng.randint(0, n_bins, size=(n_samples, 1)), dtype=X_BINNED_DTYPE)\n    binned_feature = X_binned[:, 0]\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    all_gradients = np.ones_like(binned_feature, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = all_hessians.sum()\n    hessians_are_constant = False\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins - 1] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1"
        ]
    },
    {
        "func_name": "test_splitting_missing_values",
        "original": "@pytest.mark.parametrize('X_binned, all_gradients, has_missing_values, n_bins_non_missing,  expected_split_on_nan, expected_bin_idx, expected_go_to_left', [([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], False, 10, False, 3, 'not_applicable'), ([8, 0, 1, 8, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([9, 0, 1, 9, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([0, 1, 2, 3, 8, 4, 8, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 9, 4, 9, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 4, True, 3, False), ([0, 1, 2, 3, 9, 9, 9, 9, 9, 9], [1, 1, 1, 1, 1, 1, 5, 5, 5, 5], True, 4, True, 3, False), ([6, 6, 6, 6, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False), ([9, 9, 9, 9, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False)])\ndef test_splitting_missing_values(X_binned, all_gradients, has_missing_values, n_bins_non_missing, expected_split_on_nan, expected_bin_idx, expected_go_to_left):\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.bin_idx == expected_bin_idx\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_go_to_left\n    split_on_nan = split_info.bin_idx == n_bins_non_missing[0] - 1\n    assert split_on_nan == expected_split_on_nan\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    if not expected_split_on_nan:\n        assert set(samples_left) == set([0, 1, 2, 3])\n        assert set(samples_right) == set([4, 5, 6, 7, 8, 9])\n    else:\n        missing_samples_indices = np.flatnonzero(np.array(X_binned) == missing_values_bin_idx)\n        non_missing_samples_indices = np.flatnonzero(np.array(X_binned) != missing_values_bin_idx)\n        assert set(samples_right) == set(missing_samples_indices)\n        assert set(samples_left) == set(non_missing_samples_indices)",
        "mutated": [
            "@pytest.mark.parametrize('X_binned, all_gradients, has_missing_values, n_bins_non_missing,  expected_split_on_nan, expected_bin_idx, expected_go_to_left', [([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], False, 10, False, 3, 'not_applicable'), ([8, 0, 1, 8, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([9, 0, 1, 9, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([0, 1, 2, 3, 8, 4, 8, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 9, 4, 9, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 4, True, 3, False), ([0, 1, 2, 3, 9, 9, 9, 9, 9, 9], [1, 1, 1, 1, 1, 1, 5, 5, 5, 5], True, 4, True, 3, False), ([6, 6, 6, 6, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False), ([9, 9, 9, 9, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False)])\ndef test_splitting_missing_values(X_binned, all_gradients, has_missing_values, n_bins_non_missing, expected_split_on_nan, expected_bin_idx, expected_go_to_left):\n    if False:\n        i = 10\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.bin_idx == expected_bin_idx\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_go_to_left\n    split_on_nan = split_info.bin_idx == n_bins_non_missing[0] - 1\n    assert split_on_nan == expected_split_on_nan\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    if not expected_split_on_nan:\n        assert set(samples_left) == set([0, 1, 2, 3])\n        assert set(samples_right) == set([4, 5, 6, 7, 8, 9])\n    else:\n        missing_samples_indices = np.flatnonzero(np.array(X_binned) == missing_values_bin_idx)\n        non_missing_samples_indices = np.flatnonzero(np.array(X_binned) != missing_values_bin_idx)\n        assert set(samples_right) == set(missing_samples_indices)\n        assert set(samples_left) == set(non_missing_samples_indices)",
            "@pytest.mark.parametrize('X_binned, all_gradients, has_missing_values, n_bins_non_missing,  expected_split_on_nan, expected_bin_idx, expected_go_to_left', [([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], False, 10, False, 3, 'not_applicable'), ([8, 0, 1, 8, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([9, 0, 1, 9, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([0, 1, 2, 3, 8, 4, 8, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 9, 4, 9, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 4, True, 3, False), ([0, 1, 2, 3, 9, 9, 9, 9, 9, 9], [1, 1, 1, 1, 1, 1, 5, 5, 5, 5], True, 4, True, 3, False), ([6, 6, 6, 6, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False), ([9, 9, 9, 9, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False)])\ndef test_splitting_missing_values(X_binned, all_gradients, has_missing_values, n_bins_non_missing, expected_split_on_nan, expected_bin_idx, expected_go_to_left):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.bin_idx == expected_bin_idx\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_go_to_left\n    split_on_nan = split_info.bin_idx == n_bins_non_missing[0] - 1\n    assert split_on_nan == expected_split_on_nan\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    if not expected_split_on_nan:\n        assert set(samples_left) == set([0, 1, 2, 3])\n        assert set(samples_right) == set([4, 5, 6, 7, 8, 9])\n    else:\n        missing_samples_indices = np.flatnonzero(np.array(X_binned) == missing_values_bin_idx)\n        non_missing_samples_indices = np.flatnonzero(np.array(X_binned) != missing_values_bin_idx)\n        assert set(samples_right) == set(missing_samples_indices)\n        assert set(samples_left) == set(non_missing_samples_indices)",
            "@pytest.mark.parametrize('X_binned, all_gradients, has_missing_values, n_bins_non_missing,  expected_split_on_nan, expected_bin_idx, expected_go_to_left', [([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], False, 10, False, 3, 'not_applicable'), ([8, 0, 1, 8, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([9, 0, 1, 9, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([0, 1, 2, 3, 8, 4, 8, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 9, 4, 9, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 4, True, 3, False), ([0, 1, 2, 3, 9, 9, 9, 9, 9, 9], [1, 1, 1, 1, 1, 1, 5, 5, 5, 5], True, 4, True, 3, False), ([6, 6, 6, 6, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False), ([9, 9, 9, 9, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False)])\ndef test_splitting_missing_values(X_binned, all_gradients, has_missing_values, n_bins_non_missing, expected_split_on_nan, expected_bin_idx, expected_go_to_left):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.bin_idx == expected_bin_idx\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_go_to_left\n    split_on_nan = split_info.bin_idx == n_bins_non_missing[0] - 1\n    assert split_on_nan == expected_split_on_nan\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    if not expected_split_on_nan:\n        assert set(samples_left) == set([0, 1, 2, 3])\n        assert set(samples_right) == set([4, 5, 6, 7, 8, 9])\n    else:\n        missing_samples_indices = np.flatnonzero(np.array(X_binned) == missing_values_bin_idx)\n        non_missing_samples_indices = np.flatnonzero(np.array(X_binned) != missing_values_bin_idx)\n        assert set(samples_right) == set(missing_samples_indices)\n        assert set(samples_left) == set(non_missing_samples_indices)",
            "@pytest.mark.parametrize('X_binned, all_gradients, has_missing_values, n_bins_non_missing,  expected_split_on_nan, expected_bin_idx, expected_go_to_left', [([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], False, 10, False, 3, 'not_applicable'), ([8, 0, 1, 8, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([9, 0, 1, 9, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([0, 1, 2, 3, 8, 4, 8, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 9, 4, 9, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 4, True, 3, False), ([0, 1, 2, 3, 9, 9, 9, 9, 9, 9], [1, 1, 1, 1, 1, 1, 5, 5, 5, 5], True, 4, True, 3, False), ([6, 6, 6, 6, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False), ([9, 9, 9, 9, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False)])\ndef test_splitting_missing_values(X_binned, all_gradients, has_missing_values, n_bins_non_missing, expected_split_on_nan, expected_bin_idx, expected_go_to_left):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.bin_idx == expected_bin_idx\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_go_to_left\n    split_on_nan = split_info.bin_idx == n_bins_non_missing[0] - 1\n    assert split_on_nan == expected_split_on_nan\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    if not expected_split_on_nan:\n        assert set(samples_left) == set([0, 1, 2, 3])\n        assert set(samples_right) == set([4, 5, 6, 7, 8, 9])\n    else:\n        missing_samples_indices = np.flatnonzero(np.array(X_binned) == missing_values_bin_idx)\n        non_missing_samples_indices = np.flatnonzero(np.array(X_binned) != missing_values_bin_idx)\n        assert set(samples_right) == set(missing_samples_indices)\n        assert set(samples_left) == set(non_missing_samples_indices)",
            "@pytest.mark.parametrize('X_binned, all_gradients, has_missing_values, n_bins_non_missing,  expected_split_on_nan, expected_bin_idx, expected_go_to_left', [([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], False, 10, False, 3, 'not_applicable'), ([8, 0, 1, 8, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([9, 0, 1, 9, 2, 3, 4, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 1, True), ([0, 1, 2, 3, 8, 4, 8, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 9, 4, 9, 5, 6, 7], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 8, False, 3, False), ([0, 1, 2, 3, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 4, True, 3, False), ([0, 1, 2, 3, 9, 9, 9, 9, 9, 9], [1, 1, 1, 1, 1, 1, 5, 5, 5, 5], True, 4, True, 3, False), ([6, 6, 6, 6, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False), ([9, 9, 9, 9, 0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 5, 5, 5, 5, 5, 5], True, 6, True, 5, False)])\ndef test_splitting_missing_values(X_binned, all_gradients, has_missing_values, n_bins_non_missing, expected_split_on_nan, expected_bin_idx, expected_go_to_left):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = 1 * n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.bin_idx == expected_bin_idx\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_go_to_left\n    split_on_nan = split_info.bin_idx == n_bins_non_missing[0] - 1\n    assert split_on_nan == expected_split_on_nan\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    if not expected_split_on_nan:\n        assert set(samples_left) == set([0, 1, 2, 3])\n        assert set(samples_right) == set([4, 5, 6, 7, 8, 9])\n    else:\n        missing_samples_indices = np.flatnonzero(np.array(X_binned) == missing_values_bin_idx)\n        non_missing_samples_indices = np.flatnonzero(np.array(X_binned) != missing_values_bin_idx)\n        assert set(samples_right) == set(missing_samples_indices)\n        assert set(samples_left) == set(non_missing_samples_indices)"
        ]
    },
    {
        "func_name": "test_splitting_categorical_cat_smooth",
        "original": "@pytest.mark.parametrize('X_binned, has_missing_values, n_bins_non_missing, ', [([0] * 20, False, 1), ([0] * 9 + [1] * 8, False, 2), ([0] * 12 + [1] * 8, False, 2), ([0] * 9 + [1] * 8 + [9] * 4, True, 2), ([9] * 11, True, 0)])\ndef test_splitting_categorical_cat_smooth(X_binned, has_missing_values, n_bins_non_missing):\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    X_binned = np.array([X_binned], dtype=X_BINNED_DTYPE).T\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.ones(n_samples, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
        "mutated": [
            "@pytest.mark.parametrize('X_binned, has_missing_values, n_bins_non_missing, ', [([0] * 20, False, 1), ([0] * 9 + [1] * 8, False, 2), ([0] * 12 + [1] * 8, False, 2), ([0] * 9 + [1] * 8 + [9] * 4, True, 2), ([9] * 11, True, 0)])\ndef test_splitting_categorical_cat_smooth(X_binned, has_missing_values, n_bins_non_missing):\n    if False:\n        i = 10\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    X_binned = np.array([X_binned], dtype=X_BINNED_DTYPE).T\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.ones(n_samples, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
            "@pytest.mark.parametrize('X_binned, has_missing_values, n_bins_non_missing, ', [([0] * 20, False, 1), ([0] * 9 + [1] * 8, False, 2), ([0] * 12 + [1] * 8, False, 2), ([0] * 9 + [1] * 8 + [9] * 4, True, 2), ([9] * 11, True, 0)])\ndef test_splitting_categorical_cat_smooth(X_binned, has_missing_values, n_bins_non_missing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    X_binned = np.array([X_binned], dtype=X_BINNED_DTYPE).T\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.ones(n_samples, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
            "@pytest.mark.parametrize('X_binned, has_missing_values, n_bins_non_missing, ', [([0] * 20, False, 1), ([0] * 9 + [1] * 8, False, 2), ([0] * 12 + [1] * 8, False, 2), ([0] * 9 + [1] * 8 + [9] * 4, True, 2), ([9] * 11, True, 0)])\ndef test_splitting_categorical_cat_smooth(X_binned, has_missing_values, n_bins_non_missing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    X_binned = np.array([X_binned], dtype=X_BINNED_DTYPE).T\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.ones(n_samples, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
            "@pytest.mark.parametrize('X_binned, has_missing_values, n_bins_non_missing, ', [([0] * 20, False, 1), ([0] * 9 + [1] * 8, False, 2), ([0] * 12 + [1] * 8, False, 2), ([0] * 9 + [1] * 8 + [9] * 4, True, 2), ([9] * 11, True, 0)])\ndef test_splitting_categorical_cat_smooth(X_binned, has_missing_values, n_bins_non_missing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    X_binned = np.array([X_binned], dtype=X_BINNED_DTYPE).T\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.ones(n_samples, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1",
            "@pytest.mark.parametrize('X_binned, has_missing_values, n_bins_non_missing, ', [([0] * 20, False, 1), ([0] * 9 + [1] * 8, False, 2), ([0] * 12 + [1] * 8, False, 2), ([0] * 9 + [1] * 8 + [9] * 4, True, 2), ([9] * 11, True, 0)])\ndef test_splitting_categorical_cat_smooth(X_binned, has_missing_values, n_bins_non_missing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n_bins = max(X_binned) + 1\n    n_samples = len(X_binned)\n    X_binned = np.array([X_binned], dtype=X_BINNED_DTYPE).T\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.ones(n_samples, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.gain == -1"
        ]
    },
    {
        "func_name": "_assert_categories_equals_bitset",
        "original": "def _assert_categories_equals_bitset(categories, bitset):\n    expected_bitset = np.zeros(8, dtype=np.uint32)\n    for cat in categories:\n        idx = cat // 32\n        shift = cat % 32\n        expected_bitset[idx] |= 1 << shift\n    assert_array_equal(expected_bitset, bitset)",
        "mutated": [
            "def _assert_categories_equals_bitset(categories, bitset):\n    if False:\n        i = 10\n    expected_bitset = np.zeros(8, dtype=np.uint32)\n    for cat in categories:\n        idx = cat // 32\n        shift = cat % 32\n        expected_bitset[idx] |= 1 << shift\n    assert_array_equal(expected_bitset, bitset)",
            "def _assert_categories_equals_bitset(categories, bitset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    expected_bitset = np.zeros(8, dtype=np.uint32)\n    for cat in categories:\n        idx = cat // 32\n        shift = cat % 32\n        expected_bitset[idx] |= 1 << shift\n    assert_array_equal(expected_bitset, bitset)",
            "def _assert_categories_equals_bitset(categories, bitset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    expected_bitset = np.zeros(8, dtype=np.uint32)\n    for cat in categories:\n        idx = cat // 32\n        shift = cat % 32\n        expected_bitset[idx] |= 1 << shift\n    assert_array_equal(expected_bitset, bitset)",
            "def _assert_categories_equals_bitset(categories, bitset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    expected_bitset = np.zeros(8, dtype=np.uint32)\n    for cat in categories:\n        idx = cat // 32\n        shift = cat % 32\n        expected_bitset[idx] |= 1 << shift\n    assert_array_equal(expected_bitset, bitset)",
            "def _assert_categories_equals_bitset(categories, bitset):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    expected_bitset = np.zeros(8, dtype=np.uint32)\n    for cat in categories:\n        idx = cat // 32\n        shift = cat % 32\n        expected_bitset[idx] |= 1 << shift\n    assert_array_equal(expected_bitset, bitset)"
        ]
    },
    {
        "func_name": "test_splitting_categorical_sanity",
        "original": "@pytest.mark.parametrize('X_binned, all_gradients, expected_categories_left, n_bins_non_missing,missing_values_bin_idx, has_missing_values, expected_missing_go_to_left', [([0, 1, 2, 3] * 11, [10, 1, 10, 10] * 11, [1], 4, 4, False, None), ([0, 1, 2, 3] * 11, [10, 10, 10, 1] * 11, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [10] * 5, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [1] * 5, [3], 4, 4, False, None), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [10] * 11, [1], 3, 9, True, False), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [1] * 11, [1, 9], 3, 9, True, True), ([0, 1, 2, 3, 4] * 11 + [255] * 12, [10, 10, 10, 10, 10] * 11 + [1] * 12, [255], 5, 255, True, True), (list(range(60)) * 12, [10, 1] * 360, list(range(1, 60, 2)), 59, 59, True, True), (list(range(256)) * 12, [10, 10, 10, 10, 10, 10, 10, 1] * 384, list(range(7, 256, 8)), 255, 255, True, True)])\ndef test_splitting_categorical_sanity(X_binned, all_gradients, expected_categories_left, n_bins_non_missing, missing_values_bin_idx, has_missing_values, expected_missing_go_to_left):\n    n_samples = len(X_binned)\n    n_bins = max(X_binned) + 1\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.is_categorical\n    assert split_info.gain > 0\n    _assert_categories_equals_bitset(expected_categories_left, split_info.left_cat_bitset)\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_missing_go_to_left\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    left_mask = np.isin(X_binned.ravel(), expected_categories_left)\n    assert_array_equal(sample_indices[left_mask], samples_left)\n    assert_array_equal(sample_indices[~left_mask], samples_right)",
        "mutated": [
            "@pytest.mark.parametrize('X_binned, all_gradients, expected_categories_left, n_bins_non_missing,missing_values_bin_idx, has_missing_values, expected_missing_go_to_left', [([0, 1, 2, 3] * 11, [10, 1, 10, 10] * 11, [1], 4, 4, False, None), ([0, 1, 2, 3] * 11, [10, 10, 10, 1] * 11, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [10] * 5, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [1] * 5, [3], 4, 4, False, None), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [10] * 11, [1], 3, 9, True, False), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [1] * 11, [1, 9], 3, 9, True, True), ([0, 1, 2, 3, 4] * 11 + [255] * 12, [10, 10, 10, 10, 10] * 11 + [1] * 12, [255], 5, 255, True, True), (list(range(60)) * 12, [10, 1] * 360, list(range(1, 60, 2)), 59, 59, True, True), (list(range(256)) * 12, [10, 10, 10, 10, 10, 10, 10, 1] * 384, list(range(7, 256, 8)), 255, 255, True, True)])\ndef test_splitting_categorical_sanity(X_binned, all_gradients, expected_categories_left, n_bins_non_missing, missing_values_bin_idx, has_missing_values, expected_missing_go_to_left):\n    if False:\n        i = 10\n    n_samples = len(X_binned)\n    n_bins = max(X_binned) + 1\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.is_categorical\n    assert split_info.gain > 0\n    _assert_categories_equals_bitset(expected_categories_left, split_info.left_cat_bitset)\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_missing_go_to_left\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    left_mask = np.isin(X_binned.ravel(), expected_categories_left)\n    assert_array_equal(sample_indices[left_mask], samples_left)\n    assert_array_equal(sample_indices[~left_mask], samples_right)",
            "@pytest.mark.parametrize('X_binned, all_gradients, expected_categories_left, n_bins_non_missing,missing_values_bin_idx, has_missing_values, expected_missing_go_to_left', [([0, 1, 2, 3] * 11, [10, 1, 10, 10] * 11, [1], 4, 4, False, None), ([0, 1, 2, 3] * 11, [10, 10, 10, 1] * 11, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [10] * 5, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [1] * 5, [3], 4, 4, False, None), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [10] * 11, [1], 3, 9, True, False), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [1] * 11, [1, 9], 3, 9, True, True), ([0, 1, 2, 3, 4] * 11 + [255] * 12, [10, 10, 10, 10, 10] * 11 + [1] * 12, [255], 5, 255, True, True), (list(range(60)) * 12, [10, 1] * 360, list(range(1, 60, 2)), 59, 59, True, True), (list(range(256)) * 12, [10, 10, 10, 10, 10, 10, 10, 1] * 384, list(range(7, 256, 8)), 255, 255, True, True)])\ndef test_splitting_categorical_sanity(X_binned, all_gradients, expected_categories_left, n_bins_non_missing, missing_values_bin_idx, has_missing_values, expected_missing_go_to_left):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n_samples = len(X_binned)\n    n_bins = max(X_binned) + 1\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.is_categorical\n    assert split_info.gain > 0\n    _assert_categories_equals_bitset(expected_categories_left, split_info.left_cat_bitset)\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_missing_go_to_left\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    left_mask = np.isin(X_binned.ravel(), expected_categories_left)\n    assert_array_equal(sample_indices[left_mask], samples_left)\n    assert_array_equal(sample_indices[~left_mask], samples_right)",
            "@pytest.mark.parametrize('X_binned, all_gradients, expected_categories_left, n_bins_non_missing,missing_values_bin_idx, has_missing_values, expected_missing_go_to_left', [([0, 1, 2, 3] * 11, [10, 1, 10, 10] * 11, [1], 4, 4, False, None), ([0, 1, 2, 3] * 11, [10, 10, 10, 1] * 11, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [10] * 5, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [1] * 5, [3], 4, 4, False, None), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [10] * 11, [1], 3, 9, True, False), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [1] * 11, [1, 9], 3, 9, True, True), ([0, 1, 2, 3, 4] * 11 + [255] * 12, [10, 10, 10, 10, 10] * 11 + [1] * 12, [255], 5, 255, True, True), (list(range(60)) * 12, [10, 1] * 360, list(range(1, 60, 2)), 59, 59, True, True), (list(range(256)) * 12, [10, 10, 10, 10, 10, 10, 10, 1] * 384, list(range(7, 256, 8)), 255, 255, True, True)])\ndef test_splitting_categorical_sanity(X_binned, all_gradients, expected_categories_left, n_bins_non_missing, missing_values_bin_idx, has_missing_values, expected_missing_go_to_left):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n_samples = len(X_binned)\n    n_bins = max(X_binned) + 1\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.is_categorical\n    assert split_info.gain > 0\n    _assert_categories_equals_bitset(expected_categories_left, split_info.left_cat_bitset)\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_missing_go_to_left\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    left_mask = np.isin(X_binned.ravel(), expected_categories_left)\n    assert_array_equal(sample_indices[left_mask], samples_left)\n    assert_array_equal(sample_indices[~left_mask], samples_right)",
            "@pytest.mark.parametrize('X_binned, all_gradients, expected_categories_left, n_bins_non_missing,missing_values_bin_idx, has_missing_values, expected_missing_go_to_left', [([0, 1, 2, 3] * 11, [10, 1, 10, 10] * 11, [1], 4, 4, False, None), ([0, 1, 2, 3] * 11, [10, 10, 10, 1] * 11, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [10] * 5, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [1] * 5, [3], 4, 4, False, None), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [10] * 11, [1], 3, 9, True, False), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [1] * 11, [1, 9], 3, 9, True, True), ([0, 1, 2, 3, 4] * 11 + [255] * 12, [10, 10, 10, 10, 10] * 11 + [1] * 12, [255], 5, 255, True, True), (list(range(60)) * 12, [10, 1] * 360, list(range(1, 60, 2)), 59, 59, True, True), (list(range(256)) * 12, [10, 10, 10, 10, 10, 10, 10, 1] * 384, list(range(7, 256, 8)), 255, 255, True, True)])\ndef test_splitting_categorical_sanity(X_binned, all_gradients, expected_categories_left, n_bins_non_missing, missing_values_bin_idx, has_missing_values, expected_missing_go_to_left):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n_samples = len(X_binned)\n    n_bins = max(X_binned) + 1\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.is_categorical\n    assert split_info.gain > 0\n    _assert_categories_equals_bitset(expected_categories_left, split_info.left_cat_bitset)\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_missing_go_to_left\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    left_mask = np.isin(X_binned.ravel(), expected_categories_left)\n    assert_array_equal(sample_indices[left_mask], samples_left)\n    assert_array_equal(sample_indices[~left_mask], samples_right)",
            "@pytest.mark.parametrize('X_binned, all_gradients, expected_categories_left, n_bins_non_missing,missing_values_bin_idx, has_missing_values, expected_missing_go_to_left', [([0, 1, 2, 3] * 11, [10, 1, 10, 10] * 11, [1], 4, 4, False, None), ([0, 1, 2, 3] * 11, [10, 10, 10, 1] * 11, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [10] * 5, [3], 4, 4, False, None), ([0, 1, 2, 3] * 11 + [4] * 5, [10, 10, 10, 1] * 11 + [1] * 5, [3], 4, 4, False, None), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [10] * 11, [1], 3, 9, True, False), ([0, 1, 2] * 11 + [9] * 11, [10, 1, 10] * 11 + [1] * 11, [1, 9], 3, 9, True, True), ([0, 1, 2, 3, 4] * 11 + [255] * 12, [10, 10, 10, 10, 10] * 11 + [1] * 12, [255], 5, 255, True, True), (list(range(60)) * 12, [10, 1] * 360, list(range(1, 60, 2)), 59, 59, True, True), (list(range(256)) * 12, [10, 10, 10, 10, 10, 10, 10, 1] * 384, list(range(7, 256, 8)), 255, 255, True, True)])\ndef test_splitting_categorical_sanity(X_binned, all_gradients, expected_categories_left, n_bins_non_missing, missing_values_bin_idx, has_missing_values, expected_missing_go_to_left):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n_samples = len(X_binned)\n    n_bins = max(X_binned) + 1\n    X_binned = np.array(X_binned, dtype=X_BINNED_DTYPE).reshape(-1, 1)\n    X_binned = np.asfortranarray(X_binned)\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = np.array(all_gradients, dtype=G_H_DTYPE)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    has_missing_values = np.array([has_missing_values], dtype=np.uint8)\n    sum_gradients = all_gradients.sum()\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    n_bins_non_missing = np.array([n_bins_non_missing], dtype=np.uint32)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.ones_like(monotonic_cst, dtype=np.uint8)\n    splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    split_info = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value)\n    assert split_info.is_categorical\n    assert split_info.gain > 0\n    _assert_categories_equals_bitset(expected_categories_left, split_info.left_cat_bitset)\n    if has_missing_values:\n        assert split_info.missing_go_to_left == expected_missing_go_to_left\n    (samples_left, samples_right, _) = splitter.split_indices(split_info, splitter.partition)\n    left_mask = np.isin(X_binned.ravel(), expected_categories_left)\n    assert_array_equal(sample_indices[left_mask], samples_left)\n    assert_array_equal(sample_indices[~left_mask], samples_right)"
        ]
    },
    {
        "func_name": "test_split_interaction_constraints",
        "original": "def test_split_interaction_constraints():\n    \"\"\"Check that allowed_features are respected.\"\"\"\n    n_features = 4\n    allowed_features = np.array([0, 3], dtype=np.uint32)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    split_features = []\n    for i in range(10):\n        rng = np.random.RandomState(919 + i)\n        X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n        X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n        all_gradients = (10 * X_binned[:, 1] + rng.randn(n_samples)).astype(G_H_DTYPE)\n        sum_gradients = all_gradients.sum()\n        builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n        n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n        has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n        monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n        is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n        missing_values_bin_idx = n_bins - 1\n        splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n        assert np.all(sample_indices == splitter.partition)\n        histograms = builder.compute_histograms_brute(sample_indices)\n        value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=None)\n        assert si_root.feature_idx == 1\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features.append(si_root.feature_idx)\n        assert si_root.feature_idx in allowed_features\n    assert set(allowed_features) == set(split_features)",
        "mutated": [
            "def test_split_interaction_constraints():\n    if False:\n        i = 10\n    'Check that allowed_features are respected.'\n    n_features = 4\n    allowed_features = np.array([0, 3], dtype=np.uint32)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    split_features = []\n    for i in range(10):\n        rng = np.random.RandomState(919 + i)\n        X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n        X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n        all_gradients = (10 * X_binned[:, 1] + rng.randn(n_samples)).astype(G_H_DTYPE)\n        sum_gradients = all_gradients.sum()\n        builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n        n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n        has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n        monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n        is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n        missing_values_bin_idx = n_bins - 1\n        splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n        assert np.all(sample_indices == splitter.partition)\n        histograms = builder.compute_histograms_brute(sample_indices)\n        value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=None)\n        assert si_root.feature_idx == 1\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features.append(si_root.feature_idx)\n        assert si_root.feature_idx in allowed_features\n    assert set(allowed_features) == set(split_features)",
            "def test_split_interaction_constraints():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Check that allowed_features are respected.'\n    n_features = 4\n    allowed_features = np.array([0, 3], dtype=np.uint32)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    split_features = []\n    for i in range(10):\n        rng = np.random.RandomState(919 + i)\n        X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n        X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n        all_gradients = (10 * X_binned[:, 1] + rng.randn(n_samples)).astype(G_H_DTYPE)\n        sum_gradients = all_gradients.sum()\n        builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n        n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n        has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n        monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n        is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n        missing_values_bin_idx = n_bins - 1\n        splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n        assert np.all(sample_indices == splitter.partition)\n        histograms = builder.compute_histograms_brute(sample_indices)\n        value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=None)\n        assert si_root.feature_idx == 1\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features.append(si_root.feature_idx)\n        assert si_root.feature_idx in allowed_features\n    assert set(allowed_features) == set(split_features)",
            "def test_split_interaction_constraints():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Check that allowed_features are respected.'\n    n_features = 4\n    allowed_features = np.array([0, 3], dtype=np.uint32)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    split_features = []\n    for i in range(10):\n        rng = np.random.RandomState(919 + i)\n        X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n        X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n        all_gradients = (10 * X_binned[:, 1] + rng.randn(n_samples)).astype(G_H_DTYPE)\n        sum_gradients = all_gradients.sum()\n        builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n        n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n        has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n        monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n        is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n        missing_values_bin_idx = n_bins - 1\n        splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n        assert np.all(sample_indices == splitter.partition)\n        histograms = builder.compute_histograms_brute(sample_indices)\n        value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=None)\n        assert si_root.feature_idx == 1\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features.append(si_root.feature_idx)\n        assert si_root.feature_idx in allowed_features\n    assert set(allowed_features) == set(split_features)",
            "def test_split_interaction_constraints():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Check that allowed_features are respected.'\n    n_features = 4\n    allowed_features = np.array([0, 3], dtype=np.uint32)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    split_features = []\n    for i in range(10):\n        rng = np.random.RandomState(919 + i)\n        X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n        X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n        all_gradients = (10 * X_binned[:, 1] + rng.randn(n_samples)).astype(G_H_DTYPE)\n        sum_gradients = all_gradients.sum()\n        builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n        n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n        has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n        monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n        is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n        missing_values_bin_idx = n_bins - 1\n        splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n        assert np.all(sample_indices == splitter.partition)\n        histograms = builder.compute_histograms_brute(sample_indices)\n        value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=None)\n        assert si_root.feature_idx == 1\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features.append(si_root.feature_idx)\n        assert si_root.feature_idx in allowed_features\n    assert set(allowed_features) == set(split_features)",
            "def test_split_interaction_constraints():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Check that allowed_features are respected.'\n    n_features = 4\n    allowed_features = np.array([0, 3], dtype=np.uint32)\n    n_bins = 5\n    n_samples = 10\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    split_features = []\n    for i in range(10):\n        rng = np.random.RandomState(919 + i)\n        X_binned = np.asfortranarray(rng.randint(0, n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n        X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n        all_gradients = (10 * X_binned[:, 1] + rng.randn(n_samples)).astype(G_H_DTYPE)\n        sum_gradients = all_gradients.sum()\n        builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n        n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n        has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n        monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n        is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n        missing_values_bin_idx = n_bins - 1\n        splitter = Splitter(X_binned, n_bins_non_missing, missing_values_bin_idx, has_missing_values, is_categorical, monotonic_cst, l2_regularization, min_hessian_to_split, min_samples_leaf, min_gain_to_split, hessians_are_constant)\n        assert np.all(sample_indices == splitter.partition)\n        histograms = builder.compute_histograms_brute(sample_indices)\n        value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=None)\n        assert si_root.feature_idx == 1\n        si_root = splitter.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features.append(si_root.feature_idx)\n        assert si_root.feature_idx in allowed_features\n    assert set(allowed_features) == set(split_features)"
        ]
    },
    {
        "func_name": "test_split_feature_fraction_per_split",
        "original": "@pytest.mark.parametrize('forbidden_features', [set(), {1, 3}])\ndef test_split_feature_fraction_per_split(forbidden_features):\n    \"\"\"Check that feature_fraction_per_split is respected.\n\n    Because we set `n_features = 4` and `feature_fraction_per_split = 0.25`, it means\n    that calling `splitter.find_node_split` will be allowed to select a split for a\n    single completely random feature at each call. So if we iterate enough, we should\n    cover all the allowed features, irrespective of the values of the gradients and\n    Hessians of the objective.\n    \"\"\"\n    n_features = 4\n    allowed_features = np.array(list(set(range(n_features)) - forbidden_features), dtype=np.uint32)\n    n_bins = 5\n    n_samples = 40\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    rng = np.random.default_rng(42)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.uniform(low=0.5, high=1, size=n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    X_binned = np.asfortranarray(rng.integers(low=0, high=n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    params = dict(X_binned=X_binned, n_bins_non_missing=n_bins_non_missing, missing_values_bin_idx=missing_values_bin_idx, has_missing_values=has_missing_values, is_categorical=is_categorical, monotonic_cst=monotonic_cst, l2_regularization=l2_regularization, min_hessian_to_split=min_hessian_to_split, min_samples_leaf=min_samples_leaf, min_gain_to_split=min_gain_to_split, hessians_are_constant=hessians_are_constant, rng=rng)\n    splitter_subsample = Splitter(feature_fraction_per_split=0.25, **params)\n    splitter_all_features = Splitter(feature_fraction_per_split=1.0, **params)\n    assert np.all(sample_indices == splitter_subsample.partition)\n    split_features_subsample = []\n    split_features_all = []\n    for i in range(20):\n        si_root = splitter_subsample.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_subsample.append(si_root.feature_idx)\n        si_root = splitter_all_features.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_all.append(si_root.feature_idx)\n    assert set(split_features_subsample) == set(allowed_features)\n    assert len(set(split_features_all)) == 1",
        "mutated": [
            "@pytest.mark.parametrize('forbidden_features', [set(), {1, 3}])\ndef test_split_feature_fraction_per_split(forbidden_features):\n    if False:\n        i = 10\n    'Check that feature_fraction_per_split is respected.\\n\\n    Because we set `n_features = 4` and `feature_fraction_per_split = 0.25`, it means\\n    that calling `splitter.find_node_split` will be allowed to select a split for a\\n    single completely random feature at each call. So if we iterate enough, we should\\n    cover all the allowed features, irrespective of the values of the gradients and\\n    Hessians of the objective.\\n    '\n    n_features = 4\n    allowed_features = np.array(list(set(range(n_features)) - forbidden_features), dtype=np.uint32)\n    n_bins = 5\n    n_samples = 40\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    rng = np.random.default_rng(42)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.uniform(low=0.5, high=1, size=n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    X_binned = np.asfortranarray(rng.integers(low=0, high=n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    params = dict(X_binned=X_binned, n_bins_non_missing=n_bins_non_missing, missing_values_bin_idx=missing_values_bin_idx, has_missing_values=has_missing_values, is_categorical=is_categorical, monotonic_cst=monotonic_cst, l2_regularization=l2_regularization, min_hessian_to_split=min_hessian_to_split, min_samples_leaf=min_samples_leaf, min_gain_to_split=min_gain_to_split, hessians_are_constant=hessians_are_constant, rng=rng)\n    splitter_subsample = Splitter(feature_fraction_per_split=0.25, **params)\n    splitter_all_features = Splitter(feature_fraction_per_split=1.0, **params)\n    assert np.all(sample_indices == splitter_subsample.partition)\n    split_features_subsample = []\n    split_features_all = []\n    for i in range(20):\n        si_root = splitter_subsample.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_subsample.append(si_root.feature_idx)\n        si_root = splitter_all_features.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_all.append(si_root.feature_idx)\n    assert set(split_features_subsample) == set(allowed_features)\n    assert len(set(split_features_all)) == 1",
            "@pytest.mark.parametrize('forbidden_features', [set(), {1, 3}])\ndef test_split_feature_fraction_per_split(forbidden_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Check that feature_fraction_per_split is respected.\\n\\n    Because we set `n_features = 4` and `feature_fraction_per_split = 0.25`, it means\\n    that calling `splitter.find_node_split` will be allowed to select a split for a\\n    single completely random feature at each call. So if we iterate enough, we should\\n    cover all the allowed features, irrespective of the values of the gradients and\\n    Hessians of the objective.\\n    '\n    n_features = 4\n    allowed_features = np.array(list(set(range(n_features)) - forbidden_features), dtype=np.uint32)\n    n_bins = 5\n    n_samples = 40\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    rng = np.random.default_rng(42)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.uniform(low=0.5, high=1, size=n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    X_binned = np.asfortranarray(rng.integers(low=0, high=n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    params = dict(X_binned=X_binned, n_bins_non_missing=n_bins_non_missing, missing_values_bin_idx=missing_values_bin_idx, has_missing_values=has_missing_values, is_categorical=is_categorical, monotonic_cst=monotonic_cst, l2_regularization=l2_regularization, min_hessian_to_split=min_hessian_to_split, min_samples_leaf=min_samples_leaf, min_gain_to_split=min_gain_to_split, hessians_are_constant=hessians_are_constant, rng=rng)\n    splitter_subsample = Splitter(feature_fraction_per_split=0.25, **params)\n    splitter_all_features = Splitter(feature_fraction_per_split=1.0, **params)\n    assert np.all(sample_indices == splitter_subsample.partition)\n    split_features_subsample = []\n    split_features_all = []\n    for i in range(20):\n        si_root = splitter_subsample.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_subsample.append(si_root.feature_idx)\n        si_root = splitter_all_features.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_all.append(si_root.feature_idx)\n    assert set(split_features_subsample) == set(allowed_features)\n    assert len(set(split_features_all)) == 1",
            "@pytest.mark.parametrize('forbidden_features', [set(), {1, 3}])\ndef test_split_feature_fraction_per_split(forbidden_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Check that feature_fraction_per_split is respected.\\n\\n    Because we set `n_features = 4` and `feature_fraction_per_split = 0.25`, it means\\n    that calling `splitter.find_node_split` will be allowed to select a split for a\\n    single completely random feature at each call. So if we iterate enough, we should\\n    cover all the allowed features, irrespective of the values of the gradients and\\n    Hessians of the objective.\\n    '\n    n_features = 4\n    allowed_features = np.array(list(set(range(n_features)) - forbidden_features), dtype=np.uint32)\n    n_bins = 5\n    n_samples = 40\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    rng = np.random.default_rng(42)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.uniform(low=0.5, high=1, size=n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    X_binned = np.asfortranarray(rng.integers(low=0, high=n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    params = dict(X_binned=X_binned, n_bins_non_missing=n_bins_non_missing, missing_values_bin_idx=missing_values_bin_idx, has_missing_values=has_missing_values, is_categorical=is_categorical, monotonic_cst=monotonic_cst, l2_regularization=l2_regularization, min_hessian_to_split=min_hessian_to_split, min_samples_leaf=min_samples_leaf, min_gain_to_split=min_gain_to_split, hessians_are_constant=hessians_are_constant, rng=rng)\n    splitter_subsample = Splitter(feature_fraction_per_split=0.25, **params)\n    splitter_all_features = Splitter(feature_fraction_per_split=1.0, **params)\n    assert np.all(sample_indices == splitter_subsample.partition)\n    split_features_subsample = []\n    split_features_all = []\n    for i in range(20):\n        si_root = splitter_subsample.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_subsample.append(si_root.feature_idx)\n        si_root = splitter_all_features.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_all.append(si_root.feature_idx)\n    assert set(split_features_subsample) == set(allowed_features)\n    assert len(set(split_features_all)) == 1",
            "@pytest.mark.parametrize('forbidden_features', [set(), {1, 3}])\ndef test_split_feature_fraction_per_split(forbidden_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Check that feature_fraction_per_split is respected.\\n\\n    Because we set `n_features = 4` and `feature_fraction_per_split = 0.25`, it means\\n    that calling `splitter.find_node_split` will be allowed to select a split for a\\n    single completely random feature at each call. So if we iterate enough, we should\\n    cover all the allowed features, irrespective of the values of the gradients and\\n    Hessians of the objective.\\n    '\n    n_features = 4\n    allowed_features = np.array(list(set(range(n_features)) - forbidden_features), dtype=np.uint32)\n    n_bins = 5\n    n_samples = 40\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    rng = np.random.default_rng(42)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.uniform(low=0.5, high=1, size=n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    X_binned = np.asfortranarray(rng.integers(low=0, high=n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    params = dict(X_binned=X_binned, n_bins_non_missing=n_bins_non_missing, missing_values_bin_idx=missing_values_bin_idx, has_missing_values=has_missing_values, is_categorical=is_categorical, monotonic_cst=monotonic_cst, l2_regularization=l2_regularization, min_hessian_to_split=min_hessian_to_split, min_samples_leaf=min_samples_leaf, min_gain_to_split=min_gain_to_split, hessians_are_constant=hessians_are_constant, rng=rng)\n    splitter_subsample = Splitter(feature_fraction_per_split=0.25, **params)\n    splitter_all_features = Splitter(feature_fraction_per_split=1.0, **params)\n    assert np.all(sample_indices == splitter_subsample.partition)\n    split_features_subsample = []\n    split_features_all = []\n    for i in range(20):\n        si_root = splitter_subsample.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_subsample.append(si_root.feature_idx)\n        si_root = splitter_all_features.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_all.append(si_root.feature_idx)\n    assert set(split_features_subsample) == set(allowed_features)\n    assert len(set(split_features_all)) == 1",
            "@pytest.mark.parametrize('forbidden_features', [set(), {1, 3}])\ndef test_split_feature_fraction_per_split(forbidden_features):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Check that feature_fraction_per_split is respected.\\n\\n    Because we set `n_features = 4` and `feature_fraction_per_split = 0.25`, it means\\n    that calling `splitter.find_node_split` will be allowed to select a split for a\\n    single completely random feature at each call. So if we iterate enough, we should\\n    cover all the allowed features, irrespective of the values of the gradients and\\n    Hessians of the objective.\\n    '\n    n_features = 4\n    allowed_features = np.array(list(set(range(n_features)) - forbidden_features), dtype=np.uint32)\n    n_bins = 5\n    n_samples = 40\n    l2_regularization = 0.0\n    min_hessian_to_split = 0.001\n    min_samples_leaf = 1\n    min_gain_to_split = 0.0\n    rng = np.random.default_rng(42)\n    sample_indices = np.arange(n_samples, dtype=np.uint32)\n    all_gradients = rng.uniform(low=0.5, high=1, size=n_samples).astype(G_H_DTYPE)\n    sum_gradients = all_gradients.sum()\n    all_hessians = np.ones(1, dtype=G_H_DTYPE)\n    sum_hessians = n_samples\n    hessians_are_constant = True\n    X_binned = np.asfortranarray(rng.integers(low=0, high=n_bins - 1, size=(n_samples, n_features)), dtype=X_BINNED_DTYPE)\n    X_binned = np.asfortranarray(X_binned, dtype=X_BINNED_DTYPE)\n    builder = HistogramBuilder(X_binned, n_bins, all_gradients, all_hessians, hessians_are_constant, n_threads)\n    histograms = builder.compute_histograms_brute(sample_indices)\n    value = compute_node_value(sum_gradients, sum_hessians, -np.inf, np.inf, l2_regularization)\n    n_bins_non_missing = np.array([n_bins] * X_binned.shape[1], dtype=np.uint32)\n    has_missing_values = np.array([False] * X_binned.shape[1], dtype=np.uint8)\n    monotonic_cst = np.array([MonotonicConstraint.NO_CST] * X_binned.shape[1], dtype=np.int8)\n    is_categorical = np.zeros_like(monotonic_cst, dtype=np.uint8)\n    missing_values_bin_idx = n_bins - 1\n    params = dict(X_binned=X_binned, n_bins_non_missing=n_bins_non_missing, missing_values_bin_idx=missing_values_bin_idx, has_missing_values=has_missing_values, is_categorical=is_categorical, monotonic_cst=monotonic_cst, l2_regularization=l2_regularization, min_hessian_to_split=min_hessian_to_split, min_samples_leaf=min_samples_leaf, min_gain_to_split=min_gain_to_split, hessians_are_constant=hessians_are_constant, rng=rng)\n    splitter_subsample = Splitter(feature_fraction_per_split=0.25, **params)\n    splitter_all_features = Splitter(feature_fraction_per_split=1.0, **params)\n    assert np.all(sample_indices == splitter_subsample.partition)\n    split_features_subsample = []\n    split_features_all = []\n    for i in range(20):\n        si_root = splitter_subsample.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_subsample.append(si_root.feature_idx)\n        si_root = splitter_all_features.find_node_split(n_samples, histograms, sum_gradients, sum_hessians, value, allowed_features=allowed_features)\n        split_features_all.append(si_root.feature_idx)\n    assert set(split_features_subsample) == set(allowed_features)\n    assert len(set(split_features_all)) == 1"
        ]
    }
]