[
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_classes, in_channels, train_cfg, test_cfg, feat_channels=256, use_direction_classifier=True, anchor_generator=dict(type='Anchor3DRangeGenerator', range=[0, -39.68, -1.78, 69.12, 39.68, -1.78], strides=[2], sizes=[[3.9, 1.6, 1.56]], rotations=[0, 1.57], custom_values=[], reshape_out=False), assigner_per_size=False, assign_per_class=False, diff_rad_by_sin=True, dir_offset=-np.pi / 2, dir_limit_offset=0, bbox_coder=dict(type='DeltaXYZWLHRBBoxCoder'), loss_cls=dict(type='CrossEntropyLoss', use_sigmoid=True, loss_weight=1.0), loss_bbox=dict(type='SmoothL1Loss', beta=1.0 / 9.0, loss_weight=2.0), loss_dir=dict(type='CrossEntropyLoss', loss_weight=0.2), init_cfg=None):\n    super().__init__(num_classes, in_channels, train_cfg, test_cfg, feat_channels, use_direction_classifier, anchor_generator, assigner_per_size, assign_per_class, diff_rad_by_sin, dir_offset, dir_limit_offset, bbox_coder, loss_cls, loss_bbox, loss_dir, init_cfg)",
        "mutated": [
            "def __init__(self, num_classes, in_channels, train_cfg, test_cfg, feat_channels=256, use_direction_classifier=True, anchor_generator=dict(type='Anchor3DRangeGenerator', range=[0, -39.68, -1.78, 69.12, 39.68, -1.78], strides=[2], sizes=[[3.9, 1.6, 1.56]], rotations=[0, 1.57], custom_values=[], reshape_out=False), assigner_per_size=False, assign_per_class=False, diff_rad_by_sin=True, dir_offset=-np.pi / 2, dir_limit_offset=0, bbox_coder=dict(type='DeltaXYZWLHRBBoxCoder'), loss_cls=dict(type='CrossEntropyLoss', use_sigmoid=True, loss_weight=1.0), loss_bbox=dict(type='SmoothL1Loss', beta=1.0 / 9.0, loss_weight=2.0), loss_dir=dict(type='CrossEntropyLoss', loss_weight=0.2), init_cfg=None):\n    if False:\n        i = 10\n    super().__init__(num_classes, in_channels, train_cfg, test_cfg, feat_channels, use_direction_classifier, anchor_generator, assigner_per_size, assign_per_class, diff_rad_by_sin, dir_offset, dir_limit_offset, bbox_coder, loss_cls, loss_bbox, loss_dir, init_cfg)",
            "def __init__(self, num_classes, in_channels, train_cfg, test_cfg, feat_channels=256, use_direction_classifier=True, anchor_generator=dict(type='Anchor3DRangeGenerator', range=[0, -39.68, -1.78, 69.12, 39.68, -1.78], strides=[2], sizes=[[3.9, 1.6, 1.56]], rotations=[0, 1.57], custom_values=[], reshape_out=False), assigner_per_size=False, assign_per_class=False, diff_rad_by_sin=True, dir_offset=-np.pi / 2, dir_limit_offset=0, bbox_coder=dict(type='DeltaXYZWLHRBBoxCoder'), loss_cls=dict(type='CrossEntropyLoss', use_sigmoid=True, loss_weight=1.0), loss_bbox=dict(type='SmoothL1Loss', beta=1.0 / 9.0, loss_weight=2.0), loss_dir=dict(type='CrossEntropyLoss', loss_weight=0.2), init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__(num_classes, in_channels, train_cfg, test_cfg, feat_channels, use_direction_classifier, anchor_generator, assigner_per_size, assign_per_class, diff_rad_by_sin, dir_offset, dir_limit_offset, bbox_coder, loss_cls, loss_bbox, loss_dir, init_cfg)",
            "def __init__(self, num_classes, in_channels, train_cfg, test_cfg, feat_channels=256, use_direction_classifier=True, anchor_generator=dict(type='Anchor3DRangeGenerator', range=[0, -39.68, -1.78, 69.12, 39.68, -1.78], strides=[2], sizes=[[3.9, 1.6, 1.56]], rotations=[0, 1.57], custom_values=[], reshape_out=False), assigner_per_size=False, assign_per_class=False, diff_rad_by_sin=True, dir_offset=-np.pi / 2, dir_limit_offset=0, bbox_coder=dict(type='DeltaXYZWLHRBBoxCoder'), loss_cls=dict(type='CrossEntropyLoss', use_sigmoid=True, loss_weight=1.0), loss_bbox=dict(type='SmoothL1Loss', beta=1.0 / 9.0, loss_weight=2.0), loss_dir=dict(type='CrossEntropyLoss', loss_weight=0.2), init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__(num_classes, in_channels, train_cfg, test_cfg, feat_channels, use_direction_classifier, anchor_generator, assigner_per_size, assign_per_class, diff_rad_by_sin, dir_offset, dir_limit_offset, bbox_coder, loss_cls, loss_bbox, loss_dir, init_cfg)",
            "def __init__(self, num_classes, in_channels, train_cfg, test_cfg, feat_channels=256, use_direction_classifier=True, anchor_generator=dict(type='Anchor3DRangeGenerator', range=[0, -39.68, -1.78, 69.12, 39.68, -1.78], strides=[2], sizes=[[3.9, 1.6, 1.56]], rotations=[0, 1.57], custom_values=[], reshape_out=False), assigner_per_size=False, assign_per_class=False, diff_rad_by_sin=True, dir_offset=-np.pi / 2, dir_limit_offset=0, bbox_coder=dict(type='DeltaXYZWLHRBBoxCoder'), loss_cls=dict(type='CrossEntropyLoss', use_sigmoid=True, loss_weight=1.0), loss_bbox=dict(type='SmoothL1Loss', beta=1.0 / 9.0, loss_weight=2.0), loss_dir=dict(type='CrossEntropyLoss', loss_weight=0.2), init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__(num_classes, in_channels, train_cfg, test_cfg, feat_channels, use_direction_classifier, anchor_generator, assigner_per_size, assign_per_class, diff_rad_by_sin, dir_offset, dir_limit_offset, bbox_coder, loss_cls, loss_bbox, loss_dir, init_cfg)",
            "def __init__(self, num_classes, in_channels, train_cfg, test_cfg, feat_channels=256, use_direction_classifier=True, anchor_generator=dict(type='Anchor3DRangeGenerator', range=[0, -39.68, -1.78, 69.12, 39.68, -1.78], strides=[2], sizes=[[3.9, 1.6, 1.56]], rotations=[0, 1.57], custom_values=[], reshape_out=False), assigner_per_size=False, assign_per_class=False, diff_rad_by_sin=True, dir_offset=-np.pi / 2, dir_limit_offset=0, bbox_coder=dict(type='DeltaXYZWLHRBBoxCoder'), loss_cls=dict(type='CrossEntropyLoss', use_sigmoid=True, loss_weight=1.0), loss_bbox=dict(type='SmoothL1Loss', beta=1.0 / 9.0, loss_weight=2.0), loss_dir=dict(type='CrossEntropyLoss', loss_weight=0.2), init_cfg=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__(num_classes, in_channels, train_cfg, test_cfg, feat_channels, use_direction_classifier, anchor_generator, assigner_per_size, assign_per_class, diff_rad_by_sin, dir_offset, dir_limit_offset, bbox_coder, loss_cls, loss_bbox, loss_dir, init_cfg)"
        ]
    },
    {
        "func_name": "loss",
        "original": "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    \"\"\"Calculate losses.\n\n        Args:\n            cls_scores (list[torch.Tensor]): Multi-level class scores.\n            bbox_preds (list[torch.Tensor]): Multi-level bbox predictions.\n            dir_cls_preds (list[torch.Tensor]): Multi-level direction\n                class predictions.\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes\n                of each sample.\n            gt_labels (list[torch.Tensor]): Labels of each sample.\n            input_metas (list[dict]): Point cloud and image's meta info.\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\n                which bounding.\n\n        Returns:\n            dict[str, list[torch.Tensor]]: Classification, bbox, and\n                direction losses of each level.\n\n                - loss_rpn_cls (list[torch.Tensor]): Classification losses.\n                - loss_rpn_bbox (list[torch.Tensor]): Box regression losses.\n                - loss_rpn_dir (list[torch.Tensor]): Direction classification\n                    losses.\n        \"\"\"\n    loss_dict = super().loss(cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore)\n    return dict(loss_rpn_cls=loss_dict['loss_cls'], loss_rpn_bbox=loss_dict['loss_bbox'], loss_rpn_dir=loss_dict['loss_dir'])",
        "mutated": [
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n    \"Calculate losses.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Multi-level class scores.\\n            bbox_preds (list[torch.Tensor]): Multi-level bbox predictions.\\n            dir_cls_preds (list[torch.Tensor]): Multi-level direction\\n                class predictions.\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes\\n                of each sample.\\n            gt_labels (list[torch.Tensor]): Labels of each sample.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict[str, list[torch.Tensor]]: Classification, bbox, and\\n                direction losses of each level.\\n\\n                - loss_rpn_cls (list[torch.Tensor]): Classification losses.\\n                - loss_rpn_bbox (list[torch.Tensor]): Box regression losses.\\n                - loss_rpn_dir (list[torch.Tensor]): Direction classification\\n                    losses.\\n        \"\n    loss_dict = super().loss(cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore)\n    return dict(loss_rpn_cls=loss_dict['loss_cls'], loss_rpn_bbox=loss_dict['loss_bbox'], loss_rpn_dir=loss_dict['loss_dir'])",
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Calculate losses.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Multi-level class scores.\\n            bbox_preds (list[torch.Tensor]): Multi-level bbox predictions.\\n            dir_cls_preds (list[torch.Tensor]): Multi-level direction\\n                class predictions.\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes\\n                of each sample.\\n            gt_labels (list[torch.Tensor]): Labels of each sample.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict[str, list[torch.Tensor]]: Classification, bbox, and\\n                direction losses of each level.\\n\\n                - loss_rpn_cls (list[torch.Tensor]): Classification losses.\\n                - loss_rpn_bbox (list[torch.Tensor]): Box regression losses.\\n                - loss_rpn_dir (list[torch.Tensor]): Direction classification\\n                    losses.\\n        \"\n    loss_dict = super().loss(cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore)\n    return dict(loss_rpn_cls=loss_dict['loss_cls'], loss_rpn_bbox=loss_dict['loss_bbox'], loss_rpn_dir=loss_dict['loss_dir'])",
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Calculate losses.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Multi-level class scores.\\n            bbox_preds (list[torch.Tensor]): Multi-level bbox predictions.\\n            dir_cls_preds (list[torch.Tensor]): Multi-level direction\\n                class predictions.\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes\\n                of each sample.\\n            gt_labels (list[torch.Tensor]): Labels of each sample.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict[str, list[torch.Tensor]]: Classification, bbox, and\\n                direction losses of each level.\\n\\n                - loss_rpn_cls (list[torch.Tensor]): Classification losses.\\n                - loss_rpn_bbox (list[torch.Tensor]): Box regression losses.\\n                - loss_rpn_dir (list[torch.Tensor]): Direction classification\\n                    losses.\\n        \"\n    loss_dict = super().loss(cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore)\n    return dict(loss_rpn_cls=loss_dict['loss_cls'], loss_rpn_bbox=loss_dict['loss_bbox'], loss_rpn_dir=loss_dict['loss_dir'])",
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Calculate losses.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Multi-level class scores.\\n            bbox_preds (list[torch.Tensor]): Multi-level bbox predictions.\\n            dir_cls_preds (list[torch.Tensor]): Multi-level direction\\n                class predictions.\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes\\n                of each sample.\\n            gt_labels (list[torch.Tensor]): Labels of each sample.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict[str, list[torch.Tensor]]: Classification, bbox, and\\n                direction losses of each level.\\n\\n                - loss_rpn_cls (list[torch.Tensor]): Classification losses.\\n                - loss_rpn_bbox (list[torch.Tensor]): Box regression losses.\\n                - loss_rpn_dir (list[torch.Tensor]): Direction classification\\n                    losses.\\n        \"\n    loss_dict = super().loss(cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore)\n    return dict(loss_rpn_cls=loss_dict['loss_cls'], loss_rpn_bbox=loss_dict['loss_bbox'], loss_rpn_dir=loss_dict['loss_dir'])",
            "@force_fp32(apply_to=('cls_scores', 'bbox_preds', 'dir_cls_preds'))\ndef loss(self, cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Calculate losses.\\n\\n        Args:\\n            cls_scores (list[torch.Tensor]): Multi-level class scores.\\n            bbox_preds (list[torch.Tensor]): Multi-level bbox predictions.\\n            dir_cls_preds (list[torch.Tensor]): Multi-level direction\\n                class predictions.\\n            gt_bboxes (list[:obj:`BaseInstance3DBoxes`]): Ground truth boxes\\n                of each sample.\\n            gt_labels (list[torch.Tensor]): Labels of each sample.\\n            input_metas (list[dict]): Point cloud and image's meta info.\\n            gt_bboxes_ignore (list[torch.Tensor]): Specify\\n                which bounding.\\n\\n        Returns:\\n            dict[str, list[torch.Tensor]]: Classification, bbox, and\\n                direction losses of each level.\\n\\n                - loss_rpn_cls (list[torch.Tensor]): Classification losses.\\n                - loss_rpn_bbox (list[torch.Tensor]): Box regression losses.\\n                - loss_rpn_dir (list[torch.Tensor]): Direction classification\\n                    losses.\\n        \"\n    loss_dict = super().loss(cls_scores, bbox_preds, dir_cls_preds, gt_bboxes, gt_labels, input_metas, gt_bboxes_ignore)\n    return dict(loss_rpn_cls=loss_dict['loss_cls'], loss_rpn_bbox=loss_dict['loss_bbox'], loss_rpn_dir=loss_dict['loss_dir'])"
        ]
    },
    {
        "func_name": "get_bboxes_single",
        "original": "def get_bboxes_single(self, cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors, input_meta, cfg, rescale=False):\n    \"\"\"Get bboxes of single branch.\n\n        Args:\n            cls_scores (torch.Tensor): Class score in single batch.\n            bbox_preds (torch.Tensor): Bbox prediction in single batch.\n            dir_cls_preds (torch.Tensor): Predictions of direction class\n                in single batch.\n            mlvl_anchors (List[torch.Tensor]): Multi-level anchors\n                in single batch.\n            input_meta (list[dict]): Contain pcd and img's meta info.\n            cfg (:obj:`ConfigDict`): Training or testing config.\n            rescale (list[torch.Tensor]): whether th rescale bbox.\n\n        Returns:\n            dict: Predictions of single batch containing the following keys:\n\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\n                - scores_3d (torch.Tensor): Score of each bbox.\n                - labels_3d (torch.Tensor): Label of each bbox.\n                - cls_preds (torch.Tensor): Class score of each bbox.\n        \"\"\"\n    assert len(cls_scores) == len(bbox_preds) == len(mlvl_anchors)\n    mlvl_bboxes = []\n    mlvl_max_scores = []\n    mlvl_label_pred = []\n    mlvl_dir_scores = []\n    mlvl_cls_score = []\n    for (cls_score, bbox_pred, dir_cls_pred, anchors) in zip(cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors):\n        assert cls_score.size()[-2:] == bbox_pred.size()[-2:]\n        assert cls_score.size()[-2:] == dir_cls_pred.size()[-2:]\n        dir_cls_pred = dir_cls_pred.permute(1, 2, 0).reshape(-1, 2)\n        dir_cls_score = torch.max(dir_cls_pred, dim=-1)[1]\n        cls_score = cls_score.permute(1, 2, 0).reshape(-1, self.num_classes)\n        if self.use_sigmoid_cls:\n            scores = cls_score.sigmoid()\n        else:\n            scores = cls_score.softmax(-1)\n        bbox_pred = bbox_pred.permute(1, 2, 0).reshape(-1, self.box_code_size)\n        nms_pre = cfg.get('nms_pre', -1)\n        if self.use_sigmoid_cls:\n            (max_scores, pred_labels) = scores.max(dim=1)\n        else:\n            (max_scores, pred_labels) = scores[:, :-1].max(dim=1)\n        if nms_pre > 0 and scores.shape[0] > nms_pre:\n            (topk_scores, topk_inds) = max_scores.topk(nms_pre)\n            anchors = anchors[topk_inds, :]\n            bbox_pred = bbox_pred[topk_inds, :]\n            max_scores = topk_scores\n            cls_score = scores[topk_inds, :]\n            dir_cls_score = dir_cls_score[topk_inds]\n            pred_labels = pred_labels[topk_inds]\n        bboxes = self.bbox_coder.decode(anchors, bbox_pred)\n        mlvl_bboxes.append(bboxes)\n        mlvl_max_scores.append(max_scores)\n        mlvl_cls_score.append(cls_score)\n        mlvl_label_pred.append(pred_labels)\n        mlvl_dir_scores.append(dir_cls_score)\n    mlvl_bboxes = torch.cat(mlvl_bboxes)\n    mlvl_bboxes_for_nms = xywhr2xyxyr(input_meta['box_type_3d'](mlvl_bboxes, box_dim=self.box_code_size).bev)\n    mlvl_max_scores = torch.cat(mlvl_max_scores)\n    mlvl_label_pred = torch.cat(mlvl_label_pred)\n    mlvl_dir_scores = torch.cat(mlvl_dir_scores)\n    mlvl_cls_score = torch.cat(mlvl_cls_score)\n    score_thr = cfg.get('score_thr', 0)\n    result = self.class_agnostic_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, cfg.nms_post, cfg, input_meta)\n    return result",
        "mutated": [
            "def get_bboxes_single(self, cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors, input_meta, cfg, rescale=False):\n    if False:\n        i = 10\n    \"Get bboxes of single branch.\\n\\n        Args:\\n            cls_scores (torch.Tensor): Class score in single batch.\\n            bbox_preds (torch.Tensor): Bbox prediction in single batch.\\n            dir_cls_preds (torch.Tensor): Predictions of direction class\\n                in single batch.\\n            mlvl_anchors (List[torch.Tensor]): Multi-level anchors\\n                in single batch.\\n            input_meta (list[dict]): Contain pcd and img's meta info.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            rescale (list[torch.Tensor]): whether th rescale bbox.\\n\\n        Returns:\\n            dict: Predictions of single batch containing the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    assert len(cls_scores) == len(bbox_preds) == len(mlvl_anchors)\n    mlvl_bboxes = []\n    mlvl_max_scores = []\n    mlvl_label_pred = []\n    mlvl_dir_scores = []\n    mlvl_cls_score = []\n    for (cls_score, bbox_pred, dir_cls_pred, anchors) in zip(cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors):\n        assert cls_score.size()[-2:] == bbox_pred.size()[-2:]\n        assert cls_score.size()[-2:] == dir_cls_pred.size()[-2:]\n        dir_cls_pred = dir_cls_pred.permute(1, 2, 0).reshape(-1, 2)\n        dir_cls_score = torch.max(dir_cls_pred, dim=-1)[1]\n        cls_score = cls_score.permute(1, 2, 0).reshape(-1, self.num_classes)\n        if self.use_sigmoid_cls:\n            scores = cls_score.sigmoid()\n        else:\n            scores = cls_score.softmax(-1)\n        bbox_pred = bbox_pred.permute(1, 2, 0).reshape(-1, self.box_code_size)\n        nms_pre = cfg.get('nms_pre', -1)\n        if self.use_sigmoid_cls:\n            (max_scores, pred_labels) = scores.max(dim=1)\n        else:\n            (max_scores, pred_labels) = scores[:, :-1].max(dim=1)\n        if nms_pre > 0 and scores.shape[0] > nms_pre:\n            (topk_scores, topk_inds) = max_scores.topk(nms_pre)\n            anchors = anchors[topk_inds, :]\n            bbox_pred = bbox_pred[topk_inds, :]\n            max_scores = topk_scores\n            cls_score = scores[topk_inds, :]\n            dir_cls_score = dir_cls_score[topk_inds]\n            pred_labels = pred_labels[topk_inds]\n        bboxes = self.bbox_coder.decode(anchors, bbox_pred)\n        mlvl_bboxes.append(bboxes)\n        mlvl_max_scores.append(max_scores)\n        mlvl_cls_score.append(cls_score)\n        mlvl_label_pred.append(pred_labels)\n        mlvl_dir_scores.append(dir_cls_score)\n    mlvl_bboxes = torch.cat(mlvl_bboxes)\n    mlvl_bboxes_for_nms = xywhr2xyxyr(input_meta['box_type_3d'](mlvl_bboxes, box_dim=self.box_code_size).bev)\n    mlvl_max_scores = torch.cat(mlvl_max_scores)\n    mlvl_label_pred = torch.cat(mlvl_label_pred)\n    mlvl_dir_scores = torch.cat(mlvl_dir_scores)\n    mlvl_cls_score = torch.cat(mlvl_cls_score)\n    score_thr = cfg.get('score_thr', 0)\n    result = self.class_agnostic_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, cfg.nms_post, cfg, input_meta)\n    return result",
            "def get_bboxes_single(self, cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors, input_meta, cfg, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Get bboxes of single branch.\\n\\n        Args:\\n            cls_scores (torch.Tensor): Class score in single batch.\\n            bbox_preds (torch.Tensor): Bbox prediction in single batch.\\n            dir_cls_preds (torch.Tensor): Predictions of direction class\\n                in single batch.\\n            mlvl_anchors (List[torch.Tensor]): Multi-level anchors\\n                in single batch.\\n            input_meta (list[dict]): Contain pcd and img's meta info.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            rescale (list[torch.Tensor]): whether th rescale bbox.\\n\\n        Returns:\\n            dict: Predictions of single batch containing the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    assert len(cls_scores) == len(bbox_preds) == len(mlvl_anchors)\n    mlvl_bboxes = []\n    mlvl_max_scores = []\n    mlvl_label_pred = []\n    mlvl_dir_scores = []\n    mlvl_cls_score = []\n    for (cls_score, bbox_pred, dir_cls_pred, anchors) in zip(cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors):\n        assert cls_score.size()[-2:] == bbox_pred.size()[-2:]\n        assert cls_score.size()[-2:] == dir_cls_pred.size()[-2:]\n        dir_cls_pred = dir_cls_pred.permute(1, 2, 0).reshape(-1, 2)\n        dir_cls_score = torch.max(dir_cls_pred, dim=-1)[1]\n        cls_score = cls_score.permute(1, 2, 0).reshape(-1, self.num_classes)\n        if self.use_sigmoid_cls:\n            scores = cls_score.sigmoid()\n        else:\n            scores = cls_score.softmax(-1)\n        bbox_pred = bbox_pred.permute(1, 2, 0).reshape(-1, self.box_code_size)\n        nms_pre = cfg.get('nms_pre', -1)\n        if self.use_sigmoid_cls:\n            (max_scores, pred_labels) = scores.max(dim=1)\n        else:\n            (max_scores, pred_labels) = scores[:, :-1].max(dim=1)\n        if nms_pre > 0 and scores.shape[0] > nms_pre:\n            (topk_scores, topk_inds) = max_scores.topk(nms_pre)\n            anchors = anchors[topk_inds, :]\n            bbox_pred = bbox_pred[topk_inds, :]\n            max_scores = topk_scores\n            cls_score = scores[topk_inds, :]\n            dir_cls_score = dir_cls_score[topk_inds]\n            pred_labels = pred_labels[topk_inds]\n        bboxes = self.bbox_coder.decode(anchors, bbox_pred)\n        mlvl_bboxes.append(bboxes)\n        mlvl_max_scores.append(max_scores)\n        mlvl_cls_score.append(cls_score)\n        mlvl_label_pred.append(pred_labels)\n        mlvl_dir_scores.append(dir_cls_score)\n    mlvl_bboxes = torch.cat(mlvl_bboxes)\n    mlvl_bboxes_for_nms = xywhr2xyxyr(input_meta['box_type_3d'](mlvl_bboxes, box_dim=self.box_code_size).bev)\n    mlvl_max_scores = torch.cat(mlvl_max_scores)\n    mlvl_label_pred = torch.cat(mlvl_label_pred)\n    mlvl_dir_scores = torch.cat(mlvl_dir_scores)\n    mlvl_cls_score = torch.cat(mlvl_cls_score)\n    score_thr = cfg.get('score_thr', 0)\n    result = self.class_agnostic_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, cfg.nms_post, cfg, input_meta)\n    return result",
            "def get_bboxes_single(self, cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors, input_meta, cfg, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Get bboxes of single branch.\\n\\n        Args:\\n            cls_scores (torch.Tensor): Class score in single batch.\\n            bbox_preds (torch.Tensor): Bbox prediction in single batch.\\n            dir_cls_preds (torch.Tensor): Predictions of direction class\\n                in single batch.\\n            mlvl_anchors (List[torch.Tensor]): Multi-level anchors\\n                in single batch.\\n            input_meta (list[dict]): Contain pcd and img's meta info.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            rescale (list[torch.Tensor]): whether th rescale bbox.\\n\\n        Returns:\\n            dict: Predictions of single batch containing the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    assert len(cls_scores) == len(bbox_preds) == len(mlvl_anchors)\n    mlvl_bboxes = []\n    mlvl_max_scores = []\n    mlvl_label_pred = []\n    mlvl_dir_scores = []\n    mlvl_cls_score = []\n    for (cls_score, bbox_pred, dir_cls_pred, anchors) in zip(cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors):\n        assert cls_score.size()[-2:] == bbox_pred.size()[-2:]\n        assert cls_score.size()[-2:] == dir_cls_pred.size()[-2:]\n        dir_cls_pred = dir_cls_pred.permute(1, 2, 0).reshape(-1, 2)\n        dir_cls_score = torch.max(dir_cls_pred, dim=-1)[1]\n        cls_score = cls_score.permute(1, 2, 0).reshape(-1, self.num_classes)\n        if self.use_sigmoid_cls:\n            scores = cls_score.sigmoid()\n        else:\n            scores = cls_score.softmax(-1)\n        bbox_pred = bbox_pred.permute(1, 2, 0).reshape(-1, self.box_code_size)\n        nms_pre = cfg.get('nms_pre', -1)\n        if self.use_sigmoid_cls:\n            (max_scores, pred_labels) = scores.max(dim=1)\n        else:\n            (max_scores, pred_labels) = scores[:, :-1].max(dim=1)\n        if nms_pre > 0 and scores.shape[0] > nms_pre:\n            (topk_scores, topk_inds) = max_scores.topk(nms_pre)\n            anchors = anchors[topk_inds, :]\n            bbox_pred = bbox_pred[topk_inds, :]\n            max_scores = topk_scores\n            cls_score = scores[topk_inds, :]\n            dir_cls_score = dir_cls_score[topk_inds]\n            pred_labels = pred_labels[topk_inds]\n        bboxes = self.bbox_coder.decode(anchors, bbox_pred)\n        mlvl_bboxes.append(bboxes)\n        mlvl_max_scores.append(max_scores)\n        mlvl_cls_score.append(cls_score)\n        mlvl_label_pred.append(pred_labels)\n        mlvl_dir_scores.append(dir_cls_score)\n    mlvl_bboxes = torch.cat(mlvl_bboxes)\n    mlvl_bboxes_for_nms = xywhr2xyxyr(input_meta['box_type_3d'](mlvl_bboxes, box_dim=self.box_code_size).bev)\n    mlvl_max_scores = torch.cat(mlvl_max_scores)\n    mlvl_label_pred = torch.cat(mlvl_label_pred)\n    mlvl_dir_scores = torch.cat(mlvl_dir_scores)\n    mlvl_cls_score = torch.cat(mlvl_cls_score)\n    score_thr = cfg.get('score_thr', 0)\n    result = self.class_agnostic_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, cfg.nms_post, cfg, input_meta)\n    return result",
            "def get_bboxes_single(self, cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors, input_meta, cfg, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Get bboxes of single branch.\\n\\n        Args:\\n            cls_scores (torch.Tensor): Class score in single batch.\\n            bbox_preds (torch.Tensor): Bbox prediction in single batch.\\n            dir_cls_preds (torch.Tensor): Predictions of direction class\\n                in single batch.\\n            mlvl_anchors (List[torch.Tensor]): Multi-level anchors\\n                in single batch.\\n            input_meta (list[dict]): Contain pcd and img's meta info.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            rescale (list[torch.Tensor]): whether th rescale bbox.\\n\\n        Returns:\\n            dict: Predictions of single batch containing the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    assert len(cls_scores) == len(bbox_preds) == len(mlvl_anchors)\n    mlvl_bboxes = []\n    mlvl_max_scores = []\n    mlvl_label_pred = []\n    mlvl_dir_scores = []\n    mlvl_cls_score = []\n    for (cls_score, bbox_pred, dir_cls_pred, anchors) in zip(cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors):\n        assert cls_score.size()[-2:] == bbox_pred.size()[-2:]\n        assert cls_score.size()[-2:] == dir_cls_pred.size()[-2:]\n        dir_cls_pred = dir_cls_pred.permute(1, 2, 0).reshape(-1, 2)\n        dir_cls_score = torch.max(dir_cls_pred, dim=-1)[1]\n        cls_score = cls_score.permute(1, 2, 0).reshape(-1, self.num_classes)\n        if self.use_sigmoid_cls:\n            scores = cls_score.sigmoid()\n        else:\n            scores = cls_score.softmax(-1)\n        bbox_pred = bbox_pred.permute(1, 2, 0).reshape(-1, self.box_code_size)\n        nms_pre = cfg.get('nms_pre', -1)\n        if self.use_sigmoid_cls:\n            (max_scores, pred_labels) = scores.max(dim=1)\n        else:\n            (max_scores, pred_labels) = scores[:, :-1].max(dim=1)\n        if nms_pre > 0 and scores.shape[0] > nms_pre:\n            (topk_scores, topk_inds) = max_scores.topk(nms_pre)\n            anchors = anchors[topk_inds, :]\n            bbox_pred = bbox_pred[topk_inds, :]\n            max_scores = topk_scores\n            cls_score = scores[topk_inds, :]\n            dir_cls_score = dir_cls_score[topk_inds]\n            pred_labels = pred_labels[topk_inds]\n        bboxes = self.bbox_coder.decode(anchors, bbox_pred)\n        mlvl_bboxes.append(bboxes)\n        mlvl_max_scores.append(max_scores)\n        mlvl_cls_score.append(cls_score)\n        mlvl_label_pred.append(pred_labels)\n        mlvl_dir_scores.append(dir_cls_score)\n    mlvl_bboxes = torch.cat(mlvl_bboxes)\n    mlvl_bboxes_for_nms = xywhr2xyxyr(input_meta['box_type_3d'](mlvl_bboxes, box_dim=self.box_code_size).bev)\n    mlvl_max_scores = torch.cat(mlvl_max_scores)\n    mlvl_label_pred = torch.cat(mlvl_label_pred)\n    mlvl_dir_scores = torch.cat(mlvl_dir_scores)\n    mlvl_cls_score = torch.cat(mlvl_cls_score)\n    score_thr = cfg.get('score_thr', 0)\n    result = self.class_agnostic_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, cfg.nms_post, cfg, input_meta)\n    return result",
            "def get_bboxes_single(self, cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors, input_meta, cfg, rescale=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Get bboxes of single branch.\\n\\n        Args:\\n            cls_scores (torch.Tensor): Class score in single batch.\\n            bbox_preds (torch.Tensor): Bbox prediction in single batch.\\n            dir_cls_preds (torch.Tensor): Predictions of direction class\\n                in single batch.\\n            mlvl_anchors (List[torch.Tensor]): Multi-level anchors\\n                in single batch.\\n            input_meta (list[dict]): Contain pcd and img's meta info.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            rescale (list[torch.Tensor]): whether th rescale bbox.\\n\\n        Returns:\\n            dict: Predictions of single batch containing the following keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    assert len(cls_scores) == len(bbox_preds) == len(mlvl_anchors)\n    mlvl_bboxes = []\n    mlvl_max_scores = []\n    mlvl_label_pred = []\n    mlvl_dir_scores = []\n    mlvl_cls_score = []\n    for (cls_score, bbox_pred, dir_cls_pred, anchors) in zip(cls_scores, bbox_preds, dir_cls_preds, mlvl_anchors):\n        assert cls_score.size()[-2:] == bbox_pred.size()[-2:]\n        assert cls_score.size()[-2:] == dir_cls_pred.size()[-2:]\n        dir_cls_pred = dir_cls_pred.permute(1, 2, 0).reshape(-1, 2)\n        dir_cls_score = torch.max(dir_cls_pred, dim=-1)[1]\n        cls_score = cls_score.permute(1, 2, 0).reshape(-1, self.num_classes)\n        if self.use_sigmoid_cls:\n            scores = cls_score.sigmoid()\n        else:\n            scores = cls_score.softmax(-1)\n        bbox_pred = bbox_pred.permute(1, 2, 0).reshape(-1, self.box_code_size)\n        nms_pre = cfg.get('nms_pre', -1)\n        if self.use_sigmoid_cls:\n            (max_scores, pred_labels) = scores.max(dim=1)\n        else:\n            (max_scores, pred_labels) = scores[:, :-1].max(dim=1)\n        if nms_pre > 0 and scores.shape[0] > nms_pre:\n            (topk_scores, topk_inds) = max_scores.topk(nms_pre)\n            anchors = anchors[topk_inds, :]\n            bbox_pred = bbox_pred[topk_inds, :]\n            max_scores = topk_scores\n            cls_score = scores[topk_inds, :]\n            dir_cls_score = dir_cls_score[topk_inds]\n            pred_labels = pred_labels[topk_inds]\n        bboxes = self.bbox_coder.decode(anchors, bbox_pred)\n        mlvl_bboxes.append(bboxes)\n        mlvl_max_scores.append(max_scores)\n        mlvl_cls_score.append(cls_score)\n        mlvl_label_pred.append(pred_labels)\n        mlvl_dir_scores.append(dir_cls_score)\n    mlvl_bboxes = torch.cat(mlvl_bboxes)\n    mlvl_bboxes_for_nms = xywhr2xyxyr(input_meta['box_type_3d'](mlvl_bboxes, box_dim=self.box_code_size).bev)\n    mlvl_max_scores = torch.cat(mlvl_max_scores)\n    mlvl_label_pred = torch.cat(mlvl_label_pred)\n    mlvl_dir_scores = torch.cat(mlvl_dir_scores)\n    mlvl_cls_score = torch.cat(mlvl_cls_score)\n    score_thr = cfg.get('score_thr', 0)\n    result = self.class_agnostic_nms(mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, cfg.nms_post, cfg, input_meta)\n    return result"
        ]
    },
    {
        "func_name": "class_agnostic_nms",
        "original": "def class_agnostic_nms(self, mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, max_num, cfg, input_meta):\n    \"\"\"Class agnostic nms for single batch.\n\n        Args:\n            mlvl_bboxes (torch.Tensor): Bboxes from Multi-level.\n            mlvl_bboxes_for_nms (torch.Tensor): Bboxes for nms\n                (bev or minmax boxes) from Multi-level.\n            mlvl_max_scores (torch.Tensor): Max scores of Multi-level bbox.\n            mlvl_label_pred (torch.Tensor): Class predictions\n                of Multi-level bbox.\n            mlvl_cls_score (torch.Tensor): Class scores of\n                Multi-level bbox.\n            mlvl_dir_scores (torch.Tensor): Direction scores of\n                Multi-level bbox.\n            score_thr (int): Score threshold.\n            max_num (int): Max number of bboxes after nms.\n            cfg (:obj:`ConfigDict`): Training or testing config.\n            input_meta (dict): Contain pcd and img's meta info.\n\n        Returns:\n            dict: Predictions of single batch. Contain the keys:\n\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\n                - scores_3d (torch.Tensor): Score of each bbox.\n                - labels_3d (torch.Tensor): Label of each bbox.\n                - cls_preds (torch.Tensor): Class score of each bbox.\n        \"\"\"\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    cls_scores = []\n    score_thr_inds = mlvl_max_scores > score_thr\n    _scores = mlvl_max_scores[score_thr_inds]\n    _bboxes_for_nms = mlvl_bboxes_for_nms[score_thr_inds, :]\n    if cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n    _mlvl_bboxes = mlvl_bboxes[score_thr_inds, :]\n    _mlvl_dir_scores = mlvl_dir_scores[score_thr_inds]\n    _mlvl_label_pred = mlvl_label_pred[score_thr_inds]\n    _mlvl_cls_score = mlvl_cls_score[score_thr_inds]\n    if len(selected) > 0:\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        labels.append(_mlvl_label_pred[selected])\n        cls_scores.append(_mlvl_cls_score[selected])\n        dir_scores.append(_mlvl_dir_scores[selected])\n        dir_rot = limit_period(bboxes[-1][..., 6] - self.dir_offset, self.dir_limit_offset, np.pi)\n        bboxes[-1][..., 6] = dir_rot + self.dir_offset + np.pi * dir_scores[-1].to(bboxes[-1].dtype)\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        cls_scores = torch.cat(cls_scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            cls_scores = cls_scores[inds]\n        bboxes = input_meta['box_type_3d'](bboxes, box_dim=self.box_code_size)\n        return dict(boxes_3d=bboxes, scores_3d=scores, labels_3d=labels, cls_preds=cls_scores)\n    else:\n        return dict(boxes_3d=input_meta['box_type_3d'](mlvl_bboxes.new_zeros([0, self.box_code_size]), box_dim=self.box_code_size), scores_3d=mlvl_bboxes.new_zeros([0]), labels_3d=mlvl_bboxes.new_zeros([0]), cls_preds=mlvl_bboxes.new_zeros([0, mlvl_cls_score.shape[-1]]))",
        "mutated": [
            "def class_agnostic_nms(self, mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, max_num, cfg, input_meta):\n    if False:\n        i = 10\n    \"Class agnostic nms for single batch.\\n\\n        Args:\\n            mlvl_bboxes (torch.Tensor): Bboxes from Multi-level.\\n            mlvl_bboxes_for_nms (torch.Tensor): Bboxes for nms\\n                (bev or minmax boxes) from Multi-level.\\n            mlvl_max_scores (torch.Tensor): Max scores of Multi-level bbox.\\n            mlvl_label_pred (torch.Tensor): Class predictions\\n                of Multi-level bbox.\\n            mlvl_cls_score (torch.Tensor): Class scores of\\n                Multi-level bbox.\\n            mlvl_dir_scores (torch.Tensor): Direction scores of\\n                Multi-level bbox.\\n            score_thr (int): Score threshold.\\n            max_num (int): Max number of bboxes after nms.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            input_meta (dict): Contain pcd and img's meta info.\\n\\n        Returns:\\n            dict: Predictions of single batch. Contain the keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    cls_scores = []\n    score_thr_inds = mlvl_max_scores > score_thr\n    _scores = mlvl_max_scores[score_thr_inds]\n    _bboxes_for_nms = mlvl_bboxes_for_nms[score_thr_inds, :]\n    if cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n    _mlvl_bboxes = mlvl_bboxes[score_thr_inds, :]\n    _mlvl_dir_scores = mlvl_dir_scores[score_thr_inds]\n    _mlvl_label_pred = mlvl_label_pred[score_thr_inds]\n    _mlvl_cls_score = mlvl_cls_score[score_thr_inds]\n    if len(selected) > 0:\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        labels.append(_mlvl_label_pred[selected])\n        cls_scores.append(_mlvl_cls_score[selected])\n        dir_scores.append(_mlvl_dir_scores[selected])\n        dir_rot = limit_period(bboxes[-1][..., 6] - self.dir_offset, self.dir_limit_offset, np.pi)\n        bboxes[-1][..., 6] = dir_rot + self.dir_offset + np.pi * dir_scores[-1].to(bboxes[-1].dtype)\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        cls_scores = torch.cat(cls_scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            cls_scores = cls_scores[inds]\n        bboxes = input_meta['box_type_3d'](bboxes, box_dim=self.box_code_size)\n        return dict(boxes_3d=bboxes, scores_3d=scores, labels_3d=labels, cls_preds=cls_scores)\n    else:\n        return dict(boxes_3d=input_meta['box_type_3d'](mlvl_bboxes.new_zeros([0, self.box_code_size]), box_dim=self.box_code_size), scores_3d=mlvl_bboxes.new_zeros([0]), labels_3d=mlvl_bboxes.new_zeros([0]), cls_preds=mlvl_bboxes.new_zeros([0, mlvl_cls_score.shape[-1]]))",
            "def class_agnostic_nms(self, mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, max_num, cfg, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Class agnostic nms for single batch.\\n\\n        Args:\\n            mlvl_bboxes (torch.Tensor): Bboxes from Multi-level.\\n            mlvl_bboxes_for_nms (torch.Tensor): Bboxes for nms\\n                (bev or minmax boxes) from Multi-level.\\n            mlvl_max_scores (torch.Tensor): Max scores of Multi-level bbox.\\n            mlvl_label_pred (torch.Tensor): Class predictions\\n                of Multi-level bbox.\\n            mlvl_cls_score (torch.Tensor): Class scores of\\n                Multi-level bbox.\\n            mlvl_dir_scores (torch.Tensor): Direction scores of\\n                Multi-level bbox.\\n            score_thr (int): Score threshold.\\n            max_num (int): Max number of bboxes after nms.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            input_meta (dict): Contain pcd and img's meta info.\\n\\n        Returns:\\n            dict: Predictions of single batch. Contain the keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    cls_scores = []\n    score_thr_inds = mlvl_max_scores > score_thr\n    _scores = mlvl_max_scores[score_thr_inds]\n    _bboxes_for_nms = mlvl_bboxes_for_nms[score_thr_inds, :]\n    if cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n    _mlvl_bboxes = mlvl_bboxes[score_thr_inds, :]\n    _mlvl_dir_scores = mlvl_dir_scores[score_thr_inds]\n    _mlvl_label_pred = mlvl_label_pred[score_thr_inds]\n    _mlvl_cls_score = mlvl_cls_score[score_thr_inds]\n    if len(selected) > 0:\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        labels.append(_mlvl_label_pred[selected])\n        cls_scores.append(_mlvl_cls_score[selected])\n        dir_scores.append(_mlvl_dir_scores[selected])\n        dir_rot = limit_period(bboxes[-1][..., 6] - self.dir_offset, self.dir_limit_offset, np.pi)\n        bboxes[-1][..., 6] = dir_rot + self.dir_offset + np.pi * dir_scores[-1].to(bboxes[-1].dtype)\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        cls_scores = torch.cat(cls_scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            cls_scores = cls_scores[inds]\n        bboxes = input_meta['box_type_3d'](bboxes, box_dim=self.box_code_size)\n        return dict(boxes_3d=bboxes, scores_3d=scores, labels_3d=labels, cls_preds=cls_scores)\n    else:\n        return dict(boxes_3d=input_meta['box_type_3d'](mlvl_bboxes.new_zeros([0, self.box_code_size]), box_dim=self.box_code_size), scores_3d=mlvl_bboxes.new_zeros([0]), labels_3d=mlvl_bboxes.new_zeros([0]), cls_preds=mlvl_bboxes.new_zeros([0, mlvl_cls_score.shape[-1]]))",
            "def class_agnostic_nms(self, mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, max_num, cfg, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Class agnostic nms for single batch.\\n\\n        Args:\\n            mlvl_bboxes (torch.Tensor): Bboxes from Multi-level.\\n            mlvl_bboxes_for_nms (torch.Tensor): Bboxes for nms\\n                (bev or minmax boxes) from Multi-level.\\n            mlvl_max_scores (torch.Tensor): Max scores of Multi-level bbox.\\n            mlvl_label_pred (torch.Tensor): Class predictions\\n                of Multi-level bbox.\\n            mlvl_cls_score (torch.Tensor): Class scores of\\n                Multi-level bbox.\\n            mlvl_dir_scores (torch.Tensor): Direction scores of\\n                Multi-level bbox.\\n            score_thr (int): Score threshold.\\n            max_num (int): Max number of bboxes after nms.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            input_meta (dict): Contain pcd and img's meta info.\\n\\n        Returns:\\n            dict: Predictions of single batch. Contain the keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    cls_scores = []\n    score_thr_inds = mlvl_max_scores > score_thr\n    _scores = mlvl_max_scores[score_thr_inds]\n    _bboxes_for_nms = mlvl_bboxes_for_nms[score_thr_inds, :]\n    if cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n    _mlvl_bboxes = mlvl_bboxes[score_thr_inds, :]\n    _mlvl_dir_scores = mlvl_dir_scores[score_thr_inds]\n    _mlvl_label_pred = mlvl_label_pred[score_thr_inds]\n    _mlvl_cls_score = mlvl_cls_score[score_thr_inds]\n    if len(selected) > 0:\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        labels.append(_mlvl_label_pred[selected])\n        cls_scores.append(_mlvl_cls_score[selected])\n        dir_scores.append(_mlvl_dir_scores[selected])\n        dir_rot = limit_period(bboxes[-1][..., 6] - self.dir_offset, self.dir_limit_offset, np.pi)\n        bboxes[-1][..., 6] = dir_rot + self.dir_offset + np.pi * dir_scores[-1].to(bboxes[-1].dtype)\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        cls_scores = torch.cat(cls_scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            cls_scores = cls_scores[inds]\n        bboxes = input_meta['box_type_3d'](bboxes, box_dim=self.box_code_size)\n        return dict(boxes_3d=bboxes, scores_3d=scores, labels_3d=labels, cls_preds=cls_scores)\n    else:\n        return dict(boxes_3d=input_meta['box_type_3d'](mlvl_bboxes.new_zeros([0, self.box_code_size]), box_dim=self.box_code_size), scores_3d=mlvl_bboxes.new_zeros([0]), labels_3d=mlvl_bboxes.new_zeros([0]), cls_preds=mlvl_bboxes.new_zeros([0, mlvl_cls_score.shape[-1]]))",
            "def class_agnostic_nms(self, mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, max_num, cfg, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Class agnostic nms for single batch.\\n\\n        Args:\\n            mlvl_bboxes (torch.Tensor): Bboxes from Multi-level.\\n            mlvl_bboxes_for_nms (torch.Tensor): Bboxes for nms\\n                (bev or minmax boxes) from Multi-level.\\n            mlvl_max_scores (torch.Tensor): Max scores of Multi-level bbox.\\n            mlvl_label_pred (torch.Tensor): Class predictions\\n                of Multi-level bbox.\\n            mlvl_cls_score (torch.Tensor): Class scores of\\n                Multi-level bbox.\\n            mlvl_dir_scores (torch.Tensor): Direction scores of\\n                Multi-level bbox.\\n            score_thr (int): Score threshold.\\n            max_num (int): Max number of bboxes after nms.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            input_meta (dict): Contain pcd and img's meta info.\\n\\n        Returns:\\n            dict: Predictions of single batch. Contain the keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    cls_scores = []\n    score_thr_inds = mlvl_max_scores > score_thr\n    _scores = mlvl_max_scores[score_thr_inds]\n    _bboxes_for_nms = mlvl_bboxes_for_nms[score_thr_inds, :]\n    if cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n    _mlvl_bboxes = mlvl_bboxes[score_thr_inds, :]\n    _mlvl_dir_scores = mlvl_dir_scores[score_thr_inds]\n    _mlvl_label_pred = mlvl_label_pred[score_thr_inds]\n    _mlvl_cls_score = mlvl_cls_score[score_thr_inds]\n    if len(selected) > 0:\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        labels.append(_mlvl_label_pred[selected])\n        cls_scores.append(_mlvl_cls_score[selected])\n        dir_scores.append(_mlvl_dir_scores[selected])\n        dir_rot = limit_period(bboxes[-1][..., 6] - self.dir_offset, self.dir_limit_offset, np.pi)\n        bboxes[-1][..., 6] = dir_rot + self.dir_offset + np.pi * dir_scores[-1].to(bboxes[-1].dtype)\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        cls_scores = torch.cat(cls_scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            cls_scores = cls_scores[inds]\n        bboxes = input_meta['box_type_3d'](bboxes, box_dim=self.box_code_size)\n        return dict(boxes_3d=bboxes, scores_3d=scores, labels_3d=labels, cls_preds=cls_scores)\n    else:\n        return dict(boxes_3d=input_meta['box_type_3d'](mlvl_bboxes.new_zeros([0, self.box_code_size]), box_dim=self.box_code_size), scores_3d=mlvl_bboxes.new_zeros([0]), labels_3d=mlvl_bboxes.new_zeros([0]), cls_preds=mlvl_bboxes.new_zeros([0, mlvl_cls_score.shape[-1]]))",
            "def class_agnostic_nms(self, mlvl_bboxes, mlvl_bboxes_for_nms, mlvl_max_scores, mlvl_label_pred, mlvl_cls_score, mlvl_dir_scores, score_thr, max_num, cfg, input_meta):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Class agnostic nms for single batch.\\n\\n        Args:\\n            mlvl_bboxes (torch.Tensor): Bboxes from Multi-level.\\n            mlvl_bboxes_for_nms (torch.Tensor): Bboxes for nms\\n                (bev or minmax boxes) from Multi-level.\\n            mlvl_max_scores (torch.Tensor): Max scores of Multi-level bbox.\\n            mlvl_label_pred (torch.Tensor): Class predictions\\n                of Multi-level bbox.\\n            mlvl_cls_score (torch.Tensor): Class scores of\\n                Multi-level bbox.\\n            mlvl_dir_scores (torch.Tensor): Direction scores of\\n                Multi-level bbox.\\n            score_thr (int): Score threshold.\\n            max_num (int): Max number of bboxes after nms.\\n            cfg (:obj:`ConfigDict`): Training or testing config.\\n            input_meta (dict): Contain pcd and img's meta info.\\n\\n        Returns:\\n            dict: Predictions of single batch. Contain the keys:\\n\\n                - boxes_3d (:obj:`BaseInstance3DBoxes`): Predicted 3d bboxes.\\n                - scores_3d (torch.Tensor): Score of each bbox.\\n                - labels_3d (torch.Tensor): Label of each bbox.\\n                - cls_preds (torch.Tensor): Class score of each bbox.\\n        \"\n    bboxes = []\n    scores = []\n    labels = []\n    dir_scores = []\n    cls_scores = []\n    score_thr_inds = mlvl_max_scores > score_thr\n    _scores = mlvl_max_scores[score_thr_inds]\n    _bboxes_for_nms = mlvl_bboxes_for_nms[score_thr_inds, :]\n    if cfg.use_rotate_nms:\n        nms_func = nms_bev\n    else:\n        nms_func = nms_normal_bev\n    selected = nms_func(_bboxes_for_nms, _scores, cfg.nms_thr)\n    _mlvl_bboxes = mlvl_bboxes[score_thr_inds, :]\n    _mlvl_dir_scores = mlvl_dir_scores[score_thr_inds]\n    _mlvl_label_pred = mlvl_label_pred[score_thr_inds]\n    _mlvl_cls_score = mlvl_cls_score[score_thr_inds]\n    if len(selected) > 0:\n        bboxes.append(_mlvl_bboxes[selected])\n        scores.append(_scores[selected])\n        labels.append(_mlvl_label_pred[selected])\n        cls_scores.append(_mlvl_cls_score[selected])\n        dir_scores.append(_mlvl_dir_scores[selected])\n        dir_rot = limit_period(bboxes[-1][..., 6] - self.dir_offset, self.dir_limit_offset, np.pi)\n        bboxes[-1][..., 6] = dir_rot + self.dir_offset + np.pi * dir_scores[-1].to(bboxes[-1].dtype)\n    if bboxes:\n        bboxes = torch.cat(bboxes, dim=0)\n        scores = torch.cat(scores, dim=0)\n        cls_scores = torch.cat(cls_scores, dim=0)\n        labels = torch.cat(labels, dim=0)\n        if bboxes.shape[0] > max_num:\n            (_, inds) = scores.sort(descending=True)\n            inds = inds[:max_num]\n            bboxes = bboxes[inds, :]\n            labels = labels[inds]\n            scores = scores[inds]\n            cls_scores = cls_scores[inds]\n        bboxes = input_meta['box_type_3d'](bboxes, box_dim=self.box_code_size)\n        return dict(boxes_3d=bboxes, scores_3d=scores, labels_3d=labels, cls_preds=cls_scores)\n    else:\n        return dict(boxes_3d=input_meta['box_type_3d'](mlvl_bboxes.new_zeros([0, self.box_code_size]), box_dim=self.box_code_size), scores_3d=mlvl_bboxes.new_zeros([0]), labels_3d=mlvl_bboxes.new_zeros([0]), cls_preds=mlvl_bboxes.new_zeros([0, mlvl_cls_score.shape[-1]]))"
        ]
    }
]