[
    {
        "func_name": "unpackbits",
        "original": "def unpackbits(x, num_bits):\n    \"\"\"Convert a decimal value numpy.ndarray into multi-binary value numpy.ndarray ([1,2]->[[0,1],[1,0]])\n\n    Args:\n        x (numpy.ndarray): Decimal array.\n        num_bits (int): The max length of the converted binary value.\n    \"\"\"\n    xshape = list(x.shape)\n    x = x.reshape([-1, 1])\n    to_and = 2 ** np.arange(num_bits).reshape([1, num_bits])\n    return (x & to_and).astype(bool).astype(int).reshape(xshape + [num_bits])",
        "mutated": [
            "def unpackbits(x, num_bits):\n    if False:\n        i = 10\n    'Convert a decimal value numpy.ndarray into multi-binary value numpy.ndarray ([1,2]->[[0,1],[1,0]])\\n\\n    Args:\\n        x (numpy.ndarray): Decimal array.\\n        num_bits (int): The max length of the converted binary value.\\n    '\n    xshape = list(x.shape)\n    x = x.reshape([-1, 1])\n    to_and = 2 ** np.arange(num_bits).reshape([1, num_bits])\n    return (x & to_and).astype(bool).astype(int).reshape(xshape + [num_bits])",
            "def unpackbits(x, num_bits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert a decimal value numpy.ndarray into multi-binary value numpy.ndarray ([1,2]->[[0,1],[1,0]])\\n\\n    Args:\\n        x (numpy.ndarray): Decimal array.\\n        num_bits (int): The max length of the converted binary value.\\n    '\n    xshape = list(x.shape)\n    x = x.reshape([-1, 1])\n    to_and = 2 ** np.arange(num_bits).reshape([1, num_bits])\n    return (x & to_and).astype(bool).astype(int).reshape(xshape + [num_bits])",
            "def unpackbits(x, num_bits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert a decimal value numpy.ndarray into multi-binary value numpy.ndarray ([1,2]->[[0,1],[1,0]])\\n\\n    Args:\\n        x (numpy.ndarray): Decimal array.\\n        num_bits (int): The max length of the converted binary value.\\n    '\n    xshape = list(x.shape)\n    x = x.reshape([-1, 1])\n    to_and = 2 ** np.arange(num_bits).reshape([1, num_bits])\n    return (x & to_and).astype(bool).astype(int).reshape(xshape + [num_bits])",
            "def unpackbits(x, num_bits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert a decimal value numpy.ndarray into multi-binary value numpy.ndarray ([1,2]->[[0,1],[1,0]])\\n\\n    Args:\\n        x (numpy.ndarray): Decimal array.\\n        num_bits (int): The max length of the converted binary value.\\n    '\n    xshape = list(x.shape)\n    x = x.reshape([-1, 1])\n    to_and = 2 ** np.arange(num_bits).reshape([1, num_bits])\n    return (x & to_and).astype(bool).astype(int).reshape(xshape + [num_bits])",
            "def unpackbits(x, num_bits):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert a decimal value numpy.ndarray into multi-binary value numpy.ndarray ([1,2]->[[0,1],[1,0]])\\n\\n    Args:\\n        x (numpy.ndarray): Decimal array.\\n        num_bits (int): The max length of the converted binary value.\\n    '\n    xshape = list(x.shape)\n    x = x.reshape([-1, 1])\n    to_and = 2 ** np.arange(num_bits).reshape([1, num_bits])\n    return (x & to_and).astype(bool).astype(int).reshape(xshape + [num_bits])"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, cate_cols, nume_cols, label_col, threshold=10, thresrate=0.99):\n    \"\"\"Constructor.\n\n        Args:\n            cate_cols (list): The columns of categorical features.\n            nume_cols (list): The columns of numerical features.\n            label_col (object): The column of Label.\n            threshold (int): The categories whose frequency is lower than the threshold will be filtered (be treated\n                as \"<LESS>\").\n            thresrate (float): The (1.0 - thersrate, default 1%) lowest-frequency categories will also be filtered.\n        \"\"\"\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s [INFO] %(message)s')\n    self.label_name = label_col\n    self.cate_cols = cate_cols\n    self.dtype_dict = {}\n    for item in cate_cols:\n        self.dtype_dict[item] = 'str'\n    for item in nume_cols:\n        self.dtype_dict[item] = 'float'\n    self.nume_cols = nume_cols\n    self.tgt_nume_cols = []\n    self.encoder = ce.ordinal.OrdinalEncoder(cols=cate_cols)\n    self.threshold = threshold\n    self.thresrate = thresrate\n    self.save_cate_avgs = {}\n    self.save_value_filter = {}\n    self.save_num_embs = {}\n    self.Max_len = {}\n    self.samples = 0",
        "mutated": [
            "def __init__(self, cate_cols, nume_cols, label_col, threshold=10, thresrate=0.99):\n    if False:\n        i = 10\n    'Constructor.\\n\\n        Args:\\n            cate_cols (list): The columns of categorical features.\\n            nume_cols (list): The columns of numerical features.\\n            label_col (object): The column of Label.\\n            threshold (int): The categories whose frequency is lower than the threshold will be filtered (be treated\\n                as \"<LESS>\").\\n            thresrate (float): The (1.0 - thersrate, default 1%) lowest-frequency categories will also be filtered.\\n        '\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s [INFO] %(message)s')\n    self.label_name = label_col\n    self.cate_cols = cate_cols\n    self.dtype_dict = {}\n    for item in cate_cols:\n        self.dtype_dict[item] = 'str'\n    for item in nume_cols:\n        self.dtype_dict[item] = 'float'\n    self.nume_cols = nume_cols\n    self.tgt_nume_cols = []\n    self.encoder = ce.ordinal.OrdinalEncoder(cols=cate_cols)\n    self.threshold = threshold\n    self.thresrate = thresrate\n    self.save_cate_avgs = {}\n    self.save_value_filter = {}\n    self.save_num_embs = {}\n    self.Max_len = {}\n    self.samples = 0",
            "def __init__(self, cate_cols, nume_cols, label_col, threshold=10, thresrate=0.99):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Constructor.\\n\\n        Args:\\n            cate_cols (list): The columns of categorical features.\\n            nume_cols (list): The columns of numerical features.\\n            label_col (object): The column of Label.\\n            threshold (int): The categories whose frequency is lower than the threshold will be filtered (be treated\\n                as \"<LESS>\").\\n            thresrate (float): The (1.0 - thersrate, default 1%) lowest-frequency categories will also be filtered.\\n        '\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s [INFO] %(message)s')\n    self.label_name = label_col\n    self.cate_cols = cate_cols\n    self.dtype_dict = {}\n    for item in cate_cols:\n        self.dtype_dict[item] = 'str'\n    for item in nume_cols:\n        self.dtype_dict[item] = 'float'\n    self.nume_cols = nume_cols\n    self.tgt_nume_cols = []\n    self.encoder = ce.ordinal.OrdinalEncoder(cols=cate_cols)\n    self.threshold = threshold\n    self.thresrate = thresrate\n    self.save_cate_avgs = {}\n    self.save_value_filter = {}\n    self.save_num_embs = {}\n    self.Max_len = {}\n    self.samples = 0",
            "def __init__(self, cate_cols, nume_cols, label_col, threshold=10, thresrate=0.99):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Constructor.\\n\\n        Args:\\n            cate_cols (list): The columns of categorical features.\\n            nume_cols (list): The columns of numerical features.\\n            label_col (object): The column of Label.\\n            threshold (int): The categories whose frequency is lower than the threshold will be filtered (be treated\\n                as \"<LESS>\").\\n            thresrate (float): The (1.0 - thersrate, default 1%) lowest-frequency categories will also be filtered.\\n        '\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s [INFO] %(message)s')\n    self.label_name = label_col\n    self.cate_cols = cate_cols\n    self.dtype_dict = {}\n    for item in cate_cols:\n        self.dtype_dict[item] = 'str'\n    for item in nume_cols:\n        self.dtype_dict[item] = 'float'\n    self.nume_cols = nume_cols\n    self.tgt_nume_cols = []\n    self.encoder = ce.ordinal.OrdinalEncoder(cols=cate_cols)\n    self.threshold = threshold\n    self.thresrate = thresrate\n    self.save_cate_avgs = {}\n    self.save_value_filter = {}\n    self.save_num_embs = {}\n    self.Max_len = {}\n    self.samples = 0",
            "def __init__(self, cate_cols, nume_cols, label_col, threshold=10, thresrate=0.99):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Constructor.\\n\\n        Args:\\n            cate_cols (list): The columns of categorical features.\\n            nume_cols (list): The columns of numerical features.\\n            label_col (object): The column of Label.\\n            threshold (int): The categories whose frequency is lower than the threshold will be filtered (be treated\\n                as \"<LESS>\").\\n            thresrate (float): The (1.0 - thersrate, default 1%) lowest-frequency categories will also be filtered.\\n        '\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s [INFO] %(message)s')\n    self.label_name = label_col\n    self.cate_cols = cate_cols\n    self.dtype_dict = {}\n    for item in cate_cols:\n        self.dtype_dict[item] = 'str'\n    for item in nume_cols:\n        self.dtype_dict[item] = 'float'\n    self.nume_cols = nume_cols\n    self.tgt_nume_cols = []\n    self.encoder = ce.ordinal.OrdinalEncoder(cols=cate_cols)\n    self.threshold = threshold\n    self.thresrate = thresrate\n    self.save_cate_avgs = {}\n    self.save_value_filter = {}\n    self.save_num_embs = {}\n    self.Max_len = {}\n    self.samples = 0",
            "def __init__(self, cate_cols, nume_cols, label_col, threshold=10, thresrate=0.99):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Constructor.\\n\\n        Args:\\n            cate_cols (list): The columns of categorical features.\\n            nume_cols (list): The columns of numerical features.\\n            label_col (object): The column of Label.\\n            threshold (int): The categories whose frequency is lower than the threshold will be filtered (be treated\\n                as \"<LESS>\").\\n            thresrate (float): The (1.0 - thersrate, default 1%) lowest-frequency categories will also be filtered.\\n        '\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s [INFO] %(message)s')\n    self.label_name = label_col\n    self.cate_cols = cate_cols\n    self.dtype_dict = {}\n    for item in cate_cols:\n        self.dtype_dict[item] = 'str'\n    for item in nume_cols:\n        self.dtype_dict[item] = 'float'\n    self.nume_cols = nume_cols\n    self.tgt_nume_cols = []\n    self.encoder = ce.ordinal.OrdinalEncoder(cols=cate_cols)\n    self.threshold = threshold\n    self.thresrate = thresrate\n    self.save_cate_avgs = {}\n    self.save_value_filter = {}\n    self.save_num_embs = {}\n    self.Max_len = {}\n    self.samples = 0"
        ]
    },
    {
        "func_name": "fit_transform",
        "original": "def fit_transform(self, df):\n    \"\"\"Input a training set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\n\n        Args:\n            df (pandas.DataFrame): Input dataframe\n\n        Returns:\n            numpy.ndarray, numpy.ndarray: New features and labels.\n        \"\"\"\n    df = df.astype(dtype=self.dtype_dict)\n    self.samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        num = value_counts.shape[0]\n        self.save_value_filter[item] = list(value_counts[:int(num * self.thresrate)][value_counts > self.threshold].index)\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n        del value_counts\n        gc.collect()\n    for item in tqdm(self.nume_cols):\n        df[item] = df[item].fillna(df[item].mean())\n        self.save_num_embs[item] = {'sum': df[item].sum(), 'cnt': df[item].shape[0]}\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.fit_transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        labels = df[self.label_name].values\n        feat_encoding = {'mean': [], 'count': []}\n        self.save_cate_avgs[item] = collections.defaultdict(lambda : [0, 0])\n        for idx in range(self.samples):\n            cur_feat = feats[idx]\n            if cur_feat in self.save_cate_avgs[item]:\n                feat_encoding['mean'].append(self.save_cate_avgs[item][cur_feat][0] / self.save_cate_avgs[item][cur_feat][1])\n                feat_encoding['count'].append(self.save_cate_avgs[item][cur_feat][1] / idx)\n            else:\n                feat_encoding['mean'].append(0)\n                feat_encoding['count'].append(0)\n            self.save_cate_avgs[item][cur_feat][0] += labels[idx]\n            self.save_cate_avgs[item][cur_feat][1] += 1\n        df[item + '_t_mean'] = feat_encoding['mean']\n        df[item + '_t_count'] = feat_encoding['count']\n        self.tgt_nume_cols.append(item + '_t_mean')\n        self.tgt_nume_cols.append(item + '_t_count')\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        Max = df[item].max()\n        bit_len = len(bin(Max)) - 2\n        samples = self.samples\n        self.Max_len[item] = bit_len\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    trn_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    trn_x = np.array(rows)\n    return (trn_x, trn_y)",
        "mutated": [
            "def fit_transform(self, df):\n    if False:\n        i = 10\n    'Input a training set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    self.samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        num = value_counts.shape[0]\n        self.save_value_filter[item] = list(value_counts[:int(num * self.thresrate)][value_counts > self.threshold].index)\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n        del value_counts\n        gc.collect()\n    for item in tqdm(self.nume_cols):\n        df[item] = df[item].fillna(df[item].mean())\n        self.save_num_embs[item] = {'sum': df[item].sum(), 'cnt': df[item].shape[0]}\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.fit_transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        labels = df[self.label_name].values\n        feat_encoding = {'mean': [], 'count': []}\n        self.save_cate_avgs[item] = collections.defaultdict(lambda : [0, 0])\n        for idx in range(self.samples):\n            cur_feat = feats[idx]\n            if cur_feat in self.save_cate_avgs[item]:\n                feat_encoding['mean'].append(self.save_cate_avgs[item][cur_feat][0] / self.save_cate_avgs[item][cur_feat][1])\n                feat_encoding['count'].append(self.save_cate_avgs[item][cur_feat][1] / idx)\n            else:\n                feat_encoding['mean'].append(0)\n                feat_encoding['count'].append(0)\n            self.save_cate_avgs[item][cur_feat][0] += labels[idx]\n            self.save_cate_avgs[item][cur_feat][1] += 1\n        df[item + '_t_mean'] = feat_encoding['mean']\n        df[item + '_t_count'] = feat_encoding['count']\n        self.tgt_nume_cols.append(item + '_t_mean')\n        self.tgt_nume_cols.append(item + '_t_count')\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        Max = df[item].max()\n        bit_len = len(bin(Max)) - 2\n        samples = self.samples\n        self.Max_len[item] = bit_len\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    trn_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    trn_x = np.array(rows)\n    return (trn_x, trn_y)",
            "def fit_transform(self, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Input a training set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    self.samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        num = value_counts.shape[0]\n        self.save_value_filter[item] = list(value_counts[:int(num * self.thresrate)][value_counts > self.threshold].index)\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n        del value_counts\n        gc.collect()\n    for item in tqdm(self.nume_cols):\n        df[item] = df[item].fillna(df[item].mean())\n        self.save_num_embs[item] = {'sum': df[item].sum(), 'cnt': df[item].shape[0]}\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.fit_transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        labels = df[self.label_name].values\n        feat_encoding = {'mean': [], 'count': []}\n        self.save_cate_avgs[item] = collections.defaultdict(lambda : [0, 0])\n        for idx in range(self.samples):\n            cur_feat = feats[idx]\n            if cur_feat in self.save_cate_avgs[item]:\n                feat_encoding['mean'].append(self.save_cate_avgs[item][cur_feat][0] / self.save_cate_avgs[item][cur_feat][1])\n                feat_encoding['count'].append(self.save_cate_avgs[item][cur_feat][1] / idx)\n            else:\n                feat_encoding['mean'].append(0)\n                feat_encoding['count'].append(0)\n            self.save_cate_avgs[item][cur_feat][0] += labels[idx]\n            self.save_cate_avgs[item][cur_feat][1] += 1\n        df[item + '_t_mean'] = feat_encoding['mean']\n        df[item + '_t_count'] = feat_encoding['count']\n        self.tgt_nume_cols.append(item + '_t_mean')\n        self.tgt_nume_cols.append(item + '_t_count')\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        Max = df[item].max()\n        bit_len = len(bin(Max)) - 2\n        samples = self.samples\n        self.Max_len[item] = bit_len\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    trn_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    trn_x = np.array(rows)\n    return (trn_x, trn_y)",
            "def fit_transform(self, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Input a training set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    self.samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        num = value_counts.shape[0]\n        self.save_value_filter[item] = list(value_counts[:int(num * self.thresrate)][value_counts > self.threshold].index)\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n        del value_counts\n        gc.collect()\n    for item in tqdm(self.nume_cols):\n        df[item] = df[item].fillna(df[item].mean())\n        self.save_num_embs[item] = {'sum': df[item].sum(), 'cnt': df[item].shape[0]}\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.fit_transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        labels = df[self.label_name].values\n        feat_encoding = {'mean': [], 'count': []}\n        self.save_cate_avgs[item] = collections.defaultdict(lambda : [0, 0])\n        for idx in range(self.samples):\n            cur_feat = feats[idx]\n            if cur_feat in self.save_cate_avgs[item]:\n                feat_encoding['mean'].append(self.save_cate_avgs[item][cur_feat][0] / self.save_cate_avgs[item][cur_feat][1])\n                feat_encoding['count'].append(self.save_cate_avgs[item][cur_feat][1] / idx)\n            else:\n                feat_encoding['mean'].append(0)\n                feat_encoding['count'].append(0)\n            self.save_cate_avgs[item][cur_feat][0] += labels[idx]\n            self.save_cate_avgs[item][cur_feat][1] += 1\n        df[item + '_t_mean'] = feat_encoding['mean']\n        df[item + '_t_count'] = feat_encoding['count']\n        self.tgt_nume_cols.append(item + '_t_mean')\n        self.tgt_nume_cols.append(item + '_t_count')\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        Max = df[item].max()\n        bit_len = len(bin(Max)) - 2\n        samples = self.samples\n        self.Max_len[item] = bit_len\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    trn_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    trn_x = np.array(rows)\n    return (trn_x, trn_y)",
            "def fit_transform(self, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Input a training set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    self.samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        num = value_counts.shape[0]\n        self.save_value_filter[item] = list(value_counts[:int(num * self.thresrate)][value_counts > self.threshold].index)\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n        del value_counts\n        gc.collect()\n    for item in tqdm(self.nume_cols):\n        df[item] = df[item].fillna(df[item].mean())\n        self.save_num_embs[item] = {'sum': df[item].sum(), 'cnt': df[item].shape[0]}\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.fit_transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        labels = df[self.label_name].values\n        feat_encoding = {'mean': [], 'count': []}\n        self.save_cate_avgs[item] = collections.defaultdict(lambda : [0, 0])\n        for idx in range(self.samples):\n            cur_feat = feats[idx]\n            if cur_feat in self.save_cate_avgs[item]:\n                feat_encoding['mean'].append(self.save_cate_avgs[item][cur_feat][0] / self.save_cate_avgs[item][cur_feat][1])\n                feat_encoding['count'].append(self.save_cate_avgs[item][cur_feat][1] / idx)\n            else:\n                feat_encoding['mean'].append(0)\n                feat_encoding['count'].append(0)\n            self.save_cate_avgs[item][cur_feat][0] += labels[idx]\n            self.save_cate_avgs[item][cur_feat][1] += 1\n        df[item + '_t_mean'] = feat_encoding['mean']\n        df[item + '_t_count'] = feat_encoding['count']\n        self.tgt_nume_cols.append(item + '_t_mean')\n        self.tgt_nume_cols.append(item + '_t_count')\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        Max = df[item].max()\n        bit_len = len(bin(Max)) - 2\n        samples = self.samples\n        self.Max_len[item] = bit_len\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    trn_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    trn_x = np.array(rows)\n    return (trn_x, trn_y)",
            "def fit_transform(self, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Input a training set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    self.samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        num = value_counts.shape[0]\n        self.save_value_filter[item] = list(value_counts[:int(num * self.thresrate)][value_counts > self.threshold].index)\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n        del value_counts\n        gc.collect()\n    for item in tqdm(self.nume_cols):\n        df[item] = df[item].fillna(df[item].mean())\n        self.save_num_embs[item] = {'sum': df[item].sum(), 'cnt': df[item].shape[0]}\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.fit_transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        labels = df[self.label_name].values\n        feat_encoding = {'mean': [], 'count': []}\n        self.save_cate_avgs[item] = collections.defaultdict(lambda : [0, 0])\n        for idx in range(self.samples):\n            cur_feat = feats[idx]\n            if cur_feat in self.save_cate_avgs[item]:\n                feat_encoding['mean'].append(self.save_cate_avgs[item][cur_feat][0] / self.save_cate_avgs[item][cur_feat][1])\n                feat_encoding['count'].append(self.save_cate_avgs[item][cur_feat][1] / idx)\n            else:\n                feat_encoding['mean'].append(0)\n                feat_encoding['count'].append(0)\n            self.save_cate_avgs[item][cur_feat][0] += labels[idx]\n            self.save_cate_avgs[item][cur_feat][1] += 1\n        df[item + '_t_mean'] = feat_encoding['mean']\n        df[item + '_t_count'] = feat_encoding['count']\n        self.tgt_nume_cols.append(item + '_t_mean')\n        self.tgt_nume_cols.append(item + '_t_count')\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        Max = df[item].max()\n        bit_len = len(bin(Max)) - 2\n        samples = self.samples\n        self.Max_len[item] = bit_len\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    trn_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    trn_x = np.array(rows)\n    return (trn_x, trn_y)"
        ]
    },
    {
        "func_name": "transform",
        "original": "def transform(self, df):\n    \"\"\"Input a testing / validation set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\n\n        Args:\n            df (pandas.DataFrame): Input dataframe\n\n        Returns:\n            numpy.ndarray, numpy.ndarray: New features and labels.\n        \"\"\"\n    df = df.astype(dtype=self.dtype_dict)\n    samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n    for item in tqdm(self.nume_cols):\n        mean = self.save_num_embs[item]['sum'] / self.save_num_embs[item]['cnt']\n        df[item] = df[item].fillna(mean)\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        avgs = self.save_cate_avgs[item]\n        df[item + '_t_mean'] = df[item].map(lambda x: avgs[x][0] / avgs[x][1] if x in avgs else 0)\n        df[item + '_t_count'] = df[item].map(lambda x: avgs[x][1] / self.samples if x in avgs else 0)\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        bit_len = self.Max_len[item]\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    vld_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    vld_x = np.array(rows)\n    return (vld_x, vld_y)",
        "mutated": [
            "def transform(self, df):\n    if False:\n        i = 10\n    'Input a testing / validation set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n    for item in tqdm(self.nume_cols):\n        mean = self.save_num_embs[item]['sum'] / self.save_num_embs[item]['cnt']\n        df[item] = df[item].fillna(mean)\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        avgs = self.save_cate_avgs[item]\n        df[item + '_t_mean'] = df[item].map(lambda x: avgs[x][0] / avgs[x][1] if x in avgs else 0)\n        df[item + '_t_count'] = df[item].map(lambda x: avgs[x][1] / self.samples if x in avgs else 0)\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        bit_len = self.Max_len[item]\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    vld_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    vld_x = np.array(rows)\n    return (vld_x, vld_y)",
            "def transform(self, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Input a testing / validation set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n    for item in tqdm(self.nume_cols):\n        mean = self.save_num_embs[item]['sum'] / self.save_num_embs[item]['cnt']\n        df[item] = df[item].fillna(mean)\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        avgs = self.save_cate_avgs[item]\n        df[item + '_t_mean'] = df[item].map(lambda x: avgs[x][0] / avgs[x][1] if x in avgs else 0)\n        df[item + '_t_count'] = df[item].map(lambda x: avgs[x][1] / self.samples if x in avgs else 0)\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        bit_len = self.Max_len[item]\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    vld_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    vld_x = np.array(rows)\n    return (vld_x, vld_y)",
            "def transform(self, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Input a testing / validation set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n    for item in tqdm(self.nume_cols):\n        mean = self.save_num_embs[item]['sum'] / self.save_num_embs[item]['cnt']\n        df[item] = df[item].fillna(mean)\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        avgs = self.save_cate_avgs[item]\n        df[item + '_t_mean'] = df[item].map(lambda x: avgs[x][0] / avgs[x][1] if x in avgs else 0)\n        df[item + '_t_count'] = df[item].map(lambda x: avgs[x][1] / self.samples if x in avgs else 0)\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        bit_len = self.Max_len[item]\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    vld_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    vld_x = np.array(rows)\n    return (vld_x, vld_y)",
            "def transform(self, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Input a testing / validation set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n    for item in tqdm(self.nume_cols):\n        mean = self.save_num_embs[item]['sum'] / self.save_num_embs[item]['cnt']\n        df[item] = df[item].fillna(mean)\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        avgs = self.save_cate_avgs[item]\n        df[item + '_t_mean'] = df[item].map(lambda x: avgs[x][0] / avgs[x][1] if x in avgs else 0)\n        df[item + '_t_count'] = df[item].map(lambda x: avgs[x][1] / self.samples if x in avgs else 0)\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        bit_len = self.Max_len[item]\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    vld_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    vld_x = np.array(rows)\n    return (vld_x, vld_y)",
            "def transform(self, df):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Input a testing / validation set (pandas.DataFrame) and return the converted 2 numpy.ndarray (x,y).\\n\\n        Args:\\n            df (pandas.DataFrame): Input dataframe\\n\\n        Returns:\\n            numpy.ndarray, numpy.ndarray: New features and labels.\\n        '\n    df = df.astype(dtype=self.dtype_dict)\n    samples = df.shape[0]\n    logging.info('Filtering and fillna features')\n    for item in tqdm(self.cate_cols):\n        value_counts = df[item].value_counts()\n        rm_values = set(value_counts.index) - set(self.save_value_filter[item])\n        df[item] = df[item].map(lambda x: '<LESS>' if x in rm_values else x)\n        df[item] = df[item].fillna('<UNK>')\n    for item in tqdm(self.nume_cols):\n        mean = self.save_num_embs[item]['sum'] / self.save_num_embs[item]['cnt']\n        df[item] = df[item].fillna(mean)\n    logging.info('Ordinal encoding cate features')\n    df = self.encoder.transform(df)\n    logging.info('Target encoding cate features')\n    for item in tqdm(self.cate_cols):\n        avgs = self.save_cate_avgs[item]\n        df[item + '_t_mean'] = df[item].map(lambda x: avgs[x][0] / avgs[x][1] if x in avgs else 0)\n        df[item + '_t_count'] = df[item].map(lambda x: avgs[x][1] / self.samples if x in avgs else 0)\n    logging.info('Start manual binary encoding')\n    rows = None\n    for item in tqdm(self.nume_cols + self.tgt_nume_cols):\n        feats = df[item].values\n        if rows is None:\n            rows = feats.reshape((-1, 1))\n        else:\n            rows = np.concatenate([rows, feats.reshape((-1, 1))], axis=1)\n        del feats\n        gc.collect()\n    for item in tqdm(self.cate_cols):\n        feats = df[item].values\n        bit_len = self.Max_len[item]\n        res = unpackbits(feats, bit_len).reshape((samples, -1))\n        rows = np.concatenate([rows, res], axis=1)\n        del feats\n        gc.collect()\n    vld_y = np.array(df[self.label_name].values).reshape((-1, 1))\n    del df\n    gc.collect()\n    vld_x = np.array(rows)\n    return (vld_x, vld_y)"
        ]
    }
]