[
    {
        "func_name": "manacher",
        "original": "def manacher(s):\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
        "mutated": [
            "def manacher(s):\n    if False:\n        i = 10\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
            "def manacher(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
            "def manacher(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
            "def manacher(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
            "def manacher(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P"
        ]
    },
    {
        "func_name": "maxProduct",
        "original": "def maxProduct(self, s):\n    \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    P = manacher(s)\n    q = collections.deque()\n    left = [0]\n    for i in xrange(len(s)):\n        while q and q[0][1] < i:\n            q.popleft()\n        left.append(max(left[-1], 1 + 2 * (i - q[0][0]) if q else 1))\n        q.append((i, i + P[2 * i + 2] // 2))\n    q = collections.deque()\n    result = right = 0\n    for i in reversed(xrange(len(s))):\n        while q and q[0][1] > i:\n            q.popleft()\n        right = max(right, 1 + 2 * (q[0][0] - i) if q else 1)\n        q.append((i, i - P[2 * i + 2] // 2))\n        result = max(result, left[i] * right)\n    return result",
        "mutated": [
            "def maxProduct(self, s):\n    if False:\n        i = 10\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    P = manacher(s)\n    q = collections.deque()\n    left = [0]\n    for i in xrange(len(s)):\n        while q and q[0][1] < i:\n            q.popleft()\n        left.append(max(left[-1], 1 + 2 * (i - q[0][0]) if q else 1))\n        q.append((i, i + P[2 * i + 2] // 2))\n    q = collections.deque()\n    result = right = 0\n    for i in reversed(xrange(len(s))):\n        while q and q[0][1] > i:\n            q.popleft()\n        right = max(right, 1 + 2 * (q[0][0] - i) if q else 1)\n        q.append((i, i - P[2 * i + 2] // 2))\n        result = max(result, left[i] * right)\n    return result",
            "def maxProduct(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    P = manacher(s)\n    q = collections.deque()\n    left = [0]\n    for i in xrange(len(s)):\n        while q and q[0][1] < i:\n            q.popleft()\n        left.append(max(left[-1], 1 + 2 * (i - q[0][0]) if q else 1))\n        q.append((i, i + P[2 * i + 2] // 2))\n    q = collections.deque()\n    result = right = 0\n    for i in reversed(xrange(len(s))):\n        while q and q[0][1] > i:\n            q.popleft()\n        right = max(right, 1 + 2 * (q[0][0] - i) if q else 1)\n        q.append((i, i - P[2 * i + 2] // 2))\n        result = max(result, left[i] * right)\n    return result",
            "def maxProduct(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    P = manacher(s)\n    q = collections.deque()\n    left = [0]\n    for i in xrange(len(s)):\n        while q and q[0][1] < i:\n            q.popleft()\n        left.append(max(left[-1], 1 + 2 * (i - q[0][0]) if q else 1))\n        q.append((i, i + P[2 * i + 2] // 2))\n    q = collections.deque()\n    result = right = 0\n    for i in reversed(xrange(len(s))):\n        while q and q[0][1] > i:\n            q.popleft()\n        right = max(right, 1 + 2 * (q[0][0] - i) if q else 1)\n        q.append((i, i - P[2 * i + 2] // 2))\n        result = max(result, left[i] * right)\n    return result",
            "def maxProduct(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    P = manacher(s)\n    q = collections.deque()\n    left = [0]\n    for i in xrange(len(s)):\n        while q and q[0][1] < i:\n            q.popleft()\n        left.append(max(left[-1], 1 + 2 * (i - q[0][0]) if q else 1))\n        q.append((i, i + P[2 * i + 2] // 2))\n    q = collections.deque()\n    result = right = 0\n    for i in reversed(xrange(len(s))):\n        while q and q[0][1] > i:\n            q.popleft()\n        right = max(right, 1 + 2 * (q[0][0] - i) if q else 1)\n        q.append((i, i - P[2 * i + 2] // 2))\n        result = max(result, left[i] * right)\n    return result",
            "def maxProduct(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    P = manacher(s)\n    q = collections.deque()\n    left = [0]\n    for i in xrange(len(s)):\n        while q and q[0][1] < i:\n            q.popleft()\n        left.append(max(left[-1], 1 + 2 * (i - q[0][0]) if q else 1))\n        q.append((i, i + P[2 * i + 2] // 2))\n    q = collections.deque()\n    result = right = 0\n    for i in reversed(xrange(len(s))):\n        while q and q[0][1] > i:\n            q.popleft()\n        right = max(right, 1 + 2 * (q[0][0] - i) if q else 1)\n        q.append((i, i - P[2 * i + 2] // 2))\n        result = max(result, left[i] * right)\n    return result"
        ]
    },
    {
        "func_name": "manacher",
        "original": "def manacher(s):\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
        "mutated": [
            "def manacher(s):\n    if False:\n        i = 10\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
            "def manacher(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
            "def manacher(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
            "def manacher(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P",
            "def manacher(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s = '^#' + '#'.join(s) + '#$'\n    P = [0] * len(s)\n    (C, R) = (0, 0)\n    for i in xrange(1, len(s) - 1):\n        i_mirror = 2 * C - i\n        if R > i:\n            P[i] = min(R - i, P[i_mirror])\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n        if i + P[i] > R:\n            (C, R) = (i, i + P[i])\n    return P"
        ]
    },
    {
        "func_name": "accumulate",
        "original": "def accumulate(iterable, func=operator.add, initial=None):\n    it = iter(iterable)\n    total = initial\n    if initial is None:\n        try:\n            total = next(it)\n        except StopIteration:\n            return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total",
        "mutated": [
            "def accumulate(iterable, func=operator.add, initial=None):\n    if False:\n        i = 10\n    it = iter(iterable)\n    total = initial\n    if initial is None:\n        try:\n            total = next(it)\n        except StopIteration:\n            return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total",
            "def accumulate(iterable, func=operator.add, initial=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    it = iter(iterable)\n    total = initial\n    if initial is None:\n        try:\n            total = next(it)\n        except StopIteration:\n            return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total",
            "def accumulate(iterable, func=operator.add, initial=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    it = iter(iterable)\n    total = initial\n    if initial is None:\n        try:\n            total = next(it)\n        except StopIteration:\n            return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total",
            "def accumulate(iterable, func=operator.add, initial=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    it = iter(iterable)\n    total = initial\n    if initial is None:\n        try:\n            total = next(it)\n        except StopIteration:\n            return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total",
            "def accumulate(iterable, func=operator.add, initial=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    it = iter(iterable)\n    total = initial\n    if initial is None:\n        try:\n            total = next(it)\n        except StopIteration:\n            return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total"
        ]
    },
    {
        "func_name": "fin_max_len",
        "original": "def fin_max_len(s):\n    P = manacher(s)\n    intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n    dp = [0] * len(s)\n    for (l, r) in reversed(intervals):\n        dp[r] = r - l + 1\n    for i in reversed(xrange(len(s) - 1)):\n        dp[i] = max(dp[i], dp[i + 1] - 2)\n    return list(accumulate(dp, max, 0))",
        "mutated": [
            "def fin_max_len(s):\n    if False:\n        i = 10\n    P = manacher(s)\n    intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n    dp = [0] * len(s)\n    for (l, r) in reversed(intervals):\n        dp[r] = r - l + 1\n    for i in reversed(xrange(len(s) - 1)):\n        dp[i] = max(dp[i], dp[i + 1] - 2)\n    return list(accumulate(dp, max, 0))",
            "def fin_max_len(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    P = manacher(s)\n    intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n    dp = [0] * len(s)\n    for (l, r) in reversed(intervals):\n        dp[r] = r - l + 1\n    for i in reversed(xrange(len(s) - 1)):\n        dp[i] = max(dp[i], dp[i + 1] - 2)\n    return list(accumulate(dp, max, 0))",
            "def fin_max_len(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    P = manacher(s)\n    intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n    dp = [0] * len(s)\n    for (l, r) in reversed(intervals):\n        dp[r] = r - l + 1\n    for i in reversed(xrange(len(s) - 1)):\n        dp[i] = max(dp[i], dp[i + 1] - 2)\n    return list(accumulate(dp, max, 0))",
            "def fin_max_len(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    P = manacher(s)\n    intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n    dp = [0] * len(s)\n    for (l, r) in reversed(intervals):\n        dp[r] = r - l + 1\n    for i in reversed(xrange(len(s) - 1)):\n        dp[i] = max(dp[i], dp[i + 1] - 2)\n    return list(accumulate(dp, max, 0))",
            "def fin_max_len(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    P = manacher(s)\n    intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n    dp = [0] * len(s)\n    for (l, r) in reversed(intervals):\n        dp[r] = r - l + 1\n    for i in reversed(xrange(len(s) - 1)):\n        dp[i] = max(dp[i], dp[i + 1] - 2)\n    return list(accumulate(dp, max, 0))"
        ]
    },
    {
        "func_name": "maxProduct",
        "original": "def maxProduct(self, s):\n    \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    import operator\n\n    def accumulate(iterable, func=operator.add, initial=None):\n        it = iter(iterable)\n        total = initial\n        if initial is None:\n            try:\n                total = next(it)\n            except StopIteration:\n                return\n        yield total\n        for element in it:\n            total = func(total, element)\n            yield total\n\n    def fin_max_len(s):\n        P = manacher(s)\n        intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n        dp = [0] * len(s)\n        for (l, r) in reversed(intervals):\n            dp[r] = r - l + 1\n        for i in reversed(xrange(len(s) - 1)):\n            dp[i] = max(dp[i], dp[i + 1] - 2)\n        return list(accumulate(dp, max, 0))\n    (l1, l2) = (fin_max_len(s), fin_max_len(s[::-1])[::-1])\n    return max((x * y for (x, y) in itertools.izip(l1, l2)))",
        "mutated": [
            "def maxProduct(self, s):\n    if False:\n        i = 10\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    import operator\n\n    def accumulate(iterable, func=operator.add, initial=None):\n        it = iter(iterable)\n        total = initial\n        if initial is None:\n            try:\n                total = next(it)\n            except StopIteration:\n                return\n        yield total\n        for element in it:\n            total = func(total, element)\n            yield total\n\n    def fin_max_len(s):\n        P = manacher(s)\n        intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n        dp = [0] * len(s)\n        for (l, r) in reversed(intervals):\n            dp[r] = r - l + 1\n        for i in reversed(xrange(len(s) - 1)):\n            dp[i] = max(dp[i], dp[i + 1] - 2)\n        return list(accumulate(dp, max, 0))\n    (l1, l2) = (fin_max_len(s), fin_max_len(s[::-1])[::-1])\n    return max((x * y for (x, y) in itertools.izip(l1, l2)))",
            "def maxProduct(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    import operator\n\n    def accumulate(iterable, func=operator.add, initial=None):\n        it = iter(iterable)\n        total = initial\n        if initial is None:\n            try:\n                total = next(it)\n            except StopIteration:\n                return\n        yield total\n        for element in it:\n            total = func(total, element)\n            yield total\n\n    def fin_max_len(s):\n        P = manacher(s)\n        intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n        dp = [0] * len(s)\n        for (l, r) in reversed(intervals):\n            dp[r] = r - l + 1\n        for i in reversed(xrange(len(s) - 1)):\n            dp[i] = max(dp[i], dp[i + 1] - 2)\n        return list(accumulate(dp, max, 0))\n    (l1, l2) = (fin_max_len(s), fin_max_len(s[::-1])[::-1])\n    return max((x * y for (x, y) in itertools.izip(l1, l2)))",
            "def maxProduct(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    import operator\n\n    def accumulate(iterable, func=operator.add, initial=None):\n        it = iter(iterable)\n        total = initial\n        if initial is None:\n            try:\n                total = next(it)\n            except StopIteration:\n                return\n        yield total\n        for element in it:\n            total = func(total, element)\n            yield total\n\n    def fin_max_len(s):\n        P = manacher(s)\n        intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n        dp = [0] * len(s)\n        for (l, r) in reversed(intervals):\n            dp[r] = r - l + 1\n        for i in reversed(xrange(len(s) - 1)):\n            dp[i] = max(dp[i], dp[i + 1] - 2)\n        return list(accumulate(dp, max, 0))\n    (l1, l2) = (fin_max_len(s), fin_max_len(s[::-1])[::-1])\n    return max((x * y for (x, y) in itertools.izip(l1, l2)))",
            "def maxProduct(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    import operator\n\n    def accumulate(iterable, func=operator.add, initial=None):\n        it = iter(iterable)\n        total = initial\n        if initial is None:\n            try:\n                total = next(it)\n            except StopIteration:\n                return\n        yield total\n        for element in it:\n            total = func(total, element)\n            yield total\n\n    def fin_max_len(s):\n        P = manacher(s)\n        intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n        dp = [0] * len(s)\n        for (l, r) in reversed(intervals):\n            dp[r] = r - l + 1\n        for i in reversed(xrange(len(s) - 1)):\n            dp[i] = max(dp[i], dp[i + 1] - 2)\n        return list(accumulate(dp, max, 0))\n    (l1, l2) = (fin_max_len(s), fin_max_len(s[::-1])[::-1])\n    return max((x * y for (x, y) in itertools.izip(l1, l2)))",
            "def maxProduct(self, s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type s: str\\n        :rtype: int\\n        '\n\n    def manacher(s):\n        s = '^#' + '#'.join(s) + '#$'\n        P = [0] * len(s)\n        (C, R) = (0, 0)\n        for i in xrange(1, len(s) - 1):\n            i_mirror = 2 * C - i\n            if R > i:\n                P[i] = min(R - i, P[i_mirror])\n            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n                P[i] += 1\n            if i + P[i] > R:\n                (C, R) = (i, i + P[i])\n        return P\n    import operator\n\n    def accumulate(iterable, func=operator.add, initial=None):\n        it = iter(iterable)\n        total = initial\n        if initial is None:\n            try:\n                total = next(it)\n            except StopIteration:\n                return\n        yield total\n        for element in it:\n            total = func(total, element)\n            yield total\n\n    def fin_max_len(s):\n        P = manacher(s)\n        intervals = [[(i - 2) // 2 - P[i] // 2, (i - 2) // 2 + P[i] // 2] for i in xrange(2, len(P) - 2, 2)]\n        dp = [0] * len(s)\n        for (l, r) in reversed(intervals):\n            dp[r] = r - l + 1\n        for i in reversed(xrange(len(s) - 1)):\n            dp[i] = max(dp[i], dp[i + 1] - 2)\n        return list(accumulate(dp, max, 0))\n    (l1, l2) = (fin_max_len(s), fin_max_len(s[::-1])[::-1])\n    return max((x * y for (x, y) in itertools.izip(l1, l2)))"
        ]
    }
]