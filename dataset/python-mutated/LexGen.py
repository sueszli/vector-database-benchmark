import glob
import os
import string
import sys
CR = '\r'
LF = '\n'
CRLF = '\r\n'
if sys.platform == 'win32':
    NATIVE = CRLF
else:
    NATIVE = LF

def CopyWithInsertion(input, commentPrefix, retainDefs, eolType, *lists):
    if False:
        i = 10
        return i + 15
    copying = 1
    listid = 0
    output = []
    for line in input.splitlines(0):
        isStartGenerated = line.startswith(commentPrefix + '++Autogenerated')
        if copying and (not isStartGenerated):
            output.append(line)
        if isStartGenerated:
            if retainDefs:
                output.append(line)
            copying = 0
            definition = ''
        elif not copying and line.startswith(commentPrefix + '**'):
            if retainDefs:
                output.append(line)
            definition = line[len(commentPrefix + '**'):]
            listid = 0
            if definition[0] in string.digits:
                listid = int(definition[:1])
                definition = definition[2:]
            definition = definition.replace('\\\\', '\x01')
            definition = definition.replace('\\n', '\n')
            definition = definition.replace('\\t', '\t')
            definition = definition.replace('\x01', '\\')
            startRepeat = definition.find('\\(')
            endRepeat = definition.find('\\)')
            intro = definition[:startRepeat]
            out = ''
            if intro.endswith('\n'):
                pos = 0
            else:
                pos = len(intro)
            out += intro
            middle = definition[startRepeat + 2:endRepeat]
            for i in lists[listid]:
                item = middle.replace('\\*', i)
                if pos and pos + len(item) >= 80:
                    out += '\\\n'
                    pos = 0
                out += item
                pos += len(item)
                if item.endswith('\n'):
                    pos = 0
            outro = definition[endRepeat + 2:]
            out += outro
            out = out.replace('\n', eolType)
            output.append(out)
        elif line.startswith(commentPrefix + '--Autogenerated'):
            copying = 1
            if retainDefs:
                output.append(line)
    output = [line.rstrip(' \t') for line in output]
    return eolType.join(output) + eolType

def UpdateFile(filename, updated):
    if False:
        for i in range(10):
            print('nop')
    "If the file is different to updated then copy updated\n    into the file else leave alone so CVS and make don't treat\n    it as modified."
    try:
        infile = open(filename, 'rb')
    except OSError:
        out = open(filename, 'wb')
        out.write(updated)
        out.close()
        print('New', filename)
        return
    original = infile.read()
    infile.close()
    if updated != original:
        os.unlink(filename)
        out = open(filename, 'wb')
        out.write(updated)
        out.close()
        print('Changed', filename)

def Generate(inpath, outpath, commentPrefix, eolType, *lists):
    if False:
        i = 10
        return i + 15
    'Generate \'outpath\' from \'inpath\'.\n\n    "eolType" indicates the type of EOLs to use in the generated\n        file. It should be one of following constants: LF, CRLF,\n        CR, or NATIVE.\n    '
    try:
        infile = open(inpath, 'r')
    except OSError:
        print('Can not open', inpath)
        return
    original = infile.read()
    infile.close()
    updated = CopyWithInsertion(original, commentPrefix, inpath == outpath, eolType, *lists)
    UpdateFile(outpath, updated)

def Regenerate(filename, commentPrefix, eolType, *lists):
    if False:
        print('Hello World!')
    'Regenerate the given file.\n\n    "eolType" indicates the type of EOLs to use in the generated\n        file. It should be one of following constants: LF, CRLF,\n        CR, or NATIVE.\n    '
    Generate(filename, filename, commentPrefix, eolType, *lists)

def FindModules(lexFile):
    if False:
        print('Hello World!')
    modules = []
    f = open(lexFile)
    for l in f.readlines():
        if l.startswith('LexerModule'):
            l = l.replace('(', ' ')
            modules.append(l.split()[1])
    return modules
knownIrregularProperties = ['fold', 'styling.within.preprocessor', 'tab.timmy.whinge.level', 'asp.default.language', 'html.tags.case.sensitive', 'ps.level', 'ps.tokenize', 'sql.backslash.escapes', 'nsis.uservars', 'nsis.ignorecase']

def FindProperties(lexFile):
    if False:
        return 10
    properties = set()
    f = open(lexFile)
    for l in f.readlines():
        if 'GetProperty' in l:
            l = l.strip()
            if not l.startswith('//'):
                propertyName = l.split('"')[1]
                if propertyName.lower() == propertyName:
                    if propertyName in knownIrregularProperties or propertyName.startswith('fold.') or propertyName.startswith('lexer.'):
                        properties.add(propertyName)
    return properties

def ciCompare(a, b):
    if False:
        return 10
    return cmp(a.lower(), b.lower())

def RegenerateAll():
    if False:
        i = 10
        return i + 15
    root = '../../'
    lexFilePaths = glob.glob(root + 'scintilla/src/Lex*.cxx')
    lexFiles = [os.path.basename(f)[:-4] for f in lexFilePaths]
    print(lexFiles)
    lexerModules = []
    lexerProperties = set()
    for lexFile in lexFilePaths:
        lexerModules.extend(FindModules(lexFile))
        lexerProperties.update(FindProperties(lexFile))
    lexerModules.sort(ciCompare)
    lexerProperties.remove('fold.comment.python')
    lexerProperties = list(lexerProperties)
    lexerProperties.sort(ciCompare)
    otherProps = ['abbrev.properties', 'Embedded.properties', 'SciTEGlobal.properties', 'SciTE.properties']
    if os.path.exists(root + 'scite'):
        propFilePaths = glob.glob(root + 'scite/src/*.properties')
        propFiles = [os.path.basename(f) for f in propFilePaths if os.path.basename(f) not in otherProps]
        propFiles.sort(ciCompare)
        print(propFiles)
    Regenerate(root + 'scintilla/src/KeyWords.cxx', '//', NATIVE, lexerModules)
    Regenerate(root + 'scintilla/win32/makefile', '#', NATIVE, lexFiles)
    Regenerate(root + 'scintilla/win32/scintilla.mak', '#', NATIVE, lexFiles)
    Regenerate(root + 'scintilla/win32/scintilla_vc6.mak', '#', NATIVE, lexFiles)
    Regenerate(root + 'scintilla/gtk/makefile', '#', LF, lexFiles)
    Regenerate(root + 'scintilla/gtk/scintilla.mak', '#', NATIVE, lexFiles)
    Regenerate(root + 'scintilla/macosx/makefile', '#', LF, lexFiles)
    if os.path.exists(root + 'scite'):
        Regenerate(root + 'scite/win32/makefile', '#', NATIVE, lexFiles, propFiles)
        Regenerate(root + 'scite/win32/scite.mak', '#', NATIVE, lexFiles, propFiles)
        Regenerate(root + 'scite/src/SciTEProps.cxx', '//', NATIVE, lexerProperties)
        Generate(root + 'scite/boundscheck/vcproj.gen', root + 'scite/boundscheck/SciTE.vcproj', '#', NATIVE, lexFiles)
RegenerateAll()