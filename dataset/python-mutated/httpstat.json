[
    {
        "func_name": "__init__",
        "original": "def __init__(self, key):\n    self.key = key.format(prefix=self.prefix)\n    Env._instances.append(self)",
        "mutated": [
            "def __init__(self, key):\n    if False:\n        i = 10\n    self.key = key.format(prefix=self.prefix)\n    Env._instances.append(self)",
            "def __init__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.key = key.format(prefix=self.prefix)\n    Env._instances.append(self)",
            "def __init__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.key = key.format(prefix=self.prefix)\n    Env._instances.append(self)",
            "def __init__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.key = key.format(prefix=self.prefix)\n    Env._instances.append(self)",
            "def __init__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.key = key.format(prefix=self.prefix)\n    Env._instances.append(self)"
        ]
    },
    {
        "func_name": "get",
        "original": "def get(self, default=None):\n    return os.environ.get(self.key, default)",
        "mutated": [
            "def get(self, default=None):\n    if False:\n        i = 10\n    return os.environ.get(self.key, default)",
            "def get(self, default=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return os.environ.get(self.key, default)",
            "def get(self, default=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return os.environ.get(self.key, default)",
            "def get(self, default=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return os.environ.get(self.key, default)",
            "def get(self, default=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return os.environ.get(self.key, default)"
        ]
    },
    {
        "func_name": "color_func",
        "original": "def color_func(s):\n    if not ISATTY:\n        return s\n    tpl = '\\x1b[{}m{}\\x1b[0m'\n    return tpl.format(code, s)",
        "mutated": [
            "def color_func(s):\n    if False:\n        i = 10\n    if not ISATTY:\n        return s\n    tpl = '\\x1b[{}m{}\\x1b[0m'\n    return tpl.format(code, s)",
            "def color_func(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not ISATTY:\n        return s\n    tpl = '\\x1b[{}m{}\\x1b[0m'\n    return tpl.format(code, s)",
            "def color_func(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not ISATTY:\n        return s\n    tpl = '\\x1b[{}m{}\\x1b[0m'\n    return tpl.format(code, s)",
            "def color_func(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not ISATTY:\n        return s\n    tpl = '\\x1b[{}m{}\\x1b[0m'\n    return tpl.format(code, s)",
            "def color_func(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not ISATTY:\n        return s\n    tpl = '\\x1b[{}m{}\\x1b[0m'\n    return tpl.format(code, s)"
        ]
    },
    {
        "func_name": "make_color",
        "original": "def make_color(code):\n\n    def color_func(s):\n        if not ISATTY:\n            return s\n        tpl = '\\x1b[{}m{}\\x1b[0m'\n        return tpl.format(code, s)\n    return color_func",
        "mutated": [
            "def make_color(code):\n    if False:\n        i = 10\n\n    def color_func(s):\n        if not ISATTY:\n            return s\n        tpl = '\\x1b[{}m{}\\x1b[0m'\n        return tpl.format(code, s)\n    return color_func",
            "def make_color(code):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def color_func(s):\n        if not ISATTY:\n            return s\n        tpl = '\\x1b[{}m{}\\x1b[0m'\n        return tpl.format(code, s)\n    return color_func",
            "def make_color(code):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def color_func(s):\n        if not ISATTY:\n            return s\n        tpl = '\\x1b[{}m{}\\x1b[0m'\n        return tpl.format(code, s)\n    return color_func",
            "def make_color(code):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def color_func(s):\n        if not ISATTY:\n            return s\n        tpl = '\\x1b[{}m{}\\x1b[0m'\n        return tpl.format(code, s)\n    return color_func",
            "def make_color(code):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def color_func(s):\n        if not ISATTY:\n            return s\n        tpl = '\\x1b[{}m{}\\x1b[0m'\n        return tpl.format(code, s)\n    return color_func"
        ]
    },
    {
        "func_name": "quit",
        "original": "def quit(s, code=0):\n    if s is not None:\n        print(s)\n    sys.exit(code)",
        "mutated": [
            "def quit(s, code=0):\n    if False:\n        i = 10\n    if s is not None:\n        print(s)\n    sys.exit(code)",
            "def quit(s, code=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if s is not None:\n        print(s)\n    sys.exit(code)",
            "def quit(s, code=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if s is not None:\n        print(s)\n    sys.exit(code)",
            "def quit(s, code=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if s is not None:\n        print(s)\n    sys.exit(code)",
            "def quit(s, code=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if s is not None:\n        print(s)\n    sys.exit(code)"
        ]
    },
    {
        "func_name": "print_help",
        "original": "def print_help():\n    help = '\\nUsage: httpstat URL [CURL_OPTIONS]\\n       httpstat -h | --help\\n       httpstat --version\\n\\nArguments:\\n  URL     url to request, could be with or without `http(s)://` prefix\\n\\nOptions:\\n  CURL_OPTIONS  any curl supported options, except for -w -D -o -S -s,\\n                which are already used internally.\\n  -h --help     show this screen.\\n  --version     show version.\\n\\nEnvironments:\\n  HTTPSTAT_SHOW_BODY    Set to `true` to show response body in the output,\\n                        note that body length is limited to 1023 bytes, will be\\n                        truncated if exceeds. Default is `false`.\\n  HTTPSTAT_SHOW_IP      By default httpstat shows remote and local IP/port address.\\n                        Set to `false` to disable this feature. Default is `true`.\\n  HTTPSTAT_SHOW_SPEED   Set to `true` to show download and upload speed.\\n                        Default is `false`.\\n  HTTPSTAT_SAVE_BODY    By default httpstat stores body in a tmp file,\\n                        set to `false` to disable this feature. Default is `true`\\n  HTTPSTAT_CURL_BIN     Indicate the curl bin path to use. Default is `curl`\\n                        from current shell $PATH.\\n  HTTPSTAT_DEBUG        Set to `true` to see debugging logs. Default is `false`\\n'[1:-1]\n    print(help)",
        "mutated": [
            "def print_help():\n    if False:\n        i = 10\n    help = '\\nUsage: httpstat URL [CURL_OPTIONS]\\n       httpstat -h | --help\\n       httpstat --version\\n\\nArguments:\\n  URL     url to request, could be with or without `http(s)://` prefix\\n\\nOptions:\\n  CURL_OPTIONS  any curl supported options, except for -w -D -o -S -s,\\n                which are already used internally.\\n  -h --help     show this screen.\\n  --version     show version.\\n\\nEnvironments:\\n  HTTPSTAT_SHOW_BODY    Set to `true` to show response body in the output,\\n                        note that body length is limited to 1023 bytes, will be\\n                        truncated if exceeds. Default is `false`.\\n  HTTPSTAT_SHOW_IP      By default httpstat shows remote and local IP/port address.\\n                        Set to `false` to disable this feature. Default is `true`.\\n  HTTPSTAT_SHOW_SPEED   Set to `true` to show download and upload speed.\\n                        Default is `false`.\\n  HTTPSTAT_SAVE_BODY    By default httpstat stores body in a tmp file,\\n                        set to `false` to disable this feature. Default is `true`\\n  HTTPSTAT_CURL_BIN     Indicate the curl bin path to use. Default is `curl`\\n                        from current shell $PATH.\\n  HTTPSTAT_DEBUG        Set to `true` to see debugging logs. Default is `false`\\n'[1:-1]\n    print(help)",
            "def print_help():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    help = '\\nUsage: httpstat URL [CURL_OPTIONS]\\n       httpstat -h | --help\\n       httpstat --version\\n\\nArguments:\\n  URL     url to request, could be with or without `http(s)://` prefix\\n\\nOptions:\\n  CURL_OPTIONS  any curl supported options, except for -w -D -o -S -s,\\n                which are already used internally.\\n  -h --help     show this screen.\\n  --version     show version.\\n\\nEnvironments:\\n  HTTPSTAT_SHOW_BODY    Set to `true` to show response body in the output,\\n                        note that body length is limited to 1023 bytes, will be\\n                        truncated if exceeds. Default is `false`.\\n  HTTPSTAT_SHOW_IP      By default httpstat shows remote and local IP/port address.\\n                        Set to `false` to disable this feature. Default is `true`.\\n  HTTPSTAT_SHOW_SPEED   Set to `true` to show download and upload speed.\\n                        Default is `false`.\\n  HTTPSTAT_SAVE_BODY    By default httpstat stores body in a tmp file,\\n                        set to `false` to disable this feature. Default is `true`\\n  HTTPSTAT_CURL_BIN     Indicate the curl bin path to use. Default is `curl`\\n                        from current shell $PATH.\\n  HTTPSTAT_DEBUG        Set to `true` to see debugging logs. Default is `false`\\n'[1:-1]\n    print(help)",
            "def print_help():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    help = '\\nUsage: httpstat URL [CURL_OPTIONS]\\n       httpstat -h | --help\\n       httpstat --version\\n\\nArguments:\\n  URL     url to request, could be with or without `http(s)://` prefix\\n\\nOptions:\\n  CURL_OPTIONS  any curl supported options, except for -w -D -o -S -s,\\n                which are already used internally.\\n  -h --help     show this screen.\\n  --version     show version.\\n\\nEnvironments:\\n  HTTPSTAT_SHOW_BODY    Set to `true` to show response body in the output,\\n                        note that body length is limited to 1023 bytes, will be\\n                        truncated if exceeds. Default is `false`.\\n  HTTPSTAT_SHOW_IP      By default httpstat shows remote and local IP/port address.\\n                        Set to `false` to disable this feature. Default is `true`.\\n  HTTPSTAT_SHOW_SPEED   Set to `true` to show download and upload speed.\\n                        Default is `false`.\\n  HTTPSTAT_SAVE_BODY    By default httpstat stores body in a tmp file,\\n                        set to `false` to disable this feature. Default is `true`\\n  HTTPSTAT_CURL_BIN     Indicate the curl bin path to use. Default is `curl`\\n                        from current shell $PATH.\\n  HTTPSTAT_DEBUG        Set to `true` to see debugging logs. Default is `false`\\n'[1:-1]\n    print(help)",
            "def print_help():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    help = '\\nUsage: httpstat URL [CURL_OPTIONS]\\n       httpstat -h | --help\\n       httpstat --version\\n\\nArguments:\\n  URL     url to request, could be with or without `http(s)://` prefix\\n\\nOptions:\\n  CURL_OPTIONS  any curl supported options, except for -w -D -o -S -s,\\n                which are already used internally.\\n  -h --help     show this screen.\\n  --version     show version.\\n\\nEnvironments:\\n  HTTPSTAT_SHOW_BODY    Set to `true` to show response body in the output,\\n                        note that body length is limited to 1023 bytes, will be\\n                        truncated if exceeds. Default is `false`.\\n  HTTPSTAT_SHOW_IP      By default httpstat shows remote and local IP/port address.\\n                        Set to `false` to disable this feature. Default is `true`.\\n  HTTPSTAT_SHOW_SPEED   Set to `true` to show download and upload speed.\\n                        Default is `false`.\\n  HTTPSTAT_SAVE_BODY    By default httpstat stores body in a tmp file,\\n                        set to `false` to disable this feature. Default is `true`\\n  HTTPSTAT_CURL_BIN     Indicate the curl bin path to use. Default is `curl`\\n                        from current shell $PATH.\\n  HTTPSTAT_DEBUG        Set to `true` to see debugging logs. Default is `false`\\n'[1:-1]\n    print(help)",
            "def print_help():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    help = '\\nUsage: httpstat URL [CURL_OPTIONS]\\n       httpstat -h | --help\\n       httpstat --version\\n\\nArguments:\\n  URL     url to request, could be with or without `http(s)://` prefix\\n\\nOptions:\\n  CURL_OPTIONS  any curl supported options, except for -w -D -o -S -s,\\n                which are already used internally.\\n  -h --help     show this screen.\\n  --version     show version.\\n\\nEnvironments:\\n  HTTPSTAT_SHOW_BODY    Set to `true` to show response body in the output,\\n                        note that body length is limited to 1023 bytes, will be\\n                        truncated if exceeds. Default is `false`.\\n  HTTPSTAT_SHOW_IP      By default httpstat shows remote and local IP/port address.\\n                        Set to `false` to disable this feature. Default is `true`.\\n  HTTPSTAT_SHOW_SPEED   Set to `true` to show download and upload speed.\\n                        Default is `false`.\\n  HTTPSTAT_SAVE_BODY    By default httpstat stores body in a tmp file,\\n                        set to `false` to disable this feature. Default is `true`\\n  HTTPSTAT_CURL_BIN     Indicate the curl bin path to use. Default is `curl`\\n                        from current shell $PATH.\\n  HTTPSTAT_DEBUG        Set to `true` to see debugging logs. Default is `false`\\n'[1:-1]\n    print(help)"
        ]
    },
    {
        "func_name": "fmta",
        "original": "def fmta(s):\n    return cyan('{:^7}'.format(str(s) + 'ms'))",
        "mutated": [
            "def fmta(s):\n    if False:\n        i = 10\n    return cyan('{:^7}'.format(str(s) + 'ms'))",
            "def fmta(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return cyan('{:^7}'.format(str(s) + 'ms'))",
            "def fmta(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return cyan('{:^7}'.format(str(s) + 'ms'))",
            "def fmta(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return cyan('{:^7}'.format(str(s) + 'ms'))",
            "def fmta(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return cyan('{:^7}'.format(str(s) + 'ms'))"
        ]
    },
    {
        "func_name": "fmtb",
        "original": "def fmtb(s):\n    return cyan('{:<7}'.format(str(s) + 'ms'))",
        "mutated": [
            "def fmtb(s):\n    if False:\n        i = 10\n    return cyan('{:<7}'.format(str(s) + 'ms'))",
            "def fmtb(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return cyan('{:<7}'.format(str(s) + 'ms'))",
            "def fmtb(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return cyan('{:<7}'.format(str(s) + 'ms'))",
            "def fmtb(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return cyan('{:<7}'.format(str(s) + 'ms'))",
            "def fmtb(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return cyan('{:<7}'.format(str(s) + 'ms'))"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    args = sys.argv[1:]\n    if not args:\n        print_help()\n        quit(None, 0)\n    show_body = 'true' in ENV_SHOW_BODY.get('false').lower()\n    show_ip = 'true' in ENV_SHOW_IP.get('true').lower()\n    show_speed = 'true' in ENV_SHOW_SPEED.get('false').lower()\n    save_body = 'true' in ENV_SAVE_BODY.get('true').lower()\n    curl_bin = ENV_CURL_BIN.get('curl')\n    metrics_only = 'true' in ENV_METRICS_ONLY.get('false').lower()\n    is_debug = 'true' in ENV_DEBUG.get('false').lower()\n    if is_debug:\n        log_level = logging.DEBUG\n    else:\n        log_level = logging.INFO\n    logging.basicConfig(level=log_level)\n    lg = logging.getLogger('httpstat')\n    lg.debug('Envs:\\n%s', '\\n'.join(('  {}={}'.format(i.key, i.get('')) for i in Env._instances)))\n    lg.debug('Flags: %s', dict(show_body=show_body, show_ip=show_ip, show_speed=show_speed, save_body=save_body, curl_bin=curl_bin, is_debug=is_debug))\n    url = args[0]\n    if url in ['-h', '--help']:\n        print_help()\n        quit(None, 0)\n    elif url == '--version':\n        print('httpstat {}'.format(__version__))\n        quit(None, 0)\n    curl_args = args[1:]\n    exclude_options = ['-w', '--write-out', '-D', '--dump-header', '-o', '--output', '-s', '--silent']\n    for i in exclude_options:\n        if i in curl_args:\n            quit(yellow('Error: {} is not allowed in extra curl args'.format(i)), 1)\n    bodyf = tempfile.NamedTemporaryFile(delete=False)\n    bodyf.close()\n    headerf = tempfile.NamedTemporaryFile(delete=False)\n    headerf.close()\n    cmd_env = os.environ.copy()\n    cmd_env.update(LC_ALL='C')\n    cmd_core = [curl_bin, '-w', curl_format, '-D', headerf.name, '-o', bodyf.name, '-s', '-S']\n    cmd = cmd_core + curl_args + [url]\n    lg.debug('cmd: %s', cmd)\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=cmd_env)\n    (out, err) = p.communicate()\n    if PY3:\n        (out, err) = (out.decode(), err.decode())\n    lg.debug('out: %s', out)\n    if p.returncode == 0:\n        if err:\n            print(grayscale[16](err))\n    else:\n        _cmd = list(cmd)\n        _cmd[2] = '<output-format>'\n        _cmd[4] = '<tempfile>'\n        _cmd[6] = '<tempfile>'\n        print('> {}'.format(' '.join(_cmd)))\n        quit(yellow('curl error: {}'.format(err)), p.returncode)\n    try:\n        d = json.loads(out)\n    except ValueError as e:\n        print(yellow('Could not decode json: {}'.format(e)))\n        print('curl result:', p.returncode, grayscale[16](out), grayscale[16](err))\n        quit(None, 1)\n    for k in d:\n        if k.startswith('time_'):\n            v = d[k]\n            if isinstance(v, float):\n                d[k] = int(v * 1000)\n            elif isinstance(v, int):\n                d[k] = int(v / 1000)\n            else:\n                raise TypeError('{} value type is invalid: {}'.format(k, type(v)))\n    d.update(range_dns=d['time_namelookup'], range_connection=d['time_connect'] - d['time_namelookup'], range_ssl=d['time_pretransfer'] - d['time_connect'], range_server=d['time_starttransfer'] - d['time_pretransfer'], range_transfer=d['time_total'] - d['time_starttransfer'])\n    if metrics_only:\n        print(json.dumps(d, indent=2))\n        quit(None, 0)\n    if show_ip:\n        s = 'Connected to {}:{} from {}:{}'.format(cyan(d['remote_ip']), cyan(d['remote_port']), d['local_ip'], d['local_port'])\n        print(s)\n        print()\n    with open(headerf.name, 'r') as f:\n        headers = f.read().strip()\n    lg.debug('rm header file %s', headerf.name)\n    os.remove(headerf.name)\n    for (loop, line) in enumerate(headers.split('\\n')):\n        if loop == 0:\n            (p1, p2) = tuple(line.split('/'))\n            print(green(p1) + grayscale[14]('/') + cyan(p2))\n        else:\n            pos = line.find(':')\n            print(grayscale[14](line[:pos + 1]) + cyan(line[pos + 1:]))\n    print()\n    if show_body:\n        body_limit = 1024\n        with open(bodyf.name, 'r') as f:\n            body = f.read().strip()\n        body_len = len(body)\n        if body_len > body_limit:\n            print(body[:body_limit] + cyan('...'))\n            print()\n            s = '{} is truncated ({} out of {})'.format(green('Body'), body_limit, body_len)\n            if save_body:\n                s += ', stored in: {}'.format(bodyf.name)\n            print(s)\n        else:\n            print(body)\n    elif save_body:\n        print('{} stored in: {}'.format(green('Body'), bodyf.name))\n    if not save_body:\n        lg.debug('rm body file %s', bodyf.name)\n        os.remove(bodyf.name)\n    if url.startswith('https://'):\n        template = https_template\n    else:\n        template = http_template\n    tpl_parts = template.split('\\n')\n    tpl_parts[0] = grayscale[16](tpl_parts[0])\n    template = '\\n'.join(tpl_parts)\n\n    def fmta(s):\n        return cyan('{:^7}'.format(str(s) + 'ms'))\n\n    def fmtb(s):\n        return cyan('{:<7}'.format(str(s) + 'ms'))\n    stat = template.format(a0000=fmta(d['range_dns']), a0001=fmta(d['range_connection']), a0002=fmta(d['range_ssl']), a0003=fmta(d['range_server']), a0004=fmta(d['range_transfer']), b0000=fmtb(d['time_namelookup']), b0001=fmtb(d['time_connect']), b0002=fmtb(d['time_pretransfer']), b0003=fmtb(d['time_starttransfer']), b0004=fmtb(d['time_total']))\n    print()\n    print(stat)\n    if show_speed:\n        print('speed_download: {:.1f} KiB/s, speed_upload: {:.1f} KiB/s'.format(d['speed_download'] / 1024, d['speed_upload'] / 1024))",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    args = sys.argv[1:]\n    if not args:\n        print_help()\n        quit(None, 0)\n    show_body = 'true' in ENV_SHOW_BODY.get('false').lower()\n    show_ip = 'true' in ENV_SHOW_IP.get('true').lower()\n    show_speed = 'true' in ENV_SHOW_SPEED.get('false').lower()\n    save_body = 'true' in ENV_SAVE_BODY.get('true').lower()\n    curl_bin = ENV_CURL_BIN.get('curl')\n    metrics_only = 'true' in ENV_METRICS_ONLY.get('false').lower()\n    is_debug = 'true' in ENV_DEBUG.get('false').lower()\n    if is_debug:\n        log_level = logging.DEBUG\n    else:\n        log_level = logging.INFO\n    logging.basicConfig(level=log_level)\n    lg = logging.getLogger('httpstat')\n    lg.debug('Envs:\\n%s', '\\n'.join(('  {}={}'.format(i.key, i.get('')) for i in Env._instances)))\n    lg.debug('Flags: %s', dict(show_body=show_body, show_ip=show_ip, show_speed=show_speed, save_body=save_body, curl_bin=curl_bin, is_debug=is_debug))\n    url = args[0]\n    if url in ['-h', '--help']:\n        print_help()\n        quit(None, 0)\n    elif url == '--version':\n        print('httpstat {}'.format(__version__))\n        quit(None, 0)\n    curl_args = args[1:]\n    exclude_options = ['-w', '--write-out', '-D', '--dump-header', '-o', '--output', '-s', '--silent']\n    for i in exclude_options:\n        if i in curl_args:\n            quit(yellow('Error: {} is not allowed in extra curl args'.format(i)), 1)\n    bodyf = tempfile.NamedTemporaryFile(delete=False)\n    bodyf.close()\n    headerf = tempfile.NamedTemporaryFile(delete=False)\n    headerf.close()\n    cmd_env = os.environ.copy()\n    cmd_env.update(LC_ALL='C')\n    cmd_core = [curl_bin, '-w', curl_format, '-D', headerf.name, '-o', bodyf.name, '-s', '-S']\n    cmd = cmd_core + curl_args + [url]\n    lg.debug('cmd: %s', cmd)\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=cmd_env)\n    (out, err) = p.communicate()\n    if PY3:\n        (out, err) = (out.decode(), err.decode())\n    lg.debug('out: %s', out)\n    if p.returncode == 0:\n        if err:\n            print(grayscale[16](err))\n    else:\n        _cmd = list(cmd)\n        _cmd[2] = '<output-format>'\n        _cmd[4] = '<tempfile>'\n        _cmd[6] = '<tempfile>'\n        print('> {}'.format(' '.join(_cmd)))\n        quit(yellow('curl error: {}'.format(err)), p.returncode)\n    try:\n        d = json.loads(out)\n    except ValueError as e:\n        print(yellow('Could not decode json: {}'.format(e)))\n        print('curl result:', p.returncode, grayscale[16](out), grayscale[16](err))\n        quit(None, 1)\n    for k in d:\n        if k.startswith('time_'):\n            v = d[k]\n            if isinstance(v, float):\n                d[k] = int(v * 1000)\n            elif isinstance(v, int):\n                d[k] = int(v / 1000)\n            else:\n                raise TypeError('{} value type is invalid: {}'.format(k, type(v)))\n    d.update(range_dns=d['time_namelookup'], range_connection=d['time_connect'] - d['time_namelookup'], range_ssl=d['time_pretransfer'] - d['time_connect'], range_server=d['time_starttransfer'] - d['time_pretransfer'], range_transfer=d['time_total'] - d['time_starttransfer'])\n    if metrics_only:\n        print(json.dumps(d, indent=2))\n        quit(None, 0)\n    if show_ip:\n        s = 'Connected to {}:{} from {}:{}'.format(cyan(d['remote_ip']), cyan(d['remote_port']), d['local_ip'], d['local_port'])\n        print(s)\n        print()\n    with open(headerf.name, 'r') as f:\n        headers = f.read().strip()\n    lg.debug('rm header file %s', headerf.name)\n    os.remove(headerf.name)\n    for (loop, line) in enumerate(headers.split('\\n')):\n        if loop == 0:\n            (p1, p2) = tuple(line.split('/'))\n            print(green(p1) + grayscale[14]('/') + cyan(p2))\n        else:\n            pos = line.find(':')\n            print(grayscale[14](line[:pos + 1]) + cyan(line[pos + 1:]))\n    print()\n    if show_body:\n        body_limit = 1024\n        with open(bodyf.name, 'r') as f:\n            body = f.read().strip()\n        body_len = len(body)\n        if body_len > body_limit:\n            print(body[:body_limit] + cyan('...'))\n            print()\n            s = '{} is truncated ({} out of {})'.format(green('Body'), body_limit, body_len)\n            if save_body:\n                s += ', stored in: {}'.format(bodyf.name)\n            print(s)\n        else:\n            print(body)\n    elif save_body:\n        print('{} stored in: {}'.format(green('Body'), bodyf.name))\n    if not save_body:\n        lg.debug('rm body file %s', bodyf.name)\n        os.remove(bodyf.name)\n    if url.startswith('https://'):\n        template = https_template\n    else:\n        template = http_template\n    tpl_parts = template.split('\\n')\n    tpl_parts[0] = grayscale[16](tpl_parts[0])\n    template = '\\n'.join(tpl_parts)\n\n    def fmta(s):\n        return cyan('{:^7}'.format(str(s) + 'ms'))\n\n    def fmtb(s):\n        return cyan('{:<7}'.format(str(s) + 'ms'))\n    stat = template.format(a0000=fmta(d['range_dns']), a0001=fmta(d['range_connection']), a0002=fmta(d['range_ssl']), a0003=fmta(d['range_server']), a0004=fmta(d['range_transfer']), b0000=fmtb(d['time_namelookup']), b0001=fmtb(d['time_connect']), b0002=fmtb(d['time_pretransfer']), b0003=fmtb(d['time_starttransfer']), b0004=fmtb(d['time_total']))\n    print()\n    print(stat)\n    if show_speed:\n        print('speed_download: {:.1f} KiB/s, speed_upload: {:.1f} KiB/s'.format(d['speed_download'] / 1024, d['speed_upload'] / 1024))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    args = sys.argv[1:]\n    if not args:\n        print_help()\n        quit(None, 0)\n    show_body = 'true' in ENV_SHOW_BODY.get('false').lower()\n    show_ip = 'true' in ENV_SHOW_IP.get('true').lower()\n    show_speed = 'true' in ENV_SHOW_SPEED.get('false').lower()\n    save_body = 'true' in ENV_SAVE_BODY.get('true').lower()\n    curl_bin = ENV_CURL_BIN.get('curl')\n    metrics_only = 'true' in ENV_METRICS_ONLY.get('false').lower()\n    is_debug = 'true' in ENV_DEBUG.get('false').lower()\n    if is_debug:\n        log_level = logging.DEBUG\n    else:\n        log_level = logging.INFO\n    logging.basicConfig(level=log_level)\n    lg = logging.getLogger('httpstat')\n    lg.debug('Envs:\\n%s', '\\n'.join(('  {}={}'.format(i.key, i.get('')) for i in Env._instances)))\n    lg.debug('Flags: %s', dict(show_body=show_body, show_ip=show_ip, show_speed=show_speed, save_body=save_body, curl_bin=curl_bin, is_debug=is_debug))\n    url = args[0]\n    if url in ['-h', '--help']:\n        print_help()\n        quit(None, 0)\n    elif url == '--version':\n        print('httpstat {}'.format(__version__))\n        quit(None, 0)\n    curl_args = args[1:]\n    exclude_options = ['-w', '--write-out', '-D', '--dump-header', '-o', '--output', '-s', '--silent']\n    for i in exclude_options:\n        if i in curl_args:\n            quit(yellow('Error: {} is not allowed in extra curl args'.format(i)), 1)\n    bodyf = tempfile.NamedTemporaryFile(delete=False)\n    bodyf.close()\n    headerf = tempfile.NamedTemporaryFile(delete=False)\n    headerf.close()\n    cmd_env = os.environ.copy()\n    cmd_env.update(LC_ALL='C')\n    cmd_core = [curl_bin, '-w', curl_format, '-D', headerf.name, '-o', bodyf.name, '-s', '-S']\n    cmd = cmd_core + curl_args + [url]\n    lg.debug('cmd: %s', cmd)\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=cmd_env)\n    (out, err) = p.communicate()\n    if PY3:\n        (out, err) = (out.decode(), err.decode())\n    lg.debug('out: %s', out)\n    if p.returncode == 0:\n        if err:\n            print(grayscale[16](err))\n    else:\n        _cmd = list(cmd)\n        _cmd[2] = '<output-format>'\n        _cmd[4] = '<tempfile>'\n        _cmd[6] = '<tempfile>'\n        print('> {}'.format(' '.join(_cmd)))\n        quit(yellow('curl error: {}'.format(err)), p.returncode)\n    try:\n        d = json.loads(out)\n    except ValueError as e:\n        print(yellow('Could not decode json: {}'.format(e)))\n        print('curl result:', p.returncode, grayscale[16](out), grayscale[16](err))\n        quit(None, 1)\n    for k in d:\n        if k.startswith('time_'):\n            v = d[k]\n            if isinstance(v, float):\n                d[k] = int(v * 1000)\n            elif isinstance(v, int):\n                d[k] = int(v / 1000)\n            else:\n                raise TypeError('{} value type is invalid: {}'.format(k, type(v)))\n    d.update(range_dns=d['time_namelookup'], range_connection=d['time_connect'] - d['time_namelookup'], range_ssl=d['time_pretransfer'] - d['time_connect'], range_server=d['time_starttransfer'] - d['time_pretransfer'], range_transfer=d['time_total'] - d['time_starttransfer'])\n    if metrics_only:\n        print(json.dumps(d, indent=2))\n        quit(None, 0)\n    if show_ip:\n        s = 'Connected to {}:{} from {}:{}'.format(cyan(d['remote_ip']), cyan(d['remote_port']), d['local_ip'], d['local_port'])\n        print(s)\n        print()\n    with open(headerf.name, 'r') as f:\n        headers = f.read().strip()\n    lg.debug('rm header file %s', headerf.name)\n    os.remove(headerf.name)\n    for (loop, line) in enumerate(headers.split('\\n')):\n        if loop == 0:\n            (p1, p2) = tuple(line.split('/'))\n            print(green(p1) + grayscale[14]('/') + cyan(p2))\n        else:\n            pos = line.find(':')\n            print(grayscale[14](line[:pos + 1]) + cyan(line[pos + 1:]))\n    print()\n    if show_body:\n        body_limit = 1024\n        with open(bodyf.name, 'r') as f:\n            body = f.read().strip()\n        body_len = len(body)\n        if body_len > body_limit:\n            print(body[:body_limit] + cyan('...'))\n            print()\n            s = '{} is truncated ({} out of {})'.format(green('Body'), body_limit, body_len)\n            if save_body:\n                s += ', stored in: {}'.format(bodyf.name)\n            print(s)\n        else:\n            print(body)\n    elif save_body:\n        print('{} stored in: {}'.format(green('Body'), bodyf.name))\n    if not save_body:\n        lg.debug('rm body file %s', bodyf.name)\n        os.remove(bodyf.name)\n    if url.startswith('https://'):\n        template = https_template\n    else:\n        template = http_template\n    tpl_parts = template.split('\\n')\n    tpl_parts[0] = grayscale[16](tpl_parts[0])\n    template = '\\n'.join(tpl_parts)\n\n    def fmta(s):\n        return cyan('{:^7}'.format(str(s) + 'ms'))\n\n    def fmtb(s):\n        return cyan('{:<7}'.format(str(s) + 'ms'))\n    stat = template.format(a0000=fmta(d['range_dns']), a0001=fmta(d['range_connection']), a0002=fmta(d['range_ssl']), a0003=fmta(d['range_server']), a0004=fmta(d['range_transfer']), b0000=fmtb(d['time_namelookup']), b0001=fmtb(d['time_connect']), b0002=fmtb(d['time_pretransfer']), b0003=fmtb(d['time_starttransfer']), b0004=fmtb(d['time_total']))\n    print()\n    print(stat)\n    if show_speed:\n        print('speed_download: {:.1f} KiB/s, speed_upload: {:.1f} KiB/s'.format(d['speed_download'] / 1024, d['speed_upload'] / 1024))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    args = sys.argv[1:]\n    if not args:\n        print_help()\n        quit(None, 0)\n    show_body = 'true' in ENV_SHOW_BODY.get('false').lower()\n    show_ip = 'true' in ENV_SHOW_IP.get('true').lower()\n    show_speed = 'true' in ENV_SHOW_SPEED.get('false').lower()\n    save_body = 'true' in ENV_SAVE_BODY.get('true').lower()\n    curl_bin = ENV_CURL_BIN.get('curl')\n    metrics_only = 'true' in ENV_METRICS_ONLY.get('false').lower()\n    is_debug = 'true' in ENV_DEBUG.get('false').lower()\n    if is_debug:\n        log_level = logging.DEBUG\n    else:\n        log_level = logging.INFO\n    logging.basicConfig(level=log_level)\n    lg = logging.getLogger('httpstat')\n    lg.debug('Envs:\\n%s', '\\n'.join(('  {}={}'.format(i.key, i.get('')) for i in Env._instances)))\n    lg.debug('Flags: %s', dict(show_body=show_body, show_ip=show_ip, show_speed=show_speed, save_body=save_body, curl_bin=curl_bin, is_debug=is_debug))\n    url = args[0]\n    if url in ['-h', '--help']:\n        print_help()\n        quit(None, 0)\n    elif url == '--version':\n        print('httpstat {}'.format(__version__))\n        quit(None, 0)\n    curl_args = args[1:]\n    exclude_options = ['-w', '--write-out', '-D', '--dump-header', '-o', '--output', '-s', '--silent']\n    for i in exclude_options:\n        if i in curl_args:\n            quit(yellow('Error: {} is not allowed in extra curl args'.format(i)), 1)\n    bodyf = tempfile.NamedTemporaryFile(delete=False)\n    bodyf.close()\n    headerf = tempfile.NamedTemporaryFile(delete=False)\n    headerf.close()\n    cmd_env = os.environ.copy()\n    cmd_env.update(LC_ALL='C')\n    cmd_core = [curl_bin, '-w', curl_format, '-D', headerf.name, '-o', bodyf.name, '-s', '-S']\n    cmd = cmd_core + curl_args + [url]\n    lg.debug('cmd: %s', cmd)\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=cmd_env)\n    (out, err) = p.communicate()\n    if PY3:\n        (out, err) = (out.decode(), err.decode())\n    lg.debug('out: %s', out)\n    if p.returncode == 0:\n        if err:\n            print(grayscale[16](err))\n    else:\n        _cmd = list(cmd)\n        _cmd[2] = '<output-format>'\n        _cmd[4] = '<tempfile>'\n        _cmd[6] = '<tempfile>'\n        print('> {}'.format(' '.join(_cmd)))\n        quit(yellow('curl error: {}'.format(err)), p.returncode)\n    try:\n        d = json.loads(out)\n    except ValueError as e:\n        print(yellow('Could not decode json: {}'.format(e)))\n        print('curl result:', p.returncode, grayscale[16](out), grayscale[16](err))\n        quit(None, 1)\n    for k in d:\n        if k.startswith('time_'):\n            v = d[k]\n            if isinstance(v, float):\n                d[k] = int(v * 1000)\n            elif isinstance(v, int):\n                d[k] = int(v / 1000)\n            else:\n                raise TypeError('{} value type is invalid: {}'.format(k, type(v)))\n    d.update(range_dns=d['time_namelookup'], range_connection=d['time_connect'] - d['time_namelookup'], range_ssl=d['time_pretransfer'] - d['time_connect'], range_server=d['time_starttransfer'] - d['time_pretransfer'], range_transfer=d['time_total'] - d['time_starttransfer'])\n    if metrics_only:\n        print(json.dumps(d, indent=2))\n        quit(None, 0)\n    if show_ip:\n        s = 'Connected to {}:{} from {}:{}'.format(cyan(d['remote_ip']), cyan(d['remote_port']), d['local_ip'], d['local_port'])\n        print(s)\n        print()\n    with open(headerf.name, 'r') as f:\n        headers = f.read().strip()\n    lg.debug('rm header file %s', headerf.name)\n    os.remove(headerf.name)\n    for (loop, line) in enumerate(headers.split('\\n')):\n        if loop == 0:\n            (p1, p2) = tuple(line.split('/'))\n            print(green(p1) + grayscale[14]('/') + cyan(p2))\n        else:\n            pos = line.find(':')\n            print(grayscale[14](line[:pos + 1]) + cyan(line[pos + 1:]))\n    print()\n    if show_body:\n        body_limit = 1024\n        with open(bodyf.name, 'r') as f:\n            body = f.read().strip()\n        body_len = len(body)\n        if body_len > body_limit:\n            print(body[:body_limit] + cyan('...'))\n            print()\n            s = '{} is truncated ({} out of {})'.format(green('Body'), body_limit, body_len)\n            if save_body:\n                s += ', stored in: {}'.format(bodyf.name)\n            print(s)\n        else:\n            print(body)\n    elif save_body:\n        print('{} stored in: {}'.format(green('Body'), bodyf.name))\n    if not save_body:\n        lg.debug('rm body file %s', bodyf.name)\n        os.remove(bodyf.name)\n    if url.startswith('https://'):\n        template = https_template\n    else:\n        template = http_template\n    tpl_parts = template.split('\\n')\n    tpl_parts[0] = grayscale[16](tpl_parts[0])\n    template = '\\n'.join(tpl_parts)\n\n    def fmta(s):\n        return cyan('{:^7}'.format(str(s) + 'ms'))\n\n    def fmtb(s):\n        return cyan('{:<7}'.format(str(s) + 'ms'))\n    stat = template.format(a0000=fmta(d['range_dns']), a0001=fmta(d['range_connection']), a0002=fmta(d['range_ssl']), a0003=fmta(d['range_server']), a0004=fmta(d['range_transfer']), b0000=fmtb(d['time_namelookup']), b0001=fmtb(d['time_connect']), b0002=fmtb(d['time_pretransfer']), b0003=fmtb(d['time_starttransfer']), b0004=fmtb(d['time_total']))\n    print()\n    print(stat)\n    if show_speed:\n        print('speed_download: {:.1f} KiB/s, speed_upload: {:.1f} KiB/s'.format(d['speed_download'] / 1024, d['speed_upload'] / 1024))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    args = sys.argv[1:]\n    if not args:\n        print_help()\n        quit(None, 0)\n    show_body = 'true' in ENV_SHOW_BODY.get('false').lower()\n    show_ip = 'true' in ENV_SHOW_IP.get('true').lower()\n    show_speed = 'true' in ENV_SHOW_SPEED.get('false').lower()\n    save_body = 'true' in ENV_SAVE_BODY.get('true').lower()\n    curl_bin = ENV_CURL_BIN.get('curl')\n    metrics_only = 'true' in ENV_METRICS_ONLY.get('false').lower()\n    is_debug = 'true' in ENV_DEBUG.get('false').lower()\n    if is_debug:\n        log_level = logging.DEBUG\n    else:\n        log_level = logging.INFO\n    logging.basicConfig(level=log_level)\n    lg = logging.getLogger('httpstat')\n    lg.debug('Envs:\\n%s', '\\n'.join(('  {}={}'.format(i.key, i.get('')) for i in Env._instances)))\n    lg.debug('Flags: %s', dict(show_body=show_body, show_ip=show_ip, show_speed=show_speed, save_body=save_body, curl_bin=curl_bin, is_debug=is_debug))\n    url = args[0]\n    if url in ['-h', '--help']:\n        print_help()\n        quit(None, 0)\n    elif url == '--version':\n        print('httpstat {}'.format(__version__))\n        quit(None, 0)\n    curl_args = args[1:]\n    exclude_options = ['-w', '--write-out', '-D', '--dump-header', '-o', '--output', '-s', '--silent']\n    for i in exclude_options:\n        if i in curl_args:\n            quit(yellow('Error: {} is not allowed in extra curl args'.format(i)), 1)\n    bodyf = tempfile.NamedTemporaryFile(delete=False)\n    bodyf.close()\n    headerf = tempfile.NamedTemporaryFile(delete=False)\n    headerf.close()\n    cmd_env = os.environ.copy()\n    cmd_env.update(LC_ALL='C')\n    cmd_core = [curl_bin, '-w', curl_format, '-D', headerf.name, '-o', bodyf.name, '-s', '-S']\n    cmd = cmd_core + curl_args + [url]\n    lg.debug('cmd: %s', cmd)\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=cmd_env)\n    (out, err) = p.communicate()\n    if PY3:\n        (out, err) = (out.decode(), err.decode())\n    lg.debug('out: %s', out)\n    if p.returncode == 0:\n        if err:\n            print(grayscale[16](err))\n    else:\n        _cmd = list(cmd)\n        _cmd[2] = '<output-format>'\n        _cmd[4] = '<tempfile>'\n        _cmd[6] = '<tempfile>'\n        print('> {}'.format(' '.join(_cmd)))\n        quit(yellow('curl error: {}'.format(err)), p.returncode)\n    try:\n        d = json.loads(out)\n    except ValueError as e:\n        print(yellow('Could not decode json: {}'.format(e)))\n        print('curl result:', p.returncode, grayscale[16](out), grayscale[16](err))\n        quit(None, 1)\n    for k in d:\n        if k.startswith('time_'):\n            v = d[k]\n            if isinstance(v, float):\n                d[k] = int(v * 1000)\n            elif isinstance(v, int):\n                d[k] = int(v / 1000)\n            else:\n                raise TypeError('{} value type is invalid: {}'.format(k, type(v)))\n    d.update(range_dns=d['time_namelookup'], range_connection=d['time_connect'] - d['time_namelookup'], range_ssl=d['time_pretransfer'] - d['time_connect'], range_server=d['time_starttransfer'] - d['time_pretransfer'], range_transfer=d['time_total'] - d['time_starttransfer'])\n    if metrics_only:\n        print(json.dumps(d, indent=2))\n        quit(None, 0)\n    if show_ip:\n        s = 'Connected to {}:{} from {}:{}'.format(cyan(d['remote_ip']), cyan(d['remote_port']), d['local_ip'], d['local_port'])\n        print(s)\n        print()\n    with open(headerf.name, 'r') as f:\n        headers = f.read().strip()\n    lg.debug('rm header file %s', headerf.name)\n    os.remove(headerf.name)\n    for (loop, line) in enumerate(headers.split('\\n')):\n        if loop == 0:\n            (p1, p2) = tuple(line.split('/'))\n            print(green(p1) + grayscale[14]('/') + cyan(p2))\n        else:\n            pos = line.find(':')\n            print(grayscale[14](line[:pos + 1]) + cyan(line[pos + 1:]))\n    print()\n    if show_body:\n        body_limit = 1024\n        with open(bodyf.name, 'r') as f:\n            body = f.read().strip()\n        body_len = len(body)\n        if body_len > body_limit:\n            print(body[:body_limit] + cyan('...'))\n            print()\n            s = '{} is truncated ({} out of {})'.format(green('Body'), body_limit, body_len)\n            if save_body:\n                s += ', stored in: {}'.format(bodyf.name)\n            print(s)\n        else:\n            print(body)\n    elif save_body:\n        print('{} stored in: {}'.format(green('Body'), bodyf.name))\n    if not save_body:\n        lg.debug('rm body file %s', bodyf.name)\n        os.remove(bodyf.name)\n    if url.startswith('https://'):\n        template = https_template\n    else:\n        template = http_template\n    tpl_parts = template.split('\\n')\n    tpl_parts[0] = grayscale[16](tpl_parts[0])\n    template = '\\n'.join(tpl_parts)\n\n    def fmta(s):\n        return cyan('{:^7}'.format(str(s) + 'ms'))\n\n    def fmtb(s):\n        return cyan('{:<7}'.format(str(s) + 'ms'))\n    stat = template.format(a0000=fmta(d['range_dns']), a0001=fmta(d['range_connection']), a0002=fmta(d['range_ssl']), a0003=fmta(d['range_server']), a0004=fmta(d['range_transfer']), b0000=fmtb(d['time_namelookup']), b0001=fmtb(d['time_connect']), b0002=fmtb(d['time_pretransfer']), b0003=fmtb(d['time_starttransfer']), b0004=fmtb(d['time_total']))\n    print()\n    print(stat)\n    if show_speed:\n        print('speed_download: {:.1f} KiB/s, speed_upload: {:.1f} KiB/s'.format(d['speed_download'] / 1024, d['speed_upload'] / 1024))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    args = sys.argv[1:]\n    if not args:\n        print_help()\n        quit(None, 0)\n    show_body = 'true' in ENV_SHOW_BODY.get('false').lower()\n    show_ip = 'true' in ENV_SHOW_IP.get('true').lower()\n    show_speed = 'true' in ENV_SHOW_SPEED.get('false').lower()\n    save_body = 'true' in ENV_SAVE_BODY.get('true').lower()\n    curl_bin = ENV_CURL_BIN.get('curl')\n    metrics_only = 'true' in ENV_METRICS_ONLY.get('false').lower()\n    is_debug = 'true' in ENV_DEBUG.get('false').lower()\n    if is_debug:\n        log_level = logging.DEBUG\n    else:\n        log_level = logging.INFO\n    logging.basicConfig(level=log_level)\n    lg = logging.getLogger('httpstat')\n    lg.debug('Envs:\\n%s', '\\n'.join(('  {}={}'.format(i.key, i.get('')) for i in Env._instances)))\n    lg.debug('Flags: %s', dict(show_body=show_body, show_ip=show_ip, show_speed=show_speed, save_body=save_body, curl_bin=curl_bin, is_debug=is_debug))\n    url = args[0]\n    if url in ['-h', '--help']:\n        print_help()\n        quit(None, 0)\n    elif url == '--version':\n        print('httpstat {}'.format(__version__))\n        quit(None, 0)\n    curl_args = args[1:]\n    exclude_options = ['-w', '--write-out', '-D', '--dump-header', '-o', '--output', '-s', '--silent']\n    for i in exclude_options:\n        if i in curl_args:\n            quit(yellow('Error: {} is not allowed in extra curl args'.format(i)), 1)\n    bodyf = tempfile.NamedTemporaryFile(delete=False)\n    bodyf.close()\n    headerf = tempfile.NamedTemporaryFile(delete=False)\n    headerf.close()\n    cmd_env = os.environ.copy()\n    cmd_env.update(LC_ALL='C')\n    cmd_core = [curl_bin, '-w', curl_format, '-D', headerf.name, '-o', bodyf.name, '-s', '-S']\n    cmd = cmd_core + curl_args + [url]\n    lg.debug('cmd: %s', cmd)\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=cmd_env)\n    (out, err) = p.communicate()\n    if PY3:\n        (out, err) = (out.decode(), err.decode())\n    lg.debug('out: %s', out)\n    if p.returncode == 0:\n        if err:\n            print(grayscale[16](err))\n    else:\n        _cmd = list(cmd)\n        _cmd[2] = '<output-format>'\n        _cmd[4] = '<tempfile>'\n        _cmd[6] = '<tempfile>'\n        print('> {}'.format(' '.join(_cmd)))\n        quit(yellow('curl error: {}'.format(err)), p.returncode)\n    try:\n        d = json.loads(out)\n    except ValueError as e:\n        print(yellow('Could not decode json: {}'.format(e)))\n        print('curl result:', p.returncode, grayscale[16](out), grayscale[16](err))\n        quit(None, 1)\n    for k in d:\n        if k.startswith('time_'):\n            v = d[k]\n            if isinstance(v, float):\n                d[k] = int(v * 1000)\n            elif isinstance(v, int):\n                d[k] = int(v / 1000)\n            else:\n                raise TypeError('{} value type is invalid: {}'.format(k, type(v)))\n    d.update(range_dns=d['time_namelookup'], range_connection=d['time_connect'] - d['time_namelookup'], range_ssl=d['time_pretransfer'] - d['time_connect'], range_server=d['time_starttransfer'] - d['time_pretransfer'], range_transfer=d['time_total'] - d['time_starttransfer'])\n    if metrics_only:\n        print(json.dumps(d, indent=2))\n        quit(None, 0)\n    if show_ip:\n        s = 'Connected to {}:{} from {}:{}'.format(cyan(d['remote_ip']), cyan(d['remote_port']), d['local_ip'], d['local_port'])\n        print(s)\n        print()\n    with open(headerf.name, 'r') as f:\n        headers = f.read().strip()\n    lg.debug('rm header file %s', headerf.name)\n    os.remove(headerf.name)\n    for (loop, line) in enumerate(headers.split('\\n')):\n        if loop == 0:\n            (p1, p2) = tuple(line.split('/'))\n            print(green(p1) + grayscale[14]('/') + cyan(p2))\n        else:\n            pos = line.find(':')\n            print(grayscale[14](line[:pos + 1]) + cyan(line[pos + 1:]))\n    print()\n    if show_body:\n        body_limit = 1024\n        with open(bodyf.name, 'r') as f:\n            body = f.read().strip()\n        body_len = len(body)\n        if body_len > body_limit:\n            print(body[:body_limit] + cyan('...'))\n            print()\n            s = '{} is truncated ({} out of {})'.format(green('Body'), body_limit, body_len)\n            if save_body:\n                s += ', stored in: {}'.format(bodyf.name)\n            print(s)\n        else:\n            print(body)\n    elif save_body:\n        print('{} stored in: {}'.format(green('Body'), bodyf.name))\n    if not save_body:\n        lg.debug('rm body file %s', bodyf.name)\n        os.remove(bodyf.name)\n    if url.startswith('https://'):\n        template = https_template\n    else:\n        template = http_template\n    tpl_parts = template.split('\\n')\n    tpl_parts[0] = grayscale[16](tpl_parts[0])\n    template = '\\n'.join(tpl_parts)\n\n    def fmta(s):\n        return cyan('{:^7}'.format(str(s) + 'ms'))\n\n    def fmtb(s):\n        return cyan('{:<7}'.format(str(s) + 'ms'))\n    stat = template.format(a0000=fmta(d['range_dns']), a0001=fmta(d['range_connection']), a0002=fmta(d['range_ssl']), a0003=fmta(d['range_server']), a0004=fmta(d['range_transfer']), b0000=fmtb(d['time_namelookup']), b0001=fmtb(d['time_connect']), b0002=fmtb(d['time_pretransfer']), b0003=fmtb(d['time_starttransfer']), b0004=fmtb(d['time_total']))\n    print()\n    print(stat)\n    if show_speed:\n        print('speed_download: {:.1f} KiB/s, speed_upload: {:.1f} KiB/s'.format(d['speed_download'] / 1024, d['speed_upload'] / 1024))"
        ]
    }
]