[
    {
        "func_name": "accuracy",
        "original": "def accuracy(outputs: torch.Tensor, targets: torch.Tensor, topk: Sequence[int]=(1,)) -> Sequence[torch.Tensor]:\n    \"\"\"\n    Computes multiclass accuracy@topk for the specified values of `topk`.\n\n    Args:\n        outputs: model outputs, logits\n            with shape [bs; num_classes]\n        targets: ground truth, labels\n            with shape [bs; 1]\n        topk: `topk` for accuracy@topk computing\n\n    Returns:\n        list with computed accuracy@topk\n\n    Examples:\n\n    .. code-block:: python\n\n        import torch\n        from catalyst import metrics\n        metrics.accuracy(\n            outputs=torch.tensor([\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1],\n            ]),\n            targets=torch.tensor([0, 1, 2]),\n        )\n        # [tensor([1.])]\n\n    .. code-block:: python\n\n        import torch\n        from catalyst import metrics\n        metrics.accuracy(\n            outputs=torch.tensor([\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 1, 0],\n            ]),\n            targets=torch.tensor([0, 1, 2]),\n        )\n        # [tensor([0.6667])]\n\n    .. code-block:: python\n\n        import torch\n        from catalyst import metrics\n        metrics.accuracy(\n            outputs=torch.tensor([\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1],\n            ]),\n            targets=torch.tensor([0, 1, 2]),\n            topk=[1, 3],\n        )\n        # [tensor([1.]), tensor([1.])]\n\n    .. code-block:: python\n\n        import torch\n        from catalyst import metrics\n        metrics.accuracy(\n            outputs=torch.tensor([\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 1, 0],\n            ]),\n            targets=torch.tensor([0, 1, 2]),\n            topk=[1, 3],\n        )\n        # [tensor([0.6667]), tensor([1.])]\n    \"\"\"\n    max_k = max(topk)\n    batch_size = targets.size(0)\n    if len(outputs.shape) == 1 or outputs.shape[1] == 1:\n        pred = outputs.t()\n    else:\n        (_, pred) = outputs.topk(max_k, 1, True, True)\n        pred = pred.t()\n    correct = pred.eq(targets.long().view(1, -1).expand_as(pred))\n    output = []\n    for k in topk:\n        correct_k = correct[:k].contiguous().view(-1).float().sum(0, keepdim=True)\n        output.append(correct_k.mul_(1.0 / batch_size))\n    return output",
        "mutated": [
            "def accuracy(outputs: torch.Tensor, targets: torch.Tensor, topk: Sequence[int]=(1,)) -> Sequence[torch.Tensor]:\n    if False:\n        i = 10\n    '\\n    Computes multiclass accuracy@topk for the specified values of `topk`.\\n\\n    Args:\\n        outputs: model outputs, logits\\n            with shape [bs; num_classes]\\n        targets: ground truth, labels\\n            with shape [bs; 1]\\n        topk: `topk` for accuracy@topk computing\\n\\n    Returns:\\n        list with computed accuracy@topk\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([0.6667])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([1.]), tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([0.6667]), tensor([1.])]\\n    '\n    max_k = max(topk)\n    batch_size = targets.size(0)\n    if len(outputs.shape) == 1 or outputs.shape[1] == 1:\n        pred = outputs.t()\n    else:\n        (_, pred) = outputs.topk(max_k, 1, True, True)\n        pred = pred.t()\n    correct = pred.eq(targets.long().view(1, -1).expand_as(pred))\n    output = []\n    for k in topk:\n        correct_k = correct[:k].contiguous().view(-1).float().sum(0, keepdim=True)\n        output.append(correct_k.mul_(1.0 / batch_size))\n    return output",
            "def accuracy(outputs: torch.Tensor, targets: torch.Tensor, topk: Sequence[int]=(1,)) -> Sequence[torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes multiclass accuracy@topk for the specified values of `topk`.\\n\\n    Args:\\n        outputs: model outputs, logits\\n            with shape [bs; num_classes]\\n        targets: ground truth, labels\\n            with shape [bs; 1]\\n        topk: `topk` for accuracy@topk computing\\n\\n    Returns:\\n        list with computed accuracy@topk\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([0.6667])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([1.]), tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([0.6667]), tensor([1.])]\\n    '\n    max_k = max(topk)\n    batch_size = targets.size(0)\n    if len(outputs.shape) == 1 or outputs.shape[1] == 1:\n        pred = outputs.t()\n    else:\n        (_, pred) = outputs.topk(max_k, 1, True, True)\n        pred = pred.t()\n    correct = pred.eq(targets.long().view(1, -1).expand_as(pred))\n    output = []\n    for k in topk:\n        correct_k = correct[:k].contiguous().view(-1).float().sum(0, keepdim=True)\n        output.append(correct_k.mul_(1.0 / batch_size))\n    return output",
            "def accuracy(outputs: torch.Tensor, targets: torch.Tensor, topk: Sequence[int]=(1,)) -> Sequence[torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes multiclass accuracy@topk for the specified values of `topk`.\\n\\n    Args:\\n        outputs: model outputs, logits\\n            with shape [bs; num_classes]\\n        targets: ground truth, labels\\n            with shape [bs; 1]\\n        topk: `topk` for accuracy@topk computing\\n\\n    Returns:\\n        list with computed accuracy@topk\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([0.6667])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([1.]), tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([0.6667]), tensor([1.])]\\n    '\n    max_k = max(topk)\n    batch_size = targets.size(0)\n    if len(outputs.shape) == 1 or outputs.shape[1] == 1:\n        pred = outputs.t()\n    else:\n        (_, pred) = outputs.topk(max_k, 1, True, True)\n        pred = pred.t()\n    correct = pred.eq(targets.long().view(1, -1).expand_as(pred))\n    output = []\n    for k in topk:\n        correct_k = correct[:k].contiguous().view(-1).float().sum(0, keepdim=True)\n        output.append(correct_k.mul_(1.0 / batch_size))\n    return output",
            "def accuracy(outputs: torch.Tensor, targets: torch.Tensor, topk: Sequence[int]=(1,)) -> Sequence[torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes multiclass accuracy@topk for the specified values of `topk`.\\n\\n    Args:\\n        outputs: model outputs, logits\\n            with shape [bs; num_classes]\\n        targets: ground truth, labels\\n            with shape [bs; 1]\\n        topk: `topk` for accuracy@topk computing\\n\\n    Returns:\\n        list with computed accuracy@topk\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([0.6667])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([1.]), tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([0.6667]), tensor([1.])]\\n    '\n    max_k = max(topk)\n    batch_size = targets.size(0)\n    if len(outputs.shape) == 1 or outputs.shape[1] == 1:\n        pred = outputs.t()\n    else:\n        (_, pred) = outputs.topk(max_k, 1, True, True)\n        pred = pred.t()\n    correct = pred.eq(targets.long().view(1, -1).expand_as(pred))\n    output = []\n    for k in topk:\n        correct_k = correct[:k].contiguous().view(-1).float().sum(0, keepdim=True)\n        output.append(correct_k.mul_(1.0 / batch_size))\n    return output",
            "def accuracy(outputs: torch.Tensor, targets: torch.Tensor, topk: Sequence[int]=(1,)) -> Sequence[torch.Tensor]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes multiclass accuracy@topk for the specified values of `topk`.\\n\\n    Args:\\n        outputs: model outputs, logits\\n            with shape [bs; num_classes]\\n        targets: ground truth, labels\\n            with shape [bs; 1]\\n        topk: `topk` for accuracy@topk computing\\n\\n    Returns:\\n        list with computed accuracy@topk\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n        )\\n        # [tensor([0.6667])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 0, 1],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([1.]), tensor([1.])]\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.accuracy(\\n            outputs=torch.tensor([\\n                [1, 0, 0],\\n                [0, 1, 0],\\n                [0, 1, 0],\\n            ]),\\n            targets=torch.tensor([0, 1, 2]),\\n            topk=[1, 3],\\n        )\\n        # [tensor([0.6667]), tensor([1.])]\\n    '\n    max_k = max(topk)\n    batch_size = targets.size(0)\n    if len(outputs.shape) == 1 or outputs.shape[1] == 1:\n        pred = outputs.t()\n    else:\n        (_, pred) = outputs.topk(max_k, 1, True, True)\n        pred = pred.t()\n    correct = pred.eq(targets.long().view(1, -1).expand_as(pred))\n    output = []\n    for k in topk:\n        correct_k = correct[:k].contiguous().view(-1).float().sum(0, keepdim=True)\n        output.append(correct_k.mul_(1.0 / batch_size))\n    return output"
        ]
    },
    {
        "func_name": "multilabel_accuracy",
        "original": "def multilabel_accuracy(outputs: torch.Tensor, targets: torch.Tensor, threshold: Union[float, torch.Tensor]) -> torch.Tensor:\n    \"\"\"\n    Computes multilabel accuracy for the specified activation and threshold.\n\n    Args:\n        outputs: NxK tensor that for each of the N examples\n            indicates the probability of the example belonging to each of\n            the K classes, according to the model.\n        targets: binary NxK tensort that encodes which of the K\n            classes are associated with the N-th input\n            (eg: a row [0, 1, 0, 1] indicates that the example is\n            associated with classes 2 and 4)\n        threshold: threshold for for model output\n\n    Returns:\n        computed multilabel accuracy\n\n    Examples:\n\n    .. code-block:: python\n\n        import torch\n        from catalyst import metrics\n        metrics.multilabel_accuracy(\n            outputs=torch.tensor([\n                [1, 0],\n                [0, 1],\n            ]),\n            targets=torch.tensor([\n                [1, 0],\n                [0, 1],\n            ]),\n            threshold=0.5,\n        )\n        # tensor([1.])\n\n    .. code-block:: python\n\n        import torch\n        from catalyst import metrics\n        metrics.multilabel_accuracy(\n            outputs=torch.tensor([\n                [1.0, 0.0],\n                [0.6, 1.0],\n            ]),\n            targets=torch.tensor([\n                [1, 0],\n                [0, 1],\n            ]),\n            threshold=0.5,\n        )\n        # tensor(0.7500)\n\n    .. code-block:: python\n\n        import torch\n        from catalyst import metrics\n        metrics.multilabel_accuracy(\n            outputs=torch.tensor([\n                [1.0, 0.0],\n                [0.4, 1.0],\n            ]),\n            targets=torch.tensor([\n                [1, 0],\n                [0, 1],\n            ]),\n            threshold=0.5,\n        )\n        # tensor(1.0)\n    \"\"\"\n    (outputs, targets, _, _) = process_multilabel_components(outputs=outputs, targets=targets)\n    outputs = (outputs > threshold).long()\n    output = (targets.long() == outputs.long()).sum().float() / np.prod(targets.shape)\n    return output",
        "mutated": [
            "def multilabel_accuracy(outputs: torch.Tensor, targets: torch.Tensor, threshold: Union[float, torch.Tensor]) -> torch.Tensor:\n    if False:\n        i = 10\n    '\\n    Computes multilabel accuracy for the specified activation and threshold.\\n\\n    Args:\\n        outputs: NxK tensor that for each of the N examples\\n            indicates the probability of the example belonging to each of\\n            the K classes, according to the model.\\n        targets: binary NxK tensort that encodes which of the K\\n            classes are associated with the N-th input\\n            (eg: a row [0, 1, 0, 1] indicates that the example is\\n            associated with classes 2 and 4)\\n        threshold: threshold for for model output\\n\\n    Returns:\\n        computed multilabel accuracy\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor([1.])\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.6, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(0.7500)\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.4, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(1.0)\\n    '\n    (outputs, targets, _, _) = process_multilabel_components(outputs=outputs, targets=targets)\n    outputs = (outputs > threshold).long()\n    output = (targets.long() == outputs.long()).sum().float() / np.prod(targets.shape)\n    return output",
            "def multilabel_accuracy(outputs: torch.Tensor, targets: torch.Tensor, threshold: Union[float, torch.Tensor]) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Computes multilabel accuracy for the specified activation and threshold.\\n\\n    Args:\\n        outputs: NxK tensor that for each of the N examples\\n            indicates the probability of the example belonging to each of\\n            the K classes, according to the model.\\n        targets: binary NxK tensort that encodes which of the K\\n            classes are associated with the N-th input\\n            (eg: a row [0, 1, 0, 1] indicates that the example is\\n            associated with classes 2 and 4)\\n        threshold: threshold for for model output\\n\\n    Returns:\\n        computed multilabel accuracy\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor([1.])\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.6, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(0.7500)\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.4, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(1.0)\\n    '\n    (outputs, targets, _, _) = process_multilabel_components(outputs=outputs, targets=targets)\n    outputs = (outputs > threshold).long()\n    output = (targets.long() == outputs.long()).sum().float() / np.prod(targets.shape)\n    return output",
            "def multilabel_accuracy(outputs: torch.Tensor, targets: torch.Tensor, threshold: Union[float, torch.Tensor]) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Computes multilabel accuracy for the specified activation and threshold.\\n\\n    Args:\\n        outputs: NxK tensor that for each of the N examples\\n            indicates the probability of the example belonging to each of\\n            the K classes, according to the model.\\n        targets: binary NxK tensort that encodes which of the K\\n            classes are associated with the N-th input\\n            (eg: a row [0, 1, 0, 1] indicates that the example is\\n            associated with classes 2 and 4)\\n        threshold: threshold for for model output\\n\\n    Returns:\\n        computed multilabel accuracy\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor([1.])\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.6, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(0.7500)\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.4, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(1.0)\\n    '\n    (outputs, targets, _, _) = process_multilabel_components(outputs=outputs, targets=targets)\n    outputs = (outputs > threshold).long()\n    output = (targets.long() == outputs.long()).sum().float() / np.prod(targets.shape)\n    return output",
            "def multilabel_accuracy(outputs: torch.Tensor, targets: torch.Tensor, threshold: Union[float, torch.Tensor]) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Computes multilabel accuracy for the specified activation and threshold.\\n\\n    Args:\\n        outputs: NxK tensor that for each of the N examples\\n            indicates the probability of the example belonging to each of\\n            the K classes, according to the model.\\n        targets: binary NxK tensort that encodes which of the K\\n            classes are associated with the N-th input\\n            (eg: a row [0, 1, 0, 1] indicates that the example is\\n            associated with classes 2 and 4)\\n        threshold: threshold for for model output\\n\\n    Returns:\\n        computed multilabel accuracy\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor([1.])\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.6, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(0.7500)\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.4, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(1.0)\\n    '\n    (outputs, targets, _, _) = process_multilabel_components(outputs=outputs, targets=targets)\n    outputs = (outputs > threshold).long()\n    output = (targets.long() == outputs.long()).sum().float() / np.prod(targets.shape)\n    return output",
            "def multilabel_accuracy(outputs: torch.Tensor, targets: torch.Tensor, threshold: Union[float, torch.Tensor]) -> torch.Tensor:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Computes multilabel accuracy for the specified activation and threshold.\\n\\n    Args:\\n        outputs: NxK tensor that for each of the N examples\\n            indicates the probability of the example belonging to each of\\n            the K classes, according to the model.\\n        targets: binary NxK tensort that encodes which of the K\\n            classes are associated with the N-th input\\n            (eg: a row [0, 1, 0, 1] indicates that the example is\\n            associated with classes 2 and 4)\\n        threshold: threshold for for model output\\n\\n    Returns:\\n        computed multilabel accuracy\\n\\n    Examples:\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor([1.])\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.6, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(0.7500)\\n\\n    .. code-block:: python\\n\\n        import torch\\n        from catalyst import metrics\\n        metrics.multilabel_accuracy(\\n            outputs=torch.tensor([\\n                [1.0, 0.0],\\n                [0.4, 1.0],\\n            ]),\\n            targets=torch.tensor([\\n                [1, 0],\\n                [0, 1],\\n            ]),\\n            threshold=0.5,\\n        )\\n        # tensor(1.0)\\n    '\n    (outputs, targets, _, _) = process_multilabel_components(outputs=outputs, targets=targets)\n    outputs = (outputs > threshold).long()\n    output = (targets.long() == outputs.long()).sum().float() / np.prod(targets.shape)\n    return output"
        ]
    }
]