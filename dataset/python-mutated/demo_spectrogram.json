[
    {
        "func_name": "get_rounded_ticks",
        "original": "def get_rounded_ticks(top_pos, step, n_ticks):\n    top_label = top_pos * step\n    ticks_first_label = top_pos * step / n_ticks\n    ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n    ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n    ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n    ticks_labels = ['%.1f' % x for x in ticks_labels]\n    return (ticks_positions, ticks_labels)",
        "mutated": [
            "def get_rounded_ticks(top_pos, step, n_ticks):\n    if False:\n        i = 10\n    top_label = top_pos * step\n    ticks_first_label = top_pos * step / n_ticks\n    ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n    ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n    ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n    ticks_labels = ['%.1f' % x for x in ticks_labels]\n    return (ticks_positions, ticks_labels)",
            "def get_rounded_ticks(top_pos, step, n_ticks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    top_label = top_pos * step\n    ticks_first_label = top_pos * step / n_ticks\n    ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n    ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n    ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n    ticks_labels = ['%.1f' % x for x in ticks_labels]\n    return (ticks_positions, ticks_labels)",
            "def get_rounded_ticks(top_pos, step, n_ticks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    top_label = top_pos * step\n    ticks_first_label = top_pos * step / n_ticks\n    ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n    ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n    ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n    ticks_labels = ['%.1f' % x for x in ticks_labels]\n    return (ticks_positions, ticks_labels)",
            "def get_rounded_ticks(top_pos, step, n_ticks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    top_label = top_pos * step\n    ticks_first_label = top_pos * step / n_ticks\n    ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n    ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n    ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n    ticks_labels = ['%.1f' % x for x in ticks_labels]\n    return (ticks_positions, ticks_labels)",
            "def get_rounded_ticks(top_pos, step, n_ticks):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    top_label = top_pos * step\n    ticks_first_label = top_pos * step / n_ticks\n    ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n    ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n    ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n    ticks_labels = ['%.1f' % x for x in ticks_labels]\n    return (ticks_positions, ticks_labels)"
        ]
    },
    {
        "func_name": "get_spectrogram",
        "original": "def get_spectrogram(filename, samplerate=0):\n    win_s = 512\n    hop_s = win_s // 2\n    fft_s = win_s // 2 + 1\n    a = source(filename, samplerate, hop_s)\n    if samplerate == 0:\n        samplerate = a.samplerate\n    pv = pvoc(win_s, hop_s)\n    specgram = zeros([0, fft_s], dtype=float_type)\n    while True:\n        (samples, read) = a()\n        specgram = vstack((specgram, pv(samples).norm))\n        if read < a.hop_size:\n            break\n    fig = plt.imshow(log10(specgram.T + 0.001), origin='bottom', aspect='auto', cmap=plt.cm.gray_r)\n    ax = fig.axes\n    ax.axis([0, len(specgram), 0, len(specgram[0])])\n    time_step = hop_s / float(samplerate)\n    total_time = len(specgram) * time_step\n    outstr = 'total time: %0.2fs' % total_time\n    print(outstr + ', samplerate: %.2fkHz' % (samplerate / 1000.0))\n    n_xticks = 10\n    n_yticks = 10\n\n    def get_rounded_ticks(top_pos, step, n_ticks):\n        top_label = top_pos * step\n        ticks_first_label = top_pos * step / n_ticks\n        ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n        ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n        ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n        ticks_labels = ['%.1f' % x for x in ticks_labels]\n        return (ticks_positions, ticks_labels)\n    (x_ticks, x_labels) = get_rounded_ticks(len(specgram), time_step, n_xticks)\n    (y_ticks, y_labels) = get_rounded_ticks(len(specgram[0]), samplerate / 1000.0 / 2.0 / len(specgram[0]), n_yticks)\n    ax.set_xticks(x_ticks)\n    ax.set_yticks(y_ticks)\n    ax.set_xticklabels(x_labels)\n    ax.set_yticklabels(y_labels)\n    ax.set_ylabel('Frequency (kHz)')\n    ax.set_xlabel('Time (s)')\n    ax.set_title(os.path.basename(filename))\n    for item in [ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels():\n        item.set_fontsize('x-small')\n    return fig",
        "mutated": [
            "def get_spectrogram(filename, samplerate=0):\n    if False:\n        i = 10\n    win_s = 512\n    hop_s = win_s // 2\n    fft_s = win_s // 2 + 1\n    a = source(filename, samplerate, hop_s)\n    if samplerate == 0:\n        samplerate = a.samplerate\n    pv = pvoc(win_s, hop_s)\n    specgram = zeros([0, fft_s], dtype=float_type)\n    while True:\n        (samples, read) = a()\n        specgram = vstack((specgram, pv(samples).norm))\n        if read < a.hop_size:\n            break\n    fig = plt.imshow(log10(specgram.T + 0.001), origin='bottom', aspect='auto', cmap=plt.cm.gray_r)\n    ax = fig.axes\n    ax.axis([0, len(specgram), 0, len(specgram[0])])\n    time_step = hop_s / float(samplerate)\n    total_time = len(specgram) * time_step\n    outstr = 'total time: %0.2fs' % total_time\n    print(outstr + ', samplerate: %.2fkHz' % (samplerate / 1000.0))\n    n_xticks = 10\n    n_yticks = 10\n\n    def get_rounded_ticks(top_pos, step, n_ticks):\n        top_label = top_pos * step\n        ticks_first_label = top_pos * step / n_ticks\n        ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n        ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n        ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n        ticks_labels = ['%.1f' % x for x in ticks_labels]\n        return (ticks_positions, ticks_labels)\n    (x_ticks, x_labels) = get_rounded_ticks(len(specgram), time_step, n_xticks)\n    (y_ticks, y_labels) = get_rounded_ticks(len(specgram[0]), samplerate / 1000.0 / 2.0 / len(specgram[0]), n_yticks)\n    ax.set_xticks(x_ticks)\n    ax.set_yticks(y_ticks)\n    ax.set_xticklabels(x_labels)\n    ax.set_yticklabels(y_labels)\n    ax.set_ylabel('Frequency (kHz)')\n    ax.set_xlabel('Time (s)')\n    ax.set_title(os.path.basename(filename))\n    for item in [ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels():\n        item.set_fontsize('x-small')\n    return fig",
            "def get_spectrogram(filename, samplerate=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    win_s = 512\n    hop_s = win_s // 2\n    fft_s = win_s // 2 + 1\n    a = source(filename, samplerate, hop_s)\n    if samplerate == 0:\n        samplerate = a.samplerate\n    pv = pvoc(win_s, hop_s)\n    specgram = zeros([0, fft_s], dtype=float_type)\n    while True:\n        (samples, read) = a()\n        specgram = vstack((specgram, pv(samples).norm))\n        if read < a.hop_size:\n            break\n    fig = plt.imshow(log10(specgram.T + 0.001), origin='bottom', aspect='auto', cmap=plt.cm.gray_r)\n    ax = fig.axes\n    ax.axis([0, len(specgram), 0, len(specgram[0])])\n    time_step = hop_s / float(samplerate)\n    total_time = len(specgram) * time_step\n    outstr = 'total time: %0.2fs' % total_time\n    print(outstr + ', samplerate: %.2fkHz' % (samplerate / 1000.0))\n    n_xticks = 10\n    n_yticks = 10\n\n    def get_rounded_ticks(top_pos, step, n_ticks):\n        top_label = top_pos * step\n        ticks_first_label = top_pos * step / n_ticks\n        ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n        ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n        ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n        ticks_labels = ['%.1f' % x for x in ticks_labels]\n        return (ticks_positions, ticks_labels)\n    (x_ticks, x_labels) = get_rounded_ticks(len(specgram), time_step, n_xticks)\n    (y_ticks, y_labels) = get_rounded_ticks(len(specgram[0]), samplerate / 1000.0 / 2.0 / len(specgram[0]), n_yticks)\n    ax.set_xticks(x_ticks)\n    ax.set_yticks(y_ticks)\n    ax.set_xticklabels(x_labels)\n    ax.set_yticklabels(y_labels)\n    ax.set_ylabel('Frequency (kHz)')\n    ax.set_xlabel('Time (s)')\n    ax.set_title(os.path.basename(filename))\n    for item in [ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels():\n        item.set_fontsize('x-small')\n    return fig",
            "def get_spectrogram(filename, samplerate=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    win_s = 512\n    hop_s = win_s // 2\n    fft_s = win_s // 2 + 1\n    a = source(filename, samplerate, hop_s)\n    if samplerate == 0:\n        samplerate = a.samplerate\n    pv = pvoc(win_s, hop_s)\n    specgram = zeros([0, fft_s], dtype=float_type)\n    while True:\n        (samples, read) = a()\n        specgram = vstack((specgram, pv(samples).norm))\n        if read < a.hop_size:\n            break\n    fig = plt.imshow(log10(specgram.T + 0.001), origin='bottom', aspect='auto', cmap=plt.cm.gray_r)\n    ax = fig.axes\n    ax.axis([0, len(specgram), 0, len(specgram[0])])\n    time_step = hop_s / float(samplerate)\n    total_time = len(specgram) * time_step\n    outstr = 'total time: %0.2fs' % total_time\n    print(outstr + ', samplerate: %.2fkHz' % (samplerate / 1000.0))\n    n_xticks = 10\n    n_yticks = 10\n\n    def get_rounded_ticks(top_pos, step, n_ticks):\n        top_label = top_pos * step\n        ticks_first_label = top_pos * step / n_ticks\n        ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n        ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n        ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n        ticks_labels = ['%.1f' % x for x in ticks_labels]\n        return (ticks_positions, ticks_labels)\n    (x_ticks, x_labels) = get_rounded_ticks(len(specgram), time_step, n_xticks)\n    (y_ticks, y_labels) = get_rounded_ticks(len(specgram[0]), samplerate / 1000.0 / 2.0 / len(specgram[0]), n_yticks)\n    ax.set_xticks(x_ticks)\n    ax.set_yticks(y_ticks)\n    ax.set_xticklabels(x_labels)\n    ax.set_yticklabels(y_labels)\n    ax.set_ylabel('Frequency (kHz)')\n    ax.set_xlabel('Time (s)')\n    ax.set_title(os.path.basename(filename))\n    for item in [ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels():\n        item.set_fontsize('x-small')\n    return fig",
            "def get_spectrogram(filename, samplerate=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    win_s = 512\n    hop_s = win_s // 2\n    fft_s = win_s // 2 + 1\n    a = source(filename, samplerate, hop_s)\n    if samplerate == 0:\n        samplerate = a.samplerate\n    pv = pvoc(win_s, hop_s)\n    specgram = zeros([0, fft_s], dtype=float_type)\n    while True:\n        (samples, read) = a()\n        specgram = vstack((specgram, pv(samples).norm))\n        if read < a.hop_size:\n            break\n    fig = plt.imshow(log10(specgram.T + 0.001), origin='bottom', aspect='auto', cmap=plt.cm.gray_r)\n    ax = fig.axes\n    ax.axis([0, len(specgram), 0, len(specgram[0])])\n    time_step = hop_s / float(samplerate)\n    total_time = len(specgram) * time_step\n    outstr = 'total time: %0.2fs' % total_time\n    print(outstr + ', samplerate: %.2fkHz' % (samplerate / 1000.0))\n    n_xticks = 10\n    n_yticks = 10\n\n    def get_rounded_ticks(top_pos, step, n_ticks):\n        top_label = top_pos * step\n        ticks_first_label = top_pos * step / n_ticks\n        ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n        ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n        ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n        ticks_labels = ['%.1f' % x for x in ticks_labels]\n        return (ticks_positions, ticks_labels)\n    (x_ticks, x_labels) = get_rounded_ticks(len(specgram), time_step, n_xticks)\n    (y_ticks, y_labels) = get_rounded_ticks(len(specgram[0]), samplerate / 1000.0 / 2.0 / len(specgram[0]), n_yticks)\n    ax.set_xticks(x_ticks)\n    ax.set_yticks(y_ticks)\n    ax.set_xticklabels(x_labels)\n    ax.set_yticklabels(y_labels)\n    ax.set_ylabel('Frequency (kHz)')\n    ax.set_xlabel('Time (s)')\n    ax.set_title(os.path.basename(filename))\n    for item in [ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels():\n        item.set_fontsize('x-small')\n    return fig",
            "def get_spectrogram(filename, samplerate=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    win_s = 512\n    hop_s = win_s // 2\n    fft_s = win_s // 2 + 1\n    a = source(filename, samplerate, hop_s)\n    if samplerate == 0:\n        samplerate = a.samplerate\n    pv = pvoc(win_s, hop_s)\n    specgram = zeros([0, fft_s], dtype=float_type)\n    while True:\n        (samples, read) = a()\n        specgram = vstack((specgram, pv(samples).norm))\n        if read < a.hop_size:\n            break\n    fig = plt.imshow(log10(specgram.T + 0.001), origin='bottom', aspect='auto', cmap=plt.cm.gray_r)\n    ax = fig.axes\n    ax.axis([0, len(specgram), 0, len(specgram[0])])\n    time_step = hop_s / float(samplerate)\n    total_time = len(specgram) * time_step\n    outstr = 'total time: %0.2fs' % total_time\n    print(outstr + ', samplerate: %.2fkHz' % (samplerate / 1000.0))\n    n_xticks = 10\n    n_yticks = 10\n\n    def get_rounded_ticks(top_pos, step, n_ticks):\n        top_label = top_pos * step\n        ticks_first_label = top_pos * step / n_ticks\n        ticks_first_label = round(ticks_first_label * 10.0) / 10.0\n        ticks_labels = [ticks_first_label * n for n in range(n_ticks)] + [top_label]\n        ticks_positions = [ticks_labels[n] / step for n in range(n_ticks)] + [top_pos]\n        ticks_labels = ['%.1f' % x for x in ticks_labels]\n        return (ticks_positions, ticks_labels)\n    (x_ticks, x_labels) = get_rounded_ticks(len(specgram), time_step, n_xticks)\n    (y_ticks, y_labels) = get_rounded_ticks(len(specgram[0]), samplerate / 1000.0 / 2.0 / len(specgram[0]), n_yticks)\n    ax.set_xticks(x_ticks)\n    ax.set_yticks(y_ticks)\n    ax.set_xticklabels(x_labels)\n    ax.set_yticklabels(y_labels)\n    ax.set_ylabel('Frequency (kHz)')\n    ax.set_xlabel('Time (s)')\n    ax.set_title(os.path.basename(filename))\n    for item in [ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels():\n        item.set_fontsize('x-small')\n    return fig"
        ]
    }
]