[
    {
        "func_name": "_dnsname_match",
        "original": "def _dnsname_match(dn: typing.Any, hostname: str, max_wildcards: int=1) -> typing.Match[str] | None | bool:\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return bool(dn.lower() == hostname.lower())\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
        "mutated": [
            "def _dnsname_match(dn: typing.Any, hostname: str, max_wildcards: int=1) -> typing.Match[str] | None | bool:\n    if False:\n        i = 10\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return bool(dn.lower() == hostname.lower())\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
            "def _dnsname_match(dn: typing.Any, hostname: str, max_wildcards: int=1) -> typing.Match[str] | None | bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return bool(dn.lower() == hostname.lower())\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
            "def _dnsname_match(dn: typing.Any, hostname: str, max_wildcards: int=1) -> typing.Match[str] | None | bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return bool(dn.lower() == hostname.lower())\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
            "def _dnsname_match(dn: typing.Any, hostname: str, max_wildcards: int=1) -> typing.Match[str] | None | bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return bool(dn.lower() == hostname.lower())\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)",
            "def _dnsname_match(dn: typing.Any, hostname: str, max_wildcards: int=1) -> typing.Match[str] | None | bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Matching according to RFC 6125, section 6.4.3\\n\\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\\n    '\n    pats = []\n    if not dn:\n        return False\n    parts = dn.split('.')\n    leftmost = parts[0]\n    remainder = parts[1:]\n    wildcards = leftmost.count('*')\n    if wildcards > max_wildcards:\n        raise CertificateError('too many wildcards in certificate DNS name: ' + repr(dn))\n    if not wildcards:\n        return bool(dn.lower() == hostname.lower())\n    if leftmost == '*':\n        pats.append('[^.]+')\n    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n        pats.append(re.escape(leftmost))\n    else:\n        pats.append(re.escape(leftmost).replace('\\\\*', '[^.]*'))\n    for frag in remainder:\n        pats.append(re.escape(frag))\n    pat = re.compile('\\\\A' + '\\\\.'.join(pats) + '\\\\Z', re.IGNORECASE)\n    return pat.match(hostname)"
        ]
    },
    {
        "func_name": "_ipaddress_match",
        "original": "def _ipaddress_match(ipname: str, host_ip: IPv4Address | IPv6Address) -> bool:\n    \"\"\"Exact matching of IP addresses.\n\n    RFC 9110 section 4.3.5: \"A reference identity of IP-ID contains the decoded\n    bytes of the IP address. An IP version 4 address is 4 octets, and an IP\n    version 6 address is 16 octets. [...] A reference identity of type IP-ID\n    matches if the address is identical to an iPAddress value of the\n    subjectAltName extension of the certificate.\"\n    \"\"\"\n    ip = ipaddress.ip_address(ipname.rstrip())\n    return bool(ip.packed == host_ip.packed)",
        "mutated": [
            "def _ipaddress_match(ipname: str, host_ip: IPv4Address | IPv6Address) -> bool:\n    if False:\n        i = 10\n    'Exact matching of IP addresses.\\n\\n    RFC 9110 section 4.3.5: \"A reference identity of IP-ID contains the decoded\\n    bytes of the IP address. An IP version 4 address is 4 octets, and an IP\\n    version 6 address is 16 octets. [...] A reference identity of type IP-ID\\n    matches if the address is identical to an iPAddress value of the\\n    subjectAltName extension of the certificate.\"\\n    '\n    ip = ipaddress.ip_address(ipname.rstrip())\n    return bool(ip.packed == host_ip.packed)",
            "def _ipaddress_match(ipname: str, host_ip: IPv4Address | IPv6Address) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Exact matching of IP addresses.\\n\\n    RFC 9110 section 4.3.5: \"A reference identity of IP-ID contains the decoded\\n    bytes of the IP address. An IP version 4 address is 4 octets, and an IP\\n    version 6 address is 16 octets. [...] A reference identity of type IP-ID\\n    matches if the address is identical to an iPAddress value of the\\n    subjectAltName extension of the certificate.\"\\n    '\n    ip = ipaddress.ip_address(ipname.rstrip())\n    return bool(ip.packed == host_ip.packed)",
            "def _ipaddress_match(ipname: str, host_ip: IPv4Address | IPv6Address) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Exact matching of IP addresses.\\n\\n    RFC 9110 section 4.3.5: \"A reference identity of IP-ID contains the decoded\\n    bytes of the IP address. An IP version 4 address is 4 octets, and an IP\\n    version 6 address is 16 octets. [...] A reference identity of type IP-ID\\n    matches if the address is identical to an iPAddress value of the\\n    subjectAltName extension of the certificate.\"\\n    '\n    ip = ipaddress.ip_address(ipname.rstrip())\n    return bool(ip.packed == host_ip.packed)",
            "def _ipaddress_match(ipname: str, host_ip: IPv4Address | IPv6Address) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Exact matching of IP addresses.\\n\\n    RFC 9110 section 4.3.5: \"A reference identity of IP-ID contains the decoded\\n    bytes of the IP address. An IP version 4 address is 4 octets, and an IP\\n    version 6 address is 16 octets. [...] A reference identity of type IP-ID\\n    matches if the address is identical to an iPAddress value of the\\n    subjectAltName extension of the certificate.\"\\n    '\n    ip = ipaddress.ip_address(ipname.rstrip())\n    return bool(ip.packed == host_ip.packed)",
            "def _ipaddress_match(ipname: str, host_ip: IPv4Address | IPv6Address) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Exact matching of IP addresses.\\n\\n    RFC 9110 section 4.3.5: \"A reference identity of IP-ID contains the decoded\\n    bytes of the IP address. An IP version 4 address is 4 octets, and an IP\\n    version 6 address is 16 octets. [...] A reference identity of type IP-ID\\n    matches if the address is identical to an iPAddress value of the\\n    subjectAltName extension of the certificate.\"\\n    '\n    ip = ipaddress.ip_address(ipname.rstrip())\n    return bool(ip.packed == host_ip.packed)"
        ]
    },
    {
        "func_name": "match_hostname",
        "original": "def match_hostname(cert: _TYPE_PEER_CERT_RET_DICT | None, hostname: str, hostname_checks_common_name: bool=False) -> None:\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n\n    CertificateError is raised on failure. On success, the function\n    returns nothing.\n    \"\"\"\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        if '%' in hostname:\n            host_ip = ipaddress.ip_address(hostname[:hostname.rfind('%')])\n        else:\n            host_ip = ipaddress.ip_address(hostname)\n    except ValueError:\n        host_ip = None\n    dnsnames = []\n    san: tuple[tuple[str, str], ...] = cert.get('subjectAltName', ())\n    key: str\n    value: str\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if hostname_checks_common_name and host_ip is None and (not dnsnames):\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(f\"hostname {hostname!r} doesn't match {dnsnames[0]!r}\")\n    else:\n        raise CertificateError('no appropriate subjectAltName fields were found')",
        "mutated": [
            "def match_hostname(cert: _TYPE_PEER_CERT_RET_DICT | None, hostname: str, hostname_checks_common_name: bool=False) -> None:\n    if False:\n        i = 10\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        if '%' in hostname:\n            host_ip = ipaddress.ip_address(hostname[:hostname.rfind('%')])\n        else:\n            host_ip = ipaddress.ip_address(hostname)\n    except ValueError:\n        host_ip = None\n    dnsnames = []\n    san: tuple[tuple[str, str], ...] = cert.get('subjectAltName', ())\n    key: str\n    value: str\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if hostname_checks_common_name and host_ip is None and (not dnsnames):\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(f\"hostname {hostname!r} doesn't match {dnsnames[0]!r}\")\n    else:\n        raise CertificateError('no appropriate subjectAltName fields were found')",
            "def match_hostname(cert: _TYPE_PEER_CERT_RET_DICT | None, hostname: str, hostname_checks_common_name: bool=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        if '%' in hostname:\n            host_ip = ipaddress.ip_address(hostname[:hostname.rfind('%')])\n        else:\n            host_ip = ipaddress.ip_address(hostname)\n    except ValueError:\n        host_ip = None\n    dnsnames = []\n    san: tuple[tuple[str, str], ...] = cert.get('subjectAltName', ())\n    key: str\n    value: str\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if hostname_checks_common_name and host_ip is None and (not dnsnames):\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(f\"hostname {hostname!r} doesn't match {dnsnames[0]!r}\")\n    else:\n        raise CertificateError('no appropriate subjectAltName fields were found')",
            "def match_hostname(cert: _TYPE_PEER_CERT_RET_DICT | None, hostname: str, hostname_checks_common_name: bool=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        if '%' in hostname:\n            host_ip = ipaddress.ip_address(hostname[:hostname.rfind('%')])\n        else:\n            host_ip = ipaddress.ip_address(hostname)\n    except ValueError:\n        host_ip = None\n    dnsnames = []\n    san: tuple[tuple[str, str], ...] = cert.get('subjectAltName', ())\n    key: str\n    value: str\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if hostname_checks_common_name and host_ip is None and (not dnsnames):\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(f\"hostname {hostname!r} doesn't match {dnsnames[0]!r}\")\n    else:\n        raise CertificateError('no appropriate subjectAltName fields were found')",
            "def match_hostname(cert: _TYPE_PEER_CERT_RET_DICT | None, hostname: str, hostname_checks_common_name: bool=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        if '%' in hostname:\n            host_ip = ipaddress.ip_address(hostname[:hostname.rfind('%')])\n        else:\n            host_ip = ipaddress.ip_address(hostname)\n    except ValueError:\n        host_ip = None\n    dnsnames = []\n    san: tuple[tuple[str, str], ...] = cert.get('subjectAltName', ())\n    key: str\n    value: str\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if hostname_checks_common_name and host_ip is None and (not dnsnames):\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(f\"hostname {hostname!r} doesn't match {dnsnames[0]!r}\")\n    else:\n        raise CertificateError('no appropriate subjectAltName fields were found')",
            "def match_hostname(cert: _TYPE_PEER_CERT_RET_DICT | None, hostname: str, hostname_checks_common_name: bool=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Verify that *cert* (in decoded format as returned by\\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\\n    rules are followed, but IP addresses are not accepted for *hostname*.\\n\\n    CertificateError is raised on failure. On success, the function\\n    returns nothing.\\n    '\n    if not cert:\n        raise ValueError('empty or no certificate, match_hostname needs a SSL socket or SSL context with either CERT_OPTIONAL or CERT_REQUIRED')\n    try:\n        if '%' in hostname:\n            host_ip = ipaddress.ip_address(hostname[:hostname.rfind('%')])\n        else:\n            host_ip = ipaddress.ip_address(hostname)\n    except ValueError:\n        host_ip = None\n    dnsnames = []\n    san: tuple[tuple[str, str], ...] = cert.get('subjectAltName', ())\n    key: str\n    value: str\n    for (key, value) in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if hostname_checks_common_name and host_ip is None and (not dnsnames):\n        for sub in cert.get('subject', ()):\n            for (key, value) in sub:\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r doesn't match either of %s\" % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(f\"hostname {hostname!r} doesn't match {dnsnames[0]!r}\")\n    else:\n        raise CertificateError('no appropriate subjectAltName fields were found')"
        ]
    }
]