[
    {
        "func_name": "bond_curve",
        "original": "def bond_curve(bond_cashflows: types.RealTensor, bond_cashflow_times: types.RealTensor, present_values: types.RealTensor, present_values_settlement_times: types.RealTensor=None, initial_discount_rates: types.RealTensor=None, discount_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> CurveBuilderResult:\n    \"\"\"Constructs the bond discount rate curve using the Hagan-West algorithm.\n\n\n  A discount curve is a function of time which gives the interest rate that\n  applies to a unit of currency deposited today for a period of  time `t`.\n  The traded price of bonds implicitly contains the market view on the discount\n  rates. The purpose of discount curve construction is to extract this\n  information.\n\n  Suppose we have a set of `N` bonds `B_i` with increasing expiries whose market\n  prices are known.\n  Suppose also that the `i`th bond issues cashflows at times `T_{ij}` where\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\n  for the `i`th bond.\n  Denote by `T_i` the time of final payment for the `i`th bond\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\n  such that when these rates are interpolated to all other cashflow times using\n  the Monotone Convex interpolation scheme (Ref [1, 2]), the computed value of\n  the bonds matches the market value of the bonds (within some tolerance).\n\n  The algorithm implemented here is based on the Monotone Convex Interpolation\n  method described by Hagan and West in Ref [1, 2].\n\n\n  ### Limitations\n\n  The fitting algorithm suggested in Hagan and West has a few limitations that\n  are worth keeping in mind.\n\n    1. Non-convexity: The implicit loss function that is minimized by the\n      procedure is non-convex. Practically this means that for a given level of\n      tolerance, it is possible to find distinct values for the discount rates\n      all of which price the given cashflows to within tolerance. Depending\n      on the initial values chosen, the procedure of Hagan-West can converge to\n      different minima.\n    2. Stability: The procedure iterates by computing the rate to expiry of\n      a bond given the approximate rates for the coupon dates. If the initial\n      guess is widely off or even if it isn't but the rates are artificially\n      large, it can happen that the discount factor estimated at an iteration\n      step (see Eq. 14 in Ref. [2]) is negative. Hence no real discount rate\n      can be found to continue the iterations. Additionally, it can be shown\n      that the procedure diverges if the final cashflow is not larger than\n      all the intermediate cashflows. While this situation does not arise in\n      the case of bond cashflows, it is an important consideration from a\n      mathematical perspective. For the details of the stability and\n      convergence of the scheme see the associated technical note.\n      TODO(b/139052353): Write the technical note and add a reference here.\n\n  #### Example:\n\n  The following example demonstrates the usage by building the implied curve\n  from four coupon bearing bonds.\n\n  ```python\n\n  dtype=np.float64\n\n  # These need to be sorted by expiry time.\n  cashflow_times = [\n      np.array([0.25, 0.5, 0.75, 1.0], dtype=dtype),\n      np.array([0.5, 1.0, 1.5, 2.0], dtype=dtype),\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\n  ]\n\n  cashflows = [\n      # 1 year bond with 5% three monthly coupon.\n      np.array([12.5, 12.5, 12.5, 1012.5], dtype=dtype),\n      # 2 year bond with 6% semi-annual coupon.\n      np.array([30, 30, 30, 1030], dtype=dtype),\n      # 3 year bond with 8% semi-annual coupon.\n      np.array([40, 40, 40, 40, 40, 1040], dtype=dtype),\n      # 4 year bond with 3% semi-annual coupon.\n      np.array([15, 15, 15, 15, 15, 15, 15, 1015], dtype=dtype)\n  ]\n\n  # The present values of the above cashflows.\n  pvs = np.array([\n      999.68155223943393, 1022.322872470043, 1093.9894418810143,\n      934.20885689015677\n  ], dtype=dtype)\n\n  results = bond_curve(cashflows, cashflow_times, pvs)\n\n  # The curve times are the expiries of the supplied cashflows.\n  np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 4.0])\n\n  expected_discount_rates = np.array([5.0, 4.75, 4.53333333, 4.775],\n                                     dtype=dtype) / 100\n\n  np.testing.assert_allclose(results.discount_rates, expected_discount_rates,\n                             atol=1e-6)\n  ```\n\n  #### References:\n\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\n    June 2006.\n  https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\n  [2]: Patrick Hagan & Graeme West. Methods for Constructing a Yield Curve.\n    Wilmott Magazine, pp. 70-81. May 2008.\n  https://www.researchgate.net/profile/Patrick_Hagan3/publication/228463045_Methods_for_constructing_a_yield_curve/links/54db8cda0cf23fe133ad4d01.pdf\n\n  Args:\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\n      the same real dtype. They may be of different sizes. Each `Tensor`\n      represents the bond cashflows defining a particular bond. The elements of\n      the list are the bonds to be used to build the curve.\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\n      `bond_cashflows` and contain strictly positive and increasing values. The\n      times of the bond cashflows for the bonds must in an ascending order.\n    present_values: List containing scalar `Tensor`s of the same dtype as\n      elements of `bond_cashflows`. The length of the list must be the same as\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\n      price) of the bond cashflows supplied in the `bond_cashflows`.\n    present_values_settlement_times: List containing scalar `Tensor`s of the\n      same dtype as elements of `bond_cashflows`. The length of the list must be\n      the same as the length of `bond_cashflows`. The settlement times for the\n      present values is the time from now when the bond is traded to the time\n      that the purchase price is actually delivered. If not supplied, then it is\n      assumed that the settlement times are zero for every bond.\n      Default value: `None` which is equivalent to zero settlement times.\n    initial_discount_rates: Optional `Tensor` of the same dtype and shape as\n      `present_values`. The starting guess for the discount rates used to\n      initialize the iterative procedure.\n      Default value: `None`. If not supplied, the yields to maturity for the\n        bonds is used as the initial value.\n    discount_tolerance: Optional positive scalar `Tensor` of same dtype as\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\n      iterations used to fit the rate curve. The iterations are stopped when the\n      estimated discounts at the expiry times of the bond_cashflows change by a\n      amount smaller than `discount_tolerance` in an iteration.\n      Default value: 1e-8.\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\n      of iterations permitted when fitting the curve.\n      Default value: 50.\n    validate_args: Optional boolean flag to enable validation of the input\n      arguments. The checks performed are: (1) There are no cashflows which\n      expire before or at the corresponding settlement time (or at time 0 if\n      settlement time is not provided). (2) Cashflow times for each bond form\n      strictly increasing sequence. (3) Final cashflow for each bond is larger\n      than any other cashflow for that bond.\n      Default value: False.\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\n      `bond_cashflows`, `bond_cashflow_times` and `present_values`.\n      Default value: None which maps to the default dtype inferred by TensorFlow\n        (float32).\n    name: Python str. The name to give to the ops created by this function.\n      Default value: None which maps to 'hagan_west'.\n\n  Returns:\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\n      following attributes.\n      times: Rank 1 real `Tensor`. Times for the computed discount rates. These\n        are chosen to be the expiry times of the supplied cashflows.\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\n        The inferred discount rates.\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\n        The inferred discount factors.\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\n        initial guess for the discount rates.\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\n        The procedure is said to have converged when the maximum absolute\n        difference in the discount factors from one iteration to the next falls\n        below the `discount_tolerance`.\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\n        may fail either because a NaN value was encountered for the discount\n        rates or the discount factors.\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\n\n  Raises:\n    ValueError: If the `cashflows` and `cashflow_times` are not all of the same\n      length greater than or equal to two. Also raised if the\n      `present_values_settlement_times` is not None and not of the same length\n      as the `cashflows`.\n    tf.errors.InvalidArgumentError: In case argument validation is requested and\n      conditions explained in the corresponding section of Args comments are not\n      met.\n  \"\"\"\n    with tf.compat.v1.name_scope(name, default_name='bond_curve', values=[bond_cashflows, bond_cashflow_times, present_values, present_values_settlement_times]):\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        args = _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times) = args\n        _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        control_inputs = []\n        if validate_args:\n            control_inputs = _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times)\n        if initial_discount_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_discount_rates, dtype=dtype, name='initial_rates')\n        else:\n            initial_rates = _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_rates')\n        with tf.compat.v1.control_dependencies(control_inputs):\n            return _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_rates, discount_tolerance, maximum_iterations)",
        "mutated": [
            "def bond_curve(bond_cashflows: types.RealTensor, bond_cashflow_times: types.RealTensor, present_values: types.RealTensor, present_values_settlement_times: types.RealTensor=None, initial_discount_rates: types.RealTensor=None, discount_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> CurveBuilderResult:\n    if False:\n        i = 10\n    \"Constructs the bond discount rate curve using the Hagan-West algorithm.\\n\\n\\n  A discount curve is a function of time which gives the interest rate that\\n  applies to a unit of currency deposited today for a period of  time `t`.\\n  The traded price of bonds implicitly contains the market view on the discount\\n  rates. The purpose of discount curve construction is to extract this\\n  information.\\n\\n  Suppose we have a set of `N` bonds `B_i` with increasing expiries whose market\\n  prices are known.\\n  Suppose also that the `i`th bond issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th bond.\\n  Denote by `T_i` the time of final payment for the `i`th bond\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated to all other cashflow times using\\n  the Monotone Convex interpolation scheme (Ref [1, 2]), the computed value of\\n  the bonds matches the market value of the bonds (within some tolerance).\\n\\n  The algorithm implemented here is based on the Monotone Convex Interpolation\\n  method described by Hagan and West in Ref [1, 2].\\n\\n\\n  ### Limitations\\n\\n  The fitting algorithm suggested in Hagan and West has a few limitations that\\n  are worth keeping in mind.\\n\\n    1. Non-convexity: The implicit loss function that is minimized by the\\n      procedure is non-convex. Practically this means that for a given level of\\n      tolerance, it is possible to find distinct values for the discount rates\\n      all of which price the given cashflows to within tolerance. Depending\\n      on the initial values chosen, the procedure of Hagan-West can converge to\\n      different minima.\\n    2. Stability: The procedure iterates by computing the rate to expiry of\\n      a bond given the approximate rates for the coupon dates. If the initial\\n      guess is widely off or even if it isn't but the rates are artificially\\n      large, it can happen that the discount factor estimated at an iteration\\n      step (see Eq. 14 in Ref. [2]) is negative. Hence no real discount rate\\n      can be found to continue the iterations. Additionally, it can be shown\\n      that the procedure diverges if the final cashflow is not larger than\\n      all the intermediate cashflows. While this situation does not arise in\\n      the case of bond cashflows, it is an important consideration from a\\n      mathematical perspective. For the details of the stability and\\n      convergence of the scheme see the associated technical note.\\n      TODO(b/139052353): Write the technical note and add a reference here.\\n\\n  #### Example:\\n\\n  The following example demonstrates the usage by building the implied curve\\n  from four coupon bearing bonds.\\n\\n  ```python\\n\\n  dtype=np.float64\\n\\n  # These need to be sorted by expiry time.\\n  cashflow_times = [\\n      np.array([0.25, 0.5, 0.75, 1.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n  ]\\n\\n  cashflows = [\\n      # 1 year bond with 5% three monthly coupon.\\n      np.array([12.5, 12.5, 12.5, 1012.5], dtype=dtype),\\n      # 2 year bond with 6% semi-annual coupon.\\n      np.array([30, 30, 30, 1030], dtype=dtype),\\n      # 3 year bond with 8% semi-annual coupon.\\n      np.array([40, 40, 40, 40, 40, 1040], dtype=dtype),\\n      # 4 year bond with 3% semi-annual coupon.\\n      np.array([15, 15, 15, 15, 15, 15, 15, 1015], dtype=dtype)\\n  ]\\n\\n  # The present values of the above cashflows.\\n  pvs = np.array([\\n      999.68155223943393, 1022.322872470043, 1093.9894418810143,\\n      934.20885689015677\\n  ], dtype=dtype)\\n\\n  results = bond_curve(cashflows, cashflow_times, pvs)\\n\\n  # The curve times are the expiries of the supplied cashflows.\\n  np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 4.0])\\n\\n  expected_discount_rates = np.array([5.0, 4.75, 4.53333333, 4.775],\\n                                     dtype=dtype) / 100\\n\\n  np.testing.assert_allclose(results.discount_rates, expected_discount_rates,\\n                             atol=1e-6)\\n  ```\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n  https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n  [2]: Patrick Hagan & Graeme West. Methods for Constructing a Yield Curve.\\n    Wilmott Magazine, pp. 70-81. May 2008.\\n  https://www.researchgate.net/profile/Patrick_Hagan3/publication/228463045_Methods_for_constructing_a_yield_curve/links/54db8cda0cf23fe133ad4d01.pdf\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `bond_cashflows`. The length of the list must be\\n      the same as the length of `bond_cashflows`. The settlement times for the\\n      present values is the time from now when the bond is traded to the time\\n      that the purchase price is actually delivered. If not supplied, then it is\\n      assumed that the settlement times are zero for every bond.\\n      Default value: `None` which is equivalent to zero settlement times.\\n    initial_discount_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    discount_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    validate_args: Optional boolean flag to enable validation of the input\\n      arguments. The checks performed are: (1) There are no cashflows which\\n      expire before or at the corresponding settlement time (or at time 0 if\\n      settlement time is not provided). (2) Cashflow times for each bond form\\n      strictly increasing sequence. (3) Final cashflow for each bond is larger\\n      than any other cashflow for that bond.\\n      Default value: False.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `bond_cashflows`, `bond_cashflow_times` and `present_values`.\\n      Default value: None which maps to the default dtype inferred by TensorFlow\\n        (float32).\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'hagan_west'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates. These\\n        are chosen to be the expiry times of the supplied cashflows.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the `cashflows` and `cashflow_times` are not all of the same\\n      length greater than or equal to two. Also raised if the\\n      `present_values_settlement_times` is not None and not of the same length\\n      as the `cashflows`.\\n    tf.errors.InvalidArgumentError: In case argument validation is requested and\\n      conditions explained in the corresponding section of Args comments are not\\n      met.\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='bond_curve', values=[bond_cashflows, bond_cashflow_times, present_values, present_values_settlement_times]):\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        args = _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times) = args\n        _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        control_inputs = []\n        if validate_args:\n            control_inputs = _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times)\n        if initial_discount_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_discount_rates, dtype=dtype, name='initial_rates')\n        else:\n            initial_rates = _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_rates')\n        with tf.compat.v1.control_dependencies(control_inputs):\n            return _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_rates, discount_tolerance, maximum_iterations)",
            "def bond_curve(bond_cashflows: types.RealTensor, bond_cashflow_times: types.RealTensor, present_values: types.RealTensor, present_values_settlement_times: types.RealTensor=None, initial_discount_rates: types.RealTensor=None, discount_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> CurveBuilderResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Constructs the bond discount rate curve using the Hagan-West algorithm.\\n\\n\\n  A discount curve is a function of time which gives the interest rate that\\n  applies to a unit of currency deposited today for a period of  time `t`.\\n  The traded price of bonds implicitly contains the market view on the discount\\n  rates. The purpose of discount curve construction is to extract this\\n  information.\\n\\n  Suppose we have a set of `N` bonds `B_i` with increasing expiries whose market\\n  prices are known.\\n  Suppose also that the `i`th bond issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th bond.\\n  Denote by `T_i` the time of final payment for the `i`th bond\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated to all other cashflow times using\\n  the Monotone Convex interpolation scheme (Ref [1, 2]), the computed value of\\n  the bonds matches the market value of the bonds (within some tolerance).\\n\\n  The algorithm implemented here is based on the Monotone Convex Interpolation\\n  method described by Hagan and West in Ref [1, 2].\\n\\n\\n  ### Limitations\\n\\n  The fitting algorithm suggested in Hagan and West has a few limitations that\\n  are worth keeping in mind.\\n\\n    1. Non-convexity: The implicit loss function that is minimized by the\\n      procedure is non-convex. Practically this means that for a given level of\\n      tolerance, it is possible to find distinct values for the discount rates\\n      all of which price the given cashflows to within tolerance. Depending\\n      on the initial values chosen, the procedure of Hagan-West can converge to\\n      different minima.\\n    2. Stability: The procedure iterates by computing the rate to expiry of\\n      a bond given the approximate rates for the coupon dates. If the initial\\n      guess is widely off or even if it isn't but the rates are artificially\\n      large, it can happen that the discount factor estimated at an iteration\\n      step (see Eq. 14 in Ref. [2]) is negative. Hence no real discount rate\\n      can be found to continue the iterations. Additionally, it can be shown\\n      that the procedure diverges if the final cashflow is not larger than\\n      all the intermediate cashflows. While this situation does not arise in\\n      the case of bond cashflows, it is an important consideration from a\\n      mathematical perspective. For the details of the stability and\\n      convergence of the scheme see the associated technical note.\\n      TODO(b/139052353): Write the technical note and add a reference here.\\n\\n  #### Example:\\n\\n  The following example demonstrates the usage by building the implied curve\\n  from four coupon bearing bonds.\\n\\n  ```python\\n\\n  dtype=np.float64\\n\\n  # These need to be sorted by expiry time.\\n  cashflow_times = [\\n      np.array([0.25, 0.5, 0.75, 1.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n  ]\\n\\n  cashflows = [\\n      # 1 year bond with 5% three monthly coupon.\\n      np.array([12.5, 12.5, 12.5, 1012.5], dtype=dtype),\\n      # 2 year bond with 6% semi-annual coupon.\\n      np.array([30, 30, 30, 1030], dtype=dtype),\\n      # 3 year bond with 8% semi-annual coupon.\\n      np.array([40, 40, 40, 40, 40, 1040], dtype=dtype),\\n      # 4 year bond with 3% semi-annual coupon.\\n      np.array([15, 15, 15, 15, 15, 15, 15, 1015], dtype=dtype)\\n  ]\\n\\n  # The present values of the above cashflows.\\n  pvs = np.array([\\n      999.68155223943393, 1022.322872470043, 1093.9894418810143,\\n      934.20885689015677\\n  ], dtype=dtype)\\n\\n  results = bond_curve(cashflows, cashflow_times, pvs)\\n\\n  # The curve times are the expiries of the supplied cashflows.\\n  np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 4.0])\\n\\n  expected_discount_rates = np.array([5.0, 4.75, 4.53333333, 4.775],\\n                                     dtype=dtype) / 100\\n\\n  np.testing.assert_allclose(results.discount_rates, expected_discount_rates,\\n                             atol=1e-6)\\n  ```\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n  https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n  [2]: Patrick Hagan & Graeme West. Methods for Constructing a Yield Curve.\\n    Wilmott Magazine, pp. 70-81. May 2008.\\n  https://www.researchgate.net/profile/Patrick_Hagan3/publication/228463045_Methods_for_constructing_a_yield_curve/links/54db8cda0cf23fe133ad4d01.pdf\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `bond_cashflows`. The length of the list must be\\n      the same as the length of `bond_cashflows`. The settlement times for the\\n      present values is the time from now when the bond is traded to the time\\n      that the purchase price is actually delivered. If not supplied, then it is\\n      assumed that the settlement times are zero for every bond.\\n      Default value: `None` which is equivalent to zero settlement times.\\n    initial_discount_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    discount_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    validate_args: Optional boolean flag to enable validation of the input\\n      arguments. The checks performed are: (1) There are no cashflows which\\n      expire before or at the corresponding settlement time (or at time 0 if\\n      settlement time is not provided). (2) Cashflow times for each bond form\\n      strictly increasing sequence. (3) Final cashflow for each bond is larger\\n      than any other cashflow for that bond.\\n      Default value: False.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `bond_cashflows`, `bond_cashflow_times` and `present_values`.\\n      Default value: None which maps to the default dtype inferred by TensorFlow\\n        (float32).\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'hagan_west'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates. These\\n        are chosen to be the expiry times of the supplied cashflows.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the `cashflows` and `cashflow_times` are not all of the same\\n      length greater than or equal to two. Also raised if the\\n      `present_values_settlement_times` is not None and not of the same length\\n      as the `cashflows`.\\n    tf.errors.InvalidArgumentError: In case argument validation is requested and\\n      conditions explained in the corresponding section of Args comments are not\\n      met.\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='bond_curve', values=[bond_cashflows, bond_cashflow_times, present_values, present_values_settlement_times]):\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        args = _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times) = args\n        _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        control_inputs = []\n        if validate_args:\n            control_inputs = _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times)\n        if initial_discount_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_discount_rates, dtype=dtype, name='initial_rates')\n        else:\n            initial_rates = _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_rates')\n        with tf.compat.v1.control_dependencies(control_inputs):\n            return _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_rates, discount_tolerance, maximum_iterations)",
            "def bond_curve(bond_cashflows: types.RealTensor, bond_cashflow_times: types.RealTensor, present_values: types.RealTensor, present_values_settlement_times: types.RealTensor=None, initial_discount_rates: types.RealTensor=None, discount_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> CurveBuilderResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Constructs the bond discount rate curve using the Hagan-West algorithm.\\n\\n\\n  A discount curve is a function of time which gives the interest rate that\\n  applies to a unit of currency deposited today for a period of  time `t`.\\n  The traded price of bonds implicitly contains the market view on the discount\\n  rates. The purpose of discount curve construction is to extract this\\n  information.\\n\\n  Suppose we have a set of `N` bonds `B_i` with increasing expiries whose market\\n  prices are known.\\n  Suppose also that the `i`th bond issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th bond.\\n  Denote by `T_i` the time of final payment for the `i`th bond\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated to all other cashflow times using\\n  the Monotone Convex interpolation scheme (Ref [1, 2]), the computed value of\\n  the bonds matches the market value of the bonds (within some tolerance).\\n\\n  The algorithm implemented here is based on the Monotone Convex Interpolation\\n  method described by Hagan and West in Ref [1, 2].\\n\\n\\n  ### Limitations\\n\\n  The fitting algorithm suggested in Hagan and West has a few limitations that\\n  are worth keeping in mind.\\n\\n    1. Non-convexity: The implicit loss function that is minimized by the\\n      procedure is non-convex. Practically this means that for a given level of\\n      tolerance, it is possible to find distinct values for the discount rates\\n      all of which price the given cashflows to within tolerance. Depending\\n      on the initial values chosen, the procedure of Hagan-West can converge to\\n      different minima.\\n    2. Stability: The procedure iterates by computing the rate to expiry of\\n      a bond given the approximate rates for the coupon dates. If the initial\\n      guess is widely off or even if it isn't but the rates are artificially\\n      large, it can happen that the discount factor estimated at an iteration\\n      step (see Eq. 14 in Ref. [2]) is negative. Hence no real discount rate\\n      can be found to continue the iterations. Additionally, it can be shown\\n      that the procedure diverges if the final cashflow is not larger than\\n      all the intermediate cashflows. While this situation does not arise in\\n      the case of bond cashflows, it is an important consideration from a\\n      mathematical perspective. For the details of the stability and\\n      convergence of the scheme see the associated technical note.\\n      TODO(b/139052353): Write the technical note and add a reference here.\\n\\n  #### Example:\\n\\n  The following example demonstrates the usage by building the implied curve\\n  from four coupon bearing bonds.\\n\\n  ```python\\n\\n  dtype=np.float64\\n\\n  # These need to be sorted by expiry time.\\n  cashflow_times = [\\n      np.array([0.25, 0.5, 0.75, 1.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n  ]\\n\\n  cashflows = [\\n      # 1 year bond with 5% three monthly coupon.\\n      np.array([12.5, 12.5, 12.5, 1012.5], dtype=dtype),\\n      # 2 year bond with 6% semi-annual coupon.\\n      np.array([30, 30, 30, 1030], dtype=dtype),\\n      # 3 year bond with 8% semi-annual coupon.\\n      np.array([40, 40, 40, 40, 40, 1040], dtype=dtype),\\n      # 4 year bond with 3% semi-annual coupon.\\n      np.array([15, 15, 15, 15, 15, 15, 15, 1015], dtype=dtype)\\n  ]\\n\\n  # The present values of the above cashflows.\\n  pvs = np.array([\\n      999.68155223943393, 1022.322872470043, 1093.9894418810143,\\n      934.20885689015677\\n  ], dtype=dtype)\\n\\n  results = bond_curve(cashflows, cashflow_times, pvs)\\n\\n  # The curve times are the expiries of the supplied cashflows.\\n  np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 4.0])\\n\\n  expected_discount_rates = np.array([5.0, 4.75, 4.53333333, 4.775],\\n                                     dtype=dtype) / 100\\n\\n  np.testing.assert_allclose(results.discount_rates, expected_discount_rates,\\n                             atol=1e-6)\\n  ```\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n  https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n  [2]: Patrick Hagan & Graeme West. Methods for Constructing a Yield Curve.\\n    Wilmott Magazine, pp. 70-81. May 2008.\\n  https://www.researchgate.net/profile/Patrick_Hagan3/publication/228463045_Methods_for_constructing_a_yield_curve/links/54db8cda0cf23fe133ad4d01.pdf\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `bond_cashflows`. The length of the list must be\\n      the same as the length of `bond_cashflows`. The settlement times for the\\n      present values is the time from now when the bond is traded to the time\\n      that the purchase price is actually delivered. If not supplied, then it is\\n      assumed that the settlement times are zero for every bond.\\n      Default value: `None` which is equivalent to zero settlement times.\\n    initial_discount_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    discount_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    validate_args: Optional boolean flag to enable validation of the input\\n      arguments. The checks performed are: (1) There are no cashflows which\\n      expire before or at the corresponding settlement time (or at time 0 if\\n      settlement time is not provided). (2) Cashflow times for each bond form\\n      strictly increasing sequence. (3) Final cashflow for each bond is larger\\n      than any other cashflow for that bond.\\n      Default value: False.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `bond_cashflows`, `bond_cashflow_times` and `present_values`.\\n      Default value: None which maps to the default dtype inferred by TensorFlow\\n        (float32).\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'hagan_west'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates. These\\n        are chosen to be the expiry times of the supplied cashflows.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the `cashflows` and `cashflow_times` are not all of the same\\n      length greater than or equal to two. Also raised if the\\n      `present_values_settlement_times` is not None and not of the same length\\n      as the `cashflows`.\\n    tf.errors.InvalidArgumentError: In case argument validation is requested and\\n      conditions explained in the corresponding section of Args comments are not\\n      met.\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='bond_curve', values=[bond_cashflows, bond_cashflow_times, present_values, present_values_settlement_times]):\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        args = _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times) = args\n        _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        control_inputs = []\n        if validate_args:\n            control_inputs = _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times)\n        if initial_discount_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_discount_rates, dtype=dtype, name='initial_rates')\n        else:\n            initial_rates = _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_rates')\n        with tf.compat.v1.control_dependencies(control_inputs):\n            return _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_rates, discount_tolerance, maximum_iterations)",
            "def bond_curve(bond_cashflows: types.RealTensor, bond_cashflow_times: types.RealTensor, present_values: types.RealTensor, present_values_settlement_times: types.RealTensor=None, initial_discount_rates: types.RealTensor=None, discount_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> CurveBuilderResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Constructs the bond discount rate curve using the Hagan-West algorithm.\\n\\n\\n  A discount curve is a function of time which gives the interest rate that\\n  applies to a unit of currency deposited today for a period of  time `t`.\\n  The traded price of bonds implicitly contains the market view on the discount\\n  rates. The purpose of discount curve construction is to extract this\\n  information.\\n\\n  Suppose we have a set of `N` bonds `B_i` with increasing expiries whose market\\n  prices are known.\\n  Suppose also that the `i`th bond issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th bond.\\n  Denote by `T_i` the time of final payment for the `i`th bond\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated to all other cashflow times using\\n  the Monotone Convex interpolation scheme (Ref [1, 2]), the computed value of\\n  the bonds matches the market value of the bonds (within some tolerance).\\n\\n  The algorithm implemented here is based on the Monotone Convex Interpolation\\n  method described by Hagan and West in Ref [1, 2].\\n\\n\\n  ### Limitations\\n\\n  The fitting algorithm suggested in Hagan and West has a few limitations that\\n  are worth keeping in mind.\\n\\n    1. Non-convexity: The implicit loss function that is minimized by the\\n      procedure is non-convex. Practically this means that for a given level of\\n      tolerance, it is possible to find distinct values for the discount rates\\n      all of which price the given cashflows to within tolerance. Depending\\n      on the initial values chosen, the procedure of Hagan-West can converge to\\n      different minima.\\n    2. Stability: The procedure iterates by computing the rate to expiry of\\n      a bond given the approximate rates for the coupon dates. If the initial\\n      guess is widely off or even if it isn't but the rates are artificially\\n      large, it can happen that the discount factor estimated at an iteration\\n      step (see Eq. 14 in Ref. [2]) is negative. Hence no real discount rate\\n      can be found to continue the iterations. Additionally, it can be shown\\n      that the procedure diverges if the final cashflow is not larger than\\n      all the intermediate cashflows. While this situation does not arise in\\n      the case of bond cashflows, it is an important consideration from a\\n      mathematical perspective. For the details of the stability and\\n      convergence of the scheme see the associated technical note.\\n      TODO(b/139052353): Write the technical note and add a reference here.\\n\\n  #### Example:\\n\\n  The following example demonstrates the usage by building the implied curve\\n  from four coupon bearing bonds.\\n\\n  ```python\\n\\n  dtype=np.float64\\n\\n  # These need to be sorted by expiry time.\\n  cashflow_times = [\\n      np.array([0.25, 0.5, 0.75, 1.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n  ]\\n\\n  cashflows = [\\n      # 1 year bond with 5% three monthly coupon.\\n      np.array([12.5, 12.5, 12.5, 1012.5], dtype=dtype),\\n      # 2 year bond with 6% semi-annual coupon.\\n      np.array([30, 30, 30, 1030], dtype=dtype),\\n      # 3 year bond with 8% semi-annual coupon.\\n      np.array([40, 40, 40, 40, 40, 1040], dtype=dtype),\\n      # 4 year bond with 3% semi-annual coupon.\\n      np.array([15, 15, 15, 15, 15, 15, 15, 1015], dtype=dtype)\\n  ]\\n\\n  # The present values of the above cashflows.\\n  pvs = np.array([\\n      999.68155223943393, 1022.322872470043, 1093.9894418810143,\\n      934.20885689015677\\n  ], dtype=dtype)\\n\\n  results = bond_curve(cashflows, cashflow_times, pvs)\\n\\n  # The curve times are the expiries of the supplied cashflows.\\n  np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 4.0])\\n\\n  expected_discount_rates = np.array([5.0, 4.75, 4.53333333, 4.775],\\n                                     dtype=dtype) / 100\\n\\n  np.testing.assert_allclose(results.discount_rates, expected_discount_rates,\\n                             atol=1e-6)\\n  ```\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n  https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n  [2]: Patrick Hagan & Graeme West. Methods for Constructing a Yield Curve.\\n    Wilmott Magazine, pp. 70-81. May 2008.\\n  https://www.researchgate.net/profile/Patrick_Hagan3/publication/228463045_Methods_for_constructing_a_yield_curve/links/54db8cda0cf23fe133ad4d01.pdf\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `bond_cashflows`. The length of the list must be\\n      the same as the length of `bond_cashflows`. The settlement times for the\\n      present values is the time from now when the bond is traded to the time\\n      that the purchase price is actually delivered. If not supplied, then it is\\n      assumed that the settlement times are zero for every bond.\\n      Default value: `None` which is equivalent to zero settlement times.\\n    initial_discount_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    discount_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    validate_args: Optional boolean flag to enable validation of the input\\n      arguments. The checks performed are: (1) There are no cashflows which\\n      expire before or at the corresponding settlement time (or at time 0 if\\n      settlement time is not provided). (2) Cashflow times for each bond form\\n      strictly increasing sequence. (3) Final cashflow for each bond is larger\\n      than any other cashflow for that bond.\\n      Default value: False.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `bond_cashflows`, `bond_cashflow_times` and `present_values`.\\n      Default value: None which maps to the default dtype inferred by TensorFlow\\n        (float32).\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'hagan_west'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates. These\\n        are chosen to be the expiry times of the supplied cashflows.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the `cashflows` and `cashflow_times` are not all of the same\\n      length greater than or equal to two. Also raised if the\\n      `present_values_settlement_times` is not None and not of the same length\\n      as the `cashflows`.\\n    tf.errors.InvalidArgumentError: In case argument validation is requested and\\n      conditions explained in the corresponding section of Args comments are not\\n      met.\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='bond_curve', values=[bond_cashflows, bond_cashflow_times, present_values, present_values_settlement_times]):\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        args = _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times) = args\n        _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        control_inputs = []\n        if validate_args:\n            control_inputs = _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times)\n        if initial_discount_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_discount_rates, dtype=dtype, name='initial_rates')\n        else:\n            initial_rates = _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_rates')\n        with tf.compat.v1.control_dependencies(control_inputs):\n            return _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_rates, discount_tolerance, maximum_iterations)",
            "def bond_curve(bond_cashflows: types.RealTensor, bond_cashflow_times: types.RealTensor, present_values: types.RealTensor, present_values_settlement_times: types.RealTensor=None, initial_discount_rates: types.RealTensor=None, discount_tolerance: types.RealTensor=1e-08, maximum_iterations: types.IntTensor=50, validate_args: bool=False, dtype: tf.DType=None, name: str=None) -> CurveBuilderResult:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Constructs the bond discount rate curve using the Hagan-West algorithm.\\n\\n\\n  A discount curve is a function of time which gives the interest rate that\\n  applies to a unit of currency deposited today for a period of  time `t`.\\n  The traded price of bonds implicitly contains the market view on the discount\\n  rates. The purpose of discount curve construction is to extract this\\n  information.\\n\\n  Suppose we have a set of `N` bonds `B_i` with increasing expiries whose market\\n  prices are known.\\n  Suppose also that the `i`th bond issues cashflows at times `T_{ij}` where\\n  `1 <= j <= n_i` and `n_i` is the number of cashflows (including expiry)\\n  for the `i`th bond.\\n  Denote by `T_i` the time of final payment for the `i`th bond\\n  (hence `T_i = T_{i,n_i}`). This function estimates a set of rates `r(T_i)`\\n  such that when these rates are interpolated to all other cashflow times using\\n  the Monotone Convex interpolation scheme (Ref [1, 2]), the computed value of\\n  the bonds matches the market value of the bonds (within some tolerance).\\n\\n  The algorithm implemented here is based on the Monotone Convex Interpolation\\n  method described by Hagan and West in Ref [1, 2].\\n\\n\\n  ### Limitations\\n\\n  The fitting algorithm suggested in Hagan and West has a few limitations that\\n  are worth keeping in mind.\\n\\n    1. Non-convexity: The implicit loss function that is minimized by the\\n      procedure is non-convex. Practically this means that for a given level of\\n      tolerance, it is possible to find distinct values for the discount rates\\n      all of which price the given cashflows to within tolerance. Depending\\n      on the initial values chosen, the procedure of Hagan-West can converge to\\n      different minima.\\n    2. Stability: The procedure iterates by computing the rate to expiry of\\n      a bond given the approximate rates for the coupon dates. If the initial\\n      guess is widely off or even if it isn't but the rates are artificially\\n      large, it can happen that the discount factor estimated at an iteration\\n      step (see Eq. 14 in Ref. [2]) is negative. Hence no real discount rate\\n      can be found to continue the iterations. Additionally, it can be shown\\n      that the procedure diverges if the final cashflow is not larger than\\n      all the intermediate cashflows. While this situation does not arise in\\n      the case of bond cashflows, it is an important consideration from a\\n      mathematical perspective. For the details of the stability and\\n      convergence of the scheme see the associated technical note.\\n      TODO(b/139052353): Write the technical note and add a reference here.\\n\\n  #### Example:\\n\\n  The following example demonstrates the usage by building the implied curve\\n  from four coupon bearing bonds.\\n\\n  ```python\\n\\n  dtype=np.float64\\n\\n  # These need to be sorted by expiry time.\\n  cashflow_times = [\\n      np.array([0.25, 0.5, 0.75, 1.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0], dtype=dtype),\\n      np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0], dtype=dtype)\\n  ]\\n\\n  cashflows = [\\n      # 1 year bond with 5% three monthly coupon.\\n      np.array([12.5, 12.5, 12.5, 1012.5], dtype=dtype),\\n      # 2 year bond with 6% semi-annual coupon.\\n      np.array([30, 30, 30, 1030], dtype=dtype),\\n      # 3 year bond with 8% semi-annual coupon.\\n      np.array([40, 40, 40, 40, 40, 1040], dtype=dtype),\\n      # 4 year bond with 3% semi-annual coupon.\\n      np.array([15, 15, 15, 15, 15, 15, 15, 1015], dtype=dtype)\\n  ]\\n\\n  # The present values of the above cashflows.\\n  pvs = np.array([\\n      999.68155223943393, 1022.322872470043, 1093.9894418810143,\\n      934.20885689015677\\n  ], dtype=dtype)\\n\\n  results = bond_curve(cashflows, cashflow_times, pvs)\\n\\n  # The curve times are the expiries of the supplied cashflows.\\n  np.testing.assert_allclose(results.times, [1.0, 2.0, 3.0, 4.0])\\n\\n  expected_discount_rates = np.array([5.0, 4.75, 4.53333333, 4.775],\\n                                     dtype=dtype) / 100\\n\\n  np.testing.assert_allclose(results.discount_rates, expected_discount_rates,\\n                             atol=1e-6)\\n  ```\\n\\n  #### References:\\n\\n  [1]: Patrick Hagan & Graeme West. Interpolation Methods for Curve\\n    Construction. Applied Mathematical Finance. Vol 13, No. 2, pp 89-129.\\n    June 2006.\\n  https://www.researchgate.net/publication/24071726_Interpolation_Methods_for_Curve_Construction\\n  [2]: Patrick Hagan & Graeme West. Methods for Constructing a Yield Curve.\\n    Wilmott Magazine, pp. 70-81. May 2008.\\n  https://www.researchgate.net/profile/Patrick_Hagan3/publication/228463045_Methods_for_constructing_a_yield_curve/links/54db8cda0cf23fe133ad4d01.pdf\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    present_values_settlement_times: List containing scalar `Tensor`s of the\\n      same dtype as elements of `bond_cashflows`. The length of the list must be\\n      the same as the length of `bond_cashflows`. The settlement times for the\\n      present values is the time from now when the bond is traded to the time\\n      that the purchase price is actually delivered. If not supplied, then it is\\n      assumed that the settlement times are zero for every bond.\\n      Default value: `None` which is equivalent to zero settlement times.\\n    initial_discount_rates: Optional `Tensor` of the same dtype and shape as\\n      `present_values`. The starting guess for the discount rates used to\\n      initialize the iterative procedure.\\n      Default value: `None`. If not supplied, the yields to maturity for the\\n        bonds is used as the initial value.\\n    discount_tolerance: Optional positive scalar `Tensor` of same dtype as\\n      elements of `bond_cashflows`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond_cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n      Default value: 1e-8.\\n    maximum_iterations: Optional positive integer `Tensor`. The maximum number\\n      of iterations permitted when fitting the curve.\\n      Default value: 50.\\n    validate_args: Optional boolean flag to enable validation of the input\\n      arguments. The checks performed are: (1) There are no cashflows which\\n      expire before or at the corresponding settlement time (or at time 0 if\\n      settlement time is not provided). (2) Cashflow times for each bond form\\n      strictly increasing sequence. (3) Final cashflow for each bond is larger\\n      than any other cashflow for that bond.\\n      Default value: False.\\n    dtype: `tf.Dtype`. If supplied the dtype for the (elements of)\\n      `bond_cashflows`, `bond_cashflow_times` and `present_values`.\\n      Default value: None which maps to the default dtype inferred by TensorFlow\\n        (float32).\\n    name: Python str. The name to give to the ops created by this function.\\n      Default value: None which maps to 'hagan_west'.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates. These\\n        are chosen to be the expiry times of the supplied cashflows.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar int32 `Tensor`. Number of iterations performed.\\n\\n  Raises:\\n    ValueError: If the `cashflows` and `cashflow_times` are not all of the same\\n      length greater than or equal to two. Also raised if the\\n      `present_values_settlement_times` is not None and not of the same length\\n      as the `cashflows`.\\n    tf.errors.InvalidArgumentError: In case argument validation is requested and\\n      conditions explained in the corresponding section of Args comments are not\\n      met.\\n  \"\n    with tf.compat.v1.name_scope(name, default_name='bond_curve', values=[bond_cashflows, bond_cashflow_times, present_values, present_values_settlement_times]):\n        if present_values_settlement_times is None:\n            pv_settle_times = [tf.zeros_like(pv) for pv in present_values]\n        else:\n            pv_settle_times = present_values_settlement_times\n        args = _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times) = args\n        _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)\n        control_inputs = []\n        if validate_args:\n            control_inputs = _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times)\n        if initial_discount_rates is not None:\n            initial_rates = tf.convert_to_tensor(initial_discount_rates, dtype=dtype, name='initial_rates')\n        else:\n            initial_rates = _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_rates')\n        with tf.compat.v1.control_dependencies(control_inputs):\n            return _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_rates, discount_tolerance, maximum_iterations)"
        ]
    },
    {
        "func_name": "one_step",
        "original": "def one_step(converged, failed, iteration, expiry_discounts):\n    \"\"\"One step of the iteration.\"\"\"\n    expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n    failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n    calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n    calc_discounts = tf.math.exp(-calc_rates * calc_times)\n    next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n    discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n    return (converged, failed, iteration + 1, next_expiry_discounts)",
        "mutated": [
            "def one_step(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n    'One step of the iteration.'\n    expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n    failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n    calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n    calc_discounts = tf.math.exp(-calc_rates * calc_times)\n    next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n    discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n    return (converged, failed, iteration + 1, next_expiry_discounts)",
            "def one_step(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'One step of the iteration.'\n    expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n    failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n    calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n    calc_discounts = tf.math.exp(-calc_rates * calc_times)\n    next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n    discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n    return (converged, failed, iteration + 1, next_expiry_discounts)",
            "def one_step(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'One step of the iteration.'\n    expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n    failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n    calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n    calc_discounts = tf.math.exp(-calc_rates * calc_times)\n    next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n    discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n    return (converged, failed, iteration + 1, next_expiry_discounts)",
            "def one_step(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'One step of the iteration.'\n    expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n    failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n    calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n    calc_discounts = tf.math.exp(-calc_rates * calc_times)\n    next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n    discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n    return (converged, failed, iteration + 1, next_expiry_discounts)",
            "def one_step(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'One step of the iteration.'\n    expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n    failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n    calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n    calc_discounts = tf.math.exp(-calc_rates * calc_times)\n    next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n    discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n    converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n    return (converged, failed, iteration + 1, next_expiry_discounts)"
        ]
    },
    {
        "func_name": "cond",
        "original": "def cond(converged, failed, iteration, expiry_discounts):\n    del expiry_discounts, iteration\n    return ~tf.math.logical_or(converged, failed)",
        "mutated": [
            "def cond(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n    del expiry_discounts, iteration\n    return ~tf.math.logical_or(converged, failed)",
            "def cond(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    del expiry_discounts, iteration\n    return ~tf.math.logical_or(converged, failed)",
            "def cond(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    del expiry_discounts, iteration\n    return ~tf.math.logical_or(converged, failed)",
            "def cond(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    del expiry_discounts, iteration\n    return ~tf.math.logical_or(converged, failed)",
            "def cond(converged, failed, iteration, expiry_discounts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    del expiry_discounts, iteration\n    return ~tf.math.logical_or(converged, failed)"
        ]
    },
    {
        "func_name": "_build_discount_curve",
        "original": "def _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_discount_rates, discount_tolerance, maximum_iterations):\n    \"\"\"Estimates the discount curve.\n\n  The procedure is recursive and as follows:\n  1. Assume some initial set of discount rates/discount factors.\n    Set this as the current yield curve.\n  2. From the current yield curve, interpolate to get the discount rates\n    for each time at which bond_cashflows occur.\n  3. Using these discounts and the known bond prices, compute the discount\n    rate to expiry of each bond by inverting the bond pricing formula as\n    follows. We know that the bond price satisfies (`P` is the present value,\n    `r_i` is the discount rate to time `t_i`, `c_i` is the cashflow occurring at\n    time `t_i`.):\n\n    ```None\n      P e^{-r_0 t_0} = c_1 e^{-r_1 t_1} + ... + c_n e^{-r_n t_n}        (A)\n\n    ```\n    Assuming we have estimated r_0, r_1, r_2, ..., r_{n-1}, we can invert the\n    above equation to calculate r_n. We write this in a suggestive form\n    suitable for the implementation below.\n\n    ```None\n      -c_n z_n = -P z_0 + c_1 z_1 + c_2 z_2 + ... + c_{n-1} z_{n-1}     (B)\n\n    ```\n    where\n\n    ```None\n      z_i = e^{-r_i t_i}      (C)\n\n    ```\n    The RHS of Eq. (B) looks like the PV of cashflows\n    `[-P, c_1, c_2, ... c_{n-1}]` paid out at times `[t_0, t_1, ..., t_{n-1}]`.\n\n    Concatenate these \"synthetic\" cashflow times for each bond:\n\n    `Ts = [t1_0, t1_1, ... t1_{n1-1}] + [t2_0, t2_1, ... t2_{n2-1}] ...`\n\n    Also concatenate the synthetic bond cashflows as:\n\n    `Cs = [-P1, c1_1, ..., c1_{n1-1}] + [-P2, c2_1, ..., c2_{n2-1}] ...`\n\n    Then compute `Rs = InterpolateRates[Ts], Zs = exp(-Rs * Ts)`\n\n    Let `Zns = [z_n1, z_n2, ... ], Cns = [c1_n, c2_n, ...]` be the discount\n    factors to expiry and the final cashflow of each bond.\n    We can derive `Zns = - SegmentSum(Cs * Zs) / Cns`.\n\n    From that, we get Rns = -log(Zns) / Tns.\n    Using this as the next guess for the discount rates and we repeat the\n    procedure from Step (1) until convergence.\n\n  Args:\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\n      the same real dtype. They may be of different sizes. Each `Tensor`\n      represents the bond cashflows defining a particular bond. The elements of\n      the list are the bonds to be used to build the curve.\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\n      `bond_cashflows` and contain strictly positive and increasing values. The\n      times of the bond cashflows for the bonds must in an ascending order.\n    present_values: List containing scalar `Tensor`s of the same dtype as\n      elements of `bond_cashflows`. The length of the list must be the same as\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\n      price) of the bond cashflows supplied in the `bond_cashflows`.\n    pv_settle_times:   List containing scalar `Tensor`s of the same dtype as\n      elements of `bond_cashflows`. The length of the list must be the same as\n      the length of `bond_cashflows`. The settlement times for the present\n      values is the time from now when the bond is traded to the time that the\n      purchase price is actually delivered.\n    initial_discount_rates: Rank 1 `Tensor` of same shape and dtype as\n      `pv_settle_times`. The initial guess for the discount rates to bond expiry\n      times.\n    discount_tolerance: Positive scalar `Tensor` of same dtype as\n      `initial_discount_factors`. The absolute tolerance for terminating the\n      iterations used to fit the rate curve. The iterations are stopped when the\n      estimated discounts at the expiry times of the bond cashflows change by a\n      amount smaller than `discount_tolerance` in an iteration.\n    maximum_iterations: Positive scalar `tf.int32` `Tensor`. The maximum number\n      of iterations permitted.\n\n  Returns:\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\n      following attributes.\n      times: Rank 1 real `Tensor`. Times for the computed discount rates.\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\n        The inferred discount rates.\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\n        The inferred discount factors.\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\n        initial guess for the discount rates.\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\n        The procedure is said to have converged when the maximum absolute\n        difference in the discount factors from one iteration to the next falls\n        below the `discount_tolerance`.\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\n        may fail either because a NaN value was encountered for the discount\n        rates or the discount factors.\n      iterations: Scalar `tf.int32` `Tensor`. Number of iterations performed.\n  \"\"\"\n    calc_bond_cashflows = []\n    calc_times = []\n    expiry_times = []\n    expiry_bond_cashflows = []\n    calc_groups = []\n    num_bonds = len(bond_cashflows)\n    for i in range(num_bonds):\n        calc_bond_cashflows.extend([[-present_values[i]], bond_cashflows[i][:-1]])\n        calc_times.extend([[pv_settle_times[i]], bond_cashflow_times[i][:-1]])\n        expiry_times.append(bond_cashflow_times[i][-1])\n        expiry_bond_cashflows.append(bond_cashflows[i][-1])\n        calc_groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    calc_bond_cashflows = tf.concat(calc_bond_cashflows, axis=0)\n    calc_times = tf.concat(calc_times, axis=0)\n    expiry_times = tf.stack(expiry_times, axis=0)\n    expiry_bond_cashflows = tf.stack(expiry_bond_cashflows, axis=0)\n    calc_groups = tf.concat(calc_groups, axis=0)\n\n    def one_step(converged, failed, iteration, expiry_discounts):\n        \"\"\"One step of the iteration.\"\"\"\n        expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n        failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n        calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n        calc_discounts = tf.math.exp(-calc_rates * calc_times)\n        next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n        discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n        return (converged, failed, iteration + 1, next_expiry_discounts)\n\n    def cond(converged, failed, iteration, expiry_discounts):\n        del expiry_discounts, iteration\n        return ~tf.math.logical_or(converged, failed)\n    initial_discount_factors = tf.math.exp(-initial_discount_rates * expiry_times)\n    initial_vals = (False, False, 0, initial_discount_factors)\n    loop_result = tf.while_loop(cond, one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = loop_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = CurveBuilderResult(times=expiry_times, discount_rates=discount_rates, discount_factors=discount_factors, initial_discount_rates=initial_discount_rates, converged=loop_result[0], failed=loop_result[1], iterations=loop_result[2])\n    return results",
        "mutated": [
            "def _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_discount_rates, discount_tolerance, maximum_iterations):\n    if False:\n        i = 10\n    'Estimates the discount curve.\\n\\n  The procedure is recursive and as follows:\\n  1. Assume some initial set of discount rates/discount factors.\\n    Set this as the current yield curve.\\n  2. From the current yield curve, interpolate to get the discount rates\\n    for each time at which bond_cashflows occur.\\n  3. Using these discounts and the known bond prices, compute the discount\\n    rate to expiry of each bond by inverting the bond pricing formula as\\n    follows. We know that the bond price satisfies (`P` is the present value,\\n    `r_i` is the discount rate to time `t_i`, `c_i` is the cashflow occurring at\\n    time `t_i`.):\\n\\n    ```None\\n      P e^{-r_0 t_0} = c_1 e^{-r_1 t_1} + ... + c_n e^{-r_n t_n}        (A)\\n\\n    ```\\n    Assuming we have estimated r_0, r_1, r_2, ..., r_{n-1}, we can invert the\\n    above equation to calculate r_n. We write this in a suggestive form\\n    suitable for the implementation below.\\n\\n    ```None\\n      -c_n z_n = -P z_0 + c_1 z_1 + c_2 z_2 + ... + c_{n-1} z_{n-1}     (B)\\n\\n    ```\\n    where\\n\\n    ```None\\n      z_i = e^{-r_i t_i}      (C)\\n\\n    ```\\n    The RHS of Eq. (B) looks like the PV of cashflows\\n    `[-P, c_1, c_2, ... c_{n-1}]` paid out at times `[t_0, t_1, ..., t_{n-1}]`.\\n\\n    Concatenate these \"synthetic\" cashflow times for each bond:\\n\\n    `Ts = [t1_0, t1_1, ... t1_{n1-1}] + [t2_0, t2_1, ... t2_{n2-1}] ...`\\n\\n    Also concatenate the synthetic bond cashflows as:\\n\\n    `Cs = [-P1, c1_1, ..., c1_{n1-1}] + [-P2, c2_1, ..., c2_{n2-1}] ...`\\n\\n    Then compute `Rs = InterpolateRates[Ts], Zs = exp(-Rs * Ts)`\\n\\n    Let `Zns = [z_n1, z_n2, ... ], Cns = [c1_n, c2_n, ...]` be the discount\\n    factors to expiry and the final cashflow of each bond.\\n    We can derive `Zns = - SegmentSum(Cs * Zs) / Cns`.\\n\\n    From that, we get Rns = -log(Zns) / Tns.\\n    Using this as the next guess for the discount rates and we repeat the\\n    procedure from Step (1) until convergence.\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    pv_settle_times:   List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The settlement times for the present\\n      values is the time from now when the bond is traded to the time that the\\n      purchase price is actually delivered.\\n    initial_discount_rates: Rank 1 `Tensor` of same shape and dtype as\\n      `pv_settle_times`. The initial guess for the discount rates to bond expiry\\n      times.\\n    discount_tolerance: Positive scalar `Tensor` of same dtype as\\n      `initial_discount_factors`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n    maximum_iterations: Positive scalar `tf.int32` `Tensor`. The maximum number\\n      of iterations permitted.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar `tf.int32` `Tensor`. Number of iterations performed.\\n  '\n    calc_bond_cashflows = []\n    calc_times = []\n    expiry_times = []\n    expiry_bond_cashflows = []\n    calc_groups = []\n    num_bonds = len(bond_cashflows)\n    for i in range(num_bonds):\n        calc_bond_cashflows.extend([[-present_values[i]], bond_cashflows[i][:-1]])\n        calc_times.extend([[pv_settle_times[i]], bond_cashflow_times[i][:-1]])\n        expiry_times.append(bond_cashflow_times[i][-1])\n        expiry_bond_cashflows.append(bond_cashflows[i][-1])\n        calc_groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    calc_bond_cashflows = tf.concat(calc_bond_cashflows, axis=0)\n    calc_times = tf.concat(calc_times, axis=0)\n    expiry_times = tf.stack(expiry_times, axis=0)\n    expiry_bond_cashflows = tf.stack(expiry_bond_cashflows, axis=0)\n    calc_groups = tf.concat(calc_groups, axis=0)\n\n    def one_step(converged, failed, iteration, expiry_discounts):\n        \"\"\"One step of the iteration.\"\"\"\n        expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n        failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n        calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n        calc_discounts = tf.math.exp(-calc_rates * calc_times)\n        next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n        discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n        return (converged, failed, iteration + 1, next_expiry_discounts)\n\n    def cond(converged, failed, iteration, expiry_discounts):\n        del expiry_discounts, iteration\n        return ~tf.math.logical_or(converged, failed)\n    initial_discount_factors = tf.math.exp(-initial_discount_rates * expiry_times)\n    initial_vals = (False, False, 0, initial_discount_factors)\n    loop_result = tf.while_loop(cond, one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = loop_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = CurveBuilderResult(times=expiry_times, discount_rates=discount_rates, discount_factors=discount_factors, initial_discount_rates=initial_discount_rates, converged=loop_result[0], failed=loop_result[1], iterations=loop_result[2])\n    return results",
            "def _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_discount_rates, discount_tolerance, maximum_iterations):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Estimates the discount curve.\\n\\n  The procedure is recursive and as follows:\\n  1. Assume some initial set of discount rates/discount factors.\\n    Set this as the current yield curve.\\n  2. From the current yield curve, interpolate to get the discount rates\\n    for each time at which bond_cashflows occur.\\n  3. Using these discounts and the known bond prices, compute the discount\\n    rate to expiry of each bond by inverting the bond pricing formula as\\n    follows. We know that the bond price satisfies (`P` is the present value,\\n    `r_i` is the discount rate to time `t_i`, `c_i` is the cashflow occurring at\\n    time `t_i`.):\\n\\n    ```None\\n      P e^{-r_0 t_0} = c_1 e^{-r_1 t_1} + ... + c_n e^{-r_n t_n}        (A)\\n\\n    ```\\n    Assuming we have estimated r_0, r_1, r_2, ..., r_{n-1}, we can invert the\\n    above equation to calculate r_n. We write this in a suggestive form\\n    suitable for the implementation below.\\n\\n    ```None\\n      -c_n z_n = -P z_0 + c_1 z_1 + c_2 z_2 + ... + c_{n-1} z_{n-1}     (B)\\n\\n    ```\\n    where\\n\\n    ```None\\n      z_i = e^{-r_i t_i}      (C)\\n\\n    ```\\n    The RHS of Eq. (B) looks like the PV of cashflows\\n    `[-P, c_1, c_2, ... c_{n-1}]` paid out at times `[t_0, t_1, ..., t_{n-1}]`.\\n\\n    Concatenate these \"synthetic\" cashflow times for each bond:\\n\\n    `Ts = [t1_0, t1_1, ... t1_{n1-1}] + [t2_0, t2_1, ... t2_{n2-1}] ...`\\n\\n    Also concatenate the synthetic bond cashflows as:\\n\\n    `Cs = [-P1, c1_1, ..., c1_{n1-1}] + [-P2, c2_1, ..., c2_{n2-1}] ...`\\n\\n    Then compute `Rs = InterpolateRates[Ts], Zs = exp(-Rs * Ts)`\\n\\n    Let `Zns = [z_n1, z_n2, ... ], Cns = [c1_n, c2_n, ...]` be the discount\\n    factors to expiry and the final cashflow of each bond.\\n    We can derive `Zns = - SegmentSum(Cs * Zs) / Cns`.\\n\\n    From that, we get Rns = -log(Zns) / Tns.\\n    Using this as the next guess for the discount rates and we repeat the\\n    procedure from Step (1) until convergence.\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    pv_settle_times:   List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The settlement times for the present\\n      values is the time from now when the bond is traded to the time that the\\n      purchase price is actually delivered.\\n    initial_discount_rates: Rank 1 `Tensor` of same shape and dtype as\\n      `pv_settle_times`. The initial guess for the discount rates to bond expiry\\n      times.\\n    discount_tolerance: Positive scalar `Tensor` of same dtype as\\n      `initial_discount_factors`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n    maximum_iterations: Positive scalar `tf.int32` `Tensor`. The maximum number\\n      of iterations permitted.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar `tf.int32` `Tensor`. Number of iterations performed.\\n  '\n    calc_bond_cashflows = []\n    calc_times = []\n    expiry_times = []\n    expiry_bond_cashflows = []\n    calc_groups = []\n    num_bonds = len(bond_cashflows)\n    for i in range(num_bonds):\n        calc_bond_cashflows.extend([[-present_values[i]], bond_cashflows[i][:-1]])\n        calc_times.extend([[pv_settle_times[i]], bond_cashflow_times[i][:-1]])\n        expiry_times.append(bond_cashflow_times[i][-1])\n        expiry_bond_cashflows.append(bond_cashflows[i][-1])\n        calc_groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    calc_bond_cashflows = tf.concat(calc_bond_cashflows, axis=0)\n    calc_times = tf.concat(calc_times, axis=0)\n    expiry_times = tf.stack(expiry_times, axis=0)\n    expiry_bond_cashflows = tf.stack(expiry_bond_cashflows, axis=0)\n    calc_groups = tf.concat(calc_groups, axis=0)\n\n    def one_step(converged, failed, iteration, expiry_discounts):\n        \"\"\"One step of the iteration.\"\"\"\n        expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n        failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n        calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n        calc_discounts = tf.math.exp(-calc_rates * calc_times)\n        next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n        discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n        return (converged, failed, iteration + 1, next_expiry_discounts)\n\n    def cond(converged, failed, iteration, expiry_discounts):\n        del expiry_discounts, iteration\n        return ~tf.math.logical_or(converged, failed)\n    initial_discount_factors = tf.math.exp(-initial_discount_rates * expiry_times)\n    initial_vals = (False, False, 0, initial_discount_factors)\n    loop_result = tf.while_loop(cond, one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = loop_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = CurveBuilderResult(times=expiry_times, discount_rates=discount_rates, discount_factors=discount_factors, initial_discount_rates=initial_discount_rates, converged=loop_result[0], failed=loop_result[1], iterations=loop_result[2])\n    return results",
            "def _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_discount_rates, discount_tolerance, maximum_iterations):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Estimates the discount curve.\\n\\n  The procedure is recursive and as follows:\\n  1. Assume some initial set of discount rates/discount factors.\\n    Set this as the current yield curve.\\n  2. From the current yield curve, interpolate to get the discount rates\\n    for each time at which bond_cashflows occur.\\n  3. Using these discounts and the known bond prices, compute the discount\\n    rate to expiry of each bond by inverting the bond pricing formula as\\n    follows. We know that the bond price satisfies (`P` is the present value,\\n    `r_i` is the discount rate to time `t_i`, `c_i` is the cashflow occurring at\\n    time `t_i`.):\\n\\n    ```None\\n      P e^{-r_0 t_0} = c_1 e^{-r_1 t_1} + ... + c_n e^{-r_n t_n}        (A)\\n\\n    ```\\n    Assuming we have estimated r_0, r_1, r_2, ..., r_{n-1}, we can invert the\\n    above equation to calculate r_n. We write this in a suggestive form\\n    suitable for the implementation below.\\n\\n    ```None\\n      -c_n z_n = -P z_0 + c_1 z_1 + c_2 z_2 + ... + c_{n-1} z_{n-1}     (B)\\n\\n    ```\\n    where\\n\\n    ```None\\n      z_i = e^{-r_i t_i}      (C)\\n\\n    ```\\n    The RHS of Eq. (B) looks like the PV of cashflows\\n    `[-P, c_1, c_2, ... c_{n-1}]` paid out at times `[t_0, t_1, ..., t_{n-1}]`.\\n\\n    Concatenate these \"synthetic\" cashflow times for each bond:\\n\\n    `Ts = [t1_0, t1_1, ... t1_{n1-1}] + [t2_0, t2_1, ... t2_{n2-1}] ...`\\n\\n    Also concatenate the synthetic bond cashflows as:\\n\\n    `Cs = [-P1, c1_1, ..., c1_{n1-1}] + [-P2, c2_1, ..., c2_{n2-1}] ...`\\n\\n    Then compute `Rs = InterpolateRates[Ts], Zs = exp(-Rs * Ts)`\\n\\n    Let `Zns = [z_n1, z_n2, ... ], Cns = [c1_n, c2_n, ...]` be the discount\\n    factors to expiry and the final cashflow of each bond.\\n    We can derive `Zns = - SegmentSum(Cs * Zs) / Cns`.\\n\\n    From that, we get Rns = -log(Zns) / Tns.\\n    Using this as the next guess for the discount rates and we repeat the\\n    procedure from Step (1) until convergence.\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    pv_settle_times:   List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The settlement times for the present\\n      values is the time from now when the bond is traded to the time that the\\n      purchase price is actually delivered.\\n    initial_discount_rates: Rank 1 `Tensor` of same shape and dtype as\\n      `pv_settle_times`. The initial guess for the discount rates to bond expiry\\n      times.\\n    discount_tolerance: Positive scalar `Tensor` of same dtype as\\n      `initial_discount_factors`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n    maximum_iterations: Positive scalar `tf.int32` `Tensor`. The maximum number\\n      of iterations permitted.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar `tf.int32` `Tensor`. Number of iterations performed.\\n  '\n    calc_bond_cashflows = []\n    calc_times = []\n    expiry_times = []\n    expiry_bond_cashflows = []\n    calc_groups = []\n    num_bonds = len(bond_cashflows)\n    for i in range(num_bonds):\n        calc_bond_cashflows.extend([[-present_values[i]], bond_cashflows[i][:-1]])\n        calc_times.extend([[pv_settle_times[i]], bond_cashflow_times[i][:-1]])\n        expiry_times.append(bond_cashflow_times[i][-1])\n        expiry_bond_cashflows.append(bond_cashflows[i][-1])\n        calc_groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    calc_bond_cashflows = tf.concat(calc_bond_cashflows, axis=0)\n    calc_times = tf.concat(calc_times, axis=0)\n    expiry_times = tf.stack(expiry_times, axis=0)\n    expiry_bond_cashflows = tf.stack(expiry_bond_cashflows, axis=0)\n    calc_groups = tf.concat(calc_groups, axis=0)\n\n    def one_step(converged, failed, iteration, expiry_discounts):\n        \"\"\"One step of the iteration.\"\"\"\n        expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n        failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n        calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n        calc_discounts = tf.math.exp(-calc_rates * calc_times)\n        next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n        discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n        return (converged, failed, iteration + 1, next_expiry_discounts)\n\n    def cond(converged, failed, iteration, expiry_discounts):\n        del expiry_discounts, iteration\n        return ~tf.math.logical_or(converged, failed)\n    initial_discount_factors = tf.math.exp(-initial_discount_rates * expiry_times)\n    initial_vals = (False, False, 0, initial_discount_factors)\n    loop_result = tf.while_loop(cond, one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = loop_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = CurveBuilderResult(times=expiry_times, discount_rates=discount_rates, discount_factors=discount_factors, initial_discount_rates=initial_discount_rates, converged=loop_result[0], failed=loop_result[1], iterations=loop_result[2])\n    return results",
            "def _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_discount_rates, discount_tolerance, maximum_iterations):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Estimates the discount curve.\\n\\n  The procedure is recursive and as follows:\\n  1. Assume some initial set of discount rates/discount factors.\\n    Set this as the current yield curve.\\n  2. From the current yield curve, interpolate to get the discount rates\\n    for each time at which bond_cashflows occur.\\n  3. Using these discounts and the known bond prices, compute the discount\\n    rate to expiry of each bond by inverting the bond pricing formula as\\n    follows. We know that the bond price satisfies (`P` is the present value,\\n    `r_i` is the discount rate to time `t_i`, `c_i` is the cashflow occurring at\\n    time `t_i`.):\\n\\n    ```None\\n      P e^{-r_0 t_0} = c_1 e^{-r_1 t_1} + ... + c_n e^{-r_n t_n}        (A)\\n\\n    ```\\n    Assuming we have estimated r_0, r_1, r_2, ..., r_{n-1}, we can invert the\\n    above equation to calculate r_n. We write this in a suggestive form\\n    suitable for the implementation below.\\n\\n    ```None\\n      -c_n z_n = -P z_0 + c_1 z_1 + c_2 z_2 + ... + c_{n-1} z_{n-1}     (B)\\n\\n    ```\\n    where\\n\\n    ```None\\n      z_i = e^{-r_i t_i}      (C)\\n\\n    ```\\n    The RHS of Eq. (B) looks like the PV of cashflows\\n    `[-P, c_1, c_2, ... c_{n-1}]` paid out at times `[t_0, t_1, ..., t_{n-1}]`.\\n\\n    Concatenate these \"synthetic\" cashflow times for each bond:\\n\\n    `Ts = [t1_0, t1_1, ... t1_{n1-1}] + [t2_0, t2_1, ... t2_{n2-1}] ...`\\n\\n    Also concatenate the synthetic bond cashflows as:\\n\\n    `Cs = [-P1, c1_1, ..., c1_{n1-1}] + [-P2, c2_1, ..., c2_{n2-1}] ...`\\n\\n    Then compute `Rs = InterpolateRates[Ts], Zs = exp(-Rs * Ts)`\\n\\n    Let `Zns = [z_n1, z_n2, ... ], Cns = [c1_n, c2_n, ...]` be the discount\\n    factors to expiry and the final cashflow of each bond.\\n    We can derive `Zns = - SegmentSum(Cs * Zs) / Cns`.\\n\\n    From that, we get Rns = -log(Zns) / Tns.\\n    Using this as the next guess for the discount rates and we repeat the\\n    procedure from Step (1) until convergence.\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    pv_settle_times:   List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The settlement times for the present\\n      values is the time from now when the bond is traded to the time that the\\n      purchase price is actually delivered.\\n    initial_discount_rates: Rank 1 `Tensor` of same shape and dtype as\\n      `pv_settle_times`. The initial guess for the discount rates to bond expiry\\n      times.\\n    discount_tolerance: Positive scalar `Tensor` of same dtype as\\n      `initial_discount_factors`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n    maximum_iterations: Positive scalar `tf.int32` `Tensor`. The maximum number\\n      of iterations permitted.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar `tf.int32` `Tensor`. Number of iterations performed.\\n  '\n    calc_bond_cashflows = []\n    calc_times = []\n    expiry_times = []\n    expiry_bond_cashflows = []\n    calc_groups = []\n    num_bonds = len(bond_cashflows)\n    for i in range(num_bonds):\n        calc_bond_cashflows.extend([[-present_values[i]], bond_cashflows[i][:-1]])\n        calc_times.extend([[pv_settle_times[i]], bond_cashflow_times[i][:-1]])\n        expiry_times.append(bond_cashflow_times[i][-1])\n        expiry_bond_cashflows.append(bond_cashflows[i][-1])\n        calc_groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    calc_bond_cashflows = tf.concat(calc_bond_cashflows, axis=0)\n    calc_times = tf.concat(calc_times, axis=0)\n    expiry_times = tf.stack(expiry_times, axis=0)\n    expiry_bond_cashflows = tf.stack(expiry_bond_cashflows, axis=0)\n    calc_groups = tf.concat(calc_groups, axis=0)\n\n    def one_step(converged, failed, iteration, expiry_discounts):\n        \"\"\"One step of the iteration.\"\"\"\n        expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n        failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n        calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n        calc_discounts = tf.math.exp(-calc_rates * calc_times)\n        next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n        discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n        return (converged, failed, iteration + 1, next_expiry_discounts)\n\n    def cond(converged, failed, iteration, expiry_discounts):\n        del expiry_discounts, iteration\n        return ~tf.math.logical_or(converged, failed)\n    initial_discount_factors = tf.math.exp(-initial_discount_rates * expiry_times)\n    initial_vals = (False, False, 0, initial_discount_factors)\n    loop_result = tf.while_loop(cond, one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = loop_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = CurveBuilderResult(times=expiry_times, discount_rates=discount_rates, discount_factors=discount_factors, initial_discount_rates=initial_discount_rates, converged=loop_result[0], failed=loop_result[1], iterations=loop_result[2])\n    return results",
            "def _build_discount_curve(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times, initial_discount_rates, discount_tolerance, maximum_iterations):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Estimates the discount curve.\\n\\n  The procedure is recursive and as follows:\\n  1. Assume some initial set of discount rates/discount factors.\\n    Set this as the current yield curve.\\n  2. From the current yield curve, interpolate to get the discount rates\\n    for each time at which bond_cashflows occur.\\n  3. Using these discounts and the known bond prices, compute the discount\\n    rate to expiry of each bond by inverting the bond pricing formula as\\n    follows. We know that the bond price satisfies (`P` is the present value,\\n    `r_i` is the discount rate to time `t_i`, `c_i` is the cashflow occurring at\\n    time `t_i`.):\\n\\n    ```None\\n      P e^{-r_0 t_0} = c_1 e^{-r_1 t_1} + ... + c_n e^{-r_n t_n}        (A)\\n\\n    ```\\n    Assuming we have estimated r_0, r_1, r_2, ..., r_{n-1}, we can invert the\\n    above equation to calculate r_n. We write this in a suggestive form\\n    suitable for the implementation below.\\n\\n    ```None\\n      -c_n z_n = -P z_0 + c_1 z_1 + c_2 z_2 + ... + c_{n-1} z_{n-1}     (B)\\n\\n    ```\\n    where\\n\\n    ```None\\n      z_i = e^{-r_i t_i}      (C)\\n\\n    ```\\n    The RHS of Eq. (B) looks like the PV of cashflows\\n    `[-P, c_1, c_2, ... c_{n-1}]` paid out at times `[t_0, t_1, ..., t_{n-1}]`.\\n\\n    Concatenate these \"synthetic\" cashflow times for each bond:\\n\\n    `Ts = [t1_0, t1_1, ... t1_{n1-1}] + [t2_0, t2_1, ... t2_{n2-1}] ...`\\n\\n    Also concatenate the synthetic bond cashflows as:\\n\\n    `Cs = [-P1, c1_1, ..., c1_{n1-1}] + [-P2, c2_1, ..., c2_{n2-1}] ...`\\n\\n    Then compute `Rs = InterpolateRates[Ts], Zs = exp(-Rs * Ts)`\\n\\n    Let `Zns = [z_n1, z_n2, ... ], Cns = [c1_n, c2_n, ...]` be the discount\\n    factors to expiry and the final cashflow of each bond.\\n    We can derive `Zns = - SegmentSum(Cs * Zs) / Cns`.\\n\\n    From that, we get Rns = -log(Zns) / Tns.\\n    Using this as the next guess for the discount rates and we repeat the\\n    procedure from Step (1) until convergence.\\n\\n  Args:\\n    bond_cashflows: List of `Tensor`s. Each `Tensor` must be of rank 1 and of\\n      the same real dtype. They may be of different sizes. Each `Tensor`\\n      represents the bond cashflows defining a particular bond. The elements of\\n      the list are the bonds to be used to build the curve.\\n    bond_cashflow_times: List of `Tensor`s. The list must be of the same length\\n      as the `bond_cashflows` and each `Tensor` in the list must be of the same\\n      length as the `Tensor` at the same index in the `bond_cashflows` list.\\n      Each `Tensor` must be of rank 1 and of the same dtype as the `Tensor`s in\\n      `bond_cashflows` and contain strictly positive and increasing values. The\\n      times of the bond cashflows for the bonds must in an ascending order.\\n    present_values: List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The market price (i.e the all-in or dirty\\n      price) of the bond cashflows supplied in the `bond_cashflows`.\\n    pv_settle_times:   List containing scalar `Tensor`s of the same dtype as\\n      elements of `bond_cashflows`. The length of the list must be the same as\\n      the length of `bond_cashflows`. The settlement times for the present\\n      values is the time from now when the bond is traded to the time that the\\n      purchase price is actually delivered.\\n    initial_discount_rates: Rank 1 `Tensor` of same shape and dtype as\\n      `pv_settle_times`. The initial guess for the discount rates to bond expiry\\n      times.\\n    discount_tolerance: Positive scalar `Tensor` of same dtype as\\n      `initial_discount_factors`. The absolute tolerance for terminating the\\n      iterations used to fit the rate curve. The iterations are stopped when the\\n      estimated discounts at the expiry times of the bond cashflows change by a\\n      amount smaller than `discount_tolerance` in an iteration.\\n    maximum_iterations: Positive scalar `tf.int32` `Tensor`. The maximum number\\n      of iterations permitted.\\n\\n  Returns:\\n    curve_builder_result: An instance of `CurveBuilderResult` containing the\\n      following attributes.\\n      times: Rank 1 real `Tensor`. Times for the computed discount rates.\\n      discount_rates: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount rates.\\n      discount_factor: Rank 1 `Tensor` of the same dtype as `times`.\\n        The inferred discount factors.\\n      initial_discount_rates: Rank 1 `Tensor` of the same dtype as `times`. The\\n        initial guess for the discount rates.\\n      converged: Scalar boolean `Tensor`. Whether the procedure converged.\\n        The procedure is said to have converged when the maximum absolute\\n        difference in the discount factors from one iteration to the next falls\\n        below the `discount_tolerance`.\\n      failed: Scalar boolean `Tensor`. Whether the procedure failed. Procedure\\n        may fail either because a NaN value was encountered for the discount\\n        rates or the discount factors.\\n      iterations: Scalar `tf.int32` `Tensor`. Number of iterations performed.\\n  '\n    calc_bond_cashflows = []\n    calc_times = []\n    expiry_times = []\n    expiry_bond_cashflows = []\n    calc_groups = []\n    num_bonds = len(bond_cashflows)\n    for i in range(num_bonds):\n        calc_bond_cashflows.extend([[-present_values[i]], bond_cashflows[i][:-1]])\n        calc_times.extend([[pv_settle_times[i]], bond_cashflow_times[i][:-1]])\n        expiry_times.append(bond_cashflow_times[i][-1])\n        expiry_bond_cashflows.append(bond_cashflows[i][-1])\n        calc_groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    calc_bond_cashflows = tf.concat(calc_bond_cashflows, axis=0)\n    calc_times = tf.concat(calc_times, axis=0)\n    expiry_times = tf.stack(expiry_times, axis=0)\n    expiry_bond_cashflows = tf.stack(expiry_bond_cashflows, axis=0)\n    calc_groups = tf.concat(calc_groups, axis=0)\n\n    def one_step(converged, failed, iteration, expiry_discounts):\n        \"\"\"One step of the iteration.\"\"\"\n        expiry_rates = -tf.math.log(expiry_discounts) / expiry_times\n        failed = tf.math.reduce_any(tf.math.is_nan(expiry_rates) | tf.math.is_nan(expiry_discounts))\n        calc_rates = monotone_convex.interpolate_yields(calc_times, expiry_times, yields=expiry_rates)\n        calc_discounts = tf.math.exp(-calc_rates * calc_times)\n        next_expiry_discounts = -tf.math.segment_sum(calc_bond_cashflows * calc_discounts, calc_groups) / expiry_bond_cashflows\n        discount_diff = tf.math.abs(next_expiry_discounts - expiry_discounts)\n        converged = ~tf.math.reduce_any(tf.math.is_nan(discount_diff)) & (tf.math.reduce_max(discount_diff) < discount_tolerance)\n        return (converged, failed, iteration + 1, next_expiry_discounts)\n\n    def cond(converged, failed, iteration, expiry_discounts):\n        del expiry_discounts, iteration\n        return ~tf.math.logical_or(converged, failed)\n    initial_discount_factors = tf.math.exp(-initial_discount_rates * expiry_times)\n    initial_vals = (False, False, 0, initial_discount_factors)\n    loop_result = tf.while_loop(cond, one_step, initial_vals, maximum_iterations=maximum_iterations)\n    discount_factors = loop_result[-1]\n    discount_rates = -tf.math.log(discount_factors) / expiry_times\n    results = CurveBuilderResult(times=expiry_times, discount_rates=discount_rates, discount_factors=discount_factors, initial_discount_rates=initial_discount_rates, converged=loop_result[0], failed=loop_result[1], iterations=loop_result[2])\n    return results"
        ]
    },
    {
        "func_name": "_initial_discount_rates",
        "original": "def _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_discount_rates'):\n    \"\"\"Constructs a guess for the initial rates as the yields to maturity.\"\"\"\n    n = len(bond_cashflows)\n    groups = []\n    for i in range(n):\n        groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    bond_cashflows = tf.concat(bond_cashflows, axis=0)\n    bond_cashflow_times = tf.concat(bond_cashflow_times, axis=0)\n    groups = tf.concat(groups, axis=0)\n    return cashflows.yields_from_pv(bond_cashflows, bond_cashflow_times, present_values, groups=groups, name=name)",
        "mutated": [
            "def _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_discount_rates'):\n    if False:\n        i = 10\n    'Constructs a guess for the initial rates as the yields to maturity.'\n    n = len(bond_cashflows)\n    groups = []\n    for i in range(n):\n        groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    bond_cashflows = tf.concat(bond_cashflows, axis=0)\n    bond_cashflow_times = tf.concat(bond_cashflow_times, axis=0)\n    groups = tf.concat(groups, axis=0)\n    return cashflows.yields_from_pv(bond_cashflows, bond_cashflow_times, present_values, groups=groups, name=name)",
            "def _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_discount_rates'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Constructs a guess for the initial rates as the yields to maturity.'\n    n = len(bond_cashflows)\n    groups = []\n    for i in range(n):\n        groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    bond_cashflows = tf.concat(bond_cashflows, axis=0)\n    bond_cashflow_times = tf.concat(bond_cashflow_times, axis=0)\n    groups = tf.concat(groups, axis=0)\n    return cashflows.yields_from_pv(bond_cashflows, bond_cashflow_times, present_values, groups=groups, name=name)",
            "def _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_discount_rates'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Constructs a guess for the initial rates as the yields to maturity.'\n    n = len(bond_cashflows)\n    groups = []\n    for i in range(n):\n        groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    bond_cashflows = tf.concat(bond_cashflows, axis=0)\n    bond_cashflow_times = tf.concat(bond_cashflow_times, axis=0)\n    groups = tf.concat(groups, axis=0)\n    return cashflows.yields_from_pv(bond_cashflows, bond_cashflow_times, present_values, groups=groups, name=name)",
            "def _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_discount_rates'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Constructs a guess for the initial rates as the yields to maturity.'\n    n = len(bond_cashflows)\n    groups = []\n    for i in range(n):\n        groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    bond_cashflows = tf.concat(bond_cashflows, axis=0)\n    bond_cashflow_times = tf.concat(bond_cashflow_times, axis=0)\n    groups = tf.concat(groups, axis=0)\n    return cashflows.yields_from_pv(bond_cashflows, bond_cashflow_times, present_values, groups=groups, name=name)",
            "def _initial_discount_rates(bond_cashflows, bond_cashflow_times, present_values, name='initial_discount_rates'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Constructs a guess for the initial rates as the yields to maturity.'\n    n = len(bond_cashflows)\n    groups = []\n    for i in range(n):\n        groups.append(tf.fill(tf.shape(bond_cashflows[i]), i))\n    bond_cashflows = tf.concat(bond_cashflows, axis=0)\n    bond_cashflow_times = tf.concat(bond_cashflow_times, axis=0)\n    groups = tf.concat(groups, axis=0)\n    return cashflows.yields_from_pv(bond_cashflows, bond_cashflow_times, present_values, groups=groups, name=name)"
        ]
    },
    {
        "func_name": "_perform_static_validation",
        "original": "def _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    \"\"\"Performs static validation on the arguments.\"\"\"\n    if len(bond_cashflows) != len(bond_cashflow_times):\n        raise ValueError('Cashflow times and bond_cashflows must be of the same length.bond_cashflows are of size {} and times of size {}'.format(len(bond_cashflows), len(bond_cashflow_times)))\n    if len(bond_cashflows) != len(present_values):\n        raise ValueError('Present values and bond_cashflows must be of the same length.bond_cashflows are of size {} and PVs of size {}'.format(len(bond_cashflows), len(present_values)))\n    if len(present_values) != len(pv_settle_times):\n        raise ValueError('Present value settlement times and present values must be ofthe same length. Settlement times are of size {} and PVs of size {}'.format(len(pv_settle_times), len(present_values)))\n    if len(bond_cashflows) < 2:\n        raise ValueError('At least two bonds must be supplied to calibrate the curve.Found {}.'.format(len(bond_cashflows)))",
        "mutated": [
            "def _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n    'Performs static validation on the arguments.'\n    if len(bond_cashflows) != len(bond_cashflow_times):\n        raise ValueError('Cashflow times and bond_cashflows must be of the same length.bond_cashflows are of size {} and times of size {}'.format(len(bond_cashflows), len(bond_cashflow_times)))\n    if len(bond_cashflows) != len(present_values):\n        raise ValueError('Present values and bond_cashflows must be of the same length.bond_cashflows are of size {} and PVs of size {}'.format(len(bond_cashflows), len(present_values)))\n    if len(present_values) != len(pv_settle_times):\n        raise ValueError('Present value settlement times and present values must be ofthe same length. Settlement times are of size {} and PVs of size {}'.format(len(pv_settle_times), len(present_values)))\n    if len(bond_cashflows) < 2:\n        raise ValueError('At least two bonds must be supplied to calibrate the curve.Found {}.'.format(len(bond_cashflows)))",
            "def _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Performs static validation on the arguments.'\n    if len(bond_cashflows) != len(bond_cashflow_times):\n        raise ValueError('Cashflow times and bond_cashflows must be of the same length.bond_cashflows are of size {} and times of size {}'.format(len(bond_cashflows), len(bond_cashflow_times)))\n    if len(bond_cashflows) != len(present_values):\n        raise ValueError('Present values and bond_cashflows must be of the same length.bond_cashflows are of size {} and PVs of size {}'.format(len(bond_cashflows), len(present_values)))\n    if len(present_values) != len(pv_settle_times):\n        raise ValueError('Present value settlement times and present values must be ofthe same length. Settlement times are of size {} and PVs of size {}'.format(len(pv_settle_times), len(present_values)))\n    if len(bond_cashflows) < 2:\n        raise ValueError('At least two bonds must be supplied to calibrate the curve.Found {}.'.format(len(bond_cashflows)))",
            "def _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Performs static validation on the arguments.'\n    if len(bond_cashflows) != len(bond_cashflow_times):\n        raise ValueError('Cashflow times and bond_cashflows must be of the same length.bond_cashflows are of size {} and times of size {}'.format(len(bond_cashflows), len(bond_cashflow_times)))\n    if len(bond_cashflows) != len(present_values):\n        raise ValueError('Present values and bond_cashflows must be of the same length.bond_cashflows are of size {} and PVs of size {}'.format(len(bond_cashflows), len(present_values)))\n    if len(present_values) != len(pv_settle_times):\n        raise ValueError('Present value settlement times and present values must be ofthe same length. Settlement times are of size {} and PVs of size {}'.format(len(pv_settle_times), len(present_values)))\n    if len(bond_cashflows) < 2:\n        raise ValueError('At least two bonds must be supplied to calibrate the curve.Found {}.'.format(len(bond_cashflows)))",
            "def _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Performs static validation on the arguments.'\n    if len(bond_cashflows) != len(bond_cashflow_times):\n        raise ValueError('Cashflow times and bond_cashflows must be of the same length.bond_cashflows are of size {} and times of size {}'.format(len(bond_cashflows), len(bond_cashflow_times)))\n    if len(bond_cashflows) != len(present_values):\n        raise ValueError('Present values and bond_cashflows must be of the same length.bond_cashflows are of size {} and PVs of size {}'.format(len(bond_cashflows), len(present_values)))\n    if len(present_values) != len(pv_settle_times):\n        raise ValueError('Present value settlement times and present values must be ofthe same length. Settlement times are of size {} and PVs of size {}'.format(len(pv_settle_times), len(present_values)))\n    if len(bond_cashflows) < 2:\n        raise ValueError('At least two bonds must be supplied to calibrate the curve.Found {}.'.format(len(bond_cashflows)))",
            "def _perform_static_validation(bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Performs static validation on the arguments.'\n    if len(bond_cashflows) != len(bond_cashflow_times):\n        raise ValueError('Cashflow times and bond_cashflows must be of the same length.bond_cashflows are of size {} and times of size {}'.format(len(bond_cashflows), len(bond_cashflow_times)))\n    if len(bond_cashflows) != len(present_values):\n        raise ValueError('Present values and bond_cashflows must be of the same length.bond_cashflows are of size {} and PVs of size {}'.format(len(bond_cashflows), len(present_values)))\n    if len(present_values) != len(pv_settle_times):\n        raise ValueError('Present value settlement times and present values must be ofthe same length. Settlement times are of size {} and PVs of size {}'.format(len(pv_settle_times), len(present_values)))\n    if len(bond_cashflows) < 2:\n        raise ValueError('At least two bonds must be supplied to calibrate the curve.Found {}.'.format(len(bond_cashflows)))"
        ]
    },
    {
        "func_name": "_validate_args_control_deps",
        "original": "def _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times):\n    \"\"\"Returns assertions for the validity of the arguments.\"\"\"\n    cashflows_are_strictly_increasing = []\n    cashflow_after_settlement = []\n    final_cashflow_is_the_largest = []\n    for (bond_index, bond_cashflow) in enumerate(bond_cashflows):\n        times = bond_cashflow_times[bond_index]\n        time_difference = times[1:] - times[:-1]\n        cashflows_are_strictly_increasing.append(tf.debugging.assert_positive(time_difference))\n        cashflow_after_settlement.append(tf.debugging.assert_greater(times[0], pv_settle_times[bond_index]))\n        final_cashflow_is_the_largest.append(tf.debugging.assert_greater(tf.fill(tf.shape(bond_cashflow[:-1]), bond_cashflow[-1]), bond_cashflow[:-1]))\n    return cashflow_after_settlement + cashflows_are_strictly_increasing + final_cashflow_is_the_largest",
        "mutated": [
            "def _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times):\n    if False:\n        i = 10\n    'Returns assertions for the validity of the arguments.'\n    cashflows_are_strictly_increasing = []\n    cashflow_after_settlement = []\n    final_cashflow_is_the_largest = []\n    for (bond_index, bond_cashflow) in enumerate(bond_cashflows):\n        times = bond_cashflow_times[bond_index]\n        time_difference = times[1:] - times[:-1]\n        cashflows_are_strictly_increasing.append(tf.debugging.assert_positive(time_difference))\n        cashflow_after_settlement.append(tf.debugging.assert_greater(times[0], pv_settle_times[bond_index]))\n        final_cashflow_is_the_largest.append(tf.debugging.assert_greater(tf.fill(tf.shape(bond_cashflow[:-1]), bond_cashflow[-1]), bond_cashflow[:-1]))\n    return cashflow_after_settlement + cashflows_are_strictly_increasing + final_cashflow_is_the_largest",
            "def _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns assertions for the validity of the arguments.'\n    cashflows_are_strictly_increasing = []\n    cashflow_after_settlement = []\n    final_cashflow_is_the_largest = []\n    for (bond_index, bond_cashflow) in enumerate(bond_cashflows):\n        times = bond_cashflow_times[bond_index]\n        time_difference = times[1:] - times[:-1]\n        cashflows_are_strictly_increasing.append(tf.debugging.assert_positive(time_difference))\n        cashflow_after_settlement.append(tf.debugging.assert_greater(times[0], pv_settle_times[bond_index]))\n        final_cashflow_is_the_largest.append(tf.debugging.assert_greater(tf.fill(tf.shape(bond_cashflow[:-1]), bond_cashflow[-1]), bond_cashflow[:-1]))\n    return cashflow_after_settlement + cashflows_are_strictly_increasing + final_cashflow_is_the_largest",
            "def _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns assertions for the validity of the arguments.'\n    cashflows_are_strictly_increasing = []\n    cashflow_after_settlement = []\n    final_cashflow_is_the_largest = []\n    for (bond_index, bond_cashflow) in enumerate(bond_cashflows):\n        times = bond_cashflow_times[bond_index]\n        time_difference = times[1:] - times[:-1]\n        cashflows_are_strictly_increasing.append(tf.debugging.assert_positive(time_difference))\n        cashflow_after_settlement.append(tf.debugging.assert_greater(times[0], pv_settle_times[bond_index]))\n        final_cashflow_is_the_largest.append(tf.debugging.assert_greater(tf.fill(tf.shape(bond_cashflow[:-1]), bond_cashflow[-1]), bond_cashflow[:-1]))\n    return cashflow_after_settlement + cashflows_are_strictly_increasing + final_cashflow_is_the_largest",
            "def _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns assertions for the validity of the arguments.'\n    cashflows_are_strictly_increasing = []\n    cashflow_after_settlement = []\n    final_cashflow_is_the_largest = []\n    for (bond_index, bond_cashflow) in enumerate(bond_cashflows):\n        times = bond_cashflow_times[bond_index]\n        time_difference = times[1:] - times[:-1]\n        cashflows_are_strictly_increasing.append(tf.debugging.assert_positive(time_difference))\n        cashflow_after_settlement.append(tf.debugging.assert_greater(times[0], pv_settle_times[bond_index]))\n        final_cashflow_is_the_largest.append(tf.debugging.assert_greater(tf.fill(tf.shape(bond_cashflow[:-1]), bond_cashflow[-1]), bond_cashflow[:-1]))\n    return cashflow_after_settlement + cashflows_are_strictly_increasing + final_cashflow_is_the_largest",
            "def _validate_args_control_deps(bond_cashflows, bond_cashflow_times, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns assertions for the validity of the arguments.'\n    cashflows_are_strictly_increasing = []\n    cashflow_after_settlement = []\n    final_cashflow_is_the_largest = []\n    for (bond_index, bond_cashflow) in enumerate(bond_cashflows):\n        times = bond_cashflow_times[bond_index]\n        time_difference = times[1:] - times[:-1]\n        cashflows_are_strictly_increasing.append(tf.debugging.assert_positive(time_difference))\n        cashflow_after_settlement.append(tf.debugging.assert_greater(times[0], pv_settle_times[bond_index]))\n        final_cashflow_is_the_largest.append(tf.debugging.assert_greater(tf.fill(tf.shape(bond_cashflow[:-1]), bond_cashflow[-1]), bond_cashflow[:-1]))\n    return cashflow_after_settlement + cashflows_are_strictly_increasing + final_cashflow_is_the_largest"
        ]
    },
    {
        "func_name": "_convert_to_tensors",
        "original": "def _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    \"\"\"Converts each element of the supplied lists to a tensor.\"\"\"\n    bond_cashflows = [tf.convert_to_tensor(cashflow, dtype=dtype, name='cashflows_bond_{}'.format(i)) for (i, cashflow) in enumerate(bond_cashflows)]\n    bond_cashflow_times = [tf.convert_to_tensor(cashflow_times, dtype=dtype, name='cashflow_times_bond_{}'.format(i)) for (i, cashflow_times) in enumerate(bond_cashflow_times)]\n    present_values = [tf.convert_to_tensor(pv, dtype=dtype, name='pv_bond_{}'.format(i)) for (i, pv) in enumerate(present_values)]\n    pv_settle_times = [tf.convert_to_tensor(pv_time, dtype=dtype, name='pv_settle_time_bond_{}'.format(i)) for (i, pv_time) in enumerate(pv_settle_times)]\n    return (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)",
        "mutated": [
            "def _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n    'Converts each element of the supplied lists to a tensor.'\n    bond_cashflows = [tf.convert_to_tensor(cashflow, dtype=dtype, name='cashflows_bond_{}'.format(i)) for (i, cashflow) in enumerate(bond_cashflows)]\n    bond_cashflow_times = [tf.convert_to_tensor(cashflow_times, dtype=dtype, name='cashflow_times_bond_{}'.format(i)) for (i, cashflow_times) in enumerate(bond_cashflow_times)]\n    present_values = [tf.convert_to_tensor(pv, dtype=dtype, name='pv_bond_{}'.format(i)) for (i, pv) in enumerate(present_values)]\n    pv_settle_times = [tf.convert_to_tensor(pv_time, dtype=dtype, name='pv_settle_time_bond_{}'.format(i)) for (i, pv_time) in enumerate(pv_settle_times)]\n    return (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)",
            "def _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Converts each element of the supplied lists to a tensor.'\n    bond_cashflows = [tf.convert_to_tensor(cashflow, dtype=dtype, name='cashflows_bond_{}'.format(i)) for (i, cashflow) in enumerate(bond_cashflows)]\n    bond_cashflow_times = [tf.convert_to_tensor(cashflow_times, dtype=dtype, name='cashflow_times_bond_{}'.format(i)) for (i, cashflow_times) in enumerate(bond_cashflow_times)]\n    present_values = [tf.convert_to_tensor(pv, dtype=dtype, name='pv_bond_{}'.format(i)) for (i, pv) in enumerate(present_values)]\n    pv_settle_times = [tf.convert_to_tensor(pv_time, dtype=dtype, name='pv_settle_time_bond_{}'.format(i)) for (i, pv_time) in enumerate(pv_settle_times)]\n    return (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)",
            "def _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Converts each element of the supplied lists to a tensor.'\n    bond_cashflows = [tf.convert_to_tensor(cashflow, dtype=dtype, name='cashflows_bond_{}'.format(i)) for (i, cashflow) in enumerate(bond_cashflows)]\n    bond_cashflow_times = [tf.convert_to_tensor(cashflow_times, dtype=dtype, name='cashflow_times_bond_{}'.format(i)) for (i, cashflow_times) in enumerate(bond_cashflow_times)]\n    present_values = [tf.convert_to_tensor(pv, dtype=dtype, name='pv_bond_{}'.format(i)) for (i, pv) in enumerate(present_values)]\n    pv_settle_times = [tf.convert_to_tensor(pv_time, dtype=dtype, name='pv_settle_time_bond_{}'.format(i)) for (i, pv_time) in enumerate(pv_settle_times)]\n    return (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)",
            "def _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Converts each element of the supplied lists to a tensor.'\n    bond_cashflows = [tf.convert_to_tensor(cashflow, dtype=dtype, name='cashflows_bond_{}'.format(i)) for (i, cashflow) in enumerate(bond_cashflows)]\n    bond_cashflow_times = [tf.convert_to_tensor(cashflow_times, dtype=dtype, name='cashflow_times_bond_{}'.format(i)) for (i, cashflow_times) in enumerate(bond_cashflow_times)]\n    present_values = [tf.convert_to_tensor(pv, dtype=dtype, name='pv_bond_{}'.format(i)) for (i, pv) in enumerate(present_values)]\n    pv_settle_times = [tf.convert_to_tensor(pv_time, dtype=dtype, name='pv_settle_time_bond_{}'.format(i)) for (i, pv_time) in enumerate(pv_settle_times)]\n    return (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)",
            "def _convert_to_tensors(dtype, bond_cashflows, bond_cashflow_times, present_values, pv_settle_times):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Converts each element of the supplied lists to a tensor.'\n    bond_cashflows = [tf.convert_to_tensor(cashflow, dtype=dtype, name='cashflows_bond_{}'.format(i)) for (i, cashflow) in enumerate(bond_cashflows)]\n    bond_cashflow_times = [tf.convert_to_tensor(cashflow_times, dtype=dtype, name='cashflow_times_bond_{}'.format(i)) for (i, cashflow_times) in enumerate(bond_cashflow_times)]\n    present_values = [tf.convert_to_tensor(pv, dtype=dtype, name='pv_bond_{}'.format(i)) for (i, pv) in enumerate(present_values)]\n    pv_settle_times = [tf.convert_to_tensor(pv_time, dtype=dtype, name='pv_settle_time_bond_{}'.format(i)) for (i, pv_time) in enumerate(pv_settle_times)]\n    return (bond_cashflows, bond_cashflow_times, present_values, pv_settle_times)"
        ]
    }
]