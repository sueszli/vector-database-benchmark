[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.start = time.time()",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.start = time.time()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.start = time.time()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.start = time.time()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.start = time.time()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.start = time.time()"
        ]
    },
    {
        "func_name": "info",
        "original": "def info(self):\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
        "mutated": [
            "def info(self):\n    if False:\n        i = 10\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
            "def info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
            "def info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
            "def info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
            "def info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [ray._private.worker.global_worker.node.unique_id, self.start]"
        ]
    },
    {
        "func_name": "create",
        "original": "def create(self, num):\n    ret_list = []\n    for _ in range(num):\n        start_time = time.time()\n        ret_list.append([start_time, BottomActor.remote()])\n    return ret_list",
        "mutated": [
            "def create(self, num):\n    if False:\n        i = 10\n    ret_list = []\n    for _ in range(num):\n        start_time = time.time()\n        ret_list.append([start_time, BottomActor.remote()])\n    return ret_list",
            "def create(self, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ret_list = []\n    for _ in range(num):\n        start_time = time.time()\n        ret_list.append([start_time, BottomActor.remote()])\n    return ret_list",
            "def create(self, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ret_list = []\n    for _ in range(num):\n        start_time = time.time()\n        ret_list.append([start_time, BottomActor.remote()])\n    return ret_list",
            "def create(self, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ret_list = []\n    for _ in range(num):\n        start_time = time.time()\n        ret_list.append([start_time, BottomActor.remote()])\n    return ret_list",
            "def create(self, num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ret_list = []\n    for _ in range(num):\n        start_time = time.time()\n        ret_list.append([start_time, BottomActor.remote()])\n    return ret_list"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.start = time.time()",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.start = time.time()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.start = time.time()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.start = time.time()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.start = time.time()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.start = time.time()"
        ]
    },
    {
        "func_name": "info",
        "original": "def info(self):\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
        "mutated": [
            "def info(self):\n    if False:\n        i = 10\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
            "def info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
            "def info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
            "def info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return [ray._private.worker.global_worker.node.unique_id, self.start]",
            "def info(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return [ray._private.worker.global_worker.node.unique_id, self.start]"
        ]
    },
    {
        "func_name": "test_actor_scheduling_latency",
        "original": "@pytest.mark.parametrize('args', [[16, 16, 4, False], [16, 16, 4, True]])\ndef test_actor_scheduling_latency(ray_start_cluster, args):\n    cluster = ray_start_cluster\n    node_count = args[0]\n    actor_count = args[1]\n    upper_count = args[2]\n    gcs_sched = args[3]\n    for i in range(node_count):\n        cluster.add_node(memory=1024 ** 2, _system_config={'gcs_actor_scheduling_enabled': gcs_sched} if i == 0 else {})\n    ray.init(address=cluster.address)\n    cluster.wait_for_nodes()\n\n    @ray.remote(memory=1024 ** 2)\n    class UpperActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n\n        def create(self, num):\n            ret_list = []\n            for _ in range(num):\n                start_time = time.time()\n                ret_list.append([start_time, BottomActor.remote()])\n            return ret_list\n\n    @ray.remote(memory=1024 ** 2)\n    class BottomActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n    actor_distribution = {}\n    actor_list = []\n    start_list = []\n    end_list = []\n    ref_list = []\n    for _ in range(upper_count):\n        start_list.append(time.time())\n        actor_list.append(UpperActor.remote())\n    for actor in actor_list:\n        ref_list.append(actor.create.remote(int((actor_count - upper_count) / upper_count)))\n    for ref in ref_list:\n        ret_list = ray.get(ref)\n        for ret in ret_list:\n            start_list.append(ret[0])\n            actor_list.append(ret[1])\n    for actor in actor_list:\n        ret_list = ray.get(actor.info.remote())\n        if ret_list[0] not in actor_distribution.keys():\n            actor_distribution[ret_list[0]] = []\n        actor_distribution[ret_list[0]].append(actor)\n        end_list.append(ret_list[1])\n    assert len(actor_distribution) == node_count\n    for (node_id, actors) in actor_distribution.items():\n        assert len(actors) <= int(actor_count / node_count)\n    latency_list = []\n    for i in range(actor_count):\n        latency_list.append(end_list[i] - start_list[i])\n        print(latency_list[i])",
        "mutated": [
            "@pytest.mark.parametrize('args', [[16, 16, 4, False], [16, 16, 4, True]])\ndef test_actor_scheduling_latency(ray_start_cluster, args):\n    if False:\n        i = 10\n    cluster = ray_start_cluster\n    node_count = args[0]\n    actor_count = args[1]\n    upper_count = args[2]\n    gcs_sched = args[3]\n    for i in range(node_count):\n        cluster.add_node(memory=1024 ** 2, _system_config={'gcs_actor_scheduling_enabled': gcs_sched} if i == 0 else {})\n    ray.init(address=cluster.address)\n    cluster.wait_for_nodes()\n\n    @ray.remote(memory=1024 ** 2)\n    class UpperActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n\n        def create(self, num):\n            ret_list = []\n            for _ in range(num):\n                start_time = time.time()\n                ret_list.append([start_time, BottomActor.remote()])\n            return ret_list\n\n    @ray.remote(memory=1024 ** 2)\n    class BottomActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n    actor_distribution = {}\n    actor_list = []\n    start_list = []\n    end_list = []\n    ref_list = []\n    for _ in range(upper_count):\n        start_list.append(time.time())\n        actor_list.append(UpperActor.remote())\n    for actor in actor_list:\n        ref_list.append(actor.create.remote(int((actor_count - upper_count) / upper_count)))\n    for ref in ref_list:\n        ret_list = ray.get(ref)\n        for ret in ret_list:\n            start_list.append(ret[0])\n            actor_list.append(ret[1])\n    for actor in actor_list:\n        ret_list = ray.get(actor.info.remote())\n        if ret_list[0] not in actor_distribution.keys():\n            actor_distribution[ret_list[0]] = []\n        actor_distribution[ret_list[0]].append(actor)\n        end_list.append(ret_list[1])\n    assert len(actor_distribution) == node_count\n    for (node_id, actors) in actor_distribution.items():\n        assert len(actors) <= int(actor_count / node_count)\n    latency_list = []\n    for i in range(actor_count):\n        latency_list.append(end_list[i] - start_list[i])\n        print(latency_list[i])",
            "@pytest.mark.parametrize('args', [[16, 16, 4, False], [16, 16, 4, True]])\ndef test_actor_scheduling_latency(ray_start_cluster, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cluster = ray_start_cluster\n    node_count = args[0]\n    actor_count = args[1]\n    upper_count = args[2]\n    gcs_sched = args[3]\n    for i in range(node_count):\n        cluster.add_node(memory=1024 ** 2, _system_config={'gcs_actor_scheduling_enabled': gcs_sched} if i == 0 else {})\n    ray.init(address=cluster.address)\n    cluster.wait_for_nodes()\n\n    @ray.remote(memory=1024 ** 2)\n    class UpperActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n\n        def create(self, num):\n            ret_list = []\n            for _ in range(num):\n                start_time = time.time()\n                ret_list.append([start_time, BottomActor.remote()])\n            return ret_list\n\n    @ray.remote(memory=1024 ** 2)\n    class BottomActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n    actor_distribution = {}\n    actor_list = []\n    start_list = []\n    end_list = []\n    ref_list = []\n    for _ in range(upper_count):\n        start_list.append(time.time())\n        actor_list.append(UpperActor.remote())\n    for actor in actor_list:\n        ref_list.append(actor.create.remote(int((actor_count - upper_count) / upper_count)))\n    for ref in ref_list:\n        ret_list = ray.get(ref)\n        for ret in ret_list:\n            start_list.append(ret[0])\n            actor_list.append(ret[1])\n    for actor in actor_list:\n        ret_list = ray.get(actor.info.remote())\n        if ret_list[0] not in actor_distribution.keys():\n            actor_distribution[ret_list[0]] = []\n        actor_distribution[ret_list[0]].append(actor)\n        end_list.append(ret_list[1])\n    assert len(actor_distribution) == node_count\n    for (node_id, actors) in actor_distribution.items():\n        assert len(actors) <= int(actor_count / node_count)\n    latency_list = []\n    for i in range(actor_count):\n        latency_list.append(end_list[i] - start_list[i])\n        print(latency_list[i])",
            "@pytest.mark.parametrize('args', [[16, 16, 4, False], [16, 16, 4, True]])\ndef test_actor_scheduling_latency(ray_start_cluster, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cluster = ray_start_cluster\n    node_count = args[0]\n    actor_count = args[1]\n    upper_count = args[2]\n    gcs_sched = args[3]\n    for i in range(node_count):\n        cluster.add_node(memory=1024 ** 2, _system_config={'gcs_actor_scheduling_enabled': gcs_sched} if i == 0 else {})\n    ray.init(address=cluster.address)\n    cluster.wait_for_nodes()\n\n    @ray.remote(memory=1024 ** 2)\n    class UpperActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n\n        def create(self, num):\n            ret_list = []\n            for _ in range(num):\n                start_time = time.time()\n                ret_list.append([start_time, BottomActor.remote()])\n            return ret_list\n\n    @ray.remote(memory=1024 ** 2)\n    class BottomActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n    actor_distribution = {}\n    actor_list = []\n    start_list = []\n    end_list = []\n    ref_list = []\n    for _ in range(upper_count):\n        start_list.append(time.time())\n        actor_list.append(UpperActor.remote())\n    for actor in actor_list:\n        ref_list.append(actor.create.remote(int((actor_count - upper_count) / upper_count)))\n    for ref in ref_list:\n        ret_list = ray.get(ref)\n        for ret in ret_list:\n            start_list.append(ret[0])\n            actor_list.append(ret[1])\n    for actor in actor_list:\n        ret_list = ray.get(actor.info.remote())\n        if ret_list[0] not in actor_distribution.keys():\n            actor_distribution[ret_list[0]] = []\n        actor_distribution[ret_list[0]].append(actor)\n        end_list.append(ret_list[1])\n    assert len(actor_distribution) == node_count\n    for (node_id, actors) in actor_distribution.items():\n        assert len(actors) <= int(actor_count / node_count)\n    latency_list = []\n    for i in range(actor_count):\n        latency_list.append(end_list[i] - start_list[i])\n        print(latency_list[i])",
            "@pytest.mark.parametrize('args', [[16, 16, 4, False], [16, 16, 4, True]])\ndef test_actor_scheduling_latency(ray_start_cluster, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cluster = ray_start_cluster\n    node_count = args[0]\n    actor_count = args[1]\n    upper_count = args[2]\n    gcs_sched = args[3]\n    for i in range(node_count):\n        cluster.add_node(memory=1024 ** 2, _system_config={'gcs_actor_scheduling_enabled': gcs_sched} if i == 0 else {})\n    ray.init(address=cluster.address)\n    cluster.wait_for_nodes()\n\n    @ray.remote(memory=1024 ** 2)\n    class UpperActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n\n        def create(self, num):\n            ret_list = []\n            for _ in range(num):\n                start_time = time.time()\n                ret_list.append([start_time, BottomActor.remote()])\n            return ret_list\n\n    @ray.remote(memory=1024 ** 2)\n    class BottomActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n    actor_distribution = {}\n    actor_list = []\n    start_list = []\n    end_list = []\n    ref_list = []\n    for _ in range(upper_count):\n        start_list.append(time.time())\n        actor_list.append(UpperActor.remote())\n    for actor in actor_list:\n        ref_list.append(actor.create.remote(int((actor_count - upper_count) / upper_count)))\n    for ref in ref_list:\n        ret_list = ray.get(ref)\n        for ret in ret_list:\n            start_list.append(ret[0])\n            actor_list.append(ret[1])\n    for actor in actor_list:\n        ret_list = ray.get(actor.info.remote())\n        if ret_list[0] not in actor_distribution.keys():\n            actor_distribution[ret_list[0]] = []\n        actor_distribution[ret_list[0]].append(actor)\n        end_list.append(ret_list[1])\n    assert len(actor_distribution) == node_count\n    for (node_id, actors) in actor_distribution.items():\n        assert len(actors) <= int(actor_count / node_count)\n    latency_list = []\n    for i in range(actor_count):\n        latency_list.append(end_list[i] - start_list[i])\n        print(latency_list[i])",
            "@pytest.mark.parametrize('args', [[16, 16, 4, False], [16, 16, 4, True]])\ndef test_actor_scheduling_latency(ray_start_cluster, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cluster = ray_start_cluster\n    node_count = args[0]\n    actor_count = args[1]\n    upper_count = args[2]\n    gcs_sched = args[3]\n    for i in range(node_count):\n        cluster.add_node(memory=1024 ** 2, _system_config={'gcs_actor_scheduling_enabled': gcs_sched} if i == 0 else {})\n    ray.init(address=cluster.address)\n    cluster.wait_for_nodes()\n\n    @ray.remote(memory=1024 ** 2)\n    class UpperActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n\n        def create(self, num):\n            ret_list = []\n            for _ in range(num):\n                start_time = time.time()\n                ret_list.append([start_time, BottomActor.remote()])\n            return ret_list\n\n    @ray.remote(memory=1024 ** 2)\n    class BottomActor:\n\n        def __init__(self):\n            self.start = time.time()\n\n        def info(self):\n            return [ray._private.worker.global_worker.node.unique_id, self.start]\n    actor_distribution = {}\n    actor_list = []\n    start_list = []\n    end_list = []\n    ref_list = []\n    for _ in range(upper_count):\n        start_list.append(time.time())\n        actor_list.append(UpperActor.remote())\n    for actor in actor_list:\n        ref_list.append(actor.create.remote(int((actor_count - upper_count) / upper_count)))\n    for ref in ref_list:\n        ret_list = ray.get(ref)\n        for ret in ret_list:\n            start_list.append(ret[0])\n            actor_list.append(ret[1])\n    for actor in actor_list:\n        ret_list = ray.get(actor.info.remote())\n        if ret_list[0] not in actor_distribution.keys():\n            actor_distribution[ret_list[0]] = []\n        actor_distribution[ret_list[0]].append(actor)\n        end_list.append(ret_list[1])\n    assert len(actor_distribution) == node_count\n    for (node_id, actors) in actor_distribution.items():\n        assert len(actors) <= int(actor_count / node_count)\n    latency_list = []\n    for i in range(actor_count):\n        latency_list.append(end_list[i] - start_list[i])\n        print(latency_list[i])"
        ]
    }
]