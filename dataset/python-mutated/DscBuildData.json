[
    {
        "func_name": "_IsFieldValueAnArray",
        "original": "def _IsFieldValueAnArray(Value):\n    Value = Value.strip()\n    if Value.startswith(TAB_GUID) and Value.endswith(')'):\n        return True\n    if Value.startswith('L\"') and Value.endswith('\"') and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == '\"' and Value[-1] == '\"' and (len(list(Value[1:-1])) > 1):\n        return True\n    if Value[0] == '{' and Value[-1] == '}':\n        return True\n    if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n        return True\n    return False",
        "mutated": [
            "def _IsFieldValueAnArray(Value):\n    if False:\n        i = 10\n    Value = Value.strip()\n    if Value.startswith(TAB_GUID) and Value.endswith(')'):\n        return True\n    if Value.startswith('L\"') and Value.endswith('\"') and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == '\"' and Value[-1] == '\"' and (len(list(Value[1:-1])) > 1):\n        return True\n    if Value[0] == '{' and Value[-1] == '}':\n        return True\n    if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n        return True\n    return False",
            "def _IsFieldValueAnArray(Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Value = Value.strip()\n    if Value.startswith(TAB_GUID) and Value.endswith(')'):\n        return True\n    if Value.startswith('L\"') and Value.endswith('\"') and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == '\"' and Value[-1] == '\"' and (len(list(Value[1:-1])) > 1):\n        return True\n    if Value[0] == '{' and Value[-1] == '}':\n        return True\n    if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n        return True\n    return False",
            "def _IsFieldValueAnArray(Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Value = Value.strip()\n    if Value.startswith(TAB_GUID) and Value.endswith(')'):\n        return True\n    if Value.startswith('L\"') and Value.endswith('\"') and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == '\"' and Value[-1] == '\"' and (len(list(Value[1:-1])) > 1):\n        return True\n    if Value[0] == '{' and Value[-1] == '}':\n        return True\n    if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n        return True\n    return False",
            "def _IsFieldValueAnArray(Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Value = Value.strip()\n    if Value.startswith(TAB_GUID) and Value.endswith(')'):\n        return True\n    if Value.startswith('L\"') and Value.endswith('\"') and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == '\"' and Value[-1] == '\"' and (len(list(Value[1:-1])) > 1):\n        return True\n    if Value[0] == '{' and Value[-1] == '}':\n        return True\n    if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n        return True\n    return False",
            "def _IsFieldValueAnArray(Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Value = Value.strip()\n    if Value.startswith(TAB_GUID) and Value.endswith(')'):\n        return True\n    if Value.startswith('L\"') and Value.endswith('\"') and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == '\"' and Value[-1] == '\"' and (len(list(Value[1:-1])) > 1):\n        return True\n    if Value[0] == '{' and Value[-1] == '}':\n        return True\n    if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n        return True\n    if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n        return True\n    return False"
        ]
    },
    {
        "func_name": "GetDependencyList",
        "original": "def GetDependencyList(FileStack, SearchPathList):\n    DepDb = dict()\n    DependencySet = set(FileStack)\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F, 'r')\n                FileContent = Fd.read()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F + '\\n\\t' + str(X))\n            finally:\n                if 'Fd' in dir(locals()):\n                    Fd.close()\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = os.path.dirname(F)\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if not os.path.exists(FilePath):\n                    continue\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                    FullPathDependList.append(FilePath)\n                break\n        DependencySet.update(FullPathDependList)\n    DependencyList = list(DependencySet)\n    return DependencyList",
        "mutated": [
            "def GetDependencyList(FileStack, SearchPathList):\n    if False:\n        i = 10\n    DepDb = dict()\n    DependencySet = set(FileStack)\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F, 'r')\n                FileContent = Fd.read()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F + '\\n\\t' + str(X))\n            finally:\n                if 'Fd' in dir(locals()):\n                    Fd.close()\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = os.path.dirname(F)\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if not os.path.exists(FilePath):\n                    continue\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                    FullPathDependList.append(FilePath)\n                break\n        DependencySet.update(FullPathDependList)\n    DependencyList = list(DependencySet)\n    return DependencyList",
            "def GetDependencyList(FileStack, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DepDb = dict()\n    DependencySet = set(FileStack)\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F, 'r')\n                FileContent = Fd.read()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F + '\\n\\t' + str(X))\n            finally:\n                if 'Fd' in dir(locals()):\n                    Fd.close()\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = os.path.dirname(F)\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if not os.path.exists(FilePath):\n                    continue\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                    FullPathDependList.append(FilePath)\n                break\n        DependencySet.update(FullPathDependList)\n    DependencyList = list(DependencySet)\n    return DependencyList",
            "def GetDependencyList(FileStack, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DepDb = dict()\n    DependencySet = set(FileStack)\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F, 'r')\n                FileContent = Fd.read()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F + '\\n\\t' + str(X))\n            finally:\n                if 'Fd' in dir(locals()):\n                    Fd.close()\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = os.path.dirname(F)\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if not os.path.exists(FilePath):\n                    continue\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                    FullPathDependList.append(FilePath)\n                break\n        DependencySet.update(FullPathDependList)\n    DependencyList = list(DependencySet)\n    return DependencyList",
            "def GetDependencyList(FileStack, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DepDb = dict()\n    DependencySet = set(FileStack)\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F, 'r')\n                FileContent = Fd.read()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F + '\\n\\t' + str(X))\n            finally:\n                if 'Fd' in dir(locals()):\n                    Fd.close()\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = os.path.dirname(F)\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if not os.path.exists(FilePath):\n                    continue\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                    FullPathDependList.append(FilePath)\n                break\n        DependencySet.update(FullPathDependList)\n    DependencyList = list(DependencySet)\n    return DependencyList",
            "def GetDependencyList(FileStack, SearchPathList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DepDb = dict()\n    DependencySet = set(FileStack)\n    while len(FileStack) > 0:\n        F = FileStack.pop()\n        FullPathDependList = []\n        CurrentFileDependencyList = []\n        if F in DepDb:\n            CurrentFileDependencyList = DepDb[F]\n        else:\n            try:\n                Fd = open(F, 'r')\n                FileContent = Fd.read()\n            except BaseException as X:\n                EdkLogger.error('build', FILE_OPEN_FAILURE, ExtraData=F + '\\n\\t' + str(X))\n            finally:\n                if 'Fd' in dir(locals()):\n                    Fd.close()\n            if len(FileContent) == 0:\n                continue\n            try:\n                if FileContent[0] == 255 or FileContent[0] == 254:\n                    FileContent = FileContent.decode('utf-16')\n                else:\n                    FileContent = FileContent.decode()\n            except:\n                continue\n            IncludedFileList = gIncludePattern.findall(FileContent)\n            for Inc in IncludedFileList:\n                Inc = Inc.strip()\n                Inc = os.path.normpath(Inc)\n                CurrentFileDependencyList.append(Inc)\n            DepDb[F] = CurrentFileDependencyList\n        CurrentFilePath = os.path.dirname(F)\n        PathList = [CurrentFilePath] + SearchPathList\n        for Inc in CurrentFileDependencyList:\n            for SearchPath in PathList:\n                FilePath = os.path.join(SearchPath, Inc)\n                if not os.path.exists(FilePath):\n                    continue\n                if FilePath not in DependencySet:\n                    FileStack.append(FilePath)\n                    FullPathDependList.append(FilePath)\n                break\n        DependencySet.update(FullPathDependList)\n    DependencyList = list(DependencySet)\n    return DependencyList"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, FilePath, RawData, BuildDataBase, Arch=TAB_ARCH_COMMON, Target=None, Toolchain=None):\n    self.MetaFile = FilePath\n    self._RawData = RawData\n    self._Bdb = BuildDataBase\n    self._Arch = Arch\n    self._Target = Target\n    self._Toolchain = Toolchain\n    self._ToolChainFamily = None\n    self._Clear()\n    self.WorkspaceDir = os.getenv('WORKSPACE') if os.getenv('WORKSPACE') else ''\n    self.DefaultStores = None\n    self.SkuIdMgr = SkuClass(self.SkuName, self.SkuIds)\n    self.UpdatePcdTypeDict()",
        "mutated": [
            "def __init__(self, FilePath, RawData, BuildDataBase, Arch=TAB_ARCH_COMMON, Target=None, Toolchain=None):\n    if False:\n        i = 10\n    self.MetaFile = FilePath\n    self._RawData = RawData\n    self._Bdb = BuildDataBase\n    self._Arch = Arch\n    self._Target = Target\n    self._Toolchain = Toolchain\n    self._ToolChainFamily = None\n    self._Clear()\n    self.WorkspaceDir = os.getenv('WORKSPACE') if os.getenv('WORKSPACE') else ''\n    self.DefaultStores = None\n    self.SkuIdMgr = SkuClass(self.SkuName, self.SkuIds)\n    self.UpdatePcdTypeDict()",
            "def __init__(self, FilePath, RawData, BuildDataBase, Arch=TAB_ARCH_COMMON, Target=None, Toolchain=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.MetaFile = FilePath\n    self._RawData = RawData\n    self._Bdb = BuildDataBase\n    self._Arch = Arch\n    self._Target = Target\n    self._Toolchain = Toolchain\n    self._ToolChainFamily = None\n    self._Clear()\n    self.WorkspaceDir = os.getenv('WORKSPACE') if os.getenv('WORKSPACE') else ''\n    self.DefaultStores = None\n    self.SkuIdMgr = SkuClass(self.SkuName, self.SkuIds)\n    self.UpdatePcdTypeDict()",
            "def __init__(self, FilePath, RawData, BuildDataBase, Arch=TAB_ARCH_COMMON, Target=None, Toolchain=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.MetaFile = FilePath\n    self._RawData = RawData\n    self._Bdb = BuildDataBase\n    self._Arch = Arch\n    self._Target = Target\n    self._Toolchain = Toolchain\n    self._ToolChainFamily = None\n    self._Clear()\n    self.WorkspaceDir = os.getenv('WORKSPACE') if os.getenv('WORKSPACE') else ''\n    self.DefaultStores = None\n    self.SkuIdMgr = SkuClass(self.SkuName, self.SkuIds)\n    self.UpdatePcdTypeDict()",
            "def __init__(self, FilePath, RawData, BuildDataBase, Arch=TAB_ARCH_COMMON, Target=None, Toolchain=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.MetaFile = FilePath\n    self._RawData = RawData\n    self._Bdb = BuildDataBase\n    self._Arch = Arch\n    self._Target = Target\n    self._Toolchain = Toolchain\n    self._ToolChainFamily = None\n    self._Clear()\n    self.WorkspaceDir = os.getenv('WORKSPACE') if os.getenv('WORKSPACE') else ''\n    self.DefaultStores = None\n    self.SkuIdMgr = SkuClass(self.SkuName, self.SkuIds)\n    self.UpdatePcdTypeDict()",
            "def __init__(self, FilePath, RawData, BuildDataBase, Arch=TAB_ARCH_COMMON, Target=None, Toolchain=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.MetaFile = FilePath\n    self._RawData = RawData\n    self._Bdb = BuildDataBase\n    self._Arch = Arch\n    self._Target = Target\n    self._Toolchain = Toolchain\n    self._ToolChainFamily = None\n    self._Clear()\n    self.WorkspaceDir = os.getenv('WORKSPACE') if os.getenv('WORKSPACE') else ''\n    self.DefaultStores = None\n    self.SkuIdMgr = SkuClass(self.SkuName, self.SkuIds)\n    self.UpdatePcdTypeDict()"
        ]
    },
    {
        "func_name": "OutputPath",
        "original": "@property\ndef OutputPath(self):\n    if os.getenv('WORKSPACE'):\n        return os.path.join(os.getenv('WORKSPACE'), self.OutputDirectory, self._Target + '_' + self._Toolchain, PcdValueInitName)\n    else:\n        return os.path.dirname(self.DscFile)",
        "mutated": [
            "@property\ndef OutputPath(self):\n    if False:\n        i = 10\n    if os.getenv('WORKSPACE'):\n        return os.path.join(os.getenv('WORKSPACE'), self.OutputDirectory, self._Target + '_' + self._Toolchain, PcdValueInitName)\n    else:\n        return os.path.dirname(self.DscFile)",
            "@property\ndef OutputPath(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if os.getenv('WORKSPACE'):\n        return os.path.join(os.getenv('WORKSPACE'), self.OutputDirectory, self._Target + '_' + self._Toolchain, PcdValueInitName)\n    else:\n        return os.path.dirname(self.DscFile)",
            "@property\ndef OutputPath(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if os.getenv('WORKSPACE'):\n        return os.path.join(os.getenv('WORKSPACE'), self.OutputDirectory, self._Target + '_' + self._Toolchain, PcdValueInitName)\n    else:\n        return os.path.dirname(self.DscFile)",
            "@property\ndef OutputPath(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if os.getenv('WORKSPACE'):\n        return os.path.join(os.getenv('WORKSPACE'), self.OutputDirectory, self._Target + '_' + self._Toolchain, PcdValueInitName)\n    else:\n        return os.path.dirname(self.DscFile)",
            "@property\ndef OutputPath(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if os.getenv('WORKSPACE'):\n        return os.path.join(os.getenv('WORKSPACE'), self.OutputDirectory, self._Target + '_' + self._Toolchain, PcdValueInitName)\n    else:\n        return os.path.dirname(self.DscFile)"
        ]
    },
    {
        "func_name": "__setitem__",
        "original": "def __setitem__(self, key, value):\n    self.__dict__[self._PROPERTY_[key]] = value",
        "mutated": [
            "def __setitem__(self, key, value):\n    if False:\n        i = 10\n    self.__dict__[self._PROPERTY_[key]] = value",
            "def __setitem__(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__dict__[self._PROPERTY_[key]] = value",
            "def __setitem__(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__dict__[self._PROPERTY_[key]] = value",
            "def __setitem__(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__dict__[self._PROPERTY_[key]] = value",
            "def __setitem__(self, key, value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__dict__[self._PROPERTY_[key]] = value"
        ]
    },
    {
        "func_name": "__getitem__",
        "original": "def __getitem__(self, key):\n    return self.__dict__[self._PROPERTY_[key]]",
        "mutated": [
            "def __getitem__(self, key):\n    if False:\n        i = 10\n    return self.__dict__[self._PROPERTY_[key]]",
            "def __getitem__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.__dict__[self._PROPERTY_[key]]",
            "def __getitem__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.__dict__[self._PROPERTY_[key]]",
            "def __getitem__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.__dict__[self._PROPERTY_[key]]",
            "def __getitem__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.__dict__[self._PROPERTY_[key]]"
        ]
    },
    {
        "func_name": "__contains__",
        "original": "def __contains__(self, key):\n    return key in self._PROPERTY_",
        "mutated": [
            "def __contains__(self, key):\n    if False:\n        i = 10\n    return key in self._PROPERTY_",
            "def __contains__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return key in self._PROPERTY_",
            "def __contains__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return key in self._PROPERTY_",
            "def __contains__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return key in self._PROPERTY_",
            "def __contains__(self, key):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return key in self._PROPERTY_"
        ]
    },
    {
        "func_name": "_Clear",
        "original": "def _Clear(self):\n    self._Header = None\n    self._PlatformName = None\n    self._Guid = None\n    self._Version = None\n    self._DscSpecification = None\n    self._OutputDirectory = None\n    self._SupArchList = None\n    self._BuildTargets = None\n    self._SkuName = None\n    self._PcdInfoFlag = None\n    self._VarCheckFlag = None\n    self._FlashDefinition = None\n    self._Prebuild = None\n    self._Postbuild = None\n    self._BuildNumber = None\n    self._MakefileName = None\n    self._BsBaseAddress = None\n    self._RtBaseAddress = None\n    self._SkuIds = None\n    self._Modules = None\n    self._LibraryInstances = None\n    self._LibraryClasses = None\n    self._Pcds = None\n    self._DecPcds = None\n    self._BuildOptions = None\n    self._ModuleTypeOptions = None\n    self._LoadFixAddress = None\n    self._RFCLanguages = None\n    self._ISOLanguages = None\n    self._VpdToolGuid = None\n    self._MacroDict = None\n    self.DefaultStores = None",
        "mutated": [
            "def _Clear(self):\n    if False:\n        i = 10\n    self._Header = None\n    self._PlatformName = None\n    self._Guid = None\n    self._Version = None\n    self._DscSpecification = None\n    self._OutputDirectory = None\n    self._SupArchList = None\n    self._BuildTargets = None\n    self._SkuName = None\n    self._PcdInfoFlag = None\n    self._VarCheckFlag = None\n    self._FlashDefinition = None\n    self._Prebuild = None\n    self._Postbuild = None\n    self._BuildNumber = None\n    self._MakefileName = None\n    self._BsBaseAddress = None\n    self._RtBaseAddress = None\n    self._SkuIds = None\n    self._Modules = None\n    self._LibraryInstances = None\n    self._LibraryClasses = None\n    self._Pcds = None\n    self._DecPcds = None\n    self._BuildOptions = None\n    self._ModuleTypeOptions = None\n    self._LoadFixAddress = None\n    self._RFCLanguages = None\n    self._ISOLanguages = None\n    self._VpdToolGuid = None\n    self._MacroDict = None\n    self.DefaultStores = None",
            "def _Clear(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._Header = None\n    self._PlatformName = None\n    self._Guid = None\n    self._Version = None\n    self._DscSpecification = None\n    self._OutputDirectory = None\n    self._SupArchList = None\n    self._BuildTargets = None\n    self._SkuName = None\n    self._PcdInfoFlag = None\n    self._VarCheckFlag = None\n    self._FlashDefinition = None\n    self._Prebuild = None\n    self._Postbuild = None\n    self._BuildNumber = None\n    self._MakefileName = None\n    self._BsBaseAddress = None\n    self._RtBaseAddress = None\n    self._SkuIds = None\n    self._Modules = None\n    self._LibraryInstances = None\n    self._LibraryClasses = None\n    self._Pcds = None\n    self._DecPcds = None\n    self._BuildOptions = None\n    self._ModuleTypeOptions = None\n    self._LoadFixAddress = None\n    self._RFCLanguages = None\n    self._ISOLanguages = None\n    self._VpdToolGuid = None\n    self._MacroDict = None\n    self.DefaultStores = None",
            "def _Clear(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._Header = None\n    self._PlatformName = None\n    self._Guid = None\n    self._Version = None\n    self._DscSpecification = None\n    self._OutputDirectory = None\n    self._SupArchList = None\n    self._BuildTargets = None\n    self._SkuName = None\n    self._PcdInfoFlag = None\n    self._VarCheckFlag = None\n    self._FlashDefinition = None\n    self._Prebuild = None\n    self._Postbuild = None\n    self._BuildNumber = None\n    self._MakefileName = None\n    self._BsBaseAddress = None\n    self._RtBaseAddress = None\n    self._SkuIds = None\n    self._Modules = None\n    self._LibraryInstances = None\n    self._LibraryClasses = None\n    self._Pcds = None\n    self._DecPcds = None\n    self._BuildOptions = None\n    self._ModuleTypeOptions = None\n    self._LoadFixAddress = None\n    self._RFCLanguages = None\n    self._ISOLanguages = None\n    self._VpdToolGuid = None\n    self._MacroDict = None\n    self.DefaultStores = None",
            "def _Clear(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._Header = None\n    self._PlatformName = None\n    self._Guid = None\n    self._Version = None\n    self._DscSpecification = None\n    self._OutputDirectory = None\n    self._SupArchList = None\n    self._BuildTargets = None\n    self._SkuName = None\n    self._PcdInfoFlag = None\n    self._VarCheckFlag = None\n    self._FlashDefinition = None\n    self._Prebuild = None\n    self._Postbuild = None\n    self._BuildNumber = None\n    self._MakefileName = None\n    self._BsBaseAddress = None\n    self._RtBaseAddress = None\n    self._SkuIds = None\n    self._Modules = None\n    self._LibraryInstances = None\n    self._LibraryClasses = None\n    self._Pcds = None\n    self._DecPcds = None\n    self._BuildOptions = None\n    self._ModuleTypeOptions = None\n    self._LoadFixAddress = None\n    self._RFCLanguages = None\n    self._ISOLanguages = None\n    self._VpdToolGuid = None\n    self._MacroDict = None\n    self.DefaultStores = None",
            "def _Clear(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._Header = None\n    self._PlatformName = None\n    self._Guid = None\n    self._Version = None\n    self._DscSpecification = None\n    self._OutputDirectory = None\n    self._SupArchList = None\n    self._BuildTargets = None\n    self._SkuName = None\n    self._PcdInfoFlag = None\n    self._VarCheckFlag = None\n    self._FlashDefinition = None\n    self._Prebuild = None\n    self._Postbuild = None\n    self._BuildNumber = None\n    self._MakefileName = None\n    self._BsBaseAddress = None\n    self._RtBaseAddress = None\n    self._SkuIds = None\n    self._Modules = None\n    self._LibraryInstances = None\n    self._LibraryClasses = None\n    self._Pcds = None\n    self._DecPcds = None\n    self._BuildOptions = None\n    self._ModuleTypeOptions = None\n    self._LoadFixAddress = None\n    self._RFCLanguages = None\n    self._ISOLanguages = None\n    self._VpdToolGuid = None\n    self._MacroDict = None\n    self.DefaultStores = None"
        ]
    },
    {
        "func_name": "_Macros",
        "original": "@property\ndef _Macros(self):\n    if self._MacroDict is None:\n        self._MacroDict = {}\n        self._MacroDict.update(GlobalData.gPlatformDefines)\n        self._MacroDict.update(GlobalData.gGlobalDefines)\n        self._MacroDict.update(GlobalData.gCommandLineDefines)\n    return self._MacroDict",
        "mutated": [
            "@property\ndef _Macros(self):\n    if False:\n        i = 10\n    if self._MacroDict is None:\n        self._MacroDict = {}\n        self._MacroDict.update(GlobalData.gPlatformDefines)\n        self._MacroDict.update(GlobalData.gGlobalDefines)\n        self._MacroDict.update(GlobalData.gCommandLineDefines)\n    return self._MacroDict",
            "@property\ndef _Macros(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._MacroDict is None:\n        self._MacroDict = {}\n        self._MacroDict.update(GlobalData.gPlatformDefines)\n        self._MacroDict.update(GlobalData.gGlobalDefines)\n        self._MacroDict.update(GlobalData.gCommandLineDefines)\n    return self._MacroDict",
            "@property\ndef _Macros(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._MacroDict is None:\n        self._MacroDict = {}\n        self._MacroDict.update(GlobalData.gPlatformDefines)\n        self._MacroDict.update(GlobalData.gGlobalDefines)\n        self._MacroDict.update(GlobalData.gCommandLineDefines)\n    return self._MacroDict",
            "@property\ndef _Macros(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._MacroDict is None:\n        self._MacroDict = {}\n        self._MacroDict.update(GlobalData.gPlatformDefines)\n        self._MacroDict.update(GlobalData.gGlobalDefines)\n        self._MacroDict.update(GlobalData.gCommandLineDefines)\n    return self._MacroDict",
            "@property\ndef _Macros(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._MacroDict is None:\n        self._MacroDict = {}\n        self._MacroDict.update(GlobalData.gPlatformDefines)\n        self._MacroDict.update(GlobalData.gGlobalDefines)\n        self._MacroDict.update(GlobalData.gCommandLineDefines)\n    return self._MacroDict"
        ]
    },
    {
        "func_name": "Arch",
        "original": "@property\ndef Arch(self):\n    return self._Arch",
        "mutated": [
            "@property\ndef Arch(self):\n    if False:\n        i = 10\n    return self._Arch",
            "@property\ndef Arch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self._Arch",
            "@property\ndef Arch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self._Arch",
            "@property\ndef Arch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self._Arch",
            "@property\ndef Arch(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self._Arch"
        ]
    },
    {
        "func_name": "Dir",
        "original": "@property\ndef Dir(self):\n    return self.MetaFile.Dir",
        "mutated": [
            "@property\ndef Dir(self):\n    if False:\n        i = 10\n    return self.MetaFile.Dir",
            "@property\ndef Dir(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.MetaFile.Dir",
            "@property\ndef Dir(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.MetaFile.Dir",
            "@property\ndef Dir(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.MetaFile.Dir",
            "@property\ndef Dir(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.MetaFile.Dir"
        ]
    },
    {
        "func_name": "_GetHeaderInfo",
        "original": "def _GetHeaderInfo(self):\n    RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch]\n    for Record in RecordList:\n        Name = Record[1]\n        if Name == TAB_DSC_DEFINES_OUTPUT_DIRECTORY:\n            self._OutputDirectory = NormPath(Record[2], self._Macros)\n            if ' ' in self._OutputDirectory:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'No space is allowed in OUTPUT_DIRECTORY', File=self.MetaFile, Line=Record[-1], ExtraData=self._OutputDirectory)\n        elif Name == TAB_DSC_DEFINES_FLASH_DEFINITION:\n            self._FlashDefinition = PathClass(NormPath(Record[2], self._Macros), GlobalData.gWorkspace)\n            (ErrorCode, ErrorInfo) = self._FlashDefinition.Validate('.fdf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=Record[-1], ExtraData=ErrorInfo)\n        elif Name == TAB_DSC_PREBUILD:\n            PrebuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_PREBUILD, File=self.MetaFile, Line=Record[-1])\n                PrebuildValue = Record[2][1:-1]\n            self._Prebuild = PrebuildValue\n        elif Name == TAB_DSC_POSTBUILD:\n            PostbuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_POSTBUILD, File=self.MetaFile, Line=Record[-1])\n                PostbuildValue = Record[2][1:-1]\n            self._Postbuild = PostbuildValue\n        elif Name == TAB_DSC_DEFINES_SUPPORTED_ARCHITECTURES:\n            self._SupArchList = GetSplitValueList(Record[2], TAB_VALUE_SPLIT)\n        elif Name == TAB_DSC_DEFINES_BUILD_TARGETS:\n            self._BuildTargets = GetSplitValueList(Record[2])\n        elif Name == TAB_DSC_DEFINES_SKUID_IDENTIFIER:\n            if self._SkuName is None:\n                self._SkuName = Record[2]\n            if GlobalData.gSKUID_CMD:\n                self._SkuName = GlobalData.gSKUID_CMD\n        elif Name == TAB_DSC_DEFINES_PCD_INFO_GENERATION:\n            self._PcdInfoFlag = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_VAR_CHECK_GENERATION:\n            self._VarCheckFlag = Record[2]\n        elif Name == TAB_FIX_LOAD_TOP_MEMORY_ADDRESS:\n            try:\n                self._LoadFixAddress = int(Record[2], 0)\n            except:\n                EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % Record[2])\n        elif Name == TAB_DSC_DEFINES_RFC_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for RFC_LANGUAGES must have double quotes around it, for example: RFC_LANGUAGES = \"en-us;zh-hans\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more RFC4646 format language code must be provided for RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            LanguageList = GetSplitValueList(LanguageCodes, TAB_SEMI_COLON_SPLIT)\n            if None in LanguageList:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more empty language code is in RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            self._RFCLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_ISO_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for ISO_LANGUAGES must have double quotes around it, for example: ISO_LANGUAGES = \"engchn\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more ISO639-2 format language code must be provided for ISO_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            if len(LanguageCodes) % 3:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'bad ISO639-2 format for ISO_LANGUAGES', File=self.MetaFile, Line=Record[-1])\n            LanguageList = []\n            for i in range(0, len(LanguageCodes), 3):\n                LanguageList.append(LanguageCodes[i:i + 3])\n            self._ISOLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE:\n            if TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE] = Record[2].strip()\n        elif Name == TAB_DSC_DEFINES_VPD_TOOL_GUID:\n            try:\n                uuid.UUID(Record[2])\n            except:\n                EdkLogger.error('build', FORMAT_INVALID, 'Invalid GUID format for VPD_TOOL_GUID', File=self.MetaFile)\n            self._VpdToolGuid = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX:\n            if TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX] = Record[2].strip()\n        elif Name in self:\n            self[Name] = Record[2]\n    self._Header = 'DUMMY'",
        "mutated": [
            "def _GetHeaderInfo(self):\n    if False:\n        i = 10\n    RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch]\n    for Record in RecordList:\n        Name = Record[1]\n        if Name == TAB_DSC_DEFINES_OUTPUT_DIRECTORY:\n            self._OutputDirectory = NormPath(Record[2], self._Macros)\n            if ' ' in self._OutputDirectory:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'No space is allowed in OUTPUT_DIRECTORY', File=self.MetaFile, Line=Record[-1], ExtraData=self._OutputDirectory)\n        elif Name == TAB_DSC_DEFINES_FLASH_DEFINITION:\n            self._FlashDefinition = PathClass(NormPath(Record[2], self._Macros), GlobalData.gWorkspace)\n            (ErrorCode, ErrorInfo) = self._FlashDefinition.Validate('.fdf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=Record[-1], ExtraData=ErrorInfo)\n        elif Name == TAB_DSC_PREBUILD:\n            PrebuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_PREBUILD, File=self.MetaFile, Line=Record[-1])\n                PrebuildValue = Record[2][1:-1]\n            self._Prebuild = PrebuildValue\n        elif Name == TAB_DSC_POSTBUILD:\n            PostbuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_POSTBUILD, File=self.MetaFile, Line=Record[-1])\n                PostbuildValue = Record[2][1:-1]\n            self._Postbuild = PostbuildValue\n        elif Name == TAB_DSC_DEFINES_SUPPORTED_ARCHITECTURES:\n            self._SupArchList = GetSplitValueList(Record[2], TAB_VALUE_SPLIT)\n        elif Name == TAB_DSC_DEFINES_BUILD_TARGETS:\n            self._BuildTargets = GetSplitValueList(Record[2])\n        elif Name == TAB_DSC_DEFINES_SKUID_IDENTIFIER:\n            if self._SkuName is None:\n                self._SkuName = Record[2]\n            if GlobalData.gSKUID_CMD:\n                self._SkuName = GlobalData.gSKUID_CMD\n        elif Name == TAB_DSC_DEFINES_PCD_INFO_GENERATION:\n            self._PcdInfoFlag = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_VAR_CHECK_GENERATION:\n            self._VarCheckFlag = Record[2]\n        elif Name == TAB_FIX_LOAD_TOP_MEMORY_ADDRESS:\n            try:\n                self._LoadFixAddress = int(Record[2], 0)\n            except:\n                EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % Record[2])\n        elif Name == TAB_DSC_DEFINES_RFC_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for RFC_LANGUAGES must have double quotes around it, for example: RFC_LANGUAGES = \"en-us;zh-hans\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more RFC4646 format language code must be provided for RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            LanguageList = GetSplitValueList(LanguageCodes, TAB_SEMI_COLON_SPLIT)\n            if None in LanguageList:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more empty language code is in RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            self._RFCLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_ISO_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for ISO_LANGUAGES must have double quotes around it, for example: ISO_LANGUAGES = \"engchn\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more ISO639-2 format language code must be provided for ISO_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            if len(LanguageCodes) % 3:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'bad ISO639-2 format for ISO_LANGUAGES', File=self.MetaFile, Line=Record[-1])\n            LanguageList = []\n            for i in range(0, len(LanguageCodes), 3):\n                LanguageList.append(LanguageCodes[i:i + 3])\n            self._ISOLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE:\n            if TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE] = Record[2].strip()\n        elif Name == TAB_DSC_DEFINES_VPD_TOOL_GUID:\n            try:\n                uuid.UUID(Record[2])\n            except:\n                EdkLogger.error('build', FORMAT_INVALID, 'Invalid GUID format for VPD_TOOL_GUID', File=self.MetaFile)\n            self._VpdToolGuid = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX:\n            if TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX] = Record[2].strip()\n        elif Name in self:\n            self[Name] = Record[2]\n    self._Header = 'DUMMY'",
            "def _GetHeaderInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch]\n    for Record in RecordList:\n        Name = Record[1]\n        if Name == TAB_DSC_DEFINES_OUTPUT_DIRECTORY:\n            self._OutputDirectory = NormPath(Record[2], self._Macros)\n            if ' ' in self._OutputDirectory:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'No space is allowed in OUTPUT_DIRECTORY', File=self.MetaFile, Line=Record[-1], ExtraData=self._OutputDirectory)\n        elif Name == TAB_DSC_DEFINES_FLASH_DEFINITION:\n            self._FlashDefinition = PathClass(NormPath(Record[2], self._Macros), GlobalData.gWorkspace)\n            (ErrorCode, ErrorInfo) = self._FlashDefinition.Validate('.fdf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=Record[-1], ExtraData=ErrorInfo)\n        elif Name == TAB_DSC_PREBUILD:\n            PrebuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_PREBUILD, File=self.MetaFile, Line=Record[-1])\n                PrebuildValue = Record[2][1:-1]\n            self._Prebuild = PrebuildValue\n        elif Name == TAB_DSC_POSTBUILD:\n            PostbuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_POSTBUILD, File=self.MetaFile, Line=Record[-1])\n                PostbuildValue = Record[2][1:-1]\n            self._Postbuild = PostbuildValue\n        elif Name == TAB_DSC_DEFINES_SUPPORTED_ARCHITECTURES:\n            self._SupArchList = GetSplitValueList(Record[2], TAB_VALUE_SPLIT)\n        elif Name == TAB_DSC_DEFINES_BUILD_TARGETS:\n            self._BuildTargets = GetSplitValueList(Record[2])\n        elif Name == TAB_DSC_DEFINES_SKUID_IDENTIFIER:\n            if self._SkuName is None:\n                self._SkuName = Record[2]\n            if GlobalData.gSKUID_CMD:\n                self._SkuName = GlobalData.gSKUID_CMD\n        elif Name == TAB_DSC_DEFINES_PCD_INFO_GENERATION:\n            self._PcdInfoFlag = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_VAR_CHECK_GENERATION:\n            self._VarCheckFlag = Record[2]\n        elif Name == TAB_FIX_LOAD_TOP_MEMORY_ADDRESS:\n            try:\n                self._LoadFixAddress = int(Record[2], 0)\n            except:\n                EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % Record[2])\n        elif Name == TAB_DSC_DEFINES_RFC_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for RFC_LANGUAGES must have double quotes around it, for example: RFC_LANGUAGES = \"en-us;zh-hans\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more RFC4646 format language code must be provided for RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            LanguageList = GetSplitValueList(LanguageCodes, TAB_SEMI_COLON_SPLIT)\n            if None in LanguageList:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more empty language code is in RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            self._RFCLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_ISO_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for ISO_LANGUAGES must have double quotes around it, for example: ISO_LANGUAGES = \"engchn\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more ISO639-2 format language code must be provided for ISO_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            if len(LanguageCodes) % 3:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'bad ISO639-2 format for ISO_LANGUAGES', File=self.MetaFile, Line=Record[-1])\n            LanguageList = []\n            for i in range(0, len(LanguageCodes), 3):\n                LanguageList.append(LanguageCodes[i:i + 3])\n            self._ISOLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE:\n            if TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE] = Record[2].strip()\n        elif Name == TAB_DSC_DEFINES_VPD_TOOL_GUID:\n            try:\n                uuid.UUID(Record[2])\n            except:\n                EdkLogger.error('build', FORMAT_INVALID, 'Invalid GUID format for VPD_TOOL_GUID', File=self.MetaFile)\n            self._VpdToolGuid = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX:\n            if TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX] = Record[2].strip()\n        elif Name in self:\n            self[Name] = Record[2]\n    self._Header = 'DUMMY'",
            "def _GetHeaderInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch]\n    for Record in RecordList:\n        Name = Record[1]\n        if Name == TAB_DSC_DEFINES_OUTPUT_DIRECTORY:\n            self._OutputDirectory = NormPath(Record[2], self._Macros)\n            if ' ' in self._OutputDirectory:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'No space is allowed in OUTPUT_DIRECTORY', File=self.MetaFile, Line=Record[-1], ExtraData=self._OutputDirectory)\n        elif Name == TAB_DSC_DEFINES_FLASH_DEFINITION:\n            self._FlashDefinition = PathClass(NormPath(Record[2], self._Macros), GlobalData.gWorkspace)\n            (ErrorCode, ErrorInfo) = self._FlashDefinition.Validate('.fdf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=Record[-1], ExtraData=ErrorInfo)\n        elif Name == TAB_DSC_PREBUILD:\n            PrebuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_PREBUILD, File=self.MetaFile, Line=Record[-1])\n                PrebuildValue = Record[2][1:-1]\n            self._Prebuild = PrebuildValue\n        elif Name == TAB_DSC_POSTBUILD:\n            PostbuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_POSTBUILD, File=self.MetaFile, Line=Record[-1])\n                PostbuildValue = Record[2][1:-1]\n            self._Postbuild = PostbuildValue\n        elif Name == TAB_DSC_DEFINES_SUPPORTED_ARCHITECTURES:\n            self._SupArchList = GetSplitValueList(Record[2], TAB_VALUE_SPLIT)\n        elif Name == TAB_DSC_DEFINES_BUILD_TARGETS:\n            self._BuildTargets = GetSplitValueList(Record[2])\n        elif Name == TAB_DSC_DEFINES_SKUID_IDENTIFIER:\n            if self._SkuName is None:\n                self._SkuName = Record[2]\n            if GlobalData.gSKUID_CMD:\n                self._SkuName = GlobalData.gSKUID_CMD\n        elif Name == TAB_DSC_DEFINES_PCD_INFO_GENERATION:\n            self._PcdInfoFlag = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_VAR_CHECK_GENERATION:\n            self._VarCheckFlag = Record[2]\n        elif Name == TAB_FIX_LOAD_TOP_MEMORY_ADDRESS:\n            try:\n                self._LoadFixAddress = int(Record[2], 0)\n            except:\n                EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % Record[2])\n        elif Name == TAB_DSC_DEFINES_RFC_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for RFC_LANGUAGES must have double quotes around it, for example: RFC_LANGUAGES = \"en-us;zh-hans\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more RFC4646 format language code must be provided for RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            LanguageList = GetSplitValueList(LanguageCodes, TAB_SEMI_COLON_SPLIT)\n            if None in LanguageList:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more empty language code is in RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            self._RFCLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_ISO_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for ISO_LANGUAGES must have double quotes around it, for example: ISO_LANGUAGES = \"engchn\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more ISO639-2 format language code must be provided for ISO_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            if len(LanguageCodes) % 3:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'bad ISO639-2 format for ISO_LANGUAGES', File=self.MetaFile, Line=Record[-1])\n            LanguageList = []\n            for i in range(0, len(LanguageCodes), 3):\n                LanguageList.append(LanguageCodes[i:i + 3])\n            self._ISOLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE:\n            if TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE] = Record[2].strip()\n        elif Name == TAB_DSC_DEFINES_VPD_TOOL_GUID:\n            try:\n                uuid.UUID(Record[2])\n            except:\n                EdkLogger.error('build', FORMAT_INVALID, 'Invalid GUID format for VPD_TOOL_GUID', File=self.MetaFile)\n            self._VpdToolGuid = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX:\n            if TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX] = Record[2].strip()\n        elif Name in self:\n            self[Name] = Record[2]\n    self._Header = 'DUMMY'",
            "def _GetHeaderInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch]\n    for Record in RecordList:\n        Name = Record[1]\n        if Name == TAB_DSC_DEFINES_OUTPUT_DIRECTORY:\n            self._OutputDirectory = NormPath(Record[2], self._Macros)\n            if ' ' in self._OutputDirectory:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'No space is allowed in OUTPUT_DIRECTORY', File=self.MetaFile, Line=Record[-1], ExtraData=self._OutputDirectory)\n        elif Name == TAB_DSC_DEFINES_FLASH_DEFINITION:\n            self._FlashDefinition = PathClass(NormPath(Record[2], self._Macros), GlobalData.gWorkspace)\n            (ErrorCode, ErrorInfo) = self._FlashDefinition.Validate('.fdf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=Record[-1], ExtraData=ErrorInfo)\n        elif Name == TAB_DSC_PREBUILD:\n            PrebuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_PREBUILD, File=self.MetaFile, Line=Record[-1])\n                PrebuildValue = Record[2][1:-1]\n            self._Prebuild = PrebuildValue\n        elif Name == TAB_DSC_POSTBUILD:\n            PostbuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_POSTBUILD, File=self.MetaFile, Line=Record[-1])\n                PostbuildValue = Record[2][1:-1]\n            self._Postbuild = PostbuildValue\n        elif Name == TAB_DSC_DEFINES_SUPPORTED_ARCHITECTURES:\n            self._SupArchList = GetSplitValueList(Record[2], TAB_VALUE_SPLIT)\n        elif Name == TAB_DSC_DEFINES_BUILD_TARGETS:\n            self._BuildTargets = GetSplitValueList(Record[2])\n        elif Name == TAB_DSC_DEFINES_SKUID_IDENTIFIER:\n            if self._SkuName is None:\n                self._SkuName = Record[2]\n            if GlobalData.gSKUID_CMD:\n                self._SkuName = GlobalData.gSKUID_CMD\n        elif Name == TAB_DSC_DEFINES_PCD_INFO_GENERATION:\n            self._PcdInfoFlag = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_VAR_CHECK_GENERATION:\n            self._VarCheckFlag = Record[2]\n        elif Name == TAB_FIX_LOAD_TOP_MEMORY_ADDRESS:\n            try:\n                self._LoadFixAddress = int(Record[2], 0)\n            except:\n                EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % Record[2])\n        elif Name == TAB_DSC_DEFINES_RFC_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for RFC_LANGUAGES must have double quotes around it, for example: RFC_LANGUAGES = \"en-us;zh-hans\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more RFC4646 format language code must be provided for RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            LanguageList = GetSplitValueList(LanguageCodes, TAB_SEMI_COLON_SPLIT)\n            if None in LanguageList:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more empty language code is in RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            self._RFCLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_ISO_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for ISO_LANGUAGES must have double quotes around it, for example: ISO_LANGUAGES = \"engchn\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more ISO639-2 format language code must be provided for ISO_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            if len(LanguageCodes) % 3:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'bad ISO639-2 format for ISO_LANGUAGES', File=self.MetaFile, Line=Record[-1])\n            LanguageList = []\n            for i in range(0, len(LanguageCodes), 3):\n                LanguageList.append(LanguageCodes[i:i + 3])\n            self._ISOLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE:\n            if TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE] = Record[2].strip()\n        elif Name == TAB_DSC_DEFINES_VPD_TOOL_GUID:\n            try:\n                uuid.UUID(Record[2])\n            except:\n                EdkLogger.error('build', FORMAT_INVALID, 'Invalid GUID format for VPD_TOOL_GUID', File=self.MetaFile)\n            self._VpdToolGuid = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX:\n            if TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX] = Record[2].strip()\n        elif Name in self:\n            self[Name] = Record[2]\n    self._Header = 'DUMMY'",
            "def _GetHeaderInfo(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch]\n    for Record in RecordList:\n        Name = Record[1]\n        if Name == TAB_DSC_DEFINES_OUTPUT_DIRECTORY:\n            self._OutputDirectory = NormPath(Record[2], self._Macros)\n            if ' ' in self._OutputDirectory:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'No space is allowed in OUTPUT_DIRECTORY', File=self.MetaFile, Line=Record[-1], ExtraData=self._OutputDirectory)\n        elif Name == TAB_DSC_DEFINES_FLASH_DEFINITION:\n            self._FlashDefinition = PathClass(NormPath(Record[2], self._Macros), GlobalData.gWorkspace)\n            (ErrorCode, ErrorInfo) = self._FlashDefinition.Validate('.fdf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=Record[-1], ExtraData=ErrorInfo)\n        elif Name == TAB_DSC_PREBUILD:\n            PrebuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_PREBUILD, File=self.MetaFile, Line=Record[-1])\n                PrebuildValue = Record[2][1:-1]\n            self._Prebuild = PrebuildValue\n        elif Name == TAB_DSC_POSTBUILD:\n            PostbuildValue = Record[2]\n            if Record[2][0] == '\"':\n                if Record[2][-1] != '\"':\n                    EdkLogger.error('build', FORMAT_INVALID, 'Missing double quotes in the end of %s statement.' % TAB_DSC_POSTBUILD, File=self.MetaFile, Line=Record[-1])\n                PostbuildValue = Record[2][1:-1]\n            self._Postbuild = PostbuildValue\n        elif Name == TAB_DSC_DEFINES_SUPPORTED_ARCHITECTURES:\n            self._SupArchList = GetSplitValueList(Record[2], TAB_VALUE_SPLIT)\n        elif Name == TAB_DSC_DEFINES_BUILD_TARGETS:\n            self._BuildTargets = GetSplitValueList(Record[2])\n        elif Name == TAB_DSC_DEFINES_SKUID_IDENTIFIER:\n            if self._SkuName is None:\n                self._SkuName = Record[2]\n            if GlobalData.gSKUID_CMD:\n                self._SkuName = GlobalData.gSKUID_CMD\n        elif Name == TAB_DSC_DEFINES_PCD_INFO_GENERATION:\n            self._PcdInfoFlag = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_VAR_CHECK_GENERATION:\n            self._VarCheckFlag = Record[2]\n        elif Name == TAB_FIX_LOAD_TOP_MEMORY_ADDRESS:\n            try:\n                self._LoadFixAddress = int(Record[2], 0)\n            except:\n                EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % Record[2])\n        elif Name == TAB_DSC_DEFINES_RFC_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for RFC_LANGUAGES must have double quotes around it, for example: RFC_LANGUAGES = \"en-us;zh-hans\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more RFC4646 format language code must be provided for RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            LanguageList = GetSplitValueList(LanguageCodes, TAB_SEMI_COLON_SPLIT)\n            if None in LanguageList:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more empty language code is in RFC_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            self._RFCLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_ISO_LANGUAGES:\n            if not Record[2] or Record[2][0] != '\"' or Record[2][-1] != '\"' or (len(Record[2]) == 1):\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'language code for ISO_LANGUAGES must have double quotes around it, for example: ISO_LANGUAGES = \"engchn\"', File=self.MetaFile, Line=Record[-1])\n            LanguageCodes = Record[2][1:-1]\n            if not LanguageCodes:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'one or more ISO639-2 format language code must be provided for ISO_LANGUAGES statement', File=self.MetaFile, Line=Record[-1])\n            if len(LanguageCodes) % 3:\n                EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'bad ISO639-2 format for ISO_LANGUAGES', File=self.MetaFile, Line=Record[-1])\n            LanguageList = []\n            for i in range(0, len(LanguageCodes), 3):\n                LanguageList.append(LanguageCodes[i:i + 3])\n            self._ISOLanguages = LanguageList\n        elif Name == TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE:\n            if TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_VPD_AUTHENTICATED_VARIABLE_STORE] = Record[2].strip()\n        elif Name == TAB_DSC_DEFINES_VPD_TOOL_GUID:\n            try:\n                uuid.UUID(Record[2])\n            except:\n                EdkLogger.error('build', FORMAT_INVALID, 'Invalid GUID format for VPD_TOOL_GUID', File=self.MetaFile)\n            self._VpdToolGuid = Record[2]\n        elif Name == TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX:\n            if TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX not in gCommandLineDefines:\n                gCommandLineDefines[TAB_DSC_DEFINES_PCD_DYNAMIC_AS_DYNAMICEX] = Record[2].strip()\n        elif Name in self:\n            self[Name] = Record[2]\n    self._Header = 'DUMMY'"
        ]
    },
    {
        "func_name": "PlatformName",
        "original": "@property\ndef PlatformName(self):\n    if self._PlatformName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._PlatformName is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_NAME', File=self.MetaFile)\n    return self._PlatformName",
        "mutated": [
            "@property\ndef PlatformName(self):\n    if False:\n        i = 10\n    if self._PlatformName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._PlatformName is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_NAME', File=self.MetaFile)\n    return self._PlatformName",
            "@property\ndef PlatformName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._PlatformName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._PlatformName is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_NAME', File=self.MetaFile)\n    return self._PlatformName",
            "@property\ndef PlatformName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._PlatformName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._PlatformName is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_NAME', File=self.MetaFile)\n    return self._PlatformName",
            "@property\ndef PlatformName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._PlatformName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._PlatformName is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_NAME', File=self.MetaFile)\n    return self._PlatformName",
            "@property\ndef PlatformName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._PlatformName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._PlatformName is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_NAME', File=self.MetaFile)\n    return self._PlatformName"
        ]
    },
    {
        "func_name": "Platform",
        "original": "@property\ndef Platform(self):\n    return self.PlatformName",
        "mutated": [
            "@property\ndef Platform(self):\n    if False:\n        i = 10\n    return self.PlatformName",
            "@property\ndef Platform(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.PlatformName",
            "@property\ndef Platform(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.PlatformName",
            "@property\ndef Platform(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.PlatformName",
            "@property\ndef Platform(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.PlatformName"
        ]
    },
    {
        "func_name": "Guid",
        "original": "@property\ndef Guid(self):\n    if self._Guid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Guid is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_GUID', File=self.MetaFile)\n    return self._Guid",
        "mutated": [
            "@property\ndef Guid(self):\n    if False:\n        i = 10\n    if self._Guid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Guid is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_GUID', File=self.MetaFile)\n    return self._Guid",
            "@property\ndef Guid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._Guid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Guid is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_GUID', File=self.MetaFile)\n    return self._Guid",
            "@property\ndef Guid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._Guid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Guid is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_GUID', File=self.MetaFile)\n    return self._Guid",
            "@property\ndef Guid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._Guid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Guid is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_GUID', File=self.MetaFile)\n    return self._Guid",
            "@property\ndef Guid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._Guid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Guid is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_GUID', File=self.MetaFile)\n    return self._Guid"
        ]
    },
    {
        "func_name": "Version",
        "original": "@property\ndef Version(self):\n    if self._Version is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Version is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_VERSION', File=self.MetaFile)\n    return self._Version",
        "mutated": [
            "@property\ndef Version(self):\n    if False:\n        i = 10\n    if self._Version is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Version is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_VERSION', File=self.MetaFile)\n    return self._Version",
            "@property\ndef Version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._Version is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Version is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_VERSION', File=self.MetaFile)\n    return self._Version",
            "@property\ndef Version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._Version is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Version is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_VERSION', File=self.MetaFile)\n    return self._Version",
            "@property\ndef Version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._Version is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Version is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_VERSION', File=self.MetaFile)\n    return self._Version",
            "@property\ndef Version(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._Version is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Version is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No PLATFORM_VERSION', File=self.MetaFile)\n    return self._Version"
        ]
    },
    {
        "func_name": "DscSpecification",
        "original": "@property\ndef DscSpecification(self):\n    if self._DscSpecification is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._DscSpecification is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No DSC_SPECIFICATION', File=self.MetaFile)\n    return self._DscSpecification",
        "mutated": [
            "@property\ndef DscSpecification(self):\n    if False:\n        i = 10\n    if self._DscSpecification is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._DscSpecification is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No DSC_SPECIFICATION', File=self.MetaFile)\n    return self._DscSpecification",
            "@property\ndef DscSpecification(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._DscSpecification is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._DscSpecification is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No DSC_SPECIFICATION', File=self.MetaFile)\n    return self._DscSpecification",
            "@property\ndef DscSpecification(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._DscSpecification is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._DscSpecification is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No DSC_SPECIFICATION', File=self.MetaFile)\n    return self._DscSpecification",
            "@property\ndef DscSpecification(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._DscSpecification is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._DscSpecification is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No DSC_SPECIFICATION', File=self.MetaFile)\n    return self._DscSpecification",
            "@property\ndef DscSpecification(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._DscSpecification is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._DscSpecification is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No DSC_SPECIFICATION', File=self.MetaFile)\n    return self._DscSpecification"
        ]
    },
    {
        "func_name": "OutputDirectory",
        "original": "@property\ndef OutputDirectory(self):\n    if self._OutputDirectory is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._OutputDirectory is None:\n            self._OutputDirectory = os.path.join('Build', self._PlatformName)\n    return self._OutputDirectory",
        "mutated": [
            "@property\ndef OutputDirectory(self):\n    if False:\n        i = 10\n    if self._OutputDirectory is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._OutputDirectory is None:\n            self._OutputDirectory = os.path.join('Build', self._PlatformName)\n    return self._OutputDirectory",
            "@property\ndef OutputDirectory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._OutputDirectory is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._OutputDirectory is None:\n            self._OutputDirectory = os.path.join('Build', self._PlatformName)\n    return self._OutputDirectory",
            "@property\ndef OutputDirectory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._OutputDirectory is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._OutputDirectory is None:\n            self._OutputDirectory = os.path.join('Build', self._PlatformName)\n    return self._OutputDirectory",
            "@property\ndef OutputDirectory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._OutputDirectory is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._OutputDirectory is None:\n            self._OutputDirectory = os.path.join('Build', self._PlatformName)\n    return self._OutputDirectory",
            "@property\ndef OutputDirectory(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._OutputDirectory is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._OutputDirectory is None:\n            self._OutputDirectory = os.path.join('Build', self._PlatformName)\n    return self._OutputDirectory"
        ]
    },
    {
        "func_name": "SupArchList",
        "original": "@property\ndef SupArchList(self):\n    if self._SupArchList is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SupArchList is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No SUPPORTED_ARCHITECTURES', File=self.MetaFile)\n    return self._SupArchList",
        "mutated": [
            "@property\ndef SupArchList(self):\n    if False:\n        i = 10\n    if self._SupArchList is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SupArchList is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No SUPPORTED_ARCHITECTURES', File=self.MetaFile)\n    return self._SupArchList",
            "@property\ndef SupArchList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._SupArchList is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SupArchList is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No SUPPORTED_ARCHITECTURES', File=self.MetaFile)\n    return self._SupArchList",
            "@property\ndef SupArchList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._SupArchList is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SupArchList is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No SUPPORTED_ARCHITECTURES', File=self.MetaFile)\n    return self._SupArchList",
            "@property\ndef SupArchList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._SupArchList is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SupArchList is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No SUPPORTED_ARCHITECTURES', File=self.MetaFile)\n    return self._SupArchList",
            "@property\ndef SupArchList(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._SupArchList is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SupArchList is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No SUPPORTED_ARCHITECTURES', File=self.MetaFile)\n    return self._SupArchList"
        ]
    },
    {
        "func_name": "BuildTargets",
        "original": "@property\ndef BuildTargets(self):\n    if self._BuildTargets is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildTargets is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No BUILD_TARGETS', File=self.MetaFile)\n    return self._BuildTargets",
        "mutated": [
            "@property\ndef BuildTargets(self):\n    if False:\n        i = 10\n    if self._BuildTargets is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildTargets is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No BUILD_TARGETS', File=self.MetaFile)\n    return self._BuildTargets",
            "@property\ndef BuildTargets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._BuildTargets is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildTargets is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No BUILD_TARGETS', File=self.MetaFile)\n    return self._BuildTargets",
            "@property\ndef BuildTargets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._BuildTargets is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildTargets is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No BUILD_TARGETS', File=self.MetaFile)\n    return self._BuildTargets",
            "@property\ndef BuildTargets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._BuildTargets is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildTargets is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No BUILD_TARGETS', File=self.MetaFile)\n    return self._BuildTargets",
            "@property\ndef BuildTargets(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._BuildTargets is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildTargets is None:\n            EdkLogger.error('build', ATTRIBUTE_NOT_AVAILABLE, 'No BUILD_TARGETS', File=self.MetaFile)\n    return self._BuildTargets"
        ]
    },
    {
        "func_name": "PcdInfoFlag",
        "original": "@property\ndef PcdInfoFlag(self):\n    if self._PcdInfoFlag is None or self._PcdInfoFlag.upper() == 'FALSE':\n        return False\n    elif self._PcdInfoFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
        "mutated": [
            "@property\ndef PcdInfoFlag(self):\n    if False:\n        i = 10\n    if self._PcdInfoFlag is None or self._PcdInfoFlag.upper() == 'FALSE':\n        return False\n    elif self._PcdInfoFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
            "@property\ndef PcdInfoFlag(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._PcdInfoFlag is None or self._PcdInfoFlag.upper() == 'FALSE':\n        return False\n    elif self._PcdInfoFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
            "@property\ndef PcdInfoFlag(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._PcdInfoFlag is None or self._PcdInfoFlag.upper() == 'FALSE':\n        return False\n    elif self._PcdInfoFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
            "@property\ndef PcdInfoFlag(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._PcdInfoFlag is None or self._PcdInfoFlag.upper() == 'FALSE':\n        return False\n    elif self._PcdInfoFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
            "@property\ndef PcdInfoFlag(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._PcdInfoFlag is None or self._PcdInfoFlag.upper() == 'FALSE':\n        return False\n    elif self._PcdInfoFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False"
        ]
    },
    {
        "func_name": "VarCheckFlag",
        "original": "@property\ndef VarCheckFlag(self):\n    if self._VarCheckFlag is None or self._VarCheckFlag.upper() == 'FALSE':\n        return False\n    elif self._VarCheckFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
        "mutated": [
            "@property\ndef VarCheckFlag(self):\n    if False:\n        i = 10\n    if self._VarCheckFlag is None or self._VarCheckFlag.upper() == 'FALSE':\n        return False\n    elif self._VarCheckFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
            "@property\ndef VarCheckFlag(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._VarCheckFlag is None or self._VarCheckFlag.upper() == 'FALSE':\n        return False\n    elif self._VarCheckFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
            "@property\ndef VarCheckFlag(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._VarCheckFlag is None or self._VarCheckFlag.upper() == 'FALSE':\n        return False\n    elif self._VarCheckFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
            "@property\ndef VarCheckFlag(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._VarCheckFlag is None or self._VarCheckFlag.upper() == 'FALSE':\n        return False\n    elif self._VarCheckFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False",
            "@property\ndef VarCheckFlag(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._VarCheckFlag is None or self._VarCheckFlag.upper() == 'FALSE':\n        return False\n    elif self._VarCheckFlag.upper() == 'TRUE':\n        return True\n    else:\n        return False"
        ]
    },
    {
        "func_name": "SkuName",
        "original": "@property\ndef SkuName(self):\n    if self._SkuName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SkuName is None:\n            self._SkuName = TAB_DEFAULT\n    return self._SkuName",
        "mutated": [
            "@property\ndef SkuName(self):\n    if False:\n        i = 10\n    if self._SkuName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SkuName is None:\n            self._SkuName = TAB_DEFAULT\n    return self._SkuName",
            "@property\ndef SkuName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._SkuName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SkuName is None:\n            self._SkuName = TAB_DEFAULT\n    return self._SkuName",
            "@property\ndef SkuName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._SkuName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SkuName is None:\n            self._SkuName = TAB_DEFAULT\n    return self._SkuName",
            "@property\ndef SkuName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._SkuName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SkuName is None:\n            self._SkuName = TAB_DEFAULT\n    return self._SkuName",
            "@property\ndef SkuName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._SkuName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._SkuName is None:\n            self._SkuName = TAB_DEFAULT\n    return self._SkuName"
        ]
    },
    {
        "func_name": "SkuName",
        "original": "@SkuName.setter\ndef SkuName(self, Value):\n    self._SkuName = Value",
        "mutated": [
            "@SkuName.setter\ndef SkuName(self, Value):\n    if False:\n        i = 10\n    self._SkuName = Value",
            "@SkuName.setter\ndef SkuName(self, Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._SkuName = Value",
            "@SkuName.setter\ndef SkuName(self, Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._SkuName = Value",
            "@SkuName.setter\ndef SkuName(self, Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._SkuName = Value",
            "@SkuName.setter\ndef SkuName(self, Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._SkuName = Value"
        ]
    },
    {
        "func_name": "FlashDefinition",
        "original": "@property\ndef FlashDefinition(self):\n    if self._FlashDefinition is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._FlashDefinition is None:\n            self._FlashDefinition = ''\n    return self._FlashDefinition",
        "mutated": [
            "@property\ndef FlashDefinition(self):\n    if False:\n        i = 10\n    if self._FlashDefinition is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._FlashDefinition is None:\n            self._FlashDefinition = ''\n    return self._FlashDefinition",
            "@property\ndef FlashDefinition(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._FlashDefinition is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._FlashDefinition is None:\n            self._FlashDefinition = ''\n    return self._FlashDefinition",
            "@property\ndef FlashDefinition(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._FlashDefinition is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._FlashDefinition is None:\n            self._FlashDefinition = ''\n    return self._FlashDefinition",
            "@property\ndef FlashDefinition(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._FlashDefinition is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._FlashDefinition is None:\n            self._FlashDefinition = ''\n    return self._FlashDefinition",
            "@property\ndef FlashDefinition(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._FlashDefinition is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._FlashDefinition is None:\n            self._FlashDefinition = ''\n    return self._FlashDefinition"
        ]
    },
    {
        "func_name": "Prebuild",
        "original": "@property\ndef Prebuild(self):\n    if self._Prebuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Prebuild is None:\n            self._Prebuild = ''\n    return self._Prebuild",
        "mutated": [
            "@property\ndef Prebuild(self):\n    if False:\n        i = 10\n    if self._Prebuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Prebuild is None:\n            self._Prebuild = ''\n    return self._Prebuild",
            "@property\ndef Prebuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._Prebuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Prebuild is None:\n            self._Prebuild = ''\n    return self._Prebuild",
            "@property\ndef Prebuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._Prebuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Prebuild is None:\n            self._Prebuild = ''\n    return self._Prebuild",
            "@property\ndef Prebuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._Prebuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Prebuild is None:\n            self._Prebuild = ''\n    return self._Prebuild",
            "@property\ndef Prebuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._Prebuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Prebuild is None:\n            self._Prebuild = ''\n    return self._Prebuild"
        ]
    },
    {
        "func_name": "Postbuild",
        "original": "@property\ndef Postbuild(self):\n    if self._Postbuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Postbuild is None:\n            self._Postbuild = ''\n    return self._Postbuild",
        "mutated": [
            "@property\ndef Postbuild(self):\n    if False:\n        i = 10\n    if self._Postbuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Postbuild is None:\n            self._Postbuild = ''\n    return self._Postbuild",
            "@property\ndef Postbuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._Postbuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Postbuild is None:\n            self._Postbuild = ''\n    return self._Postbuild",
            "@property\ndef Postbuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._Postbuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Postbuild is None:\n            self._Postbuild = ''\n    return self._Postbuild",
            "@property\ndef Postbuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._Postbuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Postbuild is None:\n            self._Postbuild = ''\n    return self._Postbuild",
            "@property\ndef Postbuild(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._Postbuild is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._Postbuild is None:\n            self._Postbuild = ''\n    return self._Postbuild"
        ]
    },
    {
        "func_name": "BuildNumber",
        "original": "@property\ndef BuildNumber(self):\n    if self._BuildNumber is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildNumber is None:\n            self._BuildNumber = ''\n    return self._BuildNumber",
        "mutated": [
            "@property\ndef BuildNumber(self):\n    if False:\n        i = 10\n    if self._BuildNumber is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildNumber is None:\n            self._BuildNumber = ''\n    return self._BuildNumber",
            "@property\ndef BuildNumber(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._BuildNumber is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildNumber is None:\n            self._BuildNumber = ''\n    return self._BuildNumber",
            "@property\ndef BuildNumber(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._BuildNumber is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildNumber is None:\n            self._BuildNumber = ''\n    return self._BuildNumber",
            "@property\ndef BuildNumber(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._BuildNumber is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildNumber is None:\n            self._BuildNumber = ''\n    return self._BuildNumber",
            "@property\ndef BuildNumber(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._BuildNumber is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BuildNumber is None:\n            self._BuildNumber = ''\n    return self._BuildNumber"
        ]
    },
    {
        "func_name": "MakefileName",
        "original": "@property\ndef MakefileName(self):\n    if self._MakefileName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._MakefileName is None:\n            self._MakefileName = ''\n    return self._MakefileName",
        "mutated": [
            "@property\ndef MakefileName(self):\n    if False:\n        i = 10\n    if self._MakefileName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._MakefileName is None:\n            self._MakefileName = ''\n    return self._MakefileName",
            "@property\ndef MakefileName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._MakefileName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._MakefileName is None:\n            self._MakefileName = ''\n    return self._MakefileName",
            "@property\ndef MakefileName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._MakefileName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._MakefileName is None:\n            self._MakefileName = ''\n    return self._MakefileName",
            "@property\ndef MakefileName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._MakefileName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._MakefileName is None:\n            self._MakefileName = ''\n    return self._MakefileName",
            "@property\ndef MakefileName(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._MakefileName is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._MakefileName is None:\n            self._MakefileName = ''\n    return self._MakefileName"
        ]
    },
    {
        "func_name": "BsBaseAddress",
        "original": "@property\ndef BsBaseAddress(self):\n    if self._BsBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BsBaseAddress is None:\n            self._BsBaseAddress = ''\n    return self._BsBaseAddress",
        "mutated": [
            "@property\ndef BsBaseAddress(self):\n    if False:\n        i = 10\n    if self._BsBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BsBaseAddress is None:\n            self._BsBaseAddress = ''\n    return self._BsBaseAddress",
            "@property\ndef BsBaseAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._BsBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BsBaseAddress is None:\n            self._BsBaseAddress = ''\n    return self._BsBaseAddress",
            "@property\ndef BsBaseAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._BsBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BsBaseAddress is None:\n            self._BsBaseAddress = ''\n    return self._BsBaseAddress",
            "@property\ndef BsBaseAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._BsBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BsBaseAddress is None:\n            self._BsBaseAddress = ''\n    return self._BsBaseAddress",
            "@property\ndef BsBaseAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._BsBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._BsBaseAddress is None:\n            self._BsBaseAddress = ''\n    return self._BsBaseAddress"
        ]
    },
    {
        "func_name": "RtBaseAddress",
        "original": "@property\ndef RtBaseAddress(self):\n    if self._RtBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RtBaseAddress is None:\n            self._RtBaseAddress = ''\n    return self._RtBaseAddress",
        "mutated": [
            "@property\ndef RtBaseAddress(self):\n    if False:\n        i = 10\n    if self._RtBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RtBaseAddress is None:\n            self._RtBaseAddress = ''\n    return self._RtBaseAddress",
            "@property\ndef RtBaseAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._RtBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RtBaseAddress is None:\n            self._RtBaseAddress = ''\n    return self._RtBaseAddress",
            "@property\ndef RtBaseAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._RtBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RtBaseAddress is None:\n            self._RtBaseAddress = ''\n    return self._RtBaseAddress",
            "@property\ndef RtBaseAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._RtBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RtBaseAddress is None:\n            self._RtBaseAddress = ''\n    return self._RtBaseAddress",
            "@property\ndef RtBaseAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._RtBaseAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RtBaseAddress is None:\n            self._RtBaseAddress = ''\n    return self._RtBaseAddress"
        ]
    },
    {
        "func_name": "LoadFixAddress",
        "original": "@property\ndef LoadFixAddress(self):\n    if self._LoadFixAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._LoadFixAddress is None:\n            self._LoadFixAddress = self._Macros.get(TAB_FIX_LOAD_TOP_MEMORY_ADDRESS, '0')\n        try:\n            self._LoadFixAddress = int(self._LoadFixAddress, 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % self._LoadFixAddress)\n    if 'FIX_LOAD_TOP_MEMORY_ADDRESS' in GlobalData.gCommandLineDefines:\n        try:\n            self._LoadFixAddress = int(GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'], 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'])\n    if self._LoadFixAddress < 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid negative value 0x%x' % self._LoadFixAddress)\n    if self._LoadFixAddress != 18446744073709551615 and self._LoadFixAddress % 4096 != 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid unaligned 4K value 0x%x' % self._LoadFixAddress)\n    return self._LoadFixAddress",
        "mutated": [
            "@property\ndef LoadFixAddress(self):\n    if False:\n        i = 10\n    if self._LoadFixAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._LoadFixAddress is None:\n            self._LoadFixAddress = self._Macros.get(TAB_FIX_LOAD_TOP_MEMORY_ADDRESS, '0')\n        try:\n            self._LoadFixAddress = int(self._LoadFixAddress, 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % self._LoadFixAddress)\n    if 'FIX_LOAD_TOP_MEMORY_ADDRESS' in GlobalData.gCommandLineDefines:\n        try:\n            self._LoadFixAddress = int(GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'], 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'])\n    if self._LoadFixAddress < 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid negative value 0x%x' % self._LoadFixAddress)\n    if self._LoadFixAddress != 18446744073709551615 and self._LoadFixAddress % 4096 != 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid unaligned 4K value 0x%x' % self._LoadFixAddress)\n    return self._LoadFixAddress",
            "@property\ndef LoadFixAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._LoadFixAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._LoadFixAddress is None:\n            self._LoadFixAddress = self._Macros.get(TAB_FIX_LOAD_TOP_MEMORY_ADDRESS, '0')\n        try:\n            self._LoadFixAddress = int(self._LoadFixAddress, 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % self._LoadFixAddress)\n    if 'FIX_LOAD_TOP_MEMORY_ADDRESS' in GlobalData.gCommandLineDefines:\n        try:\n            self._LoadFixAddress = int(GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'], 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'])\n    if self._LoadFixAddress < 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid negative value 0x%x' % self._LoadFixAddress)\n    if self._LoadFixAddress != 18446744073709551615 and self._LoadFixAddress % 4096 != 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid unaligned 4K value 0x%x' % self._LoadFixAddress)\n    return self._LoadFixAddress",
            "@property\ndef LoadFixAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._LoadFixAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._LoadFixAddress is None:\n            self._LoadFixAddress = self._Macros.get(TAB_FIX_LOAD_TOP_MEMORY_ADDRESS, '0')\n        try:\n            self._LoadFixAddress = int(self._LoadFixAddress, 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % self._LoadFixAddress)\n    if 'FIX_LOAD_TOP_MEMORY_ADDRESS' in GlobalData.gCommandLineDefines:\n        try:\n            self._LoadFixAddress = int(GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'], 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'])\n    if self._LoadFixAddress < 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid negative value 0x%x' % self._LoadFixAddress)\n    if self._LoadFixAddress != 18446744073709551615 and self._LoadFixAddress % 4096 != 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid unaligned 4K value 0x%x' % self._LoadFixAddress)\n    return self._LoadFixAddress",
            "@property\ndef LoadFixAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._LoadFixAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._LoadFixAddress is None:\n            self._LoadFixAddress = self._Macros.get(TAB_FIX_LOAD_TOP_MEMORY_ADDRESS, '0')\n        try:\n            self._LoadFixAddress = int(self._LoadFixAddress, 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % self._LoadFixAddress)\n    if 'FIX_LOAD_TOP_MEMORY_ADDRESS' in GlobalData.gCommandLineDefines:\n        try:\n            self._LoadFixAddress = int(GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'], 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'])\n    if self._LoadFixAddress < 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid negative value 0x%x' % self._LoadFixAddress)\n    if self._LoadFixAddress != 18446744073709551615 and self._LoadFixAddress % 4096 != 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid unaligned 4K value 0x%x' % self._LoadFixAddress)\n    return self._LoadFixAddress",
            "@property\ndef LoadFixAddress(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._LoadFixAddress is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._LoadFixAddress is None:\n            self._LoadFixAddress = self._Macros.get(TAB_FIX_LOAD_TOP_MEMORY_ADDRESS, '0')\n        try:\n            self._LoadFixAddress = int(self._LoadFixAddress, 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % self._LoadFixAddress)\n    if 'FIX_LOAD_TOP_MEMORY_ADDRESS' in GlobalData.gCommandLineDefines:\n        try:\n            self._LoadFixAddress = int(GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'], 0)\n        except:\n            EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS %s is not valid dec or hex string' % GlobalData.gCommandLineDefines['FIX_LOAD_TOP_MEMORY_ADDRESS'])\n    if self._LoadFixAddress < 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid negative value 0x%x' % self._LoadFixAddress)\n    if self._LoadFixAddress != 18446744073709551615 and self._LoadFixAddress % 4096 != 0:\n        EdkLogger.error('build', PARAMETER_INVALID, 'FIX_LOAD_TOP_MEMORY_ADDRESS is set to the invalid unaligned 4K value 0x%x' % self._LoadFixAddress)\n    return self._LoadFixAddress"
        ]
    },
    {
        "func_name": "RFCLanguages",
        "original": "@property\ndef RFCLanguages(self):\n    if self._RFCLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RFCLanguages is None:\n            self._RFCLanguages = []\n    return self._RFCLanguages",
        "mutated": [
            "@property\ndef RFCLanguages(self):\n    if False:\n        i = 10\n    if self._RFCLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RFCLanguages is None:\n            self._RFCLanguages = []\n    return self._RFCLanguages",
            "@property\ndef RFCLanguages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._RFCLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RFCLanguages is None:\n            self._RFCLanguages = []\n    return self._RFCLanguages",
            "@property\ndef RFCLanguages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._RFCLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RFCLanguages is None:\n            self._RFCLanguages = []\n    return self._RFCLanguages",
            "@property\ndef RFCLanguages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._RFCLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RFCLanguages is None:\n            self._RFCLanguages = []\n    return self._RFCLanguages",
            "@property\ndef RFCLanguages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._RFCLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._RFCLanguages is None:\n            self._RFCLanguages = []\n    return self._RFCLanguages"
        ]
    },
    {
        "func_name": "ISOLanguages",
        "original": "@property\ndef ISOLanguages(self):\n    if self._ISOLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._ISOLanguages is None:\n            self._ISOLanguages = []\n    return self._ISOLanguages",
        "mutated": [
            "@property\ndef ISOLanguages(self):\n    if False:\n        i = 10\n    if self._ISOLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._ISOLanguages is None:\n            self._ISOLanguages = []\n    return self._ISOLanguages",
            "@property\ndef ISOLanguages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._ISOLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._ISOLanguages is None:\n            self._ISOLanguages = []\n    return self._ISOLanguages",
            "@property\ndef ISOLanguages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._ISOLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._ISOLanguages is None:\n            self._ISOLanguages = []\n    return self._ISOLanguages",
            "@property\ndef ISOLanguages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._ISOLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._ISOLanguages is None:\n            self._ISOLanguages = []\n    return self._ISOLanguages",
            "@property\ndef ISOLanguages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._ISOLanguages is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._ISOLanguages is None:\n            self._ISOLanguages = []\n    return self._ISOLanguages"
        ]
    },
    {
        "func_name": "VpdToolGuid",
        "original": "@property\ndef VpdToolGuid(self):\n    if self._VpdToolGuid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._VpdToolGuid is None:\n            self._VpdToolGuid = ''\n    return self._VpdToolGuid",
        "mutated": [
            "@property\ndef VpdToolGuid(self):\n    if False:\n        i = 10\n    if self._VpdToolGuid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._VpdToolGuid is None:\n            self._VpdToolGuid = ''\n    return self._VpdToolGuid",
            "@property\ndef VpdToolGuid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._VpdToolGuid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._VpdToolGuid is None:\n            self._VpdToolGuid = ''\n    return self._VpdToolGuid",
            "@property\ndef VpdToolGuid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._VpdToolGuid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._VpdToolGuid is None:\n            self._VpdToolGuid = ''\n    return self._VpdToolGuid",
            "@property\ndef VpdToolGuid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._VpdToolGuid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._VpdToolGuid is None:\n            self._VpdToolGuid = ''\n    return self._VpdToolGuid",
            "@property\ndef VpdToolGuid(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._VpdToolGuid is None:\n        if self._Header is None:\n            self._GetHeaderInfo()\n        if self._VpdToolGuid is None:\n            self._VpdToolGuid = ''\n    return self._VpdToolGuid"
        ]
    },
    {
        "func_name": "SkuIds",
        "original": "@property\ndef SkuIds(self):\n    if self._SkuIds is None:\n        self._SkuIds = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_SKU_ID, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the Sku ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not SkuIdPattern.match(Record[1]) or (Record[2] and (not SkuIdPattern.match(Record[2]))):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the Sku ID name is invalid. The correct format is '(a-zA-Z_)(a-zA-Z0-9_)*'\", File=self.MetaFile, Line=Record[-1])\n            self._SkuIds[Record[1].upper()] = (str(DscBuildData.ToInt(Record[0])), Record[1].upper(), Record[2].upper())\n        if TAB_DEFAULT not in self._SkuIds:\n            self._SkuIds[TAB_DEFAULT] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n        if TAB_COMMON not in self._SkuIds:\n            self._SkuIds[TAB_COMMON] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n    return self._SkuIds",
        "mutated": [
            "@property\ndef SkuIds(self):\n    if False:\n        i = 10\n    if self._SkuIds is None:\n        self._SkuIds = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_SKU_ID, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the Sku ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not SkuIdPattern.match(Record[1]) or (Record[2] and (not SkuIdPattern.match(Record[2]))):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the Sku ID name is invalid. The correct format is '(a-zA-Z_)(a-zA-Z0-9_)*'\", File=self.MetaFile, Line=Record[-1])\n            self._SkuIds[Record[1].upper()] = (str(DscBuildData.ToInt(Record[0])), Record[1].upper(), Record[2].upper())\n        if TAB_DEFAULT not in self._SkuIds:\n            self._SkuIds[TAB_DEFAULT] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n        if TAB_COMMON not in self._SkuIds:\n            self._SkuIds[TAB_COMMON] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n    return self._SkuIds",
            "@property\ndef SkuIds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._SkuIds is None:\n        self._SkuIds = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_SKU_ID, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the Sku ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not SkuIdPattern.match(Record[1]) or (Record[2] and (not SkuIdPattern.match(Record[2]))):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the Sku ID name is invalid. The correct format is '(a-zA-Z_)(a-zA-Z0-9_)*'\", File=self.MetaFile, Line=Record[-1])\n            self._SkuIds[Record[1].upper()] = (str(DscBuildData.ToInt(Record[0])), Record[1].upper(), Record[2].upper())\n        if TAB_DEFAULT not in self._SkuIds:\n            self._SkuIds[TAB_DEFAULT] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n        if TAB_COMMON not in self._SkuIds:\n            self._SkuIds[TAB_COMMON] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n    return self._SkuIds",
            "@property\ndef SkuIds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._SkuIds is None:\n        self._SkuIds = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_SKU_ID, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the Sku ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not SkuIdPattern.match(Record[1]) or (Record[2] and (not SkuIdPattern.match(Record[2]))):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the Sku ID name is invalid. The correct format is '(a-zA-Z_)(a-zA-Z0-9_)*'\", File=self.MetaFile, Line=Record[-1])\n            self._SkuIds[Record[1].upper()] = (str(DscBuildData.ToInt(Record[0])), Record[1].upper(), Record[2].upper())\n        if TAB_DEFAULT not in self._SkuIds:\n            self._SkuIds[TAB_DEFAULT] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n        if TAB_COMMON not in self._SkuIds:\n            self._SkuIds[TAB_COMMON] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n    return self._SkuIds",
            "@property\ndef SkuIds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._SkuIds is None:\n        self._SkuIds = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_SKU_ID, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the Sku ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not SkuIdPattern.match(Record[1]) or (Record[2] and (not SkuIdPattern.match(Record[2]))):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the Sku ID name is invalid. The correct format is '(a-zA-Z_)(a-zA-Z0-9_)*'\", File=self.MetaFile, Line=Record[-1])\n            self._SkuIds[Record[1].upper()] = (str(DscBuildData.ToInt(Record[0])), Record[1].upper(), Record[2].upper())\n        if TAB_DEFAULT not in self._SkuIds:\n            self._SkuIds[TAB_DEFAULT] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n        if TAB_COMMON not in self._SkuIds:\n            self._SkuIds[TAB_COMMON] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n    return self._SkuIds",
            "@property\ndef SkuIds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._SkuIds is None:\n        self._SkuIds = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_SKU_ID, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No Sku ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the Sku ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not SkuIdPattern.match(Record[1]) or (Record[2] and (not SkuIdPattern.match(Record[2]))):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the Sku ID name is invalid. The correct format is '(a-zA-Z_)(a-zA-Z0-9_)*'\", File=self.MetaFile, Line=Record[-1])\n            self._SkuIds[Record[1].upper()] = (str(DscBuildData.ToInt(Record[0])), Record[1].upper(), Record[2].upper())\n        if TAB_DEFAULT not in self._SkuIds:\n            self._SkuIds[TAB_DEFAULT] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n        if TAB_COMMON not in self._SkuIds:\n            self._SkuIds[TAB_COMMON] = ('0', TAB_DEFAULT, TAB_DEFAULT)\n    return self._SkuIds"
        ]
    },
    {
        "func_name": "ToInt",
        "original": "@staticmethod\ndef ToInt(intstr):\n    return int(intstr, 16) if intstr.upper().startswith('0X') else int(intstr)",
        "mutated": [
            "@staticmethod\ndef ToInt(intstr):\n    if False:\n        i = 10\n    return int(intstr, 16) if intstr.upper().startswith('0X') else int(intstr)",
            "@staticmethod\ndef ToInt(intstr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return int(intstr, 16) if intstr.upper().startswith('0X') else int(intstr)",
            "@staticmethod\ndef ToInt(intstr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return int(intstr, 16) if intstr.upper().startswith('0X') else int(intstr)",
            "@staticmethod\ndef ToInt(intstr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return int(intstr, 16) if intstr.upper().startswith('0X') else int(intstr)",
            "@staticmethod\ndef ToInt(intstr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return int(intstr, 16) if intstr.upper().startswith('0X') else int(intstr)"
        ]
    },
    {
        "func_name": "_GetDefaultStores",
        "original": "def _GetDefaultStores(self):\n    if self.DefaultStores is None:\n        self.DefaultStores = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_DEFAULT_STORES, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the DefaultStores ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not IsValidWord(Record[1]):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the DefaultStores ID name is invalid. The correct format is '(a-zA-Z0-9_)(a-zA-Z0-9_-.)*'\", File=self.MetaFile, Line=Record[-1])\n            self.DefaultStores[Record[1].upper()] = (DscBuildData.ToInt(Record[0]), Record[1].upper())\n        if TAB_DEFAULT_STORES_DEFAULT not in self.DefaultStores:\n            self.DefaultStores[TAB_DEFAULT_STORES_DEFAULT] = (0, TAB_DEFAULT_STORES_DEFAULT)\n        GlobalData.gDefaultStores = sorted(self.DefaultStores.keys())\n    return self.DefaultStores",
        "mutated": [
            "def _GetDefaultStores(self):\n    if False:\n        i = 10\n    if self.DefaultStores is None:\n        self.DefaultStores = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_DEFAULT_STORES, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the DefaultStores ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not IsValidWord(Record[1]):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the DefaultStores ID name is invalid. The correct format is '(a-zA-Z0-9_)(a-zA-Z0-9_-.)*'\", File=self.MetaFile, Line=Record[-1])\n            self.DefaultStores[Record[1].upper()] = (DscBuildData.ToInt(Record[0]), Record[1].upper())\n        if TAB_DEFAULT_STORES_DEFAULT not in self.DefaultStores:\n            self.DefaultStores[TAB_DEFAULT_STORES_DEFAULT] = (0, TAB_DEFAULT_STORES_DEFAULT)\n        GlobalData.gDefaultStores = sorted(self.DefaultStores.keys())\n    return self.DefaultStores",
            "def _GetDefaultStores(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.DefaultStores is None:\n        self.DefaultStores = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_DEFAULT_STORES, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the DefaultStores ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not IsValidWord(Record[1]):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the DefaultStores ID name is invalid. The correct format is '(a-zA-Z0-9_)(a-zA-Z0-9_-.)*'\", File=self.MetaFile, Line=Record[-1])\n            self.DefaultStores[Record[1].upper()] = (DscBuildData.ToInt(Record[0]), Record[1].upper())\n        if TAB_DEFAULT_STORES_DEFAULT not in self.DefaultStores:\n            self.DefaultStores[TAB_DEFAULT_STORES_DEFAULT] = (0, TAB_DEFAULT_STORES_DEFAULT)\n        GlobalData.gDefaultStores = sorted(self.DefaultStores.keys())\n    return self.DefaultStores",
            "def _GetDefaultStores(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.DefaultStores is None:\n        self.DefaultStores = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_DEFAULT_STORES, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the DefaultStores ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not IsValidWord(Record[1]):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the DefaultStores ID name is invalid. The correct format is '(a-zA-Z0-9_)(a-zA-Z0-9_-.)*'\", File=self.MetaFile, Line=Record[-1])\n            self.DefaultStores[Record[1].upper()] = (DscBuildData.ToInt(Record[0]), Record[1].upper())\n        if TAB_DEFAULT_STORES_DEFAULT not in self.DefaultStores:\n            self.DefaultStores[TAB_DEFAULT_STORES_DEFAULT] = (0, TAB_DEFAULT_STORES_DEFAULT)\n        GlobalData.gDefaultStores = sorted(self.DefaultStores.keys())\n    return self.DefaultStores",
            "def _GetDefaultStores(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.DefaultStores is None:\n        self.DefaultStores = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_DEFAULT_STORES, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the DefaultStores ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not IsValidWord(Record[1]):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the DefaultStores ID name is invalid. The correct format is '(a-zA-Z0-9_)(a-zA-Z0-9_-.)*'\", File=self.MetaFile, Line=Record[-1])\n            self.DefaultStores[Record[1].upper()] = (DscBuildData.ToInt(Record[0]), Record[1].upper())\n        if TAB_DEFAULT_STORES_DEFAULT not in self.DefaultStores:\n            self.DefaultStores[TAB_DEFAULT_STORES_DEFAULT] = (0, TAB_DEFAULT_STORES_DEFAULT)\n        GlobalData.gDefaultStores = sorted(self.DefaultStores.keys())\n    return self.DefaultStores",
            "def _GetDefaultStores(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.DefaultStores is None:\n        self.DefaultStores = OrderedDict()\n        RecordList = self._RawData[MODEL_EFI_DEFAULT_STORES, self._Arch]\n        for Record in RecordList:\n            if not Record[0]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID number', File=self.MetaFile, Line=Record[-1])\n            if not Record[1]:\n                EdkLogger.error('build', FORMAT_INVALID, 'No DefaultStores ID name', File=self.MetaFile, Line=Record[-1])\n            if not Pattern.match(Record[0]) and (not HexPattern.match(Record[0])):\n                EdkLogger.error('build', FORMAT_INVALID, 'The format of the DefaultStores ID number is invalid. It only support Integer and HexNumber', File=self.MetaFile, Line=Record[-1])\n            if not IsValidWord(Record[1]):\n                EdkLogger.error('build', FORMAT_INVALID, \"The format of the DefaultStores ID name is invalid. The correct format is '(a-zA-Z0-9_)(a-zA-Z0-9_-.)*'\", File=self.MetaFile, Line=Record[-1])\n            self.DefaultStores[Record[1].upper()] = (DscBuildData.ToInt(Record[0]), Record[1].upper())\n        if TAB_DEFAULT_STORES_DEFAULT not in self.DefaultStores:\n            self.DefaultStores[TAB_DEFAULT_STORES_DEFAULT] = (0, TAB_DEFAULT_STORES_DEFAULT)\n        GlobalData.gDefaultStores = sorted(self.DefaultStores.keys())\n    return self.DefaultStores"
        ]
    },
    {
        "func_name": "OverrideDuplicateModule",
        "original": "def OverrideDuplicateModule(self):\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    Components = {}\n    for Record in RecordList:\n        ModuleId = Record[6]\n        file_guid = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        file_guid_str = file_guid[0][2] if file_guid else 'NULL'\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        if self._Arch != TAB_ARCH_COMMON and (file_guid_str, str(ModuleFile)) in Components:\n            self._RawData.DisableOverrideComponent(Components[file_guid_str, str(ModuleFile)])\n        Components[file_guid_str, str(ModuleFile)] = ModuleId\n    self._RawData._PostProcessed = False",
        "mutated": [
            "def OverrideDuplicateModule(self):\n    if False:\n        i = 10\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    Components = {}\n    for Record in RecordList:\n        ModuleId = Record[6]\n        file_guid = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        file_guid_str = file_guid[0][2] if file_guid else 'NULL'\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        if self._Arch != TAB_ARCH_COMMON and (file_guid_str, str(ModuleFile)) in Components:\n            self._RawData.DisableOverrideComponent(Components[file_guid_str, str(ModuleFile)])\n        Components[file_guid_str, str(ModuleFile)] = ModuleId\n    self._RawData._PostProcessed = False",
            "def OverrideDuplicateModule(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    Components = {}\n    for Record in RecordList:\n        ModuleId = Record[6]\n        file_guid = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        file_guid_str = file_guid[0][2] if file_guid else 'NULL'\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        if self._Arch != TAB_ARCH_COMMON and (file_guid_str, str(ModuleFile)) in Components:\n            self._RawData.DisableOverrideComponent(Components[file_guid_str, str(ModuleFile)])\n        Components[file_guid_str, str(ModuleFile)] = ModuleId\n    self._RawData._PostProcessed = False",
            "def OverrideDuplicateModule(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    Components = {}\n    for Record in RecordList:\n        ModuleId = Record[6]\n        file_guid = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        file_guid_str = file_guid[0][2] if file_guid else 'NULL'\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        if self._Arch != TAB_ARCH_COMMON and (file_guid_str, str(ModuleFile)) in Components:\n            self._RawData.DisableOverrideComponent(Components[file_guid_str, str(ModuleFile)])\n        Components[file_guid_str, str(ModuleFile)] = ModuleId\n    self._RawData._PostProcessed = False",
            "def OverrideDuplicateModule(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    Components = {}\n    for Record in RecordList:\n        ModuleId = Record[6]\n        file_guid = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        file_guid_str = file_guid[0][2] if file_guid else 'NULL'\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        if self._Arch != TAB_ARCH_COMMON and (file_guid_str, str(ModuleFile)) in Components:\n            self._RawData.DisableOverrideComponent(Components[file_guid_str, str(ModuleFile)])\n        Components[file_guid_str, str(ModuleFile)] = ModuleId\n    self._RawData._PostProcessed = False",
            "def OverrideDuplicateModule(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    Components = {}\n    for Record in RecordList:\n        ModuleId = Record[6]\n        file_guid = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        file_guid_str = file_guid[0][2] if file_guid else 'NULL'\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        if self._Arch != TAB_ARCH_COMMON and (file_guid_str, str(ModuleFile)) in Components:\n            self._RawData.DisableOverrideComponent(Components[file_guid_str, str(ModuleFile)])\n        Components[file_guid_str, str(ModuleFile)] = ModuleId\n    self._RawData._PostProcessed = False"
        ]
    },
    {
        "func_name": "Packages",
        "original": "@cached_property\ndef Packages(self):\n    RetVal = set()\n    RecordList = self._RawData[MODEL_META_DATA_PACKAGE, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        (ErrorCode, ErrorInfo) = File.Validate('.dec')\n        if ErrorCode != 0:\n            LineNo = Record[-1]\n            EdkLogger.error('build', ErrorCode, ExtraData=ErrorInfo, File=self.MetaFile, Line=LineNo)\n        RetVal.add(self._Bdb[File, self._Arch, self._Target, self._Toolchain])\n    return RetVal",
        "mutated": [
            "@cached_property\ndef Packages(self):\n    if False:\n        i = 10\n    RetVal = set()\n    RecordList = self._RawData[MODEL_META_DATA_PACKAGE, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        (ErrorCode, ErrorInfo) = File.Validate('.dec')\n        if ErrorCode != 0:\n            LineNo = Record[-1]\n            EdkLogger.error('build', ErrorCode, ExtraData=ErrorInfo, File=self.MetaFile, Line=LineNo)\n        RetVal.add(self._Bdb[File, self._Arch, self._Target, self._Toolchain])\n    return RetVal",
            "@cached_property\ndef Packages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    RetVal = set()\n    RecordList = self._RawData[MODEL_META_DATA_PACKAGE, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        (ErrorCode, ErrorInfo) = File.Validate('.dec')\n        if ErrorCode != 0:\n            LineNo = Record[-1]\n            EdkLogger.error('build', ErrorCode, ExtraData=ErrorInfo, File=self.MetaFile, Line=LineNo)\n        RetVal.add(self._Bdb[File, self._Arch, self._Target, self._Toolchain])\n    return RetVal",
            "@cached_property\ndef Packages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    RetVal = set()\n    RecordList = self._RawData[MODEL_META_DATA_PACKAGE, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        (ErrorCode, ErrorInfo) = File.Validate('.dec')\n        if ErrorCode != 0:\n            LineNo = Record[-1]\n            EdkLogger.error('build', ErrorCode, ExtraData=ErrorInfo, File=self.MetaFile, Line=LineNo)\n        RetVal.add(self._Bdb[File, self._Arch, self._Target, self._Toolchain])\n    return RetVal",
            "@cached_property\ndef Packages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    RetVal = set()\n    RecordList = self._RawData[MODEL_META_DATA_PACKAGE, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        (ErrorCode, ErrorInfo) = File.Validate('.dec')\n        if ErrorCode != 0:\n            LineNo = Record[-1]\n            EdkLogger.error('build', ErrorCode, ExtraData=ErrorInfo, File=self.MetaFile, Line=LineNo)\n        RetVal.add(self._Bdb[File, self._Arch, self._Target, self._Toolchain])\n    return RetVal",
            "@cached_property\ndef Packages(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    RetVal = set()\n    RecordList = self._RawData[MODEL_META_DATA_PACKAGE, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        (ErrorCode, ErrorInfo) = File.Validate('.dec')\n        if ErrorCode != 0:\n            LineNo = Record[-1]\n            EdkLogger.error('build', ErrorCode, ExtraData=ErrorInfo, File=self.MetaFile, Line=LineNo)\n        RetVal.add(self._Bdb[File, self._Arch, self._Target, self._Toolchain])\n    return RetVal"
        ]
    },
    {
        "func_name": "Modules",
        "original": "@property\ndef Modules(self):\n    if self._Modules is not None:\n        return self._Modules\n    self.OverrideDuplicateModule()\n    self._Modules = OrderedDict()\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        ModuleId = Record[6]\n        LineNo = Record[7]\n        (ErrorCode, ErrorInfo) = ModuleFile.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n        ModuleBuildData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = ModuleFile\n        Module.Guid = ModuleBuildData.Guid\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, ModuleId]\n        for Record in RecordList:\n            LibraryClass = Record[0]\n            LibraryPath = PathClass(NormPath(Record[1], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = LibraryPath.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for %s\\n\\t%s [%s]' % (ModuleFile, LibraryPath, LibraryClass))\n            Module.LibraryClasses[LibraryClass] = LibraryPath\n            if LibraryPath not in self.LibraryInstances:\n                self.LibraryInstances.append(LibraryPath)\n        S_PcdSet = []\n        for Type in [MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE, MODEL_PCD_FEATURE_FLAG, MODEL_PCD_DYNAMIC, MODEL_PCD_DYNAMIC_EX]:\n            RecordList = self._RawData[Type, self._Arch, None, ModuleId]\n            for (TokenSpaceGuid, PcdCName, Setting, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                TokenList = GetSplitValueList(Setting)\n                DefaultValue = TokenList[0]\n                if len(TokenList) > 2:\n                    MaxDatumSize = TokenList[2]\n                else:\n                    MaxDatumSize = ''\n                TypeString = self._PCD_TYPE_STRING_[Type]\n                (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n                if '.' in TokenSpaceGuid or '[' in PcdCName:\n                    S_PcdSet.append([TCName, PCName, DimensionAttr, Field, ModuleBuildData.Guid, '', Dummy5, AnalyzePcdExpression(Setting)[0]])\n                    DefaultValue = ''\n                if (PCName, TCName) not in Module.Pcds:\n                    Pcd = PcdClassObject(PCName, TCName, TypeString, '', DefaultValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n                    Module.Pcds[PCName, TCName] = Pcd\n        Module.StrPcdSet = S_PcdSet\n        for (TCName, PCName, _, _, _, _, _, _) in S_PcdSet:\n            if (PCName, TCName) in Module.Pcds:\n                Module.StrPcdOverallValue[PCName, TCName] = (Module.Pcds[PCName, TCName].DefaultValue, self.MetaFile, Dummy5)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, None, ModuleId]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if (ToolChainFamily, ToolChain) not in Module.BuildOptions:\n                Module.BuildOptions[ToolChainFamily, ToolChain] = Option\n            else:\n                OptionString = Module.BuildOptions[ToolChainFamily, ToolChain]\n                Module.BuildOptions[ToolChainFamily, ToolChain] = OptionString + ' ' + Option\n        RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        if RecordList:\n            if len(RecordList) != 1:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Only FILE_GUID can be listed in <Defines> section.', File=self.MetaFile, ExtraData=str(ModuleFile), Line=LineNo)\n            ModuleFile = ProcessDuplicatedInf(ModuleFile, RecordList[0][2], GlobalData.gWorkspace)\n            ModuleFile.Arch = self._Arch\n            Module.Guid = RecordList[0][2]\n            for item in Module.StrPcdSet:\n                item[4] = RecordList[0][2]\n        self._Modules[ModuleFile] = Module\n    return self._Modules",
        "mutated": [
            "@property\ndef Modules(self):\n    if False:\n        i = 10\n    if self._Modules is not None:\n        return self._Modules\n    self.OverrideDuplicateModule()\n    self._Modules = OrderedDict()\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        ModuleId = Record[6]\n        LineNo = Record[7]\n        (ErrorCode, ErrorInfo) = ModuleFile.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n        ModuleBuildData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = ModuleFile\n        Module.Guid = ModuleBuildData.Guid\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, ModuleId]\n        for Record in RecordList:\n            LibraryClass = Record[0]\n            LibraryPath = PathClass(NormPath(Record[1], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = LibraryPath.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for %s\\n\\t%s [%s]' % (ModuleFile, LibraryPath, LibraryClass))\n            Module.LibraryClasses[LibraryClass] = LibraryPath\n            if LibraryPath not in self.LibraryInstances:\n                self.LibraryInstances.append(LibraryPath)\n        S_PcdSet = []\n        for Type in [MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE, MODEL_PCD_FEATURE_FLAG, MODEL_PCD_DYNAMIC, MODEL_PCD_DYNAMIC_EX]:\n            RecordList = self._RawData[Type, self._Arch, None, ModuleId]\n            for (TokenSpaceGuid, PcdCName, Setting, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                TokenList = GetSplitValueList(Setting)\n                DefaultValue = TokenList[0]\n                if len(TokenList) > 2:\n                    MaxDatumSize = TokenList[2]\n                else:\n                    MaxDatumSize = ''\n                TypeString = self._PCD_TYPE_STRING_[Type]\n                (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n                if '.' in TokenSpaceGuid or '[' in PcdCName:\n                    S_PcdSet.append([TCName, PCName, DimensionAttr, Field, ModuleBuildData.Guid, '', Dummy5, AnalyzePcdExpression(Setting)[0]])\n                    DefaultValue = ''\n                if (PCName, TCName) not in Module.Pcds:\n                    Pcd = PcdClassObject(PCName, TCName, TypeString, '', DefaultValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n                    Module.Pcds[PCName, TCName] = Pcd\n        Module.StrPcdSet = S_PcdSet\n        for (TCName, PCName, _, _, _, _, _, _) in S_PcdSet:\n            if (PCName, TCName) in Module.Pcds:\n                Module.StrPcdOverallValue[PCName, TCName] = (Module.Pcds[PCName, TCName].DefaultValue, self.MetaFile, Dummy5)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, None, ModuleId]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if (ToolChainFamily, ToolChain) not in Module.BuildOptions:\n                Module.BuildOptions[ToolChainFamily, ToolChain] = Option\n            else:\n                OptionString = Module.BuildOptions[ToolChainFamily, ToolChain]\n                Module.BuildOptions[ToolChainFamily, ToolChain] = OptionString + ' ' + Option\n        RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        if RecordList:\n            if len(RecordList) != 1:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Only FILE_GUID can be listed in <Defines> section.', File=self.MetaFile, ExtraData=str(ModuleFile), Line=LineNo)\n            ModuleFile = ProcessDuplicatedInf(ModuleFile, RecordList[0][2], GlobalData.gWorkspace)\n            ModuleFile.Arch = self._Arch\n            Module.Guid = RecordList[0][2]\n            for item in Module.StrPcdSet:\n                item[4] = RecordList[0][2]\n        self._Modules[ModuleFile] = Module\n    return self._Modules",
            "@property\ndef Modules(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._Modules is not None:\n        return self._Modules\n    self.OverrideDuplicateModule()\n    self._Modules = OrderedDict()\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        ModuleId = Record[6]\n        LineNo = Record[7]\n        (ErrorCode, ErrorInfo) = ModuleFile.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n        ModuleBuildData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = ModuleFile\n        Module.Guid = ModuleBuildData.Guid\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, ModuleId]\n        for Record in RecordList:\n            LibraryClass = Record[0]\n            LibraryPath = PathClass(NormPath(Record[1], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = LibraryPath.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for %s\\n\\t%s [%s]' % (ModuleFile, LibraryPath, LibraryClass))\n            Module.LibraryClasses[LibraryClass] = LibraryPath\n            if LibraryPath not in self.LibraryInstances:\n                self.LibraryInstances.append(LibraryPath)\n        S_PcdSet = []\n        for Type in [MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE, MODEL_PCD_FEATURE_FLAG, MODEL_PCD_DYNAMIC, MODEL_PCD_DYNAMIC_EX]:\n            RecordList = self._RawData[Type, self._Arch, None, ModuleId]\n            for (TokenSpaceGuid, PcdCName, Setting, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                TokenList = GetSplitValueList(Setting)\n                DefaultValue = TokenList[0]\n                if len(TokenList) > 2:\n                    MaxDatumSize = TokenList[2]\n                else:\n                    MaxDatumSize = ''\n                TypeString = self._PCD_TYPE_STRING_[Type]\n                (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n                if '.' in TokenSpaceGuid or '[' in PcdCName:\n                    S_PcdSet.append([TCName, PCName, DimensionAttr, Field, ModuleBuildData.Guid, '', Dummy5, AnalyzePcdExpression(Setting)[0]])\n                    DefaultValue = ''\n                if (PCName, TCName) not in Module.Pcds:\n                    Pcd = PcdClassObject(PCName, TCName, TypeString, '', DefaultValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n                    Module.Pcds[PCName, TCName] = Pcd\n        Module.StrPcdSet = S_PcdSet\n        for (TCName, PCName, _, _, _, _, _, _) in S_PcdSet:\n            if (PCName, TCName) in Module.Pcds:\n                Module.StrPcdOverallValue[PCName, TCName] = (Module.Pcds[PCName, TCName].DefaultValue, self.MetaFile, Dummy5)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, None, ModuleId]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if (ToolChainFamily, ToolChain) not in Module.BuildOptions:\n                Module.BuildOptions[ToolChainFamily, ToolChain] = Option\n            else:\n                OptionString = Module.BuildOptions[ToolChainFamily, ToolChain]\n                Module.BuildOptions[ToolChainFamily, ToolChain] = OptionString + ' ' + Option\n        RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        if RecordList:\n            if len(RecordList) != 1:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Only FILE_GUID can be listed in <Defines> section.', File=self.MetaFile, ExtraData=str(ModuleFile), Line=LineNo)\n            ModuleFile = ProcessDuplicatedInf(ModuleFile, RecordList[0][2], GlobalData.gWorkspace)\n            ModuleFile.Arch = self._Arch\n            Module.Guid = RecordList[0][2]\n            for item in Module.StrPcdSet:\n                item[4] = RecordList[0][2]\n        self._Modules[ModuleFile] = Module\n    return self._Modules",
            "@property\ndef Modules(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._Modules is not None:\n        return self._Modules\n    self.OverrideDuplicateModule()\n    self._Modules = OrderedDict()\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        ModuleId = Record[6]\n        LineNo = Record[7]\n        (ErrorCode, ErrorInfo) = ModuleFile.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n        ModuleBuildData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = ModuleFile\n        Module.Guid = ModuleBuildData.Guid\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, ModuleId]\n        for Record in RecordList:\n            LibraryClass = Record[0]\n            LibraryPath = PathClass(NormPath(Record[1], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = LibraryPath.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for %s\\n\\t%s [%s]' % (ModuleFile, LibraryPath, LibraryClass))\n            Module.LibraryClasses[LibraryClass] = LibraryPath\n            if LibraryPath not in self.LibraryInstances:\n                self.LibraryInstances.append(LibraryPath)\n        S_PcdSet = []\n        for Type in [MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE, MODEL_PCD_FEATURE_FLAG, MODEL_PCD_DYNAMIC, MODEL_PCD_DYNAMIC_EX]:\n            RecordList = self._RawData[Type, self._Arch, None, ModuleId]\n            for (TokenSpaceGuid, PcdCName, Setting, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                TokenList = GetSplitValueList(Setting)\n                DefaultValue = TokenList[0]\n                if len(TokenList) > 2:\n                    MaxDatumSize = TokenList[2]\n                else:\n                    MaxDatumSize = ''\n                TypeString = self._PCD_TYPE_STRING_[Type]\n                (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n                if '.' in TokenSpaceGuid or '[' in PcdCName:\n                    S_PcdSet.append([TCName, PCName, DimensionAttr, Field, ModuleBuildData.Guid, '', Dummy5, AnalyzePcdExpression(Setting)[0]])\n                    DefaultValue = ''\n                if (PCName, TCName) not in Module.Pcds:\n                    Pcd = PcdClassObject(PCName, TCName, TypeString, '', DefaultValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n                    Module.Pcds[PCName, TCName] = Pcd\n        Module.StrPcdSet = S_PcdSet\n        for (TCName, PCName, _, _, _, _, _, _) in S_PcdSet:\n            if (PCName, TCName) in Module.Pcds:\n                Module.StrPcdOverallValue[PCName, TCName] = (Module.Pcds[PCName, TCName].DefaultValue, self.MetaFile, Dummy5)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, None, ModuleId]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if (ToolChainFamily, ToolChain) not in Module.BuildOptions:\n                Module.BuildOptions[ToolChainFamily, ToolChain] = Option\n            else:\n                OptionString = Module.BuildOptions[ToolChainFamily, ToolChain]\n                Module.BuildOptions[ToolChainFamily, ToolChain] = OptionString + ' ' + Option\n        RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        if RecordList:\n            if len(RecordList) != 1:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Only FILE_GUID can be listed in <Defines> section.', File=self.MetaFile, ExtraData=str(ModuleFile), Line=LineNo)\n            ModuleFile = ProcessDuplicatedInf(ModuleFile, RecordList[0][2], GlobalData.gWorkspace)\n            ModuleFile.Arch = self._Arch\n            Module.Guid = RecordList[0][2]\n            for item in Module.StrPcdSet:\n                item[4] = RecordList[0][2]\n        self._Modules[ModuleFile] = Module\n    return self._Modules",
            "@property\ndef Modules(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._Modules is not None:\n        return self._Modules\n    self.OverrideDuplicateModule()\n    self._Modules = OrderedDict()\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        ModuleId = Record[6]\n        LineNo = Record[7]\n        (ErrorCode, ErrorInfo) = ModuleFile.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n        ModuleBuildData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = ModuleFile\n        Module.Guid = ModuleBuildData.Guid\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, ModuleId]\n        for Record in RecordList:\n            LibraryClass = Record[0]\n            LibraryPath = PathClass(NormPath(Record[1], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = LibraryPath.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for %s\\n\\t%s [%s]' % (ModuleFile, LibraryPath, LibraryClass))\n            Module.LibraryClasses[LibraryClass] = LibraryPath\n            if LibraryPath not in self.LibraryInstances:\n                self.LibraryInstances.append(LibraryPath)\n        S_PcdSet = []\n        for Type in [MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE, MODEL_PCD_FEATURE_FLAG, MODEL_PCD_DYNAMIC, MODEL_PCD_DYNAMIC_EX]:\n            RecordList = self._RawData[Type, self._Arch, None, ModuleId]\n            for (TokenSpaceGuid, PcdCName, Setting, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                TokenList = GetSplitValueList(Setting)\n                DefaultValue = TokenList[0]\n                if len(TokenList) > 2:\n                    MaxDatumSize = TokenList[2]\n                else:\n                    MaxDatumSize = ''\n                TypeString = self._PCD_TYPE_STRING_[Type]\n                (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n                if '.' in TokenSpaceGuid or '[' in PcdCName:\n                    S_PcdSet.append([TCName, PCName, DimensionAttr, Field, ModuleBuildData.Guid, '', Dummy5, AnalyzePcdExpression(Setting)[0]])\n                    DefaultValue = ''\n                if (PCName, TCName) not in Module.Pcds:\n                    Pcd = PcdClassObject(PCName, TCName, TypeString, '', DefaultValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n                    Module.Pcds[PCName, TCName] = Pcd\n        Module.StrPcdSet = S_PcdSet\n        for (TCName, PCName, _, _, _, _, _, _) in S_PcdSet:\n            if (PCName, TCName) in Module.Pcds:\n                Module.StrPcdOverallValue[PCName, TCName] = (Module.Pcds[PCName, TCName].DefaultValue, self.MetaFile, Dummy5)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, None, ModuleId]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if (ToolChainFamily, ToolChain) not in Module.BuildOptions:\n                Module.BuildOptions[ToolChainFamily, ToolChain] = Option\n            else:\n                OptionString = Module.BuildOptions[ToolChainFamily, ToolChain]\n                Module.BuildOptions[ToolChainFamily, ToolChain] = OptionString + ' ' + Option\n        RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        if RecordList:\n            if len(RecordList) != 1:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Only FILE_GUID can be listed in <Defines> section.', File=self.MetaFile, ExtraData=str(ModuleFile), Line=LineNo)\n            ModuleFile = ProcessDuplicatedInf(ModuleFile, RecordList[0][2], GlobalData.gWorkspace)\n            ModuleFile.Arch = self._Arch\n            Module.Guid = RecordList[0][2]\n            for item in Module.StrPcdSet:\n                item[4] = RecordList[0][2]\n        self._Modules[ModuleFile] = Module\n    return self._Modules",
            "@property\ndef Modules(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._Modules is not None:\n        return self._Modules\n    self.OverrideDuplicateModule()\n    self._Modules = OrderedDict()\n    RecordList = self._RawData[MODEL_META_DATA_COMPONENT, self._Arch]\n    Macros = self._Macros\n    for Record in RecordList:\n        ModuleFile = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n        ModuleId = Record[6]\n        LineNo = Record[7]\n        (ErrorCode, ErrorInfo) = ModuleFile.Validate('.inf')\n        if ErrorCode != 0:\n            EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n        ModuleBuildData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = ModuleFile\n        Module.Guid = ModuleBuildData.Guid\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, ModuleId]\n        for Record in RecordList:\n            LibraryClass = Record[0]\n            LibraryPath = PathClass(NormPath(Record[1], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = LibraryPath.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for %s\\n\\t%s [%s]' % (ModuleFile, LibraryPath, LibraryClass))\n            Module.LibraryClasses[LibraryClass] = LibraryPath\n            if LibraryPath not in self.LibraryInstances:\n                self.LibraryInstances.append(LibraryPath)\n        S_PcdSet = []\n        for Type in [MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE, MODEL_PCD_FEATURE_FLAG, MODEL_PCD_DYNAMIC, MODEL_PCD_DYNAMIC_EX]:\n            RecordList = self._RawData[Type, self._Arch, None, ModuleId]\n            for (TokenSpaceGuid, PcdCName, Setting, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                TokenList = GetSplitValueList(Setting)\n                DefaultValue = TokenList[0]\n                if len(TokenList) > 2:\n                    MaxDatumSize = TokenList[2]\n                else:\n                    MaxDatumSize = ''\n                TypeString = self._PCD_TYPE_STRING_[Type]\n                (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n                if '.' in TokenSpaceGuid or '[' in PcdCName:\n                    S_PcdSet.append([TCName, PCName, DimensionAttr, Field, ModuleBuildData.Guid, '', Dummy5, AnalyzePcdExpression(Setting)[0]])\n                    DefaultValue = ''\n                if (PCName, TCName) not in Module.Pcds:\n                    Pcd = PcdClassObject(PCName, TCName, TypeString, '', DefaultValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n                    Module.Pcds[PCName, TCName] = Pcd\n        Module.StrPcdSet = S_PcdSet\n        for (TCName, PCName, _, _, _, _, _, _) in S_PcdSet:\n            if (PCName, TCName) in Module.Pcds:\n                Module.StrPcdOverallValue[PCName, TCName] = (Module.Pcds[PCName, TCName].DefaultValue, self.MetaFile, Dummy5)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, None, ModuleId]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if (ToolChainFamily, ToolChain) not in Module.BuildOptions:\n                Module.BuildOptions[ToolChainFamily, ToolChain] = Option\n            else:\n                OptionString = Module.BuildOptions[ToolChainFamily, ToolChain]\n                Module.BuildOptions[ToolChainFamily, ToolChain] = OptionString + ' ' + Option\n        RecordList = self._RawData[MODEL_META_DATA_HEADER, self._Arch, None, ModuleId]\n        if RecordList:\n            if len(RecordList) != 1:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Only FILE_GUID can be listed in <Defines> section.', File=self.MetaFile, ExtraData=str(ModuleFile), Line=LineNo)\n            ModuleFile = ProcessDuplicatedInf(ModuleFile, RecordList[0][2], GlobalData.gWorkspace)\n            ModuleFile.Arch = self._Arch\n            Module.Guid = RecordList[0][2]\n            for item in Module.StrPcdSet:\n                item[4] = RecordList[0][2]\n        self._Modules[ModuleFile] = Module\n    return self._Modules"
        ]
    },
    {
        "func_name": "LibraryInstances",
        "original": "@property\ndef LibraryInstances(self):\n    if self._LibraryInstances is None:\n        self.LibraryClasses\n    return self._LibraryInstances",
        "mutated": [
            "@property\ndef LibraryInstances(self):\n    if False:\n        i = 10\n    if self._LibraryInstances is None:\n        self.LibraryClasses\n    return self._LibraryInstances",
            "@property\ndef LibraryInstances(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._LibraryInstances is None:\n        self.LibraryClasses\n    return self._LibraryInstances",
            "@property\ndef LibraryInstances(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._LibraryInstances is None:\n        self.LibraryClasses\n    return self._LibraryInstances",
            "@property\ndef LibraryInstances(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._LibraryInstances is None:\n        self.LibraryClasses\n    return self._LibraryInstances",
            "@property\ndef LibraryInstances(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._LibraryInstances is None:\n        self.LibraryClasses\n    return self._LibraryInstances"
        ]
    },
    {
        "func_name": "LibraryClasses",
        "original": "@property\ndef LibraryClasses(self):\n    if self._LibraryClasses is None:\n        self._LibraryInstances = []\n        LibraryClassDict = tdict(True, 3)\n        LibraryClassSet = set()\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, -1]\n        Macros = self._Macros\n        for Record in RecordList:\n            (LibraryClass, LibraryInstance, Dummy, Arch, ModuleType, Dummy, Dummy, LineNo) = Record\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for arch=%s\\n\\t%s [%s]' % (Arch, LibraryInstance, LibraryClass))\n            LibraryClassSet.add(LibraryClass)\n            LibraryInstance = PathClass(NormPath(LibraryInstance, Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            (ErrorCode, ErrorInfo) = LibraryInstance.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if ModuleType != TAB_COMMON and ModuleType not in SUP_MODULE_LIST:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Unknown module type [%s]' % ModuleType, File=self.MetaFile, ExtraData=LibraryInstance, Line=LineNo)\n            LibraryClassDict[Arch, ModuleType, LibraryClass] = LibraryInstance\n            if LibraryInstance not in self._LibraryInstances:\n                self._LibraryInstances.append(LibraryInstance)\n        self._LibraryClasses = tdict(True)\n        for LibraryClass in LibraryClassSet:\n            for ModuleType in SUP_MODULE_LIST:\n                LibraryInstance = LibraryClassDict[self._Arch, ModuleType, LibraryClass]\n                if LibraryInstance is None:\n                    continue\n                self._LibraryClasses[LibraryClass, ModuleType] = LibraryInstance\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_INSTANCE, self._Arch]\n        for Record in RecordList:\n            File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = File.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if File not in self._LibraryInstances:\n                self._LibraryInstances.append(File)\n            Library = self._Bdb[File, self._Arch, self._Target, self._Toolchain]\n            self._LibraryClasses[Library.BaseName, ':dummy:'] = Library\n    return self._LibraryClasses",
        "mutated": [
            "@property\ndef LibraryClasses(self):\n    if False:\n        i = 10\n    if self._LibraryClasses is None:\n        self._LibraryInstances = []\n        LibraryClassDict = tdict(True, 3)\n        LibraryClassSet = set()\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, -1]\n        Macros = self._Macros\n        for Record in RecordList:\n            (LibraryClass, LibraryInstance, Dummy, Arch, ModuleType, Dummy, Dummy, LineNo) = Record\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for arch=%s\\n\\t%s [%s]' % (Arch, LibraryInstance, LibraryClass))\n            LibraryClassSet.add(LibraryClass)\n            LibraryInstance = PathClass(NormPath(LibraryInstance, Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            (ErrorCode, ErrorInfo) = LibraryInstance.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if ModuleType != TAB_COMMON and ModuleType not in SUP_MODULE_LIST:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Unknown module type [%s]' % ModuleType, File=self.MetaFile, ExtraData=LibraryInstance, Line=LineNo)\n            LibraryClassDict[Arch, ModuleType, LibraryClass] = LibraryInstance\n            if LibraryInstance not in self._LibraryInstances:\n                self._LibraryInstances.append(LibraryInstance)\n        self._LibraryClasses = tdict(True)\n        for LibraryClass in LibraryClassSet:\n            for ModuleType in SUP_MODULE_LIST:\n                LibraryInstance = LibraryClassDict[self._Arch, ModuleType, LibraryClass]\n                if LibraryInstance is None:\n                    continue\n                self._LibraryClasses[LibraryClass, ModuleType] = LibraryInstance\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_INSTANCE, self._Arch]\n        for Record in RecordList:\n            File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = File.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if File not in self._LibraryInstances:\n                self._LibraryInstances.append(File)\n            Library = self._Bdb[File, self._Arch, self._Target, self._Toolchain]\n            self._LibraryClasses[Library.BaseName, ':dummy:'] = Library\n    return self._LibraryClasses",
            "@property\ndef LibraryClasses(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._LibraryClasses is None:\n        self._LibraryInstances = []\n        LibraryClassDict = tdict(True, 3)\n        LibraryClassSet = set()\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, -1]\n        Macros = self._Macros\n        for Record in RecordList:\n            (LibraryClass, LibraryInstance, Dummy, Arch, ModuleType, Dummy, Dummy, LineNo) = Record\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for arch=%s\\n\\t%s [%s]' % (Arch, LibraryInstance, LibraryClass))\n            LibraryClassSet.add(LibraryClass)\n            LibraryInstance = PathClass(NormPath(LibraryInstance, Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            (ErrorCode, ErrorInfo) = LibraryInstance.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if ModuleType != TAB_COMMON and ModuleType not in SUP_MODULE_LIST:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Unknown module type [%s]' % ModuleType, File=self.MetaFile, ExtraData=LibraryInstance, Line=LineNo)\n            LibraryClassDict[Arch, ModuleType, LibraryClass] = LibraryInstance\n            if LibraryInstance not in self._LibraryInstances:\n                self._LibraryInstances.append(LibraryInstance)\n        self._LibraryClasses = tdict(True)\n        for LibraryClass in LibraryClassSet:\n            for ModuleType in SUP_MODULE_LIST:\n                LibraryInstance = LibraryClassDict[self._Arch, ModuleType, LibraryClass]\n                if LibraryInstance is None:\n                    continue\n                self._LibraryClasses[LibraryClass, ModuleType] = LibraryInstance\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_INSTANCE, self._Arch]\n        for Record in RecordList:\n            File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = File.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if File not in self._LibraryInstances:\n                self._LibraryInstances.append(File)\n            Library = self._Bdb[File, self._Arch, self._Target, self._Toolchain]\n            self._LibraryClasses[Library.BaseName, ':dummy:'] = Library\n    return self._LibraryClasses",
            "@property\ndef LibraryClasses(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._LibraryClasses is None:\n        self._LibraryInstances = []\n        LibraryClassDict = tdict(True, 3)\n        LibraryClassSet = set()\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, -1]\n        Macros = self._Macros\n        for Record in RecordList:\n            (LibraryClass, LibraryInstance, Dummy, Arch, ModuleType, Dummy, Dummy, LineNo) = Record\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for arch=%s\\n\\t%s [%s]' % (Arch, LibraryInstance, LibraryClass))\n            LibraryClassSet.add(LibraryClass)\n            LibraryInstance = PathClass(NormPath(LibraryInstance, Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            (ErrorCode, ErrorInfo) = LibraryInstance.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if ModuleType != TAB_COMMON and ModuleType not in SUP_MODULE_LIST:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Unknown module type [%s]' % ModuleType, File=self.MetaFile, ExtraData=LibraryInstance, Line=LineNo)\n            LibraryClassDict[Arch, ModuleType, LibraryClass] = LibraryInstance\n            if LibraryInstance not in self._LibraryInstances:\n                self._LibraryInstances.append(LibraryInstance)\n        self._LibraryClasses = tdict(True)\n        for LibraryClass in LibraryClassSet:\n            for ModuleType in SUP_MODULE_LIST:\n                LibraryInstance = LibraryClassDict[self._Arch, ModuleType, LibraryClass]\n                if LibraryInstance is None:\n                    continue\n                self._LibraryClasses[LibraryClass, ModuleType] = LibraryInstance\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_INSTANCE, self._Arch]\n        for Record in RecordList:\n            File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = File.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if File not in self._LibraryInstances:\n                self._LibraryInstances.append(File)\n            Library = self._Bdb[File, self._Arch, self._Target, self._Toolchain]\n            self._LibraryClasses[Library.BaseName, ':dummy:'] = Library\n    return self._LibraryClasses",
            "@property\ndef LibraryClasses(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._LibraryClasses is None:\n        self._LibraryInstances = []\n        LibraryClassDict = tdict(True, 3)\n        LibraryClassSet = set()\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, -1]\n        Macros = self._Macros\n        for Record in RecordList:\n            (LibraryClass, LibraryInstance, Dummy, Arch, ModuleType, Dummy, Dummy, LineNo) = Record\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for arch=%s\\n\\t%s [%s]' % (Arch, LibraryInstance, LibraryClass))\n            LibraryClassSet.add(LibraryClass)\n            LibraryInstance = PathClass(NormPath(LibraryInstance, Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            (ErrorCode, ErrorInfo) = LibraryInstance.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if ModuleType != TAB_COMMON and ModuleType not in SUP_MODULE_LIST:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Unknown module type [%s]' % ModuleType, File=self.MetaFile, ExtraData=LibraryInstance, Line=LineNo)\n            LibraryClassDict[Arch, ModuleType, LibraryClass] = LibraryInstance\n            if LibraryInstance not in self._LibraryInstances:\n                self._LibraryInstances.append(LibraryInstance)\n        self._LibraryClasses = tdict(True)\n        for LibraryClass in LibraryClassSet:\n            for ModuleType in SUP_MODULE_LIST:\n                LibraryInstance = LibraryClassDict[self._Arch, ModuleType, LibraryClass]\n                if LibraryInstance is None:\n                    continue\n                self._LibraryClasses[LibraryClass, ModuleType] = LibraryInstance\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_INSTANCE, self._Arch]\n        for Record in RecordList:\n            File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = File.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if File not in self._LibraryInstances:\n                self._LibraryInstances.append(File)\n            Library = self._Bdb[File, self._Arch, self._Target, self._Toolchain]\n            self._LibraryClasses[Library.BaseName, ':dummy:'] = Library\n    return self._LibraryClasses",
            "@property\ndef LibraryClasses(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._LibraryClasses is None:\n        self._LibraryInstances = []\n        LibraryClassDict = tdict(True, 3)\n        LibraryClassSet = set()\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_CLASS, self._Arch, None, -1]\n        Macros = self._Macros\n        for Record in RecordList:\n            (LibraryClass, LibraryInstance, Dummy, Arch, ModuleType, Dummy, Dummy, LineNo) = Record\n            if LibraryClass == '' or LibraryClass == 'NULL':\n                self._NullLibraryNumber += 1\n                LibraryClass = 'NULL%d' % self._NullLibraryNumber\n                EdkLogger.verbose('Found forced library for arch=%s\\n\\t%s [%s]' % (Arch, LibraryInstance, LibraryClass))\n            LibraryClassSet.add(LibraryClass)\n            LibraryInstance = PathClass(NormPath(LibraryInstance, Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            (ErrorCode, ErrorInfo) = LibraryInstance.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if ModuleType != TAB_COMMON and ModuleType not in SUP_MODULE_LIST:\n                EdkLogger.error('build', OPTION_UNKNOWN, 'Unknown module type [%s]' % ModuleType, File=self.MetaFile, ExtraData=LibraryInstance, Line=LineNo)\n            LibraryClassDict[Arch, ModuleType, LibraryClass] = LibraryInstance\n            if LibraryInstance not in self._LibraryInstances:\n                self._LibraryInstances.append(LibraryInstance)\n        self._LibraryClasses = tdict(True)\n        for LibraryClass in LibraryClassSet:\n            for ModuleType in SUP_MODULE_LIST:\n                LibraryInstance = LibraryClassDict[self._Arch, ModuleType, LibraryClass]\n                if LibraryInstance is None:\n                    continue\n                self._LibraryClasses[LibraryClass, ModuleType] = LibraryInstance\n        RecordList = self._RawData[MODEL_EFI_LIBRARY_INSTANCE, self._Arch]\n        for Record in RecordList:\n            File = PathClass(NormPath(Record[0], Macros), GlobalData.gWorkspace, Arch=self._Arch)\n            LineNo = Record[-1]\n            (ErrorCode, ErrorInfo) = File.Validate('.inf')\n            if ErrorCode != 0:\n                EdkLogger.error('build', ErrorCode, File=self.MetaFile, Line=LineNo, ExtraData=ErrorInfo)\n            if File not in self._LibraryInstances:\n                self._LibraryInstances.append(File)\n            Library = self._Bdb[File, self._Arch, self._Target, self._Toolchain]\n            self._LibraryClasses[Library.BaseName, ':dummy:'] = Library\n    return self._LibraryClasses"
        ]
    },
    {
        "func_name": "_ValidatePcd",
        "original": "def _ValidatePcd(self, PcdCName, TokenSpaceGuid, Setting, PcdType, LineNo):\n    if not self._DecPcds:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    if (PcdCName, TokenSpaceGuid) not in self._DecPcds:\n        EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files referenced in INF files in FDF. Arch: ['%s']\" % (TokenSpaceGuid, PcdCName, self._Arch), File=self.MetaFile, Line=LineNo)\n    (ValueList, IsValid, Index) = AnalyzeDscPcd(Setting, PcdType, self._DecPcds[PcdCName, TokenSpaceGuid].DatumType)\n    if not IsValid:\n        if PcdType not in [MODEL_PCD_FEATURE_FLAG, MODEL_PCD_FIXED_AT_BUILD]:\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n        elif ValueList[2] == '-1':\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n    if ValueList[Index]:\n        DatumType = self._DecPcds[PcdCName, TokenSpaceGuid].DatumType\n        if '{CODE(' not in ValueList[Index]:\n            try:\n                ValueList[Index] = ValueExpressionEx(ValueList[Index], DatumType, self._GuidDict)(True)\n            except BadExpression as Value:\n                EdkLogger.error('Parser', FORMAT_INVALID, Value, File=self.MetaFile, Line=LineNo, ExtraData='PCD [%s.%s] Value \"%s\" ' % (TokenSpaceGuid, PcdCName, ValueList[Index]))\n            except EvaluationException as Excpt:\n                if hasattr(Excpt, 'Pcd'):\n                    if Excpt.Pcd in GlobalData.gPlatformOtherPcds:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'Cannot use this PCD (%s) in an expression as it must be defined in a [PcdsFixedAtBuild] or [PcdsFeatureFlag] section of the DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                    else:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'PCD (%s) is not defined in DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                else:\n                    EdkLogger.error('Parser', FORMAT_INVALID, 'Invalid expression: %s' % str(Excpt), File=self.MetaFile, Line=LineNo)\n    if ValueList[Index]:\n        (Valid, ErrStr) = CheckPcdDatum(self._DecPcds[PcdCName, TokenSpaceGuid].DatumType, ValueList[Index])\n        if not Valid:\n            EdkLogger.error('build', FORMAT_INVALID, ErrStr, File=self.MetaFile, Line=LineNo, ExtraData='%s.%s' % (TokenSpaceGuid, PcdCName))\n        if PcdType in (MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE):\n            if self._DecPcds[PcdCName, TokenSpaceGuid].DatumType.strip() != ValueList[1].strip():\n                DecPcd = self._DecPcds[PcdCName, TokenSpaceGuid]\n                EdkLogger.error('build', FORMAT_INVALID, 'Pcd datumtype used in DSC file is not the same as its declaration. DatumType:%s' % DecPcd.DatumType, File=self.MetaFile, Line=LineNo, ExtraData='Dsc:%s.%s|%s\\n    Dec:%s.%s|%s|%s|%s' % (TokenSpaceGuid, PcdCName, Setting, TokenSpaceGuid, PcdCName, DecPcd.DefaultValue, DecPcd.DatumType, DecPcd.TokenValue))\n    if TokenSpaceGuid + '.' + PcdCName in GlobalData.gPlatformPcds:\n        if GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] != ValueList[Index]:\n            GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n        GlobalData.gPlatformFinalPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n    return ValueList",
        "mutated": [
            "def _ValidatePcd(self, PcdCName, TokenSpaceGuid, Setting, PcdType, LineNo):\n    if False:\n        i = 10\n    if not self._DecPcds:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    if (PcdCName, TokenSpaceGuid) not in self._DecPcds:\n        EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files referenced in INF files in FDF. Arch: ['%s']\" % (TokenSpaceGuid, PcdCName, self._Arch), File=self.MetaFile, Line=LineNo)\n    (ValueList, IsValid, Index) = AnalyzeDscPcd(Setting, PcdType, self._DecPcds[PcdCName, TokenSpaceGuid].DatumType)\n    if not IsValid:\n        if PcdType not in [MODEL_PCD_FEATURE_FLAG, MODEL_PCD_FIXED_AT_BUILD]:\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n        elif ValueList[2] == '-1':\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n    if ValueList[Index]:\n        DatumType = self._DecPcds[PcdCName, TokenSpaceGuid].DatumType\n        if '{CODE(' not in ValueList[Index]:\n            try:\n                ValueList[Index] = ValueExpressionEx(ValueList[Index], DatumType, self._GuidDict)(True)\n            except BadExpression as Value:\n                EdkLogger.error('Parser', FORMAT_INVALID, Value, File=self.MetaFile, Line=LineNo, ExtraData='PCD [%s.%s] Value \"%s\" ' % (TokenSpaceGuid, PcdCName, ValueList[Index]))\n            except EvaluationException as Excpt:\n                if hasattr(Excpt, 'Pcd'):\n                    if Excpt.Pcd in GlobalData.gPlatformOtherPcds:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'Cannot use this PCD (%s) in an expression as it must be defined in a [PcdsFixedAtBuild] or [PcdsFeatureFlag] section of the DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                    else:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'PCD (%s) is not defined in DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                else:\n                    EdkLogger.error('Parser', FORMAT_INVALID, 'Invalid expression: %s' % str(Excpt), File=self.MetaFile, Line=LineNo)\n    if ValueList[Index]:\n        (Valid, ErrStr) = CheckPcdDatum(self._DecPcds[PcdCName, TokenSpaceGuid].DatumType, ValueList[Index])\n        if not Valid:\n            EdkLogger.error('build', FORMAT_INVALID, ErrStr, File=self.MetaFile, Line=LineNo, ExtraData='%s.%s' % (TokenSpaceGuid, PcdCName))\n        if PcdType in (MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE):\n            if self._DecPcds[PcdCName, TokenSpaceGuid].DatumType.strip() != ValueList[1].strip():\n                DecPcd = self._DecPcds[PcdCName, TokenSpaceGuid]\n                EdkLogger.error('build', FORMAT_INVALID, 'Pcd datumtype used in DSC file is not the same as its declaration. DatumType:%s' % DecPcd.DatumType, File=self.MetaFile, Line=LineNo, ExtraData='Dsc:%s.%s|%s\\n    Dec:%s.%s|%s|%s|%s' % (TokenSpaceGuid, PcdCName, Setting, TokenSpaceGuid, PcdCName, DecPcd.DefaultValue, DecPcd.DatumType, DecPcd.TokenValue))\n    if TokenSpaceGuid + '.' + PcdCName in GlobalData.gPlatformPcds:\n        if GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] != ValueList[Index]:\n            GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n        GlobalData.gPlatformFinalPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n    return ValueList",
            "def _ValidatePcd(self, PcdCName, TokenSpaceGuid, Setting, PcdType, LineNo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not self._DecPcds:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    if (PcdCName, TokenSpaceGuid) not in self._DecPcds:\n        EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files referenced in INF files in FDF. Arch: ['%s']\" % (TokenSpaceGuid, PcdCName, self._Arch), File=self.MetaFile, Line=LineNo)\n    (ValueList, IsValid, Index) = AnalyzeDscPcd(Setting, PcdType, self._DecPcds[PcdCName, TokenSpaceGuid].DatumType)\n    if not IsValid:\n        if PcdType not in [MODEL_PCD_FEATURE_FLAG, MODEL_PCD_FIXED_AT_BUILD]:\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n        elif ValueList[2] == '-1':\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n    if ValueList[Index]:\n        DatumType = self._DecPcds[PcdCName, TokenSpaceGuid].DatumType\n        if '{CODE(' not in ValueList[Index]:\n            try:\n                ValueList[Index] = ValueExpressionEx(ValueList[Index], DatumType, self._GuidDict)(True)\n            except BadExpression as Value:\n                EdkLogger.error('Parser', FORMAT_INVALID, Value, File=self.MetaFile, Line=LineNo, ExtraData='PCD [%s.%s] Value \"%s\" ' % (TokenSpaceGuid, PcdCName, ValueList[Index]))\n            except EvaluationException as Excpt:\n                if hasattr(Excpt, 'Pcd'):\n                    if Excpt.Pcd in GlobalData.gPlatformOtherPcds:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'Cannot use this PCD (%s) in an expression as it must be defined in a [PcdsFixedAtBuild] or [PcdsFeatureFlag] section of the DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                    else:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'PCD (%s) is not defined in DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                else:\n                    EdkLogger.error('Parser', FORMAT_INVALID, 'Invalid expression: %s' % str(Excpt), File=self.MetaFile, Line=LineNo)\n    if ValueList[Index]:\n        (Valid, ErrStr) = CheckPcdDatum(self._DecPcds[PcdCName, TokenSpaceGuid].DatumType, ValueList[Index])\n        if not Valid:\n            EdkLogger.error('build', FORMAT_INVALID, ErrStr, File=self.MetaFile, Line=LineNo, ExtraData='%s.%s' % (TokenSpaceGuid, PcdCName))\n        if PcdType in (MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE):\n            if self._DecPcds[PcdCName, TokenSpaceGuid].DatumType.strip() != ValueList[1].strip():\n                DecPcd = self._DecPcds[PcdCName, TokenSpaceGuid]\n                EdkLogger.error('build', FORMAT_INVALID, 'Pcd datumtype used in DSC file is not the same as its declaration. DatumType:%s' % DecPcd.DatumType, File=self.MetaFile, Line=LineNo, ExtraData='Dsc:%s.%s|%s\\n    Dec:%s.%s|%s|%s|%s' % (TokenSpaceGuid, PcdCName, Setting, TokenSpaceGuid, PcdCName, DecPcd.DefaultValue, DecPcd.DatumType, DecPcd.TokenValue))\n    if TokenSpaceGuid + '.' + PcdCName in GlobalData.gPlatformPcds:\n        if GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] != ValueList[Index]:\n            GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n        GlobalData.gPlatformFinalPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n    return ValueList",
            "def _ValidatePcd(self, PcdCName, TokenSpaceGuid, Setting, PcdType, LineNo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not self._DecPcds:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    if (PcdCName, TokenSpaceGuid) not in self._DecPcds:\n        EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files referenced in INF files in FDF. Arch: ['%s']\" % (TokenSpaceGuid, PcdCName, self._Arch), File=self.MetaFile, Line=LineNo)\n    (ValueList, IsValid, Index) = AnalyzeDscPcd(Setting, PcdType, self._DecPcds[PcdCName, TokenSpaceGuid].DatumType)\n    if not IsValid:\n        if PcdType not in [MODEL_PCD_FEATURE_FLAG, MODEL_PCD_FIXED_AT_BUILD]:\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n        elif ValueList[2] == '-1':\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n    if ValueList[Index]:\n        DatumType = self._DecPcds[PcdCName, TokenSpaceGuid].DatumType\n        if '{CODE(' not in ValueList[Index]:\n            try:\n                ValueList[Index] = ValueExpressionEx(ValueList[Index], DatumType, self._GuidDict)(True)\n            except BadExpression as Value:\n                EdkLogger.error('Parser', FORMAT_INVALID, Value, File=self.MetaFile, Line=LineNo, ExtraData='PCD [%s.%s] Value \"%s\" ' % (TokenSpaceGuid, PcdCName, ValueList[Index]))\n            except EvaluationException as Excpt:\n                if hasattr(Excpt, 'Pcd'):\n                    if Excpt.Pcd in GlobalData.gPlatformOtherPcds:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'Cannot use this PCD (%s) in an expression as it must be defined in a [PcdsFixedAtBuild] or [PcdsFeatureFlag] section of the DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                    else:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'PCD (%s) is not defined in DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                else:\n                    EdkLogger.error('Parser', FORMAT_INVALID, 'Invalid expression: %s' % str(Excpt), File=self.MetaFile, Line=LineNo)\n    if ValueList[Index]:\n        (Valid, ErrStr) = CheckPcdDatum(self._DecPcds[PcdCName, TokenSpaceGuid].DatumType, ValueList[Index])\n        if not Valid:\n            EdkLogger.error('build', FORMAT_INVALID, ErrStr, File=self.MetaFile, Line=LineNo, ExtraData='%s.%s' % (TokenSpaceGuid, PcdCName))\n        if PcdType in (MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE):\n            if self._DecPcds[PcdCName, TokenSpaceGuid].DatumType.strip() != ValueList[1].strip():\n                DecPcd = self._DecPcds[PcdCName, TokenSpaceGuid]\n                EdkLogger.error('build', FORMAT_INVALID, 'Pcd datumtype used in DSC file is not the same as its declaration. DatumType:%s' % DecPcd.DatumType, File=self.MetaFile, Line=LineNo, ExtraData='Dsc:%s.%s|%s\\n    Dec:%s.%s|%s|%s|%s' % (TokenSpaceGuid, PcdCName, Setting, TokenSpaceGuid, PcdCName, DecPcd.DefaultValue, DecPcd.DatumType, DecPcd.TokenValue))\n    if TokenSpaceGuid + '.' + PcdCName in GlobalData.gPlatformPcds:\n        if GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] != ValueList[Index]:\n            GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n        GlobalData.gPlatformFinalPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n    return ValueList",
            "def _ValidatePcd(self, PcdCName, TokenSpaceGuid, Setting, PcdType, LineNo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not self._DecPcds:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    if (PcdCName, TokenSpaceGuid) not in self._DecPcds:\n        EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files referenced in INF files in FDF. Arch: ['%s']\" % (TokenSpaceGuid, PcdCName, self._Arch), File=self.MetaFile, Line=LineNo)\n    (ValueList, IsValid, Index) = AnalyzeDscPcd(Setting, PcdType, self._DecPcds[PcdCName, TokenSpaceGuid].DatumType)\n    if not IsValid:\n        if PcdType not in [MODEL_PCD_FEATURE_FLAG, MODEL_PCD_FIXED_AT_BUILD]:\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n        elif ValueList[2] == '-1':\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n    if ValueList[Index]:\n        DatumType = self._DecPcds[PcdCName, TokenSpaceGuid].DatumType\n        if '{CODE(' not in ValueList[Index]:\n            try:\n                ValueList[Index] = ValueExpressionEx(ValueList[Index], DatumType, self._GuidDict)(True)\n            except BadExpression as Value:\n                EdkLogger.error('Parser', FORMAT_INVALID, Value, File=self.MetaFile, Line=LineNo, ExtraData='PCD [%s.%s] Value \"%s\" ' % (TokenSpaceGuid, PcdCName, ValueList[Index]))\n            except EvaluationException as Excpt:\n                if hasattr(Excpt, 'Pcd'):\n                    if Excpt.Pcd in GlobalData.gPlatformOtherPcds:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'Cannot use this PCD (%s) in an expression as it must be defined in a [PcdsFixedAtBuild] or [PcdsFeatureFlag] section of the DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                    else:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'PCD (%s) is not defined in DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                else:\n                    EdkLogger.error('Parser', FORMAT_INVALID, 'Invalid expression: %s' % str(Excpt), File=self.MetaFile, Line=LineNo)\n    if ValueList[Index]:\n        (Valid, ErrStr) = CheckPcdDatum(self._DecPcds[PcdCName, TokenSpaceGuid].DatumType, ValueList[Index])\n        if not Valid:\n            EdkLogger.error('build', FORMAT_INVALID, ErrStr, File=self.MetaFile, Line=LineNo, ExtraData='%s.%s' % (TokenSpaceGuid, PcdCName))\n        if PcdType in (MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE):\n            if self._DecPcds[PcdCName, TokenSpaceGuid].DatumType.strip() != ValueList[1].strip():\n                DecPcd = self._DecPcds[PcdCName, TokenSpaceGuid]\n                EdkLogger.error('build', FORMAT_INVALID, 'Pcd datumtype used in DSC file is not the same as its declaration. DatumType:%s' % DecPcd.DatumType, File=self.MetaFile, Line=LineNo, ExtraData='Dsc:%s.%s|%s\\n    Dec:%s.%s|%s|%s|%s' % (TokenSpaceGuid, PcdCName, Setting, TokenSpaceGuid, PcdCName, DecPcd.DefaultValue, DecPcd.DatumType, DecPcd.TokenValue))\n    if TokenSpaceGuid + '.' + PcdCName in GlobalData.gPlatformPcds:\n        if GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] != ValueList[Index]:\n            GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n        GlobalData.gPlatformFinalPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n    return ValueList",
            "def _ValidatePcd(self, PcdCName, TokenSpaceGuid, Setting, PcdType, LineNo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not self._DecPcds:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    if (PcdCName, TokenSpaceGuid) not in self._DecPcds:\n        EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files referenced in INF files in FDF. Arch: ['%s']\" % (TokenSpaceGuid, PcdCName, self._Arch), File=self.MetaFile, Line=LineNo)\n    (ValueList, IsValid, Index) = AnalyzeDscPcd(Setting, PcdType, self._DecPcds[PcdCName, TokenSpaceGuid].DatumType)\n    if not IsValid:\n        if PcdType not in [MODEL_PCD_FEATURE_FLAG, MODEL_PCD_FIXED_AT_BUILD]:\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n        elif ValueList[2] == '-1':\n            EdkLogger.error('build', FORMAT_INVALID, 'Pcd format incorrect.', File=self.MetaFile, Line=LineNo, ExtraData='%s.%s|%s' % (TokenSpaceGuid, PcdCName, Setting))\n    if ValueList[Index]:\n        DatumType = self._DecPcds[PcdCName, TokenSpaceGuid].DatumType\n        if '{CODE(' not in ValueList[Index]:\n            try:\n                ValueList[Index] = ValueExpressionEx(ValueList[Index], DatumType, self._GuidDict)(True)\n            except BadExpression as Value:\n                EdkLogger.error('Parser', FORMAT_INVALID, Value, File=self.MetaFile, Line=LineNo, ExtraData='PCD [%s.%s] Value \"%s\" ' % (TokenSpaceGuid, PcdCName, ValueList[Index]))\n            except EvaluationException as Excpt:\n                if hasattr(Excpt, 'Pcd'):\n                    if Excpt.Pcd in GlobalData.gPlatformOtherPcds:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'Cannot use this PCD (%s) in an expression as it must be defined in a [PcdsFixedAtBuild] or [PcdsFeatureFlag] section of the DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                    else:\n                        EdkLogger.error('Parser', FORMAT_INVALID, 'PCD (%s) is not defined in DSC file' % Excpt.Pcd, File=self.MetaFile, Line=LineNo)\n                else:\n                    EdkLogger.error('Parser', FORMAT_INVALID, 'Invalid expression: %s' % str(Excpt), File=self.MetaFile, Line=LineNo)\n    if ValueList[Index]:\n        (Valid, ErrStr) = CheckPcdDatum(self._DecPcds[PcdCName, TokenSpaceGuid].DatumType, ValueList[Index])\n        if not Valid:\n            EdkLogger.error('build', FORMAT_INVALID, ErrStr, File=self.MetaFile, Line=LineNo, ExtraData='%s.%s' % (TokenSpaceGuid, PcdCName))\n        if PcdType in (MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_FIXED_AT_BUILD, MODEL_PCD_PATCHABLE_IN_MODULE):\n            if self._DecPcds[PcdCName, TokenSpaceGuid].DatumType.strip() != ValueList[1].strip():\n                DecPcd = self._DecPcds[PcdCName, TokenSpaceGuid]\n                EdkLogger.error('build', FORMAT_INVALID, 'Pcd datumtype used in DSC file is not the same as its declaration. DatumType:%s' % DecPcd.DatumType, File=self.MetaFile, Line=LineNo, ExtraData='Dsc:%s.%s|%s\\n    Dec:%s.%s|%s|%s|%s' % (TokenSpaceGuid, PcdCName, Setting, TokenSpaceGuid, PcdCName, DecPcd.DefaultValue, DecPcd.DatumType, DecPcd.TokenValue))\n    if TokenSpaceGuid + '.' + PcdCName in GlobalData.gPlatformPcds:\n        if GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] != ValueList[Index]:\n            GlobalData.gPlatformPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n        GlobalData.gPlatformFinalPcds[TokenSpaceGuid + '.' + PcdCName] = ValueList[Index]\n    return ValueList"
        ]
    },
    {
        "func_name": "_FilterPcdBySkuUsage",
        "original": "def _FilterPcdBySkuUsage(self, Pcds):\n    available_sku = self.SkuIdMgr.AvailableSkuIdSet\n    sku_usage = self.SkuIdMgr.SkuUsageType\n    if sku_usage == SkuClass.SINGLE:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {TAB_DEFAULT: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {TAB_DEFAULT: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    else:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {skuid: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {skuid: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    return Pcds",
        "mutated": [
            "def _FilterPcdBySkuUsage(self, Pcds):\n    if False:\n        i = 10\n    available_sku = self.SkuIdMgr.AvailableSkuIdSet\n    sku_usage = self.SkuIdMgr.SkuUsageType\n    if sku_usage == SkuClass.SINGLE:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {TAB_DEFAULT: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {TAB_DEFAULT: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    else:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {skuid: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {skuid: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    return Pcds",
            "def _FilterPcdBySkuUsage(self, Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    available_sku = self.SkuIdMgr.AvailableSkuIdSet\n    sku_usage = self.SkuIdMgr.SkuUsageType\n    if sku_usage == SkuClass.SINGLE:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {TAB_DEFAULT: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {TAB_DEFAULT: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    else:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {skuid: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {skuid: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    return Pcds",
            "def _FilterPcdBySkuUsage(self, Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    available_sku = self.SkuIdMgr.AvailableSkuIdSet\n    sku_usage = self.SkuIdMgr.SkuUsageType\n    if sku_usage == SkuClass.SINGLE:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {TAB_DEFAULT: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {TAB_DEFAULT: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    else:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {skuid: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {skuid: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    return Pcds",
            "def _FilterPcdBySkuUsage(self, Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    available_sku = self.SkuIdMgr.AvailableSkuIdSet\n    sku_usage = self.SkuIdMgr.SkuUsageType\n    if sku_usage == SkuClass.SINGLE:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {TAB_DEFAULT: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {TAB_DEFAULT: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    else:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {skuid: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {skuid: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    return Pcds",
            "def _FilterPcdBySkuUsage(self, Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    available_sku = self.SkuIdMgr.AvailableSkuIdSet\n    sku_usage = self.SkuIdMgr.SkuUsageType\n    if sku_usage == SkuClass.SINGLE:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {TAB_DEFAULT: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {TAB_DEFAULT: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    else:\n        for pcdname in Pcds:\n            pcd = Pcds[pcdname]\n            Pcds[pcdname].SkuInfoList = {skuid: pcd.SkuInfoList[skuid] for skuid in pcd.SkuInfoList if skuid in available_sku}\n            if isinstance(pcd, StructurePcd) and pcd.SkuOverrideValues:\n                Pcds[pcdname].SkuOverrideValues = {skuid: pcd.SkuOverrideValues[skuid] for skuid in pcd.SkuOverrideValues if skuid in available_sku}\n    return Pcds"
        ]
    },
    {
        "func_name": "CompleteHiiPcdsDefaultStores",
        "original": "def CompleteHiiPcdsDefaultStores(self, Pcds):\n    HiiPcd = [Pcds[pcd] for pcd in Pcds if Pcds[pcd].Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]]\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    for pcd in HiiPcd:\n        for skuid in pcd.SkuInfoList:\n            skuobj = pcd.SkuInfoList.get(skuid)\n            if TAB_DEFAULT_STORES_DEFAULT not in skuobj.DefaultStoreDict:\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                skuobj.DefaultStoreDict[TAB_DEFAULT_STORES_DEFAULT] = skuobj.DefaultStoreDict[mindefaultstorename]\n    return Pcds",
        "mutated": [
            "def CompleteHiiPcdsDefaultStores(self, Pcds):\n    if False:\n        i = 10\n    HiiPcd = [Pcds[pcd] for pcd in Pcds if Pcds[pcd].Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]]\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    for pcd in HiiPcd:\n        for skuid in pcd.SkuInfoList:\n            skuobj = pcd.SkuInfoList.get(skuid)\n            if TAB_DEFAULT_STORES_DEFAULT not in skuobj.DefaultStoreDict:\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                skuobj.DefaultStoreDict[TAB_DEFAULT_STORES_DEFAULT] = skuobj.DefaultStoreDict[mindefaultstorename]\n    return Pcds",
            "def CompleteHiiPcdsDefaultStores(self, Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    HiiPcd = [Pcds[pcd] for pcd in Pcds if Pcds[pcd].Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]]\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    for pcd in HiiPcd:\n        for skuid in pcd.SkuInfoList:\n            skuobj = pcd.SkuInfoList.get(skuid)\n            if TAB_DEFAULT_STORES_DEFAULT not in skuobj.DefaultStoreDict:\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                skuobj.DefaultStoreDict[TAB_DEFAULT_STORES_DEFAULT] = skuobj.DefaultStoreDict[mindefaultstorename]\n    return Pcds",
            "def CompleteHiiPcdsDefaultStores(self, Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    HiiPcd = [Pcds[pcd] for pcd in Pcds if Pcds[pcd].Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]]\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    for pcd in HiiPcd:\n        for skuid in pcd.SkuInfoList:\n            skuobj = pcd.SkuInfoList.get(skuid)\n            if TAB_DEFAULT_STORES_DEFAULT not in skuobj.DefaultStoreDict:\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                skuobj.DefaultStoreDict[TAB_DEFAULT_STORES_DEFAULT] = skuobj.DefaultStoreDict[mindefaultstorename]\n    return Pcds",
            "def CompleteHiiPcdsDefaultStores(self, Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    HiiPcd = [Pcds[pcd] for pcd in Pcds if Pcds[pcd].Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]]\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    for pcd in HiiPcd:\n        for skuid in pcd.SkuInfoList:\n            skuobj = pcd.SkuInfoList.get(skuid)\n            if TAB_DEFAULT_STORES_DEFAULT not in skuobj.DefaultStoreDict:\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                skuobj.DefaultStoreDict[TAB_DEFAULT_STORES_DEFAULT] = skuobj.DefaultStoreDict[mindefaultstorename]\n    return Pcds",
            "def CompleteHiiPcdsDefaultStores(self, Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    HiiPcd = [Pcds[pcd] for pcd in Pcds if Pcds[pcd].Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]]\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    for pcd in HiiPcd:\n        for skuid in pcd.SkuInfoList:\n            skuobj = pcd.SkuInfoList.get(skuid)\n            if TAB_DEFAULT_STORES_DEFAULT not in skuobj.DefaultStoreDict:\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                skuobj.DefaultStoreDict[TAB_DEFAULT_STORES_DEFAULT] = skuobj.DefaultStoreDict[mindefaultstorename]\n    return Pcds"
        ]
    },
    {
        "func_name": "UpdateCommandLineValue",
        "original": "def UpdateCommandLineValue(pcd):\n    if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n        pcd.PcdValueFromComm = pcd.DefaultValue\n    elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n    else:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue",
        "mutated": [
            "def UpdateCommandLineValue(pcd):\n    if False:\n        i = 10\n    if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n        pcd.PcdValueFromComm = pcd.DefaultValue\n    elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n    else:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue",
            "def UpdateCommandLineValue(pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n        pcd.PcdValueFromComm = pcd.DefaultValue\n    elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n    else:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue",
            "def UpdateCommandLineValue(pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n        pcd.PcdValueFromComm = pcd.DefaultValue\n    elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n    else:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue",
            "def UpdateCommandLineValue(pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n        pcd.PcdValueFromComm = pcd.DefaultValue\n    elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n    else:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue",
            "def UpdateCommandLineValue(pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n        pcd.PcdValueFromComm = pcd.DefaultValue\n    elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n    else:\n        pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue"
        ]
    },
    {
        "func_name": "RecoverCommandLinePcd",
        "original": "def RecoverCommandLinePcd(self):\n\n    def UpdateCommandLineValue(pcd):\n        if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            pcd.PcdValueFromComm = pcd.DefaultValue\n        elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n        else:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue\n    for pcd in self._Pcds:\n        if isinstance(self._Pcds[pcd], StructurePcd) and (self._Pcds[pcd].PcdValueFromComm or self._Pcds[pcd].PcdFieldValueFromComm):\n            UpdateCommandLineValue(self._Pcds[pcd])",
        "mutated": [
            "def RecoverCommandLinePcd(self):\n    if False:\n        i = 10\n\n    def UpdateCommandLineValue(pcd):\n        if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            pcd.PcdValueFromComm = pcd.DefaultValue\n        elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n        else:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue\n    for pcd in self._Pcds:\n        if isinstance(self._Pcds[pcd], StructurePcd) and (self._Pcds[pcd].PcdValueFromComm or self._Pcds[pcd].PcdFieldValueFromComm):\n            UpdateCommandLineValue(self._Pcds[pcd])",
            "def RecoverCommandLinePcd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def UpdateCommandLineValue(pcd):\n        if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            pcd.PcdValueFromComm = pcd.DefaultValue\n        elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n        else:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue\n    for pcd in self._Pcds:\n        if isinstance(self._Pcds[pcd], StructurePcd) and (self._Pcds[pcd].PcdValueFromComm or self._Pcds[pcd].PcdFieldValueFromComm):\n            UpdateCommandLineValue(self._Pcds[pcd])",
            "def RecoverCommandLinePcd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def UpdateCommandLineValue(pcd):\n        if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            pcd.PcdValueFromComm = pcd.DefaultValue\n        elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n        else:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue\n    for pcd in self._Pcds:\n        if isinstance(self._Pcds[pcd], StructurePcd) and (self._Pcds[pcd].PcdValueFromComm or self._Pcds[pcd].PcdFieldValueFromComm):\n            UpdateCommandLineValue(self._Pcds[pcd])",
            "def RecoverCommandLinePcd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def UpdateCommandLineValue(pcd):\n        if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            pcd.PcdValueFromComm = pcd.DefaultValue\n        elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n        else:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue\n    for pcd in self._Pcds:\n        if isinstance(self._Pcds[pcd], StructurePcd) and (self._Pcds[pcd].PcdValueFromComm or self._Pcds[pcd].PcdFieldValueFromComm):\n            UpdateCommandLineValue(self._Pcds[pcd])",
            "def RecoverCommandLinePcd(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def UpdateCommandLineValue(pcd):\n        if pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            pcd.PcdValueFromComm = pcd.DefaultValue\n        elif pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).HiiDefaultValue\n        else:\n            pcd.PcdValueFromComm = pcd.SkuInfoList.get(TAB_DEFAULT).DefaultValue\n    for pcd in self._Pcds:\n        if isinstance(self._Pcds[pcd], StructurePcd) and (self._Pcds[pcd].PcdValueFromComm or self._Pcds[pcd].PcdFieldValueFromComm):\n            UpdateCommandLineValue(self._Pcds[pcd])"
        ]
    },
    {
        "func_name": "__ParsePcdFromCommandLine",
        "original": "def __ParsePcdFromCommandLine(self):\n    if GlobalData.BuildOptionPcd:\n        for (i, pcd) in enumerate(GlobalData.BuildOptionPcd):\n            if isinstance(pcd, tuple):\n                continue\n            (pcdname, pcdvalue) = pcd.split('=')\n            if not pcdvalue:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No Value specified for the PCD %s.' % pcdname)\n            if '.' in pcdname:\n                (Name1, Name2) = pcdname.split('.', 1)\n                if '.' in Name2:\n                    (Name3, FieldName) = Name2.split('.', 1)\n                    if (Name3, Name1) in self.DecPcds:\n                        HasTokenSpace = True\n                        TokenCName = Name3\n                        TokenSpaceGuidCName = Name1\n                    else:\n                        FieldName = Name2\n                        TokenCName = Name1\n                        TokenSpaceGuidCName = ''\n                        HasTokenSpace = False\n                elif (Name2, Name1) in self.DecPcds:\n                    HasTokenSpace = True\n                    TokenCName = Name2\n                    TokenSpaceGuidCName = Name1\n                    FieldName = ''\n                else:\n                    FieldName = Name2\n                    TokenCName = Name1\n                    TokenSpaceGuidCName = ''\n                    HasTokenSpace = False\n            else:\n                FieldName = ''\n                TokenCName = pcdname\n                TokenSpaceGuidCName = ''\n                HasTokenSpace = False\n            TokenSpaceGuidCNameList = []\n            FoundFlag = False\n            PcdDatumType = ''\n            DisplayName = TokenCName\n            if FieldName:\n                DisplayName = TokenCName + '.' + FieldName\n            if not HasTokenSpace:\n                for key in self.DecPcds:\n                    PcdItem = self.DecPcds[key]\n                    if TokenCName == PcdItem.TokenCName:\n                        if not PcdItem.TokenSpaceGuidCName in TokenSpaceGuidCNameList:\n                            if len(TokenSpaceGuidCNameList) < 1:\n                                TokenSpaceGuidCNameList.append(PcdItem.TokenSpaceGuidCName)\n                                TokenSpaceGuidCName = PcdItem.TokenSpaceGuidCName\n                                PcdDatumType = PcdItem.DatumType\n                                FoundFlag = True\n                            else:\n                                EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is found under multiple different TokenSpaceGuid: %s and %s.' % (DisplayName, PcdItem.TokenSpaceGuidCName, TokenSpaceGuidCNameList[0]))\n            elif (TokenCName, TokenSpaceGuidCName) in self.DecPcds:\n                PcdDatumType = self.DecPcds[TokenCName, TokenSpaceGuidCName].DatumType\n                FoundFlag = True\n            if not FoundFlag:\n                if HasTokenSpace:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s.%s is not found in the DEC file.' % (TokenSpaceGuidCName, DisplayName))\n                else:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is not found in the DEC file.' % DisplayName)\n            pcdvalue = pcdvalue.replace(\"\\\\\\\\\\\\'\", '\\\\\\\\\\\\\"').replace(\"\\\\'\", \"'\").replace('\\\\\\\\\\\\\"', \"\\\\'\")\n            if FieldName:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict, FieldName)\n            else:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict)\n                (IsValid, Cause) = CheckPcdDatum(PcdDatumType, pcdvalue)\n                if not IsValid:\n                    EdkLogger.error('build', FORMAT_INVALID, Cause, ExtraData='%s.%s' % (TokenSpaceGuidCName, TokenCName))\n            GlobalData.BuildOptionPcd[i] = (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, ('build command options', 1))\n    if GlobalData.BuildOptionPcd:\n        inf_objs = [item for item in self._Bdb._CACHE_.values() if item.Arch == self.Arch and item.MetaFile.Ext.lower() == '.inf']\n        for pcd in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, _) = pcd\n            for BuildData in inf_objs:\n                for key in BuildData.Pcds:\n                    PcdItem = BuildData.Pcds[key]\n                    if (TokenSpaceGuidCName, TokenCName) == (PcdItem.TokenSpaceGuidCName, PcdItem.TokenCName) and FieldName == '':\n                        PcdItem.DefaultValue = pcdvalue\n                        PcdItem.PcdValueFromComm = pcdvalue\n    delete_assign = []\n    field_assign = {}\n    if GlobalData.BuildOptionPcd:\n        for pcdTuple in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuid, Token, Field) = (pcdTuple[0], pcdTuple[1], pcdTuple[2])\n            if Field:\n                if (TokenSpaceGuid, Token) not in field_assign:\n                    field_assign[TokenSpaceGuid, Token] = []\n                field_assign[TokenSpaceGuid, Token].append(pcdTuple)\n            elif (TokenSpaceGuid, Token) in field_assign:\n                delete_assign.extend(field_assign[TokenSpaceGuid, Token])\n                field_assign[TokenSpaceGuid, Token] = []\n        for item in delete_assign:\n            GlobalData.BuildOptionPcd.remove(item)",
        "mutated": [
            "def __ParsePcdFromCommandLine(self):\n    if False:\n        i = 10\n    if GlobalData.BuildOptionPcd:\n        for (i, pcd) in enumerate(GlobalData.BuildOptionPcd):\n            if isinstance(pcd, tuple):\n                continue\n            (pcdname, pcdvalue) = pcd.split('=')\n            if not pcdvalue:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No Value specified for the PCD %s.' % pcdname)\n            if '.' in pcdname:\n                (Name1, Name2) = pcdname.split('.', 1)\n                if '.' in Name2:\n                    (Name3, FieldName) = Name2.split('.', 1)\n                    if (Name3, Name1) in self.DecPcds:\n                        HasTokenSpace = True\n                        TokenCName = Name3\n                        TokenSpaceGuidCName = Name1\n                    else:\n                        FieldName = Name2\n                        TokenCName = Name1\n                        TokenSpaceGuidCName = ''\n                        HasTokenSpace = False\n                elif (Name2, Name1) in self.DecPcds:\n                    HasTokenSpace = True\n                    TokenCName = Name2\n                    TokenSpaceGuidCName = Name1\n                    FieldName = ''\n                else:\n                    FieldName = Name2\n                    TokenCName = Name1\n                    TokenSpaceGuidCName = ''\n                    HasTokenSpace = False\n            else:\n                FieldName = ''\n                TokenCName = pcdname\n                TokenSpaceGuidCName = ''\n                HasTokenSpace = False\n            TokenSpaceGuidCNameList = []\n            FoundFlag = False\n            PcdDatumType = ''\n            DisplayName = TokenCName\n            if FieldName:\n                DisplayName = TokenCName + '.' + FieldName\n            if not HasTokenSpace:\n                for key in self.DecPcds:\n                    PcdItem = self.DecPcds[key]\n                    if TokenCName == PcdItem.TokenCName:\n                        if not PcdItem.TokenSpaceGuidCName in TokenSpaceGuidCNameList:\n                            if len(TokenSpaceGuidCNameList) < 1:\n                                TokenSpaceGuidCNameList.append(PcdItem.TokenSpaceGuidCName)\n                                TokenSpaceGuidCName = PcdItem.TokenSpaceGuidCName\n                                PcdDatumType = PcdItem.DatumType\n                                FoundFlag = True\n                            else:\n                                EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is found under multiple different TokenSpaceGuid: %s and %s.' % (DisplayName, PcdItem.TokenSpaceGuidCName, TokenSpaceGuidCNameList[0]))\n            elif (TokenCName, TokenSpaceGuidCName) in self.DecPcds:\n                PcdDatumType = self.DecPcds[TokenCName, TokenSpaceGuidCName].DatumType\n                FoundFlag = True\n            if not FoundFlag:\n                if HasTokenSpace:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s.%s is not found in the DEC file.' % (TokenSpaceGuidCName, DisplayName))\n                else:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is not found in the DEC file.' % DisplayName)\n            pcdvalue = pcdvalue.replace(\"\\\\\\\\\\\\'\", '\\\\\\\\\\\\\"').replace(\"\\\\'\", \"'\").replace('\\\\\\\\\\\\\"', \"\\\\'\")\n            if FieldName:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict, FieldName)\n            else:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict)\n                (IsValid, Cause) = CheckPcdDatum(PcdDatumType, pcdvalue)\n                if not IsValid:\n                    EdkLogger.error('build', FORMAT_INVALID, Cause, ExtraData='%s.%s' % (TokenSpaceGuidCName, TokenCName))\n            GlobalData.BuildOptionPcd[i] = (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, ('build command options', 1))\n    if GlobalData.BuildOptionPcd:\n        inf_objs = [item for item in self._Bdb._CACHE_.values() if item.Arch == self.Arch and item.MetaFile.Ext.lower() == '.inf']\n        for pcd in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, _) = pcd\n            for BuildData in inf_objs:\n                for key in BuildData.Pcds:\n                    PcdItem = BuildData.Pcds[key]\n                    if (TokenSpaceGuidCName, TokenCName) == (PcdItem.TokenSpaceGuidCName, PcdItem.TokenCName) and FieldName == '':\n                        PcdItem.DefaultValue = pcdvalue\n                        PcdItem.PcdValueFromComm = pcdvalue\n    delete_assign = []\n    field_assign = {}\n    if GlobalData.BuildOptionPcd:\n        for pcdTuple in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuid, Token, Field) = (pcdTuple[0], pcdTuple[1], pcdTuple[2])\n            if Field:\n                if (TokenSpaceGuid, Token) not in field_assign:\n                    field_assign[TokenSpaceGuid, Token] = []\n                field_assign[TokenSpaceGuid, Token].append(pcdTuple)\n            elif (TokenSpaceGuid, Token) in field_assign:\n                delete_assign.extend(field_assign[TokenSpaceGuid, Token])\n                field_assign[TokenSpaceGuid, Token] = []\n        for item in delete_assign:\n            GlobalData.BuildOptionPcd.remove(item)",
            "def __ParsePcdFromCommandLine(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if GlobalData.BuildOptionPcd:\n        for (i, pcd) in enumerate(GlobalData.BuildOptionPcd):\n            if isinstance(pcd, tuple):\n                continue\n            (pcdname, pcdvalue) = pcd.split('=')\n            if not pcdvalue:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No Value specified for the PCD %s.' % pcdname)\n            if '.' in pcdname:\n                (Name1, Name2) = pcdname.split('.', 1)\n                if '.' in Name2:\n                    (Name3, FieldName) = Name2.split('.', 1)\n                    if (Name3, Name1) in self.DecPcds:\n                        HasTokenSpace = True\n                        TokenCName = Name3\n                        TokenSpaceGuidCName = Name1\n                    else:\n                        FieldName = Name2\n                        TokenCName = Name1\n                        TokenSpaceGuidCName = ''\n                        HasTokenSpace = False\n                elif (Name2, Name1) in self.DecPcds:\n                    HasTokenSpace = True\n                    TokenCName = Name2\n                    TokenSpaceGuidCName = Name1\n                    FieldName = ''\n                else:\n                    FieldName = Name2\n                    TokenCName = Name1\n                    TokenSpaceGuidCName = ''\n                    HasTokenSpace = False\n            else:\n                FieldName = ''\n                TokenCName = pcdname\n                TokenSpaceGuidCName = ''\n                HasTokenSpace = False\n            TokenSpaceGuidCNameList = []\n            FoundFlag = False\n            PcdDatumType = ''\n            DisplayName = TokenCName\n            if FieldName:\n                DisplayName = TokenCName + '.' + FieldName\n            if not HasTokenSpace:\n                for key in self.DecPcds:\n                    PcdItem = self.DecPcds[key]\n                    if TokenCName == PcdItem.TokenCName:\n                        if not PcdItem.TokenSpaceGuidCName in TokenSpaceGuidCNameList:\n                            if len(TokenSpaceGuidCNameList) < 1:\n                                TokenSpaceGuidCNameList.append(PcdItem.TokenSpaceGuidCName)\n                                TokenSpaceGuidCName = PcdItem.TokenSpaceGuidCName\n                                PcdDatumType = PcdItem.DatumType\n                                FoundFlag = True\n                            else:\n                                EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is found under multiple different TokenSpaceGuid: %s and %s.' % (DisplayName, PcdItem.TokenSpaceGuidCName, TokenSpaceGuidCNameList[0]))\n            elif (TokenCName, TokenSpaceGuidCName) in self.DecPcds:\n                PcdDatumType = self.DecPcds[TokenCName, TokenSpaceGuidCName].DatumType\n                FoundFlag = True\n            if not FoundFlag:\n                if HasTokenSpace:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s.%s is not found in the DEC file.' % (TokenSpaceGuidCName, DisplayName))\n                else:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is not found in the DEC file.' % DisplayName)\n            pcdvalue = pcdvalue.replace(\"\\\\\\\\\\\\'\", '\\\\\\\\\\\\\"').replace(\"\\\\'\", \"'\").replace('\\\\\\\\\\\\\"', \"\\\\'\")\n            if FieldName:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict, FieldName)\n            else:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict)\n                (IsValid, Cause) = CheckPcdDatum(PcdDatumType, pcdvalue)\n                if not IsValid:\n                    EdkLogger.error('build', FORMAT_INVALID, Cause, ExtraData='%s.%s' % (TokenSpaceGuidCName, TokenCName))\n            GlobalData.BuildOptionPcd[i] = (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, ('build command options', 1))\n    if GlobalData.BuildOptionPcd:\n        inf_objs = [item for item in self._Bdb._CACHE_.values() if item.Arch == self.Arch and item.MetaFile.Ext.lower() == '.inf']\n        for pcd in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, _) = pcd\n            for BuildData in inf_objs:\n                for key in BuildData.Pcds:\n                    PcdItem = BuildData.Pcds[key]\n                    if (TokenSpaceGuidCName, TokenCName) == (PcdItem.TokenSpaceGuidCName, PcdItem.TokenCName) and FieldName == '':\n                        PcdItem.DefaultValue = pcdvalue\n                        PcdItem.PcdValueFromComm = pcdvalue\n    delete_assign = []\n    field_assign = {}\n    if GlobalData.BuildOptionPcd:\n        for pcdTuple in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuid, Token, Field) = (pcdTuple[0], pcdTuple[1], pcdTuple[2])\n            if Field:\n                if (TokenSpaceGuid, Token) not in field_assign:\n                    field_assign[TokenSpaceGuid, Token] = []\n                field_assign[TokenSpaceGuid, Token].append(pcdTuple)\n            elif (TokenSpaceGuid, Token) in field_assign:\n                delete_assign.extend(field_assign[TokenSpaceGuid, Token])\n                field_assign[TokenSpaceGuid, Token] = []\n        for item in delete_assign:\n            GlobalData.BuildOptionPcd.remove(item)",
            "def __ParsePcdFromCommandLine(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if GlobalData.BuildOptionPcd:\n        for (i, pcd) in enumerate(GlobalData.BuildOptionPcd):\n            if isinstance(pcd, tuple):\n                continue\n            (pcdname, pcdvalue) = pcd.split('=')\n            if not pcdvalue:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No Value specified for the PCD %s.' % pcdname)\n            if '.' in pcdname:\n                (Name1, Name2) = pcdname.split('.', 1)\n                if '.' in Name2:\n                    (Name3, FieldName) = Name2.split('.', 1)\n                    if (Name3, Name1) in self.DecPcds:\n                        HasTokenSpace = True\n                        TokenCName = Name3\n                        TokenSpaceGuidCName = Name1\n                    else:\n                        FieldName = Name2\n                        TokenCName = Name1\n                        TokenSpaceGuidCName = ''\n                        HasTokenSpace = False\n                elif (Name2, Name1) in self.DecPcds:\n                    HasTokenSpace = True\n                    TokenCName = Name2\n                    TokenSpaceGuidCName = Name1\n                    FieldName = ''\n                else:\n                    FieldName = Name2\n                    TokenCName = Name1\n                    TokenSpaceGuidCName = ''\n                    HasTokenSpace = False\n            else:\n                FieldName = ''\n                TokenCName = pcdname\n                TokenSpaceGuidCName = ''\n                HasTokenSpace = False\n            TokenSpaceGuidCNameList = []\n            FoundFlag = False\n            PcdDatumType = ''\n            DisplayName = TokenCName\n            if FieldName:\n                DisplayName = TokenCName + '.' + FieldName\n            if not HasTokenSpace:\n                for key in self.DecPcds:\n                    PcdItem = self.DecPcds[key]\n                    if TokenCName == PcdItem.TokenCName:\n                        if not PcdItem.TokenSpaceGuidCName in TokenSpaceGuidCNameList:\n                            if len(TokenSpaceGuidCNameList) < 1:\n                                TokenSpaceGuidCNameList.append(PcdItem.TokenSpaceGuidCName)\n                                TokenSpaceGuidCName = PcdItem.TokenSpaceGuidCName\n                                PcdDatumType = PcdItem.DatumType\n                                FoundFlag = True\n                            else:\n                                EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is found under multiple different TokenSpaceGuid: %s and %s.' % (DisplayName, PcdItem.TokenSpaceGuidCName, TokenSpaceGuidCNameList[0]))\n            elif (TokenCName, TokenSpaceGuidCName) in self.DecPcds:\n                PcdDatumType = self.DecPcds[TokenCName, TokenSpaceGuidCName].DatumType\n                FoundFlag = True\n            if not FoundFlag:\n                if HasTokenSpace:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s.%s is not found in the DEC file.' % (TokenSpaceGuidCName, DisplayName))\n                else:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is not found in the DEC file.' % DisplayName)\n            pcdvalue = pcdvalue.replace(\"\\\\\\\\\\\\'\", '\\\\\\\\\\\\\"').replace(\"\\\\'\", \"'\").replace('\\\\\\\\\\\\\"', \"\\\\'\")\n            if FieldName:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict, FieldName)\n            else:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict)\n                (IsValid, Cause) = CheckPcdDatum(PcdDatumType, pcdvalue)\n                if not IsValid:\n                    EdkLogger.error('build', FORMAT_INVALID, Cause, ExtraData='%s.%s' % (TokenSpaceGuidCName, TokenCName))\n            GlobalData.BuildOptionPcd[i] = (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, ('build command options', 1))\n    if GlobalData.BuildOptionPcd:\n        inf_objs = [item for item in self._Bdb._CACHE_.values() if item.Arch == self.Arch and item.MetaFile.Ext.lower() == '.inf']\n        for pcd in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, _) = pcd\n            for BuildData in inf_objs:\n                for key in BuildData.Pcds:\n                    PcdItem = BuildData.Pcds[key]\n                    if (TokenSpaceGuidCName, TokenCName) == (PcdItem.TokenSpaceGuidCName, PcdItem.TokenCName) and FieldName == '':\n                        PcdItem.DefaultValue = pcdvalue\n                        PcdItem.PcdValueFromComm = pcdvalue\n    delete_assign = []\n    field_assign = {}\n    if GlobalData.BuildOptionPcd:\n        for pcdTuple in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuid, Token, Field) = (pcdTuple[0], pcdTuple[1], pcdTuple[2])\n            if Field:\n                if (TokenSpaceGuid, Token) not in field_assign:\n                    field_assign[TokenSpaceGuid, Token] = []\n                field_assign[TokenSpaceGuid, Token].append(pcdTuple)\n            elif (TokenSpaceGuid, Token) in field_assign:\n                delete_assign.extend(field_assign[TokenSpaceGuid, Token])\n                field_assign[TokenSpaceGuid, Token] = []\n        for item in delete_assign:\n            GlobalData.BuildOptionPcd.remove(item)",
            "def __ParsePcdFromCommandLine(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if GlobalData.BuildOptionPcd:\n        for (i, pcd) in enumerate(GlobalData.BuildOptionPcd):\n            if isinstance(pcd, tuple):\n                continue\n            (pcdname, pcdvalue) = pcd.split('=')\n            if not pcdvalue:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No Value specified for the PCD %s.' % pcdname)\n            if '.' in pcdname:\n                (Name1, Name2) = pcdname.split('.', 1)\n                if '.' in Name2:\n                    (Name3, FieldName) = Name2.split('.', 1)\n                    if (Name3, Name1) in self.DecPcds:\n                        HasTokenSpace = True\n                        TokenCName = Name3\n                        TokenSpaceGuidCName = Name1\n                    else:\n                        FieldName = Name2\n                        TokenCName = Name1\n                        TokenSpaceGuidCName = ''\n                        HasTokenSpace = False\n                elif (Name2, Name1) in self.DecPcds:\n                    HasTokenSpace = True\n                    TokenCName = Name2\n                    TokenSpaceGuidCName = Name1\n                    FieldName = ''\n                else:\n                    FieldName = Name2\n                    TokenCName = Name1\n                    TokenSpaceGuidCName = ''\n                    HasTokenSpace = False\n            else:\n                FieldName = ''\n                TokenCName = pcdname\n                TokenSpaceGuidCName = ''\n                HasTokenSpace = False\n            TokenSpaceGuidCNameList = []\n            FoundFlag = False\n            PcdDatumType = ''\n            DisplayName = TokenCName\n            if FieldName:\n                DisplayName = TokenCName + '.' + FieldName\n            if not HasTokenSpace:\n                for key in self.DecPcds:\n                    PcdItem = self.DecPcds[key]\n                    if TokenCName == PcdItem.TokenCName:\n                        if not PcdItem.TokenSpaceGuidCName in TokenSpaceGuidCNameList:\n                            if len(TokenSpaceGuidCNameList) < 1:\n                                TokenSpaceGuidCNameList.append(PcdItem.TokenSpaceGuidCName)\n                                TokenSpaceGuidCName = PcdItem.TokenSpaceGuidCName\n                                PcdDatumType = PcdItem.DatumType\n                                FoundFlag = True\n                            else:\n                                EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is found under multiple different TokenSpaceGuid: %s and %s.' % (DisplayName, PcdItem.TokenSpaceGuidCName, TokenSpaceGuidCNameList[0]))\n            elif (TokenCName, TokenSpaceGuidCName) in self.DecPcds:\n                PcdDatumType = self.DecPcds[TokenCName, TokenSpaceGuidCName].DatumType\n                FoundFlag = True\n            if not FoundFlag:\n                if HasTokenSpace:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s.%s is not found in the DEC file.' % (TokenSpaceGuidCName, DisplayName))\n                else:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is not found in the DEC file.' % DisplayName)\n            pcdvalue = pcdvalue.replace(\"\\\\\\\\\\\\'\", '\\\\\\\\\\\\\"').replace(\"\\\\'\", \"'\").replace('\\\\\\\\\\\\\"', \"\\\\'\")\n            if FieldName:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict, FieldName)\n            else:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict)\n                (IsValid, Cause) = CheckPcdDatum(PcdDatumType, pcdvalue)\n                if not IsValid:\n                    EdkLogger.error('build', FORMAT_INVALID, Cause, ExtraData='%s.%s' % (TokenSpaceGuidCName, TokenCName))\n            GlobalData.BuildOptionPcd[i] = (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, ('build command options', 1))\n    if GlobalData.BuildOptionPcd:\n        inf_objs = [item for item in self._Bdb._CACHE_.values() if item.Arch == self.Arch and item.MetaFile.Ext.lower() == '.inf']\n        for pcd in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, _) = pcd\n            for BuildData in inf_objs:\n                for key in BuildData.Pcds:\n                    PcdItem = BuildData.Pcds[key]\n                    if (TokenSpaceGuidCName, TokenCName) == (PcdItem.TokenSpaceGuidCName, PcdItem.TokenCName) and FieldName == '':\n                        PcdItem.DefaultValue = pcdvalue\n                        PcdItem.PcdValueFromComm = pcdvalue\n    delete_assign = []\n    field_assign = {}\n    if GlobalData.BuildOptionPcd:\n        for pcdTuple in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuid, Token, Field) = (pcdTuple[0], pcdTuple[1], pcdTuple[2])\n            if Field:\n                if (TokenSpaceGuid, Token) not in field_assign:\n                    field_assign[TokenSpaceGuid, Token] = []\n                field_assign[TokenSpaceGuid, Token].append(pcdTuple)\n            elif (TokenSpaceGuid, Token) in field_assign:\n                delete_assign.extend(field_assign[TokenSpaceGuid, Token])\n                field_assign[TokenSpaceGuid, Token] = []\n        for item in delete_assign:\n            GlobalData.BuildOptionPcd.remove(item)",
            "def __ParsePcdFromCommandLine(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if GlobalData.BuildOptionPcd:\n        for (i, pcd) in enumerate(GlobalData.BuildOptionPcd):\n            if isinstance(pcd, tuple):\n                continue\n            (pcdname, pcdvalue) = pcd.split('=')\n            if not pcdvalue:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No Value specified for the PCD %s.' % pcdname)\n            if '.' in pcdname:\n                (Name1, Name2) = pcdname.split('.', 1)\n                if '.' in Name2:\n                    (Name3, FieldName) = Name2.split('.', 1)\n                    if (Name3, Name1) in self.DecPcds:\n                        HasTokenSpace = True\n                        TokenCName = Name3\n                        TokenSpaceGuidCName = Name1\n                    else:\n                        FieldName = Name2\n                        TokenCName = Name1\n                        TokenSpaceGuidCName = ''\n                        HasTokenSpace = False\n                elif (Name2, Name1) in self.DecPcds:\n                    HasTokenSpace = True\n                    TokenCName = Name2\n                    TokenSpaceGuidCName = Name1\n                    FieldName = ''\n                else:\n                    FieldName = Name2\n                    TokenCName = Name1\n                    TokenSpaceGuidCName = ''\n                    HasTokenSpace = False\n            else:\n                FieldName = ''\n                TokenCName = pcdname\n                TokenSpaceGuidCName = ''\n                HasTokenSpace = False\n            TokenSpaceGuidCNameList = []\n            FoundFlag = False\n            PcdDatumType = ''\n            DisplayName = TokenCName\n            if FieldName:\n                DisplayName = TokenCName + '.' + FieldName\n            if not HasTokenSpace:\n                for key in self.DecPcds:\n                    PcdItem = self.DecPcds[key]\n                    if TokenCName == PcdItem.TokenCName:\n                        if not PcdItem.TokenSpaceGuidCName in TokenSpaceGuidCNameList:\n                            if len(TokenSpaceGuidCNameList) < 1:\n                                TokenSpaceGuidCNameList.append(PcdItem.TokenSpaceGuidCName)\n                                TokenSpaceGuidCName = PcdItem.TokenSpaceGuidCName\n                                PcdDatumType = PcdItem.DatumType\n                                FoundFlag = True\n                            else:\n                                EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is found under multiple different TokenSpaceGuid: %s and %s.' % (DisplayName, PcdItem.TokenSpaceGuidCName, TokenSpaceGuidCNameList[0]))\n            elif (TokenCName, TokenSpaceGuidCName) in self.DecPcds:\n                PcdDatumType = self.DecPcds[TokenCName, TokenSpaceGuidCName].DatumType\n                FoundFlag = True\n            if not FoundFlag:\n                if HasTokenSpace:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s.%s is not found in the DEC file.' % (TokenSpaceGuidCName, DisplayName))\n                else:\n                    EdkLogger.error('build', AUTOGEN_ERROR, 'The Pcd %s is not found in the DEC file.' % DisplayName)\n            pcdvalue = pcdvalue.replace(\"\\\\\\\\\\\\'\", '\\\\\\\\\\\\\"').replace(\"\\\\'\", \"'\").replace('\\\\\\\\\\\\\"', \"\\\\'\")\n            if FieldName:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict, FieldName)\n            else:\n                pcdvalue = DscBuildData.HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, pcdvalue, PcdDatumType, self._GuidDict)\n                (IsValid, Cause) = CheckPcdDatum(PcdDatumType, pcdvalue)\n                if not IsValid:\n                    EdkLogger.error('build', FORMAT_INVALID, Cause, ExtraData='%s.%s' % (TokenSpaceGuidCName, TokenCName))\n            GlobalData.BuildOptionPcd[i] = (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, ('build command options', 1))\n    if GlobalData.BuildOptionPcd:\n        inf_objs = [item for item in self._Bdb._CACHE_.values() if item.Arch == self.Arch and item.MetaFile.Ext.lower() == '.inf']\n        for pcd in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuidCName, TokenCName, FieldName, pcdvalue, _) = pcd\n            for BuildData in inf_objs:\n                for key in BuildData.Pcds:\n                    PcdItem = BuildData.Pcds[key]\n                    if (TokenSpaceGuidCName, TokenCName) == (PcdItem.TokenSpaceGuidCName, PcdItem.TokenCName) and FieldName == '':\n                        PcdItem.DefaultValue = pcdvalue\n                        PcdItem.PcdValueFromComm = pcdvalue\n    delete_assign = []\n    field_assign = {}\n    if GlobalData.BuildOptionPcd:\n        for pcdTuple in GlobalData.BuildOptionPcd:\n            (TokenSpaceGuid, Token, Field) = (pcdTuple[0], pcdTuple[1], pcdTuple[2])\n            if Field:\n                if (TokenSpaceGuid, Token) not in field_assign:\n                    field_assign[TokenSpaceGuid, Token] = []\n                field_assign[TokenSpaceGuid, Token].append(pcdTuple)\n            elif (TokenSpaceGuid, Token) in field_assign:\n                delete_assign.extend(field_assign[TokenSpaceGuid, Token])\n                field_assign[TokenSpaceGuid, Token] = []\n        for item in delete_assign:\n            GlobalData.BuildOptionPcd.remove(item)"
        ]
    },
    {
        "func_name": "HandleFlexiblePcd",
        "original": "@staticmethod\ndef HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, PcdValue, PcdDatumType, GuidDict, FieldName=''):\n    if FieldName:\n        IsArray = False\n        TokenCName += '.' + FieldName\n    if PcdValue.startswith('H'):\n        if FieldName and _IsFieldValueAnArray(PcdValue[1:]):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue[1:], PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith(\"L'\") or PcdValue.startswith(\"'\"):\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith('L'):\n        PcdValue = 'L\"' + PcdValue[1:] + '\"'\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    else:\n        if PcdValue.upper() == 'FALSE':\n            PcdValue = str(0)\n        if PcdValue.upper() == 'TRUE':\n            PcdValue = str(1)\n        if not FieldName:\n            if PcdDatumType not in TAB_PCD_NUMERIC_TYPES:\n                PcdValue = '\"' + PcdValue + '\"'\n            elif not PcdValue.isdigit() and (not PcdValue.upper().startswith('0X')):\n                PcdValue = '\"' + PcdValue + '\"'\n        else:\n            IsArray = False\n            Base = 10\n            if PcdValue.upper().startswith('0X'):\n                Base = 16\n            try:\n                Num = int(PcdValue, Base)\n            except:\n                PcdValue = '\"' + PcdValue + '\"'\n            if _IsFieldValueAnArray(PcdValue):\n                PcdDatumType = TAB_VOID\n                IsArray = True\n            if not IsArray:\n                return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    return PcdValue",
        "mutated": [
            "@staticmethod\ndef HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, PcdValue, PcdDatumType, GuidDict, FieldName=''):\n    if False:\n        i = 10\n    if FieldName:\n        IsArray = False\n        TokenCName += '.' + FieldName\n    if PcdValue.startswith('H'):\n        if FieldName and _IsFieldValueAnArray(PcdValue[1:]):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue[1:], PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith(\"L'\") or PcdValue.startswith(\"'\"):\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith('L'):\n        PcdValue = 'L\"' + PcdValue[1:] + '\"'\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    else:\n        if PcdValue.upper() == 'FALSE':\n            PcdValue = str(0)\n        if PcdValue.upper() == 'TRUE':\n            PcdValue = str(1)\n        if not FieldName:\n            if PcdDatumType not in TAB_PCD_NUMERIC_TYPES:\n                PcdValue = '\"' + PcdValue + '\"'\n            elif not PcdValue.isdigit() and (not PcdValue.upper().startswith('0X')):\n                PcdValue = '\"' + PcdValue + '\"'\n        else:\n            IsArray = False\n            Base = 10\n            if PcdValue.upper().startswith('0X'):\n                Base = 16\n            try:\n                Num = int(PcdValue, Base)\n            except:\n                PcdValue = '\"' + PcdValue + '\"'\n            if _IsFieldValueAnArray(PcdValue):\n                PcdDatumType = TAB_VOID\n                IsArray = True\n            if not IsArray:\n                return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    return PcdValue",
            "@staticmethod\ndef HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, PcdValue, PcdDatumType, GuidDict, FieldName=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if FieldName:\n        IsArray = False\n        TokenCName += '.' + FieldName\n    if PcdValue.startswith('H'):\n        if FieldName and _IsFieldValueAnArray(PcdValue[1:]):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue[1:], PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith(\"L'\") or PcdValue.startswith(\"'\"):\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith('L'):\n        PcdValue = 'L\"' + PcdValue[1:] + '\"'\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    else:\n        if PcdValue.upper() == 'FALSE':\n            PcdValue = str(0)\n        if PcdValue.upper() == 'TRUE':\n            PcdValue = str(1)\n        if not FieldName:\n            if PcdDatumType not in TAB_PCD_NUMERIC_TYPES:\n                PcdValue = '\"' + PcdValue + '\"'\n            elif not PcdValue.isdigit() and (not PcdValue.upper().startswith('0X')):\n                PcdValue = '\"' + PcdValue + '\"'\n        else:\n            IsArray = False\n            Base = 10\n            if PcdValue.upper().startswith('0X'):\n                Base = 16\n            try:\n                Num = int(PcdValue, Base)\n            except:\n                PcdValue = '\"' + PcdValue + '\"'\n            if _IsFieldValueAnArray(PcdValue):\n                PcdDatumType = TAB_VOID\n                IsArray = True\n            if not IsArray:\n                return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    return PcdValue",
            "@staticmethod\ndef HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, PcdValue, PcdDatumType, GuidDict, FieldName=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if FieldName:\n        IsArray = False\n        TokenCName += '.' + FieldName\n    if PcdValue.startswith('H'):\n        if FieldName and _IsFieldValueAnArray(PcdValue[1:]):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue[1:], PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith(\"L'\") or PcdValue.startswith(\"'\"):\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith('L'):\n        PcdValue = 'L\"' + PcdValue[1:] + '\"'\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    else:\n        if PcdValue.upper() == 'FALSE':\n            PcdValue = str(0)\n        if PcdValue.upper() == 'TRUE':\n            PcdValue = str(1)\n        if not FieldName:\n            if PcdDatumType not in TAB_PCD_NUMERIC_TYPES:\n                PcdValue = '\"' + PcdValue + '\"'\n            elif not PcdValue.isdigit() and (not PcdValue.upper().startswith('0X')):\n                PcdValue = '\"' + PcdValue + '\"'\n        else:\n            IsArray = False\n            Base = 10\n            if PcdValue.upper().startswith('0X'):\n                Base = 16\n            try:\n                Num = int(PcdValue, Base)\n            except:\n                PcdValue = '\"' + PcdValue + '\"'\n            if _IsFieldValueAnArray(PcdValue):\n                PcdDatumType = TAB_VOID\n                IsArray = True\n            if not IsArray:\n                return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    return PcdValue",
            "@staticmethod\ndef HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, PcdValue, PcdDatumType, GuidDict, FieldName=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if FieldName:\n        IsArray = False\n        TokenCName += '.' + FieldName\n    if PcdValue.startswith('H'):\n        if FieldName and _IsFieldValueAnArray(PcdValue[1:]):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue[1:], PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith(\"L'\") or PcdValue.startswith(\"'\"):\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith('L'):\n        PcdValue = 'L\"' + PcdValue[1:] + '\"'\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    else:\n        if PcdValue.upper() == 'FALSE':\n            PcdValue = str(0)\n        if PcdValue.upper() == 'TRUE':\n            PcdValue = str(1)\n        if not FieldName:\n            if PcdDatumType not in TAB_PCD_NUMERIC_TYPES:\n                PcdValue = '\"' + PcdValue + '\"'\n            elif not PcdValue.isdigit() and (not PcdValue.upper().startswith('0X')):\n                PcdValue = '\"' + PcdValue + '\"'\n        else:\n            IsArray = False\n            Base = 10\n            if PcdValue.upper().startswith('0X'):\n                Base = 16\n            try:\n                Num = int(PcdValue, Base)\n            except:\n                PcdValue = '\"' + PcdValue + '\"'\n            if _IsFieldValueAnArray(PcdValue):\n                PcdDatumType = TAB_VOID\n                IsArray = True\n            if not IsArray:\n                return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    return PcdValue",
            "@staticmethod\ndef HandleFlexiblePcd(TokenSpaceGuidCName, TokenCName, PcdValue, PcdDatumType, GuidDict, FieldName=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if FieldName:\n        IsArray = False\n        TokenCName += '.' + FieldName\n    if PcdValue.startswith('H'):\n        if FieldName and _IsFieldValueAnArray(PcdValue[1:]):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue[1:], PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith(\"L'\") or PcdValue.startswith(\"'\"):\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    elif PcdValue.startswith('L'):\n        PcdValue = 'L\"' + PcdValue[1:] + '\"'\n        if FieldName and _IsFieldValueAnArray(PcdValue):\n            PcdDatumType = TAB_VOID\n            IsArray = True\n        if FieldName and (not IsArray):\n            return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    else:\n        if PcdValue.upper() == 'FALSE':\n            PcdValue = str(0)\n        if PcdValue.upper() == 'TRUE':\n            PcdValue = str(1)\n        if not FieldName:\n            if PcdDatumType not in TAB_PCD_NUMERIC_TYPES:\n                PcdValue = '\"' + PcdValue + '\"'\n            elif not PcdValue.isdigit() and (not PcdValue.upper().startswith('0X')):\n                PcdValue = '\"' + PcdValue + '\"'\n        else:\n            IsArray = False\n            Base = 10\n            if PcdValue.upper().startswith('0X'):\n                Base = 16\n            try:\n                Num = int(PcdValue, Base)\n            except:\n                PcdValue = '\"' + PcdValue + '\"'\n            if _IsFieldValueAnArray(PcdValue):\n                PcdDatumType = TAB_VOID\n                IsArray = True\n            if not IsArray:\n                return PcdValue\n        try:\n            PcdValue = ValueExpressionEx(PcdValue, PcdDatumType, GuidDict)(True)\n        except BadExpression as Value:\n            EdkLogger.error('Parser', FORMAT_INVALID, 'PCD [%s.%s] Value \"%s\",  %s' % (TokenSpaceGuidCName, TokenCName, PcdValue, Value))\n    return PcdValue"
        ]
    },
    {
        "func_name": "Pcds",
        "original": "@property\ndef Pcds(self):\n    if self._Pcds is None:\n        self._Pcds = OrderedDict()\n        self.__ParsePcdFromCommandLine()\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FIXED_AT_BUILD))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_PATCHABLE_IN_MODULE))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FEATURE_FLAG))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_VPD))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_EX_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_EX_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_EX_VPD))\n        self._Pcds = self.CompletePcdValues(self._Pcds)\n        self._Pcds = self.OverrideByFdfOverAll(self._Pcds)\n        self._Pcds = self.OverrideByCommOverAll(self._Pcds)\n        self._Pcds = self.UpdateStructuredPcds(MODEL_PCD_TYPE_LIST, self._Pcds)\n        self._Pcds = self.CompleteHiiPcdsDefaultStores(self._Pcds)\n        self._Pcds = self._FilterPcdBySkuUsage(self._Pcds)\n        self.RecoverCommandLinePcd()\n    return self._Pcds",
        "mutated": [
            "@property\ndef Pcds(self):\n    if False:\n        i = 10\n    if self._Pcds is None:\n        self._Pcds = OrderedDict()\n        self.__ParsePcdFromCommandLine()\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FIXED_AT_BUILD))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_PATCHABLE_IN_MODULE))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FEATURE_FLAG))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_VPD))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_EX_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_EX_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_EX_VPD))\n        self._Pcds = self.CompletePcdValues(self._Pcds)\n        self._Pcds = self.OverrideByFdfOverAll(self._Pcds)\n        self._Pcds = self.OverrideByCommOverAll(self._Pcds)\n        self._Pcds = self.UpdateStructuredPcds(MODEL_PCD_TYPE_LIST, self._Pcds)\n        self._Pcds = self.CompleteHiiPcdsDefaultStores(self._Pcds)\n        self._Pcds = self._FilterPcdBySkuUsage(self._Pcds)\n        self.RecoverCommandLinePcd()\n    return self._Pcds",
            "@property\ndef Pcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._Pcds is None:\n        self._Pcds = OrderedDict()\n        self.__ParsePcdFromCommandLine()\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FIXED_AT_BUILD))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_PATCHABLE_IN_MODULE))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FEATURE_FLAG))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_VPD))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_EX_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_EX_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_EX_VPD))\n        self._Pcds = self.CompletePcdValues(self._Pcds)\n        self._Pcds = self.OverrideByFdfOverAll(self._Pcds)\n        self._Pcds = self.OverrideByCommOverAll(self._Pcds)\n        self._Pcds = self.UpdateStructuredPcds(MODEL_PCD_TYPE_LIST, self._Pcds)\n        self._Pcds = self.CompleteHiiPcdsDefaultStores(self._Pcds)\n        self._Pcds = self._FilterPcdBySkuUsage(self._Pcds)\n        self.RecoverCommandLinePcd()\n    return self._Pcds",
            "@property\ndef Pcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._Pcds is None:\n        self._Pcds = OrderedDict()\n        self.__ParsePcdFromCommandLine()\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FIXED_AT_BUILD))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_PATCHABLE_IN_MODULE))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FEATURE_FLAG))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_VPD))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_EX_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_EX_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_EX_VPD))\n        self._Pcds = self.CompletePcdValues(self._Pcds)\n        self._Pcds = self.OverrideByFdfOverAll(self._Pcds)\n        self._Pcds = self.OverrideByCommOverAll(self._Pcds)\n        self._Pcds = self.UpdateStructuredPcds(MODEL_PCD_TYPE_LIST, self._Pcds)\n        self._Pcds = self.CompleteHiiPcdsDefaultStores(self._Pcds)\n        self._Pcds = self._FilterPcdBySkuUsage(self._Pcds)\n        self.RecoverCommandLinePcd()\n    return self._Pcds",
            "@property\ndef Pcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._Pcds is None:\n        self._Pcds = OrderedDict()\n        self.__ParsePcdFromCommandLine()\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FIXED_AT_BUILD))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_PATCHABLE_IN_MODULE))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FEATURE_FLAG))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_VPD))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_EX_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_EX_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_EX_VPD))\n        self._Pcds = self.CompletePcdValues(self._Pcds)\n        self._Pcds = self.OverrideByFdfOverAll(self._Pcds)\n        self._Pcds = self.OverrideByCommOverAll(self._Pcds)\n        self._Pcds = self.UpdateStructuredPcds(MODEL_PCD_TYPE_LIST, self._Pcds)\n        self._Pcds = self.CompleteHiiPcdsDefaultStores(self._Pcds)\n        self._Pcds = self._FilterPcdBySkuUsage(self._Pcds)\n        self.RecoverCommandLinePcd()\n    return self._Pcds",
            "@property\ndef Pcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._Pcds is None:\n        self._Pcds = OrderedDict()\n        self.__ParsePcdFromCommandLine()\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FIXED_AT_BUILD))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_PATCHABLE_IN_MODULE))\n        self._Pcds.update(self._GetPcd(MODEL_PCD_FEATURE_FLAG))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_VPD))\n        self._Pcds.update(self._GetDynamicPcd(MODEL_PCD_DYNAMIC_EX_DEFAULT))\n        self._Pcds.update(self._GetDynamicHiiPcd(MODEL_PCD_DYNAMIC_EX_HII))\n        self._Pcds.update(self._GetDynamicVpdPcd(MODEL_PCD_DYNAMIC_EX_VPD))\n        self._Pcds = self.CompletePcdValues(self._Pcds)\n        self._Pcds = self.OverrideByFdfOverAll(self._Pcds)\n        self._Pcds = self.OverrideByCommOverAll(self._Pcds)\n        self._Pcds = self.UpdateStructuredPcds(MODEL_PCD_TYPE_LIST, self._Pcds)\n        self._Pcds = self.CompleteHiiPcdsDefaultStores(self._Pcds)\n        self._Pcds = self._FilterPcdBySkuUsage(self._Pcds)\n        self.RecoverCommandLinePcd()\n    return self._Pcds"
        ]
    },
    {
        "func_name": "BuildOptions",
        "original": "@property\ndef BuildOptions(self):\n    if self._BuildOptions is None:\n        self._BuildOptions = OrderedDict()\n        for CodeBase in (EDKII_NAME, EDK_NAME):\n            RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, CodeBase]\n            for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                if Dummy3.upper() != TAB_COMMON:\n                    continue\n                CurKey = (ToolChainFamily, ToolChain, CodeBase)\n                if CurKey not in self._BuildOptions or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    self._BuildOptions[CurKey] = Option\n                elif ' ' + Option not in self._BuildOptions[CurKey]:\n                    self._BuildOptions[CurKey] += ' ' + Option\n    return self._BuildOptions",
        "mutated": [
            "@property\ndef BuildOptions(self):\n    if False:\n        i = 10\n    if self._BuildOptions is None:\n        self._BuildOptions = OrderedDict()\n        for CodeBase in (EDKII_NAME, EDK_NAME):\n            RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, CodeBase]\n            for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                if Dummy3.upper() != TAB_COMMON:\n                    continue\n                CurKey = (ToolChainFamily, ToolChain, CodeBase)\n                if CurKey not in self._BuildOptions or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    self._BuildOptions[CurKey] = Option\n                elif ' ' + Option not in self._BuildOptions[CurKey]:\n                    self._BuildOptions[CurKey] += ' ' + Option\n    return self._BuildOptions",
            "@property\ndef BuildOptions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._BuildOptions is None:\n        self._BuildOptions = OrderedDict()\n        for CodeBase in (EDKII_NAME, EDK_NAME):\n            RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, CodeBase]\n            for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                if Dummy3.upper() != TAB_COMMON:\n                    continue\n                CurKey = (ToolChainFamily, ToolChain, CodeBase)\n                if CurKey not in self._BuildOptions or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    self._BuildOptions[CurKey] = Option\n                elif ' ' + Option not in self._BuildOptions[CurKey]:\n                    self._BuildOptions[CurKey] += ' ' + Option\n    return self._BuildOptions",
            "@property\ndef BuildOptions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._BuildOptions is None:\n        self._BuildOptions = OrderedDict()\n        for CodeBase in (EDKII_NAME, EDK_NAME):\n            RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, CodeBase]\n            for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                if Dummy3.upper() != TAB_COMMON:\n                    continue\n                CurKey = (ToolChainFamily, ToolChain, CodeBase)\n                if CurKey not in self._BuildOptions or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    self._BuildOptions[CurKey] = Option\n                elif ' ' + Option not in self._BuildOptions[CurKey]:\n                    self._BuildOptions[CurKey] += ' ' + Option\n    return self._BuildOptions",
            "@property\ndef BuildOptions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._BuildOptions is None:\n        self._BuildOptions = OrderedDict()\n        for CodeBase in (EDKII_NAME, EDK_NAME):\n            RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, CodeBase]\n            for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                if Dummy3.upper() != TAB_COMMON:\n                    continue\n                CurKey = (ToolChainFamily, ToolChain, CodeBase)\n                if CurKey not in self._BuildOptions or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    self._BuildOptions[CurKey] = Option\n                elif ' ' + Option not in self._BuildOptions[CurKey]:\n                    self._BuildOptions[CurKey] += ' ' + Option\n    return self._BuildOptions",
            "@property\ndef BuildOptions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._BuildOptions is None:\n        self._BuildOptions = OrderedDict()\n        for CodeBase in (EDKII_NAME, EDK_NAME):\n            RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch, CodeBase]\n            for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n                if Dummy3.upper() != TAB_COMMON:\n                    continue\n                CurKey = (ToolChainFamily, ToolChain, CodeBase)\n                if CurKey not in self._BuildOptions or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    self._BuildOptions[CurKey] = Option\n                elif ' ' + Option not in self._BuildOptions[CurKey]:\n                    self._BuildOptions[CurKey] += ' ' + Option\n    return self._BuildOptions"
        ]
    },
    {
        "func_name": "GetBuildOptionsByPkg",
        "original": "def GetBuildOptionsByPkg(self, Module, ModuleType):\n    local_pkg = os.path.split(Module.LocalPkg())[0]\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if ModuleType not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[ModuleType] = options\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if Dummy2 not in (TAB_COMMON, local_pkg.upper(), 'EDKII'):\n                continue\n            Type = Dummy3\n            if Type.upper() == ModuleType.upper():\n                Key = (ToolChainFamily, ToolChain)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[ModuleType]",
        "mutated": [
            "def GetBuildOptionsByPkg(self, Module, ModuleType):\n    if False:\n        i = 10\n    local_pkg = os.path.split(Module.LocalPkg())[0]\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if ModuleType not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[ModuleType] = options\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if Dummy2 not in (TAB_COMMON, local_pkg.upper(), 'EDKII'):\n                continue\n            Type = Dummy3\n            if Type.upper() == ModuleType.upper():\n                Key = (ToolChainFamily, ToolChain)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[ModuleType]",
            "def GetBuildOptionsByPkg(self, Module, ModuleType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    local_pkg = os.path.split(Module.LocalPkg())[0]\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if ModuleType not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[ModuleType] = options\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if Dummy2 not in (TAB_COMMON, local_pkg.upper(), 'EDKII'):\n                continue\n            Type = Dummy3\n            if Type.upper() == ModuleType.upper():\n                Key = (ToolChainFamily, ToolChain)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[ModuleType]",
            "def GetBuildOptionsByPkg(self, Module, ModuleType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    local_pkg = os.path.split(Module.LocalPkg())[0]\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if ModuleType not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[ModuleType] = options\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if Dummy2 not in (TAB_COMMON, local_pkg.upper(), 'EDKII'):\n                continue\n            Type = Dummy3\n            if Type.upper() == ModuleType.upper():\n                Key = (ToolChainFamily, ToolChain)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[ModuleType]",
            "def GetBuildOptionsByPkg(self, Module, ModuleType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    local_pkg = os.path.split(Module.LocalPkg())[0]\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if ModuleType not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[ModuleType] = options\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if Dummy2 not in (TAB_COMMON, local_pkg.upper(), 'EDKII'):\n                continue\n            Type = Dummy3\n            if Type.upper() == ModuleType.upper():\n                Key = (ToolChainFamily, ToolChain)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[ModuleType]",
            "def GetBuildOptionsByPkg(self, Module, ModuleType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    local_pkg = os.path.split(Module.LocalPkg())[0]\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if ModuleType not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[ModuleType] = options\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            if Dummy2 not in (TAB_COMMON, local_pkg.upper(), 'EDKII'):\n                continue\n            Type = Dummy3\n            if Type.upper() == ModuleType.upper():\n                Key = (ToolChainFamily, ToolChain)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[ModuleType]"
        ]
    },
    {
        "func_name": "GetBuildOptionsByModuleType",
        "original": "def GetBuildOptionsByModuleType(self, Edk, ModuleType):\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if (Edk, ModuleType) not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[Edk, ModuleType] = options\n        DriverType = '%s.%s' % (Edk, ModuleType)\n        CommonDriverType = '%s.%s' % (TAB_COMMON, ModuleType)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            Type = Dummy2 + '.' + Dummy3\n            if Type.upper() == DriverType.upper() or Type.upper() == CommonDriverType.upper():\n                Key = (ToolChainFamily, ToolChain, Edk)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[Edk, ModuleType]",
        "mutated": [
            "def GetBuildOptionsByModuleType(self, Edk, ModuleType):\n    if False:\n        i = 10\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if (Edk, ModuleType) not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[Edk, ModuleType] = options\n        DriverType = '%s.%s' % (Edk, ModuleType)\n        CommonDriverType = '%s.%s' % (TAB_COMMON, ModuleType)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            Type = Dummy2 + '.' + Dummy3\n            if Type.upper() == DriverType.upper() or Type.upper() == CommonDriverType.upper():\n                Key = (ToolChainFamily, ToolChain, Edk)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[Edk, ModuleType]",
            "def GetBuildOptionsByModuleType(self, Edk, ModuleType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if (Edk, ModuleType) not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[Edk, ModuleType] = options\n        DriverType = '%s.%s' % (Edk, ModuleType)\n        CommonDriverType = '%s.%s' % (TAB_COMMON, ModuleType)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            Type = Dummy2 + '.' + Dummy3\n            if Type.upper() == DriverType.upper() or Type.upper() == CommonDriverType.upper():\n                Key = (ToolChainFamily, ToolChain, Edk)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[Edk, ModuleType]",
            "def GetBuildOptionsByModuleType(self, Edk, ModuleType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if (Edk, ModuleType) not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[Edk, ModuleType] = options\n        DriverType = '%s.%s' % (Edk, ModuleType)\n        CommonDriverType = '%s.%s' % (TAB_COMMON, ModuleType)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            Type = Dummy2 + '.' + Dummy3\n            if Type.upper() == DriverType.upper() or Type.upper() == CommonDriverType.upper():\n                Key = (ToolChainFamily, ToolChain, Edk)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[Edk, ModuleType]",
            "def GetBuildOptionsByModuleType(self, Edk, ModuleType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if (Edk, ModuleType) not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[Edk, ModuleType] = options\n        DriverType = '%s.%s' % (Edk, ModuleType)\n        CommonDriverType = '%s.%s' % (TAB_COMMON, ModuleType)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            Type = Dummy2 + '.' + Dummy3\n            if Type.upper() == DriverType.upper() or Type.upper() == CommonDriverType.upper():\n                Key = (ToolChainFamily, ToolChain, Edk)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[Edk, ModuleType]",
            "def GetBuildOptionsByModuleType(self, Edk, ModuleType):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._ModuleTypeOptions is None:\n        self._ModuleTypeOptions = OrderedDict()\n    if (Edk, ModuleType) not in self._ModuleTypeOptions:\n        options = OrderedDict()\n        self._ModuleTypeOptions[Edk, ModuleType] = options\n        DriverType = '%s.%s' % (Edk, ModuleType)\n        CommonDriverType = '%s.%s' % (TAB_COMMON, ModuleType)\n        RecordList = self._RawData[MODEL_META_DATA_BUILD_OPTION, self._Arch]\n        for (ToolChainFamily, ToolChain, Option, Dummy1, Dummy2, Dummy3, Dummy4, Dummy5) in RecordList:\n            Type = Dummy2 + '.' + Dummy3\n            if Type.upper() == DriverType.upper() or Type.upper() == CommonDriverType.upper():\n                Key = (ToolChainFamily, ToolChain, Edk)\n                if Key not in options or not ToolChain.endswith('_FLAGS') or Option.startswith('='):\n                    options[Key] = Option\n                elif ' ' + Option not in options[Key]:\n                    options[Key] += ' ' + Option\n    return self._ModuleTypeOptions[Edk, ModuleType]"
        ]
    },
    {
        "func_name": "GetStructurePcdInfo",
        "original": "@staticmethod\ndef GetStructurePcdInfo(PcdSet):\n    structure_pcd_data = defaultdict(list)\n    for item in PcdSet:\n        structure_pcd_data[item[0], item[1]].append(item)\n    return structure_pcd_data",
        "mutated": [
            "@staticmethod\ndef GetStructurePcdInfo(PcdSet):\n    if False:\n        i = 10\n    structure_pcd_data = defaultdict(list)\n    for item in PcdSet:\n        structure_pcd_data[item[0], item[1]].append(item)\n    return structure_pcd_data",
            "@staticmethod\ndef GetStructurePcdInfo(PcdSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    structure_pcd_data = defaultdict(list)\n    for item in PcdSet:\n        structure_pcd_data[item[0], item[1]].append(item)\n    return structure_pcd_data",
            "@staticmethod\ndef GetStructurePcdInfo(PcdSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    structure_pcd_data = defaultdict(list)\n    for item in PcdSet:\n        structure_pcd_data[item[0], item[1]].append(item)\n    return structure_pcd_data",
            "@staticmethod\ndef GetStructurePcdInfo(PcdSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    structure_pcd_data = defaultdict(list)\n    for item in PcdSet:\n        structure_pcd_data[item[0], item[1]].append(item)\n    return structure_pcd_data",
            "@staticmethod\ndef GetStructurePcdInfo(PcdSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    structure_pcd_data = defaultdict(list)\n    for item in PcdSet:\n        structure_pcd_data[item[0], item[1]].append(item)\n    return structure_pcd_data"
        ]
    },
    {
        "func_name": "OverrideByFdf",
        "original": "@staticmethod\ndef OverrideByFdf(StruPcds, workspace):\n    if GlobalData.gFdfParser is None:\n        return StruPcds\n    StructurePcdInFdf = OrderedDict()\n    fdfpcd = GlobalData.gFdfParser.Profile.PcdDict\n    fdfpcdlocation = GlobalData.gFdfParser.Profile.PcdLocalDict\n    for item in fdfpcd:\n        if len(item[2]) and (item[0], item[1]) in StruPcds:\n            StructurePcdInFdf[item[1], item[0], item[2]] = fdfpcd[item]\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInFdf}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInFdf:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInFdf[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromFdf:\n                Pcd.PcdFieldValueFromFdf[field] = ['', '', '']\n            Pcd.PcdFieldValueFromFdf[field][0] = FieldValues[field]\n            Pcd.PcdFieldValueFromFdf[field][1] = os.path.relpath(fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][0], workspace)\n            Pcd.PcdFieldValueFromFdf[field][2] = fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][1]\n    return StruPcds",
        "mutated": [
            "@staticmethod\ndef OverrideByFdf(StruPcds, workspace):\n    if False:\n        i = 10\n    if GlobalData.gFdfParser is None:\n        return StruPcds\n    StructurePcdInFdf = OrderedDict()\n    fdfpcd = GlobalData.gFdfParser.Profile.PcdDict\n    fdfpcdlocation = GlobalData.gFdfParser.Profile.PcdLocalDict\n    for item in fdfpcd:\n        if len(item[2]) and (item[0], item[1]) in StruPcds:\n            StructurePcdInFdf[item[1], item[0], item[2]] = fdfpcd[item]\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInFdf}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInFdf:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInFdf[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromFdf:\n                Pcd.PcdFieldValueFromFdf[field] = ['', '', '']\n            Pcd.PcdFieldValueFromFdf[field][0] = FieldValues[field]\n            Pcd.PcdFieldValueFromFdf[field][1] = os.path.relpath(fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][0], workspace)\n            Pcd.PcdFieldValueFromFdf[field][2] = fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][1]\n    return StruPcds",
            "@staticmethod\ndef OverrideByFdf(StruPcds, workspace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if GlobalData.gFdfParser is None:\n        return StruPcds\n    StructurePcdInFdf = OrderedDict()\n    fdfpcd = GlobalData.gFdfParser.Profile.PcdDict\n    fdfpcdlocation = GlobalData.gFdfParser.Profile.PcdLocalDict\n    for item in fdfpcd:\n        if len(item[2]) and (item[0], item[1]) in StruPcds:\n            StructurePcdInFdf[item[1], item[0], item[2]] = fdfpcd[item]\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInFdf}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInFdf:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInFdf[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromFdf:\n                Pcd.PcdFieldValueFromFdf[field] = ['', '', '']\n            Pcd.PcdFieldValueFromFdf[field][0] = FieldValues[field]\n            Pcd.PcdFieldValueFromFdf[field][1] = os.path.relpath(fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][0], workspace)\n            Pcd.PcdFieldValueFromFdf[field][2] = fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][1]\n    return StruPcds",
            "@staticmethod\ndef OverrideByFdf(StruPcds, workspace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if GlobalData.gFdfParser is None:\n        return StruPcds\n    StructurePcdInFdf = OrderedDict()\n    fdfpcd = GlobalData.gFdfParser.Profile.PcdDict\n    fdfpcdlocation = GlobalData.gFdfParser.Profile.PcdLocalDict\n    for item in fdfpcd:\n        if len(item[2]) and (item[0], item[1]) in StruPcds:\n            StructurePcdInFdf[item[1], item[0], item[2]] = fdfpcd[item]\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInFdf}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInFdf:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInFdf[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromFdf:\n                Pcd.PcdFieldValueFromFdf[field] = ['', '', '']\n            Pcd.PcdFieldValueFromFdf[field][0] = FieldValues[field]\n            Pcd.PcdFieldValueFromFdf[field][1] = os.path.relpath(fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][0], workspace)\n            Pcd.PcdFieldValueFromFdf[field][2] = fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][1]\n    return StruPcds",
            "@staticmethod\ndef OverrideByFdf(StruPcds, workspace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if GlobalData.gFdfParser is None:\n        return StruPcds\n    StructurePcdInFdf = OrderedDict()\n    fdfpcd = GlobalData.gFdfParser.Profile.PcdDict\n    fdfpcdlocation = GlobalData.gFdfParser.Profile.PcdLocalDict\n    for item in fdfpcd:\n        if len(item[2]) and (item[0], item[1]) in StruPcds:\n            StructurePcdInFdf[item[1], item[0], item[2]] = fdfpcd[item]\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInFdf}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInFdf:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInFdf[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromFdf:\n                Pcd.PcdFieldValueFromFdf[field] = ['', '', '']\n            Pcd.PcdFieldValueFromFdf[field][0] = FieldValues[field]\n            Pcd.PcdFieldValueFromFdf[field][1] = os.path.relpath(fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][0], workspace)\n            Pcd.PcdFieldValueFromFdf[field][2] = fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][1]\n    return StruPcds",
            "@staticmethod\ndef OverrideByFdf(StruPcds, workspace):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if GlobalData.gFdfParser is None:\n        return StruPcds\n    StructurePcdInFdf = OrderedDict()\n    fdfpcd = GlobalData.gFdfParser.Profile.PcdDict\n    fdfpcdlocation = GlobalData.gFdfParser.Profile.PcdLocalDict\n    for item in fdfpcd:\n        if len(item[2]) and (item[0], item[1]) in StruPcds:\n            StructurePcdInFdf[item[1], item[0], item[2]] = fdfpcd[item]\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInFdf}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInFdf:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInFdf[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromFdf:\n                Pcd.PcdFieldValueFromFdf[field] = ['', '', '']\n            Pcd.PcdFieldValueFromFdf[field][0] = FieldValues[field]\n            Pcd.PcdFieldValueFromFdf[field][1] = os.path.relpath(fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][0], workspace)\n            Pcd.PcdFieldValueFromFdf[field][2] = fdfpcdlocation[Pcd.TokenCName, Pcd.TokenSpaceGuidCName, field][1]\n    return StruPcds"
        ]
    },
    {
        "func_name": "OverrideByComm",
        "original": "@staticmethod\ndef OverrideByComm(StruPcds):\n    StructurePcdInCom = OrderedDict()\n    for item in GlobalData.BuildOptionPcd:\n        if len(item) == 5 and (item[1], item[0]) in StruPcds:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInCom}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInCom:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInCom[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromComm:\n                Pcd.PcdFieldValueFromComm[field] = ['', '', '']\n            Pcd.PcdFieldValueFromComm[field][0] = FieldValues[field][0]\n            Pcd.PcdFieldValueFromComm[field][1] = FieldValues[field][1][0]\n            Pcd.PcdFieldValueFromComm[field][2] = FieldValues[field][1][1]\n    return StruPcds",
        "mutated": [
            "@staticmethod\ndef OverrideByComm(StruPcds):\n    if False:\n        i = 10\n    StructurePcdInCom = OrderedDict()\n    for item in GlobalData.BuildOptionPcd:\n        if len(item) == 5 and (item[1], item[0]) in StruPcds:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInCom}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInCom:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInCom[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromComm:\n                Pcd.PcdFieldValueFromComm[field] = ['', '', '']\n            Pcd.PcdFieldValueFromComm[field][0] = FieldValues[field][0]\n            Pcd.PcdFieldValueFromComm[field][1] = FieldValues[field][1][0]\n            Pcd.PcdFieldValueFromComm[field][2] = FieldValues[field][1][1]\n    return StruPcds",
            "@staticmethod\ndef OverrideByComm(StruPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    StructurePcdInCom = OrderedDict()\n    for item in GlobalData.BuildOptionPcd:\n        if len(item) == 5 and (item[1], item[0]) in StruPcds:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInCom}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInCom:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInCom[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromComm:\n                Pcd.PcdFieldValueFromComm[field] = ['', '', '']\n            Pcd.PcdFieldValueFromComm[field][0] = FieldValues[field][0]\n            Pcd.PcdFieldValueFromComm[field][1] = FieldValues[field][1][0]\n            Pcd.PcdFieldValueFromComm[field][2] = FieldValues[field][1][1]\n    return StruPcds",
            "@staticmethod\ndef OverrideByComm(StruPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    StructurePcdInCom = OrderedDict()\n    for item in GlobalData.BuildOptionPcd:\n        if len(item) == 5 and (item[1], item[0]) in StruPcds:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInCom}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInCom:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInCom[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromComm:\n                Pcd.PcdFieldValueFromComm[field] = ['', '', '']\n            Pcd.PcdFieldValueFromComm[field][0] = FieldValues[field][0]\n            Pcd.PcdFieldValueFromComm[field][1] = FieldValues[field][1][0]\n            Pcd.PcdFieldValueFromComm[field][2] = FieldValues[field][1][1]\n    return StruPcds",
            "@staticmethod\ndef OverrideByComm(StruPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    StructurePcdInCom = OrderedDict()\n    for item in GlobalData.BuildOptionPcd:\n        if len(item) == 5 and (item[1], item[0]) in StruPcds:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInCom}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInCom:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInCom[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromComm:\n                Pcd.PcdFieldValueFromComm[field] = ['', '', '']\n            Pcd.PcdFieldValueFromComm[field][0] = FieldValues[field][0]\n            Pcd.PcdFieldValueFromComm[field][1] = FieldValues[field][1][0]\n            Pcd.PcdFieldValueFromComm[field][2] = FieldValues[field][1][1]\n    return StruPcds",
            "@staticmethod\ndef OverrideByComm(StruPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    StructurePcdInCom = OrderedDict()\n    for item in GlobalData.BuildOptionPcd:\n        if len(item) == 5 and (item[1], item[0]) in StruPcds:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n    GlobalPcds = {(item[0], item[1]) for item in StructurePcdInCom}\n    for Pcd in StruPcds.values():\n        if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) not in GlobalPcds:\n            continue\n        FieldValues = OrderedDict()\n        for item in StructurePcdInCom:\n            if (Pcd.TokenSpaceGuidCName, Pcd.TokenCName) == (item[0], item[1]) and item[2]:\n                FieldValues[item[2]] = StructurePcdInCom[item]\n        for field in FieldValues:\n            if field not in Pcd.PcdFieldValueFromComm:\n                Pcd.PcdFieldValueFromComm[field] = ['', '', '']\n            Pcd.PcdFieldValueFromComm[field][0] = FieldValues[field][0]\n            Pcd.PcdFieldValueFromComm[field][1] = FieldValues[field][1][0]\n            Pcd.PcdFieldValueFromComm[field][2] = FieldValues[field][1][1]\n    return StruPcds"
        ]
    },
    {
        "func_name": "CheckStructureInComm",
        "original": "def CheckStructureInComm(commpcds):\n    if not commpcds:\n        return False\n    if len(commpcds[0]) == 5:\n        return True\n    return False",
        "mutated": [
            "def CheckStructureInComm(commpcds):\n    if False:\n        i = 10\n    if not commpcds:\n        return False\n    if len(commpcds[0]) == 5:\n        return True\n    return False",
            "def CheckStructureInComm(commpcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not commpcds:\n        return False\n    if len(commpcds[0]) == 5:\n        return True\n    return False",
            "def CheckStructureInComm(commpcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not commpcds:\n        return False\n    if len(commpcds[0]) == 5:\n        return True\n    return False",
            "def CheckStructureInComm(commpcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not commpcds:\n        return False\n    if len(commpcds[0]) == 5:\n        return True\n    return False",
            "def CheckStructureInComm(commpcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not commpcds:\n        return False\n    if len(commpcds[0]) == 5:\n        return True\n    return False"
        ]
    },
    {
        "func_name": "OverrideByCommOverAll",
        "original": "def OverrideByCommOverAll(self, AllPcds):\n\n    def CheckStructureInComm(commpcds):\n        if not commpcds:\n            return False\n        if len(commpcds[0]) == 5:\n            return True\n        return False\n    NoFiledValues = OrderedDict()\n    if CheckStructureInComm(GlobalData.BuildOptionPcd):\n        StructurePcdInCom = OrderedDict()\n        for item in GlobalData.BuildOptionPcd:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n        for item in StructurePcdInCom:\n            if not item[2]:\n                NoFiledValues[item[0], item[1]] = StructurePcdInCom[item]\n    else:\n        for item in GlobalData.BuildOptionPcd:\n            NoFiledValues[item[0], item[1]] = [item[2]]\n    for (Guid, Name) in NoFiledValues:\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n            else:\n                Pcd.PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                Pcd.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                    else:\n                        SkuInfo.HiiDefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromComm = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid].SkuInfoList = {TAB_DEFAULT: SkuInfoClass(TAB_DEFAULT, self.SkuIds[TAB_DEFAULT][0], '', '', '', '', '', NoFiledValues[Guid, Name][0])}\n    return AllPcds",
        "mutated": [
            "def OverrideByCommOverAll(self, AllPcds):\n    if False:\n        i = 10\n\n    def CheckStructureInComm(commpcds):\n        if not commpcds:\n            return False\n        if len(commpcds[0]) == 5:\n            return True\n        return False\n    NoFiledValues = OrderedDict()\n    if CheckStructureInComm(GlobalData.BuildOptionPcd):\n        StructurePcdInCom = OrderedDict()\n        for item in GlobalData.BuildOptionPcd:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n        for item in StructurePcdInCom:\n            if not item[2]:\n                NoFiledValues[item[0], item[1]] = StructurePcdInCom[item]\n    else:\n        for item in GlobalData.BuildOptionPcd:\n            NoFiledValues[item[0], item[1]] = [item[2]]\n    for (Guid, Name) in NoFiledValues:\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n            else:\n                Pcd.PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                Pcd.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                    else:\n                        SkuInfo.HiiDefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromComm = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid].SkuInfoList = {TAB_DEFAULT: SkuInfoClass(TAB_DEFAULT, self.SkuIds[TAB_DEFAULT][0], '', '', '', '', '', NoFiledValues[Guid, Name][0])}\n    return AllPcds",
            "def OverrideByCommOverAll(self, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def CheckStructureInComm(commpcds):\n        if not commpcds:\n            return False\n        if len(commpcds[0]) == 5:\n            return True\n        return False\n    NoFiledValues = OrderedDict()\n    if CheckStructureInComm(GlobalData.BuildOptionPcd):\n        StructurePcdInCom = OrderedDict()\n        for item in GlobalData.BuildOptionPcd:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n        for item in StructurePcdInCom:\n            if not item[2]:\n                NoFiledValues[item[0], item[1]] = StructurePcdInCom[item]\n    else:\n        for item in GlobalData.BuildOptionPcd:\n            NoFiledValues[item[0], item[1]] = [item[2]]\n    for (Guid, Name) in NoFiledValues:\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n            else:\n                Pcd.PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                Pcd.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                    else:\n                        SkuInfo.HiiDefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromComm = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid].SkuInfoList = {TAB_DEFAULT: SkuInfoClass(TAB_DEFAULT, self.SkuIds[TAB_DEFAULT][0], '', '', '', '', '', NoFiledValues[Guid, Name][0])}\n    return AllPcds",
            "def OverrideByCommOverAll(self, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def CheckStructureInComm(commpcds):\n        if not commpcds:\n            return False\n        if len(commpcds[0]) == 5:\n            return True\n        return False\n    NoFiledValues = OrderedDict()\n    if CheckStructureInComm(GlobalData.BuildOptionPcd):\n        StructurePcdInCom = OrderedDict()\n        for item in GlobalData.BuildOptionPcd:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n        for item in StructurePcdInCom:\n            if not item[2]:\n                NoFiledValues[item[0], item[1]] = StructurePcdInCom[item]\n    else:\n        for item in GlobalData.BuildOptionPcd:\n            NoFiledValues[item[0], item[1]] = [item[2]]\n    for (Guid, Name) in NoFiledValues:\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n            else:\n                Pcd.PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                Pcd.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                    else:\n                        SkuInfo.HiiDefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromComm = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid].SkuInfoList = {TAB_DEFAULT: SkuInfoClass(TAB_DEFAULT, self.SkuIds[TAB_DEFAULT][0], '', '', '', '', '', NoFiledValues[Guid, Name][0])}\n    return AllPcds",
            "def OverrideByCommOverAll(self, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def CheckStructureInComm(commpcds):\n        if not commpcds:\n            return False\n        if len(commpcds[0]) == 5:\n            return True\n        return False\n    NoFiledValues = OrderedDict()\n    if CheckStructureInComm(GlobalData.BuildOptionPcd):\n        StructurePcdInCom = OrderedDict()\n        for item in GlobalData.BuildOptionPcd:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n        for item in StructurePcdInCom:\n            if not item[2]:\n                NoFiledValues[item[0], item[1]] = StructurePcdInCom[item]\n    else:\n        for item in GlobalData.BuildOptionPcd:\n            NoFiledValues[item[0], item[1]] = [item[2]]\n    for (Guid, Name) in NoFiledValues:\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n            else:\n                Pcd.PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                Pcd.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                    else:\n                        SkuInfo.HiiDefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromComm = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid].SkuInfoList = {TAB_DEFAULT: SkuInfoClass(TAB_DEFAULT, self.SkuIds[TAB_DEFAULT][0], '', '', '', '', '', NoFiledValues[Guid, Name][0])}\n    return AllPcds",
            "def OverrideByCommOverAll(self, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def CheckStructureInComm(commpcds):\n        if not commpcds:\n            return False\n        if len(commpcds[0]) == 5:\n            return True\n        return False\n    NoFiledValues = OrderedDict()\n    if CheckStructureInComm(GlobalData.BuildOptionPcd):\n        StructurePcdInCom = OrderedDict()\n        for item in GlobalData.BuildOptionPcd:\n            StructurePcdInCom[item[0], item[1], item[2]] = (item[3], item[4])\n        for item in StructurePcdInCom:\n            if not item[2]:\n                NoFiledValues[item[0], item[1]] = StructurePcdInCom[item]\n    else:\n        for item in GlobalData.BuildOptionPcd:\n            NoFiledValues[item[0], item[1]] = [item[2]]\n    for (Guid, Name) in NoFiledValues:\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n            else:\n                Pcd.PcdValueFromComm = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                Pcd.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                    else:\n                        SkuInfo.HiiDefaultValue = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = NoFiledValues[Pcd.TokenSpaceGuidCName, Pcd.TokenCName][0]\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromComm = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = NoFiledValues[Guid, Name][0]\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX]]:\n                    self._Pcds[Name, Guid].SkuInfoList = {TAB_DEFAULT: SkuInfoClass(TAB_DEFAULT, self.SkuIds[TAB_DEFAULT][0], '', '', '', '', '', NoFiledValues[Guid, Name][0])}\n    return AllPcds"
        ]
    },
    {
        "func_name": "OverrideByFdfOverAll",
        "original": "def OverrideByFdfOverAll(self, AllPcds):\n    if GlobalData.gFdfParser is None:\n        return AllPcds\n    NoFiledValues = GlobalData.gFdfParser.Profile.PcdDict\n    for (Name, Guid, Field) in NoFiledValues:\n        if len(Field):\n            continue\n        Value = NoFiledValues[Name, Guid, Field]\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = Value\n            else:\n                Pcd.PcdValueFromComm = Value\n                Pcd.DefaultValue = Value\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = Value\n                    else:\n                        SkuInfo.HiiDefaultValue = Value\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = Value\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromFdf = Value\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = Value\n    return AllPcds",
        "mutated": [
            "def OverrideByFdfOverAll(self, AllPcds):\n    if False:\n        i = 10\n    if GlobalData.gFdfParser is None:\n        return AllPcds\n    NoFiledValues = GlobalData.gFdfParser.Profile.PcdDict\n    for (Name, Guid, Field) in NoFiledValues:\n        if len(Field):\n            continue\n        Value = NoFiledValues[Name, Guid, Field]\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = Value\n            else:\n                Pcd.PcdValueFromComm = Value\n                Pcd.DefaultValue = Value\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = Value\n                    else:\n                        SkuInfo.HiiDefaultValue = Value\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = Value\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromFdf = Value\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = Value\n    return AllPcds",
            "def OverrideByFdfOverAll(self, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if GlobalData.gFdfParser is None:\n        return AllPcds\n    NoFiledValues = GlobalData.gFdfParser.Profile.PcdDict\n    for (Name, Guid, Field) in NoFiledValues:\n        if len(Field):\n            continue\n        Value = NoFiledValues[Name, Guid, Field]\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = Value\n            else:\n                Pcd.PcdValueFromComm = Value\n                Pcd.DefaultValue = Value\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = Value\n                    else:\n                        SkuInfo.HiiDefaultValue = Value\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = Value\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromFdf = Value\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = Value\n    return AllPcds",
            "def OverrideByFdfOverAll(self, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if GlobalData.gFdfParser is None:\n        return AllPcds\n    NoFiledValues = GlobalData.gFdfParser.Profile.PcdDict\n    for (Name, Guid, Field) in NoFiledValues:\n        if len(Field):\n            continue\n        Value = NoFiledValues[Name, Guid, Field]\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = Value\n            else:\n                Pcd.PcdValueFromComm = Value\n                Pcd.DefaultValue = Value\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = Value\n                    else:\n                        SkuInfo.HiiDefaultValue = Value\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = Value\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromFdf = Value\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = Value\n    return AllPcds",
            "def OverrideByFdfOverAll(self, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if GlobalData.gFdfParser is None:\n        return AllPcds\n    NoFiledValues = GlobalData.gFdfParser.Profile.PcdDict\n    for (Name, Guid, Field) in NoFiledValues:\n        if len(Field):\n            continue\n        Value = NoFiledValues[Name, Guid, Field]\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = Value\n            else:\n                Pcd.PcdValueFromComm = Value\n                Pcd.DefaultValue = Value\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = Value\n                    else:\n                        SkuInfo.HiiDefaultValue = Value\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = Value\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromFdf = Value\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = Value\n    return AllPcds",
            "def OverrideByFdfOverAll(self, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if GlobalData.gFdfParser is None:\n        return AllPcds\n    NoFiledValues = GlobalData.gFdfParser.Profile.PcdDict\n    for (Name, Guid, Field) in NoFiledValues:\n        if len(Field):\n            continue\n        Value = NoFiledValues[Name, Guid, Field]\n        if (Name, Guid) in AllPcds:\n            Pcd = AllPcds.get((Name, Guid))\n            if isinstance(self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName), None), StructurePcd):\n                self._DecPcds.get((Pcd.TokenCName, Pcd.TokenSpaceGuidCName)).PcdValueFromComm = Value\n            else:\n                Pcd.PcdValueFromComm = Value\n                Pcd.DefaultValue = Value\n                for sku in Pcd.SkuInfoList:\n                    SkuInfo = Pcd.SkuInfoList[sku]\n                    if SkuInfo.DefaultValue:\n                        SkuInfo.DefaultValue = Value\n                    else:\n                        SkuInfo.HiiDefaultValue = Value\n                        for defaultstore in SkuInfo.DefaultStoreDict:\n                            SkuInfo.DefaultStoreDict[defaultstore] = Value\n                if Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII]]:\n                    if Pcd.DatumType == TAB_VOID:\n                        if not Pcd.MaxDatumSize:\n                            Pcd.MaxDatumSize = '0'\n                        CurrentSize = int(Pcd.MaxDatumSize, 16) if Pcd.MaxDatumSize.upper().startswith('0X') else int(Pcd.MaxDatumSize)\n                        OptionSize = len(StringToArray(Pcd.PcdValueFromComm).split(','))\n                        MaxSize = max(CurrentSize, OptionSize)\n                        Pcd.MaxDatumSize = str(MaxSize)\n        else:\n            PcdInDec = self.DecPcds.get((Name, Guid))\n            if PcdInDec:\n                PcdInDec.PcdValueFromFdf = Value\n                if PcdInDec.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE], self._PCD_TYPE_STRING_[MODEL_PCD_FEATURE_FLAG]]:\n                    self._Pcds[Name, Guid] = copy.deepcopy(PcdInDec)\n                    self._Pcds[Name, Guid].DefaultValue = Value\n    return AllPcds"
        ]
    },
    {
        "func_name": "ParsePcdNameStruct",
        "original": "def ParsePcdNameStruct(self, NamePart1, NamePart2):\n    TokenSpaceCName = PcdCName = DimensionAttr = Field = ''\n    if '.' in NamePart1:\n        (TokenSpaceCName, TempPcdCName) = NamePart1.split('.')\n        if '[' in TempPcdCName:\n            PcdCName = TempPcdCName[:TempPcdCName.index('[')]\n            DimensionAttr = TempPcdCName[TempPcdCName.index('['):]\n        else:\n            PcdCName = TempPcdCName\n        Field = NamePart2\n    else:\n        TokenSpaceCName = NamePart1\n        if '[' in NamePart2:\n            PcdCName = NamePart2[:NamePart2.index('[')]\n            DimensionAttr = NamePart2[NamePart2.index('['):]\n        else:\n            PcdCName = NamePart2\n    return (TokenSpaceCName, PcdCName, DimensionAttr, Field)",
        "mutated": [
            "def ParsePcdNameStruct(self, NamePart1, NamePart2):\n    if False:\n        i = 10\n    TokenSpaceCName = PcdCName = DimensionAttr = Field = ''\n    if '.' in NamePart1:\n        (TokenSpaceCName, TempPcdCName) = NamePart1.split('.')\n        if '[' in TempPcdCName:\n            PcdCName = TempPcdCName[:TempPcdCName.index('[')]\n            DimensionAttr = TempPcdCName[TempPcdCName.index('['):]\n        else:\n            PcdCName = TempPcdCName\n        Field = NamePart2\n    else:\n        TokenSpaceCName = NamePart1\n        if '[' in NamePart2:\n            PcdCName = NamePart2[:NamePart2.index('[')]\n            DimensionAttr = NamePart2[NamePart2.index('['):]\n        else:\n            PcdCName = NamePart2\n    return (TokenSpaceCName, PcdCName, DimensionAttr, Field)",
            "def ParsePcdNameStruct(self, NamePart1, NamePart2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    TokenSpaceCName = PcdCName = DimensionAttr = Field = ''\n    if '.' in NamePart1:\n        (TokenSpaceCName, TempPcdCName) = NamePart1.split('.')\n        if '[' in TempPcdCName:\n            PcdCName = TempPcdCName[:TempPcdCName.index('[')]\n            DimensionAttr = TempPcdCName[TempPcdCName.index('['):]\n        else:\n            PcdCName = TempPcdCName\n        Field = NamePart2\n    else:\n        TokenSpaceCName = NamePart1\n        if '[' in NamePart2:\n            PcdCName = NamePart2[:NamePart2.index('[')]\n            DimensionAttr = NamePart2[NamePart2.index('['):]\n        else:\n            PcdCName = NamePart2\n    return (TokenSpaceCName, PcdCName, DimensionAttr, Field)",
            "def ParsePcdNameStruct(self, NamePart1, NamePart2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    TokenSpaceCName = PcdCName = DimensionAttr = Field = ''\n    if '.' in NamePart1:\n        (TokenSpaceCName, TempPcdCName) = NamePart1.split('.')\n        if '[' in TempPcdCName:\n            PcdCName = TempPcdCName[:TempPcdCName.index('[')]\n            DimensionAttr = TempPcdCName[TempPcdCName.index('['):]\n        else:\n            PcdCName = TempPcdCName\n        Field = NamePart2\n    else:\n        TokenSpaceCName = NamePart1\n        if '[' in NamePart2:\n            PcdCName = NamePart2[:NamePart2.index('[')]\n            DimensionAttr = NamePart2[NamePart2.index('['):]\n        else:\n            PcdCName = NamePart2\n    return (TokenSpaceCName, PcdCName, DimensionAttr, Field)",
            "def ParsePcdNameStruct(self, NamePart1, NamePart2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    TokenSpaceCName = PcdCName = DimensionAttr = Field = ''\n    if '.' in NamePart1:\n        (TokenSpaceCName, TempPcdCName) = NamePart1.split('.')\n        if '[' in TempPcdCName:\n            PcdCName = TempPcdCName[:TempPcdCName.index('[')]\n            DimensionAttr = TempPcdCName[TempPcdCName.index('['):]\n        else:\n            PcdCName = TempPcdCName\n        Field = NamePart2\n    else:\n        TokenSpaceCName = NamePart1\n        if '[' in NamePart2:\n            PcdCName = NamePart2[:NamePart2.index('[')]\n            DimensionAttr = NamePart2[NamePart2.index('['):]\n        else:\n            PcdCName = NamePart2\n    return (TokenSpaceCName, PcdCName, DimensionAttr, Field)",
            "def ParsePcdNameStruct(self, NamePart1, NamePart2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    TokenSpaceCName = PcdCName = DimensionAttr = Field = ''\n    if '.' in NamePart1:\n        (TokenSpaceCName, TempPcdCName) = NamePart1.split('.')\n        if '[' in TempPcdCName:\n            PcdCName = TempPcdCName[:TempPcdCName.index('[')]\n            DimensionAttr = TempPcdCName[TempPcdCName.index('['):]\n        else:\n            PcdCName = TempPcdCName\n        Field = NamePart2\n    else:\n        TokenSpaceCName = NamePart1\n        if '[' in NamePart2:\n            PcdCName = NamePart2[:NamePart2.index('[')]\n            DimensionAttr = NamePart2[NamePart2.index('['):]\n        else:\n            PcdCName = NamePart2\n    return (TokenSpaceCName, PcdCName, DimensionAttr, Field)"
        ]
    },
    {
        "func_name": "UpdateStructuredPcds",
        "original": "def UpdateStructuredPcds(self, TypeList, AllPcds):\n    DynamicPcdType = [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]\n    Pcds = AllPcds\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    SkuIds = self.SkuIds\n    self.SkuIdMgr.AvailableSkuIdSet.update({TAB_DEFAULT: 0})\n    DefaultStores = {storename for pcdobj in AllPcds.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict}\n    DefaultStores.add(TAB_DEFAULT_STORES_DEFAULT)\n    S_PcdSet = []\n    RecordList = []\n    for Type in TypeList:\n        RecordList.extend(self._RawData[Type, self._Arch])\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, default_store, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        default_store = default_store.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in SkuIds:\n            continue\n        (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n        pcd_in_dec = self._DecPcds.get((PCName, TCName), None)\n        if pcd_in_dec is None:\n            EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n        if SkuName in SkuIds and ('.' in TokenSpaceGuid or '[' in PcdCName):\n            if not isinstance(pcd_in_dec, StructurePcd):\n                EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) is not declared as Structure PCD in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n            S_PcdSet.append([TCName, PCName, DimensionAttr, Field, SkuName, default_store, Dummy5, AnalyzePcdExpression(Setting)[0]])\n    ModuleScopeOverallValue = {}\n    for m in self.Modules.values():\n        mguid = m.Guid\n        if m.StrPcdSet:\n            S_PcdSet.extend(m.StrPcdSet)\n            mguid = m.StrPcdSet[0][4]\n        for (PCName, TCName) in m.StrPcdOverallValue:\n            (Value, dsc_file, lineNo) = m.StrPcdOverallValue[PCName, TCName]\n            ModuleScopeOverallValue.setdefault((PCName, TCName), {})[mguid] = (Value, dsc_file, lineNo)\n    StrPcdSet = DscBuildData.GetStructurePcdInfo(S_PcdSet)\n    S_pcd_set = OrderedDict()\n    for str_pcd in StrPcdSet:\n        str_pcd_obj = Pcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_dec = self._DecPcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_obj_str = StructurePcd()\n        str_pcd_obj_str.copy(str_pcd_dec)\n        if str_pcd_obj:\n            str_pcd_obj_str.copy(str_pcd_obj)\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n            else:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n        for str_pcd_data in StrPcdSet[str_pcd]:\n            if str_pcd_data[4] in SkuIds:\n                str_pcd_obj_str.AddOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), TAB_DEFAULT if str_pcd_data[4] == TAB_COMMON else str_pcd_data[4], TAB_DEFAULT_STORES_DEFAULT if str_pcd_data[5] == TAB_COMMON else str_pcd_data[5], self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n            elif GlobalData.gGuidPattern.match(str_pcd_data[4]):\n                str_pcd_obj_str.AddComponentOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), str_pcd_data[4].replace('-', 'S'), self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n                PcdComponentValue = ModuleScopeOverallValue.get((str_pcd_obj_str.TokenCName, str_pcd_obj_str.TokenSpaceGuidCName))\n                for module_guid in PcdComponentValue:\n                    str_pcd_obj_str.PcdValueFromComponents[module_guid.replace('-', 'S')] = PcdComponentValue[module_guid]\n        S_pcd_set[str_pcd[1], str_pcd[0]] = str_pcd_obj_str\n    for Pcd in self.DecPcds:\n        if isinstance(self._DecPcds[Pcd], StructurePcd):\n            if Pcd not in S_pcd_set:\n                str_pcd_obj_str = StructurePcd()\n                str_pcd_obj_str.copy(self._DecPcds[Pcd])\n                str_pcd_obj = Pcds.get(Pcd, None)\n                if str_pcd_obj:\n                    str_pcd_obj_str.copy(str_pcd_obj)\n                    if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                    else:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                S_pcd_set[Pcd] = str_pcd_obj_str\n    if S_pcd_set:\n        GlobalData.gStructurePcd[self.Arch] = S_pcd_set.copy()\n    self.FilterStrcturePcd(S_pcd_set)\n    for stru_pcd in S_pcd_set.values():\n        for skuid in SkuIds:\n            if skuid in stru_pcd.SkuOverrideValues:\n                continue\n            nextskuid = self.SkuIdMgr.GetNextSkuId(skuid)\n            NoDefault = False\n            if skuid not in stru_pcd.SkuOverrideValues:\n                while nextskuid not in stru_pcd.SkuOverrideValues:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                stru_pcd.SkuOverrideValues[skuid] = copy.deepcopy(stru_pcd.SkuOverrideValues[nextskuid]) if not NoDefault else copy.deepcopy({defaultstorename: stru_pcd.DefaultValues for defaultstorename in DefaultStores} if DefaultStores else {})\n                if not NoDefault:\n                    stru_pcd.ValueChain.add((skuid, ''))\n            if 'DEFAULT' in stru_pcd.SkuOverrideValues and (not GlobalData.gPcdSkuOverrides.get((stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName))):\n                GlobalData.gPcdSkuOverrides.update({(stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName): {'DEFAULT': stru_pcd.SkuOverrideValues['DEFAULT']}})\n        if stru_pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in SkuIds:\n                nextskuid = skuid\n                NoDefault = False\n                if skuid not in stru_pcd.SkuOverrideValues:\n                    while nextskuid not in stru_pcd.SkuOverrideValues:\n                        if nextskuid == TAB_DEFAULT:\n                            NoDefault = True\n                            break\n                        nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                if NoDefault:\n                    continue\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in stru_pcd.SkuOverrideValues[nextskuid]))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                for defaultstoreid in DefaultStores:\n                    if defaultstoreid not in stru_pcd.SkuOverrideValues[skuid]:\n                        stru_pcd.SkuOverrideValues[skuid][defaultstoreid] = CopyDict(stru_pcd.SkuOverrideValues[nextskuid][mindefaultstorename])\n                        stru_pcd.ValueChain.add((skuid, defaultstoreid))\n    S_pcd_set = DscBuildData.OverrideByFdf(S_pcd_set, self.WorkspaceDir)\n    S_pcd_set = DscBuildData.OverrideByComm(S_pcd_set)\n    Str_Pcd_Values = self.GenerateByteArrayValue(S_pcd_set)\n    if Str_Pcd_Values:\n        for (skuname, StoreName, PcdGuid, PcdName, PcdValue) in Str_Pcd_Values:\n            str_pcd_obj = S_pcd_set.get((PcdName, PcdGuid))\n            if str_pcd_obj is None:\n                print(PcdName, PcdGuid)\n                raise\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                if skuname not in str_pcd_obj.SkuInfoList:\n                    str_pcd_obj.SkuInfoList[skuname] = SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], HiiDefaultValue=PcdValue, DefaultStore={StoreName: PcdValue})\n                else:\n                    str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue = PcdValue\n                    str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.update({StoreName: PcdValue})\n            elif str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n                if skuname in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n                    str_pcd_obj.DefaultValue = PcdValue\n                else:\n                    moduleguid = skuname.replace('S', '-')\n                    if GlobalData.gGuidPattern.match(moduleguid):\n                        for component in self.Modules.values():\n                            if component.Guid == moduleguid:\n                                component.Pcds[PcdName, PcdGuid].DefaultValue = PcdValue\n            elif skuname not in str_pcd_obj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                NoDefault = False\n                while nextskuid not in str_pcd_obj.SkuInfoList:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                str_pcd_obj.SkuInfoList[skuname] = copy.deepcopy(str_pcd_obj.SkuInfoList[nextskuid]) if not NoDefault else SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], DefaultValue=PcdValue)\n                str_pcd_obj.SkuInfoList[skuname].SkuId = self.SkuIds[skuname][0]\n                str_pcd_obj.SkuInfoList[skuname].SkuIdName = skuname\n            else:\n                str_pcd_obj.SkuInfoList[skuname].DefaultValue = PcdValue\n        for str_pcd_obj in S_pcd_set.values():\n            if str_pcd_obj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                continue\n            PcdDefaultStoreSet = set((defaultstorename for skuobj in str_pcd_obj.SkuInfoList.values() for defaultstorename in skuobj.DefaultStoreDict))\n            DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n            mindefaultstorename = DefaultStoreObj.GetMin(PcdDefaultStoreSet)\n            str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].HiiDefaultValue = str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].DefaultStoreDict[mindefaultstorename]\n        for str_pcd_obj in S_pcd_set.values():\n            str_pcd_obj.MaxDatumSize = DscBuildData.GetStructurePcdMaxSize(str_pcd_obj)\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName] = str_pcd_obj\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName].CustomAttribute['IsStru'] = True\n        for pcdkey in Pcds:\n            pcd = Pcds[pcdkey]\n            if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n                del pcd.SkuInfoList[TAB_COMMON]\n            elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, [Pcds[pcdkey] for pcdkey in Pcds if Pcds[pcdkey].Type in DynamicPcdType]))\n    return Pcds",
        "mutated": [
            "def UpdateStructuredPcds(self, TypeList, AllPcds):\n    if False:\n        i = 10\n    DynamicPcdType = [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]\n    Pcds = AllPcds\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    SkuIds = self.SkuIds\n    self.SkuIdMgr.AvailableSkuIdSet.update({TAB_DEFAULT: 0})\n    DefaultStores = {storename for pcdobj in AllPcds.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict}\n    DefaultStores.add(TAB_DEFAULT_STORES_DEFAULT)\n    S_PcdSet = []\n    RecordList = []\n    for Type in TypeList:\n        RecordList.extend(self._RawData[Type, self._Arch])\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, default_store, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        default_store = default_store.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in SkuIds:\n            continue\n        (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n        pcd_in_dec = self._DecPcds.get((PCName, TCName), None)\n        if pcd_in_dec is None:\n            EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n        if SkuName in SkuIds and ('.' in TokenSpaceGuid or '[' in PcdCName):\n            if not isinstance(pcd_in_dec, StructurePcd):\n                EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) is not declared as Structure PCD in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n            S_PcdSet.append([TCName, PCName, DimensionAttr, Field, SkuName, default_store, Dummy5, AnalyzePcdExpression(Setting)[0]])\n    ModuleScopeOverallValue = {}\n    for m in self.Modules.values():\n        mguid = m.Guid\n        if m.StrPcdSet:\n            S_PcdSet.extend(m.StrPcdSet)\n            mguid = m.StrPcdSet[0][4]\n        for (PCName, TCName) in m.StrPcdOverallValue:\n            (Value, dsc_file, lineNo) = m.StrPcdOverallValue[PCName, TCName]\n            ModuleScopeOverallValue.setdefault((PCName, TCName), {})[mguid] = (Value, dsc_file, lineNo)\n    StrPcdSet = DscBuildData.GetStructurePcdInfo(S_PcdSet)\n    S_pcd_set = OrderedDict()\n    for str_pcd in StrPcdSet:\n        str_pcd_obj = Pcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_dec = self._DecPcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_obj_str = StructurePcd()\n        str_pcd_obj_str.copy(str_pcd_dec)\n        if str_pcd_obj:\n            str_pcd_obj_str.copy(str_pcd_obj)\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n            else:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n        for str_pcd_data in StrPcdSet[str_pcd]:\n            if str_pcd_data[4] in SkuIds:\n                str_pcd_obj_str.AddOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), TAB_DEFAULT if str_pcd_data[4] == TAB_COMMON else str_pcd_data[4], TAB_DEFAULT_STORES_DEFAULT if str_pcd_data[5] == TAB_COMMON else str_pcd_data[5], self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n            elif GlobalData.gGuidPattern.match(str_pcd_data[4]):\n                str_pcd_obj_str.AddComponentOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), str_pcd_data[4].replace('-', 'S'), self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n                PcdComponentValue = ModuleScopeOverallValue.get((str_pcd_obj_str.TokenCName, str_pcd_obj_str.TokenSpaceGuidCName))\n                for module_guid in PcdComponentValue:\n                    str_pcd_obj_str.PcdValueFromComponents[module_guid.replace('-', 'S')] = PcdComponentValue[module_guid]\n        S_pcd_set[str_pcd[1], str_pcd[0]] = str_pcd_obj_str\n    for Pcd in self.DecPcds:\n        if isinstance(self._DecPcds[Pcd], StructurePcd):\n            if Pcd not in S_pcd_set:\n                str_pcd_obj_str = StructurePcd()\n                str_pcd_obj_str.copy(self._DecPcds[Pcd])\n                str_pcd_obj = Pcds.get(Pcd, None)\n                if str_pcd_obj:\n                    str_pcd_obj_str.copy(str_pcd_obj)\n                    if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                    else:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                S_pcd_set[Pcd] = str_pcd_obj_str\n    if S_pcd_set:\n        GlobalData.gStructurePcd[self.Arch] = S_pcd_set.copy()\n    self.FilterStrcturePcd(S_pcd_set)\n    for stru_pcd in S_pcd_set.values():\n        for skuid in SkuIds:\n            if skuid in stru_pcd.SkuOverrideValues:\n                continue\n            nextskuid = self.SkuIdMgr.GetNextSkuId(skuid)\n            NoDefault = False\n            if skuid not in stru_pcd.SkuOverrideValues:\n                while nextskuid not in stru_pcd.SkuOverrideValues:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                stru_pcd.SkuOverrideValues[skuid] = copy.deepcopy(stru_pcd.SkuOverrideValues[nextskuid]) if not NoDefault else copy.deepcopy({defaultstorename: stru_pcd.DefaultValues for defaultstorename in DefaultStores} if DefaultStores else {})\n                if not NoDefault:\n                    stru_pcd.ValueChain.add((skuid, ''))\n            if 'DEFAULT' in stru_pcd.SkuOverrideValues and (not GlobalData.gPcdSkuOverrides.get((stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName))):\n                GlobalData.gPcdSkuOverrides.update({(stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName): {'DEFAULT': stru_pcd.SkuOverrideValues['DEFAULT']}})\n        if stru_pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in SkuIds:\n                nextskuid = skuid\n                NoDefault = False\n                if skuid not in stru_pcd.SkuOverrideValues:\n                    while nextskuid not in stru_pcd.SkuOverrideValues:\n                        if nextskuid == TAB_DEFAULT:\n                            NoDefault = True\n                            break\n                        nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                if NoDefault:\n                    continue\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in stru_pcd.SkuOverrideValues[nextskuid]))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                for defaultstoreid in DefaultStores:\n                    if defaultstoreid not in stru_pcd.SkuOverrideValues[skuid]:\n                        stru_pcd.SkuOverrideValues[skuid][defaultstoreid] = CopyDict(stru_pcd.SkuOverrideValues[nextskuid][mindefaultstorename])\n                        stru_pcd.ValueChain.add((skuid, defaultstoreid))\n    S_pcd_set = DscBuildData.OverrideByFdf(S_pcd_set, self.WorkspaceDir)\n    S_pcd_set = DscBuildData.OverrideByComm(S_pcd_set)\n    Str_Pcd_Values = self.GenerateByteArrayValue(S_pcd_set)\n    if Str_Pcd_Values:\n        for (skuname, StoreName, PcdGuid, PcdName, PcdValue) in Str_Pcd_Values:\n            str_pcd_obj = S_pcd_set.get((PcdName, PcdGuid))\n            if str_pcd_obj is None:\n                print(PcdName, PcdGuid)\n                raise\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                if skuname not in str_pcd_obj.SkuInfoList:\n                    str_pcd_obj.SkuInfoList[skuname] = SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], HiiDefaultValue=PcdValue, DefaultStore={StoreName: PcdValue})\n                else:\n                    str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue = PcdValue\n                    str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.update({StoreName: PcdValue})\n            elif str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n                if skuname in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n                    str_pcd_obj.DefaultValue = PcdValue\n                else:\n                    moduleguid = skuname.replace('S', '-')\n                    if GlobalData.gGuidPattern.match(moduleguid):\n                        for component in self.Modules.values():\n                            if component.Guid == moduleguid:\n                                component.Pcds[PcdName, PcdGuid].DefaultValue = PcdValue\n            elif skuname not in str_pcd_obj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                NoDefault = False\n                while nextskuid not in str_pcd_obj.SkuInfoList:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                str_pcd_obj.SkuInfoList[skuname] = copy.deepcopy(str_pcd_obj.SkuInfoList[nextskuid]) if not NoDefault else SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], DefaultValue=PcdValue)\n                str_pcd_obj.SkuInfoList[skuname].SkuId = self.SkuIds[skuname][0]\n                str_pcd_obj.SkuInfoList[skuname].SkuIdName = skuname\n            else:\n                str_pcd_obj.SkuInfoList[skuname].DefaultValue = PcdValue\n        for str_pcd_obj in S_pcd_set.values():\n            if str_pcd_obj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                continue\n            PcdDefaultStoreSet = set((defaultstorename for skuobj in str_pcd_obj.SkuInfoList.values() for defaultstorename in skuobj.DefaultStoreDict))\n            DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n            mindefaultstorename = DefaultStoreObj.GetMin(PcdDefaultStoreSet)\n            str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].HiiDefaultValue = str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].DefaultStoreDict[mindefaultstorename]\n        for str_pcd_obj in S_pcd_set.values():\n            str_pcd_obj.MaxDatumSize = DscBuildData.GetStructurePcdMaxSize(str_pcd_obj)\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName] = str_pcd_obj\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName].CustomAttribute['IsStru'] = True\n        for pcdkey in Pcds:\n            pcd = Pcds[pcdkey]\n            if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n                del pcd.SkuInfoList[TAB_COMMON]\n            elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, [Pcds[pcdkey] for pcdkey in Pcds if Pcds[pcdkey].Type in DynamicPcdType]))\n    return Pcds",
            "def UpdateStructuredPcds(self, TypeList, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DynamicPcdType = [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]\n    Pcds = AllPcds\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    SkuIds = self.SkuIds\n    self.SkuIdMgr.AvailableSkuIdSet.update({TAB_DEFAULT: 0})\n    DefaultStores = {storename for pcdobj in AllPcds.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict}\n    DefaultStores.add(TAB_DEFAULT_STORES_DEFAULT)\n    S_PcdSet = []\n    RecordList = []\n    for Type in TypeList:\n        RecordList.extend(self._RawData[Type, self._Arch])\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, default_store, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        default_store = default_store.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in SkuIds:\n            continue\n        (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n        pcd_in_dec = self._DecPcds.get((PCName, TCName), None)\n        if pcd_in_dec is None:\n            EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n        if SkuName in SkuIds and ('.' in TokenSpaceGuid or '[' in PcdCName):\n            if not isinstance(pcd_in_dec, StructurePcd):\n                EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) is not declared as Structure PCD in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n            S_PcdSet.append([TCName, PCName, DimensionAttr, Field, SkuName, default_store, Dummy5, AnalyzePcdExpression(Setting)[0]])\n    ModuleScopeOverallValue = {}\n    for m in self.Modules.values():\n        mguid = m.Guid\n        if m.StrPcdSet:\n            S_PcdSet.extend(m.StrPcdSet)\n            mguid = m.StrPcdSet[0][4]\n        for (PCName, TCName) in m.StrPcdOverallValue:\n            (Value, dsc_file, lineNo) = m.StrPcdOverallValue[PCName, TCName]\n            ModuleScopeOverallValue.setdefault((PCName, TCName), {})[mguid] = (Value, dsc_file, lineNo)\n    StrPcdSet = DscBuildData.GetStructurePcdInfo(S_PcdSet)\n    S_pcd_set = OrderedDict()\n    for str_pcd in StrPcdSet:\n        str_pcd_obj = Pcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_dec = self._DecPcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_obj_str = StructurePcd()\n        str_pcd_obj_str.copy(str_pcd_dec)\n        if str_pcd_obj:\n            str_pcd_obj_str.copy(str_pcd_obj)\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n            else:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n        for str_pcd_data in StrPcdSet[str_pcd]:\n            if str_pcd_data[4] in SkuIds:\n                str_pcd_obj_str.AddOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), TAB_DEFAULT if str_pcd_data[4] == TAB_COMMON else str_pcd_data[4], TAB_DEFAULT_STORES_DEFAULT if str_pcd_data[5] == TAB_COMMON else str_pcd_data[5], self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n            elif GlobalData.gGuidPattern.match(str_pcd_data[4]):\n                str_pcd_obj_str.AddComponentOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), str_pcd_data[4].replace('-', 'S'), self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n                PcdComponentValue = ModuleScopeOverallValue.get((str_pcd_obj_str.TokenCName, str_pcd_obj_str.TokenSpaceGuidCName))\n                for module_guid in PcdComponentValue:\n                    str_pcd_obj_str.PcdValueFromComponents[module_guid.replace('-', 'S')] = PcdComponentValue[module_guid]\n        S_pcd_set[str_pcd[1], str_pcd[0]] = str_pcd_obj_str\n    for Pcd in self.DecPcds:\n        if isinstance(self._DecPcds[Pcd], StructurePcd):\n            if Pcd not in S_pcd_set:\n                str_pcd_obj_str = StructurePcd()\n                str_pcd_obj_str.copy(self._DecPcds[Pcd])\n                str_pcd_obj = Pcds.get(Pcd, None)\n                if str_pcd_obj:\n                    str_pcd_obj_str.copy(str_pcd_obj)\n                    if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                    else:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                S_pcd_set[Pcd] = str_pcd_obj_str\n    if S_pcd_set:\n        GlobalData.gStructurePcd[self.Arch] = S_pcd_set.copy()\n    self.FilterStrcturePcd(S_pcd_set)\n    for stru_pcd in S_pcd_set.values():\n        for skuid in SkuIds:\n            if skuid in stru_pcd.SkuOverrideValues:\n                continue\n            nextskuid = self.SkuIdMgr.GetNextSkuId(skuid)\n            NoDefault = False\n            if skuid not in stru_pcd.SkuOverrideValues:\n                while nextskuid not in stru_pcd.SkuOverrideValues:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                stru_pcd.SkuOverrideValues[skuid] = copy.deepcopy(stru_pcd.SkuOverrideValues[nextskuid]) if not NoDefault else copy.deepcopy({defaultstorename: stru_pcd.DefaultValues for defaultstorename in DefaultStores} if DefaultStores else {})\n                if not NoDefault:\n                    stru_pcd.ValueChain.add((skuid, ''))\n            if 'DEFAULT' in stru_pcd.SkuOverrideValues and (not GlobalData.gPcdSkuOverrides.get((stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName))):\n                GlobalData.gPcdSkuOverrides.update({(stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName): {'DEFAULT': stru_pcd.SkuOverrideValues['DEFAULT']}})\n        if stru_pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in SkuIds:\n                nextskuid = skuid\n                NoDefault = False\n                if skuid not in stru_pcd.SkuOverrideValues:\n                    while nextskuid not in stru_pcd.SkuOverrideValues:\n                        if nextskuid == TAB_DEFAULT:\n                            NoDefault = True\n                            break\n                        nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                if NoDefault:\n                    continue\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in stru_pcd.SkuOverrideValues[nextskuid]))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                for defaultstoreid in DefaultStores:\n                    if defaultstoreid not in stru_pcd.SkuOverrideValues[skuid]:\n                        stru_pcd.SkuOverrideValues[skuid][defaultstoreid] = CopyDict(stru_pcd.SkuOverrideValues[nextskuid][mindefaultstorename])\n                        stru_pcd.ValueChain.add((skuid, defaultstoreid))\n    S_pcd_set = DscBuildData.OverrideByFdf(S_pcd_set, self.WorkspaceDir)\n    S_pcd_set = DscBuildData.OverrideByComm(S_pcd_set)\n    Str_Pcd_Values = self.GenerateByteArrayValue(S_pcd_set)\n    if Str_Pcd_Values:\n        for (skuname, StoreName, PcdGuid, PcdName, PcdValue) in Str_Pcd_Values:\n            str_pcd_obj = S_pcd_set.get((PcdName, PcdGuid))\n            if str_pcd_obj is None:\n                print(PcdName, PcdGuid)\n                raise\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                if skuname not in str_pcd_obj.SkuInfoList:\n                    str_pcd_obj.SkuInfoList[skuname] = SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], HiiDefaultValue=PcdValue, DefaultStore={StoreName: PcdValue})\n                else:\n                    str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue = PcdValue\n                    str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.update({StoreName: PcdValue})\n            elif str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n                if skuname in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n                    str_pcd_obj.DefaultValue = PcdValue\n                else:\n                    moduleguid = skuname.replace('S', '-')\n                    if GlobalData.gGuidPattern.match(moduleguid):\n                        for component in self.Modules.values():\n                            if component.Guid == moduleguid:\n                                component.Pcds[PcdName, PcdGuid].DefaultValue = PcdValue\n            elif skuname not in str_pcd_obj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                NoDefault = False\n                while nextskuid not in str_pcd_obj.SkuInfoList:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                str_pcd_obj.SkuInfoList[skuname] = copy.deepcopy(str_pcd_obj.SkuInfoList[nextskuid]) if not NoDefault else SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], DefaultValue=PcdValue)\n                str_pcd_obj.SkuInfoList[skuname].SkuId = self.SkuIds[skuname][0]\n                str_pcd_obj.SkuInfoList[skuname].SkuIdName = skuname\n            else:\n                str_pcd_obj.SkuInfoList[skuname].DefaultValue = PcdValue\n        for str_pcd_obj in S_pcd_set.values():\n            if str_pcd_obj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                continue\n            PcdDefaultStoreSet = set((defaultstorename for skuobj in str_pcd_obj.SkuInfoList.values() for defaultstorename in skuobj.DefaultStoreDict))\n            DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n            mindefaultstorename = DefaultStoreObj.GetMin(PcdDefaultStoreSet)\n            str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].HiiDefaultValue = str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].DefaultStoreDict[mindefaultstorename]\n        for str_pcd_obj in S_pcd_set.values():\n            str_pcd_obj.MaxDatumSize = DscBuildData.GetStructurePcdMaxSize(str_pcd_obj)\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName] = str_pcd_obj\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName].CustomAttribute['IsStru'] = True\n        for pcdkey in Pcds:\n            pcd = Pcds[pcdkey]\n            if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n                del pcd.SkuInfoList[TAB_COMMON]\n            elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, [Pcds[pcdkey] for pcdkey in Pcds if Pcds[pcdkey].Type in DynamicPcdType]))\n    return Pcds",
            "def UpdateStructuredPcds(self, TypeList, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DynamicPcdType = [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]\n    Pcds = AllPcds\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    SkuIds = self.SkuIds\n    self.SkuIdMgr.AvailableSkuIdSet.update({TAB_DEFAULT: 0})\n    DefaultStores = {storename for pcdobj in AllPcds.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict}\n    DefaultStores.add(TAB_DEFAULT_STORES_DEFAULT)\n    S_PcdSet = []\n    RecordList = []\n    for Type in TypeList:\n        RecordList.extend(self._RawData[Type, self._Arch])\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, default_store, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        default_store = default_store.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in SkuIds:\n            continue\n        (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n        pcd_in_dec = self._DecPcds.get((PCName, TCName), None)\n        if pcd_in_dec is None:\n            EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n        if SkuName in SkuIds and ('.' in TokenSpaceGuid or '[' in PcdCName):\n            if not isinstance(pcd_in_dec, StructurePcd):\n                EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) is not declared as Structure PCD in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n            S_PcdSet.append([TCName, PCName, DimensionAttr, Field, SkuName, default_store, Dummy5, AnalyzePcdExpression(Setting)[0]])\n    ModuleScopeOverallValue = {}\n    for m in self.Modules.values():\n        mguid = m.Guid\n        if m.StrPcdSet:\n            S_PcdSet.extend(m.StrPcdSet)\n            mguid = m.StrPcdSet[0][4]\n        for (PCName, TCName) in m.StrPcdOverallValue:\n            (Value, dsc_file, lineNo) = m.StrPcdOverallValue[PCName, TCName]\n            ModuleScopeOverallValue.setdefault((PCName, TCName), {})[mguid] = (Value, dsc_file, lineNo)\n    StrPcdSet = DscBuildData.GetStructurePcdInfo(S_PcdSet)\n    S_pcd_set = OrderedDict()\n    for str_pcd in StrPcdSet:\n        str_pcd_obj = Pcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_dec = self._DecPcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_obj_str = StructurePcd()\n        str_pcd_obj_str.copy(str_pcd_dec)\n        if str_pcd_obj:\n            str_pcd_obj_str.copy(str_pcd_obj)\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n            else:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n        for str_pcd_data in StrPcdSet[str_pcd]:\n            if str_pcd_data[4] in SkuIds:\n                str_pcd_obj_str.AddOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), TAB_DEFAULT if str_pcd_data[4] == TAB_COMMON else str_pcd_data[4], TAB_DEFAULT_STORES_DEFAULT if str_pcd_data[5] == TAB_COMMON else str_pcd_data[5], self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n            elif GlobalData.gGuidPattern.match(str_pcd_data[4]):\n                str_pcd_obj_str.AddComponentOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), str_pcd_data[4].replace('-', 'S'), self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n                PcdComponentValue = ModuleScopeOverallValue.get((str_pcd_obj_str.TokenCName, str_pcd_obj_str.TokenSpaceGuidCName))\n                for module_guid in PcdComponentValue:\n                    str_pcd_obj_str.PcdValueFromComponents[module_guid.replace('-', 'S')] = PcdComponentValue[module_guid]\n        S_pcd_set[str_pcd[1], str_pcd[0]] = str_pcd_obj_str\n    for Pcd in self.DecPcds:\n        if isinstance(self._DecPcds[Pcd], StructurePcd):\n            if Pcd not in S_pcd_set:\n                str_pcd_obj_str = StructurePcd()\n                str_pcd_obj_str.copy(self._DecPcds[Pcd])\n                str_pcd_obj = Pcds.get(Pcd, None)\n                if str_pcd_obj:\n                    str_pcd_obj_str.copy(str_pcd_obj)\n                    if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                    else:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                S_pcd_set[Pcd] = str_pcd_obj_str\n    if S_pcd_set:\n        GlobalData.gStructurePcd[self.Arch] = S_pcd_set.copy()\n    self.FilterStrcturePcd(S_pcd_set)\n    for stru_pcd in S_pcd_set.values():\n        for skuid in SkuIds:\n            if skuid in stru_pcd.SkuOverrideValues:\n                continue\n            nextskuid = self.SkuIdMgr.GetNextSkuId(skuid)\n            NoDefault = False\n            if skuid not in stru_pcd.SkuOverrideValues:\n                while nextskuid not in stru_pcd.SkuOverrideValues:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                stru_pcd.SkuOverrideValues[skuid] = copy.deepcopy(stru_pcd.SkuOverrideValues[nextskuid]) if not NoDefault else copy.deepcopy({defaultstorename: stru_pcd.DefaultValues for defaultstorename in DefaultStores} if DefaultStores else {})\n                if not NoDefault:\n                    stru_pcd.ValueChain.add((skuid, ''))\n            if 'DEFAULT' in stru_pcd.SkuOverrideValues and (not GlobalData.gPcdSkuOverrides.get((stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName))):\n                GlobalData.gPcdSkuOverrides.update({(stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName): {'DEFAULT': stru_pcd.SkuOverrideValues['DEFAULT']}})\n        if stru_pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in SkuIds:\n                nextskuid = skuid\n                NoDefault = False\n                if skuid not in stru_pcd.SkuOverrideValues:\n                    while nextskuid not in stru_pcd.SkuOverrideValues:\n                        if nextskuid == TAB_DEFAULT:\n                            NoDefault = True\n                            break\n                        nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                if NoDefault:\n                    continue\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in stru_pcd.SkuOverrideValues[nextskuid]))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                for defaultstoreid in DefaultStores:\n                    if defaultstoreid not in stru_pcd.SkuOverrideValues[skuid]:\n                        stru_pcd.SkuOverrideValues[skuid][defaultstoreid] = CopyDict(stru_pcd.SkuOverrideValues[nextskuid][mindefaultstorename])\n                        stru_pcd.ValueChain.add((skuid, defaultstoreid))\n    S_pcd_set = DscBuildData.OverrideByFdf(S_pcd_set, self.WorkspaceDir)\n    S_pcd_set = DscBuildData.OverrideByComm(S_pcd_set)\n    Str_Pcd_Values = self.GenerateByteArrayValue(S_pcd_set)\n    if Str_Pcd_Values:\n        for (skuname, StoreName, PcdGuid, PcdName, PcdValue) in Str_Pcd_Values:\n            str_pcd_obj = S_pcd_set.get((PcdName, PcdGuid))\n            if str_pcd_obj is None:\n                print(PcdName, PcdGuid)\n                raise\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                if skuname not in str_pcd_obj.SkuInfoList:\n                    str_pcd_obj.SkuInfoList[skuname] = SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], HiiDefaultValue=PcdValue, DefaultStore={StoreName: PcdValue})\n                else:\n                    str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue = PcdValue\n                    str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.update({StoreName: PcdValue})\n            elif str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n                if skuname in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n                    str_pcd_obj.DefaultValue = PcdValue\n                else:\n                    moduleguid = skuname.replace('S', '-')\n                    if GlobalData.gGuidPattern.match(moduleguid):\n                        for component in self.Modules.values():\n                            if component.Guid == moduleguid:\n                                component.Pcds[PcdName, PcdGuid].DefaultValue = PcdValue\n            elif skuname not in str_pcd_obj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                NoDefault = False\n                while nextskuid not in str_pcd_obj.SkuInfoList:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                str_pcd_obj.SkuInfoList[skuname] = copy.deepcopy(str_pcd_obj.SkuInfoList[nextskuid]) if not NoDefault else SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], DefaultValue=PcdValue)\n                str_pcd_obj.SkuInfoList[skuname].SkuId = self.SkuIds[skuname][0]\n                str_pcd_obj.SkuInfoList[skuname].SkuIdName = skuname\n            else:\n                str_pcd_obj.SkuInfoList[skuname].DefaultValue = PcdValue\n        for str_pcd_obj in S_pcd_set.values():\n            if str_pcd_obj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                continue\n            PcdDefaultStoreSet = set((defaultstorename for skuobj in str_pcd_obj.SkuInfoList.values() for defaultstorename in skuobj.DefaultStoreDict))\n            DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n            mindefaultstorename = DefaultStoreObj.GetMin(PcdDefaultStoreSet)\n            str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].HiiDefaultValue = str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].DefaultStoreDict[mindefaultstorename]\n        for str_pcd_obj in S_pcd_set.values():\n            str_pcd_obj.MaxDatumSize = DscBuildData.GetStructurePcdMaxSize(str_pcd_obj)\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName] = str_pcd_obj\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName].CustomAttribute['IsStru'] = True\n        for pcdkey in Pcds:\n            pcd = Pcds[pcdkey]\n            if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n                del pcd.SkuInfoList[TAB_COMMON]\n            elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, [Pcds[pcdkey] for pcdkey in Pcds if Pcds[pcdkey].Type in DynamicPcdType]))\n    return Pcds",
            "def UpdateStructuredPcds(self, TypeList, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DynamicPcdType = [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]\n    Pcds = AllPcds\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    SkuIds = self.SkuIds\n    self.SkuIdMgr.AvailableSkuIdSet.update({TAB_DEFAULT: 0})\n    DefaultStores = {storename for pcdobj in AllPcds.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict}\n    DefaultStores.add(TAB_DEFAULT_STORES_DEFAULT)\n    S_PcdSet = []\n    RecordList = []\n    for Type in TypeList:\n        RecordList.extend(self._RawData[Type, self._Arch])\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, default_store, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        default_store = default_store.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in SkuIds:\n            continue\n        (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n        pcd_in_dec = self._DecPcds.get((PCName, TCName), None)\n        if pcd_in_dec is None:\n            EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n        if SkuName in SkuIds and ('.' in TokenSpaceGuid or '[' in PcdCName):\n            if not isinstance(pcd_in_dec, StructurePcd):\n                EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) is not declared as Structure PCD in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n            S_PcdSet.append([TCName, PCName, DimensionAttr, Field, SkuName, default_store, Dummy5, AnalyzePcdExpression(Setting)[0]])\n    ModuleScopeOverallValue = {}\n    for m in self.Modules.values():\n        mguid = m.Guid\n        if m.StrPcdSet:\n            S_PcdSet.extend(m.StrPcdSet)\n            mguid = m.StrPcdSet[0][4]\n        for (PCName, TCName) in m.StrPcdOverallValue:\n            (Value, dsc_file, lineNo) = m.StrPcdOverallValue[PCName, TCName]\n            ModuleScopeOverallValue.setdefault((PCName, TCName), {})[mguid] = (Value, dsc_file, lineNo)\n    StrPcdSet = DscBuildData.GetStructurePcdInfo(S_PcdSet)\n    S_pcd_set = OrderedDict()\n    for str_pcd in StrPcdSet:\n        str_pcd_obj = Pcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_dec = self._DecPcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_obj_str = StructurePcd()\n        str_pcd_obj_str.copy(str_pcd_dec)\n        if str_pcd_obj:\n            str_pcd_obj_str.copy(str_pcd_obj)\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n            else:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n        for str_pcd_data in StrPcdSet[str_pcd]:\n            if str_pcd_data[4] in SkuIds:\n                str_pcd_obj_str.AddOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), TAB_DEFAULT if str_pcd_data[4] == TAB_COMMON else str_pcd_data[4], TAB_DEFAULT_STORES_DEFAULT if str_pcd_data[5] == TAB_COMMON else str_pcd_data[5], self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n            elif GlobalData.gGuidPattern.match(str_pcd_data[4]):\n                str_pcd_obj_str.AddComponentOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), str_pcd_data[4].replace('-', 'S'), self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n                PcdComponentValue = ModuleScopeOverallValue.get((str_pcd_obj_str.TokenCName, str_pcd_obj_str.TokenSpaceGuidCName))\n                for module_guid in PcdComponentValue:\n                    str_pcd_obj_str.PcdValueFromComponents[module_guid.replace('-', 'S')] = PcdComponentValue[module_guid]\n        S_pcd_set[str_pcd[1], str_pcd[0]] = str_pcd_obj_str\n    for Pcd in self.DecPcds:\n        if isinstance(self._DecPcds[Pcd], StructurePcd):\n            if Pcd not in S_pcd_set:\n                str_pcd_obj_str = StructurePcd()\n                str_pcd_obj_str.copy(self._DecPcds[Pcd])\n                str_pcd_obj = Pcds.get(Pcd, None)\n                if str_pcd_obj:\n                    str_pcd_obj_str.copy(str_pcd_obj)\n                    if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                    else:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                S_pcd_set[Pcd] = str_pcd_obj_str\n    if S_pcd_set:\n        GlobalData.gStructurePcd[self.Arch] = S_pcd_set.copy()\n    self.FilterStrcturePcd(S_pcd_set)\n    for stru_pcd in S_pcd_set.values():\n        for skuid in SkuIds:\n            if skuid in stru_pcd.SkuOverrideValues:\n                continue\n            nextskuid = self.SkuIdMgr.GetNextSkuId(skuid)\n            NoDefault = False\n            if skuid not in stru_pcd.SkuOverrideValues:\n                while nextskuid not in stru_pcd.SkuOverrideValues:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                stru_pcd.SkuOverrideValues[skuid] = copy.deepcopy(stru_pcd.SkuOverrideValues[nextskuid]) if not NoDefault else copy.deepcopy({defaultstorename: stru_pcd.DefaultValues for defaultstorename in DefaultStores} if DefaultStores else {})\n                if not NoDefault:\n                    stru_pcd.ValueChain.add((skuid, ''))\n            if 'DEFAULT' in stru_pcd.SkuOverrideValues and (not GlobalData.gPcdSkuOverrides.get((stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName))):\n                GlobalData.gPcdSkuOverrides.update({(stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName): {'DEFAULT': stru_pcd.SkuOverrideValues['DEFAULT']}})\n        if stru_pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in SkuIds:\n                nextskuid = skuid\n                NoDefault = False\n                if skuid not in stru_pcd.SkuOverrideValues:\n                    while nextskuid not in stru_pcd.SkuOverrideValues:\n                        if nextskuid == TAB_DEFAULT:\n                            NoDefault = True\n                            break\n                        nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                if NoDefault:\n                    continue\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in stru_pcd.SkuOverrideValues[nextskuid]))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                for defaultstoreid in DefaultStores:\n                    if defaultstoreid not in stru_pcd.SkuOverrideValues[skuid]:\n                        stru_pcd.SkuOverrideValues[skuid][defaultstoreid] = CopyDict(stru_pcd.SkuOverrideValues[nextskuid][mindefaultstorename])\n                        stru_pcd.ValueChain.add((skuid, defaultstoreid))\n    S_pcd_set = DscBuildData.OverrideByFdf(S_pcd_set, self.WorkspaceDir)\n    S_pcd_set = DscBuildData.OverrideByComm(S_pcd_set)\n    Str_Pcd_Values = self.GenerateByteArrayValue(S_pcd_set)\n    if Str_Pcd_Values:\n        for (skuname, StoreName, PcdGuid, PcdName, PcdValue) in Str_Pcd_Values:\n            str_pcd_obj = S_pcd_set.get((PcdName, PcdGuid))\n            if str_pcd_obj is None:\n                print(PcdName, PcdGuid)\n                raise\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                if skuname not in str_pcd_obj.SkuInfoList:\n                    str_pcd_obj.SkuInfoList[skuname] = SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], HiiDefaultValue=PcdValue, DefaultStore={StoreName: PcdValue})\n                else:\n                    str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue = PcdValue\n                    str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.update({StoreName: PcdValue})\n            elif str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n                if skuname in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n                    str_pcd_obj.DefaultValue = PcdValue\n                else:\n                    moduleguid = skuname.replace('S', '-')\n                    if GlobalData.gGuidPattern.match(moduleguid):\n                        for component in self.Modules.values():\n                            if component.Guid == moduleguid:\n                                component.Pcds[PcdName, PcdGuid].DefaultValue = PcdValue\n            elif skuname not in str_pcd_obj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                NoDefault = False\n                while nextskuid not in str_pcd_obj.SkuInfoList:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                str_pcd_obj.SkuInfoList[skuname] = copy.deepcopy(str_pcd_obj.SkuInfoList[nextskuid]) if not NoDefault else SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], DefaultValue=PcdValue)\n                str_pcd_obj.SkuInfoList[skuname].SkuId = self.SkuIds[skuname][0]\n                str_pcd_obj.SkuInfoList[skuname].SkuIdName = skuname\n            else:\n                str_pcd_obj.SkuInfoList[skuname].DefaultValue = PcdValue\n        for str_pcd_obj in S_pcd_set.values():\n            if str_pcd_obj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                continue\n            PcdDefaultStoreSet = set((defaultstorename for skuobj in str_pcd_obj.SkuInfoList.values() for defaultstorename in skuobj.DefaultStoreDict))\n            DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n            mindefaultstorename = DefaultStoreObj.GetMin(PcdDefaultStoreSet)\n            str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].HiiDefaultValue = str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].DefaultStoreDict[mindefaultstorename]\n        for str_pcd_obj in S_pcd_set.values():\n            str_pcd_obj.MaxDatumSize = DscBuildData.GetStructurePcdMaxSize(str_pcd_obj)\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName] = str_pcd_obj\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName].CustomAttribute['IsStru'] = True\n        for pcdkey in Pcds:\n            pcd = Pcds[pcdkey]\n            if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n                del pcd.SkuInfoList[TAB_COMMON]\n            elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, [Pcds[pcdkey] for pcdkey in Pcds if Pcds[pcdkey].Type in DynamicPcdType]))\n    return Pcds",
            "def UpdateStructuredPcds(self, TypeList, AllPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DynamicPcdType = [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]\n    Pcds = AllPcds\n    DefaultStoreMgr = DefaultStore(self.DefaultStores)\n    SkuIds = self.SkuIds\n    self.SkuIdMgr.AvailableSkuIdSet.update({TAB_DEFAULT: 0})\n    DefaultStores = {storename for pcdobj in AllPcds.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict}\n    DefaultStores.add(TAB_DEFAULT_STORES_DEFAULT)\n    S_PcdSet = []\n    RecordList = []\n    for Type in TypeList:\n        RecordList.extend(self._RawData[Type, self._Arch])\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, default_store, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        default_store = default_store.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in SkuIds:\n            continue\n        (TCName, PCName, DimensionAttr, Field) = self.ParsePcdNameStruct(TokenSpaceGuid, PcdCName)\n        pcd_in_dec = self._DecPcds.get((PCName, TCName), None)\n        if pcd_in_dec is None:\n            EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) defined in DSC is not declared in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n        if SkuName in SkuIds and ('.' in TokenSpaceGuid or '[' in PcdCName):\n            if not isinstance(pcd_in_dec, StructurePcd):\n                EdkLogger.error('build', PARSER_ERROR, \"Pcd (%s.%s) is not declared as Structure PCD in DEC files. Arch: ['%s']\" % (TCName, PCName, self._Arch), File=self.MetaFile, Line=Dummy5)\n            S_PcdSet.append([TCName, PCName, DimensionAttr, Field, SkuName, default_store, Dummy5, AnalyzePcdExpression(Setting)[0]])\n    ModuleScopeOverallValue = {}\n    for m in self.Modules.values():\n        mguid = m.Guid\n        if m.StrPcdSet:\n            S_PcdSet.extend(m.StrPcdSet)\n            mguid = m.StrPcdSet[0][4]\n        for (PCName, TCName) in m.StrPcdOverallValue:\n            (Value, dsc_file, lineNo) = m.StrPcdOverallValue[PCName, TCName]\n            ModuleScopeOverallValue.setdefault((PCName, TCName), {})[mguid] = (Value, dsc_file, lineNo)\n    StrPcdSet = DscBuildData.GetStructurePcdInfo(S_PcdSet)\n    S_pcd_set = OrderedDict()\n    for str_pcd in StrPcdSet:\n        str_pcd_obj = Pcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_dec = self._DecPcds.get((str_pcd[1], str_pcd[0]), None)\n        str_pcd_obj_str = StructurePcd()\n        str_pcd_obj_str.copy(str_pcd_dec)\n        if str_pcd_obj:\n            str_pcd_obj_str.copy(str_pcd_obj)\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n            else:\n                str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n        for str_pcd_data in StrPcdSet[str_pcd]:\n            if str_pcd_data[4] in SkuIds:\n                str_pcd_obj_str.AddOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), TAB_DEFAULT if str_pcd_data[4] == TAB_COMMON else str_pcd_data[4], TAB_DEFAULT_STORES_DEFAULT if str_pcd_data[5] == TAB_COMMON else str_pcd_data[5], self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n            elif GlobalData.gGuidPattern.match(str_pcd_data[4]):\n                str_pcd_obj_str.AddComponentOverrideValue(str_pcd_data[3], str(str_pcd_data[7]), str_pcd_data[4].replace('-', 'S'), self.MetaFile.File if self.WorkspaceDir not in self.MetaFile.File else self.MetaFile.File[len(self.WorkspaceDir) if self.WorkspaceDir.endswith(os.path.sep) else len(self.WorkspaceDir) + 1:], LineNo=str_pcd_data[6], DimensionAttr=str_pcd_data[2])\n                PcdComponentValue = ModuleScopeOverallValue.get((str_pcd_obj_str.TokenCName, str_pcd_obj_str.TokenSpaceGuidCName))\n                for module_guid in PcdComponentValue:\n                    str_pcd_obj_str.PcdValueFromComponents[module_guid.replace('-', 'S')] = PcdComponentValue[module_guid]\n        S_pcd_set[str_pcd[1], str_pcd[0]] = str_pcd_obj_str\n    for Pcd in self.DecPcds:\n        if isinstance(self._DecPcds[Pcd], StructurePcd):\n            if Pcd not in S_pcd_set:\n                str_pcd_obj_str = StructurePcd()\n                str_pcd_obj_str.copy(self._DecPcds[Pcd])\n                str_pcd_obj = Pcds.get(Pcd, None)\n                if str_pcd_obj:\n                    str_pcd_obj_str.copy(str_pcd_obj)\n                    if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                    else:\n                        str_pcd_obj_str.DefaultFromDSC = {skuname: {defaultstore: str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.get(defaultstore, str_pcd_obj.SkuInfoList[skuname].DefaultValue) for defaultstore in DefaultStores} for skuname in str_pcd_obj.SkuInfoList}\n                S_pcd_set[Pcd] = str_pcd_obj_str\n    if S_pcd_set:\n        GlobalData.gStructurePcd[self.Arch] = S_pcd_set.copy()\n    self.FilterStrcturePcd(S_pcd_set)\n    for stru_pcd in S_pcd_set.values():\n        for skuid in SkuIds:\n            if skuid in stru_pcd.SkuOverrideValues:\n                continue\n            nextskuid = self.SkuIdMgr.GetNextSkuId(skuid)\n            NoDefault = False\n            if skuid not in stru_pcd.SkuOverrideValues:\n                while nextskuid not in stru_pcd.SkuOverrideValues:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                stru_pcd.SkuOverrideValues[skuid] = copy.deepcopy(stru_pcd.SkuOverrideValues[nextskuid]) if not NoDefault else copy.deepcopy({defaultstorename: stru_pcd.DefaultValues for defaultstorename in DefaultStores} if DefaultStores else {})\n                if not NoDefault:\n                    stru_pcd.ValueChain.add((skuid, ''))\n            if 'DEFAULT' in stru_pcd.SkuOverrideValues and (not GlobalData.gPcdSkuOverrides.get((stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName))):\n                GlobalData.gPcdSkuOverrides.update({(stru_pcd.TokenCName, stru_pcd.TokenSpaceGuidCName): {'DEFAULT': stru_pcd.SkuOverrideValues['DEFAULT']}})\n        if stru_pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in SkuIds:\n                nextskuid = skuid\n                NoDefault = False\n                if skuid not in stru_pcd.SkuOverrideValues:\n                    while nextskuid not in stru_pcd.SkuOverrideValues:\n                        if nextskuid == TAB_DEFAULT:\n                            NoDefault = True\n                            break\n                        nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                if NoDefault:\n                    continue\n                PcdDefaultStoreSet = set((defaultstorename for defaultstorename in stru_pcd.SkuOverrideValues[nextskuid]))\n                mindefaultstorename = DefaultStoreMgr.GetMin(PcdDefaultStoreSet)\n                for defaultstoreid in DefaultStores:\n                    if defaultstoreid not in stru_pcd.SkuOverrideValues[skuid]:\n                        stru_pcd.SkuOverrideValues[skuid][defaultstoreid] = CopyDict(stru_pcd.SkuOverrideValues[nextskuid][mindefaultstorename])\n                        stru_pcd.ValueChain.add((skuid, defaultstoreid))\n    S_pcd_set = DscBuildData.OverrideByFdf(S_pcd_set, self.WorkspaceDir)\n    S_pcd_set = DscBuildData.OverrideByComm(S_pcd_set)\n    Str_Pcd_Values = self.GenerateByteArrayValue(S_pcd_set)\n    if Str_Pcd_Values:\n        for (skuname, StoreName, PcdGuid, PcdName, PcdValue) in Str_Pcd_Values:\n            str_pcd_obj = S_pcd_set.get((PcdName, PcdGuid))\n            if str_pcd_obj is None:\n                print(PcdName, PcdGuid)\n                raise\n            if str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                if skuname not in str_pcd_obj.SkuInfoList:\n                    str_pcd_obj.SkuInfoList[skuname] = SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], HiiDefaultValue=PcdValue, DefaultStore={StoreName: PcdValue})\n                else:\n                    str_pcd_obj.SkuInfoList[skuname].HiiDefaultValue = PcdValue\n                    str_pcd_obj.SkuInfoList[skuname].DefaultStoreDict.update({StoreName: PcdValue})\n            elif str_pcd_obj.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n                if skuname in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n                    str_pcd_obj.DefaultValue = PcdValue\n                else:\n                    moduleguid = skuname.replace('S', '-')\n                    if GlobalData.gGuidPattern.match(moduleguid):\n                        for component in self.Modules.values():\n                            if component.Guid == moduleguid:\n                                component.Pcds[PcdName, PcdGuid].DefaultValue = PcdValue\n            elif skuname not in str_pcd_obj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                NoDefault = False\n                while nextskuid not in str_pcd_obj.SkuInfoList:\n                    if nextskuid == TAB_DEFAULT:\n                        NoDefault = True\n                        break\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                str_pcd_obj.SkuInfoList[skuname] = copy.deepcopy(str_pcd_obj.SkuInfoList[nextskuid]) if not NoDefault else SkuInfoClass(SkuIdName=skuname, SkuId=self.SkuIds[skuname][0], DefaultValue=PcdValue)\n                str_pcd_obj.SkuInfoList[skuname].SkuId = self.SkuIds[skuname][0]\n                str_pcd_obj.SkuInfoList[skuname].SkuIdName = skuname\n            else:\n                str_pcd_obj.SkuInfoList[skuname].DefaultValue = PcdValue\n        for str_pcd_obj in S_pcd_set.values():\n            if str_pcd_obj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n                continue\n            PcdDefaultStoreSet = set((defaultstorename for skuobj in str_pcd_obj.SkuInfoList.values() for defaultstorename in skuobj.DefaultStoreDict))\n            DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n            mindefaultstorename = DefaultStoreObj.GetMin(PcdDefaultStoreSet)\n            str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].HiiDefaultValue = str_pcd_obj.SkuInfoList[self.SkuIdMgr.SystemSkuId].DefaultStoreDict[mindefaultstorename]\n        for str_pcd_obj in S_pcd_set.values():\n            str_pcd_obj.MaxDatumSize = DscBuildData.GetStructurePcdMaxSize(str_pcd_obj)\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName] = str_pcd_obj\n            Pcds[str_pcd_obj.TokenCName, str_pcd_obj.TokenSpaceGuidCName].CustomAttribute['IsStru'] = True\n        for pcdkey in Pcds:\n            pcd = Pcds[pcdkey]\n            if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n                del pcd.SkuInfoList[TAB_COMMON]\n            elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n                del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, [Pcds[pcdkey] for pcdkey in Pcds if Pcds[pcdkey].Type in DynamicPcdType]))\n    return Pcds"
        ]
    },
    {
        "func_name": "PlatformUsedPcds",
        "original": "@cached_property\ndef PlatformUsedPcds(self):\n    FdfInfList = []\n    if GlobalData.gFdfParser:\n        FdfInfList = GlobalData.gFdfParser.Profile.InfList\n    FdfModuleList = [PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch) for Inf in FdfInfList]\n    AllModulePcds = set()\n    ModuleSet = set(list(self._Modules.keys()) + FdfModuleList)\n    for ModuleFile in ModuleSet:\n        ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    for ModuleFile in self.LibraryInstances:\n        ModuleData = self._Bdb.CreateBuildObject(ModuleFile, self._Arch, self._Target, self._Toolchain)\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    return AllModulePcds",
        "mutated": [
            "@cached_property\ndef PlatformUsedPcds(self):\n    if False:\n        i = 10\n    FdfInfList = []\n    if GlobalData.gFdfParser:\n        FdfInfList = GlobalData.gFdfParser.Profile.InfList\n    FdfModuleList = [PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch) for Inf in FdfInfList]\n    AllModulePcds = set()\n    ModuleSet = set(list(self._Modules.keys()) + FdfModuleList)\n    for ModuleFile in ModuleSet:\n        ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    for ModuleFile in self.LibraryInstances:\n        ModuleData = self._Bdb.CreateBuildObject(ModuleFile, self._Arch, self._Target, self._Toolchain)\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    return AllModulePcds",
            "@cached_property\ndef PlatformUsedPcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FdfInfList = []\n    if GlobalData.gFdfParser:\n        FdfInfList = GlobalData.gFdfParser.Profile.InfList\n    FdfModuleList = [PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch) for Inf in FdfInfList]\n    AllModulePcds = set()\n    ModuleSet = set(list(self._Modules.keys()) + FdfModuleList)\n    for ModuleFile in ModuleSet:\n        ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    for ModuleFile in self.LibraryInstances:\n        ModuleData = self._Bdb.CreateBuildObject(ModuleFile, self._Arch, self._Target, self._Toolchain)\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    return AllModulePcds",
            "@cached_property\ndef PlatformUsedPcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FdfInfList = []\n    if GlobalData.gFdfParser:\n        FdfInfList = GlobalData.gFdfParser.Profile.InfList\n    FdfModuleList = [PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch) for Inf in FdfInfList]\n    AllModulePcds = set()\n    ModuleSet = set(list(self._Modules.keys()) + FdfModuleList)\n    for ModuleFile in ModuleSet:\n        ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    for ModuleFile in self.LibraryInstances:\n        ModuleData = self._Bdb.CreateBuildObject(ModuleFile, self._Arch, self._Target, self._Toolchain)\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    return AllModulePcds",
            "@cached_property\ndef PlatformUsedPcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FdfInfList = []\n    if GlobalData.gFdfParser:\n        FdfInfList = GlobalData.gFdfParser.Profile.InfList\n    FdfModuleList = [PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch) for Inf in FdfInfList]\n    AllModulePcds = set()\n    ModuleSet = set(list(self._Modules.keys()) + FdfModuleList)\n    for ModuleFile in ModuleSet:\n        ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    for ModuleFile in self.LibraryInstances:\n        ModuleData = self._Bdb.CreateBuildObject(ModuleFile, self._Arch, self._Target, self._Toolchain)\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    return AllModulePcds",
            "@cached_property\ndef PlatformUsedPcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FdfInfList = []\n    if GlobalData.gFdfParser:\n        FdfInfList = GlobalData.gFdfParser.Profile.InfList\n    FdfModuleList = [PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch) for Inf in FdfInfList]\n    AllModulePcds = set()\n    ModuleSet = set(list(self._Modules.keys()) + FdfModuleList)\n    for ModuleFile in ModuleSet:\n        ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    for ModuleFile in self.LibraryInstances:\n        ModuleData = self._Bdb.CreateBuildObject(ModuleFile, self._Arch, self._Target, self._Toolchain)\n        AllModulePcds = AllModulePcds | ModuleData.PcdsName\n    return AllModulePcds"
        ]
    },
    {
        "func_name": "FilterStrcturePcd",
        "original": "def FilterStrcturePcd(self, S_pcd_set):\n    UnusedStruPcds = set(S_pcd_set.keys()) - self.PlatformUsedPcds\n    for (Token, TokenSpaceGuid) in UnusedStruPcds:\n        del S_pcd_set[Token, TokenSpaceGuid]",
        "mutated": [
            "def FilterStrcturePcd(self, S_pcd_set):\n    if False:\n        i = 10\n    UnusedStruPcds = set(S_pcd_set.keys()) - self.PlatformUsedPcds\n    for (Token, TokenSpaceGuid) in UnusedStruPcds:\n        del S_pcd_set[Token, TokenSpaceGuid]",
            "def FilterStrcturePcd(self, S_pcd_set):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    UnusedStruPcds = set(S_pcd_set.keys()) - self.PlatformUsedPcds\n    for (Token, TokenSpaceGuid) in UnusedStruPcds:\n        del S_pcd_set[Token, TokenSpaceGuid]",
            "def FilterStrcturePcd(self, S_pcd_set):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    UnusedStruPcds = set(S_pcd_set.keys()) - self.PlatformUsedPcds\n    for (Token, TokenSpaceGuid) in UnusedStruPcds:\n        del S_pcd_set[Token, TokenSpaceGuid]",
            "def FilterStrcturePcd(self, S_pcd_set):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    UnusedStruPcds = set(S_pcd_set.keys()) - self.PlatformUsedPcds\n    for (Token, TokenSpaceGuid) in UnusedStruPcds:\n        del S_pcd_set[Token, TokenSpaceGuid]",
            "def FilterStrcturePcd(self, S_pcd_set):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    UnusedStruPcds = set(S_pcd_set.keys()) - self.PlatformUsedPcds\n    for (Token, TokenSpaceGuid) in UnusedStruPcds:\n        del S_pcd_set[Token, TokenSpaceGuid]"
        ]
    },
    {
        "func_name": "_GetPcd",
        "original": "def _GetPcd(self, Type):\n    Pcds = OrderedDict()\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    PcdValueDict = OrderedDict()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build ', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if SkuName in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n            if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n                PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n            PcdDict[Arch, PcdCName, TokenSpaceGuid, SkuName] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, PcdCName, TokenSpaceGuid, SkuName]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        if (PcdCName, TokenSpaceGuid) in PcdValueDict:\n            PcdValueDict[PcdCName, TokenSpaceGuid][SkuName] = (PcdValue, DatumType, MaxDatumSize, Dummy4)\n        else:\n            PcdValueDict[PcdCName, TokenSpaceGuid] = {SkuName: (PcdValue, DatumType, MaxDatumSize, Dummy4)}\n    for ((PcdCName, TokenSpaceGuid), PcdSetting) in PcdValueDict.items():\n        if self.SkuIdMgr.SystemSkuId in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[self.SkuIdMgr.SystemSkuId]\n        elif TAB_DEFAULT in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_DEFAULT]\n        elif TAB_COMMON in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_COMMON]\n        else:\n            PcdValue = None\n            DatumType = None\n            MaxDatumSize = None\n        Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n        for SkuName in PcdValueDict[PcdCName, TokenSpaceGuid]:\n            Settings = PcdValueDict[PcdCName, TokenSpaceGuid][SkuName]\n            if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = Settings[0]\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Settings[3])\n    return Pcds",
        "mutated": [
            "def _GetPcd(self, Type):\n    if False:\n        i = 10\n    Pcds = OrderedDict()\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    PcdValueDict = OrderedDict()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build ', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if SkuName in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n            if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n                PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n            PcdDict[Arch, PcdCName, TokenSpaceGuid, SkuName] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, PcdCName, TokenSpaceGuid, SkuName]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        if (PcdCName, TokenSpaceGuid) in PcdValueDict:\n            PcdValueDict[PcdCName, TokenSpaceGuid][SkuName] = (PcdValue, DatumType, MaxDatumSize, Dummy4)\n        else:\n            PcdValueDict[PcdCName, TokenSpaceGuid] = {SkuName: (PcdValue, DatumType, MaxDatumSize, Dummy4)}\n    for ((PcdCName, TokenSpaceGuid), PcdSetting) in PcdValueDict.items():\n        if self.SkuIdMgr.SystemSkuId in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[self.SkuIdMgr.SystemSkuId]\n        elif TAB_DEFAULT in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_DEFAULT]\n        elif TAB_COMMON in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_COMMON]\n        else:\n            PcdValue = None\n            DatumType = None\n            MaxDatumSize = None\n        Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n        for SkuName in PcdValueDict[PcdCName, TokenSpaceGuid]:\n            Settings = PcdValueDict[PcdCName, TokenSpaceGuid][SkuName]\n            if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = Settings[0]\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Settings[3])\n    return Pcds",
            "def _GetPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Pcds = OrderedDict()\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    PcdValueDict = OrderedDict()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build ', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if SkuName in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n            if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n                PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n            PcdDict[Arch, PcdCName, TokenSpaceGuid, SkuName] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, PcdCName, TokenSpaceGuid, SkuName]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        if (PcdCName, TokenSpaceGuid) in PcdValueDict:\n            PcdValueDict[PcdCName, TokenSpaceGuid][SkuName] = (PcdValue, DatumType, MaxDatumSize, Dummy4)\n        else:\n            PcdValueDict[PcdCName, TokenSpaceGuid] = {SkuName: (PcdValue, DatumType, MaxDatumSize, Dummy4)}\n    for ((PcdCName, TokenSpaceGuid), PcdSetting) in PcdValueDict.items():\n        if self.SkuIdMgr.SystemSkuId in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[self.SkuIdMgr.SystemSkuId]\n        elif TAB_DEFAULT in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_DEFAULT]\n        elif TAB_COMMON in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_COMMON]\n        else:\n            PcdValue = None\n            DatumType = None\n            MaxDatumSize = None\n        Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n        for SkuName in PcdValueDict[PcdCName, TokenSpaceGuid]:\n            Settings = PcdValueDict[PcdCName, TokenSpaceGuid][SkuName]\n            if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = Settings[0]\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Settings[3])\n    return Pcds",
            "def _GetPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Pcds = OrderedDict()\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    PcdValueDict = OrderedDict()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build ', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if SkuName in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n            if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n                PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n            PcdDict[Arch, PcdCName, TokenSpaceGuid, SkuName] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, PcdCName, TokenSpaceGuid, SkuName]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        if (PcdCName, TokenSpaceGuid) in PcdValueDict:\n            PcdValueDict[PcdCName, TokenSpaceGuid][SkuName] = (PcdValue, DatumType, MaxDatumSize, Dummy4)\n        else:\n            PcdValueDict[PcdCName, TokenSpaceGuid] = {SkuName: (PcdValue, DatumType, MaxDatumSize, Dummy4)}\n    for ((PcdCName, TokenSpaceGuid), PcdSetting) in PcdValueDict.items():\n        if self.SkuIdMgr.SystemSkuId in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[self.SkuIdMgr.SystemSkuId]\n        elif TAB_DEFAULT in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_DEFAULT]\n        elif TAB_COMMON in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_COMMON]\n        else:\n            PcdValue = None\n            DatumType = None\n            MaxDatumSize = None\n        Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n        for SkuName in PcdValueDict[PcdCName, TokenSpaceGuid]:\n            Settings = PcdValueDict[PcdCName, TokenSpaceGuid][SkuName]\n            if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = Settings[0]\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Settings[3])\n    return Pcds",
            "def _GetPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Pcds = OrderedDict()\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    PcdValueDict = OrderedDict()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build ', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if SkuName in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n            if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n                PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n            PcdDict[Arch, PcdCName, TokenSpaceGuid, SkuName] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, PcdCName, TokenSpaceGuid, SkuName]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        if (PcdCName, TokenSpaceGuid) in PcdValueDict:\n            PcdValueDict[PcdCName, TokenSpaceGuid][SkuName] = (PcdValue, DatumType, MaxDatumSize, Dummy4)\n        else:\n            PcdValueDict[PcdCName, TokenSpaceGuid] = {SkuName: (PcdValue, DatumType, MaxDatumSize, Dummy4)}\n    for ((PcdCName, TokenSpaceGuid), PcdSetting) in PcdValueDict.items():\n        if self.SkuIdMgr.SystemSkuId in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[self.SkuIdMgr.SystemSkuId]\n        elif TAB_DEFAULT in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_DEFAULT]\n        elif TAB_COMMON in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_COMMON]\n        else:\n            PcdValue = None\n            DatumType = None\n            MaxDatumSize = None\n        Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n        for SkuName in PcdValueDict[PcdCName, TokenSpaceGuid]:\n            Settings = PcdValueDict[PcdCName, TokenSpaceGuid][SkuName]\n            if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = Settings[0]\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Settings[3])\n    return Pcds",
            "def _GetPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Pcds = OrderedDict()\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    PcdValueDict = OrderedDict()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build ', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if SkuName in (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT, TAB_COMMON):\n            if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n                PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n            PcdDict[Arch, PcdCName, TokenSpaceGuid, SkuName] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, PcdCName, TokenSpaceGuid, SkuName]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        if (PcdCName, TokenSpaceGuid) in PcdValueDict:\n            PcdValueDict[PcdCName, TokenSpaceGuid][SkuName] = (PcdValue, DatumType, MaxDatumSize, Dummy4)\n        else:\n            PcdValueDict[PcdCName, TokenSpaceGuid] = {SkuName: (PcdValue, DatumType, MaxDatumSize, Dummy4)}\n    for ((PcdCName, TokenSpaceGuid), PcdSetting) in PcdValueDict.items():\n        if self.SkuIdMgr.SystemSkuId in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[self.SkuIdMgr.SystemSkuId]\n        elif TAB_DEFAULT in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_DEFAULT]\n        elif TAB_COMMON in PcdSetting:\n            (PcdValue, DatumType, MaxDatumSize, _) = PcdSetting[TAB_COMMON]\n        else:\n            PcdValue = None\n            DatumType = None\n            MaxDatumSize = None\n        Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, {}, False, None, IsDsc=True)\n        for SkuName in PcdValueDict[PcdCName, TokenSpaceGuid]:\n            Settings = PcdValueDict[PcdCName, TokenSpaceGuid][SkuName]\n            if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n                Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = Settings[0]\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Settings[3])\n    return Pcds"
        ]
    },
    {
        "func_name": "get_length",
        "original": "def get_length(value):\n    Value = value.strip()\n    if len(value) > 1:\n        if Value.startswith(TAB_GUID) and Value.endswith(')'):\n            return 16\n        if Value.startswith('L\"') and Value.endswith('\"'):\n            return len(Value[2:-1])\n        if Value[0] == '\"' and Value[-1] == '\"':\n            return len(Value) - 2\n        if Value.strip().startswith('{CODE('):\n            tmpValue = RemoveCComments(Value)\n            return len(tmpValue.split(','))\n        if Value[0] == '{' and Value[-1] == '}':\n            return len(Value.split(','))\n        if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n            return len(list(Value[2:-1]))\n        if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n            return len(Value) - 2\n    return len(Value)",
        "mutated": [
            "def get_length(value):\n    if False:\n        i = 10\n    Value = value.strip()\n    if len(value) > 1:\n        if Value.startswith(TAB_GUID) and Value.endswith(')'):\n            return 16\n        if Value.startswith('L\"') and Value.endswith('\"'):\n            return len(Value[2:-1])\n        if Value[0] == '\"' and Value[-1] == '\"':\n            return len(Value) - 2\n        if Value.strip().startswith('{CODE('):\n            tmpValue = RemoveCComments(Value)\n            return len(tmpValue.split(','))\n        if Value[0] == '{' and Value[-1] == '}':\n            return len(Value.split(','))\n        if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n            return len(list(Value[2:-1]))\n        if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n            return len(Value) - 2\n    return len(Value)",
            "def get_length(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Value = value.strip()\n    if len(value) > 1:\n        if Value.startswith(TAB_GUID) and Value.endswith(')'):\n            return 16\n        if Value.startswith('L\"') and Value.endswith('\"'):\n            return len(Value[2:-1])\n        if Value[0] == '\"' and Value[-1] == '\"':\n            return len(Value) - 2\n        if Value.strip().startswith('{CODE('):\n            tmpValue = RemoveCComments(Value)\n            return len(tmpValue.split(','))\n        if Value[0] == '{' and Value[-1] == '}':\n            return len(Value.split(','))\n        if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n            return len(list(Value[2:-1]))\n        if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n            return len(Value) - 2\n    return len(Value)",
            "def get_length(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Value = value.strip()\n    if len(value) > 1:\n        if Value.startswith(TAB_GUID) and Value.endswith(')'):\n            return 16\n        if Value.startswith('L\"') and Value.endswith('\"'):\n            return len(Value[2:-1])\n        if Value[0] == '\"' and Value[-1] == '\"':\n            return len(Value) - 2\n        if Value.strip().startswith('{CODE('):\n            tmpValue = RemoveCComments(Value)\n            return len(tmpValue.split(','))\n        if Value[0] == '{' and Value[-1] == '}':\n            return len(Value.split(','))\n        if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n            return len(list(Value[2:-1]))\n        if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n            return len(Value) - 2\n    return len(Value)",
            "def get_length(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Value = value.strip()\n    if len(value) > 1:\n        if Value.startswith(TAB_GUID) and Value.endswith(')'):\n            return 16\n        if Value.startswith('L\"') and Value.endswith('\"'):\n            return len(Value[2:-1])\n        if Value[0] == '\"' and Value[-1] == '\"':\n            return len(Value) - 2\n        if Value.strip().startswith('{CODE('):\n            tmpValue = RemoveCComments(Value)\n            return len(tmpValue.split(','))\n        if Value[0] == '{' and Value[-1] == '}':\n            return len(Value.split(','))\n        if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n            return len(list(Value[2:-1]))\n        if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n            return len(Value) - 2\n    return len(Value)",
            "def get_length(value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Value = value.strip()\n    if len(value) > 1:\n        if Value.startswith(TAB_GUID) and Value.endswith(')'):\n            return 16\n        if Value.startswith('L\"') and Value.endswith('\"'):\n            return len(Value[2:-1])\n        if Value[0] == '\"' and Value[-1] == '\"':\n            return len(Value) - 2\n        if Value.strip().startswith('{CODE('):\n            tmpValue = RemoveCComments(Value)\n            return len(tmpValue.split(','))\n        if Value[0] == '{' and Value[-1] == '}':\n            return len(Value.split(','))\n        if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n            return len(list(Value[2:-1]))\n        if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n            return len(Value) - 2\n    return len(Value)"
        ]
    },
    {
        "func_name": "GetStructurePcdMaxSize",
        "original": "@staticmethod\ndef GetStructurePcdMaxSize(str_pcd):\n    pcd_default_value = str_pcd.DefaultValue\n    sku_values = [skuobj.HiiDefaultValue if str_pcd.Type in [DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]] else skuobj.DefaultValue for skuobj in str_pcd.SkuInfoList.values()]\n    sku_values.append(pcd_default_value)\n\n    def get_length(value):\n        Value = value.strip()\n        if len(value) > 1:\n            if Value.startswith(TAB_GUID) and Value.endswith(')'):\n                return 16\n            if Value.startswith('L\"') and Value.endswith('\"'):\n                return len(Value[2:-1])\n            if Value[0] == '\"' and Value[-1] == '\"':\n                return len(Value) - 2\n            if Value.strip().startswith('{CODE('):\n                tmpValue = RemoveCComments(Value)\n                return len(tmpValue.split(','))\n            if Value[0] == '{' and Value[-1] == '}':\n                return len(Value.split(','))\n            if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n                return len(list(Value[2:-1]))\n            if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n                return len(Value) - 2\n        return len(Value)\n    return str(max((get_length(item) for item in sku_values)))",
        "mutated": [
            "@staticmethod\ndef GetStructurePcdMaxSize(str_pcd):\n    if False:\n        i = 10\n    pcd_default_value = str_pcd.DefaultValue\n    sku_values = [skuobj.HiiDefaultValue if str_pcd.Type in [DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]] else skuobj.DefaultValue for skuobj in str_pcd.SkuInfoList.values()]\n    sku_values.append(pcd_default_value)\n\n    def get_length(value):\n        Value = value.strip()\n        if len(value) > 1:\n            if Value.startswith(TAB_GUID) and Value.endswith(')'):\n                return 16\n            if Value.startswith('L\"') and Value.endswith('\"'):\n                return len(Value[2:-1])\n            if Value[0] == '\"' and Value[-1] == '\"':\n                return len(Value) - 2\n            if Value.strip().startswith('{CODE('):\n                tmpValue = RemoveCComments(Value)\n                return len(tmpValue.split(','))\n            if Value[0] == '{' and Value[-1] == '}':\n                return len(Value.split(','))\n            if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n                return len(list(Value[2:-1]))\n            if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n                return len(Value) - 2\n        return len(Value)\n    return str(max((get_length(item) for item in sku_values)))",
            "@staticmethod\ndef GetStructurePcdMaxSize(str_pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pcd_default_value = str_pcd.DefaultValue\n    sku_values = [skuobj.HiiDefaultValue if str_pcd.Type in [DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]] else skuobj.DefaultValue for skuobj in str_pcd.SkuInfoList.values()]\n    sku_values.append(pcd_default_value)\n\n    def get_length(value):\n        Value = value.strip()\n        if len(value) > 1:\n            if Value.startswith(TAB_GUID) and Value.endswith(')'):\n                return 16\n            if Value.startswith('L\"') and Value.endswith('\"'):\n                return len(Value[2:-1])\n            if Value[0] == '\"' and Value[-1] == '\"':\n                return len(Value) - 2\n            if Value.strip().startswith('{CODE('):\n                tmpValue = RemoveCComments(Value)\n                return len(tmpValue.split(','))\n            if Value[0] == '{' and Value[-1] == '}':\n                return len(Value.split(','))\n            if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n                return len(list(Value[2:-1]))\n            if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n                return len(Value) - 2\n        return len(Value)\n    return str(max((get_length(item) for item in sku_values)))",
            "@staticmethod\ndef GetStructurePcdMaxSize(str_pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pcd_default_value = str_pcd.DefaultValue\n    sku_values = [skuobj.HiiDefaultValue if str_pcd.Type in [DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]] else skuobj.DefaultValue for skuobj in str_pcd.SkuInfoList.values()]\n    sku_values.append(pcd_default_value)\n\n    def get_length(value):\n        Value = value.strip()\n        if len(value) > 1:\n            if Value.startswith(TAB_GUID) and Value.endswith(')'):\n                return 16\n            if Value.startswith('L\"') and Value.endswith('\"'):\n                return len(Value[2:-1])\n            if Value[0] == '\"' and Value[-1] == '\"':\n                return len(Value) - 2\n            if Value.strip().startswith('{CODE('):\n                tmpValue = RemoveCComments(Value)\n                return len(tmpValue.split(','))\n            if Value[0] == '{' and Value[-1] == '}':\n                return len(Value.split(','))\n            if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n                return len(list(Value[2:-1]))\n            if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n                return len(Value) - 2\n        return len(Value)\n    return str(max((get_length(item) for item in sku_values)))",
            "@staticmethod\ndef GetStructurePcdMaxSize(str_pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pcd_default_value = str_pcd.DefaultValue\n    sku_values = [skuobj.HiiDefaultValue if str_pcd.Type in [DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]] else skuobj.DefaultValue for skuobj in str_pcd.SkuInfoList.values()]\n    sku_values.append(pcd_default_value)\n\n    def get_length(value):\n        Value = value.strip()\n        if len(value) > 1:\n            if Value.startswith(TAB_GUID) and Value.endswith(')'):\n                return 16\n            if Value.startswith('L\"') and Value.endswith('\"'):\n                return len(Value[2:-1])\n            if Value[0] == '\"' and Value[-1] == '\"':\n                return len(Value) - 2\n            if Value.strip().startswith('{CODE('):\n                tmpValue = RemoveCComments(Value)\n                return len(tmpValue.split(','))\n            if Value[0] == '{' and Value[-1] == '}':\n                return len(Value.split(','))\n            if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n                return len(list(Value[2:-1]))\n            if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n                return len(Value) - 2\n        return len(Value)\n    return str(max((get_length(item) for item in sku_values)))",
            "@staticmethod\ndef GetStructurePcdMaxSize(str_pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pcd_default_value = str_pcd.DefaultValue\n    sku_values = [skuobj.HiiDefaultValue if str_pcd.Type in [DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], DscBuildData._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]] else skuobj.DefaultValue for skuobj in str_pcd.SkuInfoList.values()]\n    sku_values.append(pcd_default_value)\n\n    def get_length(value):\n        Value = value.strip()\n        if len(value) > 1:\n            if Value.startswith(TAB_GUID) and Value.endswith(')'):\n                return 16\n            if Value.startswith('L\"') and Value.endswith('\"'):\n                return len(Value[2:-1])\n            if Value[0] == '\"' and Value[-1] == '\"':\n                return len(Value) - 2\n            if Value.strip().startswith('{CODE('):\n                tmpValue = RemoveCComments(Value)\n                return len(tmpValue.split(','))\n            if Value[0] == '{' and Value[-1] == '}':\n                return len(Value.split(','))\n            if Value.startswith(\"L'\") and Value.endswith(\"'\") and (len(list(Value[2:-1])) > 1):\n                return len(list(Value[2:-1]))\n            if Value[0] == \"'\" and Value[-1] == \"'\" and (len(list(Value[1:-1])) > 1):\n                return len(Value) - 2\n        return len(Value)\n    return str(max((get_length(item) for item in sku_values)))"
        ]
    },
    {
        "func_name": "ExecuteCommand",
        "original": "@staticmethod\ndef ExecuteCommand(Command):\n    try:\n        Process = subprocess.Popen(Command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    except:\n        EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s' % Command)\n    Result = Process.communicate()\n    return (Process.returncode, Result[0].decode(errors='ignore'), Result[1].decode(errors='ignore'))",
        "mutated": [
            "@staticmethod\ndef ExecuteCommand(Command):\n    if False:\n        i = 10\n    try:\n        Process = subprocess.Popen(Command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    except:\n        EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s' % Command)\n    Result = Process.communicate()\n    return (Process.returncode, Result[0].decode(errors='ignore'), Result[1].decode(errors='ignore'))",
            "@staticmethod\ndef ExecuteCommand(Command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        Process = subprocess.Popen(Command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    except:\n        EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s' % Command)\n    Result = Process.communicate()\n    return (Process.returncode, Result[0].decode(errors='ignore'), Result[1].decode(errors='ignore'))",
            "@staticmethod\ndef ExecuteCommand(Command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        Process = subprocess.Popen(Command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    except:\n        EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s' % Command)\n    Result = Process.communicate()\n    return (Process.returncode, Result[0].decode(errors='ignore'), Result[1].decode(errors='ignore'))",
            "@staticmethod\ndef ExecuteCommand(Command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        Process = subprocess.Popen(Command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    except:\n        EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s' % Command)\n    Result = Process.communicate()\n    return (Process.returncode, Result[0].decode(errors='ignore'), Result[1].decode(errors='ignore'))",
            "@staticmethod\ndef ExecuteCommand(Command):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        Process = subprocess.Popen(Command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n    except:\n        EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s' % Command)\n    Result = Process.communicate()\n    return (Process.returncode, Result[0].decode(errors='ignore'), Result[1].decode(errors='ignore'))"
        ]
    },
    {
        "func_name": "IntToCString",
        "original": "@staticmethod\ndef IntToCString(Value, ValueSize):\n    Result = '\"'\n    if not isinstance(Value, str):\n        for Index in range(0, ValueSize):\n            Result = Result + '\\\\x%02x' % (Value & 255)\n            Value = Value >> 8\n    Result = Result + '\"'\n    return Result",
        "mutated": [
            "@staticmethod\ndef IntToCString(Value, ValueSize):\n    if False:\n        i = 10\n    Result = '\"'\n    if not isinstance(Value, str):\n        for Index in range(0, ValueSize):\n            Result = Result + '\\\\x%02x' % (Value & 255)\n            Value = Value >> 8\n    Result = Result + '\"'\n    return Result",
            "@staticmethod\ndef IntToCString(Value, ValueSize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Result = '\"'\n    if not isinstance(Value, str):\n        for Index in range(0, ValueSize):\n            Result = Result + '\\\\x%02x' % (Value & 255)\n            Value = Value >> 8\n    Result = Result + '\"'\n    return Result",
            "@staticmethod\ndef IntToCString(Value, ValueSize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Result = '\"'\n    if not isinstance(Value, str):\n        for Index in range(0, ValueSize):\n            Result = Result + '\\\\x%02x' % (Value & 255)\n            Value = Value >> 8\n    Result = Result + '\"'\n    return Result",
            "@staticmethod\ndef IntToCString(Value, ValueSize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Result = '\"'\n    if not isinstance(Value, str):\n        for Index in range(0, ValueSize):\n            Result = Result + '\\\\x%02x' % (Value & 255)\n            Value = Value >> 8\n    Result = Result + '\"'\n    return Result",
            "@staticmethod\ndef IntToCString(Value, ValueSize):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Result = '\"'\n    if not isinstance(Value, str):\n        for Index in range(0, ValueSize):\n            Result = Result + '\\\\x%02x' % (Value & 255)\n            Value = Value >> 8\n    Result = Result + '\"'\n    return Result"
        ]
    },
    {
        "func_name": "GenerateSizeFunction",
        "original": "def GenerateSizeFunction(self, Pcd):\n    CApp = '// Default Value in Dec \\n'\n    CApp = CApp + 'void Cal_%s_%s_Size(UINT32 *Size){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n        CApp += '  *Size = (sizeof (%s) > *Size ? sizeof (%s) : *Size);\\n' % (Pcd.DatumType, Pcd.DatumType)\n    else:\n        if '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp += '  *Size = (sizeof (%s_%s_INIT_Value) > *Size ? sizeof (%s_%s_INIT_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n            for skuname in Pcd.SkuInfoList:\n                skuobj = Pcd.SkuInfoList[skuname]\n                if skuobj.VariableName:\n                    for defaultstore in skuobj.DefaultStoreDict:\n                        pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                        if pcddef:\n                            if '{CODE(' in pcddef:\n                                CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore)\n                            else:\n                                CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n                else:\n                    pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                    if pcddef:\n                        if '{CODE(' in pcddef:\n                            CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                        else:\n                            CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n        else:\n            pcddef = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n            if pcddef:\n                if '{CODE(' in pcddef:\n                    CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n                else:\n                    CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n    ActualCap = []\n    for index in Pcd.DefaultValues:\n        if index:\n            ActualCap.append(index)\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            FieldName = '.' + FieldName\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n            if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                try:\n                    Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                (Value, ValueSize) = ParseFieldValue(Value)\n                if not Pcd.IsArray():\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0));  // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n            else:\n                NewFieldName = ''\n                FieldName_ori = FieldName.strip('.')\n                while '[' in FieldName:\n                    NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                    Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                    FieldName = FieldName.split(']', 1)[1]\n                FieldName = NewFieldName + FieldName\n                while '[' in FieldName and (not Pcd.IsArray()):\n                    FieldName = FieldName.rsplit('[', 1)[0]\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    flexisbale_size_statement_cache = set()\n    for skuname in Pcd.SkuOverrideValues:\n        if skuname == TAB_COMMON:\n            continue\n        for defaultstorenameitem in Pcd.SkuOverrideValues[skuname]:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n            for index in Pcd.SkuOverrideValues[skuname][defaultstorenameitem]:\n                if index:\n                    ActualCap.append(index)\n                for FieldList in [Pcd.SkuOverrideValues[skuname][defaultstorenameitem][index]]:\n                    if not FieldList:\n                        continue\n                    for FieldName in FieldList:\n                        fieldinfo = tuple(FieldList[FieldName])\n                        if fieldinfo in flexisbale_size_statement_cache:\n                            continue\n                        flexisbale_size_statement_cache.add(fieldinfo)\n                        FieldName = '.' + FieldName\n                        IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n                        if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                            try:\n                                Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                            except BadExpression:\n                                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                            (Value, ValueSize) = ParseFieldValue(Value)\n                            if not Pcd.IsArray():\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n                        else:\n                            NewFieldName = ''\n                            FieldName_ori = FieldName.strip('.')\n                            while '[' in FieldName:\n                                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                                FieldName = FieldName.split(']', 1)[1]\n                            FieldName = NewFieldName + FieldName\n                            while '[' in FieldName and (not Pcd.IsArray()):\n                                FieldName = FieldName.rsplit('[', 1)[0]\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromFdf:\n        CApp = CApp + '// From fdf \\n'\n    for FieldName in Pcd.PcdFieldValueFromFdf:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName:\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %s Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromFdf[FieldName_ori][1], Pcd.PcdFieldValueFromFdf[FieldName_ori][2], Pcd.PcdFieldValueFromFdf[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromComm:\n        CApp = CApp + '// From Command Line \\n'\n    for FieldName in Pcd.PcdFieldValueFromComm:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName and (not Pcd.IsArray()):\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromComm[FieldName_ori][1], Pcd.PcdFieldValueFromComm[FieldName_ori][2], Pcd.PcdFieldValueFromComm[FieldName_ori][0])\n    if Pcd.GetPcdMaxSize():\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); // The Pcd maxsize is %d \\n' % (Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize())\n    ArraySizeByAssign = self.CalculateActualCap(ActualCap)\n    if ArraySizeByAssign > 1:\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); \\n' % (ArraySizeByAssign, ArraySizeByAssign)\n    CApp = CApp + '}\\n'\n    return CApp",
        "mutated": [
            "def GenerateSizeFunction(self, Pcd):\n    if False:\n        i = 10\n    CApp = '// Default Value in Dec \\n'\n    CApp = CApp + 'void Cal_%s_%s_Size(UINT32 *Size){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n        CApp += '  *Size = (sizeof (%s) > *Size ? sizeof (%s) : *Size);\\n' % (Pcd.DatumType, Pcd.DatumType)\n    else:\n        if '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp += '  *Size = (sizeof (%s_%s_INIT_Value) > *Size ? sizeof (%s_%s_INIT_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n            for skuname in Pcd.SkuInfoList:\n                skuobj = Pcd.SkuInfoList[skuname]\n                if skuobj.VariableName:\n                    for defaultstore in skuobj.DefaultStoreDict:\n                        pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                        if pcddef:\n                            if '{CODE(' in pcddef:\n                                CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore)\n                            else:\n                                CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n                else:\n                    pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                    if pcddef:\n                        if '{CODE(' in pcddef:\n                            CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                        else:\n                            CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n        else:\n            pcddef = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n            if pcddef:\n                if '{CODE(' in pcddef:\n                    CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n                else:\n                    CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n    ActualCap = []\n    for index in Pcd.DefaultValues:\n        if index:\n            ActualCap.append(index)\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            FieldName = '.' + FieldName\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n            if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                try:\n                    Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                (Value, ValueSize) = ParseFieldValue(Value)\n                if not Pcd.IsArray():\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0));  // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n            else:\n                NewFieldName = ''\n                FieldName_ori = FieldName.strip('.')\n                while '[' in FieldName:\n                    NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                    Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                    FieldName = FieldName.split(']', 1)[1]\n                FieldName = NewFieldName + FieldName\n                while '[' in FieldName and (not Pcd.IsArray()):\n                    FieldName = FieldName.rsplit('[', 1)[0]\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    flexisbale_size_statement_cache = set()\n    for skuname in Pcd.SkuOverrideValues:\n        if skuname == TAB_COMMON:\n            continue\n        for defaultstorenameitem in Pcd.SkuOverrideValues[skuname]:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n            for index in Pcd.SkuOverrideValues[skuname][defaultstorenameitem]:\n                if index:\n                    ActualCap.append(index)\n                for FieldList in [Pcd.SkuOverrideValues[skuname][defaultstorenameitem][index]]:\n                    if not FieldList:\n                        continue\n                    for FieldName in FieldList:\n                        fieldinfo = tuple(FieldList[FieldName])\n                        if fieldinfo in flexisbale_size_statement_cache:\n                            continue\n                        flexisbale_size_statement_cache.add(fieldinfo)\n                        FieldName = '.' + FieldName\n                        IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n                        if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                            try:\n                                Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                            except BadExpression:\n                                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                            (Value, ValueSize) = ParseFieldValue(Value)\n                            if not Pcd.IsArray():\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n                        else:\n                            NewFieldName = ''\n                            FieldName_ori = FieldName.strip('.')\n                            while '[' in FieldName:\n                                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                                FieldName = FieldName.split(']', 1)[1]\n                            FieldName = NewFieldName + FieldName\n                            while '[' in FieldName and (not Pcd.IsArray()):\n                                FieldName = FieldName.rsplit('[', 1)[0]\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromFdf:\n        CApp = CApp + '// From fdf \\n'\n    for FieldName in Pcd.PcdFieldValueFromFdf:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName:\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %s Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromFdf[FieldName_ori][1], Pcd.PcdFieldValueFromFdf[FieldName_ori][2], Pcd.PcdFieldValueFromFdf[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromComm:\n        CApp = CApp + '// From Command Line \\n'\n    for FieldName in Pcd.PcdFieldValueFromComm:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName and (not Pcd.IsArray()):\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromComm[FieldName_ori][1], Pcd.PcdFieldValueFromComm[FieldName_ori][2], Pcd.PcdFieldValueFromComm[FieldName_ori][0])\n    if Pcd.GetPcdMaxSize():\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); // The Pcd maxsize is %d \\n' % (Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize())\n    ArraySizeByAssign = self.CalculateActualCap(ActualCap)\n    if ArraySizeByAssign > 1:\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); \\n' % (ArraySizeByAssign, ArraySizeByAssign)\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateSizeFunction(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '// Default Value in Dec \\n'\n    CApp = CApp + 'void Cal_%s_%s_Size(UINT32 *Size){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n        CApp += '  *Size = (sizeof (%s) > *Size ? sizeof (%s) : *Size);\\n' % (Pcd.DatumType, Pcd.DatumType)\n    else:\n        if '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp += '  *Size = (sizeof (%s_%s_INIT_Value) > *Size ? sizeof (%s_%s_INIT_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n            for skuname in Pcd.SkuInfoList:\n                skuobj = Pcd.SkuInfoList[skuname]\n                if skuobj.VariableName:\n                    for defaultstore in skuobj.DefaultStoreDict:\n                        pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                        if pcddef:\n                            if '{CODE(' in pcddef:\n                                CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore)\n                            else:\n                                CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n                else:\n                    pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                    if pcddef:\n                        if '{CODE(' in pcddef:\n                            CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                        else:\n                            CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n        else:\n            pcddef = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n            if pcddef:\n                if '{CODE(' in pcddef:\n                    CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n                else:\n                    CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n    ActualCap = []\n    for index in Pcd.DefaultValues:\n        if index:\n            ActualCap.append(index)\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            FieldName = '.' + FieldName\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n            if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                try:\n                    Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                (Value, ValueSize) = ParseFieldValue(Value)\n                if not Pcd.IsArray():\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0));  // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n            else:\n                NewFieldName = ''\n                FieldName_ori = FieldName.strip('.')\n                while '[' in FieldName:\n                    NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                    Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                    FieldName = FieldName.split(']', 1)[1]\n                FieldName = NewFieldName + FieldName\n                while '[' in FieldName and (not Pcd.IsArray()):\n                    FieldName = FieldName.rsplit('[', 1)[0]\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    flexisbale_size_statement_cache = set()\n    for skuname in Pcd.SkuOverrideValues:\n        if skuname == TAB_COMMON:\n            continue\n        for defaultstorenameitem in Pcd.SkuOverrideValues[skuname]:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n            for index in Pcd.SkuOverrideValues[skuname][defaultstorenameitem]:\n                if index:\n                    ActualCap.append(index)\n                for FieldList in [Pcd.SkuOverrideValues[skuname][defaultstorenameitem][index]]:\n                    if not FieldList:\n                        continue\n                    for FieldName in FieldList:\n                        fieldinfo = tuple(FieldList[FieldName])\n                        if fieldinfo in flexisbale_size_statement_cache:\n                            continue\n                        flexisbale_size_statement_cache.add(fieldinfo)\n                        FieldName = '.' + FieldName\n                        IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n                        if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                            try:\n                                Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                            except BadExpression:\n                                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                            (Value, ValueSize) = ParseFieldValue(Value)\n                            if not Pcd.IsArray():\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n                        else:\n                            NewFieldName = ''\n                            FieldName_ori = FieldName.strip('.')\n                            while '[' in FieldName:\n                                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                                FieldName = FieldName.split(']', 1)[1]\n                            FieldName = NewFieldName + FieldName\n                            while '[' in FieldName and (not Pcd.IsArray()):\n                                FieldName = FieldName.rsplit('[', 1)[0]\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromFdf:\n        CApp = CApp + '// From fdf \\n'\n    for FieldName in Pcd.PcdFieldValueFromFdf:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName:\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %s Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromFdf[FieldName_ori][1], Pcd.PcdFieldValueFromFdf[FieldName_ori][2], Pcd.PcdFieldValueFromFdf[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromComm:\n        CApp = CApp + '// From Command Line \\n'\n    for FieldName in Pcd.PcdFieldValueFromComm:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName and (not Pcd.IsArray()):\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromComm[FieldName_ori][1], Pcd.PcdFieldValueFromComm[FieldName_ori][2], Pcd.PcdFieldValueFromComm[FieldName_ori][0])\n    if Pcd.GetPcdMaxSize():\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); // The Pcd maxsize is %d \\n' % (Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize())\n    ArraySizeByAssign = self.CalculateActualCap(ActualCap)\n    if ArraySizeByAssign > 1:\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); \\n' % (ArraySizeByAssign, ArraySizeByAssign)\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateSizeFunction(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '// Default Value in Dec \\n'\n    CApp = CApp + 'void Cal_%s_%s_Size(UINT32 *Size){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n        CApp += '  *Size = (sizeof (%s) > *Size ? sizeof (%s) : *Size);\\n' % (Pcd.DatumType, Pcd.DatumType)\n    else:\n        if '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp += '  *Size = (sizeof (%s_%s_INIT_Value) > *Size ? sizeof (%s_%s_INIT_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n            for skuname in Pcd.SkuInfoList:\n                skuobj = Pcd.SkuInfoList[skuname]\n                if skuobj.VariableName:\n                    for defaultstore in skuobj.DefaultStoreDict:\n                        pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                        if pcddef:\n                            if '{CODE(' in pcddef:\n                                CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore)\n                            else:\n                                CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n                else:\n                    pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                    if pcddef:\n                        if '{CODE(' in pcddef:\n                            CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                        else:\n                            CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n        else:\n            pcddef = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n            if pcddef:\n                if '{CODE(' in pcddef:\n                    CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n                else:\n                    CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n    ActualCap = []\n    for index in Pcd.DefaultValues:\n        if index:\n            ActualCap.append(index)\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            FieldName = '.' + FieldName\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n            if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                try:\n                    Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                (Value, ValueSize) = ParseFieldValue(Value)\n                if not Pcd.IsArray():\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0));  // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n            else:\n                NewFieldName = ''\n                FieldName_ori = FieldName.strip('.')\n                while '[' in FieldName:\n                    NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                    Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                    FieldName = FieldName.split(']', 1)[1]\n                FieldName = NewFieldName + FieldName\n                while '[' in FieldName and (not Pcd.IsArray()):\n                    FieldName = FieldName.rsplit('[', 1)[0]\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    flexisbale_size_statement_cache = set()\n    for skuname in Pcd.SkuOverrideValues:\n        if skuname == TAB_COMMON:\n            continue\n        for defaultstorenameitem in Pcd.SkuOverrideValues[skuname]:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n            for index in Pcd.SkuOverrideValues[skuname][defaultstorenameitem]:\n                if index:\n                    ActualCap.append(index)\n                for FieldList in [Pcd.SkuOverrideValues[skuname][defaultstorenameitem][index]]:\n                    if not FieldList:\n                        continue\n                    for FieldName in FieldList:\n                        fieldinfo = tuple(FieldList[FieldName])\n                        if fieldinfo in flexisbale_size_statement_cache:\n                            continue\n                        flexisbale_size_statement_cache.add(fieldinfo)\n                        FieldName = '.' + FieldName\n                        IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n                        if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                            try:\n                                Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                            except BadExpression:\n                                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                            (Value, ValueSize) = ParseFieldValue(Value)\n                            if not Pcd.IsArray():\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n                        else:\n                            NewFieldName = ''\n                            FieldName_ori = FieldName.strip('.')\n                            while '[' in FieldName:\n                                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                                FieldName = FieldName.split(']', 1)[1]\n                            FieldName = NewFieldName + FieldName\n                            while '[' in FieldName and (not Pcd.IsArray()):\n                                FieldName = FieldName.rsplit('[', 1)[0]\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromFdf:\n        CApp = CApp + '// From fdf \\n'\n    for FieldName in Pcd.PcdFieldValueFromFdf:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName:\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %s Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromFdf[FieldName_ori][1], Pcd.PcdFieldValueFromFdf[FieldName_ori][2], Pcd.PcdFieldValueFromFdf[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromComm:\n        CApp = CApp + '// From Command Line \\n'\n    for FieldName in Pcd.PcdFieldValueFromComm:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName and (not Pcd.IsArray()):\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromComm[FieldName_ori][1], Pcd.PcdFieldValueFromComm[FieldName_ori][2], Pcd.PcdFieldValueFromComm[FieldName_ori][0])\n    if Pcd.GetPcdMaxSize():\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); // The Pcd maxsize is %d \\n' % (Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize())\n    ArraySizeByAssign = self.CalculateActualCap(ActualCap)\n    if ArraySizeByAssign > 1:\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); \\n' % (ArraySizeByAssign, ArraySizeByAssign)\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateSizeFunction(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '// Default Value in Dec \\n'\n    CApp = CApp + 'void Cal_%s_%s_Size(UINT32 *Size){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n        CApp += '  *Size = (sizeof (%s) > *Size ? sizeof (%s) : *Size);\\n' % (Pcd.DatumType, Pcd.DatumType)\n    else:\n        if '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp += '  *Size = (sizeof (%s_%s_INIT_Value) > *Size ? sizeof (%s_%s_INIT_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n            for skuname in Pcd.SkuInfoList:\n                skuobj = Pcd.SkuInfoList[skuname]\n                if skuobj.VariableName:\n                    for defaultstore in skuobj.DefaultStoreDict:\n                        pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                        if pcddef:\n                            if '{CODE(' in pcddef:\n                                CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore)\n                            else:\n                                CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n                else:\n                    pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                    if pcddef:\n                        if '{CODE(' in pcddef:\n                            CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                        else:\n                            CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n        else:\n            pcddef = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n            if pcddef:\n                if '{CODE(' in pcddef:\n                    CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n                else:\n                    CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n    ActualCap = []\n    for index in Pcd.DefaultValues:\n        if index:\n            ActualCap.append(index)\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            FieldName = '.' + FieldName\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n            if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                try:\n                    Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                (Value, ValueSize) = ParseFieldValue(Value)\n                if not Pcd.IsArray():\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0));  // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n            else:\n                NewFieldName = ''\n                FieldName_ori = FieldName.strip('.')\n                while '[' in FieldName:\n                    NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                    Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                    FieldName = FieldName.split(']', 1)[1]\n                FieldName = NewFieldName + FieldName\n                while '[' in FieldName and (not Pcd.IsArray()):\n                    FieldName = FieldName.rsplit('[', 1)[0]\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    flexisbale_size_statement_cache = set()\n    for skuname in Pcd.SkuOverrideValues:\n        if skuname == TAB_COMMON:\n            continue\n        for defaultstorenameitem in Pcd.SkuOverrideValues[skuname]:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n            for index in Pcd.SkuOverrideValues[skuname][defaultstorenameitem]:\n                if index:\n                    ActualCap.append(index)\n                for FieldList in [Pcd.SkuOverrideValues[skuname][defaultstorenameitem][index]]:\n                    if not FieldList:\n                        continue\n                    for FieldName in FieldList:\n                        fieldinfo = tuple(FieldList[FieldName])\n                        if fieldinfo in flexisbale_size_statement_cache:\n                            continue\n                        flexisbale_size_statement_cache.add(fieldinfo)\n                        FieldName = '.' + FieldName\n                        IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n                        if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                            try:\n                                Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                            except BadExpression:\n                                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                            (Value, ValueSize) = ParseFieldValue(Value)\n                            if not Pcd.IsArray():\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n                        else:\n                            NewFieldName = ''\n                            FieldName_ori = FieldName.strip('.')\n                            while '[' in FieldName:\n                                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                                FieldName = FieldName.split(']', 1)[1]\n                            FieldName = NewFieldName + FieldName\n                            while '[' in FieldName and (not Pcd.IsArray()):\n                                FieldName = FieldName.rsplit('[', 1)[0]\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromFdf:\n        CApp = CApp + '// From fdf \\n'\n    for FieldName in Pcd.PcdFieldValueFromFdf:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName:\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %s Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromFdf[FieldName_ori][1], Pcd.PcdFieldValueFromFdf[FieldName_ori][2], Pcd.PcdFieldValueFromFdf[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromComm:\n        CApp = CApp + '// From Command Line \\n'\n    for FieldName in Pcd.PcdFieldValueFromComm:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName and (not Pcd.IsArray()):\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromComm[FieldName_ori][1], Pcd.PcdFieldValueFromComm[FieldName_ori][2], Pcd.PcdFieldValueFromComm[FieldName_ori][0])\n    if Pcd.GetPcdMaxSize():\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); // The Pcd maxsize is %d \\n' % (Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize())\n    ArraySizeByAssign = self.CalculateActualCap(ActualCap)\n    if ArraySizeByAssign > 1:\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); \\n' % (ArraySizeByAssign, ArraySizeByAssign)\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateSizeFunction(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '// Default Value in Dec \\n'\n    CApp = CApp + 'void Cal_%s_%s_Size(UINT32 *Size){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n        CApp += '  *Size = (sizeof (%s) > *Size ? sizeof (%s) : *Size);\\n' % (Pcd.DatumType, Pcd.DatumType)\n    else:\n        if '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp += '  *Size = (sizeof (%s_%s_INIT_Value) > *Size ? sizeof (%s_%s_INIT_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n            for skuname in Pcd.SkuInfoList:\n                skuobj = Pcd.SkuInfoList[skuname]\n                if skuobj.VariableName:\n                    for defaultstore in skuobj.DefaultStoreDict:\n                        pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                        if pcddef:\n                            if '{CODE(' in pcddef:\n                                CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore)\n                            else:\n                                CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n                else:\n                    pcddef = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                    if pcddef:\n                        if '{CODE(' in pcddef:\n                            CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                        else:\n                            CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n        else:\n            pcddef = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n            if pcddef:\n                if '{CODE(' in pcddef:\n                    CApp += '  *Size = (sizeof (%s_%s_%s_%s_Value) > *Size ? sizeof (%s_%s_%s_%s_Value) : *Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n                else:\n                    CApp += '  *Size = %s > *Size ? %s : *Size;\\n' % (self.GetStructurePcdMaxSize(Pcd), self.GetStructurePcdMaxSize(Pcd))\n    ActualCap = []\n    for index in Pcd.DefaultValues:\n        if index:\n            ActualCap.append(index)\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            FieldName = '.' + FieldName\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n            if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                try:\n                    Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                (Value, ValueSize) = ParseFieldValue(Value)\n                if not Pcd.IsArray():\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0));  // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n            else:\n                NewFieldName = ''\n                FieldName_ori = FieldName.strip('.')\n                while '[' in FieldName:\n                    NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                    Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                    FieldName = FieldName.split(']', 1)[1]\n                FieldName = NewFieldName + FieldName\n                while '[' in FieldName and (not Pcd.IsArray()):\n                    FieldName = FieldName.rsplit('[', 1)[0]\n                    CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    flexisbale_size_statement_cache = set()\n    for skuname in Pcd.SkuOverrideValues:\n        if skuname == TAB_COMMON:\n            continue\n        for defaultstorenameitem in Pcd.SkuOverrideValues[skuname]:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n            for index in Pcd.SkuOverrideValues[skuname][defaultstorenameitem]:\n                if index:\n                    ActualCap.append(index)\n                for FieldList in [Pcd.SkuOverrideValues[skuname][defaultstorenameitem][index]]:\n                    if not FieldList:\n                        continue\n                    for FieldName in FieldList:\n                        fieldinfo = tuple(FieldList[FieldName])\n                        if fieldinfo in flexisbale_size_statement_cache:\n                            continue\n                        flexisbale_size_statement_cache.add(fieldinfo)\n                        FieldName = '.' + FieldName\n                        IsArray = _IsFieldValueAnArray(FieldList[FieldName.strip('.')][0])\n                        if IsArray and (not (FieldList[FieldName.strip('.')][0].startswith('{GUID') and FieldList[FieldName.strip('.')][0].endswith('}'))):\n                            try:\n                                Value = ValueExpressionEx(FieldList[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n                            except BadExpression:\n                                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2]))\n                            (Value, ValueSize) = ParseFieldValue(Value)\n                            if not Pcd.IsArray():\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), FieldList[FieldName.strip('.')][1], FieldList[FieldName.strip('.')][2], FieldList[FieldName.strip('.')][0])\n                        else:\n                            NewFieldName = ''\n                            FieldName_ori = FieldName.strip('.')\n                            while '[' in FieldName:\n                                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                                FieldName = FieldName.split(']', 1)[1]\n                            FieldName = NewFieldName + FieldName\n                            while '[' in FieldName and (not Pcd.IsArray()):\n                                FieldName = FieldName.rsplit('[', 1)[0]\n                                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, FieldList[FieldName_ori][1], FieldList[FieldName_ori][2], FieldList[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromFdf:\n        CApp = CApp + '// From fdf \\n'\n    for FieldName in Pcd.PcdFieldValueFromFdf:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][1], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][2], Pcd.PcdFieldValueFromFdf[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName:\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %s Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromFdf[FieldName_ori][1], Pcd.PcdFieldValueFromFdf[FieldName_ori][2], Pcd.PcdFieldValueFromFdf[FieldName_ori][0])\n    if Pcd.PcdFieldValueFromComm:\n        CApp = CApp + '// From Command Line \\n'\n    for FieldName in Pcd.PcdFieldValueFromComm:\n        FieldName = '.' + FieldName\n        IsArray = _IsFieldValueAnArray(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        if IsArray and (not (Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].startswith('{GUID') and Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0].endswith('}'))):\n            try:\n                Value = ValueExpressionEx(Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0], TAB_VOID, self._GuidDict)(True)\n            except BadExpression:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName.strip('.'))), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2]))\n            (Value, ValueSize) = ParseFieldValue(Value)\n            if not Pcd.IsArray():\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d / __ARRAY_ELEMENT_SIZE(%s, %s) + ((%d %% __ARRAY_ELEMENT_SIZE(%s, %s)) ? 1 : 0)); // From %s Line %d Value %s\\n' % (Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), ValueSize, Pcd.DatumType, FieldName.strip('.'), Pcd.PcdFieldValueFromComm[FieldName.strip('.')][1], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][2], Pcd.PcdFieldValueFromComm[FieldName.strip('.')][0])\n        else:\n            NewFieldName = ''\n            FieldName_ori = FieldName.strip('.')\n            while '[' in FieldName:\n                NewFieldName = NewFieldName + FieldName.split('[', 1)[0] + '[0]'\n                Array_Index = int(FieldName.split('[', 1)[1].split(']', 1)[0])\n                FieldName = FieldName.split(']', 1)[1]\n            FieldName = NewFieldName + FieldName\n            while '[' in FieldName and (not Pcd.IsArray()):\n                FieldName = FieldName.rsplit('[', 1)[0]\n                CApp = CApp + '  __FLEXIBLE_SIZE(*Size, %s, %s, %d); // From %s Line %d Value %s \\n' % (Pcd.DatumType, FieldName.strip('.'), Array_Index + 1, Pcd.PcdFieldValueFromComm[FieldName_ori][1], Pcd.PcdFieldValueFromComm[FieldName_ori][2], Pcd.PcdFieldValueFromComm[FieldName_ori][0])\n    if Pcd.GetPcdMaxSize():\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); // The Pcd maxsize is %d \\n' % (Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize(), Pcd.GetPcdMaxSize())\n    ArraySizeByAssign = self.CalculateActualCap(ActualCap)\n    if ArraySizeByAssign > 1:\n        CApp = CApp + '  *Size = (%d > *Size ? %d : *Size); \\n' % (ArraySizeByAssign, ArraySizeByAssign)\n    CApp = CApp + '}\\n'\n    return CApp"
        ]
    },
    {
        "func_name": "CalculateActualCap",
        "original": "def CalculateActualCap(self, ActualCap):\n    if not ActualCap:\n        return 1\n    maxsize = 1\n    for item in ActualCap:\n        index_elements = ArrayIndex.findall(item)\n        rt = 1\n        for index_e in index_elements:\n            index_num = index_e.lstrip('[').rstrip(']').strip()\n            if not index_num:\n                return 1\n            index_num = int(index_num, 16) if index_num.startswith(('0x', '0X')) else int(index_num)\n            rt = rt * (index_num + 1)\n        if rt > maxsize:\n            maxsize = rt\n    return maxsize",
        "mutated": [
            "def CalculateActualCap(self, ActualCap):\n    if False:\n        i = 10\n    if not ActualCap:\n        return 1\n    maxsize = 1\n    for item in ActualCap:\n        index_elements = ArrayIndex.findall(item)\n        rt = 1\n        for index_e in index_elements:\n            index_num = index_e.lstrip('[').rstrip(']').strip()\n            if not index_num:\n                return 1\n            index_num = int(index_num, 16) if index_num.startswith(('0x', '0X')) else int(index_num)\n            rt = rt * (index_num + 1)\n        if rt > maxsize:\n            maxsize = rt\n    return maxsize",
            "def CalculateActualCap(self, ActualCap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not ActualCap:\n        return 1\n    maxsize = 1\n    for item in ActualCap:\n        index_elements = ArrayIndex.findall(item)\n        rt = 1\n        for index_e in index_elements:\n            index_num = index_e.lstrip('[').rstrip(']').strip()\n            if not index_num:\n                return 1\n            index_num = int(index_num, 16) if index_num.startswith(('0x', '0X')) else int(index_num)\n            rt = rt * (index_num + 1)\n        if rt > maxsize:\n            maxsize = rt\n    return maxsize",
            "def CalculateActualCap(self, ActualCap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not ActualCap:\n        return 1\n    maxsize = 1\n    for item in ActualCap:\n        index_elements = ArrayIndex.findall(item)\n        rt = 1\n        for index_e in index_elements:\n            index_num = index_e.lstrip('[').rstrip(']').strip()\n            if not index_num:\n                return 1\n            index_num = int(index_num, 16) if index_num.startswith(('0x', '0X')) else int(index_num)\n            rt = rt * (index_num + 1)\n        if rt > maxsize:\n            maxsize = rt\n    return maxsize",
            "def CalculateActualCap(self, ActualCap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not ActualCap:\n        return 1\n    maxsize = 1\n    for item in ActualCap:\n        index_elements = ArrayIndex.findall(item)\n        rt = 1\n        for index_e in index_elements:\n            index_num = index_e.lstrip('[').rstrip(']').strip()\n            if not index_num:\n                return 1\n            index_num = int(index_num, 16) if index_num.startswith(('0x', '0X')) else int(index_num)\n            rt = rt * (index_num + 1)\n        if rt > maxsize:\n            maxsize = rt\n    return maxsize",
            "def CalculateActualCap(self, ActualCap):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not ActualCap:\n        return 1\n    maxsize = 1\n    for item in ActualCap:\n        index_elements = ArrayIndex.findall(item)\n        rt = 1\n        for index_e in index_elements:\n            index_num = index_e.lstrip('[').rstrip(']').strip()\n            if not index_num:\n                return 1\n            index_num = int(index_num, 16) if index_num.startswith(('0x', '0X')) else int(index_num)\n            rt = rt * (index_num + 1)\n        if rt > maxsize:\n            maxsize = rt\n    return maxsize"
        ]
    },
    {
        "func_name": "GenerateSizeStatments",
        "original": "@staticmethod\ndef GenerateSizeStatments(Pcd, skuname, defaultstorename):\n    if Pcd.IsArray():\n        r_datatype = [Pcd.BaseDatumType]\n        lastoneisEmpty = False\n        for dem in Pcd.Capacity:\n            if lastoneisEmpty:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.  ' % '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName)))\n            if dem == '0' or dem == '-1':\n                r_datatype.append('[1]')\n                lastoneisEmpty = True\n            else:\n                r_datatype.append('[' + dem + ']')\n        if Pcd.Type in [MODEL_PCD_DYNAMIC_EX_HII, MODEL_PCD_DYNAMIC_HII]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultStoreDict.get(defaultstorename)\n        elif Pcd.Type in [MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_DYNAMIC_VPD, MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_VPD]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultValue\n        else:\n            PcdDefValue = Pcd.DefaultValue\n        if lastoneisEmpty:\n            if '{CODE(' not in PcdDefValue:\n                sizebasevalue_plus = '(%s / sizeof(%s) + 1)' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizebasevalue = '(%s / sizeof(%s))' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizeof = 'sizeof(%s)' % Pcd.BaseDatumType\n                CApp = '  int ArraySize = %s %% %s ? %s : %s ;\\n' % (DscBuildData.GetStructurePcdMaxSize(Pcd), sizeof, sizebasevalue_plus, sizebasevalue)\n                CApp += '  Size = ArraySize * sizeof(%s); \\n' % Pcd.BaseDatumType\n            else:\n                CApp = '  Size = 0;\\n'\n        else:\n            CApp = '  Size = sizeof(%s);\\n' % ''.join(r_datatype)\n    else:\n        CApp = '  Size = sizeof(%s);\\n' % Pcd.DatumType\n    CApp = CApp + '  Cal_%s_%s_Size(&Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
        "mutated": [
            "@staticmethod\ndef GenerateSizeStatments(Pcd, skuname, defaultstorename):\n    if False:\n        i = 10\n    if Pcd.IsArray():\n        r_datatype = [Pcd.BaseDatumType]\n        lastoneisEmpty = False\n        for dem in Pcd.Capacity:\n            if lastoneisEmpty:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.  ' % '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName)))\n            if dem == '0' or dem == '-1':\n                r_datatype.append('[1]')\n                lastoneisEmpty = True\n            else:\n                r_datatype.append('[' + dem + ']')\n        if Pcd.Type in [MODEL_PCD_DYNAMIC_EX_HII, MODEL_PCD_DYNAMIC_HII]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultStoreDict.get(defaultstorename)\n        elif Pcd.Type in [MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_DYNAMIC_VPD, MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_VPD]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultValue\n        else:\n            PcdDefValue = Pcd.DefaultValue\n        if lastoneisEmpty:\n            if '{CODE(' not in PcdDefValue:\n                sizebasevalue_plus = '(%s / sizeof(%s) + 1)' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizebasevalue = '(%s / sizeof(%s))' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizeof = 'sizeof(%s)' % Pcd.BaseDatumType\n                CApp = '  int ArraySize = %s %% %s ? %s : %s ;\\n' % (DscBuildData.GetStructurePcdMaxSize(Pcd), sizeof, sizebasevalue_plus, sizebasevalue)\n                CApp += '  Size = ArraySize * sizeof(%s); \\n' % Pcd.BaseDatumType\n            else:\n                CApp = '  Size = 0;\\n'\n        else:\n            CApp = '  Size = sizeof(%s);\\n' % ''.join(r_datatype)\n    else:\n        CApp = '  Size = sizeof(%s);\\n' % Pcd.DatumType\n    CApp = CApp + '  Cal_%s_%s_Size(&Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateSizeStatments(Pcd, skuname, defaultstorename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Pcd.IsArray():\n        r_datatype = [Pcd.BaseDatumType]\n        lastoneisEmpty = False\n        for dem in Pcd.Capacity:\n            if lastoneisEmpty:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.  ' % '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName)))\n            if dem == '0' or dem == '-1':\n                r_datatype.append('[1]')\n                lastoneisEmpty = True\n            else:\n                r_datatype.append('[' + dem + ']')\n        if Pcd.Type in [MODEL_PCD_DYNAMIC_EX_HII, MODEL_PCD_DYNAMIC_HII]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultStoreDict.get(defaultstorename)\n        elif Pcd.Type in [MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_DYNAMIC_VPD, MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_VPD]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultValue\n        else:\n            PcdDefValue = Pcd.DefaultValue\n        if lastoneisEmpty:\n            if '{CODE(' not in PcdDefValue:\n                sizebasevalue_plus = '(%s / sizeof(%s) + 1)' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizebasevalue = '(%s / sizeof(%s))' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizeof = 'sizeof(%s)' % Pcd.BaseDatumType\n                CApp = '  int ArraySize = %s %% %s ? %s : %s ;\\n' % (DscBuildData.GetStructurePcdMaxSize(Pcd), sizeof, sizebasevalue_plus, sizebasevalue)\n                CApp += '  Size = ArraySize * sizeof(%s); \\n' % Pcd.BaseDatumType\n            else:\n                CApp = '  Size = 0;\\n'\n        else:\n            CApp = '  Size = sizeof(%s);\\n' % ''.join(r_datatype)\n    else:\n        CApp = '  Size = sizeof(%s);\\n' % Pcd.DatumType\n    CApp = CApp + '  Cal_%s_%s_Size(&Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateSizeStatments(Pcd, skuname, defaultstorename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Pcd.IsArray():\n        r_datatype = [Pcd.BaseDatumType]\n        lastoneisEmpty = False\n        for dem in Pcd.Capacity:\n            if lastoneisEmpty:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.  ' % '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName)))\n            if dem == '0' or dem == '-1':\n                r_datatype.append('[1]')\n                lastoneisEmpty = True\n            else:\n                r_datatype.append('[' + dem + ']')\n        if Pcd.Type in [MODEL_PCD_DYNAMIC_EX_HII, MODEL_PCD_DYNAMIC_HII]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultStoreDict.get(defaultstorename)\n        elif Pcd.Type in [MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_DYNAMIC_VPD, MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_VPD]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultValue\n        else:\n            PcdDefValue = Pcd.DefaultValue\n        if lastoneisEmpty:\n            if '{CODE(' not in PcdDefValue:\n                sizebasevalue_plus = '(%s / sizeof(%s) + 1)' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizebasevalue = '(%s / sizeof(%s))' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizeof = 'sizeof(%s)' % Pcd.BaseDatumType\n                CApp = '  int ArraySize = %s %% %s ? %s : %s ;\\n' % (DscBuildData.GetStructurePcdMaxSize(Pcd), sizeof, sizebasevalue_plus, sizebasevalue)\n                CApp += '  Size = ArraySize * sizeof(%s); \\n' % Pcd.BaseDatumType\n            else:\n                CApp = '  Size = 0;\\n'\n        else:\n            CApp = '  Size = sizeof(%s);\\n' % ''.join(r_datatype)\n    else:\n        CApp = '  Size = sizeof(%s);\\n' % Pcd.DatumType\n    CApp = CApp + '  Cal_%s_%s_Size(&Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateSizeStatments(Pcd, skuname, defaultstorename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Pcd.IsArray():\n        r_datatype = [Pcd.BaseDatumType]\n        lastoneisEmpty = False\n        for dem in Pcd.Capacity:\n            if lastoneisEmpty:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.  ' % '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName)))\n            if dem == '0' or dem == '-1':\n                r_datatype.append('[1]')\n                lastoneisEmpty = True\n            else:\n                r_datatype.append('[' + dem + ']')\n        if Pcd.Type in [MODEL_PCD_DYNAMIC_EX_HII, MODEL_PCD_DYNAMIC_HII]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultStoreDict.get(defaultstorename)\n        elif Pcd.Type in [MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_DYNAMIC_VPD, MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_VPD]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultValue\n        else:\n            PcdDefValue = Pcd.DefaultValue\n        if lastoneisEmpty:\n            if '{CODE(' not in PcdDefValue:\n                sizebasevalue_plus = '(%s / sizeof(%s) + 1)' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizebasevalue = '(%s / sizeof(%s))' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizeof = 'sizeof(%s)' % Pcd.BaseDatumType\n                CApp = '  int ArraySize = %s %% %s ? %s : %s ;\\n' % (DscBuildData.GetStructurePcdMaxSize(Pcd), sizeof, sizebasevalue_plus, sizebasevalue)\n                CApp += '  Size = ArraySize * sizeof(%s); \\n' % Pcd.BaseDatumType\n            else:\n                CApp = '  Size = 0;\\n'\n        else:\n            CApp = '  Size = sizeof(%s);\\n' % ''.join(r_datatype)\n    else:\n        CApp = '  Size = sizeof(%s);\\n' % Pcd.DatumType\n    CApp = CApp + '  Cal_%s_%s_Size(&Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateSizeStatments(Pcd, skuname, defaultstorename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Pcd.IsArray():\n        r_datatype = [Pcd.BaseDatumType]\n        lastoneisEmpty = False\n        for dem in Pcd.Capacity:\n            if lastoneisEmpty:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.  ' % '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName)))\n            if dem == '0' or dem == '-1':\n                r_datatype.append('[1]')\n                lastoneisEmpty = True\n            else:\n                r_datatype.append('[' + dem + ']')\n        if Pcd.Type in [MODEL_PCD_DYNAMIC_EX_HII, MODEL_PCD_DYNAMIC_HII]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultStoreDict.get(defaultstorename)\n        elif Pcd.Type in [MODEL_PCD_DYNAMIC_EX_DEFAULT, MODEL_PCD_DYNAMIC_VPD, MODEL_PCD_DYNAMIC_DEFAULT, MODEL_PCD_DYNAMIC_EX_VPD]:\n            PcdDefValue = Pcd.SkuInfoList.get(skuname).DefaultValue\n        else:\n            PcdDefValue = Pcd.DefaultValue\n        if lastoneisEmpty:\n            if '{CODE(' not in PcdDefValue:\n                sizebasevalue_plus = '(%s / sizeof(%s) + 1)' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizebasevalue = '(%s / sizeof(%s))' % (DscBuildData.GetStructurePcdMaxSize(Pcd), Pcd.BaseDatumType)\n                sizeof = 'sizeof(%s)' % Pcd.BaseDatumType\n                CApp = '  int ArraySize = %s %% %s ? %s : %s ;\\n' % (DscBuildData.GetStructurePcdMaxSize(Pcd), sizeof, sizebasevalue_plus, sizebasevalue)\n                CApp += '  Size = ArraySize * sizeof(%s); \\n' % Pcd.BaseDatumType\n            else:\n                CApp = '  Size = 0;\\n'\n        else:\n            CApp = '  Size = sizeof(%s);\\n' % ''.join(r_datatype)\n    else:\n        CApp = '  Size = sizeof(%s);\\n' % Pcd.DatumType\n    CApp = CApp + '  Cal_%s_%s_Size(&Size);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp"
        ]
    },
    {
        "func_name": "cleanupindex",
        "original": "def cleanupindex(indexstr):\n    return indexstr.strip('[').strip(']').strip()",
        "mutated": [
            "def cleanupindex(indexstr):\n    if False:\n        i = 10\n    return indexstr.strip('[').strip(']').strip()",
            "def cleanupindex(indexstr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return indexstr.strip('[').strip(']').strip()",
            "def cleanupindex(indexstr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return indexstr.strip('[').strip(']').strip()",
            "def cleanupindex(indexstr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return indexstr.strip('[').strip(']').strip()",
            "def cleanupindex(indexstr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return indexstr.strip('[').strip(']').strip()"
        ]
    },
    {
        "func_name": "GetIndicator",
        "original": "def GetIndicator(self, index, FieldName, Pcd):\n\n    def cleanupindex(indexstr):\n        return indexstr.strip('[').strip(']').strip()\n    index_elements = ArrayIndex.findall(index)\n    pcd_capacity = Pcd.Capacity\n    if index:\n        indicator = '(Pcd'\n        if len(pcd_capacity) > 2:\n            for i in range(0, len(index_elements)):\n                index_ele = index_elements[i]\n                index_num = index_ele.strip('[').strip(']').strip()\n                if i == len(index_elements) - 2:\n                    indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[i + 1])), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]), cleanupindex(index_elements[i]))\n                    break\n                else:\n                    indicator += ' + %d*%s*Size/sizeof(%s)/%d' % (int(cleanupindex(index_elements[i])), reduce(lambda x, y: int(x) * int(y), pcd_capacity[i + 1:-1]), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]))\n        elif len(pcd_capacity) == 2:\n            indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[0])), Pcd.BaseDatumType, int(pcd_capacity[0]), index_elements[1].strip('[').strip(']').strip())\n        elif len(pcd_capacity) == 1:\n            index_ele = index_elements[0]\n            index_num = index_ele.strip('[').strip(']').strip()\n            indicator += ' + %s)' % index_num\n    else:\n        indicator = 'Pcd'\n    if FieldName:\n        indicator += '->' + FieldName\n    return indicator",
        "mutated": [
            "def GetIndicator(self, index, FieldName, Pcd):\n    if False:\n        i = 10\n\n    def cleanupindex(indexstr):\n        return indexstr.strip('[').strip(']').strip()\n    index_elements = ArrayIndex.findall(index)\n    pcd_capacity = Pcd.Capacity\n    if index:\n        indicator = '(Pcd'\n        if len(pcd_capacity) > 2:\n            for i in range(0, len(index_elements)):\n                index_ele = index_elements[i]\n                index_num = index_ele.strip('[').strip(']').strip()\n                if i == len(index_elements) - 2:\n                    indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[i + 1])), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]), cleanupindex(index_elements[i]))\n                    break\n                else:\n                    indicator += ' + %d*%s*Size/sizeof(%s)/%d' % (int(cleanupindex(index_elements[i])), reduce(lambda x, y: int(x) * int(y), pcd_capacity[i + 1:-1]), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]))\n        elif len(pcd_capacity) == 2:\n            indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[0])), Pcd.BaseDatumType, int(pcd_capacity[0]), index_elements[1].strip('[').strip(']').strip())\n        elif len(pcd_capacity) == 1:\n            index_ele = index_elements[0]\n            index_num = index_ele.strip('[').strip(']').strip()\n            indicator += ' + %s)' % index_num\n    else:\n        indicator = 'Pcd'\n    if FieldName:\n        indicator += '->' + FieldName\n    return indicator",
            "def GetIndicator(self, index, FieldName, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def cleanupindex(indexstr):\n        return indexstr.strip('[').strip(']').strip()\n    index_elements = ArrayIndex.findall(index)\n    pcd_capacity = Pcd.Capacity\n    if index:\n        indicator = '(Pcd'\n        if len(pcd_capacity) > 2:\n            for i in range(0, len(index_elements)):\n                index_ele = index_elements[i]\n                index_num = index_ele.strip('[').strip(']').strip()\n                if i == len(index_elements) - 2:\n                    indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[i + 1])), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]), cleanupindex(index_elements[i]))\n                    break\n                else:\n                    indicator += ' + %d*%s*Size/sizeof(%s)/%d' % (int(cleanupindex(index_elements[i])), reduce(lambda x, y: int(x) * int(y), pcd_capacity[i + 1:-1]), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]))\n        elif len(pcd_capacity) == 2:\n            indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[0])), Pcd.BaseDatumType, int(pcd_capacity[0]), index_elements[1].strip('[').strip(']').strip())\n        elif len(pcd_capacity) == 1:\n            index_ele = index_elements[0]\n            index_num = index_ele.strip('[').strip(']').strip()\n            indicator += ' + %s)' % index_num\n    else:\n        indicator = 'Pcd'\n    if FieldName:\n        indicator += '->' + FieldName\n    return indicator",
            "def GetIndicator(self, index, FieldName, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def cleanupindex(indexstr):\n        return indexstr.strip('[').strip(']').strip()\n    index_elements = ArrayIndex.findall(index)\n    pcd_capacity = Pcd.Capacity\n    if index:\n        indicator = '(Pcd'\n        if len(pcd_capacity) > 2:\n            for i in range(0, len(index_elements)):\n                index_ele = index_elements[i]\n                index_num = index_ele.strip('[').strip(']').strip()\n                if i == len(index_elements) - 2:\n                    indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[i + 1])), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]), cleanupindex(index_elements[i]))\n                    break\n                else:\n                    indicator += ' + %d*%s*Size/sizeof(%s)/%d' % (int(cleanupindex(index_elements[i])), reduce(lambda x, y: int(x) * int(y), pcd_capacity[i + 1:-1]), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]))\n        elif len(pcd_capacity) == 2:\n            indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[0])), Pcd.BaseDatumType, int(pcd_capacity[0]), index_elements[1].strip('[').strip(']').strip())\n        elif len(pcd_capacity) == 1:\n            index_ele = index_elements[0]\n            index_num = index_ele.strip('[').strip(']').strip()\n            indicator += ' + %s)' % index_num\n    else:\n        indicator = 'Pcd'\n    if FieldName:\n        indicator += '->' + FieldName\n    return indicator",
            "def GetIndicator(self, index, FieldName, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def cleanupindex(indexstr):\n        return indexstr.strip('[').strip(']').strip()\n    index_elements = ArrayIndex.findall(index)\n    pcd_capacity = Pcd.Capacity\n    if index:\n        indicator = '(Pcd'\n        if len(pcd_capacity) > 2:\n            for i in range(0, len(index_elements)):\n                index_ele = index_elements[i]\n                index_num = index_ele.strip('[').strip(']').strip()\n                if i == len(index_elements) - 2:\n                    indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[i + 1])), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]), cleanupindex(index_elements[i]))\n                    break\n                else:\n                    indicator += ' + %d*%s*Size/sizeof(%s)/%d' % (int(cleanupindex(index_elements[i])), reduce(lambda x, y: int(x) * int(y), pcd_capacity[i + 1:-1]), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]))\n        elif len(pcd_capacity) == 2:\n            indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[0])), Pcd.BaseDatumType, int(pcd_capacity[0]), index_elements[1].strip('[').strip(']').strip())\n        elif len(pcd_capacity) == 1:\n            index_ele = index_elements[0]\n            index_num = index_ele.strip('[').strip(']').strip()\n            indicator += ' + %s)' % index_num\n    else:\n        indicator = 'Pcd'\n    if FieldName:\n        indicator += '->' + FieldName\n    return indicator",
            "def GetIndicator(self, index, FieldName, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def cleanupindex(indexstr):\n        return indexstr.strip('[').strip(']').strip()\n    index_elements = ArrayIndex.findall(index)\n    pcd_capacity = Pcd.Capacity\n    if index:\n        indicator = '(Pcd'\n        if len(pcd_capacity) > 2:\n            for i in range(0, len(index_elements)):\n                index_ele = index_elements[i]\n                index_num = index_ele.strip('[').strip(']').strip()\n                if i == len(index_elements) - 2:\n                    indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[i + 1])), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]), cleanupindex(index_elements[i]))\n                    break\n                else:\n                    indicator += ' + %d*%s*Size/sizeof(%s)/%d' % (int(cleanupindex(index_elements[i])), reduce(lambda x, y: int(x) * int(y), pcd_capacity[i + 1:-1]), Pcd.BaseDatumType, reduce(lambda x, y: int(x) * int(y), pcd_capacity[:-1]))\n        elif len(pcd_capacity) == 2:\n            indicator += '+ %d*Size/sizeof(%s)/%d + %s)' % (int(cleanupindex(index_elements[0])), Pcd.BaseDatumType, int(pcd_capacity[0]), index_elements[1].strip('[').strip(']').strip())\n        elif len(pcd_capacity) == 1:\n            index_ele = index_elements[0]\n            index_num = index_ele.strip('[').strip(']').strip()\n            indicator += ' + %s)' % index_num\n    else:\n        indicator = 'Pcd'\n    if FieldName:\n        indicator += '->' + FieldName\n    return indicator"
        ]
    },
    {
        "func_name": "GetStarNum",
        "original": "def GetStarNum(self, Pcd):\n    if not Pcd.IsArray():\n        return 1\n    elif Pcd.IsSimpleTypeArray():\n        return len(Pcd.Capacity)\n    else:\n        return len(Pcd.Capacity) + 1",
        "mutated": [
            "def GetStarNum(self, Pcd):\n    if False:\n        i = 10\n    if not Pcd.IsArray():\n        return 1\n    elif Pcd.IsSimpleTypeArray():\n        return len(Pcd.Capacity)\n    else:\n        return len(Pcd.Capacity) + 1",
            "def GetStarNum(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not Pcd.IsArray():\n        return 1\n    elif Pcd.IsSimpleTypeArray():\n        return len(Pcd.Capacity)\n    else:\n        return len(Pcd.Capacity) + 1",
            "def GetStarNum(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not Pcd.IsArray():\n        return 1\n    elif Pcd.IsSimpleTypeArray():\n        return len(Pcd.Capacity)\n    else:\n        return len(Pcd.Capacity) + 1",
            "def GetStarNum(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not Pcd.IsArray():\n        return 1\n    elif Pcd.IsSimpleTypeArray():\n        return len(Pcd.Capacity)\n    else:\n        return len(Pcd.Capacity) + 1",
            "def GetStarNum(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not Pcd.IsArray():\n        return 1\n    elif Pcd.IsSimpleTypeArray():\n        return len(Pcd.Capacity)\n    else:\n        return len(Pcd.Capacity) + 1"
        ]
    },
    {
        "func_name": "GenerateDefaultValueAssignFunction",
        "original": "def GenerateDefaultValueAssignFunction(self, Pcd):\n    CApp = '// Default value in Dec \\n'\n    CApp = CApp + 'void Assign_%s_%s_Default_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    DefaultValueFromDec = Pcd.DefaultValueFromDec\n    IsArray = _IsFieldValueAnArray(Pcd.DefaultValueFromDec)\n    if IsArray:\n        try:\n            DefaultValueFromDec = ValueExpressionEx(Pcd.DefaultValueFromDec, TAB_VOID)(True)\n        except BadExpression:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DEC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValueFromDec))\n    DefaultValueFromDec = StringToArray(DefaultValueFromDec)\n    (Value, ValueSize) = ParseFieldValue(DefaultValueFromDec)\n    if IsArray:\n        if Pcd.IsArray():\n            pcdarraysize = Pcd.PcdArraySize()\n            if '{CODE(' in Pcd.DefaultValueFromDec:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_INIT_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From  %s Line %s \\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n                CApp = CApp + '  memcpy (Pcd, %s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            else:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From %s Line %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n                CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n        elif '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp = CApp + '  PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            CApp = CApp + '  memcpy (Pcd, &%s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n            CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    elif isinstance(Value, str):\n        CApp = CApp + '  Pcd = %s; // From DEC Default Value %s\\n' % (Value, Pcd.DefaultValueFromDec)\n    for index in Pcd.DefaultValues:\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            indicator = self.GetIndicator(index, FieldName, Pcd)\n            if IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n            elif isinstance(Value, str):\n                CApp = CApp + '  %s = %s; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
        "mutated": [
            "def GenerateDefaultValueAssignFunction(self, Pcd):\n    if False:\n        i = 10\n    CApp = '// Default value in Dec \\n'\n    CApp = CApp + 'void Assign_%s_%s_Default_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    DefaultValueFromDec = Pcd.DefaultValueFromDec\n    IsArray = _IsFieldValueAnArray(Pcd.DefaultValueFromDec)\n    if IsArray:\n        try:\n            DefaultValueFromDec = ValueExpressionEx(Pcd.DefaultValueFromDec, TAB_VOID)(True)\n        except BadExpression:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DEC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValueFromDec))\n    DefaultValueFromDec = StringToArray(DefaultValueFromDec)\n    (Value, ValueSize) = ParseFieldValue(DefaultValueFromDec)\n    if IsArray:\n        if Pcd.IsArray():\n            pcdarraysize = Pcd.PcdArraySize()\n            if '{CODE(' in Pcd.DefaultValueFromDec:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_INIT_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From  %s Line %s \\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n                CApp = CApp + '  memcpy (Pcd, %s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            else:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From %s Line %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n                CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n        elif '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp = CApp + '  PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            CApp = CApp + '  memcpy (Pcd, &%s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n            CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    elif isinstance(Value, str):\n        CApp = CApp + '  Pcd = %s; // From DEC Default Value %s\\n' % (Value, Pcd.DefaultValueFromDec)\n    for index in Pcd.DefaultValues:\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            indicator = self.GetIndicator(index, FieldName, Pcd)\n            if IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n            elif isinstance(Value, str):\n                CApp = CApp + '  %s = %s; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateDefaultValueAssignFunction(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '// Default value in Dec \\n'\n    CApp = CApp + 'void Assign_%s_%s_Default_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    DefaultValueFromDec = Pcd.DefaultValueFromDec\n    IsArray = _IsFieldValueAnArray(Pcd.DefaultValueFromDec)\n    if IsArray:\n        try:\n            DefaultValueFromDec = ValueExpressionEx(Pcd.DefaultValueFromDec, TAB_VOID)(True)\n        except BadExpression:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DEC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValueFromDec))\n    DefaultValueFromDec = StringToArray(DefaultValueFromDec)\n    (Value, ValueSize) = ParseFieldValue(DefaultValueFromDec)\n    if IsArray:\n        if Pcd.IsArray():\n            pcdarraysize = Pcd.PcdArraySize()\n            if '{CODE(' in Pcd.DefaultValueFromDec:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_INIT_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From  %s Line %s \\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n                CApp = CApp + '  memcpy (Pcd, %s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            else:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From %s Line %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n                CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n        elif '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp = CApp + '  PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            CApp = CApp + '  memcpy (Pcd, &%s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n            CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    elif isinstance(Value, str):\n        CApp = CApp + '  Pcd = %s; // From DEC Default Value %s\\n' % (Value, Pcd.DefaultValueFromDec)\n    for index in Pcd.DefaultValues:\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            indicator = self.GetIndicator(index, FieldName, Pcd)\n            if IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n            elif isinstance(Value, str):\n                CApp = CApp + '  %s = %s; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateDefaultValueAssignFunction(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '// Default value in Dec \\n'\n    CApp = CApp + 'void Assign_%s_%s_Default_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    DefaultValueFromDec = Pcd.DefaultValueFromDec\n    IsArray = _IsFieldValueAnArray(Pcd.DefaultValueFromDec)\n    if IsArray:\n        try:\n            DefaultValueFromDec = ValueExpressionEx(Pcd.DefaultValueFromDec, TAB_VOID)(True)\n        except BadExpression:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DEC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValueFromDec))\n    DefaultValueFromDec = StringToArray(DefaultValueFromDec)\n    (Value, ValueSize) = ParseFieldValue(DefaultValueFromDec)\n    if IsArray:\n        if Pcd.IsArray():\n            pcdarraysize = Pcd.PcdArraySize()\n            if '{CODE(' in Pcd.DefaultValueFromDec:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_INIT_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From  %s Line %s \\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n                CApp = CApp + '  memcpy (Pcd, %s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            else:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From %s Line %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n                CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n        elif '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp = CApp + '  PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            CApp = CApp + '  memcpy (Pcd, &%s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n            CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    elif isinstance(Value, str):\n        CApp = CApp + '  Pcd = %s; // From DEC Default Value %s\\n' % (Value, Pcd.DefaultValueFromDec)\n    for index in Pcd.DefaultValues:\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            indicator = self.GetIndicator(index, FieldName, Pcd)\n            if IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n            elif isinstance(Value, str):\n                CApp = CApp + '  %s = %s; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateDefaultValueAssignFunction(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '// Default value in Dec \\n'\n    CApp = CApp + 'void Assign_%s_%s_Default_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    DefaultValueFromDec = Pcd.DefaultValueFromDec\n    IsArray = _IsFieldValueAnArray(Pcd.DefaultValueFromDec)\n    if IsArray:\n        try:\n            DefaultValueFromDec = ValueExpressionEx(Pcd.DefaultValueFromDec, TAB_VOID)(True)\n        except BadExpression:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DEC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValueFromDec))\n    DefaultValueFromDec = StringToArray(DefaultValueFromDec)\n    (Value, ValueSize) = ParseFieldValue(DefaultValueFromDec)\n    if IsArray:\n        if Pcd.IsArray():\n            pcdarraysize = Pcd.PcdArraySize()\n            if '{CODE(' in Pcd.DefaultValueFromDec:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_INIT_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From  %s Line %s \\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n                CApp = CApp + '  memcpy (Pcd, %s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            else:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From %s Line %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n                CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n        elif '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp = CApp + '  PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            CApp = CApp + '  memcpy (Pcd, &%s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n            CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    elif isinstance(Value, str):\n        CApp = CApp + '  Pcd = %s; // From DEC Default Value %s\\n' % (Value, Pcd.DefaultValueFromDec)\n    for index in Pcd.DefaultValues:\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            indicator = self.GetIndicator(index, FieldName, Pcd)\n            if IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n            elif isinstance(Value, str):\n                CApp = CApp + '  %s = %s; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateDefaultValueAssignFunction(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '// Default value in Dec \\n'\n    CApp = CApp + 'void Assign_%s_%s_Default_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    DefaultValueFromDec = Pcd.DefaultValueFromDec\n    IsArray = _IsFieldValueAnArray(Pcd.DefaultValueFromDec)\n    if IsArray:\n        try:\n            DefaultValueFromDec = ValueExpressionEx(Pcd.DefaultValueFromDec, TAB_VOID)(True)\n        except BadExpression:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DEC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, DefaultValueFromDec))\n    DefaultValueFromDec = StringToArray(DefaultValueFromDec)\n    (Value, ValueSize) = ParseFieldValue(DefaultValueFromDec)\n    if IsArray:\n        if Pcd.IsArray():\n            pcdarraysize = Pcd.PcdArraySize()\n            if '{CODE(' in Pcd.DefaultValueFromDec:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_INIT_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From  %s Line %s \\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n                CApp = CApp + '  memcpy (Pcd, %s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            else:\n                if Pcd.Capacity[-1] != '-1':\n                    CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dec exceed the array capability %s\"); // From %s Line %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, Pcd.DefaultValueFromDecInfo[0], Pcd.DefaultValueFromDecInfo[1])\n                CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n                CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n        elif '{CODE(' in Pcd.DefaultValueFromDec:\n            CApp = CApp + '  PcdArraySize = sizeof(%s_%s_INIT_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            CApp = CApp + '  memcpy (Pcd, &%s_%s_INIT_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            CApp = CApp + '  Value     = %s; // From DEC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultValueFromDec)\n            CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    elif isinstance(Value, str):\n        CApp = CApp + '  Pcd = %s; // From DEC Default Value %s\\n' % (Value, Pcd.DefaultValueFromDec)\n    for index in Pcd.DefaultValues:\n        FieldList = Pcd.DefaultValues[index]\n        if not FieldList:\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            indicator = self.GetIndicator(index, FieldName, Pcd)\n            if IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n            elif isinstance(Value, str):\n                CApp = CApp + '  %s = %s; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp"
        ]
    },
    {
        "func_name": "GenerateDefaultValueAssignStatement",
        "original": "@staticmethod\ndef GenerateDefaultValueAssignStatement(Pcd):\n    CApp = '  Assign_%s_%s_Default_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
        "mutated": [
            "@staticmethod\ndef GenerateDefaultValueAssignStatement(Pcd):\n    if False:\n        i = 10\n    CApp = '  Assign_%s_%s_Default_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateDefaultValueAssignStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '  Assign_%s_%s_Default_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateDefaultValueAssignStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '  Assign_%s_%s_Default_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateDefaultValueAssignStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '  Assign_%s_%s_Default_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateDefaultValueAssignStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '  Assign_%s_%s_Default_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp"
        ]
    },
    {
        "func_name": "GetPcdDscRawDefaultValue",
        "original": "def GetPcdDscRawDefaultValue(self, Pcd, SkuName, DefaultStoreName):\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET or Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            pcddefaultvalue = Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT) if Pcd.DefaultFromDSC else None\n        else:\n            pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName)\n    else:\n        pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(TAB_DEFAULT_STORES_DEFAULT)\n    return pcddefaultvalue",
        "mutated": [
            "def GetPcdDscRawDefaultValue(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET or Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            pcddefaultvalue = Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT) if Pcd.DefaultFromDSC else None\n        else:\n            pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName)\n    else:\n        pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(TAB_DEFAULT_STORES_DEFAULT)\n    return pcddefaultvalue",
            "def GetPcdDscRawDefaultValue(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET or Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            pcddefaultvalue = Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT) if Pcd.DefaultFromDSC else None\n        else:\n            pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName)\n    else:\n        pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(TAB_DEFAULT_STORES_DEFAULT)\n    return pcddefaultvalue",
            "def GetPcdDscRawDefaultValue(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET or Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            pcddefaultvalue = Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT) if Pcd.DefaultFromDSC else None\n        else:\n            pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName)\n    else:\n        pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(TAB_DEFAULT_STORES_DEFAULT)\n    return pcddefaultvalue",
            "def GetPcdDscRawDefaultValue(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET or Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            pcddefaultvalue = Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT) if Pcd.DefaultFromDSC else None\n        else:\n            pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName)\n    else:\n        pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(TAB_DEFAULT_STORES_DEFAULT)\n    return pcddefaultvalue",
            "def GetPcdDscRawDefaultValue(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET or Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            pcddefaultvalue = Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT) if Pcd.DefaultFromDSC else None\n        else:\n            pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName)\n    else:\n        pcddefaultvalue = Pcd.DscRawValue.get(SkuName, {}).get(TAB_DEFAULT_STORES_DEFAULT)\n    return pcddefaultvalue"
        ]
    },
    {
        "func_name": "GetPcdDscRawValueInfo",
        "original": "def GetPcdDscRawValueInfo(self, Pcd, SkuName, DefaultStoreName):\n    DscValueInfo = Pcd.DscRawValueInfo.get(SkuName, {}).get(DefaultStoreName)\n    if DscValueInfo:\n        (dscfilepath, lineno) = DscValueInfo\n    else:\n        dscfilepath = self.MetaFile.File\n        lineno = ''\n    return (dscfilepath, lineno)",
        "mutated": [
            "def GetPcdDscRawValueInfo(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n    DscValueInfo = Pcd.DscRawValueInfo.get(SkuName, {}).get(DefaultStoreName)\n    if DscValueInfo:\n        (dscfilepath, lineno) = DscValueInfo\n    else:\n        dscfilepath = self.MetaFile.File\n        lineno = ''\n    return (dscfilepath, lineno)",
            "def GetPcdDscRawValueInfo(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DscValueInfo = Pcd.DscRawValueInfo.get(SkuName, {}).get(DefaultStoreName)\n    if DscValueInfo:\n        (dscfilepath, lineno) = DscValueInfo\n    else:\n        dscfilepath = self.MetaFile.File\n        lineno = ''\n    return (dscfilepath, lineno)",
            "def GetPcdDscRawValueInfo(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DscValueInfo = Pcd.DscRawValueInfo.get(SkuName, {}).get(DefaultStoreName)\n    if DscValueInfo:\n        (dscfilepath, lineno) = DscValueInfo\n    else:\n        dscfilepath = self.MetaFile.File\n        lineno = ''\n    return (dscfilepath, lineno)",
            "def GetPcdDscRawValueInfo(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DscValueInfo = Pcd.DscRawValueInfo.get(SkuName, {}).get(DefaultStoreName)\n    if DscValueInfo:\n        (dscfilepath, lineno) = DscValueInfo\n    else:\n        dscfilepath = self.MetaFile.File\n        lineno = ''\n    return (dscfilepath, lineno)",
            "def GetPcdDscRawValueInfo(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DscValueInfo = Pcd.DscRawValueInfo.get(SkuName, {}).get(DefaultStoreName)\n    if DscValueInfo:\n        (dscfilepath, lineno) = DscValueInfo\n    else:\n        dscfilepath = self.MetaFile.File\n        lineno = ''\n    return (dscfilepath, lineno)"
        ]
    },
    {
        "func_name": "GenerateInitValueFunction",
        "original": "def GenerateInitValueFunction(self, Pcd, SkuName, DefaultStoreName):\n    CApp = '// Value in Dsc for Sku: %s, DefaultStore %s\\n' % (SkuName, DefaultStoreName)\n    CApp = CApp + 'void Assign_%s_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n    inherit_OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    (dscfilepath, lineno) = self.GetPcdDscRawValueInfo(Pcd, SkuName, DefaultStoreName)\n    if lineno:\n        valuefrom = '%s Line %s' % (dscfilepath, str(lineno))\n    else:\n        valuefrom = dscfilepath\n    pcddefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, SkuName, DefaultStoreName)\n    if pcddefaultvalue:\n        FieldList = pcddefaultvalue\n        IsArray = _IsFieldValueAnArray(FieldList)\n        if IsArray:\n            if '{CODE(' not in FieldList:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DSC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n        (Value, ValueSize) = ParseFieldValue(FieldList)\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            if isinstance(Value, str):\n                if '{CODE(' in Value:\n                    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                        pcdarraysize = Pcd.PcdArraySize()\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n            elif IsArray:\n                if Pcd.IsArray():\n                    pcdarraysize = Pcd.PcdArraySize()\n                    if '{CODE(' in pcddefaultvalue:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                        CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    else:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                        CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                        CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n                elif '{CODE(' in pcddefaultvalue:\n                    CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        elif isinstance(Value, str):\n            if '{CODE(' in Value:\n                if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                    pcdarraysize = Pcd.PcdArraySize()\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n        elif IsArray:\n            if Pcd.IsArray():\n                pcdarraysize = Pcd.PcdArraySize()\n                if '{CODE(' in pcddefaultvalue:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n            elif '{CODE(' in pcddefaultvalue:\n                CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    inheritvalue = inherit_OverrideValues.get(DefaultStoreName)\n    if not inheritvalue:\n        inheritvalue = []\n    for index in inheritvalue:\n        FieldList = inheritvalue[index]\n        if not FieldList:\n            continue\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT) or ((SkuName, '') not in Pcd.ValueChain and (SkuName, DefaultStoreName) not in Pcd.ValueChain):\n            for FieldName in FieldList:\n                indicator = self.GetIndicator(index, FieldName, Pcd)\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
        "mutated": [
            "def GenerateInitValueFunction(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n    CApp = '// Value in Dsc for Sku: %s, DefaultStore %s\\n' % (SkuName, DefaultStoreName)\n    CApp = CApp + 'void Assign_%s_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n    inherit_OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    (dscfilepath, lineno) = self.GetPcdDscRawValueInfo(Pcd, SkuName, DefaultStoreName)\n    if lineno:\n        valuefrom = '%s Line %s' % (dscfilepath, str(lineno))\n    else:\n        valuefrom = dscfilepath\n    pcddefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, SkuName, DefaultStoreName)\n    if pcddefaultvalue:\n        FieldList = pcddefaultvalue\n        IsArray = _IsFieldValueAnArray(FieldList)\n        if IsArray:\n            if '{CODE(' not in FieldList:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DSC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n        (Value, ValueSize) = ParseFieldValue(FieldList)\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            if isinstance(Value, str):\n                if '{CODE(' in Value:\n                    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                        pcdarraysize = Pcd.PcdArraySize()\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n            elif IsArray:\n                if Pcd.IsArray():\n                    pcdarraysize = Pcd.PcdArraySize()\n                    if '{CODE(' in pcddefaultvalue:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                        CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    else:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                        CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                        CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n                elif '{CODE(' in pcddefaultvalue:\n                    CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        elif isinstance(Value, str):\n            if '{CODE(' in Value:\n                if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                    pcdarraysize = Pcd.PcdArraySize()\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n        elif IsArray:\n            if Pcd.IsArray():\n                pcdarraysize = Pcd.PcdArraySize()\n                if '{CODE(' in pcddefaultvalue:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n            elif '{CODE(' in pcddefaultvalue:\n                CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    inheritvalue = inherit_OverrideValues.get(DefaultStoreName)\n    if not inheritvalue:\n        inheritvalue = []\n    for index in inheritvalue:\n        FieldList = inheritvalue[index]\n        if not FieldList:\n            continue\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT) or ((SkuName, '') not in Pcd.ValueChain and (SkuName, DefaultStoreName) not in Pcd.ValueChain):\n            for FieldName in FieldList:\n                indicator = self.GetIndicator(index, FieldName, Pcd)\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateInitValueFunction(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '// Value in Dsc for Sku: %s, DefaultStore %s\\n' % (SkuName, DefaultStoreName)\n    CApp = CApp + 'void Assign_%s_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n    inherit_OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    (dscfilepath, lineno) = self.GetPcdDscRawValueInfo(Pcd, SkuName, DefaultStoreName)\n    if lineno:\n        valuefrom = '%s Line %s' % (dscfilepath, str(lineno))\n    else:\n        valuefrom = dscfilepath\n    pcddefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, SkuName, DefaultStoreName)\n    if pcddefaultvalue:\n        FieldList = pcddefaultvalue\n        IsArray = _IsFieldValueAnArray(FieldList)\n        if IsArray:\n            if '{CODE(' not in FieldList:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DSC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n        (Value, ValueSize) = ParseFieldValue(FieldList)\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            if isinstance(Value, str):\n                if '{CODE(' in Value:\n                    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                        pcdarraysize = Pcd.PcdArraySize()\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n            elif IsArray:\n                if Pcd.IsArray():\n                    pcdarraysize = Pcd.PcdArraySize()\n                    if '{CODE(' in pcddefaultvalue:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                        CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    else:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                        CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                        CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n                elif '{CODE(' in pcddefaultvalue:\n                    CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        elif isinstance(Value, str):\n            if '{CODE(' in Value:\n                if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                    pcdarraysize = Pcd.PcdArraySize()\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n        elif IsArray:\n            if Pcd.IsArray():\n                pcdarraysize = Pcd.PcdArraySize()\n                if '{CODE(' in pcddefaultvalue:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n            elif '{CODE(' in pcddefaultvalue:\n                CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    inheritvalue = inherit_OverrideValues.get(DefaultStoreName)\n    if not inheritvalue:\n        inheritvalue = []\n    for index in inheritvalue:\n        FieldList = inheritvalue[index]\n        if not FieldList:\n            continue\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT) or ((SkuName, '') not in Pcd.ValueChain and (SkuName, DefaultStoreName) not in Pcd.ValueChain):\n            for FieldName in FieldList:\n                indicator = self.GetIndicator(index, FieldName, Pcd)\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateInitValueFunction(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '// Value in Dsc for Sku: %s, DefaultStore %s\\n' % (SkuName, DefaultStoreName)\n    CApp = CApp + 'void Assign_%s_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n    inherit_OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    (dscfilepath, lineno) = self.GetPcdDscRawValueInfo(Pcd, SkuName, DefaultStoreName)\n    if lineno:\n        valuefrom = '%s Line %s' % (dscfilepath, str(lineno))\n    else:\n        valuefrom = dscfilepath\n    pcddefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, SkuName, DefaultStoreName)\n    if pcddefaultvalue:\n        FieldList = pcddefaultvalue\n        IsArray = _IsFieldValueAnArray(FieldList)\n        if IsArray:\n            if '{CODE(' not in FieldList:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DSC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n        (Value, ValueSize) = ParseFieldValue(FieldList)\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            if isinstance(Value, str):\n                if '{CODE(' in Value:\n                    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                        pcdarraysize = Pcd.PcdArraySize()\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n            elif IsArray:\n                if Pcd.IsArray():\n                    pcdarraysize = Pcd.PcdArraySize()\n                    if '{CODE(' in pcddefaultvalue:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                        CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    else:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                        CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                        CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n                elif '{CODE(' in pcddefaultvalue:\n                    CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        elif isinstance(Value, str):\n            if '{CODE(' in Value:\n                if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                    pcdarraysize = Pcd.PcdArraySize()\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n        elif IsArray:\n            if Pcd.IsArray():\n                pcdarraysize = Pcd.PcdArraySize()\n                if '{CODE(' in pcddefaultvalue:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n            elif '{CODE(' in pcddefaultvalue:\n                CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    inheritvalue = inherit_OverrideValues.get(DefaultStoreName)\n    if not inheritvalue:\n        inheritvalue = []\n    for index in inheritvalue:\n        FieldList = inheritvalue[index]\n        if not FieldList:\n            continue\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT) or ((SkuName, '') not in Pcd.ValueChain and (SkuName, DefaultStoreName) not in Pcd.ValueChain):\n            for FieldName in FieldList:\n                indicator = self.GetIndicator(index, FieldName, Pcd)\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateInitValueFunction(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '// Value in Dsc for Sku: %s, DefaultStore %s\\n' % (SkuName, DefaultStoreName)\n    CApp = CApp + 'void Assign_%s_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n    inherit_OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    (dscfilepath, lineno) = self.GetPcdDscRawValueInfo(Pcd, SkuName, DefaultStoreName)\n    if lineno:\n        valuefrom = '%s Line %s' % (dscfilepath, str(lineno))\n    else:\n        valuefrom = dscfilepath\n    pcddefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, SkuName, DefaultStoreName)\n    if pcddefaultvalue:\n        FieldList = pcddefaultvalue\n        IsArray = _IsFieldValueAnArray(FieldList)\n        if IsArray:\n            if '{CODE(' not in FieldList:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DSC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n        (Value, ValueSize) = ParseFieldValue(FieldList)\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            if isinstance(Value, str):\n                if '{CODE(' in Value:\n                    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                        pcdarraysize = Pcd.PcdArraySize()\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n            elif IsArray:\n                if Pcd.IsArray():\n                    pcdarraysize = Pcd.PcdArraySize()\n                    if '{CODE(' in pcddefaultvalue:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                        CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    else:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                        CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                        CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n                elif '{CODE(' in pcddefaultvalue:\n                    CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        elif isinstance(Value, str):\n            if '{CODE(' in Value:\n                if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                    pcdarraysize = Pcd.PcdArraySize()\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n        elif IsArray:\n            if Pcd.IsArray():\n                pcdarraysize = Pcd.PcdArraySize()\n                if '{CODE(' in pcddefaultvalue:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n            elif '{CODE(' in pcddefaultvalue:\n                CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    inheritvalue = inherit_OverrideValues.get(DefaultStoreName)\n    if not inheritvalue:\n        inheritvalue = []\n    for index in inheritvalue:\n        FieldList = inheritvalue[index]\n        if not FieldList:\n            continue\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT) or ((SkuName, '') not in Pcd.ValueChain and (SkuName, DefaultStoreName) not in Pcd.ValueChain):\n            for FieldName in FieldList:\n                indicator = self.GetIndicator(index, FieldName, Pcd)\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateInitValueFunction(self, Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '// Value in Dsc for Sku: %s, DefaultStore %s\\n' % (SkuName, DefaultStoreName)\n    CApp = CApp + 'void Assign_%s_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    CApp = CApp + ' UINT32 PcdArraySize;\\n'\n    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n    inherit_OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    (dscfilepath, lineno) = self.GetPcdDscRawValueInfo(Pcd, SkuName, DefaultStoreName)\n    if lineno:\n        valuefrom = '%s Line %s' % (dscfilepath, str(lineno))\n    else:\n        valuefrom = dscfilepath\n    pcddefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, SkuName, DefaultStoreName)\n    if pcddefaultvalue:\n        FieldList = pcddefaultvalue\n        IsArray = _IsFieldValueAnArray(FieldList)\n        if IsArray:\n            if '{CODE(' not in FieldList:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from DSC: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n        (Value, ValueSize) = ParseFieldValue(FieldList)\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT):\n            if isinstance(Value, str):\n                if '{CODE(' in Value:\n                    if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                        pcdarraysize = Pcd.PcdArraySize()\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value,PcdArraySize);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n            elif IsArray:\n                if Pcd.IsArray():\n                    pcdarraysize = Pcd.PcdArraySize()\n                    if '{CODE(' in pcddefaultvalue:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                        CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    else:\n                        if Pcd.Capacity[-1] != '-1':\n                            CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                        CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                        CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                        CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n                elif '{CODE(' in pcddefaultvalue:\n                    CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                    CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DefaultFromDSC.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        elif isinstance(Value, str):\n            if '{CODE(' in Value:\n                if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n                    pcdarraysize = Pcd.PcdArraySize()\n                    CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                CApp = CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Pcd = %s; // From DSC Default Value %s\\n' % (Value, Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n        elif IsArray:\n            if Pcd.IsArray():\n                pcdarraysize = Pcd.PcdArraySize()\n                if '{CODE(' in pcddefaultvalue:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(sizeof(%s_%s_%s_%s_Value) <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp + ' PcdArraySize = sizeof(%s_%s_%s_%s_Value);\\n ' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                    CApp = CApp + '  memcpy (Pcd, %s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n                else:\n                    if Pcd.Capacity[-1] != '-1':\n                        CApp = CApp + '__STATIC_ASSERT(%d <= %d * sizeof(%s), \"Pcd %s.%s Value in Dsc exceed the array capability %s\"); // From  %s \\n' % (ValueSize, pcdarraysize, Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, valuefrom)\n                    CApp = CApp + ' PcdArraySize = %d;\\n' % ValueSize\n                    CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(TAB_DEFAULT, {}).get(TAB_DEFAULT_STORES_DEFAULT, Pcd.DefaultValue) if Pcd.DefaultFromDSC else Pcd.DefaultValue)\n                    CApp = CApp + '  memcpy (Pcd, Value, PcdArraySize);\\n'\n            elif '{CODE(' in pcddefaultvalue:\n                CApp = CApp + '  PcdArraySize = %d < sizeof(%s) * %d ? %d: sizeof(%s) * %d;\\n ' % (ValueSize, Pcd.BaseDatumType, pcdarraysize, ValueSize, Pcd.BaseDatumType, pcdarraysize)\n                CApp = CApp + '  memcpy (Pcd, &%s_%s_%s_%s_Value, PcdArraySize);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n            else:\n                CApp = CApp + '  Value     = %s; // From DSC Default Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), Pcd.DscRawValue.get(SkuName, {}).get(DefaultStoreName))\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n    inheritvalue = inherit_OverrideValues.get(DefaultStoreName)\n    if not inheritvalue:\n        inheritvalue = []\n    for index in inheritvalue:\n        FieldList = inheritvalue[index]\n        if not FieldList:\n            continue\n        if (SkuName, DefaultStoreName) == (TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT) or ((SkuName, '') not in Pcd.ValueChain and (SkuName, DefaultStoreName) not in Pcd.ValueChain):\n            for FieldName in FieldList:\n                indicator = self.GetIndicator(index, FieldName, Pcd)\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (indicator, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  %s = %dULL; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  %s = %d; // From %s Line %d Value %s\\n' % (indicator, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp"
        ]
    },
    {
        "func_name": "GenerateInitValueStatement",
        "original": "@staticmethod\ndef GenerateInitValueStatement(Pcd, SkuName, DefaultStoreName):\n    CApp = '  Assign_%s_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n    return CApp",
        "mutated": [
            "@staticmethod\ndef GenerateInitValueStatement(Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n    CApp = '  Assign_%s_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n    return CApp",
            "@staticmethod\ndef GenerateInitValueStatement(Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '  Assign_%s_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n    return CApp",
            "@staticmethod\ndef GenerateInitValueStatement(Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '  Assign_%s_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n    return CApp",
            "@staticmethod\ndef GenerateInitValueStatement(Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '  Assign_%s_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n    return CApp",
            "@staticmethod\ndef GenerateInitValueStatement(Pcd, SkuName, DefaultStoreName):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '  Assign_%s_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, SkuName, DefaultStoreName)\n    return CApp"
        ]
    },
    {
        "func_name": "GenerateCommandLineValue",
        "original": "def GenerateCommandLineValue(self, Pcd):\n    CApp = '// Value in CommandLine\\n'\n    CApp = CApp + 'void Assign_%s_%s_CommandLine_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromComm\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromComm]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Command: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Command Line \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Command Line.\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
        "mutated": [
            "def GenerateCommandLineValue(self, Pcd):\n    if False:\n        i = 10\n    CApp = '// Value in CommandLine\\n'\n    CApp = CApp + 'void Assign_%s_%s_CommandLine_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromComm\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromComm]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Command: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Command Line \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Command Line.\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateCommandLineValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '// Value in CommandLine\\n'\n    CApp = CApp + 'void Assign_%s_%s_CommandLine_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromComm\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromComm]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Command: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Command Line \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Command Line.\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateCommandLineValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '// Value in CommandLine\\n'\n    CApp = CApp + 'void Assign_%s_%s_CommandLine_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromComm\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromComm]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Command: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Command Line \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Command Line.\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateCommandLineValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '// Value in CommandLine\\n'\n    CApp = CApp + 'void Assign_%s_%s_CommandLine_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromComm\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromComm]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Command: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Command Line \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Command Line.\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateCommandLineValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '// Value in CommandLine\\n'\n    CApp = CApp + 'void Assign_%s_%s_CommandLine_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromComm\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromComm]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Command: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Command Line \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Command Line.\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp"
        ]
    },
    {
        "func_name": "GenerateModuleScopeValue",
        "original": "def GenerateModuleScopeValue(self, Pcd):\n    CApp = '// Value in Dsc Module scope \\n'\n    for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void Assign_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, ModuleGuid, Pcd.BaseDatumType)\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        (pcddefaultvalue, file_path, lineNo) = Pcd.PcdValueFromComponents.get(ModuleGuid, (None, None, None))\n        if pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(pcddefaultvalue)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(pcddefaultvalue, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from %s Line %s: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, file_path, lineNo, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From %s Line %s \\n' % (Value, file_path, lineNo)\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From %s Line %s.\\n' % (DscBuildData.IntToCString(Value, ValueSize), file_path, lineNo)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        PcdFiledValue = Pcd.PcdFiledValueFromDscComponent.get(ModuleGuid)\n        for index in PcdFiledValue:\n            FieldList = PcdFiledValue[index]\n            if not FieldList:\n                continue\n            for FieldName in FieldList:\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                    except:\n                        print('error')\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n        CApp = CApp + '}\\n'\n    return CApp",
        "mutated": [
            "def GenerateModuleScopeValue(self, Pcd):\n    if False:\n        i = 10\n    CApp = '// Value in Dsc Module scope \\n'\n    for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void Assign_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, ModuleGuid, Pcd.BaseDatumType)\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        (pcddefaultvalue, file_path, lineNo) = Pcd.PcdValueFromComponents.get(ModuleGuid, (None, None, None))\n        if pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(pcddefaultvalue)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(pcddefaultvalue, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from %s Line %s: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, file_path, lineNo, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From %s Line %s \\n' % (Value, file_path, lineNo)\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From %s Line %s.\\n' % (DscBuildData.IntToCString(Value, ValueSize), file_path, lineNo)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        PcdFiledValue = Pcd.PcdFiledValueFromDscComponent.get(ModuleGuid)\n        for index in PcdFiledValue:\n            FieldList = PcdFiledValue[index]\n            if not FieldList:\n                continue\n            for FieldName in FieldList:\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                    except:\n                        print('error')\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n        CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateModuleScopeValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '// Value in Dsc Module scope \\n'\n    for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void Assign_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, ModuleGuid, Pcd.BaseDatumType)\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        (pcddefaultvalue, file_path, lineNo) = Pcd.PcdValueFromComponents.get(ModuleGuid, (None, None, None))\n        if pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(pcddefaultvalue)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(pcddefaultvalue, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from %s Line %s: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, file_path, lineNo, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From %s Line %s \\n' % (Value, file_path, lineNo)\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From %s Line %s.\\n' % (DscBuildData.IntToCString(Value, ValueSize), file_path, lineNo)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        PcdFiledValue = Pcd.PcdFiledValueFromDscComponent.get(ModuleGuid)\n        for index in PcdFiledValue:\n            FieldList = PcdFiledValue[index]\n            if not FieldList:\n                continue\n            for FieldName in FieldList:\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                    except:\n                        print('error')\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n        CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateModuleScopeValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '// Value in Dsc Module scope \\n'\n    for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void Assign_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, ModuleGuid, Pcd.BaseDatumType)\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        (pcddefaultvalue, file_path, lineNo) = Pcd.PcdValueFromComponents.get(ModuleGuid, (None, None, None))\n        if pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(pcddefaultvalue)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(pcddefaultvalue, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from %s Line %s: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, file_path, lineNo, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From %s Line %s \\n' % (Value, file_path, lineNo)\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From %s Line %s.\\n' % (DscBuildData.IntToCString(Value, ValueSize), file_path, lineNo)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        PcdFiledValue = Pcd.PcdFiledValueFromDscComponent.get(ModuleGuid)\n        for index in PcdFiledValue:\n            FieldList = PcdFiledValue[index]\n            if not FieldList:\n                continue\n            for FieldName in FieldList:\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                    except:\n                        print('error')\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n        CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateModuleScopeValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '// Value in Dsc Module scope \\n'\n    for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void Assign_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, ModuleGuid, Pcd.BaseDatumType)\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        (pcddefaultvalue, file_path, lineNo) = Pcd.PcdValueFromComponents.get(ModuleGuid, (None, None, None))\n        if pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(pcddefaultvalue)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(pcddefaultvalue, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from %s Line %s: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, file_path, lineNo, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From %s Line %s \\n' % (Value, file_path, lineNo)\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From %s Line %s.\\n' % (DscBuildData.IntToCString(Value, ValueSize), file_path, lineNo)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        PcdFiledValue = Pcd.PcdFiledValueFromDscComponent.get(ModuleGuid)\n        for index in PcdFiledValue:\n            FieldList = PcdFiledValue[index]\n            if not FieldList:\n                continue\n            for FieldName in FieldList:\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                    except:\n                        print('error')\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n        CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateModuleScopeValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '// Value in Dsc Module scope \\n'\n    for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void Assign_%s_%s_%s_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, ModuleGuid, Pcd.BaseDatumType)\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        (pcddefaultvalue, file_path, lineNo) = Pcd.PcdValueFromComponents.get(ModuleGuid, (None, None, None))\n        if pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(pcddefaultvalue)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(pcddefaultvalue, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from %s Line %s: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, file_path, lineNo, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From %s Line %s \\n' % (Value, file_path, lineNo)\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From %s Line %s.\\n' % (DscBuildData.IntToCString(Value, ValueSize), file_path, lineNo)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n        PcdFiledValue = Pcd.PcdFiledValueFromDscComponent.get(ModuleGuid)\n        for index in PcdFiledValue:\n            FieldList = PcdFiledValue[index]\n            if not FieldList:\n                continue\n            for FieldName in FieldList:\n                IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n                if IsArray:\n                    try:\n                        FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                    except BadExpression:\n                        EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                    except:\n                        print('error')\n                try:\n                    (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n                except Exception:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                if isinstance(Value, str):\n                    CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                elif IsArray:\n                    CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                    CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n                else:\n                    if '[' in FieldName and ']' in FieldName:\n                        Index = int(FieldName.split('[')[1].split(']')[0])\n                        CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                    if ValueSize > 4:\n                        CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                    else:\n                        CApp = CApp + '  Pcd->%s = %d; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n        CApp = CApp + '}\\n'\n    return CApp"
        ]
    },
    {
        "func_name": "GenerateCommandLineValueStatement",
        "original": "@staticmethod\ndef GenerateCommandLineValueStatement(Pcd):\n    CApp = '  Assign_%s_%s_CommandLine_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
        "mutated": [
            "@staticmethod\ndef GenerateCommandLineValueStatement(Pcd):\n    if False:\n        i = 10\n    CApp = '  Assign_%s_%s_CommandLine_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateCommandLineValueStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '  Assign_%s_%s_CommandLine_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateCommandLineValueStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '  Assign_%s_%s_CommandLine_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateCommandLineValueStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '  Assign_%s_%s_CommandLine_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateCommandLineValueStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '  Assign_%s_%s_CommandLine_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp"
        ]
    },
    {
        "func_name": "GenerateFdfValue",
        "original": "def GenerateFdfValue(self, Pcd):\n    CApp = '// Value in Fdf\\n'\n    CApp = CApp + 'void Assign_%s_%s_Fdf_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromFdf\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromFdf]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Fdf: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Fdf \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Fdf .\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %s Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
        "mutated": [
            "def GenerateFdfValue(self, Pcd):\n    if False:\n        i = 10\n    CApp = '// Value in Fdf\\n'\n    CApp = CApp + 'void Assign_%s_%s_Fdf_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromFdf\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromFdf]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Fdf: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Fdf \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Fdf .\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %s Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateFdfValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '// Value in Fdf\\n'\n    CApp = CApp + 'void Assign_%s_%s_Fdf_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromFdf\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromFdf]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Fdf: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Fdf \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Fdf .\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %s Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateFdfValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '// Value in Fdf\\n'\n    CApp = CApp + 'void Assign_%s_%s_Fdf_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromFdf\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromFdf]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Fdf: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Fdf \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Fdf .\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %s Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateFdfValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '// Value in Fdf\\n'\n    CApp = CApp + 'void Assign_%s_%s_Fdf_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromFdf\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromFdf]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Fdf: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Fdf \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Fdf .\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %s Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp",
            "def GenerateFdfValue(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '// Value in Fdf\\n'\n    CApp = CApp + 'void Assign_%s_%s_Fdf_Value(%s *Pcd){\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.BaseDatumType)\n    CApp = CApp + '  UINT32  FieldSize;\\n'\n    CApp = CApp + '  CHAR8   *Value;\\n'\n    pcddefaultvalue = Pcd.PcdValueFromFdf\n    for FieldList in [pcddefaultvalue, Pcd.PcdFieldValueFromFdf]:\n        if not FieldList:\n            continue\n        if pcddefaultvalue and FieldList == pcddefaultvalue:\n            IsArray = _IsFieldValueAnArray(FieldList)\n            if IsArray:\n                try:\n                    FieldList = ValueExpressionEx(FieldList, TAB_VOID)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s.%s, from Fdf: %s' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldList))\n            (Value, ValueSize) = ParseFieldValue(FieldList)\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd = %s; // From Fdf \\n' % Value\n            elif IsArray:\n                CApp = CApp + '  Value     = %s; // From Fdf .\\n' % DscBuildData.IntToCString(Value, ValueSize)\n                CApp = CApp + '  memcpy (Pcd, Value, %d);\\n' % ValueSize\n            continue\n        for FieldName in FieldList:\n            IsArray = _IsFieldValueAnArray(FieldList[FieldName][0])\n            if IsArray:\n                try:\n                    FieldList[FieldName][0] = ValueExpressionEx(FieldList[FieldName][0], TAB_VOID, self._GuidDict)(True)\n                except BadExpression:\n                    EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n                except:\n                    print('error')\n            try:\n                (Value, ValueSize) = ParseFieldValue(FieldList[FieldName][0])\n            except Exception:\n                EdkLogger.error('Build', FORMAT_INVALID, 'Invalid value format for %s. From %s Line %d ' % ('.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName, FieldName)), FieldList[FieldName][1], FieldList[FieldName][2]))\n            if isinstance(Value, str):\n                CApp = CApp + '  Pcd->%s = %s; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n            elif IsArray:\n                CApp = CApp + '  FieldSize = __FIELD_SIZE(%s, %s);\\n' % (Pcd.BaseDatumType, FieldName)\n                CApp = CApp + '  Value     = %s; // From %s Line %d Value %s\\n' % (DscBuildData.IntToCString(Value, ValueSize), FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  __STATIC_ASSERT((__FIELD_SIZE(%s, %s) >= %d) || (__FIELD_SIZE(%s, %s) == 0), \"Input buffer exceeds the buffer array\"); // From %s Line %d Value %s\\n' % (Pcd.BaseDatumType, FieldName, ValueSize, Pcd.BaseDatumType, FieldName, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                CApp = CApp + '  memcpy (&Pcd->%s, Value, (FieldSize > 0 && FieldSize < %d) ? FieldSize : %d);\\n' % (FieldName, ValueSize, ValueSize)\n            else:\n                if '[' in FieldName and ']' in FieldName:\n                    Index = int(FieldName.split('[')[1].split(']')[0])\n                    CApp = CApp + '  __STATIC_ASSERT((%d < __ARRAY_SIZE(Pcd->%s)) || (__ARRAY_SIZE(Pcd->%s) == 0), \"array index exceeds the array number\"); // From %s Line %d Index of %s\\n' % (Index, FieldName.split('[')[0], FieldName.split('[')[0], FieldList[FieldName][1], FieldList[FieldName][2], FieldName)\n                if ValueSize > 4:\n                    CApp = CApp + '  Pcd->%s = %dULL; // From %s Line %d Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n                else:\n                    CApp = CApp + '  Pcd->%s = %d; // From %s Line %s Value %s\\n' % (FieldName, Value, FieldList[FieldName][1], FieldList[FieldName][2], FieldList[FieldName][0])\n    CApp = CApp + '}\\n'\n    return CApp"
        ]
    },
    {
        "func_name": "GenerateFdfValueStatement",
        "original": "@staticmethod\ndef GenerateFdfValueStatement(Pcd):\n    CApp = '  Assign_%s_%s_Fdf_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
        "mutated": [
            "@staticmethod\ndef GenerateFdfValueStatement(Pcd):\n    if False:\n        i = 10\n    CApp = '  Assign_%s_%s_Fdf_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateFdfValueStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '  Assign_%s_%s_Fdf_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateFdfValueStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '  Assign_%s_%s_Fdf_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateFdfValueStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '  Assign_%s_%s_Fdf_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp",
            "@staticmethod\ndef GenerateFdfValueStatement(Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '  Assign_%s_%s_Fdf_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    return CApp"
        ]
    },
    {
        "func_name": "GenerateModuleValueStatement",
        "original": "@staticmethod\ndef GenerateModuleValueStatement(module_guid, Pcd):\n    CApp = '  Assign_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, module_guid)\n    return CApp",
        "mutated": [
            "@staticmethod\ndef GenerateModuleValueStatement(module_guid, Pcd):\n    if False:\n        i = 10\n    CApp = '  Assign_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, module_guid)\n    return CApp",
            "@staticmethod\ndef GenerateModuleValueStatement(module_guid, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = '  Assign_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, module_guid)\n    return CApp",
            "@staticmethod\ndef GenerateModuleValueStatement(module_guid, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = '  Assign_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, module_guid)\n    return CApp",
            "@staticmethod\ndef GenerateModuleValueStatement(module_guid, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = '  Assign_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, module_guid)\n    return CApp",
            "@staticmethod\ndef GenerateModuleValueStatement(module_guid, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = '  Assign_%s_%s_%s_Value(Pcd);\\n' % (Pcd.TokenSpaceGuidCName, Pcd.TokenCName, module_guid)\n    return CApp"
        ]
    },
    {
        "func_name": "GenerateModuleScopeInitializeFunc",
        "original": "def GenerateModuleScopeInitializeFunc(self, SkuName, Pcd, InitByteValue, CApp):\n    for module_guid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, TAB_DEFAULT_STORES_DEFAULT)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n        CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateModuleValueStatement(module_guid, Pcd)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
        "mutated": [
            "def GenerateModuleScopeInitializeFunc(self, SkuName, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n    for module_guid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, TAB_DEFAULT_STORES_DEFAULT)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n        CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateModuleValueStatement(module_guid, Pcd)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
            "def GenerateModuleScopeInitializeFunc(self, SkuName, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for module_guid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, TAB_DEFAULT_STORES_DEFAULT)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n        CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateModuleValueStatement(module_guid, Pcd)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
            "def GenerateModuleScopeInitializeFunc(self, SkuName, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for module_guid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, TAB_DEFAULT_STORES_DEFAULT)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n        CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateModuleValueStatement(module_guid, Pcd)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
            "def GenerateModuleScopeInitializeFunc(self, SkuName, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for module_guid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, TAB_DEFAULT_STORES_DEFAULT)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n        CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateModuleValueStatement(module_guid, Pcd)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
            "def GenerateModuleScopeInitializeFunc(self, SkuName, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for module_guid in Pcd.PcdFiledValueFromDscComponent:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, TAB_DEFAULT_STORES_DEFAULT)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n        CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateModuleValueStatement(module_guid, Pcd)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (module_guid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)"
        ]
    },
    {
        "func_name": "GenerateInitializeFunc",
        "original": "def GenerateInitializeFunc(self, SkuName, DefaultStore, Pcd, InitByteValue, CApp):\n    OverrideValues = {DefaultStore: {}}\n    if Pcd.SkuOverrideValues:\n        OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    if not OverrideValues:\n        OverrideValues = {TAB_DEFAULT_STORES_DEFAULT: Pcd.DefaultValues}\n    for DefaultStoreName in OverrideValues:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, DefaultStoreName)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        if Pcd.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            for skuname in self.SkuIdMgr.GetSkuChain(SkuName):\n                storeset = [DefaultStoreName] if DefaultStoreName == TAB_DEFAULT_STORES_DEFAULT else [TAB_DEFAULT_STORES_DEFAULT, DefaultStoreName]\n                for defaultstorenameitem in storeset:\n                    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n                    CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, skuname, defaultstorenameitem)\n                if skuname == SkuName:\n                    break\n        else:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n            CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
        "mutated": [
            "def GenerateInitializeFunc(self, SkuName, DefaultStore, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n    OverrideValues = {DefaultStore: {}}\n    if Pcd.SkuOverrideValues:\n        OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    if not OverrideValues:\n        OverrideValues = {TAB_DEFAULT_STORES_DEFAULT: Pcd.DefaultValues}\n    for DefaultStoreName in OverrideValues:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, DefaultStoreName)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        if Pcd.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            for skuname in self.SkuIdMgr.GetSkuChain(SkuName):\n                storeset = [DefaultStoreName] if DefaultStoreName == TAB_DEFAULT_STORES_DEFAULT else [TAB_DEFAULT_STORES_DEFAULT, DefaultStoreName]\n                for defaultstorenameitem in storeset:\n                    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n                    CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, skuname, defaultstorenameitem)\n                if skuname == SkuName:\n                    break\n        else:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n            CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
            "def GenerateInitializeFunc(self, SkuName, DefaultStore, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    OverrideValues = {DefaultStore: {}}\n    if Pcd.SkuOverrideValues:\n        OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    if not OverrideValues:\n        OverrideValues = {TAB_DEFAULT_STORES_DEFAULT: Pcd.DefaultValues}\n    for DefaultStoreName in OverrideValues:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, DefaultStoreName)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        if Pcd.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            for skuname in self.SkuIdMgr.GetSkuChain(SkuName):\n                storeset = [DefaultStoreName] if DefaultStoreName == TAB_DEFAULT_STORES_DEFAULT else [TAB_DEFAULT_STORES_DEFAULT, DefaultStoreName]\n                for defaultstorenameitem in storeset:\n                    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n                    CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, skuname, defaultstorenameitem)\n                if skuname == SkuName:\n                    break\n        else:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n            CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
            "def GenerateInitializeFunc(self, SkuName, DefaultStore, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    OverrideValues = {DefaultStore: {}}\n    if Pcd.SkuOverrideValues:\n        OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    if not OverrideValues:\n        OverrideValues = {TAB_DEFAULT_STORES_DEFAULT: Pcd.DefaultValues}\n    for DefaultStoreName in OverrideValues:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, DefaultStoreName)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        if Pcd.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            for skuname in self.SkuIdMgr.GetSkuChain(SkuName):\n                storeset = [DefaultStoreName] if DefaultStoreName == TAB_DEFAULT_STORES_DEFAULT else [TAB_DEFAULT_STORES_DEFAULT, DefaultStoreName]\n                for defaultstorenameitem in storeset:\n                    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n                    CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, skuname, defaultstorenameitem)\n                if skuname == SkuName:\n                    break\n        else:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n            CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
            "def GenerateInitializeFunc(self, SkuName, DefaultStore, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    OverrideValues = {DefaultStore: {}}\n    if Pcd.SkuOverrideValues:\n        OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    if not OverrideValues:\n        OverrideValues = {TAB_DEFAULT_STORES_DEFAULT: Pcd.DefaultValues}\n    for DefaultStoreName in OverrideValues:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, DefaultStoreName)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        if Pcd.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            for skuname in self.SkuIdMgr.GetSkuChain(SkuName):\n                storeset = [DefaultStoreName] if DefaultStoreName == TAB_DEFAULT_STORES_DEFAULT else [TAB_DEFAULT_STORES_DEFAULT, DefaultStoreName]\n                for defaultstorenameitem in storeset:\n                    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n                    CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, skuname, defaultstorenameitem)\n                if skuname == SkuName:\n                    break\n        else:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n            CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)",
            "def GenerateInitializeFunc(self, SkuName, DefaultStore, Pcd, InitByteValue, CApp):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    OverrideValues = {DefaultStore: {}}\n    if Pcd.SkuOverrideValues:\n        OverrideValues = Pcd.SkuOverrideValues[SkuName]\n    if not OverrideValues:\n        OverrideValues = {TAB_DEFAULT_STORES_DEFAULT: Pcd.DefaultValues}\n    for DefaultStoreName in OverrideValues:\n        CApp = CApp + 'void\\n'\n        CApp = CApp + 'Initialize_%s_%s_%s_%s(\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  void\\n'\n        CApp = CApp + '  )\\n'\n        CApp = CApp + '{\\n'\n        CApp = CApp + '  UINT32  Size;\\n'\n        CApp = CApp + '  UINT32  FieldSize;\\n'\n        CApp = CApp + '  CHAR8   *Value;\\n'\n        CApp = CApp + '  UINT32  OriginalSize;\\n'\n        CApp = CApp + '  VOID    *OriginalPcd;\\n'\n        CApp = CApp + '  %s      *Pcd;  // From %s Line %d \\n' % (Pcd.BaseDatumType, Pcd.PkgPath, Pcd.PcdDefineLineNo)\n        CApp = CApp + '\\n'\n        PcdDefaultValue = StringToArray(Pcd.DefaultValueFromDec.strip())\n        InitByteValue += '%s.%s.%s.%s|%s|%s\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Pcd.DatumType, PcdDefaultValue)\n        CApp = CApp + '  OriginalPcd = PcdGetPtr (%s, %s, %s, %s, &OriginalSize);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + DscBuildData.GenerateSizeStatments(Pcd, SkuName, DefaultStoreName)\n        if Pcd.IsArray() and Pcd.Capacity[-1] != '-1':\n            CApp = CApp + '  OriginalSize = OriginalSize < sizeof(%s) * %d? OriginalSize:sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize(), Pcd.BaseDatumType, Pcd.PcdArraySize())\n            CApp = CApp + '  Size = sizeof(%s) * %d; \\n' % (Pcd.BaseDatumType, Pcd.PcdArraySize())\n        CApp = CApp + '  Size = (OriginalSize > Size ? OriginalSize : Size);\\n'\n        CApp = CApp + '  Pcd     = (%s *)malloc (Size);\\n' % (Pcd.BaseDatumType,)\n        CApp = CApp + '  memset (Pcd, 0, Size);\\n'\n        CApp = CApp + '  memcpy (Pcd, OriginalPcd, OriginalSize);\\n'\n        CApp = CApp + DscBuildData.GenerateDefaultValueAssignStatement(Pcd)\n        if Pcd.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            for skuname in self.SkuIdMgr.GetSkuChain(SkuName):\n                storeset = [DefaultStoreName] if DefaultStoreName == TAB_DEFAULT_STORES_DEFAULT else [TAB_DEFAULT_STORES_DEFAULT, DefaultStoreName]\n                for defaultstorenameitem in storeset:\n                    CApp = CApp + '// SkuName: %s,  DefaultStoreName: %s \\n' % (skuname, defaultstorenameitem)\n                    CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, skuname, defaultstorenameitem)\n                if skuname == SkuName:\n                    break\n        else:\n            CApp = CApp + '// SkuName: %s,  DefaultStoreName: STANDARD \\n' % self.SkuIdMgr.SystemSkuId\n            CApp = CApp + DscBuildData.GenerateInitValueStatement(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        CApp = CApp + DscBuildData.GenerateFdfValueStatement(Pcd)\n        CApp = CApp + DscBuildData.GenerateCommandLineValueStatement(Pcd)\n        CApp = CApp + '  PcdSetPtr (%s, %s, %s, %s, Size, (void *)Pcd);\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        CApp = CApp + '  free (Pcd);\\n'\n        CApp = CApp + '}\\n'\n        CApp = CApp + '\\n'\n    return (InitByteValue, CApp)"
        ]
    },
    {
        "func_name": "GenerateArrayAssignment",
        "original": "def GenerateArrayAssignment(self, Pcd):\n    CApp = ''\n    if not Pcd:\n        return CApp\n    Demesion = ''\n    for d in Pcd.Capacity:\n        Demesion += '[]'\n    Value = Pcd.DefaultValueFromDec\n    if '{CODE(' in Pcd.DefaultValueFromDec:\n        realvalue = Pcd.DefaultValueFromDec.strip()[6:-2]\n        CApp += 'static %s %s_%s_INIT_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n        for skuname in Pcd.SkuInfoList:\n            skuinfo = Pcd.SkuInfoList[skuname]\n            if skuinfo.VariableName:\n                for defaultstore in skuinfo.DefaultStoreDict:\n                    pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                    if pcddscrawdefaultvalue:\n                        Value = skuinfo.DefaultStoreDict[defaultstore]\n                        if '{CODE(' in Value:\n                            realvalue = Value.strip()[6:-2]\n                            CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Demesion, realvalue)\n            else:\n                pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                if pcddscrawdefaultvalue:\n                    Value = skuinfo.DefaultValue\n                    if '{CODE(' in Value:\n                        realvalue = Value.strip()[6:-2]\n                        CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Demesion, realvalue)\n    else:\n        pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n        if pcddscrawdefaultvalue:\n            if '{CODE(' in Pcd.DefaultValue:\n                realvalue = Pcd.DefaultValue.strip()[6:-2]\n                CApp += 'static %s %s_%s_DEFAULT_STANDARD_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    return CApp",
        "mutated": [
            "def GenerateArrayAssignment(self, Pcd):\n    if False:\n        i = 10\n    CApp = ''\n    if not Pcd:\n        return CApp\n    Demesion = ''\n    for d in Pcd.Capacity:\n        Demesion += '[]'\n    Value = Pcd.DefaultValueFromDec\n    if '{CODE(' in Pcd.DefaultValueFromDec:\n        realvalue = Pcd.DefaultValueFromDec.strip()[6:-2]\n        CApp += 'static %s %s_%s_INIT_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n        for skuname in Pcd.SkuInfoList:\n            skuinfo = Pcd.SkuInfoList[skuname]\n            if skuinfo.VariableName:\n                for defaultstore in skuinfo.DefaultStoreDict:\n                    pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                    if pcddscrawdefaultvalue:\n                        Value = skuinfo.DefaultStoreDict[defaultstore]\n                        if '{CODE(' in Value:\n                            realvalue = Value.strip()[6:-2]\n                            CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Demesion, realvalue)\n            else:\n                pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                if pcddscrawdefaultvalue:\n                    Value = skuinfo.DefaultValue\n                    if '{CODE(' in Value:\n                        realvalue = Value.strip()[6:-2]\n                        CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Demesion, realvalue)\n    else:\n        pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n        if pcddscrawdefaultvalue:\n            if '{CODE(' in Pcd.DefaultValue:\n                realvalue = Pcd.DefaultValue.strip()[6:-2]\n                CApp += 'static %s %s_%s_DEFAULT_STANDARD_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    return CApp",
            "def GenerateArrayAssignment(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CApp = ''\n    if not Pcd:\n        return CApp\n    Demesion = ''\n    for d in Pcd.Capacity:\n        Demesion += '[]'\n    Value = Pcd.DefaultValueFromDec\n    if '{CODE(' in Pcd.DefaultValueFromDec:\n        realvalue = Pcd.DefaultValueFromDec.strip()[6:-2]\n        CApp += 'static %s %s_%s_INIT_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n        for skuname in Pcd.SkuInfoList:\n            skuinfo = Pcd.SkuInfoList[skuname]\n            if skuinfo.VariableName:\n                for defaultstore in skuinfo.DefaultStoreDict:\n                    pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                    if pcddscrawdefaultvalue:\n                        Value = skuinfo.DefaultStoreDict[defaultstore]\n                        if '{CODE(' in Value:\n                            realvalue = Value.strip()[6:-2]\n                            CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Demesion, realvalue)\n            else:\n                pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                if pcddscrawdefaultvalue:\n                    Value = skuinfo.DefaultValue\n                    if '{CODE(' in Value:\n                        realvalue = Value.strip()[6:-2]\n                        CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Demesion, realvalue)\n    else:\n        pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n        if pcddscrawdefaultvalue:\n            if '{CODE(' in Pcd.DefaultValue:\n                realvalue = Pcd.DefaultValue.strip()[6:-2]\n                CApp += 'static %s %s_%s_DEFAULT_STANDARD_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    return CApp",
            "def GenerateArrayAssignment(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CApp = ''\n    if not Pcd:\n        return CApp\n    Demesion = ''\n    for d in Pcd.Capacity:\n        Demesion += '[]'\n    Value = Pcd.DefaultValueFromDec\n    if '{CODE(' in Pcd.DefaultValueFromDec:\n        realvalue = Pcd.DefaultValueFromDec.strip()[6:-2]\n        CApp += 'static %s %s_%s_INIT_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n        for skuname in Pcd.SkuInfoList:\n            skuinfo = Pcd.SkuInfoList[skuname]\n            if skuinfo.VariableName:\n                for defaultstore in skuinfo.DefaultStoreDict:\n                    pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                    if pcddscrawdefaultvalue:\n                        Value = skuinfo.DefaultStoreDict[defaultstore]\n                        if '{CODE(' in Value:\n                            realvalue = Value.strip()[6:-2]\n                            CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Demesion, realvalue)\n            else:\n                pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                if pcddscrawdefaultvalue:\n                    Value = skuinfo.DefaultValue\n                    if '{CODE(' in Value:\n                        realvalue = Value.strip()[6:-2]\n                        CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Demesion, realvalue)\n    else:\n        pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n        if pcddscrawdefaultvalue:\n            if '{CODE(' in Pcd.DefaultValue:\n                realvalue = Pcd.DefaultValue.strip()[6:-2]\n                CApp += 'static %s %s_%s_DEFAULT_STANDARD_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    return CApp",
            "def GenerateArrayAssignment(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CApp = ''\n    if not Pcd:\n        return CApp\n    Demesion = ''\n    for d in Pcd.Capacity:\n        Demesion += '[]'\n    Value = Pcd.DefaultValueFromDec\n    if '{CODE(' in Pcd.DefaultValueFromDec:\n        realvalue = Pcd.DefaultValueFromDec.strip()[6:-2]\n        CApp += 'static %s %s_%s_INIT_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n        for skuname in Pcd.SkuInfoList:\n            skuinfo = Pcd.SkuInfoList[skuname]\n            if skuinfo.VariableName:\n                for defaultstore in skuinfo.DefaultStoreDict:\n                    pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                    if pcddscrawdefaultvalue:\n                        Value = skuinfo.DefaultStoreDict[defaultstore]\n                        if '{CODE(' in Value:\n                            realvalue = Value.strip()[6:-2]\n                            CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Demesion, realvalue)\n            else:\n                pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                if pcddscrawdefaultvalue:\n                    Value = skuinfo.DefaultValue\n                    if '{CODE(' in Value:\n                        realvalue = Value.strip()[6:-2]\n                        CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Demesion, realvalue)\n    else:\n        pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n        if pcddscrawdefaultvalue:\n            if '{CODE(' in Pcd.DefaultValue:\n                realvalue = Pcd.DefaultValue.strip()[6:-2]\n                CApp += 'static %s %s_%s_DEFAULT_STANDARD_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    return CApp",
            "def GenerateArrayAssignment(self, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CApp = ''\n    if not Pcd:\n        return CApp\n    Demesion = ''\n    for d in Pcd.Capacity:\n        Demesion += '[]'\n    Value = Pcd.DefaultValueFromDec\n    if '{CODE(' in Pcd.DefaultValueFromDec:\n        realvalue = Pcd.DefaultValueFromDec.strip()[6:-2]\n        CApp += 'static %s %s_%s_INIT_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    if Pcd.Type in PCD_DYNAMIC_TYPE_SET | PCD_DYNAMIC_EX_TYPE_SET:\n        for skuname in Pcd.SkuInfoList:\n            skuinfo = Pcd.SkuInfoList[skuname]\n            if skuinfo.VariableName:\n                for defaultstore in skuinfo.DefaultStoreDict:\n                    pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, defaultstore)\n                    if pcddscrawdefaultvalue:\n                        Value = skuinfo.DefaultStoreDict[defaultstore]\n                        if '{CODE(' in Value:\n                            realvalue = Value.strip()[6:-2]\n                            CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, defaultstore, Demesion, realvalue)\n            else:\n                pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, skuname, TAB_DEFAULT_STORES_DEFAULT)\n                if pcddscrawdefaultvalue:\n                    Value = skuinfo.DefaultValue\n                    if '{CODE(' in Value:\n                        realvalue = Value.strip()[6:-2]\n                        CApp += 'static %s %s_%s_%s_%s_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, skuname, TAB_DEFAULT_STORES_DEFAULT, Demesion, realvalue)\n    else:\n        pcddscrawdefaultvalue = self.GetPcdDscRawDefaultValue(Pcd, TAB_DEFAULT, TAB_DEFAULT_STORES_DEFAULT)\n        if pcddscrawdefaultvalue:\n            if '{CODE(' in Pcd.DefaultValue:\n                realvalue = Pcd.DefaultValue.strip()[6:-2]\n                CApp += 'static %s %s_%s_DEFAULT_STANDARD_Value%s = %s;\\n' % (Pcd.BaseDatumType, Pcd.TokenSpaceGuidCName, Pcd.TokenCName, Demesion, realvalue)\n    return CApp"
        ]
    },
    {
        "func_name": "SkuOverrideValuesEmpty",
        "original": "def SkuOverrideValuesEmpty(self, OverrideValues):\n    if not OverrideValues:\n        return True\n    for key in OverrideValues:\n        if OverrideValues[key]:\n            return False\n    return True",
        "mutated": [
            "def SkuOverrideValuesEmpty(self, OverrideValues):\n    if False:\n        i = 10\n    if not OverrideValues:\n        return True\n    for key in OverrideValues:\n        if OverrideValues[key]:\n            return False\n    return True",
            "def SkuOverrideValuesEmpty(self, OverrideValues):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not OverrideValues:\n        return True\n    for key in OverrideValues:\n        if OverrideValues[key]:\n            return False\n    return True",
            "def SkuOverrideValuesEmpty(self, OverrideValues):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not OverrideValues:\n        return True\n    for key in OverrideValues:\n        if OverrideValues[key]:\n            return False\n    return True",
            "def SkuOverrideValuesEmpty(self, OverrideValues):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not OverrideValues:\n        return True\n    for key in OverrideValues:\n        if OverrideValues[key]:\n            return False\n    return True",
            "def SkuOverrideValuesEmpty(self, OverrideValues):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not OverrideValues:\n        return True\n    for key in OverrideValues:\n        if OverrideValues[key]:\n            return False\n    return True"
        ]
    },
    {
        "func_name": "ParseCCFlags",
        "original": "def ParseCCFlags(self, ccflag):\n    ccflags = set()\n    ccflaglist = ccflag.split(' ')\n    i = 0\n    while i < len(ccflaglist):\n        item = ccflaglist[i].strip()\n        if item in ('/D', '/U', '-D', '-U'):\n            ccflags.add(' '.join((ccflaglist[i], ccflaglist[i + 1])))\n            i = i + 1\n        elif item.startswith(('/D', '/U', '-D', '-U')):\n            ccflags.add(item)\n        i += 1\n    return ccflags",
        "mutated": [
            "def ParseCCFlags(self, ccflag):\n    if False:\n        i = 10\n    ccflags = set()\n    ccflaglist = ccflag.split(' ')\n    i = 0\n    while i < len(ccflaglist):\n        item = ccflaglist[i].strip()\n        if item in ('/D', '/U', '-D', '-U'):\n            ccflags.add(' '.join((ccflaglist[i], ccflaglist[i + 1])))\n            i = i + 1\n        elif item.startswith(('/D', '/U', '-D', '-U')):\n            ccflags.add(item)\n        i += 1\n    return ccflags",
            "def ParseCCFlags(self, ccflag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ccflags = set()\n    ccflaglist = ccflag.split(' ')\n    i = 0\n    while i < len(ccflaglist):\n        item = ccflaglist[i].strip()\n        if item in ('/D', '/U', '-D', '-U'):\n            ccflags.add(' '.join((ccflaglist[i], ccflaglist[i + 1])))\n            i = i + 1\n        elif item.startswith(('/D', '/U', '-D', '-U')):\n            ccflags.add(item)\n        i += 1\n    return ccflags",
            "def ParseCCFlags(self, ccflag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ccflags = set()\n    ccflaglist = ccflag.split(' ')\n    i = 0\n    while i < len(ccflaglist):\n        item = ccflaglist[i].strip()\n        if item in ('/D', '/U', '-D', '-U'):\n            ccflags.add(' '.join((ccflaglist[i], ccflaglist[i + 1])))\n            i = i + 1\n        elif item.startswith(('/D', '/U', '-D', '-U')):\n            ccflags.add(item)\n        i += 1\n    return ccflags",
            "def ParseCCFlags(self, ccflag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ccflags = set()\n    ccflaglist = ccflag.split(' ')\n    i = 0\n    while i < len(ccflaglist):\n        item = ccflaglist[i].strip()\n        if item in ('/D', '/U', '-D', '-U'):\n            ccflags.add(' '.join((ccflaglist[i], ccflaglist[i + 1])))\n            i = i + 1\n        elif item.startswith(('/D', '/U', '-D', '-U')):\n            ccflags.add(item)\n        i += 1\n    return ccflags",
            "def ParseCCFlags(self, ccflag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ccflags = set()\n    ccflaglist = ccflag.split(' ')\n    i = 0\n    while i < len(ccflaglist):\n        item = ccflaglist[i].strip()\n        if item in ('/D', '/U', '-D', '-U'):\n            ccflags.add(' '.join((ccflaglist[i], ccflaglist[i + 1])))\n            i = i + 1\n        elif item.startswith(('/D', '/U', '-D', '-U')):\n            ccflags.add(item)\n        i += 1\n    return ccflags"
        ]
    },
    {
        "func_name": "GenerateByteArrayValue",
        "original": "def GenerateByteArrayValue(self, StructuredPcds):\n    if not StructuredPcds:\n        return\n    InitByteValue = ''\n    CApp = PcdMainCHeader\n    IncludeFiles = set()\n    for PcdName in StructuredPcds:\n        Pcd = StructuredPcds[PcdName]\n        for IncludeFile in Pcd.StructuredPcdIncludeFile:\n            if IncludeFile not in IncludeFiles:\n                IncludeFiles.add(IncludeFile)\n                CApp = CApp + '#include <%s>\\n' % IncludeFile\n    CApp = CApp + '\\n'\n    for Pcd in StructuredPcds.values():\n        CApp = CApp + self.GenerateArrayAssignment(Pcd)\n    for PcdName in sorted(StructuredPcds.keys()):\n        Pcd = StructuredPcds[PcdName]\n        CApp = CApp + self.GenerateSizeFunction(Pcd)\n        CApp = CApp + self.GenerateDefaultValueAssignFunction(Pcd)\n        CApp = CApp + self.GenerateFdfValue(Pcd)\n        CApp = CApp + self.GenerateCommandLineValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + self.GenerateInitValueFunction(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + self.GenerateInitValueFunction(Pcd, SkuName, DefaultStoreName)\n        CApp = CApp + self.GenerateModuleScopeValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            (InitByteValue, CApp) = self.GenerateInitializeFunc(self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd, InitByteValue, CApp)\n            (InitByteValue, CApp) = self.GenerateModuleScopeInitializeFunc(self.SkuIdMgr.SystemSkuId, Pcd, InitByteValue, CApp)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.DefaultStoreName:\n                    Pcd = StructuredPcds[PcdName]\n                    (InitByteValue, CApp) = self.GenerateInitializeFunc(SkuName, DefaultStoreName, Pcd, InitByteValue, CApp)\n    CApp = CApp + 'VOID\\n'\n    CApp = CApp + 'PcdEntryPoint(\\n'\n    CApp = CApp + '  VOID\\n'\n    CApp = CApp + '  )\\n'\n    CApp = CApp + '{\\n'\n    for Pcd in StructuredPcds.values():\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n                CApp += '  Initialize_%s_%s_%s_%s();\\n' % (ModuleGuid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in self.SkuIdMgr.AvailableSkuIdSet:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    CApp = CApp + '}\\n'\n    CApp = CApp + PcdMainCEntry + '\\n'\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n    SaveFileOnChange(CAppBaseFileName + '.c', CApp, False)\n    MakeApp = PcdMakefileHeader\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + 'APPFILE = %s\\\\%s.exe\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s\\\\%s.obj %s.obj\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'INC = '\n    else:\n        MakeApp = MakeApp + PcdGccMakefile\n        MakeApp = MakeApp + 'APPFILE = %s/%s\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s/%s.o %s.o\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'include $(MAKEROOT)/Makefiles/app.makefile\\n' + 'TOOL_INCLUDE +='\n    IncSearchList = []\n    PlatformInc = OrderedDict()\n    for Cache in self._Bdb._CACHE_.values():\n        if Cache.MetaFile.Ext.lower() != '.dec':\n            continue\n        if Cache.Includes:\n            if str(Cache.MetaFile.Path) not in PlatformInc:\n                PlatformInc[str(Cache.MetaFile.Path)] = []\n                PlatformInc[str(Cache.MetaFile.Path)].append(os.path.dirname(Cache.MetaFile.Path))\n                PlatformInc[str(Cache.MetaFile.Path)].extend(Cache.CommonIncludes)\n    PcdDependDEC = []\n    for Pcd in StructuredPcds.values():\n        for PackageDec in Pcd.PackageDecs:\n            Package = os.path.normpath(mws.join(GlobalData.gWorkspace, PackageDec))\n            if not os.path.exists(Package):\n                EdkLogger.error('Build', RESOURCE_NOT_AVAILABLE, 'The dependent Package %s of PCD %s.%s is not exist.' % (PackageDec, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n            if Package not in PcdDependDEC:\n                PcdDependDEC.append(Package)\n    if PlatformInc and PcdDependDEC:\n        for pkg in PcdDependDEC:\n            if pkg in PlatformInc:\n                for inc in PlatformInc[pkg]:\n                    FileList = os.listdir(str(inc))\n                    if 'stdio.h' in FileList:\n                        continue\n                    if 'stdlib.h' in FileList:\n                        continue\n                    if 'string.h' in FileList:\n                        continue\n                    MakeApp += '-I' + str(inc) + ' '\n                    IncSearchList.append(inc)\n    MakeApp = MakeApp + '\\n'\n    CC_FLAGS = LinuxCFLAGS\n    if sys.platform == 'win32':\n        CC_FLAGS = WindowsCFLAGS\n    BuildOptions = OrderedDict()\n    for Options in self.BuildOptions:\n        if Options[2] != EDKII_NAME:\n            continue\n        Family = Options[0]\n        if Family and Family != self.ToolChainFamily:\n            continue\n        (Target, Tag, Arch, Tool, Attr) = Options[1].split('_')\n        if Tool != 'CC':\n            continue\n        if Attr != 'FLAGS':\n            continue\n        if Target == TAB_STAR or Target == self._Target:\n            if Tag == TAB_STAR or Tag == self._Toolchain:\n                if 'COMMON' not in BuildOptions:\n                    BuildOptions['COMMON'] = set()\n                if Arch == TAB_STAR:\n                    BuildOptions['COMMON'] |= self.ParseCCFlags(self.BuildOptions[Options])\n                if Arch in self.SupArchList:\n                    if Arch not in BuildOptions:\n                        BuildOptions[Arch] = set()\n                    BuildOptions[Arch] |= self.ParseCCFlags(self.BuildOptions[Options])\n    if BuildOptions:\n        ArchBuildOptions = {arch: flags for (arch, flags) in BuildOptions.items() if arch != 'COMMON'}\n        if len(ArchBuildOptions.keys()) == 1:\n            BuildOptions['COMMON'] |= list(ArchBuildOptions.values())[0]\n        elif len(ArchBuildOptions.keys()) > 1:\n            CommonBuildOptions = reduce(lambda x, y: x & y, ArchBuildOptions.values())\n            BuildOptions['COMMON'] |= CommonBuildOptions\n        ValueList = [item for item in BuildOptions['COMMON'] if item.startswith(('/U', '-U'))]\n        ValueList.extend([item for item in BuildOptions['COMMON'] if item.startswith(('/D', '-D'))])\n        CC_FLAGS += ' '.join(ValueList)\n    MakeApp += CC_FLAGS\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + PcdMakefileEnd\n        MakeApp = MakeApp + AppTarget % '\\tcopy $(APPLICATION) $(APPFILE) /y '\n    else:\n        MakeApp = MakeApp + AppTarget % '\\tcp -p $(APPLICATION) $(APPFILE) '\n    MakeApp = MakeApp + '\\n'\n    IncludeFileFullPaths = []\n    for includefile in IncludeFiles:\n        for includepath in IncSearchList:\n            includefullpath = os.path.join(str(includepath), includefile)\n            if os.path.exists(includefullpath):\n                IncludeFileFullPaths.append(os.path.normpath(includefullpath))\n                break\n    SearchPathList = []\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Include')))\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Common')))\n    SearchPathList.extend((str(item) for item in IncSearchList))\n    IncFileList = GetDependencyList(IncludeFileFullPaths, SearchPathList)\n    for include_file in IncFileList:\n        MakeApp += '$(OBJECTS) : %s\\n' % include_file\n    if sys.platform == 'win32':\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source\\\\C\\\\Common\\\\PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s\\\\PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcopy /y %s $@\\n' % PcdValueCommonPath\n    else:\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source/C/Common/PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s/PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcp -p -f %s %s/PcdValueCommon.c\\n' % (PcdValueCommonPath, self.OutputPath)\n    MakeFileName = os.path.join(self.OutputPath, 'Makefile')\n    MakeApp += '$(OBJECTS) : %s\\n' % MakeFileName\n    SaveFileOnChange(MakeFileName, MakeApp, False)\n    InputValueFile = os.path.join(self.OutputPath, 'Input.txt')\n    OutputValueFile = os.path.join(self.OutputPath, 'Output.txt')\n    SaveFileOnChange(InputValueFile, InitByteValue, False)\n    Dest_PcdValueInitExe = PcdValueInitName\n    if not sys.platform == 'win32':\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName)\n    else:\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName) + '.exe'\n    Messages = ''\n    if sys.platform == 'win32':\n        MakeCommand = 'nmake -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdOut\n    else:\n        MakeCommand = 'make -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdErr\n    EdkLogger.verbose('%s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    Messages = Messages.split('\\n')\n    MessageGroup = []\n    if returncode != 0:\n        CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n        File = open(CAppBaseFileName + '.c', 'r')\n        FileData = File.readlines()\n        File.close()\n        for Message in Messages:\n            if ' error' in Message or 'warning' in Message:\n                try:\n                    FileInfo = Message.strip().split('(')\n                    if len(FileInfo) > 1:\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1].split(')')[0]\n                    else:\n                        FileInfo = Message.strip().split(':')\n                        if len(FileInfo) < 2:\n                            continue\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1]\n                except:\n                    continue\n                if 'PcdValueInit.c' not in FileName:\n                    continue\n                if FileLine.isdigit():\n                    error_line = FileData[int(FileLine) - 1]\n                    if '//' in error_line:\n                        (c_line, dsc_line) = error_line.split('//')\n                    else:\n                        dsc_line = error_line\n                    message_itmes = Message.split(':')\n                    Index = 0\n                    if 'PcdValueInit.c' not in Message:\n                        if not MessageGroup:\n                            MessageGroup.append(Message)\n                        break\n                    else:\n                        for item in message_itmes:\n                            if 'PcdValueInit.c' in item:\n                                Index = message_itmes.index(item)\n                                message_itmes[Index] = dsc_line.strip()\n                                break\n                        MessageGroup.append(':'.join(message_itmes[Index:]).strip())\n                        continue\n                else:\n                    MessageGroup.append(Message)\n        if MessageGroup:\n            EdkLogger.error('build', PCD_STRUCTURE_PCD_ERROR, '\\n'.join(MessageGroup))\n        else:\n            EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    if DscBuildData.NeedUpdateOutput(OutputValueFile, Dest_PcdValueInitExe, InputValueFile):\n        Command = Dest_PcdValueInitExe + ' -i %s -o %s' % (InputValueFile, OutputValueFile)\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(Command)\n        EdkLogger.verbose('%s\\n%s\\n%s' % (Command, StdOut, StdErr))\n        if returncode != 0:\n            EdkLogger.warn('Build', COMMAND_FAILURE, 'Can not collect output from command: %s\\n%s\\n%s\\n' % (Command, StdOut, StdErr))\n    File = open(OutputValueFile, 'r')\n    FileBuffer = File.readlines()\n    File.close()\n    StructurePcdSet = []\n    for Pcd in FileBuffer:\n        PcdValue = Pcd.split('|')\n        PcdInfo = PcdValue[0].split('.')\n        StructurePcdSet.append((PcdInfo[0], PcdInfo[1], PcdInfo[2], PcdInfo[3], PcdValue[2].strip()))\n    return StructurePcdSet",
        "mutated": [
            "def GenerateByteArrayValue(self, StructuredPcds):\n    if False:\n        i = 10\n    if not StructuredPcds:\n        return\n    InitByteValue = ''\n    CApp = PcdMainCHeader\n    IncludeFiles = set()\n    for PcdName in StructuredPcds:\n        Pcd = StructuredPcds[PcdName]\n        for IncludeFile in Pcd.StructuredPcdIncludeFile:\n            if IncludeFile not in IncludeFiles:\n                IncludeFiles.add(IncludeFile)\n                CApp = CApp + '#include <%s>\\n' % IncludeFile\n    CApp = CApp + '\\n'\n    for Pcd in StructuredPcds.values():\n        CApp = CApp + self.GenerateArrayAssignment(Pcd)\n    for PcdName in sorted(StructuredPcds.keys()):\n        Pcd = StructuredPcds[PcdName]\n        CApp = CApp + self.GenerateSizeFunction(Pcd)\n        CApp = CApp + self.GenerateDefaultValueAssignFunction(Pcd)\n        CApp = CApp + self.GenerateFdfValue(Pcd)\n        CApp = CApp + self.GenerateCommandLineValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + self.GenerateInitValueFunction(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + self.GenerateInitValueFunction(Pcd, SkuName, DefaultStoreName)\n        CApp = CApp + self.GenerateModuleScopeValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            (InitByteValue, CApp) = self.GenerateInitializeFunc(self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd, InitByteValue, CApp)\n            (InitByteValue, CApp) = self.GenerateModuleScopeInitializeFunc(self.SkuIdMgr.SystemSkuId, Pcd, InitByteValue, CApp)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.DefaultStoreName:\n                    Pcd = StructuredPcds[PcdName]\n                    (InitByteValue, CApp) = self.GenerateInitializeFunc(SkuName, DefaultStoreName, Pcd, InitByteValue, CApp)\n    CApp = CApp + 'VOID\\n'\n    CApp = CApp + 'PcdEntryPoint(\\n'\n    CApp = CApp + '  VOID\\n'\n    CApp = CApp + '  )\\n'\n    CApp = CApp + '{\\n'\n    for Pcd in StructuredPcds.values():\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n                CApp += '  Initialize_%s_%s_%s_%s();\\n' % (ModuleGuid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in self.SkuIdMgr.AvailableSkuIdSet:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    CApp = CApp + '}\\n'\n    CApp = CApp + PcdMainCEntry + '\\n'\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n    SaveFileOnChange(CAppBaseFileName + '.c', CApp, False)\n    MakeApp = PcdMakefileHeader\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + 'APPFILE = %s\\\\%s.exe\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s\\\\%s.obj %s.obj\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'INC = '\n    else:\n        MakeApp = MakeApp + PcdGccMakefile\n        MakeApp = MakeApp + 'APPFILE = %s/%s\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s/%s.o %s.o\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'include $(MAKEROOT)/Makefiles/app.makefile\\n' + 'TOOL_INCLUDE +='\n    IncSearchList = []\n    PlatformInc = OrderedDict()\n    for Cache in self._Bdb._CACHE_.values():\n        if Cache.MetaFile.Ext.lower() != '.dec':\n            continue\n        if Cache.Includes:\n            if str(Cache.MetaFile.Path) not in PlatformInc:\n                PlatformInc[str(Cache.MetaFile.Path)] = []\n                PlatformInc[str(Cache.MetaFile.Path)].append(os.path.dirname(Cache.MetaFile.Path))\n                PlatformInc[str(Cache.MetaFile.Path)].extend(Cache.CommonIncludes)\n    PcdDependDEC = []\n    for Pcd in StructuredPcds.values():\n        for PackageDec in Pcd.PackageDecs:\n            Package = os.path.normpath(mws.join(GlobalData.gWorkspace, PackageDec))\n            if not os.path.exists(Package):\n                EdkLogger.error('Build', RESOURCE_NOT_AVAILABLE, 'The dependent Package %s of PCD %s.%s is not exist.' % (PackageDec, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n            if Package not in PcdDependDEC:\n                PcdDependDEC.append(Package)\n    if PlatformInc and PcdDependDEC:\n        for pkg in PcdDependDEC:\n            if pkg in PlatformInc:\n                for inc in PlatformInc[pkg]:\n                    FileList = os.listdir(str(inc))\n                    if 'stdio.h' in FileList:\n                        continue\n                    if 'stdlib.h' in FileList:\n                        continue\n                    if 'string.h' in FileList:\n                        continue\n                    MakeApp += '-I' + str(inc) + ' '\n                    IncSearchList.append(inc)\n    MakeApp = MakeApp + '\\n'\n    CC_FLAGS = LinuxCFLAGS\n    if sys.platform == 'win32':\n        CC_FLAGS = WindowsCFLAGS\n    BuildOptions = OrderedDict()\n    for Options in self.BuildOptions:\n        if Options[2] != EDKII_NAME:\n            continue\n        Family = Options[0]\n        if Family and Family != self.ToolChainFamily:\n            continue\n        (Target, Tag, Arch, Tool, Attr) = Options[1].split('_')\n        if Tool != 'CC':\n            continue\n        if Attr != 'FLAGS':\n            continue\n        if Target == TAB_STAR or Target == self._Target:\n            if Tag == TAB_STAR or Tag == self._Toolchain:\n                if 'COMMON' not in BuildOptions:\n                    BuildOptions['COMMON'] = set()\n                if Arch == TAB_STAR:\n                    BuildOptions['COMMON'] |= self.ParseCCFlags(self.BuildOptions[Options])\n                if Arch in self.SupArchList:\n                    if Arch not in BuildOptions:\n                        BuildOptions[Arch] = set()\n                    BuildOptions[Arch] |= self.ParseCCFlags(self.BuildOptions[Options])\n    if BuildOptions:\n        ArchBuildOptions = {arch: flags for (arch, flags) in BuildOptions.items() if arch != 'COMMON'}\n        if len(ArchBuildOptions.keys()) == 1:\n            BuildOptions['COMMON'] |= list(ArchBuildOptions.values())[0]\n        elif len(ArchBuildOptions.keys()) > 1:\n            CommonBuildOptions = reduce(lambda x, y: x & y, ArchBuildOptions.values())\n            BuildOptions['COMMON'] |= CommonBuildOptions\n        ValueList = [item for item in BuildOptions['COMMON'] if item.startswith(('/U', '-U'))]\n        ValueList.extend([item for item in BuildOptions['COMMON'] if item.startswith(('/D', '-D'))])\n        CC_FLAGS += ' '.join(ValueList)\n    MakeApp += CC_FLAGS\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + PcdMakefileEnd\n        MakeApp = MakeApp + AppTarget % '\\tcopy $(APPLICATION) $(APPFILE) /y '\n    else:\n        MakeApp = MakeApp + AppTarget % '\\tcp -p $(APPLICATION) $(APPFILE) '\n    MakeApp = MakeApp + '\\n'\n    IncludeFileFullPaths = []\n    for includefile in IncludeFiles:\n        for includepath in IncSearchList:\n            includefullpath = os.path.join(str(includepath), includefile)\n            if os.path.exists(includefullpath):\n                IncludeFileFullPaths.append(os.path.normpath(includefullpath))\n                break\n    SearchPathList = []\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Include')))\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Common')))\n    SearchPathList.extend((str(item) for item in IncSearchList))\n    IncFileList = GetDependencyList(IncludeFileFullPaths, SearchPathList)\n    for include_file in IncFileList:\n        MakeApp += '$(OBJECTS) : %s\\n' % include_file\n    if sys.platform == 'win32':\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source\\\\C\\\\Common\\\\PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s\\\\PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcopy /y %s $@\\n' % PcdValueCommonPath\n    else:\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source/C/Common/PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s/PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcp -p -f %s %s/PcdValueCommon.c\\n' % (PcdValueCommonPath, self.OutputPath)\n    MakeFileName = os.path.join(self.OutputPath, 'Makefile')\n    MakeApp += '$(OBJECTS) : %s\\n' % MakeFileName\n    SaveFileOnChange(MakeFileName, MakeApp, False)\n    InputValueFile = os.path.join(self.OutputPath, 'Input.txt')\n    OutputValueFile = os.path.join(self.OutputPath, 'Output.txt')\n    SaveFileOnChange(InputValueFile, InitByteValue, False)\n    Dest_PcdValueInitExe = PcdValueInitName\n    if not sys.platform == 'win32':\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName)\n    else:\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName) + '.exe'\n    Messages = ''\n    if sys.platform == 'win32':\n        MakeCommand = 'nmake -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdOut\n    else:\n        MakeCommand = 'make -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdErr\n    EdkLogger.verbose('%s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    Messages = Messages.split('\\n')\n    MessageGroup = []\n    if returncode != 0:\n        CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n        File = open(CAppBaseFileName + '.c', 'r')\n        FileData = File.readlines()\n        File.close()\n        for Message in Messages:\n            if ' error' in Message or 'warning' in Message:\n                try:\n                    FileInfo = Message.strip().split('(')\n                    if len(FileInfo) > 1:\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1].split(')')[0]\n                    else:\n                        FileInfo = Message.strip().split(':')\n                        if len(FileInfo) < 2:\n                            continue\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1]\n                except:\n                    continue\n                if 'PcdValueInit.c' not in FileName:\n                    continue\n                if FileLine.isdigit():\n                    error_line = FileData[int(FileLine) - 1]\n                    if '//' in error_line:\n                        (c_line, dsc_line) = error_line.split('//')\n                    else:\n                        dsc_line = error_line\n                    message_itmes = Message.split(':')\n                    Index = 0\n                    if 'PcdValueInit.c' not in Message:\n                        if not MessageGroup:\n                            MessageGroup.append(Message)\n                        break\n                    else:\n                        for item in message_itmes:\n                            if 'PcdValueInit.c' in item:\n                                Index = message_itmes.index(item)\n                                message_itmes[Index] = dsc_line.strip()\n                                break\n                        MessageGroup.append(':'.join(message_itmes[Index:]).strip())\n                        continue\n                else:\n                    MessageGroup.append(Message)\n        if MessageGroup:\n            EdkLogger.error('build', PCD_STRUCTURE_PCD_ERROR, '\\n'.join(MessageGroup))\n        else:\n            EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    if DscBuildData.NeedUpdateOutput(OutputValueFile, Dest_PcdValueInitExe, InputValueFile):\n        Command = Dest_PcdValueInitExe + ' -i %s -o %s' % (InputValueFile, OutputValueFile)\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(Command)\n        EdkLogger.verbose('%s\\n%s\\n%s' % (Command, StdOut, StdErr))\n        if returncode != 0:\n            EdkLogger.warn('Build', COMMAND_FAILURE, 'Can not collect output from command: %s\\n%s\\n%s\\n' % (Command, StdOut, StdErr))\n    File = open(OutputValueFile, 'r')\n    FileBuffer = File.readlines()\n    File.close()\n    StructurePcdSet = []\n    for Pcd in FileBuffer:\n        PcdValue = Pcd.split('|')\n        PcdInfo = PcdValue[0].split('.')\n        StructurePcdSet.append((PcdInfo[0], PcdInfo[1], PcdInfo[2], PcdInfo[3], PcdValue[2].strip()))\n    return StructurePcdSet",
            "def GenerateByteArrayValue(self, StructuredPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not StructuredPcds:\n        return\n    InitByteValue = ''\n    CApp = PcdMainCHeader\n    IncludeFiles = set()\n    for PcdName in StructuredPcds:\n        Pcd = StructuredPcds[PcdName]\n        for IncludeFile in Pcd.StructuredPcdIncludeFile:\n            if IncludeFile not in IncludeFiles:\n                IncludeFiles.add(IncludeFile)\n                CApp = CApp + '#include <%s>\\n' % IncludeFile\n    CApp = CApp + '\\n'\n    for Pcd in StructuredPcds.values():\n        CApp = CApp + self.GenerateArrayAssignment(Pcd)\n    for PcdName in sorted(StructuredPcds.keys()):\n        Pcd = StructuredPcds[PcdName]\n        CApp = CApp + self.GenerateSizeFunction(Pcd)\n        CApp = CApp + self.GenerateDefaultValueAssignFunction(Pcd)\n        CApp = CApp + self.GenerateFdfValue(Pcd)\n        CApp = CApp + self.GenerateCommandLineValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + self.GenerateInitValueFunction(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + self.GenerateInitValueFunction(Pcd, SkuName, DefaultStoreName)\n        CApp = CApp + self.GenerateModuleScopeValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            (InitByteValue, CApp) = self.GenerateInitializeFunc(self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd, InitByteValue, CApp)\n            (InitByteValue, CApp) = self.GenerateModuleScopeInitializeFunc(self.SkuIdMgr.SystemSkuId, Pcd, InitByteValue, CApp)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.DefaultStoreName:\n                    Pcd = StructuredPcds[PcdName]\n                    (InitByteValue, CApp) = self.GenerateInitializeFunc(SkuName, DefaultStoreName, Pcd, InitByteValue, CApp)\n    CApp = CApp + 'VOID\\n'\n    CApp = CApp + 'PcdEntryPoint(\\n'\n    CApp = CApp + '  VOID\\n'\n    CApp = CApp + '  )\\n'\n    CApp = CApp + '{\\n'\n    for Pcd in StructuredPcds.values():\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n                CApp += '  Initialize_%s_%s_%s_%s();\\n' % (ModuleGuid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in self.SkuIdMgr.AvailableSkuIdSet:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    CApp = CApp + '}\\n'\n    CApp = CApp + PcdMainCEntry + '\\n'\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n    SaveFileOnChange(CAppBaseFileName + '.c', CApp, False)\n    MakeApp = PcdMakefileHeader\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + 'APPFILE = %s\\\\%s.exe\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s\\\\%s.obj %s.obj\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'INC = '\n    else:\n        MakeApp = MakeApp + PcdGccMakefile\n        MakeApp = MakeApp + 'APPFILE = %s/%s\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s/%s.o %s.o\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'include $(MAKEROOT)/Makefiles/app.makefile\\n' + 'TOOL_INCLUDE +='\n    IncSearchList = []\n    PlatformInc = OrderedDict()\n    for Cache in self._Bdb._CACHE_.values():\n        if Cache.MetaFile.Ext.lower() != '.dec':\n            continue\n        if Cache.Includes:\n            if str(Cache.MetaFile.Path) not in PlatformInc:\n                PlatformInc[str(Cache.MetaFile.Path)] = []\n                PlatformInc[str(Cache.MetaFile.Path)].append(os.path.dirname(Cache.MetaFile.Path))\n                PlatformInc[str(Cache.MetaFile.Path)].extend(Cache.CommonIncludes)\n    PcdDependDEC = []\n    for Pcd in StructuredPcds.values():\n        for PackageDec in Pcd.PackageDecs:\n            Package = os.path.normpath(mws.join(GlobalData.gWorkspace, PackageDec))\n            if not os.path.exists(Package):\n                EdkLogger.error('Build', RESOURCE_NOT_AVAILABLE, 'The dependent Package %s of PCD %s.%s is not exist.' % (PackageDec, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n            if Package not in PcdDependDEC:\n                PcdDependDEC.append(Package)\n    if PlatformInc and PcdDependDEC:\n        for pkg in PcdDependDEC:\n            if pkg in PlatformInc:\n                for inc in PlatformInc[pkg]:\n                    FileList = os.listdir(str(inc))\n                    if 'stdio.h' in FileList:\n                        continue\n                    if 'stdlib.h' in FileList:\n                        continue\n                    if 'string.h' in FileList:\n                        continue\n                    MakeApp += '-I' + str(inc) + ' '\n                    IncSearchList.append(inc)\n    MakeApp = MakeApp + '\\n'\n    CC_FLAGS = LinuxCFLAGS\n    if sys.platform == 'win32':\n        CC_FLAGS = WindowsCFLAGS\n    BuildOptions = OrderedDict()\n    for Options in self.BuildOptions:\n        if Options[2] != EDKII_NAME:\n            continue\n        Family = Options[0]\n        if Family and Family != self.ToolChainFamily:\n            continue\n        (Target, Tag, Arch, Tool, Attr) = Options[1].split('_')\n        if Tool != 'CC':\n            continue\n        if Attr != 'FLAGS':\n            continue\n        if Target == TAB_STAR or Target == self._Target:\n            if Tag == TAB_STAR or Tag == self._Toolchain:\n                if 'COMMON' not in BuildOptions:\n                    BuildOptions['COMMON'] = set()\n                if Arch == TAB_STAR:\n                    BuildOptions['COMMON'] |= self.ParseCCFlags(self.BuildOptions[Options])\n                if Arch in self.SupArchList:\n                    if Arch not in BuildOptions:\n                        BuildOptions[Arch] = set()\n                    BuildOptions[Arch] |= self.ParseCCFlags(self.BuildOptions[Options])\n    if BuildOptions:\n        ArchBuildOptions = {arch: flags for (arch, flags) in BuildOptions.items() if arch != 'COMMON'}\n        if len(ArchBuildOptions.keys()) == 1:\n            BuildOptions['COMMON'] |= list(ArchBuildOptions.values())[0]\n        elif len(ArchBuildOptions.keys()) > 1:\n            CommonBuildOptions = reduce(lambda x, y: x & y, ArchBuildOptions.values())\n            BuildOptions['COMMON'] |= CommonBuildOptions\n        ValueList = [item for item in BuildOptions['COMMON'] if item.startswith(('/U', '-U'))]\n        ValueList.extend([item for item in BuildOptions['COMMON'] if item.startswith(('/D', '-D'))])\n        CC_FLAGS += ' '.join(ValueList)\n    MakeApp += CC_FLAGS\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + PcdMakefileEnd\n        MakeApp = MakeApp + AppTarget % '\\tcopy $(APPLICATION) $(APPFILE) /y '\n    else:\n        MakeApp = MakeApp + AppTarget % '\\tcp -p $(APPLICATION) $(APPFILE) '\n    MakeApp = MakeApp + '\\n'\n    IncludeFileFullPaths = []\n    for includefile in IncludeFiles:\n        for includepath in IncSearchList:\n            includefullpath = os.path.join(str(includepath), includefile)\n            if os.path.exists(includefullpath):\n                IncludeFileFullPaths.append(os.path.normpath(includefullpath))\n                break\n    SearchPathList = []\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Include')))\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Common')))\n    SearchPathList.extend((str(item) for item in IncSearchList))\n    IncFileList = GetDependencyList(IncludeFileFullPaths, SearchPathList)\n    for include_file in IncFileList:\n        MakeApp += '$(OBJECTS) : %s\\n' % include_file\n    if sys.platform == 'win32':\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source\\\\C\\\\Common\\\\PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s\\\\PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcopy /y %s $@\\n' % PcdValueCommonPath\n    else:\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source/C/Common/PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s/PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcp -p -f %s %s/PcdValueCommon.c\\n' % (PcdValueCommonPath, self.OutputPath)\n    MakeFileName = os.path.join(self.OutputPath, 'Makefile')\n    MakeApp += '$(OBJECTS) : %s\\n' % MakeFileName\n    SaveFileOnChange(MakeFileName, MakeApp, False)\n    InputValueFile = os.path.join(self.OutputPath, 'Input.txt')\n    OutputValueFile = os.path.join(self.OutputPath, 'Output.txt')\n    SaveFileOnChange(InputValueFile, InitByteValue, False)\n    Dest_PcdValueInitExe = PcdValueInitName\n    if not sys.platform == 'win32':\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName)\n    else:\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName) + '.exe'\n    Messages = ''\n    if sys.platform == 'win32':\n        MakeCommand = 'nmake -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdOut\n    else:\n        MakeCommand = 'make -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdErr\n    EdkLogger.verbose('%s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    Messages = Messages.split('\\n')\n    MessageGroup = []\n    if returncode != 0:\n        CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n        File = open(CAppBaseFileName + '.c', 'r')\n        FileData = File.readlines()\n        File.close()\n        for Message in Messages:\n            if ' error' in Message or 'warning' in Message:\n                try:\n                    FileInfo = Message.strip().split('(')\n                    if len(FileInfo) > 1:\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1].split(')')[0]\n                    else:\n                        FileInfo = Message.strip().split(':')\n                        if len(FileInfo) < 2:\n                            continue\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1]\n                except:\n                    continue\n                if 'PcdValueInit.c' not in FileName:\n                    continue\n                if FileLine.isdigit():\n                    error_line = FileData[int(FileLine) - 1]\n                    if '//' in error_line:\n                        (c_line, dsc_line) = error_line.split('//')\n                    else:\n                        dsc_line = error_line\n                    message_itmes = Message.split(':')\n                    Index = 0\n                    if 'PcdValueInit.c' not in Message:\n                        if not MessageGroup:\n                            MessageGroup.append(Message)\n                        break\n                    else:\n                        for item in message_itmes:\n                            if 'PcdValueInit.c' in item:\n                                Index = message_itmes.index(item)\n                                message_itmes[Index] = dsc_line.strip()\n                                break\n                        MessageGroup.append(':'.join(message_itmes[Index:]).strip())\n                        continue\n                else:\n                    MessageGroup.append(Message)\n        if MessageGroup:\n            EdkLogger.error('build', PCD_STRUCTURE_PCD_ERROR, '\\n'.join(MessageGroup))\n        else:\n            EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    if DscBuildData.NeedUpdateOutput(OutputValueFile, Dest_PcdValueInitExe, InputValueFile):\n        Command = Dest_PcdValueInitExe + ' -i %s -o %s' % (InputValueFile, OutputValueFile)\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(Command)\n        EdkLogger.verbose('%s\\n%s\\n%s' % (Command, StdOut, StdErr))\n        if returncode != 0:\n            EdkLogger.warn('Build', COMMAND_FAILURE, 'Can not collect output from command: %s\\n%s\\n%s\\n' % (Command, StdOut, StdErr))\n    File = open(OutputValueFile, 'r')\n    FileBuffer = File.readlines()\n    File.close()\n    StructurePcdSet = []\n    for Pcd in FileBuffer:\n        PcdValue = Pcd.split('|')\n        PcdInfo = PcdValue[0].split('.')\n        StructurePcdSet.append((PcdInfo[0], PcdInfo[1], PcdInfo[2], PcdInfo[3], PcdValue[2].strip()))\n    return StructurePcdSet",
            "def GenerateByteArrayValue(self, StructuredPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not StructuredPcds:\n        return\n    InitByteValue = ''\n    CApp = PcdMainCHeader\n    IncludeFiles = set()\n    for PcdName in StructuredPcds:\n        Pcd = StructuredPcds[PcdName]\n        for IncludeFile in Pcd.StructuredPcdIncludeFile:\n            if IncludeFile not in IncludeFiles:\n                IncludeFiles.add(IncludeFile)\n                CApp = CApp + '#include <%s>\\n' % IncludeFile\n    CApp = CApp + '\\n'\n    for Pcd in StructuredPcds.values():\n        CApp = CApp + self.GenerateArrayAssignment(Pcd)\n    for PcdName in sorted(StructuredPcds.keys()):\n        Pcd = StructuredPcds[PcdName]\n        CApp = CApp + self.GenerateSizeFunction(Pcd)\n        CApp = CApp + self.GenerateDefaultValueAssignFunction(Pcd)\n        CApp = CApp + self.GenerateFdfValue(Pcd)\n        CApp = CApp + self.GenerateCommandLineValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + self.GenerateInitValueFunction(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + self.GenerateInitValueFunction(Pcd, SkuName, DefaultStoreName)\n        CApp = CApp + self.GenerateModuleScopeValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            (InitByteValue, CApp) = self.GenerateInitializeFunc(self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd, InitByteValue, CApp)\n            (InitByteValue, CApp) = self.GenerateModuleScopeInitializeFunc(self.SkuIdMgr.SystemSkuId, Pcd, InitByteValue, CApp)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.DefaultStoreName:\n                    Pcd = StructuredPcds[PcdName]\n                    (InitByteValue, CApp) = self.GenerateInitializeFunc(SkuName, DefaultStoreName, Pcd, InitByteValue, CApp)\n    CApp = CApp + 'VOID\\n'\n    CApp = CApp + 'PcdEntryPoint(\\n'\n    CApp = CApp + '  VOID\\n'\n    CApp = CApp + '  )\\n'\n    CApp = CApp + '{\\n'\n    for Pcd in StructuredPcds.values():\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n                CApp += '  Initialize_%s_%s_%s_%s();\\n' % (ModuleGuid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in self.SkuIdMgr.AvailableSkuIdSet:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    CApp = CApp + '}\\n'\n    CApp = CApp + PcdMainCEntry + '\\n'\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n    SaveFileOnChange(CAppBaseFileName + '.c', CApp, False)\n    MakeApp = PcdMakefileHeader\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + 'APPFILE = %s\\\\%s.exe\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s\\\\%s.obj %s.obj\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'INC = '\n    else:\n        MakeApp = MakeApp + PcdGccMakefile\n        MakeApp = MakeApp + 'APPFILE = %s/%s\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s/%s.o %s.o\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'include $(MAKEROOT)/Makefiles/app.makefile\\n' + 'TOOL_INCLUDE +='\n    IncSearchList = []\n    PlatformInc = OrderedDict()\n    for Cache in self._Bdb._CACHE_.values():\n        if Cache.MetaFile.Ext.lower() != '.dec':\n            continue\n        if Cache.Includes:\n            if str(Cache.MetaFile.Path) not in PlatformInc:\n                PlatformInc[str(Cache.MetaFile.Path)] = []\n                PlatformInc[str(Cache.MetaFile.Path)].append(os.path.dirname(Cache.MetaFile.Path))\n                PlatformInc[str(Cache.MetaFile.Path)].extend(Cache.CommonIncludes)\n    PcdDependDEC = []\n    for Pcd in StructuredPcds.values():\n        for PackageDec in Pcd.PackageDecs:\n            Package = os.path.normpath(mws.join(GlobalData.gWorkspace, PackageDec))\n            if not os.path.exists(Package):\n                EdkLogger.error('Build', RESOURCE_NOT_AVAILABLE, 'The dependent Package %s of PCD %s.%s is not exist.' % (PackageDec, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n            if Package not in PcdDependDEC:\n                PcdDependDEC.append(Package)\n    if PlatformInc and PcdDependDEC:\n        for pkg in PcdDependDEC:\n            if pkg in PlatformInc:\n                for inc in PlatformInc[pkg]:\n                    FileList = os.listdir(str(inc))\n                    if 'stdio.h' in FileList:\n                        continue\n                    if 'stdlib.h' in FileList:\n                        continue\n                    if 'string.h' in FileList:\n                        continue\n                    MakeApp += '-I' + str(inc) + ' '\n                    IncSearchList.append(inc)\n    MakeApp = MakeApp + '\\n'\n    CC_FLAGS = LinuxCFLAGS\n    if sys.platform == 'win32':\n        CC_FLAGS = WindowsCFLAGS\n    BuildOptions = OrderedDict()\n    for Options in self.BuildOptions:\n        if Options[2] != EDKII_NAME:\n            continue\n        Family = Options[0]\n        if Family and Family != self.ToolChainFamily:\n            continue\n        (Target, Tag, Arch, Tool, Attr) = Options[1].split('_')\n        if Tool != 'CC':\n            continue\n        if Attr != 'FLAGS':\n            continue\n        if Target == TAB_STAR or Target == self._Target:\n            if Tag == TAB_STAR or Tag == self._Toolchain:\n                if 'COMMON' not in BuildOptions:\n                    BuildOptions['COMMON'] = set()\n                if Arch == TAB_STAR:\n                    BuildOptions['COMMON'] |= self.ParseCCFlags(self.BuildOptions[Options])\n                if Arch in self.SupArchList:\n                    if Arch not in BuildOptions:\n                        BuildOptions[Arch] = set()\n                    BuildOptions[Arch] |= self.ParseCCFlags(self.BuildOptions[Options])\n    if BuildOptions:\n        ArchBuildOptions = {arch: flags for (arch, flags) in BuildOptions.items() if arch != 'COMMON'}\n        if len(ArchBuildOptions.keys()) == 1:\n            BuildOptions['COMMON'] |= list(ArchBuildOptions.values())[0]\n        elif len(ArchBuildOptions.keys()) > 1:\n            CommonBuildOptions = reduce(lambda x, y: x & y, ArchBuildOptions.values())\n            BuildOptions['COMMON'] |= CommonBuildOptions\n        ValueList = [item for item in BuildOptions['COMMON'] if item.startswith(('/U', '-U'))]\n        ValueList.extend([item for item in BuildOptions['COMMON'] if item.startswith(('/D', '-D'))])\n        CC_FLAGS += ' '.join(ValueList)\n    MakeApp += CC_FLAGS\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + PcdMakefileEnd\n        MakeApp = MakeApp + AppTarget % '\\tcopy $(APPLICATION) $(APPFILE) /y '\n    else:\n        MakeApp = MakeApp + AppTarget % '\\tcp -p $(APPLICATION) $(APPFILE) '\n    MakeApp = MakeApp + '\\n'\n    IncludeFileFullPaths = []\n    for includefile in IncludeFiles:\n        for includepath in IncSearchList:\n            includefullpath = os.path.join(str(includepath), includefile)\n            if os.path.exists(includefullpath):\n                IncludeFileFullPaths.append(os.path.normpath(includefullpath))\n                break\n    SearchPathList = []\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Include')))\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Common')))\n    SearchPathList.extend((str(item) for item in IncSearchList))\n    IncFileList = GetDependencyList(IncludeFileFullPaths, SearchPathList)\n    for include_file in IncFileList:\n        MakeApp += '$(OBJECTS) : %s\\n' % include_file\n    if sys.platform == 'win32':\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source\\\\C\\\\Common\\\\PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s\\\\PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcopy /y %s $@\\n' % PcdValueCommonPath\n    else:\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source/C/Common/PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s/PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcp -p -f %s %s/PcdValueCommon.c\\n' % (PcdValueCommonPath, self.OutputPath)\n    MakeFileName = os.path.join(self.OutputPath, 'Makefile')\n    MakeApp += '$(OBJECTS) : %s\\n' % MakeFileName\n    SaveFileOnChange(MakeFileName, MakeApp, False)\n    InputValueFile = os.path.join(self.OutputPath, 'Input.txt')\n    OutputValueFile = os.path.join(self.OutputPath, 'Output.txt')\n    SaveFileOnChange(InputValueFile, InitByteValue, False)\n    Dest_PcdValueInitExe = PcdValueInitName\n    if not sys.platform == 'win32':\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName)\n    else:\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName) + '.exe'\n    Messages = ''\n    if sys.platform == 'win32':\n        MakeCommand = 'nmake -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdOut\n    else:\n        MakeCommand = 'make -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdErr\n    EdkLogger.verbose('%s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    Messages = Messages.split('\\n')\n    MessageGroup = []\n    if returncode != 0:\n        CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n        File = open(CAppBaseFileName + '.c', 'r')\n        FileData = File.readlines()\n        File.close()\n        for Message in Messages:\n            if ' error' in Message or 'warning' in Message:\n                try:\n                    FileInfo = Message.strip().split('(')\n                    if len(FileInfo) > 1:\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1].split(')')[0]\n                    else:\n                        FileInfo = Message.strip().split(':')\n                        if len(FileInfo) < 2:\n                            continue\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1]\n                except:\n                    continue\n                if 'PcdValueInit.c' not in FileName:\n                    continue\n                if FileLine.isdigit():\n                    error_line = FileData[int(FileLine) - 1]\n                    if '//' in error_line:\n                        (c_line, dsc_line) = error_line.split('//')\n                    else:\n                        dsc_line = error_line\n                    message_itmes = Message.split(':')\n                    Index = 0\n                    if 'PcdValueInit.c' not in Message:\n                        if not MessageGroup:\n                            MessageGroup.append(Message)\n                        break\n                    else:\n                        for item in message_itmes:\n                            if 'PcdValueInit.c' in item:\n                                Index = message_itmes.index(item)\n                                message_itmes[Index] = dsc_line.strip()\n                                break\n                        MessageGroup.append(':'.join(message_itmes[Index:]).strip())\n                        continue\n                else:\n                    MessageGroup.append(Message)\n        if MessageGroup:\n            EdkLogger.error('build', PCD_STRUCTURE_PCD_ERROR, '\\n'.join(MessageGroup))\n        else:\n            EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    if DscBuildData.NeedUpdateOutput(OutputValueFile, Dest_PcdValueInitExe, InputValueFile):\n        Command = Dest_PcdValueInitExe + ' -i %s -o %s' % (InputValueFile, OutputValueFile)\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(Command)\n        EdkLogger.verbose('%s\\n%s\\n%s' % (Command, StdOut, StdErr))\n        if returncode != 0:\n            EdkLogger.warn('Build', COMMAND_FAILURE, 'Can not collect output from command: %s\\n%s\\n%s\\n' % (Command, StdOut, StdErr))\n    File = open(OutputValueFile, 'r')\n    FileBuffer = File.readlines()\n    File.close()\n    StructurePcdSet = []\n    for Pcd in FileBuffer:\n        PcdValue = Pcd.split('|')\n        PcdInfo = PcdValue[0].split('.')\n        StructurePcdSet.append((PcdInfo[0], PcdInfo[1], PcdInfo[2], PcdInfo[3], PcdValue[2].strip()))\n    return StructurePcdSet",
            "def GenerateByteArrayValue(self, StructuredPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not StructuredPcds:\n        return\n    InitByteValue = ''\n    CApp = PcdMainCHeader\n    IncludeFiles = set()\n    for PcdName in StructuredPcds:\n        Pcd = StructuredPcds[PcdName]\n        for IncludeFile in Pcd.StructuredPcdIncludeFile:\n            if IncludeFile not in IncludeFiles:\n                IncludeFiles.add(IncludeFile)\n                CApp = CApp + '#include <%s>\\n' % IncludeFile\n    CApp = CApp + '\\n'\n    for Pcd in StructuredPcds.values():\n        CApp = CApp + self.GenerateArrayAssignment(Pcd)\n    for PcdName in sorted(StructuredPcds.keys()):\n        Pcd = StructuredPcds[PcdName]\n        CApp = CApp + self.GenerateSizeFunction(Pcd)\n        CApp = CApp + self.GenerateDefaultValueAssignFunction(Pcd)\n        CApp = CApp + self.GenerateFdfValue(Pcd)\n        CApp = CApp + self.GenerateCommandLineValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + self.GenerateInitValueFunction(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + self.GenerateInitValueFunction(Pcd, SkuName, DefaultStoreName)\n        CApp = CApp + self.GenerateModuleScopeValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            (InitByteValue, CApp) = self.GenerateInitializeFunc(self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd, InitByteValue, CApp)\n            (InitByteValue, CApp) = self.GenerateModuleScopeInitializeFunc(self.SkuIdMgr.SystemSkuId, Pcd, InitByteValue, CApp)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.DefaultStoreName:\n                    Pcd = StructuredPcds[PcdName]\n                    (InitByteValue, CApp) = self.GenerateInitializeFunc(SkuName, DefaultStoreName, Pcd, InitByteValue, CApp)\n    CApp = CApp + 'VOID\\n'\n    CApp = CApp + 'PcdEntryPoint(\\n'\n    CApp = CApp + '  VOID\\n'\n    CApp = CApp + '  )\\n'\n    CApp = CApp + '{\\n'\n    for Pcd in StructuredPcds.values():\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n                CApp += '  Initialize_%s_%s_%s_%s();\\n' % (ModuleGuid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in self.SkuIdMgr.AvailableSkuIdSet:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    CApp = CApp + '}\\n'\n    CApp = CApp + PcdMainCEntry + '\\n'\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n    SaveFileOnChange(CAppBaseFileName + '.c', CApp, False)\n    MakeApp = PcdMakefileHeader\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + 'APPFILE = %s\\\\%s.exe\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s\\\\%s.obj %s.obj\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'INC = '\n    else:\n        MakeApp = MakeApp + PcdGccMakefile\n        MakeApp = MakeApp + 'APPFILE = %s/%s\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s/%s.o %s.o\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'include $(MAKEROOT)/Makefiles/app.makefile\\n' + 'TOOL_INCLUDE +='\n    IncSearchList = []\n    PlatformInc = OrderedDict()\n    for Cache in self._Bdb._CACHE_.values():\n        if Cache.MetaFile.Ext.lower() != '.dec':\n            continue\n        if Cache.Includes:\n            if str(Cache.MetaFile.Path) not in PlatformInc:\n                PlatformInc[str(Cache.MetaFile.Path)] = []\n                PlatformInc[str(Cache.MetaFile.Path)].append(os.path.dirname(Cache.MetaFile.Path))\n                PlatformInc[str(Cache.MetaFile.Path)].extend(Cache.CommonIncludes)\n    PcdDependDEC = []\n    for Pcd in StructuredPcds.values():\n        for PackageDec in Pcd.PackageDecs:\n            Package = os.path.normpath(mws.join(GlobalData.gWorkspace, PackageDec))\n            if not os.path.exists(Package):\n                EdkLogger.error('Build', RESOURCE_NOT_AVAILABLE, 'The dependent Package %s of PCD %s.%s is not exist.' % (PackageDec, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n            if Package not in PcdDependDEC:\n                PcdDependDEC.append(Package)\n    if PlatformInc and PcdDependDEC:\n        for pkg in PcdDependDEC:\n            if pkg in PlatformInc:\n                for inc in PlatformInc[pkg]:\n                    FileList = os.listdir(str(inc))\n                    if 'stdio.h' in FileList:\n                        continue\n                    if 'stdlib.h' in FileList:\n                        continue\n                    if 'string.h' in FileList:\n                        continue\n                    MakeApp += '-I' + str(inc) + ' '\n                    IncSearchList.append(inc)\n    MakeApp = MakeApp + '\\n'\n    CC_FLAGS = LinuxCFLAGS\n    if sys.platform == 'win32':\n        CC_FLAGS = WindowsCFLAGS\n    BuildOptions = OrderedDict()\n    for Options in self.BuildOptions:\n        if Options[2] != EDKII_NAME:\n            continue\n        Family = Options[0]\n        if Family and Family != self.ToolChainFamily:\n            continue\n        (Target, Tag, Arch, Tool, Attr) = Options[1].split('_')\n        if Tool != 'CC':\n            continue\n        if Attr != 'FLAGS':\n            continue\n        if Target == TAB_STAR or Target == self._Target:\n            if Tag == TAB_STAR or Tag == self._Toolchain:\n                if 'COMMON' not in BuildOptions:\n                    BuildOptions['COMMON'] = set()\n                if Arch == TAB_STAR:\n                    BuildOptions['COMMON'] |= self.ParseCCFlags(self.BuildOptions[Options])\n                if Arch in self.SupArchList:\n                    if Arch not in BuildOptions:\n                        BuildOptions[Arch] = set()\n                    BuildOptions[Arch] |= self.ParseCCFlags(self.BuildOptions[Options])\n    if BuildOptions:\n        ArchBuildOptions = {arch: flags for (arch, flags) in BuildOptions.items() if arch != 'COMMON'}\n        if len(ArchBuildOptions.keys()) == 1:\n            BuildOptions['COMMON'] |= list(ArchBuildOptions.values())[0]\n        elif len(ArchBuildOptions.keys()) > 1:\n            CommonBuildOptions = reduce(lambda x, y: x & y, ArchBuildOptions.values())\n            BuildOptions['COMMON'] |= CommonBuildOptions\n        ValueList = [item for item in BuildOptions['COMMON'] if item.startswith(('/U', '-U'))]\n        ValueList.extend([item for item in BuildOptions['COMMON'] if item.startswith(('/D', '-D'))])\n        CC_FLAGS += ' '.join(ValueList)\n    MakeApp += CC_FLAGS\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + PcdMakefileEnd\n        MakeApp = MakeApp + AppTarget % '\\tcopy $(APPLICATION) $(APPFILE) /y '\n    else:\n        MakeApp = MakeApp + AppTarget % '\\tcp -p $(APPLICATION) $(APPFILE) '\n    MakeApp = MakeApp + '\\n'\n    IncludeFileFullPaths = []\n    for includefile in IncludeFiles:\n        for includepath in IncSearchList:\n            includefullpath = os.path.join(str(includepath), includefile)\n            if os.path.exists(includefullpath):\n                IncludeFileFullPaths.append(os.path.normpath(includefullpath))\n                break\n    SearchPathList = []\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Include')))\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Common')))\n    SearchPathList.extend((str(item) for item in IncSearchList))\n    IncFileList = GetDependencyList(IncludeFileFullPaths, SearchPathList)\n    for include_file in IncFileList:\n        MakeApp += '$(OBJECTS) : %s\\n' % include_file\n    if sys.platform == 'win32':\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source\\\\C\\\\Common\\\\PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s\\\\PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcopy /y %s $@\\n' % PcdValueCommonPath\n    else:\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source/C/Common/PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s/PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcp -p -f %s %s/PcdValueCommon.c\\n' % (PcdValueCommonPath, self.OutputPath)\n    MakeFileName = os.path.join(self.OutputPath, 'Makefile')\n    MakeApp += '$(OBJECTS) : %s\\n' % MakeFileName\n    SaveFileOnChange(MakeFileName, MakeApp, False)\n    InputValueFile = os.path.join(self.OutputPath, 'Input.txt')\n    OutputValueFile = os.path.join(self.OutputPath, 'Output.txt')\n    SaveFileOnChange(InputValueFile, InitByteValue, False)\n    Dest_PcdValueInitExe = PcdValueInitName\n    if not sys.platform == 'win32':\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName)\n    else:\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName) + '.exe'\n    Messages = ''\n    if sys.platform == 'win32':\n        MakeCommand = 'nmake -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdOut\n    else:\n        MakeCommand = 'make -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdErr\n    EdkLogger.verbose('%s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    Messages = Messages.split('\\n')\n    MessageGroup = []\n    if returncode != 0:\n        CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n        File = open(CAppBaseFileName + '.c', 'r')\n        FileData = File.readlines()\n        File.close()\n        for Message in Messages:\n            if ' error' in Message or 'warning' in Message:\n                try:\n                    FileInfo = Message.strip().split('(')\n                    if len(FileInfo) > 1:\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1].split(')')[0]\n                    else:\n                        FileInfo = Message.strip().split(':')\n                        if len(FileInfo) < 2:\n                            continue\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1]\n                except:\n                    continue\n                if 'PcdValueInit.c' not in FileName:\n                    continue\n                if FileLine.isdigit():\n                    error_line = FileData[int(FileLine) - 1]\n                    if '//' in error_line:\n                        (c_line, dsc_line) = error_line.split('//')\n                    else:\n                        dsc_line = error_line\n                    message_itmes = Message.split(':')\n                    Index = 0\n                    if 'PcdValueInit.c' not in Message:\n                        if not MessageGroup:\n                            MessageGroup.append(Message)\n                        break\n                    else:\n                        for item in message_itmes:\n                            if 'PcdValueInit.c' in item:\n                                Index = message_itmes.index(item)\n                                message_itmes[Index] = dsc_line.strip()\n                                break\n                        MessageGroup.append(':'.join(message_itmes[Index:]).strip())\n                        continue\n                else:\n                    MessageGroup.append(Message)\n        if MessageGroup:\n            EdkLogger.error('build', PCD_STRUCTURE_PCD_ERROR, '\\n'.join(MessageGroup))\n        else:\n            EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    if DscBuildData.NeedUpdateOutput(OutputValueFile, Dest_PcdValueInitExe, InputValueFile):\n        Command = Dest_PcdValueInitExe + ' -i %s -o %s' % (InputValueFile, OutputValueFile)\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(Command)\n        EdkLogger.verbose('%s\\n%s\\n%s' % (Command, StdOut, StdErr))\n        if returncode != 0:\n            EdkLogger.warn('Build', COMMAND_FAILURE, 'Can not collect output from command: %s\\n%s\\n%s\\n' % (Command, StdOut, StdErr))\n    File = open(OutputValueFile, 'r')\n    FileBuffer = File.readlines()\n    File.close()\n    StructurePcdSet = []\n    for Pcd in FileBuffer:\n        PcdValue = Pcd.split('|')\n        PcdInfo = PcdValue[0].split('.')\n        StructurePcdSet.append((PcdInfo[0], PcdInfo[1], PcdInfo[2], PcdInfo[3], PcdValue[2].strip()))\n    return StructurePcdSet",
            "def GenerateByteArrayValue(self, StructuredPcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not StructuredPcds:\n        return\n    InitByteValue = ''\n    CApp = PcdMainCHeader\n    IncludeFiles = set()\n    for PcdName in StructuredPcds:\n        Pcd = StructuredPcds[PcdName]\n        for IncludeFile in Pcd.StructuredPcdIncludeFile:\n            if IncludeFile not in IncludeFiles:\n                IncludeFiles.add(IncludeFile)\n                CApp = CApp + '#include <%s>\\n' % IncludeFile\n    CApp = CApp + '\\n'\n    for Pcd in StructuredPcds.values():\n        CApp = CApp + self.GenerateArrayAssignment(Pcd)\n    for PcdName in sorted(StructuredPcds.keys()):\n        Pcd = StructuredPcds[PcdName]\n        CApp = CApp + self.GenerateSizeFunction(Pcd)\n        CApp = CApp + self.GenerateDefaultValueAssignFunction(Pcd)\n        CApp = CApp + self.GenerateFdfValue(Pcd)\n        CApp = CApp + self.GenerateCommandLineValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + self.GenerateInitValueFunction(Pcd, self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + self.GenerateInitValueFunction(Pcd, SkuName, DefaultStoreName)\n        CApp = CApp + self.GenerateModuleScopeValue(Pcd)\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            (InitByteValue, CApp) = self.GenerateInitializeFunc(self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd, InitByteValue, CApp)\n            (InitByteValue, CApp) = self.GenerateModuleScopeInitializeFunc(self.SkuIdMgr.SystemSkuId, Pcd, InitByteValue, CApp)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in Pcd.SkuOverrideValues:\n                    continue\n                for DefaultStoreName in Pcd.DefaultStoreName:\n                    Pcd = StructuredPcds[PcdName]\n                    (InitByteValue, CApp) = self.GenerateInitializeFunc(SkuName, DefaultStoreName, Pcd, InitByteValue, CApp)\n    CApp = CApp + 'VOID\\n'\n    CApp = CApp + 'PcdEntryPoint(\\n'\n    CApp = CApp + '  VOID\\n'\n    CApp = CApp + '  )\\n'\n    CApp = CApp + '{\\n'\n    for Pcd in StructuredPcds.values():\n        if self.SkuOverrideValuesEmpty(Pcd.SkuOverrideValues) or Pcd.Type in [self._PCD_TYPE_STRING_[MODEL_PCD_FIXED_AT_BUILD], self._PCD_TYPE_STRING_[MODEL_PCD_PATCHABLE_IN_MODULE]]:\n            CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (self.SkuIdMgr.SystemSkuId, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n            for ModuleGuid in Pcd.PcdFiledValueFromDscComponent:\n                CApp += '  Initialize_%s_%s_%s_%s();\\n' % (ModuleGuid, TAB_DEFAULT_STORES_DEFAULT, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n        else:\n            for SkuName in self.SkuIdMgr.SkuOverrideOrder():\n                if SkuName not in self.SkuIdMgr.AvailableSkuIdSet:\n                    continue\n                for DefaultStoreName in Pcd.SkuOverrideValues[SkuName]:\n                    CApp = CApp + '  Initialize_%s_%s_%s_%s();\\n' % (SkuName, DefaultStoreName, Pcd.TokenSpaceGuidCName, Pcd.TokenCName)\n    CApp = CApp + '}\\n'\n    CApp = CApp + PcdMainCEntry + '\\n'\n    if not os.path.exists(self.OutputPath):\n        os.makedirs(self.OutputPath)\n    CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n    SaveFileOnChange(CAppBaseFileName + '.c', CApp, False)\n    MakeApp = PcdMakefileHeader\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + 'APPFILE = %s\\\\%s.exe\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s\\\\%s.obj %s.obj\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'INC = '\n    else:\n        MakeApp = MakeApp + PcdGccMakefile\n        MakeApp = MakeApp + 'APPFILE = %s/%s\\n' % (self.OutputPath, PcdValueInitName) + 'APPNAME = %s\\n' % PcdValueInitName + 'OBJECTS = %s/%s.o %s.o\\n' % (self.OutputPath, PcdValueInitName, os.path.join(self.OutputPath, PcdValueCommonName)) + 'include $(MAKEROOT)/Makefiles/app.makefile\\n' + 'TOOL_INCLUDE +='\n    IncSearchList = []\n    PlatformInc = OrderedDict()\n    for Cache in self._Bdb._CACHE_.values():\n        if Cache.MetaFile.Ext.lower() != '.dec':\n            continue\n        if Cache.Includes:\n            if str(Cache.MetaFile.Path) not in PlatformInc:\n                PlatformInc[str(Cache.MetaFile.Path)] = []\n                PlatformInc[str(Cache.MetaFile.Path)].append(os.path.dirname(Cache.MetaFile.Path))\n                PlatformInc[str(Cache.MetaFile.Path)].extend(Cache.CommonIncludes)\n    PcdDependDEC = []\n    for Pcd in StructuredPcds.values():\n        for PackageDec in Pcd.PackageDecs:\n            Package = os.path.normpath(mws.join(GlobalData.gWorkspace, PackageDec))\n            if not os.path.exists(Package):\n                EdkLogger.error('Build', RESOURCE_NOT_AVAILABLE, 'The dependent Package %s of PCD %s.%s is not exist.' % (PackageDec, Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n            if Package not in PcdDependDEC:\n                PcdDependDEC.append(Package)\n    if PlatformInc and PcdDependDEC:\n        for pkg in PcdDependDEC:\n            if pkg in PlatformInc:\n                for inc in PlatformInc[pkg]:\n                    FileList = os.listdir(str(inc))\n                    if 'stdio.h' in FileList:\n                        continue\n                    if 'stdlib.h' in FileList:\n                        continue\n                    if 'string.h' in FileList:\n                        continue\n                    MakeApp += '-I' + str(inc) + ' '\n                    IncSearchList.append(inc)\n    MakeApp = MakeApp + '\\n'\n    CC_FLAGS = LinuxCFLAGS\n    if sys.platform == 'win32':\n        CC_FLAGS = WindowsCFLAGS\n    BuildOptions = OrderedDict()\n    for Options in self.BuildOptions:\n        if Options[2] != EDKII_NAME:\n            continue\n        Family = Options[0]\n        if Family and Family != self.ToolChainFamily:\n            continue\n        (Target, Tag, Arch, Tool, Attr) = Options[1].split('_')\n        if Tool != 'CC':\n            continue\n        if Attr != 'FLAGS':\n            continue\n        if Target == TAB_STAR or Target == self._Target:\n            if Tag == TAB_STAR or Tag == self._Toolchain:\n                if 'COMMON' not in BuildOptions:\n                    BuildOptions['COMMON'] = set()\n                if Arch == TAB_STAR:\n                    BuildOptions['COMMON'] |= self.ParseCCFlags(self.BuildOptions[Options])\n                if Arch in self.SupArchList:\n                    if Arch not in BuildOptions:\n                        BuildOptions[Arch] = set()\n                    BuildOptions[Arch] |= self.ParseCCFlags(self.BuildOptions[Options])\n    if BuildOptions:\n        ArchBuildOptions = {arch: flags for (arch, flags) in BuildOptions.items() if arch != 'COMMON'}\n        if len(ArchBuildOptions.keys()) == 1:\n            BuildOptions['COMMON'] |= list(ArchBuildOptions.values())[0]\n        elif len(ArchBuildOptions.keys()) > 1:\n            CommonBuildOptions = reduce(lambda x, y: x & y, ArchBuildOptions.values())\n            BuildOptions['COMMON'] |= CommonBuildOptions\n        ValueList = [item for item in BuildOptions['COMMON'] if item.startswith(('/U', '-U'))]\n        ValueList.extend([item for item in BuildOptions['COMMON'] if item.startswith(('/D', '-D'))])\n        CC_FLAGS += ' '.join(ValueList)\n    MakeApp += CC_FLAGS\n    if sys.platform == 'win32':\n        MakeApp = MakeApp + PcdMakefileEnd\n        MakeApp = MakeApp + AppTarget % '\\tcopy $(APPLICATION) $(APPFILE) /y '\n    else:\n        MakeApp = MakeApp + AppTarget % '\\tcp -p $(APPLICATION) $(APPFILE) '\n    MakeApp = MakeApp + '\\n'\n    IncludeFileFullPaths = []\n    for includefile in IncludeFiles:\n        for includepath in IncSearchList:\n            includefullpath = os.path.join(str(includepath), includefile)\n            if os.path.exists(includefullpath):\n                IncludeFileFullPaths.append(os.path.normpath(includefullpath))\n                break\n    SearchPathList = []\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Include')))\n    SearchPathList.append(os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'BaseTools/Source/C/Common')))\n    SearchPathList.extend((str(item) for item in IncSearchList))\n    IncFileList = GetDependencyList(IncludeFileFullPaths, SearchPathList)\n    for include_file in IncFileList:\n        MakeApp += '$(OBJECTS) : %s\\n' % include_file\n    if sys.platform == 'win32':\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source\\\\C\\\\Common\\\\PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s\\\\PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcopy /y %s $@\\n' % PcdValueCommonPath\n    else:\n        PcdValueCommonPath = os.path.normpath(mws.join(GlobalData.gGlobalDefines['EDK_TOOLS_PATH'], 'Source/C/Common/PcdValueCommon.c'))\n        MakeApp = MakeApp + '%s/PcdValueCommon.c : %s\\n' % (self.OutputPath, PcdValueCommonPath)\n        MakeApp = MakeApp + '\\tcp -p -f %s %s/PcdValueCommon.c\\n' % (PcdValueCommonPath, self.OutputPath)\n    MakeFileName = os.path.join(self.OutputPath, 'Makefile')\n    MakeApp += '$(OBJECTS) : %s\\n' % MakeFileName\n    SaveFileOnChange(MakeFileName, MakeApp, False)\n    InputValueFile = os.path.join(self.OutputPath, 'Input.txt')\n    OutputValueFile = os.path.join(self.OutputPath, 'Output.txt')\n    SaveFileOnChange(InputValueFile, InitByteValue, False)\n    Dest_PcdValueInitExe = PcdValueInitName\n    if not sys.platform == 'win32':\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName)\n    else:\n        Dest_PcdValueInitExe = os.path.join(self.OutputPath, PcdValueInitName) + '.exe'\n    Messages = ''\n    if sys.platform == 'win32':\n        MakeCommand = 'nmake -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdOut\n    else:\n        MakeCommand = 'make -f %s' % MakeFileName\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(MakeCommand)\n        Messages = StdErr\n    EdkLogger.verbose('%s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    Messages = Messages.split('\\n')\n    MessageGroup = []\n    if returncode != 0:\n        CAppBaseFileName = os.path.join(self.OutputPath, PcdValueInitName)\n        File = open(CAppBaseFileName + '.c', 'r')\n        FileData = File.readlines()\n        File.close()\n        for Message in Messages:\n            if ' error' in Message or 'warning' in Message:\n                try:\n                    FileInfo = Message.strip().split('(')\n                    if len(FileInfo) > 1:\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1].split(')')[0]\n                    else:\n                        FileInfo = Message.strip().split(':')\n                        if len(FileInfo) < 2:\n                            continue\n                        FileName = FileInfo[0]\n                        FileLine = FileInfo[1]\n                except:\n                    continue\n                if 'PcdValueInit.c' not in FileName:\n                    continue\n                if FileLine.isdigit():\n                    error_line = FileData[int(FileLine) - 1]\n                    if '//' in error_line:\n                        (c_line, dsc_line) = error_line.split('//')\n                    else:\n                        dsc_line = error_line\n                    message_itmes = Message.split(':')\n                    Index = 0\n                    if 'PcdValueInit.c' not in Message:\n                        if not MessageGroup:\n                            MessageGroup.append(Message)\n                        break\n                    else:\n                        for item in message_itmes:\n                            if 'PcdValueInit.c' in item:\n                                Index = message_itmes.index(item)\n                                message_itmes[Index] = dsc_line.strip()\n                                break\n                        MessageGroup.append(':'.join(message_itmes[Index:]).strip())\n                        continue\n                else:\n                    MessageGroup.append(Message)\n        if MessageGroup:\n            EdkLogger.error('build', PCD_STRUCTURE_PCD_ERROR, '\\n'.join(MessageGroup))\n        else:\n            EdkLogger.error('Build', COMMAND_FAILURE, 'Can not execute command: %s\\n%s\\n%s' % (MakeCommand, StdOut, StdErr))\n    if DscBuildData.NeedUpdateOutput(OutputValueFile, Dest_PcdValueInitExe, InputValueFile):\n        Command = Dest_PcdValueInitExe + ' -i %s -o %s' % (InputValueFile, OutputValueFile)\n        (returncode, StdOut, StdErr) = DscBuildData.ExecuteCommand(Command)\n        EdkLogger.verbose('%s\\n%s\\n%s' % (Command, StdOut, StdErr))\n        if returncode != 0:\n            EdkLogger.warn('Build', COMMAND_FAILURE, 'Can not collect output from command: %s\\n%s\\n%s\\n' % (Command, StdOut, StdErr))\n    File = open(OutputValueFile, 'r')\n    FileBuffer = File.readlines()\n    File.close()\n    StructurePcdSet = []\n    for Pcd in FileBuffer:\n        PcdValue = Pcd.split('|')\n        PcdInfo = PcdValue[0].split('.')\n        StructurePcdSet.append((PcdInfo[0], PcdInfo[1], PcdInfo[2], PcdInfo[3], PcdValue[2].strip()))\n    return StructurePcdSet"
        ]
    },
    {
        "func_name": "NeedUpdateOutput",
        "original": "@staticmethod\ndef NeedUpdateOutput(OutputFile, ValueCFile, StructureInput):\n    if not os.path.exists(OutputFile):\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(ValueCFile).st_mtime:\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(StructureInput).st_mtime:\n        return True\n    return False",
        "mutated": [
            "@staticmethod\ndef NeedUpdateOutput(OutputFile, ValueCFile, StructureInput):\n    if False:\n        i = 10\n    if not os.path.exists(OutputFile):\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(ValueCFile).st_mtime:\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(StructureInput).st_mtime:\n        return True\n    return False",
            "@staticmethod\ndef NeedUpdateOutput(OutputFile, ValueCFile, StructureInput):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not os.path.exists(OutputFile):\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(ValueCFile).st_mtime:\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(StructureInput).st_mtime:\n        return True\n    return False",
            "@staticmethod\ndef NeedUpdateOutput(OutputFile, ValueCFile, StructureInput):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not os.path.exists(OutputFile):\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(ValueCFile).st_mtime:\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(StructureInput).st_mtime:\n        return True\n    return False",
            "@staticmethod\ndef NeedUpdateOutput(OutputFile, ValueCFile, StructureInput):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not os.path.exists(OutputFile):\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(ValueCFile).st_mtime:\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(StructureInput).st_mtime:\n        return True\n    return False",
            "@staticmethod\ndef NeedUpdateOutput(OutputFile, ValueCFile, StructureInput):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not os.path.exists(OutputFile):\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(ValueCFile).st_mtime:\n        return True\n    if os.stat(OutputFile).st_mtime <= os.stat(StructureInput).st_mtime:\n        return True\n    return False"
        ]
    },
    {
        "func_name": "_GetDynamicPcd",
        "original": "def _GetDynamicPcd(self, Type):\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', '', PcdValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = PcdValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', '', valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
        "mutated": [
            "def _GetDynamicPcd(self, Type):\n    if False:\n        i = 10\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', '', PcdValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = PcdValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', '', valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', '', PcdValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = PcdValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', '', valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', '', PcdValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = PcdValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', '', valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', '', PcdValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = PcdValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', '', valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (PcdValue, DatumType, MaxDatumSize) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', '', PcdValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], DatumType, PcdValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = PcdValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', '', valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds"
        ]
    },
    {
        "func_name": "FilterSkuSettings",
        "original": "def FilterSkuSettings(self, PcdObj):\n    if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE:\n        if TAB_DEFAULT in PcdObj.SkuInfoList and self.SkuIdMgr.SystemSkuId not in PcdObj.SkuInfoList:\n            PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId] = PcdObj.SkuInfoList[TAB_DEFAULT]\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId]}\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuIdName = TAB_DEFAULT\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuId = '0'\n    elif self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.DEFAULT:\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[TAB_DEFAULT]}\n    return PcdObj",
        "mutated": [
            "def FilterSkuSettings(self, PcdObj):\n    if False:\n        i = 10\n    if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE:\n        if TAB_DEFAULT in PcdObj.SkuInfoList and self.SkuIdMgr.SystemSkuId not in PcdObj.SkuInfoList:\n            PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId] = PcdObj.SkuInfoList[TAB_DEFAULT]\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId]}\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuIdName = TAB_DEFAULT\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuId = '0'\n    elif self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.DEFAULT:\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[TAB_DEFAULT]}\n    return PcdObj",
            "def FilterSkuSettings(self, PcdObj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE:\n        if TAB_DEFAULT in PcdObj.SkuInfoList and self.SkuIdMgr.SystemSkuId not in PcdObj.SkuInfoList:\n            PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId] = PcdObj.SkuInfoList[TAB_DEFAULT]\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId]}\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuIdName = TAB_DEFAULT\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuId = '0'\n    elif self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.DEFAULT:\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[TAB_DEFAULT]}\n    return PcdObj",
            "def FilterSkuSettings(self, PcdObj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE:\n        if TAB_DEFAULT in PcdObj.SkuInfoList and self.SkuIdMgr.SystemSkuId not in PcdObj.SkuInfoList:\n            PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId] = PcdObj.SkuInfoList[TAB_DEFAULT]\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId]}\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuIdName = TAB_DEFAULT\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuId = '0'\n    elif self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.DEFAULT:\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[TAB_DEFAULT]}\n    return PcdObj",
            "def FilterSkuSettings(self, PcdObj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE:\n        if TAB_DEFAULT in PcdObj.SkuInfoList and self.SkuIdMgr.SystemSkuId not in PcdObj.SkuInfoList:\n            PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId] = PcdObj.SkuInfoList[TAB_DEFAULT]\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId]}\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuIdName = TAB_DEFAULT\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuId = '0'\n    elif self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.DEFAULT:\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[TAB_DEFAULT]}\n    return PcdObj",
            "def FilterSkuSettings(self, PcdObj):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE:\n        if TAB_DEFAULT in PcdObj.SkuInfoList and self.SkuIdMgr.SystemSkuId not in PcdObj.SkuInfoList:\n            PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId] = PcdObj.SkuInfoList[TAB_DEFAULT]\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[self.SkuIdMgr.SystemSkuId]}\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuIdName = TAB_DEFAULT\n        PcdObj.SkuInfoList[TAB_DEFAULT].SkuId = '0'\n    elif self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.DEFAULT:\n        PcdObj.SkuInfoList = {TAB_DEFAULT: PcdObj.SkuInfoList[TAB_DEFAULT]}\n    return PcdObj"
        ]
    },
    {
        "func_name": "CompareVarAttr",
        "original": "@staticmethod\ndef CompareVarAttr(Attr1, Attr2):\n    if not Attr1 or not Attr2:\n        return True\n    Attr1s = [attr.strip() for attr in Attr1.split(',')]\n    Attr1Set = set(Attr1s)\n    Attr2s = [attr.strip() for attr in Attr2.split(',')]\n    Attr2Set = set(Attr2s)\n    if Attr2Set == Attr1Set:\n        return True\n    else:\n        return False",
        "mutated": [
            "@staticmethod\ndef CompareVarAttr(Attr1, Attr2):\n    if False:\n        i = 10\n    if not Attr1 or not Attr2:\n        return True\n    Attr1s = [attr.strip() for attr in Attr1.split(',')]\n    Attr1Set = set(Attr1s)\n    Attr2s = [attr.strip() for attr in Attr2.split(',')]\n    Attr2Set = set(Attr2s)\n    if Attr2Set == Attr1Set:\n        return True\n    else:\n        return False",
            "@staticmethod\ndef CompareVarAttr(Attr1, Attr2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not Attr1 or not Attr2:\n        return True\n    Attr1s = [attr.strip() for attr in Attr1.split(',')]\n    Attr1Set = set(Attr1s)\n    Attr2s = [attr.strip() for attr in Attr2.split(',')]\n    Attr2Set = set(Attr2s)\n    if Attr2Set == Attr1Set:\n        return True\n    else:\n        return False",
            "@staticmethod\ndef CompareVarAttr(Attr1, Attr2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not Attr1 or not Attr2:\n        return True\n    Attr1s = [attr.strip() for attr in Attr1.split(',')]\n    Attr1Set = set(Attr1s)\n    Attr2s = [attr.strip() for attr in Attr2.split(',')]\n    Attr2Set = set(Attr2s)\n    if Attr2Set == Attr1Set:\n        return True\n    else:\n        return False",
            "@staticmethod\ndef CompareVarAttr(Attr1, Attr2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not Attr1 or not Attr2:\n        return True\n    Attr1s = [attr.strip() for attr in Attr1.split(',')]\n    Attr1Set = set(Attr1s)\n    Attr2s = [attr.strip() for attr in Attr2.split(',')]\n    Attr2Set = set(Attr2s)\n    if Attr2Set == Attr1Set:\n        return True\n    else:\n        return False",
            "@staticmethod\ndef CompareVarAttr(Attr1, Attr2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not Attr1 or not Attr2:\n        return True\n    Attr1s = [attr.strip() for attr in Attr1.split(',')]\n    Attr1Set = set(Attr1s)\n    Attr2s = [attr.strip() for attr in Attr2.split(',')]\n    Attr2Set = set(Attr2s)\n    if Attr2Set == Attr1Set:\n        return True\n    else:\n        return False"
        ]
    },
    {
        "func_name": "CompletePcdValues",
        "original": "def CompletePcdValues(self, PcdSet):\n    Pcds = OrderedDict()\n    DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n    SkuIds = {skuname: skuid for (skuname, skuid) in self.SkuIdMgr.AvailableSkuIdSet.items() if skuname != TAB_COMMON}\n    DefaultStores = set((storename for pcdobj in PcdSet.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict))\n    for (PcdCName, TokenSpaceGuid) in PcdSet:\n        PcdObj = PcdSet[PcdCName, TokenSpaceGuid]\n        if PcdObj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n            continue\n        PcdType = PcdObj.Type\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in PcdObj.SkuInfoList:\n                skuobj = PcdObj.SkuInfoList[skuid]\n                mindefaultstorename = DefaultStoreObj.GetMin(set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict)))\n                for defaultstorename in DefaultStores:\n                    if defaultstorename not in skuobj.DefaultStoreDict:\n                        skuobj.DefaultStoreDict[defaultstorename] = skuobj.DefaultStoreDict[mindefaultstorename]\n                skuobj.HiiDefaultValue = skuobj.DefaultStoreDict[mindefaultstorename]\n        for (skuname, skuid) in SkuIds.items():\n            if skuname not in PcdObj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                while nextskuid not in PcdObj.SkuInfoList:\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                PcdObj.SkuInfoList[skuname] = copy.deepcopy(PcdObj.SkuInfoList[nextskuid])\n                PcdObj.SkuInfoList[skuname].SkuId = skuid\n                PcdObj.SkuInfoList[skuname].SkuIdName = skuname\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            PcdObj.DefaultValue = list(PcdObj.SkuInfoList.values())[0].HiiDefaultValue if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE else PcdObj.SkuInfoList[TAB_DEFAULT].HiiDefaultValue\n        Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n    return Pcds",
        "mutated": [
            "def CompletePcdValues(self, PcdSet):\n    if False:\n        i = 10\n    Pcds = OrderedDict()\n    DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n    SkuIds = {skuname: skuid for (skuname, skuid) in self.SkuIdMgr.AvailableSkuIdSet.items() if skuname != TAB_COMMON}\n    DefaultStores = set((storename for pcdobj in PcdSet.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict))\n    for (PcdCName, TokenSpaceGuid) in PcdSet:\n        PcdObj = PcdSet[PcdCName, TokenSpaceGuid]\n        if PcdObj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n            continue\n        PcdType = PcdObj.Type\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in PcdObj.SkuInfoList:\n                skuobj = PcdObj.SkuInfoList[skuid]\n                mindefaultstorename = DefaultStoreObj.GetMin(set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict)))\n                for defaultstorename in DefaultStores:\n                    if defaultstorename not in skuobj.DefaultStoreDict:\n                        skuobj.DefaultStoreDict[defaultstorename] = skuobj.DefaultStoreDict[mindefaultstorename]\n                skuobj.HiiDefaultValue = skuobj.DefaultStoreDict[mindefaultstorename]\n        for (skuname, skuid) in SkuIds.items():\n            if skuname not in PcdObj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                while nextskuid not in PcdObj.SkuInfoList:\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                PcdObj.SkuInfoList[skuname] = copy.deepcopy(PcdObj.SkuInfoList[nextskuid])\n                PcdObj.SkuInfoList[skuname].SkuId = skuid\n                PcdObj.SkuInfoList[skuname].SkuIdName = skuname\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            PcdObj.DefaultValue = list(PcdObj.SkuInfoList.values())[0].HiiDefaultValue if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE else PcdObj.SkuInfoList[TAB_DEFAULT].HiiDefaultValue\n        Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n    return Pcds",
            "def CompletePcdValues(self, PcdSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Pcds = OrderedDict()\n    DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n    SkuIds = {skuname: skuid for (skuname, skuid) in self.SkuIdMgr.AvailableSkuIdSet.items() if skuname != TAB_COMMON}\n    DefaultStores = set((storename for pcdobj in PcdSet.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict))\n    for (PcdCName, TokenSpaceGuid) in PcdSet:\n        PcdObj = PcdSet[PcdCName, TokenSpaceGuid]\n        if PcdObj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n            continue\n        PcdType = PcdObj.Type\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in PcdObj.SkuInfoList:\n                skuobj = PcdObj.SkuInfoList[skuid]\n                mindefaultstorename = DefaultStoreObj.GetMin(set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict)))\n                for defaultstorename in DefaultStores:\n                    if defaultstorename not in skuobj.DefaultStoreDict:\n                        skuobj.DefaultStoreDict[defaultstorename] = skuobj.DefaultStoreDict[mindefaultstorename]\n                skuobj.HiiDefaultValue = skuobj.DefaultStoreDict[mindefaultstorename]\n        for (skuname, skuid) in SkuIds.items():\n            if skuname not in PcdObj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                while nextskuid not in PcdObj.SkuInfoList:\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                PcdObj.SkuInfoList[skuname] = copy.deepcopy(PcdObj.SkuInfoList[nextskuid])\n                PcdObj.SkuInfoList[skuname].SkuId = skuid\n                PcdObj.SkuInfoList[skuname].SkuIdName = skuname\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            PcdObj.DefaultValue = list(PcdObj.SkuInfoList.values())[0].HiiDefaultValue if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE else PcdObj.SkuInfoList[TAB_DEFAULT].HiiDefaultValue\n        Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n    return Pcds",
            "def CompletePcdValues(self, PcdSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Pcds = OrderedDict()\n    DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n    SkuIds = {skuname: skuid for (skuname, skuid) in self.SkuIdMgr.AvailableSkuIdSet.items() if skuname != TAB_COMMON}\n    DefaultStores = set((storename for pcdobj in PcdSet.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict))\n    for (PcdCName, TokenSpaceGuid) in PcdSet:\n        PcdObj = PcdSet[PcdCName, TokenSpaceGuid]\n        if PcdObj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n            continue\n        PcdType = PcdObj.Type\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in PcdObj.SkuInfoList:\n                skuobj = PcdObj.SkuInfoList[skuid]\n                mindefaultstorename = DefaultStoreObj.GetMin(set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict)))\n                for defaultstorename in DefaultStores:\n                    if defaultstorename not in skuobj.DefaultStoreDict:\n                        skuobj.DefaultStoreDict[defaultstorename] = skuobj.DefaultStoreDict[mindefaultstorename]\n                skuobj.HiiDefaultValue = skuobj.DefaultStoreDict[mindefaultstorename]\n        for (skuname, skuid) in SkuIds.items():\n            if skuname not in PcdObj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                while nextskuid not in PcdObj.SkuInfoList:\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                PcdObj.SkuInfoList[skuname] = copy.deepcopy(PcdObj.SkuInfoList[nextskuid])\n                PcdObj.SkuInfoList[skuname].SkuId = skuid\n                PcdObj.SkuInfoList[skuname].SkuIdName = skuname\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            PcdObj.DefaultValue = list(PcdObj.SkuInfoList.values())[0].HiiDefaultValue if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE else PcdObj.SkuInfoList[TAB_DEFAULT].HiiDefaultValue\n        Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n    return Pcds",
            "def CompletePcdValues(self, PcdSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Pcds = OrderedDict()\n    DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n    SkuIds = {skuname: skuid for (skuname, skuid) in self.SkuIdMgr.AvailableSkuIdSet.items() if skuname != TAB_COMMON}\n    DefaultStores = set((storename for pcdobj in PcdSet.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict))\n    for (PcdCName, TokenSpaceGuid) in PcdSet:\n        PcdObj = PcdSet[PcdCName, TokenSpaceGuid]\n        if PcdObj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n            continue\n        PcdType = PcdObj.Type\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in PcdObj.SkuInfoList:\n                skuobj = PcdObj.SkuInfoList[skuid]\n                mindefaultstorename = DefaultStoreObj.GetMin(set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict)))\n                for defaultstorename in DefaultStores:\n                    if defaultstorename not in skuobj.DefaultStoreDict:\n                        skuobj.DefaultStoreDict[defaultstorename] = skuobj.DefaultStoreDict[mindefaultstorename]\n                skuobj.HiiDefaultValue = skuobj.DefaultStoreDict[mindefaultstorename]\n        for (skuname, skuid) in SkuIds.items():\n            if skuname not in PcdObj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                while nextskuid not in PcdObj.SkuInfoList:\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                PcdObj.SkuInfoList[skuname] = copy.deepcopy(PcdObj.SkuInfoList[nextskuid])\n                PcdObj.SkuInfoList[skuname].SkuId = skuid\n                PcdObj.SkuInfoList[skuname].SkuIdName = skuname\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            PcdObj.DefaultValue = list(PcdObj.SkuInfoList.values())[0].HiiDefaultValue if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE else PcdObj.SkuInfoList[TAB_DEFAULT].HiiDefaultValue\n        Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n    return Pcds",
            "def CompletePcdValues(self, PcdSet):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Pcds = OrderedDict()\n    DefaultStoreObj = DefaultStore(self._GetDefaultStores())\n    SkuIds = {skuname: skuid for (skuname, skuid) in self.SkuIdMgr.AvailableSkuIdSet.items() if skuname != TAB_COMMON}\n    DefaultStores = set((storename for pcdobj in PcdSet.values() for skuobj in pcdobj.SkuInfoList.values() for storename in skuobj.DefaultStoreDict))\n    for (PcdCName, TokenSpaceGuid) in PcdSet:\n        PcdObj = PcdSet[PcdCName, TokenSpaceGuid]\n        if PcdObj.Type not in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_VPD], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_DEFAULT], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_VPD]]:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n            continue\n        PcdType = PcdObj.Type\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            for skuid in PcdObj.SkuInfoList:\n                skuobj = PcdObj.SkuInfoList[skuid]\n                mindefaultstorename = DefaultStoreObj.GetMin(set((defaultstorename for defaultstorename in skuobj.DefaultStoreDict)))\n                for defaultstorename in DefaultStores:\n                    if defaultstorename not in skuobj.DefaultStoreDict:\n                        skuobj.DefaultStoreDict[defaultstorename] = skuobj.DefaultStoreDict[mindefaultstorename]\n                skuobj.HiiDefaultValue = skuobj.DefaultStoreDict[mindefaultstorename]\n        for (skuname, skuid) in SkuIds.items():\n            if skuname not in PcdObj.SkuInfoList:\n                nextskuid = self.SkuIdMgr.GetNextSkuId(skuname)\n                while nextskuid not in PcdObj.SkuInfoList:\n                    nextskuid = self.SkuIdMgr.GetNextSkuId(nextskuid)\n                PcdObj.SkuInfoList[skuname] = copy.deepcopy(PcdObj.SkuInfoList[nextskuid])\n                PcdObj.SkuInfoList[skuname].SkuId = skuid\n                PcdObj.SkuInfoList[skuname].SkuIdName = skuname\n        if PcdType in [self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_HII], self._PCD_TYPE_STRING_[MODEL_PCD_DYNAMIC_EX_HII]]:\n            PcdObj.DefaultValue = list(PcdObj.SkuInfoList.values())[0].HiiDefaultValue if self.SkuIdMgr.SkuUsageType == self.SkuIdMgr.SINGLE else PcdObj.SkuInfoList[TAB_DEFAULT].HiiDefaultValue\n        Pcds[PcdCName, TokenSpaceGuid] = PcdObj\n    return Pcds"
        ]
    },
    {
        "func_name": "_GetDynamicHiiPcd",
        "original": "def _GetDynamicHiiPcd(self, Type):\n    VariableAttrs = {}\n    Pcds = OrderedDict()\n    UserDefinedDefaultStores = []\n    PcdDict = tdict(True, 5)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    DefaultStoresDefine = self._GetDefaultStores()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, DefaultStore, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        DefaultStore = DefaultStore.upper()\n        if DefaultStore == TAB_COMMON:\n            DefaultStore = TAB_DEFAULT_STORES_DEFAULT\n        else:\n            UserDefinedDefaultStores.append((PcdCName, TokenSpaceGuid))\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if DefaultStore not in DefaultStoresDefine:\n            EdkLogger.error('build', PARAMETER_INVALID, 'DefaultStores %s is not defined in [DefaultStores] section' % DefaultStore, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore] = Setting\n    for (index, (PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy4)) in enumerate(PcdList):\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore]\n        if Setting is None:\n            continue\n        (VariableName, VariableGuid, VariableOffset, DefaultValue, VarAttribute) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        (rt, Msg) = VariableAttributes.ValidateVarAttributes(VarAttribute)\n        if not rt:\n            EdkLogger.error('build', PCD_VARIABLE_ATTRIBUTES_ERROR, 'Variable attributes settings for %s is incorrect.\\n %s' % ('.'.join((TokenSpaceGuid, PcdCName)), Msg), ExtraData='[%s]' % VarAttribute)\n        ExceedMax = False\n        FormatCorrect = True\n        if VariableOffset.isdigit():\n            if int(VariableOffset, 10) > 65535:\n                ExceedMax = True\n        elif variablePattern.match(VariableOffset):\n            if int(VariableOffset, 16) > 65535:\n                ExceedMax = True\n        elif VariableOffset.find('.') > -1:\n            VariableOffsetList = VariableOffset.split('.')\n            if not (len(VariableOffsetList) == 2 and IsValidWord(VariableOffsetList[0]) and IsValidWord(VariableOffsetList[1])):\n                FormatCorrect = False\n        else:\n            FormatCorrect = False\n        if not FormatCorrect:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid syntax or format of the variable offset value is incorrect for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if ExceedMax:\n            EdkLogger.error('Build', OPTION_VALUE_INVALID, 'The variable offset value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if (VariableName, VariableGuid) not in VariableAttrs:\n            VariableAttrs[VariableName, VariableGuid] = VarAttribute\n        elif not DscBuildData.CompareVarAttr(VariableAttrs[VariableName, VariableGuid], VarAttribute):\n            EdkLogger.error('Build', PCD_VARIABLE_ATTRIBUTES_CONFLICT_ERROR, 'The variable %s.%s for DynamicHii PCDs has conflicting attributes [%s] and [%s] ' % (VariableGuid, VariableName, VarAttribute, VariableAttrs[VariableName, VariableGuid]))\n        pcdDecObject = self._DecPcds[PcdCName, TokenSpaceGuid]\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            if SkuName in pcdObject.SkuInfoList:\n                Skuitem = pcdObject.SkuInfoList[SkuName]\n                Skuitem.DefaultStoreDict.update({DefaultStore: DefaultValue})\n            else:\n                SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n                pcdObject.SkuInfoList[SkuName] = SkuInfo\n        else:\n            SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n            PcdClassObj = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', DefaultValue, '', '', OrderedDict({SkuName: SkuInfo}), False, None, pcdDecObject.validateranges, pcdDecObject.validlists, pcdDecObject.expressions, IsDsc=True)\n            if (PcdCName, TokenSpaceGuid) in UserDefinedDefaultStores:\n                PcdClassObj.UserDefinedDefaultStoresFlag = True\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObj\n            Pcds[PcdCName, TokenSpaceGuid].CustomAttribute['DscPosition'] = index\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][DefaultStore] = DefaultValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][DefaultStore] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if sku.HiiDefaultValue == '' or sku.HiiDefaultValue is None:\n                sku.HiiDefaultValue = pcdDecObject.DefaultValue\n                for default_store in sku.DefaultStoreDict:\n                    sku.DefaultStoreDict[default_store] = pcdDecObject.DefaultValue\n                pcd.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', SkuInfoObj.VariableName, SkuInfoObj.VariableGuid, SkuInfoObj.VariableOffset, valuefromDec, VariableAttribute=SkuInfoObj.VariableAttribute, DefaultStore={DefaultStore: valuefromDec})\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n        if pcd.MaxDatumSize.strip():\n            MaxSize = int(pcd.MaxDatumSize, 0)\n        else:\n            MaxSize = 0\n        if pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            for (_, skuobj) in pcd.SkuInfoList.items():\n                datalen = 0\n                skuobj.HiiDefaultValue = StringToArray(skuobj.HiiDefaultValue)\n                datalen = len(skuobj.HiiDefaultValue.split(','))\n                if datalen > MaxSize:\n                    MaxSize = datalen\n                for defaultst in skuobj.DefaultStoreDict:\n                    skuobj.DefaultStoreDict[defaultst] = StringToArray(skuobj.DefaultStoreDict[defaultst])\n            pcd.DefaultValue = StringToArray(pcd.DefaultValue)\n            pcd.MaxDatumSize = str(MaxSize)\n    (rt, invalidhii) = DscBuildData.CheckVariableNameAssignment(Pcds)\n    if not rt:\n        invalidpcd = ','.join(invalidhii)\n        EdkLogger.error('build', PCD_VARIABLE_INFO_ERROR, Message='The same HII PCD must map to the same EFI variable for all SKUs', File=self.MetaFile, ExtraData=invalidpcd)\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
        "mutated": [
            "def _GetDynamicHiiPcd(self, Type):\n    if False:\n        i = 10\n    VariableAttrs = {}\n    Pcds = OrderedDict()\n    UserDefinedDefaultStores = []\n    PcdDict = tdict(True, 5)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    DefaultStoresDefine = self._GetDefaultStores()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, DefaultStore, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        DefaultStore = DefaultStore.upper()\n        if DefaultStore == TAB_COMMON:\n            DefaultStore = TAB_DEFAULT_STORES_DEFAULT\n        else:\n            UserDefinedDefaultStores.append((PcdCName, TokenSpaceGuid))\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if DefaultStore not in DefaultStoresDefine:\n            EdkLogger.error('build', PARAMETER_INVALID, 'DefaultStores %s is not defined in [DefaultStores] section' % DefaultStore, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore] = Setting\n    for (index, (PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy4)) in enumerate(PcdList):\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore]\n        if Setting is None:\n            continue\n        (VariableName, VariableGuid, VariableOffset, DefaultValue, VarAttribute) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        (rt, Msg) = VariableAttributes.ValidateVarAttributes(VarAttribute)\n        if not rt:\n            EdkLogger.error('build', PCD_VARIABLE_ATTRIBUTES_ERROR, 'Variable attributes settings for %s is incorrect.\\n %s' % ('.'.join((TokenSpaceGuid, PcdCName)), Msg), ExtraData='[%s]' % VarAttribute)\n        ExceedMax = False\n        FormatCorrect = True\n        if VariableOffset.isdigit():\n            if int(VariableOffset, 10) > 65535:\n                ExceedMax = True\n        elif variablePattern.match(VariableOffset):\n            if int(VariableOffset, 16) > 65535:\n                ExceedMax = True\n        elif VariableOffset.find('.') > -1:\n            VariableOffsetList = VariableOffset.split('.')\n            if not (len(VariableOffsetList) == 2 and IsValidWord(VariableOffsetList[0]) and IsValidWord(VariableOffsetList[1])):\n                FormatCorrect = False\n        else:\n            FormatCorrect = False\n        if not FormatCorrect:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid syntax or format of the variable offset value is incorrect for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if ExceedMax:\n            EdkLogger.error('Build', OPTION_VALUE_INVALID, 'The variable offset value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if (VariableName, VariableGuid) not in VariableAttrs:\n            VariableAttrs[VariableName, VariableGuid] = VarAttribute\n        elif not DscBuildData.CompareVarAttr(VariableAttrs[VariableName, VariableGuid], VarAttribute):\n            EdkLogger.error('Build', PCD_VARIABLE_ATTRIBUTES_CONFLICT_ERROR, 'The variable %s.%s for DynamicHii PCDs has conflicting attributes [%s] and [%s] ' % (VariableGuid, VariableName, VarAttribute, VariableAttrs[VariableName, VariableGuid]))\n        pcdDecObject = self._DecPcds[PcdCName, TokenSpaceGuid]\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            if SkuName in pcdObject.SkuInfoList:\n                Skuitem = pcdObject.SkuInfoList[SkuName]\n                Skuitem.DefaultStoreDict.update({DefaultStore: DefaultValue})\n            else:\n                SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n                pcdObject.SkuInfoList[SkuName] = SkuInfo\n        else:\n            SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n            PcdClassObj = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', DefaultValue, '', '', OrderedDict({SkuName: SkuInfo}), False, None, pcdDecObject.validateranges, pcdDecObject.validlists, pcdDecObject.expressions, IsDsc=True)\n            if (PcdCName, TokenSpaceGuid) in UserDefinedDefaultStores:\n                PcdClassObj.UserDefinedDefaultStoresFlag = True\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObj\n            Pcds[PcdCName, TokenSpaceGuid].CustomAttribute['DscPosition'] = index\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][DefaultStore] = DefaultValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][DefaultStore] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if sku.HiiDefaultValue == '' or sku.HiiDefaultValue is None:\n                sku.HiiDefaultValue = pcdDecObject.DefaultValue\n                for default_store in sku.DefaultStoreDict:\n                    sku.DefaultStoreDict[default_store] = pcdDecObject.DefaultValue\n                pcd.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', SkuInfoObj.VariableName, SkuInfoObj.VariableGuid, SkuInfoObj.VariableOffset, valuefromDec, VariableAttribute=SkuInfoObj.VariableAttribute, DefaultStore={DefaultStore: valuefromDec})\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n        if pcd.MaxDatumSize.strip():\n            MaxSize = int(pcd.MaxDatumSize, 0)\n        else:\n            MaxSize = 0\n        if pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            for (_, skuobj) in pcd.SkuInfoList.items():\n                datalen = 0\n                skuobj.HiiDefaultValue = StringToArray(skuobj.HiiDefaultValue)\n                datalen = len(skuobj.HiiDefaultValue.split(','))\n                if datalen > MaxSize:\n                    MaxSize = datalen\n                for defaultst in skuobj.DefaultStoreDict:\n                    skuobj.DefaultStoreDict[defaultst] = StringToArray(skuobj.DefaultStoreDict[defaultst])\n            pcd.DefaultValue = StringToArray(pcd.DefaultValue)\n            pcd.MaxDatumSize = str(MaxSize)\n    (rt, invalidhii) = DscBuildData.CheckVariableNameAssignment(Pcds)\n    if not rt:\n        invalidpcd = ','.join(invalidhii)\n        EdkLogger.error('build', PCD_VARIABLE_INFO_ERROR, Message='The same HII PCD must map to the same EFI variable for all SKUs', File=self.MetaFile, ExtraData=invalidpcd)\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicHiiPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    VariableAttrs = {}\n    Pcds = OrderedDict()\n    UserDefinedDefaultStores = []\n    PcdDict = tdict(True, 5)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    DefaultStoresDefine = self._GetDefaultStores()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, DefaultStore, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        DefaultStore = DefaultStore.upper()\n        if DefaultStore == TAB_COMMON:\n            DefaultStore = TAB_DEFAULT_STORES_DEFAULT\n        else:\n            UserDefinedDefaultStores.append((PcdCName, TokenSpaceGuid))\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if DefaultStore not in DefaultStoresDefine:\n            EdkLogger.error('build', PARAMETER_INVALID, 'DefaultStores %s is not defined in [DefaultStores] section' % DefaultStore, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore] = Setting\n    for (index, (PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy4)) in enumerate(PcdList):\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore]\n        if Setting is None:\n            continue\n        (VariableName, VariableGuid, VariableOffset, DefaultValue, VarAttribute) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        (rt, Msg) = VariableAttributes.ValidateVarAttributes(VarAttribute)\n        if not rt:\n            EdkLogger.error('build', PCD_VARIABLE_ATTRIBUTES_ERROR, 'Variable attributes settings for %s is incorrect.\\n %s' % ('.'.join((TokenSpaceGuid, PcdCName)), Msg), ExtraData='[%s]' % VarAttribute)\n        ExceedMax = False\n        FormatCorrect = True\n        if VariableOffset.isdigit():\n            if int(VariableOffset, 10) > 65535:\n                ExceedMax = True\n        elif variablePattern.match(VariableOffset):\n            if int(VariableOffset, 16) > 65535:\n                ExceedMax = True\n        elif VariableOffset.find('.') > -1:\n            VariableOffsetList = VariableOffset.split('.')\n            if not (len(VariableOffsetList) == 2 and IsValidWord(VariableOffsetList[0]) and IsValidWord(VariableOffsetList[1])):\n                FormatCorrect = False\n        else:\n            FormatCorrect = False\n        if not FormatCorrect:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid syntax or format of the variable offset value is incorrect for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if ExceedMax:\n            EdkLogger.error('Build', OPTION_VALUE_INVALID, 'The variable offset value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if (VariableName, VariableGuid) not in VariableAttrs:\n            VariableAttrs[VariableName, VariableGuid] = VarAttribute\n        elif not DscBuildData.CompareVarAttr(VariableAttrs[VariableName, VariableGuid], VarAttribute):\n            EdkLogger.error('Build', PCD_VARIABLE_ATTRIBUTES_CONFLICT_ERROR, 'The variable %s.%s for DynamicHii PCDs has conflicting attributes [%s] and [%s] ' % (VariableGuid, VariableName, VarAttribute, VariableAttrs[VariableName, VariableGuid]))\n        pcdDecObject = self._DecPcds[PcdCName, TokenSpaceGuid]\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            if SkuName in pcdObject.SkuInfoList:\n                Skuitem = pcdObject.SkuInfoList[SkuName]\n                Skuitem.DefaultStoreDict.update({DefaultStore: DefaultValue})\n            else:\n                SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n                pcdObject.SkuInfoList[SkuName] = SkuInfo\n        else:\n            SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n            PcdClassObj = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', DefaultValue, '', '', OrderedDict({SkuName: SkuInfo}), False, None, pcdDecObject.validateranges, pcdDecObject.validlists, pcdDecObject.expressions, IsDsc=True)\n            if (PcdCName, TokenSpaceGuid) in UserDefinedDefaultStores:\n                PcdClassObj.UserDefinedDefaultStoresFlag = True\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObj\n            Pcds[PcdCName, TokenSpaceGuid].CustomAttribute['DscPosition'] = index\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][DefaultStore] = DefaultValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][DefaultStore] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if sku.HiiDefaultValue == '' or sku.HiiDefaultValue is None:\n                sku.HiiDefaultValue = pcdDecObject.DefaultValue\n                for default_store in sku.DefaultStoreDict:\n                    sku.DefaultStoreDict[default_store] = pcdDecObject.DefaultValue\n                pcd.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', SkuInfoObj.VariableName, SkuInfoObj.VariableGuid, SkuInfoObj.VariableOffset, valuefromDec, VariableAttribute=SkuInfoObj.VariableAttribute, DefaultStore={DefaultStore: valuefromDec})\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n        if pcd.MaxDatumSize.strip():\n            MaxSize = int(pcd.MaxDatumSize, 0)\n        else:\n            MaxSize = 0\n        if pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            for (_, skuobj) in pcd.SkuInfoList.items():\n                datalen = 0\n                skuobj.HiiDefaultValue = StringToArray(skuobj.HiiDefaultValue)\n                datalen = len(skuobj.HiiDefaultValue.split(','))\n                if datalen > MaxSize:\n                    MaxSize = datalen\n                for defaultst in skuobj.DefaultStoreDict:\n                    skuobj.DefaultStoreDict[defaultst] = StringToArray(skuobj.DefaultStoreDict[defaultst])\n            pcd.DefaultValue = StringToArray(pcd.DefaultValue)\n            pcd.MaxDatumSize = str(MaxSize)\n    (rt, invalidhii) = DscBuildData.CheckVariableNameAssignment(Pcds)\n    if not rt:\n        invalidpcd = ','.join(invalidhii)\n        EdkLogger.error('build', PCD_VARIABLE_INFO_ERROR, Message='The same HII PCD must map to the same EFI variable for all SKUs', File=self.MetaFile, ExtraData=invalidpcd)\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicHiiPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    VariableAttrs = {}\n    Pcds = OrderedDict()\n    UserDefinedDefaultStores = []\n    PcdDict = tdict(True, 5)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    DefaultStoresDefine = self._GetDefaultStores()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, DefaultStore, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        DefaultStore = DefaultStore.upper()\n        if DefaultStore == TAB_COMMON:\n            DefaultStore = TAB_DEFAULT_STORES_DEFAULT\n        else:\n            UserDefinedDefaultStores.append((PcdCName, TokenSpaceGuid))\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if DefaultStore not in DefaultStoresDefine:\n            EdkLogger.error('build', PARAMETER_INVALID, 'DefaultStores %s is not defined in [DefaultStores] section' % DefaultStore, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore] = Setting\n    for (index, (PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy4)) in enumerate(PcdList):\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore]\n        if Setting is None:\n            continue\n        (VariableName, VariableGuid, VariableOffset, DefaultValue, VarAttribute) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        (rt, Msg) = VariableAttributes.ValidateVarAttributes(VarAttribute)\n        if not rt:\n            EdkLogger.error('build', PCD_VARIABLE_ATTRIBUTES_ERROR, 'Variable attributes settings for %s is incorrect.\\n %s' % ('.'.join((TokenSpaceGuid, PcdCName)), Msg), ExtraData='[%s]' % VarAttribute)\n        ExceedMax = False\n        FormatCorrect = True\n        if VariableOffset.isdigit():\n            if int(VariableOffset, 10) > 65535:\n                ExceedMax = True\n        elif variablePattern.match(VariableOffset):\n            if int(VariableOffset, 16) > 65535:\n                ExceedMax = True\n        elif VariableOffset.find('.') > -1:\n            VariableOffsetList = VariableOffset.split('.')\n            if not (len(VariableOffsetList) == 2 and IsValidWord(VariableOffsetList[0]) and IsValidWord(VariableOffsetList[1])):\n                FormatCorrect = False\n        else:\n            FormatCorrect = False\n        if not FormatCorrect:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid syntax or format of the variable offset value is incorrect for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if ExceedMax:\n            EdkLogger.error('Build', OPTION_VALUE_INVALID, 'The variable offset value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if (VariableName, VariableGuid) not in VariableAttrs:\n            VariableAttrs[VariableName, VariableGuid] = VarAttribute\n        elif not DscBuildData.CompareVarAttr(VariableAttrs[VariableName, VariableGuid], VarAttribute):\n            EdkLogger.error('Build', PCD_VARIABLE_ATTRIBUTES_CONFLICT_ERROR, 'The variable %s.%s for DynamicHii PCDs has conflicting attributes [%s] and [%s] ' % (VariableGuid, VariableName, VarAttribute, VariableAttrs[VariableName, VariableGuid]))\n        pcdDecObject = self._DecPcds[PcdCName, TokenSpaceGuid]\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            if SkuName in pcdObject.SkuInfoList:\n                Skuitem = pcdObject.SkuInfoList[SkuName]\n                Skuitem.DefaultStoreDict.update({DefaultStore: DefaultValue})\n            else:\n                SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n                pcdObject.SkuInfoList[SkuName] = SkuInfo\n        else:\n            SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n            PcdClassObj = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', DefaultValue, '', '', OrderedDict({SkuName: SkuInfo}), False, None, pcdDecObject.validateranges, pcdDecObject.validlists, pcdDecObject.expressions, IsDsc=True)\n            if (PcdCName, TokenSpaceGuid) in UserDefinedDefaultStores:\n                PcdClassObj.UserDefinedDefaultStoresFlag = True\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObj\n            Pcds[PcdCName, TokenSpaceGuid].CustomAttribute['DscPosition'] = index\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][DefaultStore] = DefaultValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][DefaultStore] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if sku.HiiDefaultValue == '' or sku.HiiDefaultValue is None:\n                sku.HiiDefaultValue = pcdDecObject.DefaultValue\n                for default_store in sku.DefaultStoreDict:\n                    sku.DefaultStoreDict[default_store] = pcdDecObject.DefaultValue\n                pcd.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', SkuInfoObj.VariableName, SkuInfoObj.VariableGuid, SkuInfoObj.VariableOffset, valuefromDec, VariableAttribute=SkuInfoObj.VariableAttribute, DefaultStore={DefaultStore: valuefromDec})\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n        if pcd.MaxDatumSize.strip():\n            MaxSize = int(pcd.MaxDatumSize, 0)\n        else:\n            MaxSize = 0\n        if pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            for (_, skuobj) in pcd.SkuInfoList.items():\n                datalen = 0\n                skuobj.HiiDefaultValue = StringToArray(skuobj.HiiDefaultValue)\n                datalen = len(skuobj.HiiDefaultValue.split(','))\n                if datalen > MaxSize:\n                    MaxSize = datalen\n                for defaultst in skuobj.DefaultStoreDict:\n                    skuobj.DefaultStoreDict[defaultst] = StringToArray(skuobj.DefaultStoreDict[defaultst])\n            pcd.DefaultValue = StringToArray(pcd.DefaultValue)\n            pcd.MaxDatumSize = str(MaxSize)\n    (rt, invalidhii) = DscBuildData.CheckVariableNameAssignment(Pcds)\n    if not rt:\n        invalidpcd = ','.join(invalidhii)\n        EdkLogger.error('build', PCD_VARIABLE_INFO_ERROR, Message='The same HII PCD must map to the same EFI variable for all SKUs', File=self.MetaFile, ExtraData=invalidpcd)\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicHiiPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    VariableAttrs = {}\n    Pcds = OrderedDict()\n    UserDefinedDefaultStores = []\n    PcdDict = tdict(True, 5)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    DefaultStoresDefine = self._GetDefaultStores()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, DefaultStore, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        DefaultStore = DefaultStore.upper()\n        if DefaultStore == TAB_COMMON:\n            DefaultStore = TAB_DEFAULT_STORES_DEFAULT\n        else:\n            UserDefinedDefaultStores.append((PcdCName, TokenSpaceGuid))\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if DefaultStore not in DefaultStoresDefine:\n            EdkLogger.error('build', PARAMETER_INVALID, 'DefaultStores %s is not defined in [DefaultStores] section' % DefaultStore, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore] = Setting\n    for (index, (PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy4)) in enumerate(PcdList):\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore]\n        if Setting is None:\n            continue\n        (VariableName, VariableGuid, VariableOffset, DefaultValue, VarAttribute) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        (rt, Msg) = VariableAttributes.ValidateVarAttributes(VarAttribute)\n        if not rt:\n            EdkLogger.error('build', PCD_VARIABLE_ATTRIBUTES_ERROR, 'Variable attributes settings for %s is incorrect.\\n %s' % ('.'.join((TokenSpaceGuid, PcdCName)), Msg), ExtraData='[%s]' % VarAttribute)\n        ExceedMax = False\n        FormatCorrect = True\n        if VariableOffset.isdigit():\n            if int(VariableOffset, 10) > 65535:\n                ExceedMax = True\n        elif variablePattern.match(VariableOffset):\n            if int(VariableOffset, 16) > 65535:\n                ExceedMax = True\n        elif VariableOffset.find('.') > -1:\n            VariableOffsetList = VariableOffset.split('.')\n            if not (len(VariableOffsetList) == 2 and IsValidWord(VariableOffsetList[0]) and IsValidWord(VariableOffsetList[1])):\n                FormatCorrect = False\n        else:\n            FormatCorrect = False\n        if not FormatCorrect:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid syntax or format of the variable offset value is incorrect for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if ExceedMax:\n            EdkLogger.error('Build', OPTION_VALUE_INVALID, 'The variable offset value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if (VariableName, VariableGuid) not in VariableAttrs:\n            VariableAttrs[VariableName, VariableGuid] = VarAttribute\n        elif not DscBuildData.CompareVarAttr(VariableAttrs[VariableName, VariableGuid], VarAttribute):\n            EdkLogger.error('Build', PCD_VARIABLE_ATTRIBUTES_CONFLICT_ERROR, 'The variable %s.%s for DynamicHii PCDs has conflicting attributes [%s] and [%s] ' % (VariableGuid, VariableName, VarAttribute, VariableAttrs[VariableName, VariableGuid]))\n        pcdDecObject = self._DecPcds[PcdCName, TokenSpaceGuid]\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            if SkuName in pcdObject.SkuInfoList:\n                Skuitem = pcdObject.SkuInfoList[SkuName]\n                Skuitem.DefaultStoreDict.update({DefaultStore: DefaultValue})\n            else:\n                SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n                pcdObject.SkuInfoList[SkuName] = SkuInfo\n        else:\n            SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n            PcdClassObj = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', DefaultValue, '', '', OrderedDict({SkuName: SkuInfo}), False, None, pcdDecObject.validateranges, pcdDecObject.validlists, pcdDecObject.expressions, IsDsc=True)\n            if (PcdCName, TokenSpaceGuid) in UserDefinedDefaultStores:\n                PcdClassObj.UserDefinedDefaultStoresFlag = True\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObj\n            Pcds[PcdCName, TokenSpaceGuid].CustomAttribute['DscPosition'] = index\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][DefaultStore] = DefaultValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][DefaultStore] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if sku.HiiDefaultValue == '' or sku.HiiDefaultValue is None:\n                sku.HiiDefaultValue = pcdDecObject.DefaultValue\n                for default_store in sku.DefaultStoreDict:\n                    sku.DefaultStoreDict[default_store] = pcdDecObject.DefaultValue\n                pcd.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', SkuInfoObj.VariableName, SkuInfoObj.VariableGuid, SkuInfoObj.VariableOffset, valuefromDec, VariableAttribute=SkuInfoObj.VariableAttribute, DefaultStore={DefaultStore: valuefromDec})\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n        if pcd.MaxDatumSize.strip():\n            MaxSize = int(pcd.MaxDatumSize, 0)\n        else:\n            MaxSize = 0\n        if pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            for (_, skuobj) in pcd.SkuInfoList.items():\n                datalen = 0\n                skuobj.HiiDefaultValue = StringToArray(skuobj.HiiDefaultValue)\n                datalen = len(skuobj.HiiDefaultValue.split(','))\n                if datalen > MaxSize:\n                    MaxSize = datalen\n                for defaultst in skuobj.DefaultStoreDict:\n                    skuobj.DefaultStoreDict[defaultst] = StringToArray(skuobj.DefaultStoreDict[defaultst])\n            pcd.DefaultValue = StringToArray(pcd.DefaultValue)\n            pcd.MaxDatumSize = str(MaxSize)\n    (rt, invalidhii) = DscBuildData.CheckVariableNameAssignment(Pcds)\n    if not rt:\n        invalidpcd = ','.join(invalidhii)\n        EdkLogger.error('build', PCD_VARIABLE_INFO_ERROR, Message='The same HII PCD must map to the same EFI variable for all SKUs', File=self.MetaFile, ExtraData=invalidpcd)\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicHiiPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    VariableAttrs = {}\n    Pcds = OrderedDict()\n    UserDefinedDefaultStores = []\n    PcdDict = tdict(True, 5)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    DefaultStoresDefine = self._GetDefaultStores()\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, DefaultStore, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        DefaultStore = DefaultStore.upper()\n        if DefaultStore == TAB_COMMON:\n            DefaultStore = TAB_DEFAULT_STORES_DEFAULT\n        else:\n            UserDefinedDefaultStores.append((PcdCName, TokenSpaceGuid))\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if DefaultStore not in DefaultStoresDefine:\n            EdkLogger.error('build', PARAMETER_INVALID, 'DefaultStores %s is not defined in [DefaultStores] section' % DefaultStore, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore] = Setting\n    for (index, (PcdCName, TokenSpaceGuid, SkuName, DefaultStore, Dummy4)) in enumerate(PcdList):\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid, DefaultStore]\n        if Setting is None:\n            continue\n        (VariableName, VariableGuid, VariableOffset, DefaultValue, VarAttribute) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        (rt, Msg) = VariableAttributes.ValidateVarAttributes(VarAttribute)\n        if not rt:\n            EdkLogger.error('build', PCD_VARIABLE_ATTRIBUTES_ERROR, 'Variable attributes settings for %s is incorrect.\\n %s' % ('.'.join((TokenSpaceGuid, PcdCName)), Msg), ExtraData='[%s]' % VarAttribute)\n        ExceedMax = False\n        FormatCorrect = True\n        if VariableOffset.isdigit():\n            if int(VariableOffset, 10) > 65535:\n                ExceedMax = True\n        elif variablePattern.match(VariableOffset):\n            if int(VariableOffset, 16) > 65535:\n                ExceedMax = True\n        elif VariableOffset.find('.') > -1:\n            VariableOffsetList = VariableOffset.split('.')\n            if not (len(VariableOffsetList) == 2 and IsValidWord(VariableOffsetList[0]) and IsValidWord(VariableOffsetList[1])):\n                FormatCorrect = False\n        else:\n            FormatCorrect = False\n        if not FormatCorrect:\n            EdkLogger.error('Build', FORMAT_INVALID, 'Invalid syntax or format of the variable offset value is incorrect for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if ExceedMax:\n            EdkLogger.error('Build', OPTION_VALUE_INVALID, 'The variable offset value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)))\n        if (VariableName, VariableGuid) not in VariableAttrs:\n            VariableAttrs[VariableName, VariableGuid] = VarAttribute\n        elif not DscBuildData.CompareVarAttr(VariableAttrs[VariableName, VariableGuid], VarAttribute):\n            EdkLogger.error('Build', PCD_VARIABLE_ATTRIBUTES_CONFLICT_ERROR, 'The variable %s.%s for DynamicHii PCDs has conflicting attributes [%s] and [%s] ' % (VariableGuid, VariableName, VarAttribute, VariableAttrs[VariableName, VariableGuid]))\n        pcdDecObject = self._DecPcds[PcdCName, TokenSpaceGuid]\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            if SkuName in pcdObject.SkuInfoList:\n                Skuitem = pcdObject.SkuInfoList[SkuName]\n                Skuitem.DefaultStoreDict.update({DefaultStore: DefaultValue})\n            else:\n                SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n                pcdObject.SkuInfoList[SkuName] = SkuInfo\n        else:\n            SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], VariableName, VariableGuid, VariableOffset, DefaultValue, VariableAttribute=VarAttribute, DefaultStore={DefaultStore: DefaultValue})\n            PcdClassObj = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', DefaultValue, '', '', OrderedDict({SkuName: SkuInfo}), False, None, pcdDecObject.validateranges, pcdDecObject.validlists, pcdDecObject.expressions, IsDsc=True)\n            if (PcdCName, TokenSpaceGuid) in UserDefinedDefaultStores:\n                PcdClassObj.UserDefinedDefaultStoresFlag = True\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObj\n            Pcds[PcdCName, TokenSpaceGuid].CustomAttribute['DscPosition'] = index\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][DefaultStore] = DefaultValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][DefaultStore] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if sku.HiiDefaultValue == '' or sku.HiiDefaultValue is None:\n                sku.HiiDefaultValue = pcdDecObject.DefaultValue\n                for default_store in sku.DefaultStoreDict:\n                    sku.DefaultStoreDict[default_store] = pcdDecObject.DefaultValue\n                pcd.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', SkuInfoObj.VariableName, SkuInfoObj.VariableGuid, SkuInfoObj.VariableOffset, valuefromDec, VariableAttribute=SkuInfoObj.VariableAttribute, DefaultStore={DefaultStore: valuefromDec})\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n        if pcd.MaxDatumSize.strip():\n            MaxSize = int(pcd.MaxDatumSize, 0)\n        else:\n            MaxSize = 0\n        if pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            for (_, skuobj) in pcd.SkuInfoList.items():\n                datalen = 0\n                skuobj.HiiDefaultValue = StringToArray(skuobj.HiiDefaultValue)\n                datalen = len(skuobj.HiiDefaultValue.split(','))\n                if datalen > MaxSize:\n                    MaxSize = datalen\n                for defaultst in skuobj.DefaultStoreDict:\n                    skuobj.DefaultStoreDict[defaultst] = StringToArray(skuobj.DefaultStoreDict[defaultst])\n            pcd.DefaultValue = StringToArray(pcd.DefaultValue)\n            pcd.MaxDatumSize = str(MaxSize)\n    (rt, invalidhii) = DscBuildData.CheckVariableNameAssignment(Pcds)\n    if not rt:\n        invalidpcd = ','.join(invalidhii)\n        EdkLogger.error('build', PCD_VARIABLE_INFO_ERROR, Message='The same HII PCD must map to the same EFI variable for all SKUs', File=self.MetaFile, ExtraData=invalidpcd)\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds"
        ]
    },
    {
        "func_name": "CheckVariableNameAssignment",
        "original": "@staticmethod\ndef CheckVariableNameAssignment(Pcds):\n    invalidhii = []\n    for pcdname in Pcds:\n        pcd = Pcds[pcdname]\n        varnameset = set((sku.VariableName for (skuid, sku) in pcd.SkuInfoList.items()))\n        if len(varnameset) > 1:\n            invalidhii.append('.'.join((pcdname[1], pcdname[0])))\n    if len(invalidhii):\n        return (False, invalidhii)\n    else:\n        return (True, [])",
        "mutated": [
            "@staticmethod\ndef CheckVariableNameAssignment(Pcds):\n    if False:\n        i = 10\n    invalidhii = []\n    for pcdname in Pcds:\n        pcd = Pcds[pcdname]\n        varnameset = set((sku.VariableName for (skuid, sku) in pcd.SkuInfoList.items()))\n        if len(varnameset) > 1:\n            invalidhii.append('.'.join((pcdname[1], pcdname[0])))\n    if len(invalidhii):\n        return (False, invalidhii)\n    else:\n        return (True, [])",
            "@staticmethod\ndef CheckVariableNameAssignment(Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    invalidhii = []\n    for pcdname in Pcds:\n        pcd = Pcds[pcdname]\n        varnameset = set((sku.VariableName for (skuid, sku) in pcd.SkuInfoList.items()))\n        if len(varnameset) > 1:\n            invalidhii.append('.'.join((pcdname[1], pcdname[0])))\n    if len(invalidhii):\n        return (False, invalidhii)\n    else:\n        return (True, [])",
            "@staticmethod\ndef CheckVariableNameAssignment(Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    invalidhii = []\n    for pcdname in Pcds:\n        pcd = Pcds[pcdname]\n        varnameset = set((sku.VariableName for (skuid, sku) in pcd.SkuInfoList.items()))\n        if len(varnameset) > 1:\n            invalidhii.append('.'.join((pcdname[1], pcdname[0])))\n    if len(invalidhii):\n        return (False, invalidhii)\n    else:\n        return (True, [])",
            "@staticmethod\ndef CheckVariableNameAssignment(Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    invalidhii = []\n    for pcdname in Pcds:\n        pcd = Pcds[pcdname]\n        varnameset = set((sku.VariableName for (skuid, sku) in pcd.SkuInfoList.items()))\n        if len(varnameset) > 1:\n            invalidhii.append('.'.join((pcdname[1], pcdname[0])))\n    if len(invalidhii):\n        return (False, invalidhii)\n    else:\n        return (True, [])",
            "@staticmethod\ndef CheckVariableNameAssignment(Pcds):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    invalidhii = []\n    for pcdname in Pcds:\n        pcd = Pcds[pcdname]\n        varnameset = set((sku.VariableName for (skuid, sku) in pcd.SkuInfoList.items()))\n        if len(varnameset) > 1:\n            invalidhii.append('.'.join((pcdname[1], pcdname[0])))\n    if len(invalidhii):\n        return (False, invalidhii)\n    else:\n        return (True, [])"
        ]
    },
    {
        "func_name": "_GetDynamicVpdPcd",
        "original": "def _GetDynamicVpdPcd(self, Type):\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (VpdOffset, MaxDatumSize, InitialValue) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', VpdOffset, InitialValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', InitialValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = InitialValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', SkuInfoObj.VpdOffset, valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    for pcd in Pcds.values():\n        PcdValueTypeSet = set()\n        for sku in pcd.SkuInfoList.values():\n            PcdValueTypeSet.add('UnicodeString' if sku.DefaultValue.startswith(('L\"', \"L'\")) else 'OtherVOID*')\n        if len(PcdValueTypeSet) > 1:\n            for sku in pcd.SkuInfoList.values():\n                sku.DefaultValue = StringToArray(sku.DefaultValue) if sku.DefaultValue.startswith(('L\"', \"L'\")) else sku.DefaultValue\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
        "mutated": [
            "def _GetDynamicVpdPcd(self, Type):\n    if False:\n        i = 10\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (VpdOffset, MaxDatumSize, InitialValue) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', VpdOffset, InitialValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', InitialValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = InitialValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', SkuInfoObj.VpdOffset, valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    for pcd in Pcds.values():\n        PcdValueTypeSet = set()\n        for sku in pcd.SkuInfoList.values():\n            PcdValueTypeSet.add('UnicodeString' if sku.DefaultValue.startswith(('L\"', \"L'\")) else 'OtherVOID*')\n        if len(PcdValueTypeSet) > 1:\n            for sku in pcd.SkuInfoList.values():\n                sku.DefaultValue = StringToArray(sku.DefaultValue) if sku.DefaultValue.startswith(('L\"', \"L'\")) else sku.DefaultValue\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicVpdPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (VpdOffset, MaxDatumSize, InitialValue) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', VpdOffset, InitialValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', InitialValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = InitialValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', SkuInfoObj.VpdOffset, valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    for pcd in Pcds.values():\n        PcdValueTypeSet = set()\n        for sku in pcd.SkuInfoList.values():\n            PcdValueTypeSet.add('UnicodeString' if sku.DefaultValue.startswith(('L\"', \"L'\")) else 'OtherVOID*')\n        if len(PcdValueTypeSet) > 1:\n            for sku in pcd.SkuInfoList.values():\n                sku.DefaultValue = StringToArray(sku.DefaultValue) if sku.DefaultValue.startswith(('L\"', \"L'\")) else sku.DefaultValue\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicVpdPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (VpdOffset, MaxDatumSize, InitialValue) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', VpdOffset, InitialValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', InitialValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = InitialValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', SkuInfoObj.VpdOffset, valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    for pcd in Pcds.values():\n        PcdValueTypeSet = set()\n        for sku in pcd.SkuInfoList.values():\n            PcdValueTypeSet.add('UnicodeString' if sku.DefaultValue.startswith(('L\"', \"L'\")) else 'OtherVOID*')\n        if len(PcdValueTypeSet) > 1:\n            for sku in pcd.SkuInfoList.values():\n                sku.DefaultValue = StringToArray(sku.DefaultValue) if sku.DefaultValue.startswith(('L\"', \"L'\")) else sku.DefaultValue\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicVpdPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (VpdOffset, MaxDatumSize, InitialValue) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', VpdOffset, InitialValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', InitialValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = InitialValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', SkuInfoObj.VpdOffset, valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    for pcd in Pcds.values():\n        PcdValueTypeSet = set()\n        for sku in pcd.SkuInfoList.values():\n            PcdValueTypeSet.add('UnicodeString' if sku.DefaultValue.startswith(('L\"', \"L'\")) else 'OtherVOID*')\n        if len(PcdValueTypeSet) > 1:\n            for sku in pcd.SkuInfoList.values():\n                sku.DefaultValue = StringToArray(sku.DefaultValue) if sku.DefaultValue.startswith(('L\"', \"L'\")) else sku.DefaultValue\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds",
            "def _GetDynamicVpdPcd(self, Type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    Pcds = OrderedDict()\n    PcdDict = tdict(True, 4)\n    PcdList = []\n    RecordList = self._RawData[Type, self._Arch]\n    AvailableSkuIdSet = copy.copy(self.SkuIds)\n    for (TokenSpaceGuid, PcdCName, Setting, Arch, SkuName, Dummy3, Dummy4, Dummy5) in RecordList:\n        SkuName = SkuName.upper()\n        SkuName = TAB_DEFAULT if SkuName == TAB_COMMON else SkuName\n        if SkuName not in AvailableSkuIdSet:\n            EdkLogger.error('build', PARAMETER_INVALID, 'Sku %s is not defined in [SkuIds] section' % SkuName, File=self.MetaFile, Line=Dummy5)\n        if '.' not in TokenSpaceGuid and '[' not in PcdCName and ((PcdCName, TokenSpaceGuid, SkuName, Dummy5) not in PcdList):\n            PcdList.append((PcdCName, TokenSpaceGuid, SkuName, Dummy5))\n        PcdDict[Arch, SkuName, PcdCName, TokenSpaceGuid] = Setting\n    for (PcdCName, TokenSpaceGuid, SkuName, Dummy4) in PcdList:\n        Setting = PcdDict[self._Arch, SkuName, PcdCName, TokenSpaceGuid]\n        if Setting is None:\n            continue\n        (VpdOffset, MaxDatumSize, InitialValue) = self._ValidatePcd(PcdCName, TokenSpaceGuid, Setting, Type, Dummy4)\n        if MaxDatumSize:\n            if int(MaxDatumSize, 0) > 65535:\n                EdkLogger.error('build', FORMAT_INVALID, 'The size value must not exceed the maximum value of 0xFFFF (UINT16) for %s.' % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n            if int(MaxDatumSize, 0) < 0:\n                EdkLogger.error('build', FORMAT_INVALID, \"The size value can't be set to negative value for %s.\" % '.'.join((TokenSpaceGuid, PcdCName)), File=self.MetaFile, Line=Dummy4)\n        SkuInfo = SkuInfoClass(SkuName, self.SkuIds[SkuName][0], '', '', '', '', VpdOffset, InitialValue)\n        if (PcdCName, TokenSpaceGuid) in Pcds:\n            pcdObject = Pcds[PcdCName, TokenSpaceGuid]\n            pcdObject.SkuInfoList[SkuName] = SkuInfo\n            if MaxDatumSize.strip():\n                CurrentMaxSize = int(MaxDatumSize.strip(), 0)\n            else:\n                CurrentMaxSize = 0\n            if pcdObject.MaxDatumSize:\n                PcdMaxSize = int(pcdObject.MaxDatumSize, 0)\n            else:\n                PcdMaxSize = 0\n            if CurrentMaxSize > PcdMaxSize:\n                pcdObject.MaxDatumSize = str(CurrentMaxSize)\n        else:\n            Pcds[PcdCName, TokenSpaceGuid] = PcdClassObject(PcdCName, TokenSpaceGuid, self._PCD_TYPE_STRING_[Type], '', InitialValue, '', MaxDatumSize, OrderedDict({SkuName: SkuInfo}), False, None, IsDsc=True)\n        if SkuName not in Pcds[PcdCName, TokenSpaceGuid].DscRawValue:\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName] = {}\n            Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName] = {}\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValue[SkuName][TAB_DEFAULT_STORES_DEFAULT] = InitialValue\n        Pcds[PcdCName, TokenSpaceGuid].DscRawValueInfo[SkuName][TAB_DEFAULT_STORES_DEFAULT] = (self.MetaFile.File, Dummy4)\n    for pcd in Pcds.values():\n        pcdDecObject = self._DecPcds[pcd.TokenCName, pcd.TokenSpaceGuidCName]\n        pcd.DatumType = pcdDecObject.DatumType\n        for sku in pcd.SkuInfoList.values():\n            if not sku.DefaultValue:\n                sku.DefaultValue = pcdDecObject.DefaultValue\n        if TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON not in pcd.SkuInfoList:\n            SkuInfoObj = list(pcd.SkuInfoList.values())[0]\n            valuefromDec = pcdDecObject.DefaultValue\n            SkuInfo = SkuInfoClass(TAB_DEFAULT, '0', '', '', '', '', SkuInfoObj.VpdOffset, valuefromDec)\n            pcd.SkuInfoList[TAB_DEFAULT] = SkuInfo\n        elif TAB_DEFAULT not in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            pcd.SkuInfoList[TAB_DEFAULT] = pcd.SkuInfoList[TAB_COMMON]\n            del pcd.SkuInfoList[TAB_COMMON]\n        elif TAB_DEFAULT in pcd.SkuInfoList and TAB_COMMON in pcd.SkuInfoList:\n            del pcd.SkuInfoList[TAB_COMMON]\n    for pcd in Pcds.values():\n        PcdValueTypeSet = set()\n        for sku in pcd.SkuInfoList.values():\n            PcdValueTypeSet.add('UnicodeString' if sku.DefaultValue.startswith(('L\"', \"L'\")) else 'OtherVOID*')\n        if len(PcdValueTypeSet) > 1:\n            for sku in pcd.SkuInfoList.values():\n                sku.DefaultValue = StringToArray(sku.DefaultValue) if sku.DefaultValue.startswith(('L\"', \"L'\")) else sku.DefaultValue\n    list(map(self.FilterSkuSettings, Pcds.values()))\n    return Pcds"
        ]
    },
    {
        "func_name": "AddModule",
        "original": "def AddModule(self, FilePath):\n    FilePath = NormPath(FilePath)\n    if FilePath not in self.Modules:\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = FilePath\n        self.Modules.append(Module)",
        "mutated": [
            "def AddModule(self, FilePath):\n    if False:\n        i = 10\n    FilePath = NormPath(FilePath)\n    if FilePath not in self.Modules:\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = FilePath\n        self.Modules.append(Module)",
            "def AddModule(self, FilePath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    FilePath = NormPath(FilePath)\n    if FilePath not in self.Modules:\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = FilePath\n        self.Modules.append(Module)",
            "def AddModule(self, FilePath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    FilePath = NormPath(FilePath)\n    if FilePath not in self.Modules:\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = FilePath\n        self.Modules.append(Module)",
            "def AddModule(self, FilePath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    FilePath = NormPath(FilePath)\n    if FilePath not in self.Modules:\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = FilePath\n        self.Modules.append(Module)",
            "def AddModule(self, FilePath):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    FilePath = NormPath(FilePath)\n    if FilePath not in self.Modules:\n        Module = ModuleBuildClassObject()\n        Module.MetaFile = FilePath\n        self.Modules.append(Module)"
        ]
    },
    {
        "func_name": "ToolChainFamily",
        "original": "@property\ndef ToolChainFamily(self):\n    self._ToolChainFamily = TAB_COMPILER_MSFT\n    TargetObj = TargetTxtDict()\n    TargetTxt = TargetObj.Target\n    BuildConfigurationFile = os.path.normpath(os.path.join(GlobalData.gConfDirectory, gDefaultTargetTxtFile))\n    if os.path.isfile(BuildConfigurationFile) == True:\n        ToolDefinitionFile = TargetTxt.TargetTxtDictionary[DataType.TAB_TAT_DEFINES_TOOL_CHAIN_CONF]\n        if ToolDefinitionFile == '':\n            ToolDefinitionFile = os.path.normpath(mws.join(self.WorkspaceDir, 'Conf', gDefaultToolsDefFile))\n        if os.path.isfile(ToolDefinitionFile) == True:\n            ToolDefObj = ToolDefDict(os.path.join(os.getenv('WORKSPACE'), 'Conf'))\n            ToolDefinition = ToolDefObj.ToolDef.ToolsDefTxtDatabase\n            if TAB_TOD_DEFINES_FAMILY not in ToolDefinition or self._Toolchain not in ToolDefinition[TAB_TOD_DEFINES_FAMILY] or (not ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]):\n                self._ToolChainFamily = TAB_COMPILER_MSFT\n            else:\n                self._ToolChainFamily = ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]\n    return self._ToolChainFamily",
        "mutated": [
            "@property\ndef ToolChainFamily(self):\n    if False:\n        i = 10\n    self._ToolChainFamily = TAB_COMPILER_MSFT\n    TargetObj = TargetTxtDict()\n    TargetTxt = TargetObj.Target\n    BuildConfigurationFile = os.path.normpath(os.path.join(GlobalData.gConfDirectory, gDefaultTargetTxtFile))\n    if os.path.isfile(BuildConfigurationFile) == True:\n        ToolDefinitionFile = TargetTxt.TargetTxtDictionary[DataType.TAB_TAT_DEFINES_TOOL_CHAIN_CONF]\n        if ToolDefinitionFile == '':\n            ToolDefinitionFile = os.path.normpath(mws.join(self.WorkspaceDir, 'Conf', gDefaultToolsDefFile))\n        if os.path.isfile(ToolDefinitionFile) == True:\n            ToolDefObj = ToolDefDict(os.path.join(os.getenv('WORKSPACE'), 'Conf'))\n            ToolDefinition = ToolDefObj.ToolDef.ToolsDefTxtDatabase\n            if TAB_TOD_DEFINES_FAMILY not in ToolDefinition or self._Toolchain not in ToolDefinition[TAB_TOD_DEFINES_FAMILY] or (not ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]):\n                self._ToolChainFamily = TAB_COMPILER_MSFT\n            else:\n                self._ToolChainFamily = ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]\n    return self._ToolChainFamily",
            "@property\ndef ToolChainFamily(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._ToolChainFamily = TAB_COMPILER_MSFT\n    TargetObj = TargetTxtDict()\n    TargetTxt = TargetObj.Target\n    BuildConfigurationFile = os.path.normpath(os.path.join(GlobalData.gConfDirectory, gDefaultTargetTxtFile))\n    if os.path.isfile(BuildConfigurationFile) == True:\n        ToolDefinitionFile = TargetTxt.TargetTxtDictionary[DataType.TAB_TAT_DEFINES_TOOL_CHAIN_CONF]\n        if ToolDefinitionFile == '':\n            ToolDefinitionFile = os.path.normpath(mws.join(self.WorkspaceDir, 'Conf', gDefaultToolsDefFile))\n        if os.path.isfile(ToolDefinitionFile) == True:\n            ToolDefObj = ToolDefDict(os.path.join(os.getenv('WORKSPACE'), 'Conf'))\n            ToolDefinition = ToolDefObj.ToolDef.ToolsDefTxtDatabase\n            if TAB_TOD_DEFINES_FAMILY not in ToolDefinition or self._Toolchain not in ToolDefinition[TAB_TOD_DEFINES_FAMILY] or (not ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]):\n                self._ToolChainFamily = TAB_COMPILER_MSFT\n            else:\n                self._ToolChainFamily = ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]\n    return self._ToolChainFamily",
            "@property\ndef ToolChainFamily(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._ToolChainFamily = TAB_COMPILER_MSFT\n    TargetObj = TargetTxtDict()\n    TargetTxt = TargetObj.Target\n    BuildConfigurationFile = os.path.normpath(os.path.join(GlobalData.gConfDirectory, gDefaultTargetTxtFile))\n    if os.path.isfile(BuildConfigurationFile) == True:\n        ToolDefinitionFile = TargetTxt.TargetTxtDictionary[DataType.TAB_TAT_DEFINES_TOOL_CHAIN_CONF]\n        if ToolDefinitionFile == '':\n            ToolDefinitionFile = os.path.normpath(mws.join(self.WorkspaceDir, 'Conf', gDefaultToolsDefFile))\n        if os.path.isfile(ToolDefinitionFile) == True:\n            ToolDefObj = ToolDefDict(os.path.join(os.getenv('WORKSPACE'), 'Conf'))\n            ToolDefinition = ToolDefObj.ToolDef.ToolsDefTxtDatabase\n            if TAB_TOD_DEFINES_FAMILY not in ToolDefinition or self._Toolchain not in ToolDefinition[TAB_TOD_DEFINES_FAMILY] or (not ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]):\n                self._ToolChainFamily = TAB_COMPILER_MSFT\n            else:\n                self._ToolChainFamily = ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]\n    return self._ToolChainFamily",
            "@property\ndef ToolChainFamily(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._ToolChainFamily = TAB_COMPILER_MSFT\n    TargetObj = TargetTxtDict()\n    TargetTxt = TargetObj.Target\n    BuildConfigurationFile = os.path.normpath(os.path.join(GlobalData.gConfDirectory, gDefaultTargetTxtFile))\n    if os.path.isfile(BuildConfigurationFile) == True:\n        ToolDefinitionFile = TargetTxt.TargetTxtDictionary[DataType.TAB_TAT_DEFINES_TOOL_CHAIN_CONF]\n        if ToolDefinitionFile == '':\n            ToolDefinitionFile = os.path.normpath(mws.join(self.WorkspaceDir, 'Conf', gDefaultToolsDefFile))\n        if os.path.isfile(ToolDefinitionFile) == True:\n            ToolDefObj = ToolDefDict(os.path.join(os.getenv('WORKSPACE'), 'Conf'))\n            ToolDefinition = ToolDefObj.ToolDef.ToolsDefTxtDatabase\n            if TAB_TOD_DEFINES_FAMILY not in ToolDefinition or self._Toolchain not in ToolDefinition[TAB_TOD_DEFINES_FAMILY] or (not ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]):\n                self._ToolChainFamily = TAB_COMPILER_MSFT\n            else:\n                self._ToolChainFamily = ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]\n    return self._ToolChainFamily",
            "@property\ndef ToolChainFamily(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._ToolChainFamily = TAB_COMPILER_MSFT\n    TargetObj = TargetTxtDict()\n    TargetTxt = TargetObj.Target\n    BuildConfigurationFile = os.path.normpath(os.path.join(GlobalData.gConfDirectory, gDefaultTargetTxtFile))\n    if os.path.isfile(BuildConfigurationFile) == True:\n        ToolDefinitionFile = TargetTxt.TargetTxtDictionary[DataType.TAB_TAT_DEFINES_TOOL_CHAIN_CONF]\n        if ToolDefinitionFile == '':\n            ToolDefinitionFile = os.path.normpath(mws.join(self.WorkspaceDir, 'Conf', gDefaultToolsDefFile))\n        if os.path.isfile(ToolDefinitionFile) == True:\n            ToolDefObj = ToolDefDict(os.path.join(os.getenv('WORKSPACE'), 'Conf'))\n            ToolDefinition = ToolDefObj.ToolDef.ToolsDefTxtDatabase\n            if TAB_TOD_DEFINES_FAMILY not in ToolDefinition or self._Toolchain not in ToolDefinition[TAB_TOD_DEFINES_FAMILY] or (not ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]):\n                self._ToolChainFamily = TAB_COMPILER_MSFT\n            else:\n                self._ToolChainFamily = ToolDefinition[TAB_TOD_DEFINES_FAMILY][self._Toolchain]\n    return self._ToolChainFamily"
        ]
    },
    {
        "func_name": "AddPcd",
        "original": "def AddPcd(self, Name, Guid, Value):\n    if (Name, Guid) not in self.Pcds:\n        self.Pcds[Name, Guid] = PcdClassObject(Name, Guid, '', '', '', '', '', {}, False, None)\n    self.Pcds[Name, Guid].DefaultValue = Value",
        "mutated": [
            "def AddPcd(self, Name, Guid, Value):\n    if False:\n        i = 10\n    if (Name, Guid) not in self.Pcds:\n        self.Pcds[Name, Guid] = PcdClassObject(Name, Guid, '', '', '', '', '', {}, False, None)\n    self.Pcds[Name, Guid].DefaultValue = Value",
            "def AddPcd(self, Name, Guid, Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if (Name, Guid) not in self.Pcds:\n        self.Pcds[Name, Guid] = PcdClassObject(Name, Guid, '', '', '', '', '', {}, False, None)\n    self.Pcds[Name, Guid].DefaultValue = Value",
            "def AddPcd(self, Name, Guid, Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if (Name, Guid) not in self.Pcds:\n        self.Pcds[Name, Guid] = PcdClassObject(Name, Guid, '', '', '', '', '', {}, False, None)\n    self.Pcds[Name, Guid].DefaultValue = Value",
            "def AddPcd(self, Name, Guid, Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if (Name, Guid) not in self.Pcds:\n        self.Pcds[Name, Guid] = PcdClassObject(Name, Guid, '', '', '', '', '', {}, False, None)\n    self.Pcds[Name, Guid].DefaultValue = Value",
            "def AddPcd(self, Name, Guid, Value):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if (Name, Guid) not in self.Pcds:\n        self.Pcds[Name, Guid] = PcdClassObject(Name, Guid, '', '', '', '', '', {}, False, None)\n    self.Pcds[Name, Guid].DefaultValue = Value"
        ]
    },
    {
        "func_name": "DecPcds",
        "original": "@property\ndef DecPcds(self):\n    if self._DecPcds is None:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    return self._DecPcds",
        "mutated": [
            "@property\ndef DecPcds(self):\n    if False:\n        i = 10\n    if self._DecPcds is None:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    return self._DecPcds",
            "@property\ndef DecPcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self._DecPcds is None:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    return self._DecPcds",
            "@property\ndef DecPcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self._DecPcds is None:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    return self._DecPcds",
            "@property\ndef DecPcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self._DecPcds is None:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    return self._DecPcds",
            "@property\ndef DecPcds(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self._DecPcds is None:\n        FdfInfList = []\n        if GlobalData.gFdfParser:\n            FdfInfList = GlobalData.gFdfParser.Profile.InfList\n        PkgSet = set()\n        for Inf in FdfInfList:\n            ModuleFile = PathClass(NormPath(Inf), GlobalData.gWorkspace, Arch=self._Arch)\n            if ModuleFile in self._Modules:\n                continue\n            ModuleData = self._Bdb[ModuleFile, self._Arch, self._Target, self._Toolchain]\n            PkgSet.update(ModuleData.Packages)\n        if self.Packages:\n            PkgSet.update(self.Packages)\n        (self._DecPcds, self._GuidDict) = GetDeclaredPcd(self, self._Bdb, self._Arch, self._Target, self._Toolchain, PkgSet)\n        self._GuidDict.update(GlobalData.gPlatformPcds)\n    return self._DecPcds"
        ]
    }
]