[
    {
        "func_name": "minNumberOfSemesters",
        "original": "def minNumberOfSemesters(self, n, dependencies, k):\n    \"\"\"\n        :type n: int\n        :type dependencies: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n    reqs = [0] * n\n    for (u, v) in dependencies:\n        reqs[v - 1] |= 1 << u - 1\n    dp = [n] * (1 << n)\n    dp[0] = 0\n    for mask in xrange(1 << n):\n        candidates = []\n        for v in xrange(n):\n            if mask & 1 << v == 0 and mask & reqs[v] == reqs[v]:\n                candidates.append(v)\n        for choice in itertools.combinations(candidates, min(len(candidates), k)):\n            new_mask = mask\n            for v in choice:\n                new_mask |= 1 << v\n            dp[new_mask] = min(dp[new_mask], dp[mask] + 1)\n    return dp[-1]",
        "mutated": [
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n    reqs = [0] * n\n    for (u, v) in dependencies:\n        reqs[v - 1] |= 1 << u - 1\n    dp = [n] * (1 << n)\n    dp[0] = 0\n    for mask in xrange(1 << n):\n        candidates = []\n        for v in xrange(n):\n            if mask & 1 << v == 0 and mask & reqs[v] == reqs[v]:\n                candidates.append(v)\n        for choice in itertools.combinations(candidates, min(len(candidates), k)):\n            new_mask = mask\n            for v in choice:\n                new_mask |= 1 << v\n            dp[new_mask] = min(dp[new_mask], dp[mask] + 1)\n    return dp[-1]",
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n    reqs = [0] * n\n    for (u, v) in dependencies:\n        reqs[v - 1] |= 1 << u - 1\n    dp = [n] * (1 << n)\n    dp[0] = 0\n    for mask in xrange(1 << n):\n        candidates = []\n        for v in xrange(n):\n            if mask & 1 << v == 0 and mask & reqs[v] == reqs[v]:\n                candidates.append(v)\n        for choice in itertools.combinations(candidates, min(len(candidates), k)):\n            new_mask = mask\n            for v in choice:\n                new_mask |= 1 << v\n            dp[new_mask] = min(dp[new_mask], dp[mask] + 1)\n    return dp[-1]",
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n    reqs = [0] * n\n    for (u, v) in dependencies:\n        reqs[v - 1] |= 1 << u - 1\n    dp = [n] * (1 << n)\n    dp[0] = 0\n    for mask in xrange(1 << n):\n        candidates = []\n        for v in xrange(n):\n            if mask & 1 << v == 0 and mask & reqs[v] == reqs[v]:\n                candidates.append(v)\n        for choice in itertools.combinations(candidates, min(len(candidates), k)):\n            new_mask = mask\n            for v in choice:\n                new_mask |= 1 << v\n            dp[new_mask] = min(dp[new_mask], dp[mask] + 1)\n    return dp[-1]",
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n    reqs = [0] * n\n    for (u, v) in dependencies:\n        reqs[v - 1] |= 1 << u - 1\n    dp = [n] * (1 << n)\n    dp[0] = 0\n    for mask in xrange(1 << n):\n        candidates = []\n        for v in xrange(n):\n            if mask & 1 << v == 0 and mask & reqs[v] == reqs[v]:\n                candidates.append(v)\n        for choice in itertools.combinations(candidates, min(len(candidates), k)):\n            new_mask = mask\n            for v in choice:\n                new_mask |= 1 << v\n            dp[new_mask] = min(dp[new_mask], dp[mask] + 1)\n    return dp[-1]",
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n    reqs = [0] * n\n    for (u, v) in dependencies:\n        reqs[v - 1] |= 1 << u - 1\n    dp = [n] * (1 << n)\n    dp[0] = 0\n    for mask in xrange(1 << n):\n        candidates = []\n        for v in xrange(n):\n            if mask & 1 << v == 0 and mask & reqs[v] == reqs[v]:\n                candidates.append(v)\n        for choice in itertools.combinations(candidates, min(len(candidates), k)):\n            new_mask = mask\n            for v in choice:\n                new_mask |= 1 << v\n            dp[new_mask] = min(dp[new_mask], dp[mask] + 1)\n    return dp[-1]"
        ]
    },
    {
        "func_name": "dfs",
        "original": "def dfs(graph, i, depths):\n    if depths[i] == -1:\n        depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n    return depths[i]",
        "mutated": [
            "def dfs(graph, i, depths):\n    if False:\n        i = 10\n    if depths[i] == -1:\n        depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n    return depths[i]",
            "def dfs(graph, i, depths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if depths[i] == -1:\n        depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n    return depths[i]",
            "def dfs(graph, i, depths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if depths[i] == -1:\n        depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n    return depths[i]",
            "def dfs(graph, i, depths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if depths[i] == -1:\n        depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n    return depths[i]",
            "def dfs(graph, i, depths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if depths[i] == -1:\n        depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n    return depths[i]"
        ]
    },
    {
        "func_name": "minNumberOfSemesters",
        "original": "def minNumberOfSemesters(self, n, dependencies, k):\n    \"\"\"\n        :type n: int\n        :type dependencies: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n\n    def dfs(graph, i, depths):\n        if depths[i] == -1:\n            depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n        return depths[i]\n    degrees = [0] * n\n    graph = collections.defaultdict(list)\n    for (u, v) in dependencies:\n        graph[u - 1].append(v - 1)\n        degrees[v - 1] += 1\n    depths = [-1] * n\n    for i in xrange(n):\n        dfs(graph, i, depths)\n    max_heap = []\n    for i in xrange(n):\n        if not degrees[i]:\n            heapq.heappush(max_heap, (-depths[i], i))\n    result = 0\n    while max_heap:\n        new_q = []\n        for _ in xrange(min(len(max_heap), k)):\n            (_, node) = heapq.heappop(max_heap)\n            if node not in graph:\n                continue\n            for child in graph[node]:\n                degrees[child] -= 1\n                if not degrees[child]:\n                    new_q.append(child)\n        result += 1\n        for node in new_q:\n            heapq.heappush(max_heap, (-depths[node], node))\n    return result",
        "mutated": [
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def dfs(graph, i, depths):\n        if depths[i] == -1:\n            depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n        return depths[i]\n    degrees = [0] * n\n    graph = collections.defaultdict(list)\n    for (u, v) in dependencies:\n        graph[u - 1].append(v - 1)\n        degrees[v - 1] += 1\n    depths = [-1] * n\n    for i in xrange(n):\n        dfs(graph, i, depths)\n    max_heap = []\n    for i in xrange(n):\n        if not degrees[i]:\n            heapq.heappush(max_heap, (-depths[i], i))\n    result = 0\n    while max_heap:\n        new_q = []\n        for _ in xrange(min(len(max_heap), k)):\n            (_, node) = heapq.heappop(max_heap)\n            if node not in graph:\n                continue\n            for child in graph[node]:\n                degrees[child] -= 1\n                if not degrees[child]:\n                    new_q.append(child)\n        result += 1\n        for node in new_q:\n            heapq.heappush(max_heap, (-depths[node], node))\n    return result",
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def dfs(graph, i, depths):\n        if depths[i] == -1:\n            depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n        return depths[i]\n    degrees = [0] * n\n    graph = collections.defaultdict(list)\n    for (u, v) in dependencies:\n        graph[u - 1].append(v - 1)\n        degrees[v - 1] += 1\n    depths = [-1] * n\n    for i in xrange(n):\n        dfs(graph, i, depths)\n    max_heap = []\n    for i in xrange(n):\n        if not degrees[i]:\n            heapq.heappush(max_heap, (-depths[i], i))\n    result = 0\n    while max_heap:\n        new_q = []\n        for _ in xrange(min(len(max_heap), k)):\n            (_, node) = heapq.heappop(max_heap)\n            if node not in graph:\n                continue\n            for child in graph[node]:\n                degrees[child] -= 1\n                if not degrees[child]:\n                    new_q.append(child)\n        result += 1\n        for node in new_q:\n            heapq.heappush(max_heap, (-depths[node], node))\n    return result",
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def dfs(graph, i, depths):\n        if depths[i] == -1:\n            depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n        return depths[i]\n    degrees = [0] * n\n    graph = collections.defaultdict(list)\n    for (u, v) in dependencies:\n        graph[u - 1].append(v - 1)\n        degrees[v - 1] += 1\n    depths = [-1] * n\n    for i in xrange(n):\n        dfs(graph, i, depths)\n    max_heap = []\n    for i in xrange(n):\n        if not degrees[i]:\n            heapq.heappush(max_heap, (-depths[i], i))\n    result = 0\n    while max_heap:\n        new_q = []\n        for _ in xrange(min(len(max_heap), k)):\n            (_, node) = heapq.heappop(max_heap)\n            if node not in graph:\n                continue\n            for child in graph[node]:\n                degrees[child] -= 1\n                if not degrees[child]:\n                    new_q.append(child)\n        result += 1\n        for node in new_q:\n            heapq.heappush(max_heap, (-depths[node], node))\n    return result",
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def dfs(graph, i, depths):\n        if depths[i] == -1:\n            depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n        return depths[i]\n    degrees = [0] * n\n    graph = collections.defaultdict(list)\n    for (u, v) in dependencies:\n        graph[u - 1].append(v - 1)\n        degrees[v - 1] += 1\n    depths = [-1] * n\n    for i in xrange(n):\n        dfs(graph, i, depths)\n    max_heap = []\n    for i in xrange(n):\n        if not degrees[i]:\n            heapq.heappush(max_heap, (-depths[i], i))\n    result = 0\n    while max_heap:\n        new_q = []\n        for _ in xrange(min(len(max_heap), k)):\n            (_, node) = heapq.heappop(max_heap)\n            if node not in graph:\n                continue\n            for child in graph[node]:\n                degrees[child] -= 1\n                if not degrees[child]:\n                    new_q.append(child)\n        result += 1\n        for node in new_q:\n            heapq.heappush(max_heap, (-depths[node], node))\n    return result",
            "def minNumberOfSemesters(self, n, dependencies, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type n: int\\n        :type dependencies: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        '\n\n    def dfs(graph, i, depths):\n        if depths[i] == -1:\n            depths[i] = max((dfs(graph, child, depths) for child in graph[i])) + 1 if i in graph else 1\n        return depths[i]\n    degrees = [0] * n\n    graph = collections.defaultdict(list)\n    for (u, v) in dependencies:\n        graph[u - 1].append(v - 1)\n        degrees[v - 1] += 1\n    depths = [-1] * n\n    for i in xrange(n):\n        dfs(graph, i, depths)\n    max_heap = []\n    for i in xrange(n):\n        if not degrees[i]:\n            heapq.heappush(max_heap, (-depths[i], i))\n    result = 0\n    while max_heap:\n        new_q = []\n        for _ in xrange(min(len(max_heap), k)):\n            (_, node) = heapq.heappop(max_heap)\n            if node not in graph:\n                continue\n            for child in graph[node]:\n                degrees[child] -= 1\n                if not degrees[child]:\n                    new_q.append(child)\n        result += 1\n        for node in new_q:\n            heapq.heappush(max_heap, (-depths[node], node))\n    return result"
        ]
    }
]