[
    {
        "func_name": "dot_plot",
        "original": "def dot_plot(points, intervals=None, lines=None, sections=None, styles=None, marker_props=None, line_props=None, split_names=None, section_order=None, line_order=None, stacked=False, styles_order=None, striped=False, horizontal=True, show_names='both', fmt_left_name=None, fmt_right_name=None, show_section_titles=None, ax=None):\n    \"\"\"\n    Dot plotting (also known as forest and blobbogram).\n\n    Produce a dotplot similar in style to those in Cleveland's\n    \"Visualizing Data\" book ([1]_).  These are also known as \"forest plots\".\n\n    Parameters\n    ----------\n    points : array_like\n        The quantitative values to be plotted as markers.\n    intervals : array_like\n        The intervals to be plotted around the points.  The elements\n        of `intervals` are either scalars or sequences of length 2.  A\n        scalar indicates the half width of a symmetric interval.  A\n        sequence of length 2 contains the left and right half-widths\n        (respectively) of a nonsymmetric interval.  If None, no\n        intervals are drawn.\n    lines : array_like\n        A grouping variable indicating which points/intervals are\n        drawn on a common line.  If None, each point/interval appears\n        on its own line.\n    sections : array_like\n        A grouping variable indicating which lines are grouped into\n        sections.  If None, everything is drawn in a single section.\n    styles : array_like\n        A grouping label defining the plotting style of the markers\n        and intervals.\n    marker_props : dict\n        A dictionary mapping style codes (the values in `styles`) to\n        dictionaries defining key/value pairs to be passed as keyword\n        arguments to `plot` when plotting markers.  Useful keyword\n        arguments are \"color\", \"marker\", and \"ms\" (marker size).\n    line_props : dict\n        A dictionary mapping style codes (the values in `styles`) to\n        dictionaries defining key/value pairs to be passed as keyword\n        arguments to `plot` when plotting interval lines.  Useful\n        keyword arguments are \"color\", \"linestyle\", \"solid_capstyle\",\n        and \"linewidth\".\n    split_names : str\n        If not None, this is used to split the values of `lines` into\n        substrings that are drawn in the left and right margins,\n        respectively.  If None, the values of `lines` are drawn in the\n        left margin.\n    section_order : array_like\n        The section labels in the order in which they appear in the\n        dotplot.\n    line_order : array_like\n        The line labels in the order in which they appear in the\n        dotplot.\n    stacked : bool\n        If True, when multiple points or intervals are drawn on the\n        same line, they are offset from each other.\n    styles_order : array_like\n        If stacked=True, this is the order in which the point styles\n        on a given line are drawn from top to bottom (if horizontal\n        is True) or from left to right (if horizontal is False).  If\n        None (default), the order is lexical.\n    striped : bool\n        If True, every other line is enclosed in a shaded box.\n    horizontal : bool\n        If True (default), the lines are drawn horizontally, otherwise\n        they are drawn vertically.\n    show_names : str\n        Determines whether labels (names) are shown in the left and/or\n        right margins (top/bottom margins if `horizontal` is True).\n        If `both`, labels are drawn in both margins, if 'left', labels\n        are drawn in the left or top margin.  If `right`, labels are\n        drawn in the right or bottom margin.\n    fmt_left_name : callable\n        The left/top margin names are passed through this function\n        before drawing on the plot.\n    fmt_right_name : callable\n        The right/bottom marginnames are passed through this function\n        before drawing on the plot.\n    show_section_titles : bool or None\n        If None, section titles are drawn only if there is more than\n        one section.  If False/True, section titles are never/always\n        drawn, respectively.\n    ax : matplotlib.axes\n        The axes on which the dotplot is drawn.  If None, a new axes\n        is created.\n\n    Returns\n    -------\n    fig : Figure\n        The figure given by `ax.figure` or a new instance.\n\n    Notes\n    -----\n    `points`, `intervals`, `lines`, `sections`, `styles` must all have\n    the same length whenever present.\n\n    References\n    ----------\n    .. [1] Cleveland, William S. (1993). \"Visualizing Data\". Hobart Press.\n    .. [2] Jacoby, William G. (2006) \"The Dot Plot: A Graphical Display\n       for Labeled Quantitative Values.\" The Political Methodologist\n       14(1): 6-14.\n\n    Examples\n    --------\n    This is a simple dotplot with one point per line:\n\n    >>> dot_plot(points=point_values)\n\n    This dotplot has labels on the lines (if elements in\n    `label_values` are repeated, the corresponding points appear on\n    the same line):\n\n    >>> dot_plot(points=point_values, lines=label_values)\n    \"\"\"\n    import matplotlib.transforms as transforms\n    (fig, ax) = utils.create_mpl_ax(ax)\n    points = np.asarray(points)\n    asarray_or_none = lambda x: None if x is None else np.asarray(x)\n    intervals = asarray_or_none(intervals)\n    lines = asarray_or_none(lines)\n    sections = asarray_or_none(sections)\n    styles = asarray_or_none(styles)\n    npoint = len(points)\n    if lines is None:\n        lines = np.arange(npoint)\n    if sections is None:\n        sections = np.zeros(npoint)\n    if styles is None:\n        styles = np.zeros(npoint)\n    section_title_space = 0.5\n    nsect = len(set(sections))\n    if section_order is not None:\n        nsect = len(set(section_order))\n    if show_section_titles is False:\n        draw_section_titles = False\n        nsect_title = 0\n    elif show_section_titles is True:\n        draw_section_titles = True\n        nsect_title = nsect\n    else:\n        draw_section_titles = nsect > 1\n        nsect_title = nsect if nsect > 1 else 0\n    section_space_total = section_title_space * nsect_title\n    ax.set_xmargin(0.02)\n    ax.set_ymargin(0.02)\n    if section_order is None:\n        lines0 = list(set(sections))\n        lines0.sort()\n    else:\n        lines0 = section_order\n    if line_order is None:\n        lines1 = list(set(lines))\n        lines1.sort()\n    else:\n        lines1 = line_order\n    lines_map = {}\n    for i in range(npoint):\n        if section_order is not None and sections[i] not in section_order:\n            continue\n        if line_order is not None and lines[i] not in line_order:\n            continue\n        ky = (sections[i], lines[i])\n        if ky not in lines_map:\n            lines_map[ky] = []\n        lines_map[ky].append(i)\n    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n    (awidth, aheight) = (bbox.width, bbox.height)\n    nrows = len(lines_map)\n    (bottom, top) = (0, 1)\n    if horizontal:\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    else:\n        trans = transforms.blended_transform_factory(ax.transAxes, ax.transData)\n    title_space_axes = section_title_space / aheight\n    if horizontal:\n        dpos = (top - bottom - nsect_title * title_space_axes) / float(nrows)\n    else:\n        dpos = (top - bottom) / float(nrows)\n    if styles_order is not None:\n        style_codes = styles_order\n    else:\n        style_codes = list(set(styles))\n        style_codes.sort()\n    if horizontal:\n        style_codes = style_codes[::-1]\n    nval = len(style_codes)\n    if nval > 1:\n        stackd = dpos / (2.5 * (float(nval) - 1))\n    else:\n        stackd = 0.0\n    style_codes_map = {x: style_codes.index(x) for x in style_codes}\n    colors = ['r', 'g', 'b', 'y', 'k', 'purple', 'orange']\n    if marker_props is None:\n        marker_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in marker_props[sc]:\n            marker_props[sc]['color'] = colors[j % len(colors)]\n        if 'marker' not in marker_props[sc]:\n            marker_props[sc]['marker'] = 'o'\n        if 'ms' not in marker_props[sc]:\n            marker_props[sc]['ms'] = 10 if stackd == 0 else 6\n    if line_props is None:\n        line_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in line_props[sc]:\n            line_props[sc]['color'] = 'grey'\n        if 'linewidth' not in line_props[sc]:\n            line_props[sc]['linewidth'] = 2 if stackd > 0 else 8\n    if horizontal:\n        pos = top - dpos / 2 if nsect == 1 else top\n    else:\n        pos = bottom + dpos / 2\n    labeled = set()\n    ticks = []\n    for k0 in lines0:\n        if draw_section_titles:\n            if horizontal:\n                y0 = pos + dpos / 2 if k0 == lines0[0] else pos\n                ax.fill_between((0, 1), (y0, y0), (pos - 0.7 * title_space_axes, pos - 0.7 * title_space_axes), color='darkgrey', transform=ax.transAxes, zorder=1)\n                txt = ax.text(0.5, pos - 0.35 * title_space_axes, k0, horizontalalignment='center', verticalalignment='center', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n                pos -= title_space_axes\n            else:\n                m = len([k for k in lines_map if k[0] == k0])\n                ax.fill_between((pos - dpos / 2 + 0.01, pos + (m - 1) * dpos + dpos / 2 - 0.01), (1.01, 1.01), (1.06, 1.06), color='darkgrey', transform=ax.transAxes, zorder=1, clip_on=False)\n                txt = ax.text(pos + (m - 1) * dpos / 2, 1.02, k0, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n        jrow = 0\n        for k1 in lines1:\n            if (k0, k1) not in lines_map:\n                continue\n            if horizontal:\n                ax.axhline(pos, color='grey')\n            else:\n                ax.axvline(pos, color='grey')\n            if split_names is not None:\n                us = k1.split(split_names)\n                if len(us) >= 2:\n                    (left_label, right_label) = (us[0], us[1])\n                else:\n                    (left_label, right_label) = (k1, None)\n            else:\n                (left_label, right_label) = (k1, None)\n            if fmt_left_name is not None:\n                left_label = fmt_left_name(left_label)\n            if fmt_right_name is not None:\n                right_label = fmt_right_name(right_label)\n            if striped and jrow % 2 == 0:\n                if horizontal:\n                    ax.fill_between((0, 1), (pos - dpos / 2, pos - dpos / 2), (pos + dpos / 2, pos + dpos / 2), color='lightgrey', transform=ax.transAxes, zorder=0)\n                else:\n                    ax.fill_between((pos - dpos / 2, pos + dpos / 2), (0, 0), (1, 1), color='lightgrey', transform=ax.transAxes, zorder=0)\n            jrow += 1\n            if show_names.lower() in ('left', 'both'):\n                if horizontal:\n                    ax.text(-0.1 / awidth, pos, left_label, horizontalalignment='right', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                else:\n                    ax.text(pos, -0.1 / aheight, left_label, horizontalalignment='center', verticalalignment='top', transform=ax.transAxes, family='monospace')\n            if show_names.lower() in ('right', 'both'):\n                if right_label is not None:\n                    if horizontal:\n                        ax.text(1 + 0.1 / awidth, pos, right_label, horizontalalignment='left', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                    else:\n                        ax.text(pos, 1 + 0.1 / aheight, right_label, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes, family='monospace')\n            ticks.append(pos)\n            for (ji, jp) in enumerate(lines_map[k0, k1]):\n                yo = 0\n                if stacked:\n                    yo = -dpos / 5 + style_codes_map[styles[jp]] * stackd\n                pt = points[jp]\n                if intervals is not None:\n                    if np.isscalar(intervals[jp]):\n                        (lcb, ucb) = (pt - intervals[jp], pt + intervals[jp])\n                    else:\n                        (lcb, ucb) = (pt - intervals[jp][0], pt + intervals[jp][1])\n                    if horizontal:\n                        ax.plot([lcb, ucb], [pos + yo, pos + yo], '-', transform=trans, **line_props[styles[jp]])\n                    else:\n                        ax.plot([pos + yo, pos + yo], [lcb, ucb], '-', transform=trans, **line_props[styles[jp]])\n                sl = styles[jp]\n                sll = sl if sl not in labeled else None\n                labeled.add(sl)\n                if horizontal:\n                    ax.plot([pt], [pos + yo], ls='None', transform=trans, label=sll, **marker_props[sl])\n                else:\n                    ax.plot([pos + yo], [pt], ls='None', transform=trans, label=sll, **marker_props[sl])\n            if horizontal:\n                pos -= dpos\n            else:\n                pos += dpos\n    if horizontal:\n        ax.xaxis.set_ticks_position('bottom')\n        ax.yaxis.set_ticks_position('none')\n        ax.set_yticklabels([])\n        ax.spines['left'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['bottom'].set_position(('axes', -0.1 / aheight))\n        ax.set_ylim(0, 1)\n        ax.yaxis.set_ticks(ticks)\n        ax.autoscale_view(scaley=False, tight=True)\n    else:\n        ax.yaxis.set_ticks_position('left')\n        ax.xaxis.set_ticks_position('none')\n        ax.set_xticklabels([])\n        ax.spines['bottom'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['left'].set_position(('axes', -0.1 / awidth))\n        ax.set_xlim(0, 1)\n        ax.xaxis.set_ticks(ticks)\n        ax.autoscale_view(scalex=False, tight=True)\n    return fig",
        "mutated": [
            "def dot_plot(points, intervals=None, lines=None, sections=None, styles=None, marker_props=None, line_props=None, split_names=None, section_order=None, line_order=None, stacked=False, styles_order=None, striped=False, horizontal=True, show_names='both', fmt_left_name=None, fmt_right_name=None, show_section_titles=None, ax=None):\n    if False:\n        i = 10\n    '\\n    Dot plotting (also known as forest and blobbogram).\\n\\n    Produce a dotplot similar in style to those in Cleveland\\'s\\n    \"Visualizing Data\" book ([1]_).  These are also known as \"forest plots\".\\n\\n    Parameters\\n    ----------\\n    points : array_like\\n        The quantitative values to be plotted as markers.\\n    intervals : array_like\\n        The intervals to be plotted around the points.  The elements\\n        of `intervals` are either scalars or sequences of length 2.  A\\n        scalar indicates the half width of a symmetric interval.  A\\n        sequence of length 2 contains the left and right half-widths\\n        (respectively) of a nonsymmetric interval.  If None, no\\n        intervals are drawn.\\n    lines : array_like\\n        A grouping variable indicating which points/intervals are\\n        drawn on a common line.  If None, each point/interval appears\\n        on its own line.\\n    sections : array_like\\n        A grouping variable indicating which lines are grouped into\\n        sections.  If None, everything is drawn in a single section.\\n    styles : array_like\\n        A grouping label defining the plotting style of the markers\\n        and intervals.\\n    marker_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting markers.  Useful keyword\\n        arguments are \"color\", \"marker\", and \"ms\" (marker size).\\n    line_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting interval lines.  Useful\\n        keyword arguments are \"color\", \"linestyle\", \"solid_capstyle\",\\n        and \"linewidth\".\\n    split_names : str\\n        If not None, this is used to split the values of `lines` into\\n        substrings that are drawn in the left and right margins,\\n        respectively.  If None, the values of `lines` are drawn in the\\n        left margin.\\n    section_order : array_like\\n        The section labels in the order in which they appear in the\\n        dotplot.\\n    line_order : array_like\\n        The line labels in the order in which they appear in the\\n        dotplot.\\n    stacked : bool\\n        If True, when multiple points or intervals are drawn on the\\n        same line, they are offset from each other.\\n    styles_order : array_like\\n        If stacked=True, this is the order in which the point styles\\n        on a given line are drawn from top to bottom (if horizontal\\n        is True) or from left to right (if horizontal is False).  If\\n        None (default), the order is lexical.\\n    striped : bool\\n        If True, every other line is enclosed in a shaded box.\\n    horizontal : bool\\n        If True (default), the lines are drawn horizontally, otherwise\\n        they are drawn vertically.\\n    show_names : str\\n        Determines whether labels (names) are shown in the left and/or\\n        right margins (top/bottom margins if `horizontal` is True).\\n        If `both`, labels are drawn in both margins, if \\'left\\', labels\\n        are drawn in the left or top margin.  If `right`, labels are\\n        drawn in the right or bottom margin.\\n    fmt_left_name : callable\\n        The left/top margin names are passed through this function\\n        before drawing on the plot.\\n    fmt_right_name : callable\\n        The right/bottom marginnames are passed through this function\\n        before drawing on the plot.\\n    show_section_titles : bool or None\\n        If None, section titles are drawn only if there is more than\\n        one section.  If False/True, section titles are never/always\\n        drawn, respectively.\\n    ax : matplotlib.axes\\n        The axes on which the dotplot is drawn.  If None, a new axes\\n        is created.\\n\\n    Returns\\n    -------\\n    fig : Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Notes\\n    -----\\n    `points`, `intervals`, `lines`, `sections`, `styles` must all have\\n    the same length whenever present.\\n\\n    References\\n    ----------\\n    .. [1] Cleveland, William S. (1993). \"Visualizing Data\". Hobart Press.\\n    .. [2] Jacoby, William G. (2006) \"The Dot Plot: A Graphical Display\\n       for Labeled Quantitative Values.\" The Political Methodologist\\n       14(1): 6-14.\\n\\n    Examples\\n    --------\\n    This is a simple dotplot with one point per line:\\n\\n    >>> dot_plot(points=point_values)\\n\\n    This dotplot has labels on the lines (if elements in\\n    `label_values` are repeated, the corresponding points appear on\\n    the same line):\\n\\n    >>> dot_plot(points=point_values, lines=label_values)\\n    '\n    import matplotlib.transforms as transforms\n    (fig, ax) = utils.create_mpl_ax(ax)\n    points = np.asarray(points)\n    asarray_or_none = lambda x: None if x is None else np.asarray(x)\n    intervals = asarray_or_none(intervals)\n    lines = asarray_or_none(lines)\n    sections = asarray_or_none(sections)\n    styles = asarray_or_none(styles)\n    npoint = len(points)\n    if lines is None:\n        lines = np.arange(npoint)\n    if sections is None:\n        sections = np.zeros(npoint)\n    if styles is None:\n        styles = np.zeros(npoint)\n    section_title_space = 0.5\n    nsect = len(set(sections))\n    if section_order is not None:\n        nsect = len(set(section_order))\n    if show_section_titles is False:\n        draw_section_titles = False\n        nsect_title = 0\n    elif show_section_titles is True:\n        draw_section_titles = True\n        nsect_title = nsect\n    else:\n        draw_section_titles = nsect > 1\n        nsect_title = nsect if nsect > 1 else 0\n    section_space_total = section_title_space * nsect_title\n    ax.set_xmargin(0.02)\n    ax.set_ymargin(0.02)\n    if section_order is None:\n        lines0 = list(set(sections))\n        lines0.sort()\n    else:\n        lines0 = section_order\n    if line_order is None:\n        lines1 = list(set(lines))\n        lines1.sort()\n    else:\n        lines1 = line_order\n    lines_map = {}\n    for i in range(npoint):\n        if section_order is not None and sections[i] not in section_order:\n            continue\n        if line_order is not None and lines[i] not in line_order:\n            continue\n        ky = (sections[i], lines[i])\n        if ky not in lines_map:\n            lines_map[ky] = []\n        lines_map[ky].append(i)\n    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n    (awidth, aheight) = (bbox.width, bbox.height)\n    nrows = len(lines_map)\n    (bottom, top) = (0, 1)\n    if horizontal:\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    else:\n        trans = transforms.blended_transform_factory(ax.transAxes, ax.transData)\n    title_space_axes = section_title_space / aheight\n    if horizontal:\n        dpos = (top - bottom - nsect_title * title_space_axes) / float(nrows)\n    else:\n        dpos = (top - bottom) / float(nrows)\n    if styles_order is not None:\n        style_codes = styles_order\n    else:\n        style_codes = list(set(styles))\n        style_codes.sort()\n    if horizontal:\n        style_codes = style_codes[::-1]\n    nval = len(style_codes)\n    if nval > 1:\n        stackd = dpos / (2.5 * (float(nval) - 1))\n    else:\n        stackd = 0.0\n    style_codes_map = {x: style_codes.index(x) for x in style_codes}\n    colors = ['r', 'g', 'b', 'y', 'k', 'purple', 'orange']\n    if marker_props is None:\n        marker_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in marker_props[sc]:\n            marker_props[sc]['color'] = colors[j % len(colors)]\n        if 'marker' not in marker_props[sc]:\n            marker_props[sc]['marker'] = 'o'\n        if 'ms' not in marker_props[sc]:\n            marker_props[sc]['ms'] = 10 if stackd == 0 else 6\n    if line_props is None:\n        line_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in line_props[sc]:\n            line_props[sc]['color'] = 'grey'\n        if 'linewidth' not in line_props[sc]:\n            line_props[sc]['linewidth'] = 2 if stackd > 0 else 8\n    if horizontal:\n        pos = top - dpos / 2 if nsect == 1 else top\n    else:\n        pos = bottom + dpos / 2\n    labeled = set()\n    ticks = []\n    for k0 in lines0:\n        if draw_section_titles:\n            if horizontal:\n                y0 = pos + dpos / 2 if k0 == lines0[0] else pos\n                ax.fill_between((0, 1), (y0, y0), (pos - 0.7 * title_space_axes, pos - 0.7 * title_space_axes), color='darkgrey', transform=ax.transAxes, zorder=1)\n                txt = ax.text(0.5, pos - 0.35 * title_space_axes, k0, horizontalalignment='center', verticalalignment='center', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n                pos -= title_space_axes\n            else:\n                m = len([k for k in lines_map if k[0] == k0])\n                ax.fill_between((pos - dpos / 2 + 0.01, pos + (m - 1) * dpos + dpos / 2 - 0.01), (1.01, 1.01), (1.06, 1.06), color='darkgrey', transform=ax.transAxes, zorder=1, clip_on=False)\n                txt = ax.text(pos + (m - 1) * dpos / 2, 1.02, k0, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n        jrow = 0\n        for k1 in lines1:\n            if (k0, k1) not in lines_map:\n                continue\n            if horizontal:\n                ax.axhline(pos, color='grey')\n            else:\n                ax.axvline(pos, color='grey')\n            if split_names is not None:\n                us = k1.split(split_names)\n                if len(us) >= 2:\n                    (left_label, right_label) = (us[0], us[1])\n                else:\n                    (left_label, right_label) = (k1, None)\n            else:\n                (left_label, right_label) = (k1, None)\n            if fmt_left_name is not None:\n                left_label = fmt_left_name(left_label)\n            if fmt_right_name is not None:\n                right_label = fmt_right_name(right_label)\n            if striped and jrow % 2 == 0:\n                if horizontal:\n                    ax.fill_between((0, 1), (pos - dpos / 2, pos - dpos / 2), (pos + dpos / 2, pos + dpos / 2), color='lightgrey', transform=ax.transAxes, zorder=0)\n                else:\n                    ax.fill_between((pos - dpos / 2, pos + dpos / 2), (0, 0), (1, 1), color='lightgrey', transform=ax.transAxes, zorder=0)\n            jrow += 1\n            if show_names.lower() in ('left', 'both'):\n                if horizontal:\n                    ax.text(-0.1 / awidth, pos, left_label, horizontalalignment='right', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                else:\n                    ax.text(pos, -0.1 / aheight, left_label, horizontalalignment='center', verticalalignment='top', transform=ax.transAxes, family='monospace')\n            if show_names.lower() in ('right', 'both'):\n                if right_label is not None:\n                    if horizontal:\n                        ax.text(1 + 0.1 / awidth, pos, right_label, horizontalalignment='left', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                    else:\n                        ax.text(pos, 1 + 0.1 / aheight, right_label, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes, family='monospace')\n            ticks.append(pos)\n            for (ji, jp) in enumerate(lines_map[k0, k1]):\n                yo = 0\n                if stacked:\n                    yo = -dpos / 5 + style_codes_map[styles[jp]] * stackd\n                pt = points[jp]\n                if intervals is not None:\n                    if np.isscalar(intervals[jp]):\n                        (lcb, ucb) = (pt - intervals[jp], pt + intervals[jp])\n                    else:\n                        (lcb, ucb) = (pt - intervals[jp][0], pt + intervals[jp][1])\n                    if horizontal:\n                        ax.plot([lcb, ucb], [pos + yo, pos + yo], '-', transform=trans, **line_props[styles[jp]])\n                    else:\n                        ax.plot([pos + yo, pos + yo], [lcb, ucb], '-', transform=trans, **line_props[styles[jp]])\n                sl = styles[jp]\n                sll = sl if sl not in labeled else None\n                labeled.add(sl)\n                if horizontal:\n                    ax.plot([pt], [pos + yo], ls='None', transform=trans, label=sll, **marker_props[sl])\n                else:\n                    ax.plot([pos + yo], [pt], ls='None', transform=trans, label=sll, **marker_props[sl])\n            if horizontal:\n                pos -= dpos\n            else:\n                pos += dpos\n    if horizontal:\n        ax.xaxis.set_ticks_position('bottom')\n        ax.yaxis.set_ticks_position('none')\n        ax.set_yticklabels([])\n        ax.spines['left'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['bottom'].set_position(('axes', -0.1 / aheight))\n        ax.set_ylim(0, 1)\n        ax.yaxis.set_ticks(ticks)\n        ax.autoscale_view(scaley=False, tight=True)\n    else:\n        ax.yaxis.set_ticks_position('left')\n        ax.xaxis.set_ticks_position('none')\n        ax.set_xticklabels([])\n        ax.spines['bottom'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['left'].set_position(('axes', -0.1 / awidth))\n        ax.set_xlim(0, 1)\n        ax.xaxis.set_ticks(ticks)\n        ax.autoscale_view(scalex=False, tight=True)\n    return fig",
            "def dot_plot(points, intervals=None, lines=None, sections=None, styles=None, marker_props=None, line_props=None, split_names=None, section_order=None, line_order=None, stacked=False, styles_order=None, striped=False, horizontal=True, show_names='both', fmt_left_name=None, fmt_right_name=None, show_section_titles=None, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Dot plotting (also known as forest and blobbogram).\\n\\n    Produce a dotplot similar in style to those in Cleveland\\'s\\n    \"Visualizing Data\" book ([1]_).  These are also known as \"forest plots\".\\n\\n    Parameters\\n    ----------\\n    points : array_like\\n        The quantitative values to be plotted as markers.\\n    intervals : array_like\\n        The intervals to be plotted around the points.  The elements\\n        of `intervals` are either scalars or sequences of length 2.  A\\n        scalar indicates the half width of a symmetric interval.  A\\n        sequence of length 2 contains the left and right half-widths\\n        (respectively) of a nonsymmetric interval.  If None, no\\n        intervals are drawn.\\n    lines : array_like\\n        A grouping variable indicating which points/intervals are\\n        drawn on a common line.  If None, each point/interval appears\\n        on its own line.\\n    sections : array_like\\n        A grouping variable indicating which lines are grouped into\\n        sections.  If None, everything is drawn in a single section.\\n    styles : array_like\\n        A grouping label defining the plotting style of the markers\\n        and intervals.\\n    marker_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting markers.  Useful keyword\\n        arguments are \"color\", \"marker\", and \"ms\" (marker size).\\n    line_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting interval lines.  Useful\\n        keyword arguments are \"color\", \"linestyle\", \"solid_capstyle\",\\n        and \"linewidth\".\\n    split_names : str\\n        If not None, this is used to split the values of `lines` into\\n        substrings that are drawn in the left and right margins,\\n        respectively.  If None, the values of `lines` are drawn in the\\n        left margin.\\n    section_order : array_like\\n        The section labels in the order in which they appear in the\\n        dotplot.\\n    line_order : array_like\\n        The line labels in the order in which they appear in the\\n        dotplot.\\n    stacked : bool\\n        If True, when multiple points or intervals are drawn on the\\n        same line, they are offset from each other.\\n    styles_order : array_like\\n        If stacked=True, this is the order in which the point styles\\n        on a given line are drawn from top to bottom (if horizontal\\n        is True) or from left to right (if horizontal is False).  If\\n        None (default), the order is lexical.\\n    striped : bool\\n        If True, every other line is enclosed in a shaded box.\\n    horizontal : bool\\n        If True (default), the lines are drawn horizontally, otherwise\\n        they are drawn vertically.\\n    show_names : str\\n        Determines whether labels (names) are shown in the left and/or\\n        right margins (top/bottom margins if `horizontal` is True).\\n        If `both`, labels are drawn in both margins, if \\'left\\', labels\\n        are drawn in the left or top margin.  If `right`, labels are\\n        drawn in the right or bottom margin.\\n    fmt_left_name : callable\\n        The left/top margin names are passed through this function\\n        before drawing on the plot.\\n    fmt_right_name : callable\\n        The right/bottom marginnames are passed through this function\\n        before drawing on the plot.\\n    show_section_titles : bool or None\\n        If None, section titles are drawn only if there is more than\\n        one section.  If False/True, section titles are never/always\\n        drawn, respectively.\\n    ax : matplotlib.axes\\n        The axes on which the dotplot is drawn.  If None, a new axes\\n        is created.\\n\\n    Returns\\n    -------\\n    fig : Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Notes\\n    -----\\n    `points`, `intervals`, `lines`, `sections`, `styles` must all have\\n    the same length whenever present.\\n\\n    References\\n    ----------\\n    .. [1] Cleveland, William S. (1993). \"Visualizing Data\". Hobart Press.\\n    .. [2] Jacoby, William G. (2006) \"The Dot Plot: A Graphical Display\\n       for Labeled Quantitative Values.\" The Political Methodologist\\n       14(1): 6-14.\\n\\n    Examples\\n    --------\\n    This is a simple dotplot with one point per line:\\n\\n    >>> dot_plot(points=point_values)\\n\\n    This dotplot has labels on the lines (if elements in\\n    `label_values` are repeated, the corresponding points appear on\\n    the same line):\\n\\n    >>> dot_plot(points=point_values, lines=label_values)\\n    '\n    import matplotlib.transforms as transforms\n    (fig, ax) = utils.create_mpl_ax(ax)\n    points = np.asarray(points)\n    asarray_or_none = lambda x: None if x is None else np.asarray(x)\n    intervals = asarray_or_none(intervals)\n    lines = asarray_or_none(lines)\n    sections = asarray_or_none(sections)\n    styles = asarray_or_none(styles)\n    npoint = len(points)\n    if lines is None:\n        lines = np.arange(npoint)\n    if sections is None:\n        sections = np.zeros(npoint)\n    if styles is None:\n        styles = np.zeros(npoint)\n    section_title_space = 0.5\n    nsect = len(set(sections))\n    if section_order is not None:\n        nsect = len(set(section_order))\n    if show_section_titles is False:\n        draw_section_titles = False\n        nsect_title = 0\n    elif show_section_titles is True:\n        draw_section_titles = True\n        nsect_title = nsect\n    else:\n        draw_section_titles = nsect > 1\n        nsect_title = nsect if nsect > 1 else 0\n    section_space_total = section_title_space * nsect_title\n    ax.set_xmargin(0.02)\n    ax.set_ymargin(0.02)\n    if section_order is None:\n        lines0 = list(set(sections))\n        lines0.sort()\n    else:\n        lines0 = section_order\n    if line_order is None:\n        lines1 = list(set(lines))\n        lines1.sort()\n    else:\n        lines1 = line_order\n    lines_map = {}\n    for i in range(npoint):\n        if section_order is not None and sections[i] not in section_order:\n            continue\n        if line_order is not None and lines[i] not in line_order:\n            continue\n        ky = (sections[i], lines[i])\n        if ky not in lines_map:\n            lines_map[ky] = []\n        lines_map[ky].append(i)\n    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n    (awidth, aheight) = (bbox.width, bbox.height)\n    nrows = len(lines_map)\n    (bottom, top) = (0, 1)\n    if horizontal:\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    else:\n        trans = transforms.blended_transform_factory(ax.transAxes, ax.transData)\n    title_space_axes = section_title_space / aheight\n    if horizontal:\n        dpos = (top - bottom - nsect_title * title_space_axes) / float(nrows)\n    else:\n        dpos = (top - bottom) / float(nrows)\n    if styles_order is not None:\n        style_codes = styles_order\n    else:\n        style_codes = list(set(styles))\n        style_codes.sort()\n    if horizontal:\n        style_codes = style_codes[::-1]\n    nval = len(style_codes)\n    if nval > 1:\n        stackd = dpos / (2.5 * (float(nval) - 1))\n    else:\n        stackd = 0.0\n    style_codes_map = {x: style_codes.index(x) for x in style_codes}\n    colors = ['r', 'g', 'b', 'y', 'k', 'purple', 'orange']\n    if marker_props is None:\n        marker_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in marker_props[sc]:\n            marker_props[sc]['color'] = colors[j % len(colors)]\n        if 'marker' not in marker_props[sc]:\n            marker_props[sc]['marker'] = 'o'\n        if 'ms' not in marker_props[sc]:\n            marker_props[sc]['ms'] = 10 if stackd == 0 else 6\n    if line_props is None:\n        line_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in line_props[sc]:\n            line_props[sc]['color'] = 'grey'\n        if 'linewidth' not in line_props[sc]:\n            line_props[sc]['linewidth'] = 2 if stackd > 0 else 8\n    if horizontal:\n        pos = top - dpos / 2 if nsect == 1 else top\n    else:\n        pos = bottom + dpos / 2\n    labeled = set()\n    ticks = []\n    for k0 in lines0:\n        if draw_section_titles:\n            if horizontal:\n                y0 = pos + dpos / 2 if k0 == lines0[0] else pos\n                ax.fill_between((0, 1), (y0, y0), (pos - 0.7 * title_space_axes, pos - 0.7 * title_space_axes), color='darkgrey', transform=ax.transAxes, zorder=1)\n                txt = ax.text(0.5, pos - 0.35 * title_space_axes, k0, horizontalalignment='center', verticalalignment='center', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n                pos -= title_space_axes\n            else:\n                m = len([k for k in lines_map if k[0] == k0])\n                ax.fill_between((pos - dpos / 2 + 0.01, pos + (m - 1) * dpos + dpos / 2 - 0.01), (1.01, 1.01), (1.06, 1.06), color='darkgrey', transform=ax.transAxes, zorder=1, clip_on=False)\n                txt = ax.text(pos + (m - 1) * dpos / 2, 1.02, k0, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n        jrow = 0\n        for k1 in lines1:\n            if (k0, k1) not in lines_map:\n                continue\n            if horizontal:\n                ax.axhline(pos, color='grey')\n            else:\n                ax.axvline(pos, color='grey')\n            if split_names is not None:\n                us = k1.split(split_names)\n                if len(us) >= 2:\n                    (left_label, right_label) = (us[0], us[1])\n                else:\n                    (left_label, right_label) = (k1, None)\n            else:\n                (left_label, right_label) = (k1, None)\n            if fmt_left_name is not None:\n                left_label = fmt_left_name(left_label)\n            if fmt_right_name is not None:\n                right_label = fmt_right_name(right_label)\n            if striped and jrow % 2 == 0:\n                if horizontal:\n                    ax.fill_between((0, 1), (pos - dpos / 2, pos - dpos / 2), (pos + dpos / 2, pos + dpos / 2), color='lightgrey', transform=ax.transAxes, zorder=0)\n                else:\n                    ax.fill_between((pos - dpos / 2, pos + dpos / 2), (0, 0), (1, 1), color='lightgrey', transform=ax.transAxes, zorder=0)\n            jrow += 1\n            if show_names.lower() in ('left', 'both'):\n                if horizontal:\n                    ax.text(-0.1 / awidth, pos, left_label, horizontalalignment='right', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                else:\n                    ax.text(pos, -0.1 / aheight, left_label, horizontalalignment='center', verticalalignment='top', transform=ax.transAxes, family='monospace')\n            if show_names.lower() in ('right', 'both'):\n                if right_label is not None:\n                    if horizontal:\n                        ax.text(1 + 0.1 / awidth, pos, right_label, horizontalalignment='left', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                    else:\n                        ax.text(pos, 1 + 0.1 / aheight, right_label, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes, family='monospace')\n            ticks.append(pos)\n            for (ji, jp) in enumerate(lines_map[k0, k1]):\n                yo = 0\n                if stacked:\n                    yo = -dpos / 5 + style_codes_map[styles[jp]] * stackd\n                pt = points[jp]\n                if intervals is not None:\n                    if np.isscalar(intervals[jp]):\n                        (lcb, ucb) = (pt - intervals[jp], pt + intervals[jp])\n                    else:\n                        (lcb, ucb) = (pt - intervals[jp][0], pt + intervals[jp][1])\n                    if horizontal:\n                        ax.plot([lcb, ucb], [pos + yo, pos + yo], '-', transform=trans, **line_props[styles[jp]])\n                    else:\n                        ax.plot([pos + yo, pos + yo], [lcb, ucb], '-', transform=trans, **line_props[styles[jp]])\n                sl = styles[jp]\n                sll = sl if sl not in labeled else None\n                labeled.add(sl)\n                if horizontal:\n                    ax.plot([pt], [pos + yo], ls='None', transform=trans, label=sll, **marker_props[sl])\n                else:\n                    ax.plot([pos + yo], [pt], ls='None', transform=trans, label=sll, **marker_props[sl])\n            if horizontal:\n                pos -= dpos\n            else:\n                pos += dpos\n    if horizontal:\n        ax.xaxis.set_ticks_position('bottom')\n        ax.yaxis.set_ticks_position('none')\n        ax.set_yticklabels([])\n        ax.spines['left'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['bottom'].set_position(('axes', -0.1 / aheight))\n        ax.set_ylim(0, 1)\n        ax.yaxis.set_ticks(ticks)\n        ax.autoscale_view(scaley=False, tight=True)\n    else:\n        ax.yaxis.set_ticks_position('left')\n        ax.xaxis.set_ticks_position('none')\n        ax.set_xticklabels([])\n        ax.spines['bottom'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['left'].set_position(('axes', -0.1 / awidth))\n        ax.set_xlim(0, 1)\n        ax.xaxis.set_ticks(ticks)\n        ax.autoscale_view(scalex=False, tight=True)\n    return fig",
            "def dot_plot(points, intervals=None, lines=None, sections=None, styles=None, marker_props=None, line_props=None, split_names=None, section_order=None, line_order=None, stacked=False, styles_order=None, striped=False, horizontal=True, show_names='both', fmt_left_name=None, fmt_right_name=None, show_section_titles=None, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Dot plotting (also known as forest and blobbogram).\\n\\n    Produce a dotplot similar in style to those in Cleveland\\'s\\n    \"Visualizing Data\" book ([1]_).  These are also known as \"forest plots\".\\n\\n    Parameters\\n    ----------\\n    points : array_like\\n        The quantitative values to be plotted as markers.\\n    intervals : array_like\\n        The intervals to be plotted around the points.  The elements\\n        of `intervals` are either scalars or sequences of length 2.  A\\n        scalar indicates the half width of a symmetric interval.  A\\n        sequence of length 2 contains the left and right half-widths\\n        (respectively) of a nonsymmetric interval.  If None, no\\n        intervals are drawn.\\n    lines : array_like\\n        A grouping variable indicating which points/intervals are\\n        drawn on a common line.  If None, each point/interval appears\\n        on its own line.\\n    sections : array_like\\n        A grouping variable indicating which lines are grouped into\\n        sections.  If None, everything is drawn in a single section.\\n    styles : array_like\\n        A grouping label defining the plotting style of the markers\\n        and intervals.\\n    marker_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting markers.  Useful keyword\\n        arguments are \"color\", \"marker\", and \"ms\" (marker size).\\n    line_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting interval lines.  Useful\\n        keyword arguments are \"color\", \"linestyle\", \"solid_capstyle\",\\n        and \"linewidth\".\\n    split_names : str\\n        If not None, this is used to split the values of `lines` into\\n        substrings that are drawn in the left and right margins,\\n        respectively.  If None, the values of `lines` are drawn in the\\n        left margin.\\n    section_order : array_like\\n        The section labels in the order in which they appear in the\\n        dotplot.\\n    line_order : array_like\\n        The line labels in the order in which they appear in the\\n        dotplot.\\n    stacked : bool\\n        If True, when multiple points or intervals are drawn on the\\n        same line, they are offset from each other.\\n    styles_order : array_like\\n        If stacked=True, this is the order in which the point styles\\n        on a given line are drawn from top to bottom (if horizontal\\n        is True) or from left to right (if horizontal is False).  If\\n        None (default), the order is lexical.\\n    striped : bool\\n        If True, every other line is enclosed in a shaded box.\\n    horizontal : bool\\n        If True (default), the lines are drawn horizontally, otherwise\\n        they are drawn vertically.\\n    show_names : str\\n        Determines whether labels (names) are shown in the left and/or\\n        right margins (top/bottom margins if `horizontal` is True).\\n        If `both`, labels are drawn in both margins, if \\'left\\', labels\\n        are drawn in the left or top margin.  If `right`, labels are\\n        drawn in the right or bottom margin.\\n    fmt_left_name : callable\\n        The left/top margin names are passed through this function\\n        before drawing on the plot.\\n    fmt_right_name : callable\\n        The right/bottom marginnames are passed through this function\\n        before drawing on the plot.\\n    show_section_titles : bool or None\\n        If None, section titles are drawn only if there is more than\\n        one section.  If False/True, section titles are never/always\\n        drawn, respectively.\\n    ax : matplotlib.axes\\n        The axes on which the dotplot is drawn.  If None, a new axes\\n        is created.\\n\\n    Returns\\n    -------\\n    fig : Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Notes\\n    -----\\n    `points`, `intervals`, `lines`, `sections`, `styles` must all have\\n    the same length whenever present.\\n\\n    References\\n    ----------\\n    .. [1] Cleveland, William S. (1993). \"Visualizing Data\". Hobart Press.\\n    .. [2] Jacoby, William G. (2006) \"The Dot Plot: A Graphical Display\\n       for Labeled Quantitative Values.\" The Political Methodologist\\n       14(1): 6-14.\\n\\n    Examples\\n    --------\\n    This is a simple dotplot with one point per line:\\n\\n    >>> dot_plot(points=point_values)\\n\\n    This dotplot has labels on the lines (if elements in\\n    `label_values` are repeated, the corresponding points appear on\\n    the same line):\\n\\n    >>> dot_plot(points=point_values, lines=label_values)\\n    '\n    import matplotlib.transforms as transforms\n    (fig, ax) = utils.create_mpl_ax(ax)\n    points = np.asarray(points)\n    asarray_or_none = lambda x: None if x is None else np.asarray(x)\n    intervals = asarray_or_none(intervals)\n    lines = asarray_or_none(lines)\n    sections = asarray_or_none(sections)\n    styles = asarray_or_none(styles)\n    npoint = len(points)\n    if lines is None:\n        lines = np.arange(npoint)\n    if sections is None:\n        sections = np.zeros(npoint)\n    if styles is None:\n        styles = np.zeros(npoint)\n    section_title_space = 0.5\n    nsect = len(set(sections))\n    if section_order is not None:\n        nsect = len(set(section_order))\n    if show_section_titles is False:\n        draw_section_titles = False\n        nsect_title = 0\n    elif show_section_titles is True:\n        draw_section_titles = True\n        nsect_title = nsect\n    else:\n        draw_section_titles = nsect > 1\n        nsect_title = nsect if nsect > 1 else 0\n    section_space_total = section_title_space * nsect_title\n    ax.set_xmargin(0.02)\n    ax.set_ymargin(0.02)\n    if section_order is None:\n        lines0 = list(set(sections))\n        lines0.sort()\n    else:\n        lines0 = section_order\n    if line_order is None:\n        lines1 = list(set(lines))\n        lines1.sort()\n    else:\n        lines1 = line_order\n    lines_map = {}\n    for i in range(npoint):\n        if section_order is not None and sections[i] not in section_order:\n            continue\n        if line_order is not None and lines[i] not in line_order:\n            continue\n        ky = (sections[i], lines[i])\n        if ky not in lines_map:\n            lines_map[ky] = []\n        lines_map[ky].append(i)\n    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n    (awidth, aheight) = (bbox.width, bbox.height)\n    nrows = len(lines_map)\n    (bottom, top) = (0, 1)\n    if horizontal:\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    else:\n        trans = transforms.blended_transform_factory(ax.transAxes, ax.transData)\n    title_space_axes = section_title_space / aheight\n    if horizontal:\n        dpos = (top - bottom - nsect_title * title_space_axes) / float(nrows)\n    else:\n        dpos = (top - bottom) / float(nrows)\n    if styles_order is not None:\n        style_codes = styles_order\n    else:\n        style_codes = list(set(styles))\n        style_codes.sort()\n    if horizontal:\n        style_codes = style_codes[::-1]\n    nval = len(style_codes)\n    if nval > 1:\n        stackd = dpos / (2.5 * (float(nval) - 1))\n    else:\n        stackd = 0.0\n    style_codes_map = {x: style_codes.index(x) for x in style_codes}\n    colors = ['r', 'g', 'b', 'y', 'k', 'purple', 'orange']\n    if marker_props is None:\n        marker_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in marker_props[sc]:\n            marker_props[sc]['color'] = colors[j % len(colors)]\n        if 'marker' not in marker_props[sc]:\n            marker_props[sc]['marker'] = 'o'\n        if 'ms' not in marker_props[sc]:\n            marker_props[sc]['ms'] = 10 if stackd == 0 else 6\n    if line_props is None:\n        line_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in line_props[sc]:\n            line_props[sc]['color'] = 'grey'\n        if 'linewidth' not in line_props[sc]:\n            line_props[sc]['linewidth'] = 2 if stackd > 0 else 8\n    if horizontal:\n        pos = top - dpos / 2 if nsect == 1 else top\n    else:\n        pos = bottom + dpos / 2\n    labeled = set()\n    ticks = []\n    for k0 in lines0:\n        if draw_section_titles:\n            if horizontal:\n                y0 = pos + dpos / 2 if k0 == lines0[0] else pos\n                ax.fill_between((0, 1), (y0, y0), (pos - 0.7 * title_space_axes, pos - 0.7 * title_space_axes), color='darkgrey', transform=ax.transAxes, zorder=1)\n                txt = ax.text(0.5, pos - 0.35 * title_space_axes, k0, horizontalalignment='center', verticalalignment='center', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n                pos -= title_space_axes\n            else:\n                m = len([k for k in lines_map if k[0] == k0])\n                ax.fill_between((pos - dpos / 2 + 0.01, pos + (m - 1) * dpos + dpos / 2 - 0.01), (1.01, 1.01), (1.06, 1.06), color='darkgrey', transform=ax.transAxes, zorder=1, clip_on=False)\n                txt = ax.text(pos + (m - 1) * dpos / 2, 1.02, k0, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n        jrow = 0\n        for k1 in lines1:\n            if (k0, k1) not in lines_map:\n                continue\n            if horizontal:\n                ax.axhline(pos, color='grey')\n            else:\n                ax.axvline(pos, color='grey')\n            if split_names is not None:\n                us = k1.split(split_names)\n                if len(us) >= 2:\n                    (left_label, right_label) = (us[0], us[1])\n                else:\n                    (left_label, right_label) = (k1, None)\n            else:\n                (left_label, right_label) = (k1, None)\n            if fmt_left_name is not None:\n                left_label = fmt_left_name(left_label)\n            if fmt_right_name is not None:\n                right_label = fmt_right_name(right_label)\n            if striped and jrow % 2 == 0:\n                if horizontal:\n                    ax.fill_between((0, 1), (pos - dpos / 2, pos - dpos / 2), (pos + dpos / 2, pos + dpos / 2), color='lightgrey', transform=ax.transAxes, zorder=0)\n                else:\n                    ax.fill_between((pos - dpos / 2, pos + dpos / 2), (0, 0), (1, 1), color='lightgrey', transform=ax.transAxes, zorder=0)\n            jrow += 1\n            if show_names.lower() in ('left', 'both'):\n                if horizontal:\n                    ax.text(-0.1 / awidth, pos, left_label, horizontalalignment='right', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                else:\n                    ax.text(pos, -0.1 / aheight, left_label, horizontalalignment='center', verticalalignment='top', transform=ax.transAxes, family='monospace')\n            if show_names.lower() in ('right', 'both'):\n                if right_label is not None:\n                    if horizontal:\n                        ax.text(1 + 0.1 / awidth, pos, right_label, horizontalalignment='left', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                    else:\n                        ax.text(pos, 1 + 0.1 / aheight, right_label, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes, family='monospace')\n            ticks.append(pos)\n            for (ji, jp) in enumerate(lines_map[k0, k1]):\n                yo = 0\n                if stacked:\n                    yo = -dpos / 5 + style_codes_map[styles[jp]] * stackd\n                pt = points[jp]\n                if intervals is not None:\n                    if np.isscalar(intervals[jp]):\n                        (lcb, ucb) = (pt - intervals[jp], pt + intervals[jp])\n                    else:\n                        (lcb, ucb) = (pt - intervals[jp][0], pt + intervals[jp][1])\n                    if horizontal:\n                        ax.plot([lcb, ucb], [pos + yo, pos + yo], '-', transform=trans, **line_props[styles[jp]])\n                    else:\n                        ax.plot([pos + yo, pos + yo], [lcb, ucb], '-', transform=trans, **line_props[styles[jp]])\n                sl = styles[jp]\n                sll = sl if sl not in labeled else None\n                labeled.add(sl)\n                if horizontal:\n                    ax.plot([pt], [pos + yo], ls='None', transform=trans, label=sll, **marker_props[sl])\n                else:\n                    ax.plot([pos + yo], [pt], ls='None', transform=trans, label=sll, **marker_props[sl])\n            if horizontal:\n                pos -= dpos\n            else:\n                pos += dpos\n    if horizontal:\n        ax.xaxis.set_ticks_position('bottom')\n        ax.yaxis.set_ticks_position('none')\n        ax.set_yticklabels([])\n        ax.spines['left'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['bottom'].set_position(('axes', -0.1 / aheight))\n        ax.set_ylim(0, 1)\n        ax.yaxis.set_ticks(ticks)\n        ax.autoscale_view(scaley=False, tight=True)\n    else:\n        ax.yaxis.set_ticks_position('left')\n        ax.xaxis.set_ticks_position('none')\n        ax.set_xticklabels([])\n        ax.spines['bottom'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['left'].set_position(('axes', -0.1 / awidth))\n        ax.set_xlim(0, 1)\n        ax.xaxis.set_ticks(ticks)\n        ax.autoscale_view(scalex=False, tight=True)\n    return fig",
            "def dot_plot(points, intervals=None, lines=None, sections=None, styles=None, marker_props=None, line_props=None, split_names=None, section_order=None, line_order=None, stacked=False, styles_order=None, striped=False, horizontal=True, show_names='both', fmt_left_name=None, fmt_right_name=None, show_section_titles=None, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Dot plotting (also known as forest and blobbogram).\\n\\n    Produce a dotplot similar in style to those in Cleveland\\'s\\n    \"Visualizing Data\" book ([1]_).  These are also known as \"forest plots\".\\n\\n    Parameters\\n    ----------\\n    points : array_like\\n        The quantitative values to be plotted as markers.\\n    intervals : array_like\\n        The intervals to be plotted around the points.  The elements\\n        of `intervals` are either scalars or sequences of length 2.  A\\n        scalar indicates the half width of a symmetric interval.  A\\n        sequence of length 2 contains the left and right half-widths\\n        (respectively) of a nonsymmetric interval.  If None, no\\n        intervals are drawn.\\n    lines : array_like\\n        A grouping variable indicating which points/intervals are\\n        drawn on a common line.  If None, each point/interval appears\\n        on its own line.\\n    sections : array_like\\n        A grouping variable indicating which lines are grouped into\\n        sections.  If None, everything is drawn in a single section.\\n    styles : array_like\\n        A grouping label defining the plotting style of the markers\\n        and intervals.\\n    marker_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting markers.  Useful keyword\\n        arguments are \"color\", \"marker\", and \"ms\" (marker size).\\n    line_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting interval lines.  Useful\\n        keyword arguments are \"color\", \"linestyle\", \"solid_capstyle\",\\n        and \"linewidth\".\\n    split_names : str\\n        If not None, this is used to split the values of `lines` into\\n        substrings that are drawn in the left and right margins,\\n        respectively.  If None, the values of `lines` are drawn in the\\n        left margin.\\n    section_order : array_like\\n        The section labels in the order in which they appear in the\\n        dotplot.\\n    line_order : array_like\\n        The line labels in the order in which they appear in the\\n        dotplot.\\n    stacked : bool\\n        If True, when multiple points or intervals are drawn on the\\n        same line, they are offset from each other.\\n    styles_order : array_like\\n        If stacked=True, this is the order in which the point styles\\n        on a given line are drawn from top to bottom (if horizontal\\n        is True) or from left to right (if horizontal is False).  If\\n        None (default), the order is lexical.\\n    striped : bool\\n        If True, every other line is enclosed in a shaded box.\\n    horizontal : bool\\n        If True (default), the lines are drawn horizontally, otherwise\\n        they are drawn vertically.\\n    show_names : str\\n        Determines whether labels (names) are shown in the left and/or\\n        right margins (top/bottom margins if `horizontal` is True).\\n        If `both`, labels are drawn in both margins, if \\'left\\', labels\\n        are drawn in the left or top margin.  If `right`, labels are\\n        drawn in the right or bottom margin.\\n    fmt_left_name : callable\\n        The left/top margin names are passed through this function\\n        before drawing on the plot.\\n    fmt_right_name : callable\\n        The right/bottom marginnames are passed through this function\\n        before drawing on the plot.\\n    show_section_titles : bool or None\\n        If None, section titles are drawn only if there is more than\\n        one section.  If False/True, section titles are never/always\\n        drawn, respectively.\\n    ax : matplotlib.axes\\n        The axes on which the dotplot is drawn.  If None, a new axes\\n        is created.\\n\\n    Returns\\n    -------\\n    fig : Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Notes\\n    -----\\n    `points`, `intervals`, `lines`, `sections`, `styles` must all have\\n    the same length whenever present.\\n\\n    References\\n    ----------\\n    .. [1] Cleveland, William S. (1993). \"Visualizing Data\". Hobart Press.\\n    .. [2] Jacoby, William G. (2006) \"The Dot Plot: A Graphical Display\\n       for Labeled Quantitative Values.\" The Political Methodologist\\n       14(1): 6-14.\\n\\n    Examples\\n    --------\\n    This is a simple dotplot with one point per line:\\n\\n    >>> dot_plot(points=point_values)\\n\\n    This dotplot has labels on the lines (if elements in\\n    `label_values` are repeated, the corresponding points appear on\\n    the same line):\\n\\n    >>> dot_plot(points=point_values, lines=label_values)\\n    '\n    import matplotlib.transforms as transforms\n    (fig, ax) = utils.create_mpl_ax(ax)\n    points = np.asarray(points)\n    asarray_or_none = lambda x: None if x is None else np.asarray(x)\n    intervals = asarray_or_none(intervals)\n    lines = asarray_or_none(lines)\n    sections = asarray_or_none(sections)\n    styles = asarray_or_none(styles)\n    npoint = len(points)\n    if lines is None:\n        lines = np.arange(npoint)\n    if sections is None:\n        sections = np.zeros(npoint)\n    if styles is None:\n        styles = np.zeros(npoint)\n    section_title_space = 0.5\n    nsect = len(set(sections))\n    if section_order is not None:\n        nsect = len(set(section_order))\n    if show_section_titles is False:\n        draw_section_titles = False\n        nsect_title = 0\n    elif show_section_titles is True:\n        draw_section_titles = True\n        nsect_title = nsect\n    else:\n        draw_section_titles = nsect > 1\n        nsect_title = nsect if nsect > 1 else 0\n    section_space_total = section_title_space * nsect_title\n    ax.set_xmargin(0.02)\n    ax.set_ymargin(0.02)\n    if section_order is None:\n        lines0 = list(set(sections))\n        lines0.sort()\n    else:\n        lines0 = section_order\n    if line_order is None:\n        lines1 = list(set(lines))\n        lines1.sort()\n    else:\n        lines1 = line_order\n    lines_map = {}\n    for i in range(npoint):\n        if section_order is not None and sections[i] not in section_order:\n            continue\n        if line_order is not None and lines[i] not in line_order:\n            continue\n        ky = (sections[i], lines[i])\n        if ky not in lines_map:\n            lines_map[ky] = []\n        lines_map[ky].append(i)\n    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n    (awidth, aheight) = (bbox.width, bbox.height)\n    nrows = len(lines_map)\n    (bottom, top) = (0, 1)\n    if horizontal:\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    else:\n        trans = transforms.blended_transform_factory(ax.transAxes, ax.transData)\n    title_space_axes = section_title_space / aheight\n    if horizontal:\n        dpos = (top - bottom - nsect_title * title_space_axes) / float(nrows)\n    else:\n        dpos = (top - bottom) / float(nrows)\n    if styles_order is not None:\n        style_codes = styles_order\n    else:\n        style_codes = list(set(styles))\n        style_codes.sort()\n    if horizontal:\n        style_codes = style_codes[::-1]\n    nval = len(style_codes)\n    if nval > 1:\n        stackd = dpos / (2.5 * (float(nval) - 1))\n    else:\n        stackd = 0.0\n    style_codes_map = {x: style_codes.index(x) for x in style_codes}\n    colors = ['r', 'g', 'b', 'y', 'k', 'purple', 'orange']\n    if marker_props is None:\n        marker_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in marker_props[sc]:\n            marker_props[sc]['color'] = colors[j % len(colors)]\n        if 'marker' not in marker_props[sc]:\n            marker_props[sc]['marker'] = 'o'\n        if 'ms' not in marker_props[sc]:\n            marker_props[sc]['ms'] = 10 if stackd == 0 else 6\n    if line_props is None:\n        line_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in line_props[sc]:\n            line_props[sc]['color'] = 'grey'\n        if 'linewidth' not in line_props[sc]:\n            line_props[sc]['linewidth'] = 2 if stackd > 0 else 8\n    if horizontal:\n        pos = top - dpos / 2 if nsect == 1 else top\n    else:\n        pos = bottom + dpos / 2\n    labeled = set()\n    ticks = []\n    for k0 in lines0:\n        if draw_section_titles:\n            if horizontal:\n                y0 = pos + dpos / 2 if k0 == lines0[0] else pos\n                ax.fill_between((0, 1), (y0, y0), (pos - 0.7 * title_space_axes, pos - 0.7 * title_space_axes), color='darkgrey', transform=ax.transAxes, zorder=1)\n                txt = ax.text(0.5, pos - 0.35 * title_space_axes, k0, horizontalalignment='center', verticalalignment='center', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n                pos -= title_space_axes\n            else:\n                m = len([k for k in lines_map if k[0] == k0])\n                ax.fill_between((pos - dpos / 2 + 0.01, pos + (m - 1) * dpos + dpos / 2 - 0.01), (1.01, 1.01), (1.06, 1.06), color='darkgrey', transform=ax.transAxes, zorder=1, clip_on=False)\n                txt = ax.text(pos + (m - 1) * dpos / 2, 1.02, k0, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n        jrow = 0\n        for k1 in lines1:\n            if (k0, k1) not in lines_map:\n                continue\n            if horizontal:\n                ax.axhline(pos, color='grey')\n            else:\n                ax.axvline(pos, color='grey')\n            if split_names is not None:\n                us = k1.split(split_names)\n                if len(us) >= 2:\n                    (left_label, right_label) = (us[0], us[1])\n                else:\n                    (left_label, right_label) = (k1, None)\n            else:\n                (left_label, right_label) = (k1, None)\n            if fmt_left_name is not None:\n                left_label = fmt_left_name(left_label)\n            if fmt_right_name is not None:\n                right_label = fmt_right_name(right_label)\n            if striped and jrow % 2 == 0:\n                if horizontal:\n                    ax.fill_between((0, 1), (pos - dpos / 2, pos - dpos / 2), (pos + dpos / 2, pos + dpos / 2), color='lightgrey', transform=ax.transAxes, zorder=0)\n                else:\n                    ax.fill_between((pos - dpos / 2, pos + dpos / 2), (0, 0), (1, 1), color='lightgrey', transform=ax.transAxes, zorder=0)\n            jrow += 1\n            if show_names.lower() in ('left', 'both'):\n                if horizontal:\n                    ax.text(-0.1 / awidth, pos, left_label, horizontalalignment='right', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                else:\n                    ax.text(pos, -0.1 / aheight, left_label, horizontalalignment='center', verticalalignment='top', transform=ax.transAxes, family='monospace')\n            if show_names.lower() in ('right', 'both'):\n                if right_label is not None:\n                    if horizontal:\n                        ax.text(1 + 0.1 / awidth, pos, right_label, horizontalalignment='left', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                    else:\n                        ax.text(pos, 1 + 0.1 / aheight, right_label, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes, family='monospace')\n            ticks.append(pos)\n            for (ji, jp) in enumerate(lines_map[k0, k1]):\n                yo = 0\n                if stacked:\n                    yo = -dpos / 5 + style_codes_map[styles[jp]] * stackd\n                pt = points[jp]\n                if intervals is not None:\n                    if np.isscalar(intervals[jp]):\n                        (lcb, ucb) = (pt - intervals[jp], pt + intervals[jp])\n                    else:\n                        (lcb, ucb) = (pt - intervals[jp][0], pt + intervals[jp][1])\n                    if horizontal:\n                        ax.plot([lcb, ucb], [pos + yo, pos + yo], '-', transform=trans, **line_props[styles[jp]])\n                    else:\n                        ax.plot([pos + yo, pos + yo], [lcb, ucb], '-', transform=trans, **line_props[styles[jp]])\n                sl = styles[jp]\n                sll = sl if sl not in labeled else None\n                labeled.add(sl)\n                if horizontal:\n                    ax.plot([pt], [pos + yo], ls='None', transform=trans, label=sll, **marker_props[sl])\n                else:\n                    ax.plot([pos + yo], [pt], ls='None', transform=trans, label=sll, **marker_props[sl])\n            if horizontal:\n                pos -= dpos\n            else:\n                pos += dpos\n    if horizontal:\n        ax.xaxis.set_ticks_position('bottom')\n        ax.yaxis.set_ticks_position('none')\n        ax.set_yticklabels([])\n        ax.spines['left'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['bottom'].set_position(('axes', -0.1 / aheight))\n        ax.set_ylim(0, 1)\n        ax.yaxis.set_ticks(ticks)\n        ax.autoscale_view(scaley=False, tight=True)\n    else:\n        ax.yaxis.set_ticks_position('left')\n        ax.xaxis.set_ticks_position('none')\n        ax.set_xticklabels([])\n        ax.spines['bottom'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['left'].set_position(('axes', -0.1 / awidth))\n        ax.set_xlim(0, 1)\n        ax.xaxis.set_ticks(ticks)\n        ax.autoscale_view(scalex=False, tight=True)\n    return fig",
            "def dot_plot(points, intervals=None, lines=None, sections=None, styles=None, marker_props=None, line_props=None, split_names=None, section_order=None, line_order=None, stacked=False, styles_order=None, striped=False, horizontal=True, show_names='both', fmt_left_name=None, fmt_right_name=None, show_section_titles=None, ax=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Dot plotting (also known as forest and blobbogram).\\n\\n    Produce a dotplot similar in style to those in Cleveland\\'s\\n    \"Visualizing Data\" book ([1]_).  These are also known as \"forest plots\".\\n\\n    Parameters\\n    ----------\\n    points : array_like\\n        The quantitative values to be plotted as markers.\\n    intervals : array_like\\n        The intervals to be plotted around the points.  The elements\\n        of `intervals` are either scalars or sequences of length 2.  A\\n        scalar indicates the half width of a symmetric interval.  A\\n        sequence of length 2 contains the left and right half-widths\\n        (respectively) of a nonsymmetric interval.  If None, no\\n        intervals are drawn.\\n    lines : array_like\\n        A grouping variable indicating which points/intervals are\\n        drawn on a common line.  If None, each point/interval appears\\n        on its own line.\\n    sections : array_like\\n        A grouping variable indicating which lines are grouped into\\n        sections.  If None, everything is drawn in a single section.\\n    styles : array_like\\n        A grouping label defining the plotting style of the markers\\n        and intervals.\\n    marker_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting markers.  Useful keyword\\n        arguments are \"color\", \"marker\", and \"ms\" (marker size).\\n    line_props : dict\\n        A dictionary mapping style codes (the values in `styles`) to\\n        dictionaries defining key/value pairs to be passed as keyword\\n        arguments to `plot` when plotting interval lines.  Useful\\n        keyword arguments are \"color\", \"linestyle\", \"solid_capstyle\",\\n        and \"linewidth\".\\n    split_names : str\\n        If not None, this is used to split the values of `lines` into\\n        substrings that are drawn in the left and right margins,\\n        respectively.  If None, the values of `lines` are drawn in the\\n        left margin.\\n    section_order : array_like\\n        The section labels in the order in which they appear in the\\n        dotplot.\\n    line_order : array_like\\n        The line labels in the order in which they appear in the\\n        dotplot.\\n    stacked : bool\\n        If True, when multiple points or intervals are drawn on the\\n        same line, they are offset from each other.\\n    styles_order : array_like\\n        If stacked=True, this is the order in which the point styles\\n        on a given line are drawn from top to bottom (if horizontal\\n        is True) or from left to right (if horizontal is False).  If\\n        None (default), the order is lexical.\\n    striped : bool\\n        If True, every other line is enclosed in a shaded box.\\n    horizontal : bool\\n        If True (default), the lines are drawn horizontally, otherwise\\n        they are drawn vertically.\\n    show_names : str\\n        Determines whether labels (names) are shown in the left and/or\\n        right margins (top/bottom margins if `horizontal` is True).\\n        If `both`, labels are drawn in both margins, if \\'left\\', labels\\n        are drawn in the left or top margin.  If `right`, labels are\\n        drawn in the right or bottom margin.\\n    fmt_left_name : callable\\n        The left/top margin names are passed through this function\\n        before drawing on the plot.\\n    fmt_right_name : callable\\n        The right/bottom marginnames are passed through this function\\n        before drawing on the plot.\\n    show_section_titles : bool or None\\n        If None, section titles are drawn only if there is more than\\n        one section.  If False/True, section titles are never/always\\n        drawn, respectively.\\n    ax : matplotlib.axes\\n        The axes on which the dotplot is drawn.  If None, a new axes\\n        is created.\\n\\n    Returns\\n    -------\\n    fig : Figure\\n        The figure given by `ax.figure` or a new instance.\\n\\n    Notes\\n    -----\\n    `points`, `intervals`, `lines`, `sections`, `styles` must all have\\n    the same length whenever present.\\n\\n    References\\n    ----------\\n    .. [1] Cleveland, William S. (1993). \"Visualizing Data\". Hobart Press.\\n    .. [2] Jacoby, William G. (2006) \"The Dot Plot: A Graphical Display\\n       for Labeled Quantitative Values.\" The Political Methodologist\\n       14(1): 6-14.\\n\\n    Examples\\n    --------\\n    This is a simple dotplot with one point per line:\\n\\n    >>> dot_plot(points=point_values)\\n\\n    This dotplot has labels on the lines (if elements in\\n    `label_values` are repeated, the corresponding points appear on\\n    the same line):\\n\\n    >>> dot_plot(points=point_values, lines=label_values)\\n    '\n    import matplotlib.transforms as transforms\n    (fig, ax) = utils.create_mpl_ax(ax)\n    points = np.asarray(points)\n    asarray_or_none = lambda x: None if x is None else np.asarray(x)\n    intervals = asarray_or_none(intervals)\n    lines = asarray_or_none(lines)\n    sections = asarray_or_none(sections)\n    styles = asarray_or_none(styles)\n    npoint = len(points)\n    if lines is None:\n        lines = np.arange(npoint)\n    if sections is None:\n        sections = np.zeros(npoint)\n    if styles is None:\n        styles = np.zeros(npoint)\n    section_title_space = 0.5\n    nsect = len(set(sections))\n    if section_order is not None:\n        nsect = len(set(section_order))\n    if show_section_titles is False:\n        draw_section_titles = False\n        nsect_title = 0\n    elif show_section_titles is True:\n        draw_section_titles = True\n        nsect_title = nsect\n    else:\n        draw_section_titles = nsect > 1\n        nsect_title = nsect if nsect > 1 else 0\n    section_space_total = section_title_space * nsect_title\n    ax.set_xmargin(0.02)\n    ax.set_ymargin(0.02)\n    if section_order is None:\n        lines0 = list(set(sections))\n        lines0.sort()\n    else:\n        lines0 = section_order\n    if line_order is None:\n        lines1 = list(set(lines))\n        lines1.sort()\n    else:\n        lines1 = line_order\n    lines_map = {}\n    for i in range(npoint):\n        if section_order is not None and sections[i] not in section_order:\n            continue\n        if line_order is not None and lines[i] not in line_order:\n            continue\n        ky = (sections[i], lines[i])\n        if ky not in lines_map:\n            lines_map[ky] = []\n        lines_map[ky].append(i)\n    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n    (awidth, aheight) = (bbox.width, bbox.height)\n    nrows = len(lines_map)\n    (bottom, top) = (0, 1)\n    if horizontal:\n        trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)\n    else:\n        trans = transforms.blended_transform_factory(ax.transAxes, ax.transData)\n    title_space_axes = section_title_space / aheight\n    if horizontal:\n        dpos = (top - bottom - nsect_title * title_space_axes) / float(nrows)\n    else:\n        dpos = (top - bottom) / float(nrows)\n    if styles_order is not None:\n        style_codes = styles_order\n    else:\n        style_codes = list(set(styles))\n        style_codes.sort()\n    if horizontal:\n        style_codes = style_codes[::-1]\n    nval = len(style_codes)\n    if nval > 1:\n        stackd = dpos / (2.5 * (float(nval) - 1))\n    else:\n        stackd = 0.0\n    style_codes_map = {x: style_codes.index(x) for x in style_codes}\n    colors = ['r', 'g', 'b', 'y', 'k', 'purple', 'orange']\n    if marker_props is None:\n        marker_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in marker_props[sc]:\n            marker_props[sc]['color'] = colors[j % len(colors)]\n        if 'marker' not in marker_props[sc]:\n            marker_props[sc]['marker'] = 'o'\n        if 'ms' not in marker_props[sc]:\n            marker_props[sc]['ms'] = 10 if stackd == 0 else 6\n    if line_props is None:\n        line_props = {x: {} for x in style_codes}\n    for j in range(nval):\n        sc = style_codes[j]\n        if 'color' not in line_props[sc]:\n            line_props[sc]['color'] = 'grey'\n        if 'linewidth' not in line_props[sc]:\n            line_props[sc]['linewidth'] = 2 if stackd > 0 else 8\n    if horizontal:\n        pos = top - dpos / 2 if nsect == 1 else top\n    else:\n        pos = bottom + dpos / 2\n    labeled = set()\n    ticks = []\n    for k0 in lines0:\n        if draw_section_titles:\n            if horizontal:\n                y0 = pos + dpos / 2 if k0 == lines0[0] else pos\n                ax.fill_between((0, 1), (y0, y0), (pos - 0.7 * title_space_axes, pos - 0.7 * title_space_axes), color='darkgrey', transform=ax.transAxes, zorder=1)\n                txt = ax.text(0.5, pos - 0.35 * title_space_axes, k0, horizontalalignment='center', verticalalignment='center', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n                pos -= title_space_axes\n            else:\n                m = len([k for k in lines_map if k[0] == k0])\n                ax.fill_between((pos - dpos / 2 + 0.01, pos + (m - 1) * dpos + dpos / 2 - 0.01), (1.01, 1.01), (1.06, 1.06), color='darkgrey', transform=ax.transAxes, zorder=1, clip_on=False)\n                txt = ax.text(pos + (m - 1) * dpos / 2, 1.02, k0, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes)\n                txt.set_fontweight('bold')\n        jrow = 0\n        for k1 in lines1:\n            if (k0, k1) not in lines_map:\n                continue\n            if horizontal:\n                ax.axhline(pos, color='grey')\n            else:\n                ax.axvline(pos, color='grey')\n            if split_names is not None:\n                us = k1.split(split_names)\n                if len(us) >= 2:\n                    (left_label, right_label) = (us[0], us[1])\n                else:\n                    (left_label, right_label) = (k1, None)\n            else:\n                (left_label, right_label) = (k1, None)\n            if fmt_left_name is not None:\n                left_label = fmt_left_name(left_label)\n            if fmt_right_name is not None:\n                right_label = fmt_right_name(right_label)\n            if striped and jrow % 2 == 0:\n                if horizontal:\n                    ax.fill_between((0, 1), (pos - dpos / 2, pos - dpos / 2), (pos + dpos / 2, pos + dpos / 2), color='lightgrey', transform=ax.transAxes, zorder=0)\n                else:\n                    ax.fill_between((pos - dpos / 2, pos + dpos / 2), (0, 0), (1, 1), color='lightgrey', transform=ax.transAxes, zorder=0)\n            jrow += 1\n            if show_names.lower() in ('left', 'both'):\n                if horizontal:\n                    ax.text(-0.1 / awidth, pos, left_label, horizontalalignment='right', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                else:\n                    ax.text(pos, -0.1 / aheight, left_label, horizontalalignment='center', verticalalignment='top', transform=ax.transAxes, family='monospace')\n            if show_names.lower() in ('right', 'both'):\n                if right_label is not None:\n                    if horizontal:\n                        ax.text(1 + 0.1 / awidth, pos, right_label, horizontalalignment='left', verticalalignment='center', transform=ax.transAxes, family='monospace')\n                    else:\n                        ax.text(pos, 1 + 0.1 / aheight, right_label, horizontalalignment='center', verticalalignment='bottom', transform=ax.transAxes, family='monospace')\n            ticks.append(pos)\n            for (ji, jp) in enumerate(lines_map[k0, k1]):\n                yo = 0\n                if stacked:\n                    yo = -dpos / 5 + style_codes_map[styles[jp]] * stackd\n                pt = points[jp]\n                if intervals is not None:\n                    if np.isscalar(intervals[jp]):\n                        (lcb, ucb) = (pt - intervals[jp], pt + intervals[jp])\n                    else:\n                        (lcb, ucb) = (pt - intervals[jp][0], pt + intervals[jp][1])\n                    if horizontal:\n                        ax.plot([lcb, ucb], [pos + yo, pos + yo], '-', transform=trans, **line_props[styles[jp]])\n                    else:\n                        ax.plot([pos + yo, pos + yo], [lcb, ucb], '-', transform=trans, **line_props[styles[jp]])\n                sl = styles[jp]\n                sll = sl if sl not in labeled else None\n                labeled.add(sl)\n                if horizontal:\n                    ax.plot([pt], [pos + yo], ls='None', transform=trans, label=sll, **marker_props[sl])\n                else:\n                    ax.plot([pos + yo], [pt], ls='None', transform=trans, label=sll, **marker_props[sl])\n            if horizontal:\n                pos -= dpos\n            else:\n                pos += dpos\n    if horizontal:\n        ax.xaxis.set_ticks_position('bottom')\n        ax.yaxis.set_ticks_position('none')\n        ax.set_yticklabels([])\n        ax.spines['left'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['bottom'].set_position(('axes', -0.1 / aheight))\n        ax.set_ylim(0, 1)\n        ax.yaxis.set_ticks(ticks)\n        ax.autoscale_view(scaley=False, tight=True)\n    else:\n        ax.yaxis.set_ticks_position('left')\n        ax.xaxis.set_ticks_position('none')\n        ax.set_xticklabels([])\n        ax.spines['bottom'].set_color('none')\n        ax.spines['right'].set_color('none')\n        ax.spines['top'].set_color('none')\n        ax.spines['left'].set_position(('axes', -0.1 / awidth))\n        ax.set_xlim(0, 1)\n        ax.xaxis.set_ticks(ticks)\n        ax.autoscale_view(scalex=False, tight=True)\n    return fig"
        ]
    }
]