[
    {
        "func_name": "daisy",
        "original": "def daisy(image, step=4, radius=15, rings=3, histograms=8, orientations=8, normalization='l1', sigmas=None, ring_radii=None, visualize=False):\n    \"\"\"Extract DAISY feature descriptors densely for the given image.\n\n    DAISY is a feature descriptor similar to SIFT formulated in a way that\n    allows for fast dense extraction. Typically, this is practical for\n    bag-of-features image representations.\n\n    The implementation follows Tola et al. [1]_ but deviate on the following\n    points:\n\n      * Histogram bin contribution are smoothed with a circular Gaussian\n        window over the tonal range (the angular range).\n      * The sigma values of the spatial Gaussian smoothing in this code do not\n        match the sigma values in the original code by Tola et al. [2]_. In\n        their code, spatial smoothing is applied to both the input image and\n        the center histogram. However, this smoothing is not documented in [1]_\n        and, therefore, it is omitted.\n\n    Parameters\n    ----------\n    image : (M, N) array\n        Input image (grayscale).\n    step : int, optional\n        Distance between descriptor sampling points.\n    radius : int, optional\n        Radius (in pixels) of the outermost ring.\n    rings : int, optional\n        Number of rings.\n    histograms : int, optional\n        Number of histograms sampled per ring.\n    orientations : int, optional\n        Number of orientations (bins) per histogram.\n    normalization : [ 'l1' | 'l2' | 'daisy' | 'off' ], optional\n        How to normalize the descriptors\n\n          * 'l1': L1-normalization of each descriptor.\n          * 'l2': L2-normalization of each descriptor.\n          * 'daisy': L2-normalization of individual histograms.\n          * 'off': Disable normalization.\n\n    sigmas : 1D array of float, optional\n        Standard deviation of spatial Gaussian smoothing for the center\n        histogram and for each ring of histograms. The array of sigmas should\n        be sorted from the center and out. I.e. the first sigma value defines\n        the spatial smoothing of the center histogram and the last sigma value\n        defines the spatial smoothing of the outermost ring. Specifying sigmas\n        overrides the following parameter.\n\n            ``rings = len(sigmas) - 1``\n\n    ring_radii : 1D array of int, optional\n        Radius (in pixels) for each ring. Specifying ring_radii overrides the\n        following two parameters.\n\n            ``rings = len(ring_radii)``\n            ``radius = ring_radii[-1]``\n\n        If both sigmas and ring_radii are given, they must satisfy the\n        following predicate since no radius is needed for the center\n        histogram.\n\n            ``len(ring_radii) == len(sigmas) + 1``\n\n    visualize : bool, optional\n        Generate a visualization of the DAISY descriptors\n\n    Returns\n    -------\n    descs : array\n        Grid of DAISY descriptors for the given image as an array\n        dimensionality  (P, Q, R) where\n\n            ``P = ceil((M - radius*2) / step)``\n            ``Q = ceil((N - radius*2) / step)``\n            ``R = (rings * histograms + 1) * orientations``\n\n    descs_img : (M, N, 3) array (only if visualize==True)\n        Visualization of the DAISY descriptors.\n\n    References\n    ----------\n    .. [1] Tola et al. \"Daisy: An efficient dense descriptor applied to wide-\n           baseline stereo.\" Pattern Analysis and Machine Intelligence, IEEE\n           Transactions on 32.5 (2010): 815-830.\n    .. [2] http://cvlab.epfl.ch/software/daisy\n    \"\"\"\n    check_nD(image, 2, 'img')\n    image = img_as_float(image)\n    float_dtype = image.dtype\n    if sigmas is not None and ring_radii is not None and (len(sigmas) - 1 != len(ring_radii)):\n        raise ValueError('`len(sigmas)-1 != len(ring_radii)`')\n    if ring_radii is not None:\n        rings = len(ring_radii)\n        radius = ring_radii[-1]\n    if sigmas is not None:\n        rings = len(sigmas) - 1\n    if sigmas is None:\n        sigmas = [radius * (i + 1) / float(2 * rings) for i in range(rings)]\n    if ring_radii is None:\n        ring_radii = [radius * (i + 1) / float(rings) for i in range(rings)]\n    if normalization not in ['l1', 'l2', 'daisy', 'off']:\n        raise ValueError('Invalid normalization method.')\n    dx = np.zeros(image.shape, dtype=float_dtype)\n    dy = np.zeros(image.shape, dtype=float_dtype)\n    dx[:, :-1] = np.diff(image, n=1, axis=1)\n    dy[:-1, :] = np.diff(image, n=1, axis=0)\n    grad_mag = sqrt(dx ** 2 + dy ** 2)\n    grad_ori = arctan2(dy, dx)\n    orientation_kappa = orientations / pi\n    orientation_angles = [2 * o * pi / orientations - pi for o in range(orientations)]\n    hist = np.empty((orientations,) + image.shape, dtype=float_dtype)\n    for (i, o) in enumerate(orientation_angles):\n        hist[i, :, :] = exp(orientation_kappa * np.cos(grad_ori - o))\n        hist[i, :, :] = np.multiply(hist[i, :, :], grad_mag)\n    sigmas = [sigmas[0]] + sigmas\n    hist_smooth = np.empty((rings + 1,) + hist.shape, dtype=float_dtype)\n    for i in range(rings + 1):\n        for j in range(orientations):\n            hist_smooth[i, j, :, :] = gaussian(hist[j, :, :], sigma=sigmas[i], mode='reflect')\n    theta = [2 * pi * j / histograms for j in range(histograms)]\n    desc_dims = (rings * histograms + 1) * orientations\n    descs = np.empty((desc_dims, image.shape[0] - 2 * radius, image.shape[1] - 2 * radius), dtype=float_dtype)\n    descs[:orientations, :, :] = hist_smooth[0, :, radius:-radius, radius:-radius]\n    idx = orientations\n    for i in range(rings):\n        for j in range(histograms):\n            y_min = radius + int(round(ring_radii[i] * math.sin(theta[j])))\n            y_max = descs.shape[1] + y_min\n            x_min = radius + int(round(ring_radii[i] * math.cos(theta[j])))\n            x_max = descs.shape[2] + x_min\n            descs[idx:idx + orientations, :, :] = hist_smooth[i + 1, :, y_min:y_max, x_min:x_max]\n            idx += orientations\n    descs = descs[:, ::step, ::step]\n    descs = descs.swapaxes(0, 1).swapaxes(1, 2)\n    if normalization != 'off':\n        descs += 1e-10\n        if normalization == 'l1':\n            descs /= np.sum(descs, axis=2)[:, :, np.newaxis]\n        elif normalization == 'l2':\n            descs /= sqrt(np.sum(descs ** 2, axis=2))[:, :, np.newaxis]\n        elif normalization == 'daisy':\n            for i in range(0, desc_dims, orientations):\n                norms = sqrt(np.sum(descs[:, :, i:i + orientations] ** 2, axis=2))\n                descs[:, :, i:i + orientations] /= norms[:, :, np.newaxis]\n    if visualize:\n        descs_img = gray2rgb(image)\n        for i in range(descs.shape[0]):\n            for j in range(descs.shape[1]):\n                color = [1, 0, 0]\n                desc_y = i * step + radius\n                desc_x = j * step + radius\n                (rows, cols, val) = draw.circle_perimeter_aa(desc_y, desc_x, int(sigmas[0]))\n                draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                max_bin = np.max(descs[i, j, :])\n                for (o_num, o) in enumerate(orientation_angles):\n                    bin_size = descs[i, j, o_num] / max_bin\n                    dy = sigmas[0] * bin_size * math.sin(o)\n                    dx = sigmas[0] * bin_size * math.cos(o)\n                    (rows, cols, val) = draw.line_aa(desc_y, desc_x, int(desc_y + dy), int(desc_x + dx))\n                    draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                for (r_num, r) in enumerate(ring_radii):\n                    color_offset = float(1 + r_num) / rings\n                    color = (1 - color_offset, 1, color_offset)\n                    for (t_num, t) in enumerate(theta):\n                        hist_y = desc_y + int(round(r * math.sin(t)))\n                        hist_x = desc_x + int(round(r * math.cos(t)))\n                        (rows, cols, val) = draw.circle_perimeter_aa(hist_y, hist_x, int(sigmas[r_num + 1]))\n                        draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                        for (o_num, o) in enumerate(orientation_angles):\n                            bin_size = descs[i, j, orientations + r_num * histograms * orientations + t_num * orientations + o_num]\n                            bin_size /= max_bin\n                            dy = sigmas[r_num + 1] * bin_size * math.sin(o)\n                            dx = sigmas[r_num + 1] * bin_size * math.cos(o)\n                            (rows, cols, val) = draw.line_aa(hist_y, hist_x, int(hist_y + dy), int(hist_x + dx))\n                            draw.set_color(descs_img, (rows, cols), color, alpha=val)\n        return (descs, descs_img)\n    else:\n        return descs",
        "mutated": [
            "def daisy(image, step=4, radius=15, rings=3, histograms=8, orientations=8, normalization='l1', sigmas=None, ring_radii=None, visualize=False):\n    if False:\n        i = 10\n    'Extract DAISY feature descriptors densely for the given image.\\n\\n    DAISY is a feature descriptor similar to SIFT formulated in a way that\\n    allows for fast dense extraction. Typically, this is practical for\\n    bag-of-features image representations.\\n\\n    The implementation follows Tola et al. [1]_ but deviate on the following\\n    points:\\n\\n      * Histogram bin contribution are smoothed with a circular Gaussian\\n        window over the tonal range (the angular range).\\n      * The sigma values of the spatial Gaussian smoothing in this code do not\\n        match the sigma values in the original code by Tola et al. [2]_. In\\n        their code, spatial smoothing is applied to both the input image and\\n        the center histogram. However, this smoothing is not documented in [1]_\\n        and, therefore, it is omitted.\\n\\n    Parameters\\n    ----------\\n    image : (M, N) array\\n        Input image (grayscale).\\n    step : int, optional\\n        Distance between descriptor sampling points.\\n    radius : int, optional\\n        Radius (in pixels) of the outermost ring.\\n    rings : int, optional\\n        Number of rings.\\n    histograms : int, optional\\n        Number of histograms sampled per ring.\\n    orientations : int, optional\\n        Number of orientations (bins) per histogram.\\n    normalization : [ \\'l1\\' | \\'l2\\' | \\'daisy\\' | \\'off\\' ], optional\\n        How to normalize the descriptors\\n\\n          * \\'l1\\': L1-normalization of each descriptor.\\n          * \\'l2\\': L2-normalization of each descriptor.\\n          * \\'daisy\\': L2-normalization of individual histograms.\\n          * \\'off\\': Disable normalization.\\n\\n    sigmas : 1D array of float, optional\\n        Standard deviation of spatial Gaussian smoothing for the center\\n        histogram and for each ring of histograms. The array of sigmas should\\n        be sorted from the center and out. I.e. the first sigma value defines\\n        the spatial smoothing of the center histogram and the last sigma value\\n        defines the spatial smoothing of the outermost ring. Specifying sigmas\\n        overrides the following parameter.\\n\\n            ``rings = len(sigmas) - 1``\\n\\n    ring_radii : 1D array of int, optional\\n        Radius (in pixels) for each ring. Specifying ring_radii overrides the\\n        following two parameters.\\n\\n            ``rings = len(ring_radii)``\\n            ``radius = ring_radii[-1]``\\n\\n        If both sigmas and ring_radii are given, they must satisfy the\\n        following predicate since no radius is needed for the center\\n        histogram.\\n\\n            ``len(ring_radii) == len(sigmas) + 1``\\n\\n    visualize : bool, optional\\n        Generate a visualization of the DAISY descriptors\\n\\n    Returns\\n    -------\\n    descs : array\\n        Grid of DAISY descriptors for the given image as an array\\n        dimensionality  (P, Q, R) where\\n\\n            ``P = ceil((M - radius*2) / step)``\\n            ``Q = ceil((N - radius*2) / step)``\\n            ``R = (rings * histograms + 1) * orientations``\\n\\n    descs_img : (M, N, 3) array (only if visualize==True)\\n        Visualization of the DAISY descriptors.\\n\\n    References\\n    ----------\\n    .. [1] Tola et al. \"Daisy: An efficient dense descriptor applied to wide-\\n           baseline stereo.\" Pattern Analysis and Machine Intelligence, IEEE\\n           Transactions on 32.5 (2010): 815-830.\\n    .. [2] http://cvlab.epfl.ch/software/daisy\\n    '\n    check_nD(image, 2, 'img')\n    image = img_as_float(image)\n    float_dtype = image.dtype\n    if sigmas is not None and ring_radii is not None and (len(sigmas) - 1 != len(ring_radii)):\n        raise ValueError('`len(sigmas)-1 != len(ring_radii)`')\n    if ring_radii is not None:\n        rings = len(ring_radii)\n        radius = ring_radii[-1]\n    if sigmas is not None:\n        rings = len(sigmas) - 1\n    if sigmas is None:\n        sigmas = [radius * (i + 1) / float(2 * rings) for i in range(rings)]\n    if ring_radii is None:\n        ring_radii = [radius * (i + 1) / float(rings) for i in range(rings)]\n    if normalization not in ['l1', 'l2', 'daisy', 'off']:\n        raise ValueError('Invalid normalization method.')\n    dx = np.zeros(image.shape, dtype=float_dtype)\n    dy = np.zeros(image.shape, dtype=float_dtype)\n    dx[:, :-1] = np.diff(image, n=1, axis=1)\n    dy[:-1, :] = np.diff(image, n=1, axis=0)\n    grad_mag = sqrt(dx ** 2 + dy ** 2)\n    grad_ori = arctan2(dy, dx)\n    orientation_kappa = orientations / pi\n    orientation_angles = [2 * o * pi / orientations - pi for o in range(orientations)]\n    hist = np.empty((orientations,) + image.shape, dtype=float_dtype)\n    for (i, o) in enumerate(orientation_angles):\n        hist[i, :, :] = exp(orientation_kappa * np.cos(grad_ori - o))\n        hist[i, :, :] = np.multiply(hist[i, :, :], grad_mag)\n    sigmas = [sigmas[0]] + sigmas\n    hist_smooth = np.empty((rings + 1,) + hist.shape, dtype=float_dtype)\n    for i in range(rings + 1):\n        for j in range(orientations):\n            hist_smooth[i, j, :, :] = gaussian(hist[j, :, :], sigma=sigmas[i], mode='reflect')\n    theta = [2 * pi * j / histograms for j in range(histograms)]\n    desc_dims = (rings * histograms + 1) * orientations\n    descs = np.empty((desc_dims, image.shape[0] - 2 * radius, image.shape[1] - 2 * radius), dtype=float_dtype)\n    descs[:orientations, :, :] = hist_smooth[0, :, radius:-radius, radius:-radius]\n    idx = orientations\n    for i in range(rings):\n        for j in range(histograms):\n            y_min = radius + int(round(ring_radii[i] * math.sin(theta[j])))\n            y_max = descs.shape[1] + y_min\n            x_min = radius + int(round(ring_radii[i] * math.cos(theta[j])))\n            x_max = descs.shape[2] + x_min\n            descs[idx:idx + orientations, :, :] = hist_smooth[i + 1, :, y_min:y_max, x_min:x_max]\n            idx += orientations\n    descs = descs[:, ::step, ::step]\n    descs = descs.swapaxes(0, 1).swapaxes(1, 2)\n    if normalization != 'off':\n        descs += 1e-10\n        if normalization == 'l1':\n            descs /= np.sum(descs, axis=2)[:, :, np.newaxis]\n        elif normalization == 'l2':\n            descs /= sqrt(np.sum(descs ** 2, axis=2))[:, :, np.newaxis]\n        elif normalization == 'daisy':\n            for i in range(0, desc_dims, orientations):\n                norms = sqrt(np.sum(descs[:, :, i:i + orientations] ** 2, axis=2))\n                descs[:, :, i:i + orientations] /= norms[:, :, np.newaxis]\n    if visualize:\n        descs_img = gray2rgb(image)\n        for i in range(descs.shape[0]):\n            for j in range(descs.shape[1]):\n                color = [1, 0, 0]\n                desc_y = i * step + radius\n                desc_x = j * step + radius\n                (rows, cols, val) = draw.circle_perimeter_aa(desc_y, desc_x, int(sigmas[0]))\n                draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                max_bin = np.max(descs[i, j, :])\n                for (o_num, o) in enumerate(orientation_angles):\n                    bin_size = descs[i, j, o_num] / max_bin\n                    dy = sigmas[0] * bin_size * math.sin(o)\n                    dx = sigmas[0] * bin_size * math.cos(o)\n                    (rows, cols, val) = draw.line_aa(desc_y, desc_x, int(desc_y + dy), int(desc_x + dx))\n                    draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                for (r_num, r) in enumerate(ring_radii):\n                    color_offset = float(1 + r_num) / rings\n                    color = (1 - color_offset, 1, color_offset)\n                    for (t_num, t) in enumerate(theta):\n                        hist_y = desc_y + int(round(r * math.sin(t)))\n                        hist_x = desc_x + int(round(r * math.cos(t)))\n                        (rows, cols, val) = draw.circle_perimeter_aa(hist_y, hist_x, int(sigmas[r_num + 1]))\n                        draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                        for (o_num, o) in enumerate(orientation_angles):\n                            bin_size = descs[i, j, orientations + r_num * histograms * orientations + t_num * orientations + o_num]\n                            bin_size /= max_bin\n                            dy = sigmas[r_num + 1] * bin_size * math.sin(o)\n                            dx = sigmas[r_num + 1] * bin_size * math.cos(o)\n                            (rows, cols, val) = draw.line_aa(hist_y, hist_x, int(hist_y + dy), int(hist_x + dx))\n                            draw.set_color(descs_img, (rows, cols), color, alpha=val)\n        return (descs, descs_img)\n    else:\n        return descs",
            "def daisy(image, step=4, radius=15, rings=3, histograms=8, orientations=8, normalization='l1', sigmas=None, ring_radii=None, visualize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Extract DAISY feature descriptors densely for the given image.\\n\\n    DAISY is a feature descriptor similar to SIFT formulated in a way that\\n    allows for fast dense extraction. Typically, this is practical for\\n    bag-of-features image representations.\\n\\n    The implementation follows Tola et al. [1]_ but deviate on the following\\n    points:\\n\\n      * Histogram bin contribution are smoothed with a circular Gaussian\\n        window over the tonal range (the angular range).\\n      * The sigma values of the spatial Gaussian smoothing in this code do not\\n        match the sigma values in the original code by Tola et al. [2]_. In\\n        their code, spatial smoothing is applied to both the input image and\\n        the center histogram. However, this smoothing is not documented in [1]_\\n        and, therefore, it is omitted.\\n\\n    Parameters\\n    ----------\\n    image : (M, N) array\\n        Input image (grayscale).\\n    step : int, optional\\n        Distance between descriptor sampling points.\\n    radius : int, optional\\n        Radius (in pixels) of the outermost ring.\\n    rings : int, optional\\n        Number of rings.\\n    histograms : int, optional\\n        Number of histograms sampled per ring.\\n    orientations : int, optional\\n        Number of orientations (bins) per histogram.\\n    normalization : [ \\'l1\\' | \\'l2\\' | \\'daisy\\' | \\'off\\' ], optional\\n        How to normalize the descriptors\\n\\n          * \\'l1\\': L1-normalization of each descriptor.\\n          * \\'l2\\': L2-normalization of each descriptor.\\n          * \\'daisy\\': L2-normalization of individual histograms.\\n          * \\'off\\': Disable normalization.\\n\\n    sigmas : 1D array of float, optional\\n        Standard deviation of spatial Gaussian smoothing for the center\\n        histogram and for each ring of histograms. The array of sigmas should\\n        be sorted from the center and out. I.e. the first sigma value defines\\n        the spatial smoothing of the center histogram and the last sigma value\\n        defines the spatial smoothing of the outermost ring. Specifying sigmas\\n        overrides the following parameter.\\n\\n            ``rings = len(sigmas) - 1``\\n\\n    ring_radii : 1D array of int, optional\\n        Radius (in pixels) for each ring. Specifying ring_radii overrides the\\n        following two parameters.\\n\\n            ``rings = len(ring_radii)``\\n            ``radius = ring_radii[-1]``\\n\\n        If both sigmas and ring_radii are given, they must satisfy the\\n        following predicate since no radius is needed for the center\\n        histogram.\\n\\n            ``len(ring_radii) == len(sigmas) + 1``\\n\\n    visualize : bool, optional\\n        Generate a visualization of the DAISY descriptors\\n\\n    Returns\\n    -------\\n    descs : array\\n        Grid of DAISY descriptors for the given image as an array\\n        dimensionality  (P, Q, R) where\\n\\n            ``P = ceil((M - radius*2) / step)``\\n            ``Q = ceil((N - radius*2) / step)``\\n            ``R = (rings * histograms + 1) * orientations``\\n\\n    descs_img : (M, N, 3) array (only if visualize==True)\\n        Visualization of the DAISY descriptors.\\n\\n    References\\n    ----------\\n    .. [1] Tola et al. \"Daisy: An efficient dense descriptor applied to wide-\\n           baseline stereo.\" Pattern Analysis and Machine Intelligence, IEEE\\n           Transactions on 32.5 (2010): 815-830.\\n    .. [2] http://cvlab.epfl.ch/software/daisy\\n    '\n    check_nD(image, 2, 'img')\n    image = img_as_float(image)\n    float_dtype = image.dtype\n    if sigmas is not None and ring_radii is not None and (len(sigmas) - 1 != len(ring_radii)):\n        raise ValueError('`len(sigmas)-1 != len(ring_radii)`')\n    if ring_radii is not None:\n        rings = len(ring_radii)\n        radius = ring_radii[-1]\n    if sigmas is not None:\n        rings = len(sigmas) - 1\n    if sigmas is None:\n        sigmas = [radius * (i + 1) / float(2 * rings) for i in range(rings)]\n    if ring_radii is None:\n        ring_radii = [radius * (i + 1) / float(rings) for i in range(rings)]\n    if normalization not in ['l1', 'l2', 'daisy', 'off']:\n        raise ValueError('Invalid normalization method.')\n    dx = np.zeros(image.shape, dtype=float_dtype)\n    dy = np.zeros(image.shape, dtype=float_dtype)\n    dx[:, :-1] = np.diff(image, n=1, axis=1)\n    dy[:-1, :] = np.diff(image, n=1, axis=0)\n    grad_mag = sqrt(dx ** 2 + dy ** 2)\n    grad_ori = arctan2(dy, dx)\n    orientation_kappa = orientations / pi\n    orientation_angles = [2 * o * pi / orientations - pi for o in range(orientations)]\n    hist = np.empty((orientations,) + image.shape, dtype=float_dtype)\n    for (i, o) in enumerate(orientation_angles):\n        hist[i, :, :] = exp(orientation_kappa * np.cos(grad_ori - o))\n        hist[i, :, :] = np.multiply(hist[i, :, :], grad_mag)\n    sigmas = [sigmas[0]] + sigmas\n    hist_smooth = np.empty((rings + 1,) + hist.shape, dtype=float_dtype)\n    for i in range(rings + 1):\n        for j in range(orientations):\n            hist_smooth[i, j, :, :] = gaussian(hist[j, :, :], sigma=sigmas[i], mode='reflect')\n    theta = [2 * pi * j / histograms for j in range(histograms)]\n    desc_dims = (rings * histograms + 1) * orientations\n    descs = np.empty((desc_dims, image.shape[0] - 2 * radius, image.shape[1] - 2 * radius), dtype=float_dtype)\n    descs[:orientations, :, :] = hist_smooth[0, :, radius:-radius, radius:-radius]\n    idx = orientations\n    for i in range(rings):\n        for j in range(histograms):\n            y_min = radius + int(round(ring_radii[i] * math.sin(theta[j])))\n            y_max = descs.shape[1] + y_min\n            x_min = radius + int(round(ring_radii[i] * math.cos(theta[j])))\n            x_max = descs.shape[2] + x_min\n            descs[idx:idx + orientations, :, :] = hist_smooth[i + 1, :, y_min:y_max, x_min:x_max]\n            idx += orientations\n    descs = descs[:, ::step, ::step]\n    descs = descs.swapaxes(0, 1).swapaxes(1, 2)\n    if normalization != 'off':\n        descs += 1e-10\n        if normalization == 'l1':\n            descs /= np.sum(descs, axis=2)[:, :, np.newaxis]\n        elif normalization == 'l2':\n            descs /= sqrt(np.sum(descs ** 2, axis=2))[:, :, np.newaxis]\n        elif normalization == 'daisy':\n            for i in range(0, desc_dims, orientations):\n                norms = sqrt(np.sum(descs[:, :, i:i + orientations] ** 2, axis=2))\n                descs[:, :, i:i + orientations] /= norms[:, :, np.newaxis]\n    if visualize:\n        descs_img = gray2rgb(image)\n        for i in range(descs.shape[0]):\n            for j in range(descs.shape[1]):\n                color = [1, 0, 0]\n                desc_y = i * step + radius\n                desc_x = j * step + radius\n                (rows, cols, val) = draw.circle_perimeter_aa(desc_y, desc_x, int(sigmas[0]))\n                draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                max_bin = np.max(descs[i, j, :])\n                for (o_num, o) in enumerate(orientation_angles):\n                    bin_size = descs[i, j, o_num] / max_bin\n                    dy = sigmas[0] * bin_size * math.sin(o)\n                    dx = sigmas[0] * bin_size * math.cos(o)\n                    (rows, cols, val) = draw.line_aa(desc_y, desc_x, int(desc_y + dy), int(desc_x + dx))\n                    draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                for (r_num, r) in enumerate(ring_radii):\n                    color_offset = float(1 + r_num) / rings\n                    color = (1 - color_offset, 1, color_offset)\n                    for (t_num, t) in enumerate(theta):\n                        hist_y = desc_y + int(round(r * math.sin(t)))\n                        hist_x = desc_x + int(round(r * math.cos(t)))\n                        (rows, cols, val) = draw.circle_perimeter_aa(hist_y, hist_x, int(sigmas[r_num + 1]))\n                        draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                        for (o_num, o) in enumerate(orientation_angles):\n                            bin_size = descs[i, j, orientations + r_num * histograms * orientations + t_num * orientations + o_num]\n                            bin_size /= max_bin\n                            dy = sigmas[r_num + 1] * bin_size * math.sin(o)\n                            dx = sigmas[r_num + 1] * bin_size * math.cos(o)\n                            (rows, cols, val) = draw.line_aa(hist_y, hist_x, int(hist_y + dy), int(hist_x + dx))\n                            draw.set_color(descs_img, (rows, cols), color, alpha=val)\n        return (descs, descs_img)\n    else:\n        return descs",
            "def daisy(image, step=4, radius=15, rings=3, histograms=8, orientations=8, normalization='l1', sigmas=None, ring_radii=None, visualize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Extract DAISY feature descriptors densely for the given image.\\n\\n    DAISY is a feature descriptor similar to SIFT formulated in a way that\\n    allows for fast dense extraction. Typically, this is practical for\\n    bag-of-features image representations.\\n\\n    The implementation follows Tola et al. [1]_ but deviate on the following\\n    points:\\n\\n      * Histogram bin contribution are smoothed with a circular Gaussian\\n        window over the tonal range (the angular range).\\n      * The sigma values of the spatial Gaussian smoothing in this code do not\\n        match the sigma values in the original code by Tola et al. [2]_. In\\n        their code, spatial smoothing is applied to both the input image and\\n        the center histogram. However, this smoothing is not documented in [1]_\\n        and, therefore, it is omitted.\\n\\n    Parameters\\n    ----------\\n    image : (M, N) array\\n        Input image (grayscale).\\n    step : int, optional\\n        Distance between descriptor sampling points.\\n    radius : int, optional\\n        Radius (in pixels) of the outermost ring.\\n    rings : int, optional\\n        Number of rings.\\n    histograms : int, optional\\n        Number of histograms sampled per ring.\\n    orientations : int, optional\\n        Number of orientations (bins) per histogram.\\n    normalization : [ \\'l1\\' | \\'l2\\' | \\'daisy\\' | \\'off\\' ], optional\\n        How to normalize the descriptors\\n\\n          * \\'l1\\': L1-normalization of each descriptor.\\n          * \\'l2\\': L2-normalization of each descriptor.\\n          * \\'daisy\\': L2-normalization of individual histograms.\\n          * \\'off\\': Disable normalization.\\n\\n    sigmas : 1D array of float, optional\\n        Standard deviation of spatial Gaussian smoothing for the center\\n        histogram and for each ring of histograms. The array of sigmas should\\n        be sorted from the center and out. I.e. the first sigma value defines\\n        the spatial smoothing of the center histogram and the last sigma value\\n        defines the spatial smoothing of the outermost ring. Specifying sigmas\\n        overrides the following parameter.\\n\\n            ``rings = len(sigmas) - 1``\\n\\n    ring_radii : 1D array of int, optional\\n        Radius (in pixels) for each ring. Specifying ring_radii overrides the\\n        following two parameters.\\n\\n            ``rings = len(ring_radii)``\\n            ``radius = ring_radii[-1]``\\n\\n        If both sigmas and ring_radii are given, they must satisfy the\\n        following predicate since no radius is needed for the center\\n        histogram.\\n\\n            ``len(ring_radii) == len(sigmas) + 1``\\n\\n    visualize : bool, optional\\n        Generate a visualization of the DAISY descriptors\\n\\n    Returns\\n    -------\\n    descs : array\\n        Grid of DAISY descriptors for the given image as an array\\n        dimensionality  (P, Q, R) where\\n\\n            ``P = ceil((M - radius*2) / step)``\\n            ``Q = ceil((N - radius*2) / step)``\\n            ``R = (rings * histograms + 1) * orientations``\\n\\n    descs_img : (M, N, 3) array (only if visualize==True)\\n        Visualization of the DAISY descriptors.\\n\\n    References\\n    ----------\\n    .. [1] Tola et al. \"Daisy: An efficient dense descriptor applied to wide-\\n           baseline stereo.\" Pattern Analysis and Machine Intelligence, IEEE\\n           Transactions on 32.5 (2010): 815-830.\\n    .. [2] http://cvlab.epfl.ch/software/daisy\\n    '\n    check_nD(image, 2, 'img')\n    image = img_as_float(image)\n    float_dtype = image.dtype\n    if sigmas is not None and ring_radii is not None and (len(sigmas) - 1 != len(ring_radii)):\n        raise ValueError('`len(sigmas)-1 != len(ring_radii)`')\n    if ring_radii is not None:\n        rings = len(ring_radii)\n        radius = ring_radii[-1]\n    if sigmas is not None:\n        rings = len(sigmas) - 1\n    if sigmas is None:\n        sigmas = [radius * (i + 1) / float(2 * rings) for i in range(rings)]\n    if ring_radii is None:\n        ring_radii = [radius * (i + 1) / float(rings) for i in range(rings)]\n    if normalization not in ['l1', 'l2', 'daisy', 'off']:\n        raise ValueError('Invalid normalization method.')\n    dx = np.zeros(image.shape, dtype=float_dtype)\n    dy = np.zeros(image.shape, dtype=float_dtype)\n    dx[:, :-1] = np.diff(image, n=1, axis=1)\n    dy[:-1, :] = np.diff(image, n=1, axis=0)\n    grad_mag = sqrt(dx ** 2 + dy ** 2)\n    grad_ori = arctan2(dy, dx)\n    orientation_kappa = orientations / pi\n    orientation_angles = [2 * o * pi / orientations - pi for o in range(orientations)]\n    hist = np.empty((orientations,) + image.shape, dtype=float_dtype)\n    for (i, o) in enumerate(orientation_angles):\n        hist[i, :, :] = exp(orientation_kappa * np.cos(grad_ori - o))\n        hist[i, :, :] = np.multiply(hist[i, :, :], grad_mag)\n    sigmas = [sigmas[0]] + sigmas\n    hist_smooth = np.empty((rings + 1,) + hist.shape, dtype=float_dtype)\n    for i in range(rings + 1):\n        for j in range(orientations):\n            hist_smooth[i, j, :, :] = gaussian(hist[j, :, :], sigma=sigmas[i], mode='reflect')\n    theta = [2 * pi * j / histograms for j in range(histograms)]\n    desc_dims = (rings * histograms + 1) * orientations\n    descs = np.empty((desc_dims, image.shape[0] - 2 * radius, image.shape[1] - 2 * radius), dtype=float_dtype)\n    descs[:orientations, :, :] = hist_smooth[0, :, radius:-radius, radius:-radius]\n    idx = orientations\n    for i in range(rings):\n        for j in range(histograms):\n            y_min = radius + int(round(ring_radii[i] * math.sin(theta[j])))\n            y_max = descs.shape[1] + y_min\n            x_min = radius + int(round(ring_radii[i] * math.cos(theta[j])))\n            x_max = descs.shape[2] + x_min\n            descs[idx:idx + orientations, :, :] = hist_smooth[i + 1, :, y_min:y_max, x_min:x_max]\n            idx += orientations\n    descs = descs[:, ::step, ::step]\n    descs = descs.swapaxes(0, 1).swapaxes(1, 2)\n    if normalization != 'off':\n        descs += 1e-10\n        if normalization == 'l1':\n            descs /= np.sum(descs, axis=2)[:, :, np.newaxis]\n        elif normalization == 'l2':\n            descs /= sqrt(np.sum(descs ** 2, axis=2))[:, :, np.newaxis]\n        elif normalization == 'daisy':\n            for i in range(0, desc_dims, orientations):\n                norms = sqrt(np.sum(descs[:, :, i:i + orientations] ** 2, axis=2))\n                descs[:, :, i:i + orientations] /= norms[:, :, np.newaxis]\n    if visualize:\n        descs_img = gray2rgb(image)\n        for i in range(descs.shape[0]):\n            for j in range(descs.shape[1]):\n                color = [1, 0, 0]\n                desc_y = i * step + radius\n                desc_x = j * step + radius\n                (rows, cols, val) = draw.circle_perimeter_aa(desc_y, desc_x, int(sigmas[0]))\n                draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                max_bin = np.max(descs[i, j, :])\n                for (o_num, o) in enumerate(orientation_angles):\n                    bin_size = descs[i, j, o_num] / max_bin\n                    dy = sigmas[0] * bin_size * math.sin(o)\n                    dx = sigmas[0] * bin_size * math.cos(o)\n                    (rows, cols, val) = draw.line_aa(desc_y, desc_x, int(desc_y + dy), int(desc_x + dx))\n                    draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                for (r_num, r) in enumerate(ring_radii):\n                    color_offset = float(1 + r_num) / rings\n                    color = (1 - color_offset, 1, color_offset)\n                    for (t_num, t) in enumerate(theta):\n                        hist_y = desc_y + int(round(r * math.sin(t)))\n                        hist_x = desc_x + int(round(r * math.cos(t)))\n                        (rows, cols, val) = draw.circle_perimeter_aa(hist_y, hist_x, int(sigmas[r_num + 1]))\n                        draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                        for (o_num, o) in enumerate(orientation_angles):\n                            bin_size = descs[i, j, orientations + r_num * histograms * orientations + t_num * orientations + o_num]\n                            bin_size /= max_bin\n                            dy = sigmas[r_num + 1] * bin_size * math.sin(o)\n                            dx = sigmas[r_num + 1] * bin_size * math.cos(o)\n                            (rows, cols, val) = draw.line_aa(hist_y, hist_x, int(hist_y + dy), int(hist_x + dx))\n                            draw.set_color(descs_img, (rows, cols), color, alpha=val)\n        return (descs, descs_img)\n    else:\n        return descs",
            "def daisy(image, step=4, radius=15, rings=3, histograms=8, orientations=8, normalization='l1', sigmas=None, ring_radii=None, visualize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Extract DAISY feature descriptors densely for the given image.\\n\\n    DAISY is a feature descriptor similar to SIFT formulated in a way that\\n    allows for fast dense extraction. Typically, this is practical for\\n    bag-of-features image representations.\\n\\n    The implementation follows Tola et al. [1]_ but deviate on the following\\n    points:\\n\\n      * Histogram bin contribution are smoothed with a circular Gaussian\\n        window over the tonal range (the angular range).\\n      * The sigma values of the spatial Gaussian smoothing in this code do not\\n        match the sigma values in the original code by Tola et al. [2]_. In\\n        their code, spatial smoothing is applied to both the input image and\\n        the center histogram. However, this smoothing is not documented in [1]_\\n        and, therefore, it is omitted.\\n\\n    Parameters\\n    ----------\\n    image : (M, N) array\\n        Input image (grayscale).\\n    step : int, optional\\n        Distance between descriptor sampling points.\\n    radius : int, optional\\n        Radius (in pixels) of the outermost ring.\\n    rings : int, optional\\n        Number of rings.\\n    histograms : int, optional\\n        Number of histograms sampled per ring.\\n    orientations : int, optional\\n        Number of orientations (bins) per histogram.\\n    normalization : [ \\'l1\\' | \\'l2\\' | \\'daisy\\' | \\'off\\' ], optional\\n        How to normalize the descriptors\\n\\n          * \\'l1\\': L1-normalization of each descriptor.\\n          * \\'l2\\': L2-normalization of each descriptor.\\n          * \\'daisy\\': L2-normalization of individual histograms.\\n          * \\'off\\': Disable normalization.\\n\\n    sigmas : 1D array of float, optional\\n        Standard deviation of spatial Gaussian smoothing for the center\\n        histogram and for each ring of histograms. The array of sigmas should\\n        be sorted from the center and out. I.e. the first sigma value defines\\n        the spatial smoothing of the center histogram and the last sigma value\\n        defines the spatial smoothing of the outermost ring. Specifying sigmas\\n        overrides the following parameter.\\n\\n            ``rings = len(sigmas) - 1``\\n\\n    ring_radii : 1D array of int, optional\\n        Radius (in pixels) for each ring. Specifying ring_radii overrides the\\n        following two parameters.\\n\\n            ``rings = len(ring_radii)``\\n            ``radius = ring_radii[-1]``\\n\\n        If both sigmas and ring_radii are given, they must satisfy the\\n        following predicate since no radius is needed for the center\\n        histogram.\\n\\n            ``len(ring_radii) == len(sigmas) + 1``\\n\\n    visualize : bool, optional\\n        Generate a visualization of the DAISY descriptors\\n\\n    Returns\\n    -------\\n    descs : array\\n        Grid of DAISY descriptors for the given image as an array\\n        dimensionality  (P, Q, R) where\\n\\n            ``P = ceil((M - radius*2) / step)``\\n            ``Q = ceil((N - radius*2) / step)``\\n            ``R = (rings * histograms + 1) * orientations``\\n\\n    descs_img : (M, N, 3) array (only if visualize==True)\\n        Visualization of the DAISY descriptors.\\n\\n    References\\n    ----------\\n    .. [1] Tola et al. \"Daisy: An efficient dense descriptor applied to wide-\\n           baseline stereo.\" Pattern Analysis and Machine Intelligence, IEEE\\n           Transactions on 32.5 (2010): 815-830.\\n    .. [2] http://cvlab.epfl.ch/software/daisy\\n    '\n    check_nD(image, 2, 'img')\n    image = img_as_float(image)\n    float_dtype = image.dtype\n    if sigmas is not None and ring_radii is not None and (len(sigmas) - 1 != len(ring_radii)):\n        raise ValueError('`len(sigmas)-1 != len(ring_radii)`')\n    if ring_radii is not None:\n        rings = len(ring_radii)\n        radius = ring_radii[-1]\n    if sigmas is not None:\n        rings = len(sigmas) - 1\n    if sigmas is None:\n        sigmas = [radius * (i + 1) / float(2 * rings) for i in range(rings)]\n    if ring_radii is None:\n        ring_radii = [radius * (i + 1) / float(rings) for i in range(rings)]\n    if normalization not in ['l1', 'l2', 'daisy', 'off']:\n        raise ValueError('Invalid normalization method.')\n    dx = np.zeros(image.shape, dtype=float_dtype)\n    dy = np.zeros(image.shape, dtype=float_dtype)\n    dx[:, :-1] = np.diff(image, n=1, axis=1)\n    dy[:-1, :] = np.diff(image, n=1, axis=0)\n    grad_mag = sqrt(dx ** 2 + dy ** 2)\n    grad_ori = arctan2(dy, dx)\n    orientation_kappa = orientations / pi\n    orientation_angles = [2 * o * pi / orientations - pi for o in range(orientations)]\n    hist = np.empty((orientations,) + image.shape, dtype=float_dtype)\n    for (i, o) in enumerate(orientation_angles):\n        hist[i, :, :] = exp(orientation_kappa * np.cos(grad_ori - o))\n        hist[i, :, :] = np.multiply(hist[i, :, :], grad_mag)\n    sigmas = [sigmas[0]] + sigmas\n    hist_smooth = np.empty((rings + 1,) + hist.shape, dtype=float_dtype)\n    for i in range(rings + 1):\n        for j in range(orientations):\n            hist_smooth[i, j, :, :] = gaussian(hist[j, :, :], sigma=sigmas[i], mode='reflect')\n    theta = [2 * pi * j / histograms for j in range(histograms)]\n    desc_dims = (rings * histograms + 1) * orientations\n    descs = np.empty((desc_dims, image.shape[0] - 2 * radius, image.shape[1] - 2 * radius), dtype=float_dtype)\n    descs[:orientations, :, :] = hist_smooth[0, :, radius:-radius, radius:-radius]\n    idx = orientations\n    for i in range(rings):\n        for j in range(histograms):\n            y_min = radius + int(round(ring_radii[i] * math.sin(theta[j])))\n            y_max = descs.shape[1] + y_min\n            x_min = radius + int(round(ring_radii[i] * math.cos(theta[j])))\n            x_max = descs.shape[2] + x_min\n            descs[idx:idx + orientations, :, :] = hist_smooth[i + 1, :, y_min:y_max, x_min:x_max]\n            idx += orientations\n    descs = descs[:, ::step, ::step]\n    descs = descs.swapaxes(0, 1).swapaxes(1, 2)\n    if normalization != 'off':\n        descs += 1e-10\n        if normalization == 'l1':\n            descs /= np.sum(descs, axis=2)[:, :, np.newaxis]\n        elif normalization == 'l2':\n            descs /= sqrt(np.sum(descs ** 2, axis=2))[:, :, np.newaxis]\n        elif normalization == 'daisy':\n            for i in range(0, desc_dims, orientations):\n                norms = sqrt(np.sum(descs[:, :, i:i + orientations] ** 2, axis=2))\n                descs[:, :, i:i + orientations] /= norms[:, :, np.newaxis]\n    if visualize:\n        descs_img = gray2rgb(image)\n        for i in range(descs.shape[0]):\n            for j in range(descs.shape[1]):\n                color = [1, 0, 0]\n                desc_y = i * step + radius\n                desc_x = j * step + radius\n                (rows, cols, val) = draw.circle_perimeter_aa(desc_y, desc_x, int(sigmas[0]))\n                draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                max_bin = np.max(descs[i, j, :])\n                for (o_num, o) in enumerate(orientation_angles):\n                    bin_size = descs[i, j, o_num] / max_bin\n                    dy = sigmas[0] * bin_size * math.sin(o)\n                    dx = sigmas[0] * bin_size * math.cos(o)\n                    (rows, cols, val) = draw.line_aa(desc_y, desc_x, int(desc_y + dy), int(desc_x + dx))\n                    draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                for (r_num, r) in enumerate(ring_radii):\n                    color_offset = float(1 + r_num) / rings\n                    color = (1 - color_offset, 1, color_offset)\n                    for (t_num, t) in enumerate(theta):\n                        hist_y = desc_y + int(round(r * math.sin(t)))\n                        hist_x = desc_x + int(round(r * math.cos(t)))\n                        (rows, cols, val) = draw.circle_perimeter_aa(hist_y, hist_x, int(sigmas[r_num + 1]))\n                        draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                        for (o_num, o) in enumerate(orientation_angles):\n                            bin_size = descs[i, j, orientations + r_num * histograms * orientations + t_num * orientations + o_num]\n                            bin_size /= max_bin\n                            dy = sigmas[r_num + 1] * bin_size * math.sin(o)\n                            dx = sigmas[r_num + 1] * bin_size * math.cos(o)\n                            (rows, cols, val) = draw.line_aa(hist_y, hist_x, int(hist_y + dy), int(hist_x + dx))\n                            draw.set_color(descs_img, (rows, cols), color, alpha=val)\n        return (descs, descs_img)\n    else:\n        return descs",
            "def daisy(image, step=4, radius=15, rings=3, histograms=8, orientations=8, normalization='l1', sigmas=None, ring_radii=None, visualize=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Extract DAISY feature descriptors densely for the given image.\\n\\n    DAISY is a feature descriptor similar to SIFT formulated in a way that\\n    allows for fast dense extraction. Typically, this is practical for\\n    bag-of-features image representations.\\n\\n    The implementation follows Tola et al. [1]_ but deviate on the following\\n    points:\\n\\n      * Histogram bin contribution are smoothed with a circular Gaussian\\n        window over the tonal range (the angular range).\\n      * The sigma values of the spatial Gaussian smoothing in this code do not\\n        match the sigma values in the original code by Tola et al. [2]_. In\\n        their code, spatial smoothing is applied to both the input image and\\n        the center histogram. However, this smoothing is not documented in [1]_\\n        and, therefore, it is omitted.\\n\\n    Parameters\\n    ----------\\n    image : (M, N) array\\n        Input image (grayscale).\\n    step : int, optional\\n        Distance between descriptor sampling points.\\n    radius : int, optional\\n        Radius (in pixels) of the outermost ring.\\n    rings : int, optional\\n        Number of rings.\\n    histograms : int, optional\\n        Number of histograms sampled per ring.\\n    orientations : int, optional\\n        Number of orientations (bins) per histogram.\\n    normalization : [ \\'l1\\' | \\'l2\\' | \\'daisy\\' | \\'off\\' ], optional\\n        How to normalize the descriptors\\n\\n          * \\'l1\\': L1-normalization of each descriptor.\\n          * \\'l2\\': L2-normalization of each descriptor.\\n          * \\'daisy\\': L2-normalization of individual histograms.\\n          * \\'off\\': Disable normalization.\\n\\n    sigmas : 1D array of float, optional\\n        Standard deviation of spatial Gaussian smoothing for the center\\n        histogram and for each ring of histograms. The array of sigmas should\\n        be sorted from the center and out. I.e. the first sigma value defines\\n        the spatial smoothing of the center histogram and the last sigma value\\n        defines the spatial smoothing of the outermost ring. Specifying sigmas\\n        overrides the following parameter.\\n\\n            ``rings = len(sigmas) - 1``\\n\\n    ring_radii : 1D array of int, optional\\n        Radius (in pixels) for each ring. Specifying ring_radii overrides the\\n        following two parameters.\\n\\n            ``rings = len(ring_radii)``\\n            ``radius = ring_radii[-1]``\\n\\n        If both sigmas and ring_radii are given, they must satisfy the\\n        following predicate since no radius is needed for the center\\n        histogram.\\n\\n            ``len(ring_radii) == len(sigmas) + 1``\\n\\n    visualize : bool, optional\\n        Generate a visualization of the DAISY descriptors\\n\\n    Returns\\n    -------\\n    descs : array\\n        Grid of DAISY descriptors for the given image as an array\\n        dimensionality  (P, Q, R) where\\n\\n            ``P = ceil((M - radius*2) / step)``\\n            ``Q = ceil((N - radius*2) / step)``\\n            ``R = (rings * histograms + 1) * orientations``\\n\\n    descs_img : (M, N, 3) array (only if visualize==True)\\n        Visualization of the DAISY descriptors.\\n\\n    References\\n    ----------\\n    .. [1] Tola et al. \"Daisy: An efficient dense descriptor applied to wide-\\n           baseline stereo.\" Pattern Analysis and Machine Intelligence, IEEE\\n           Transactions on 32.5 (2010): 815-830.\\n    .. [2] http://cvlab.epfl.ch/software/daisy\\n    '\n    check_nD(image, 2, 'img')\n    image = img_as_float(image)\n    float_dtype = image.dtype\n    if sigmas is not None and ring_radii is not None and (len(sigmas) - 1 != len(ring_radii)):\n        raise ValueError('`len(sigmas)-1 != len(ring_radii)`')\n    if ring_radii is not None:\n        rings = len(ring_radii)\n        radius = ring_radii[-1]\n    if sigmas is not None:\n        rings = len(sigmas) - 1\n    if sigmas is None:\n        sigmas = [radius * (i + 1) / float(2 * rings) for i in range(rings)]\n    if ring_radii is None:\n        ring_radii = [radius * (i + 1) / float(rings) for i in range(rings)]\n    if normalization not in ['l1', 'l2', 'daisy', 'off']:\n        raise ValueError('Invalid normalization method.')\n    dx = np.zeros(image.shape, dtype=float_dtype)\n    dy = np.zeros(image.shape, dtype=float_dtype)\n    dx[:, :-1] = np.diff(image, n=1, axis=1)\n    dy[:-1, :] = np.diff(image, n=1, axis=0)\n    grad_mag = sqrt(dx ** 2 + dy ** 2)\n    grad_ori = arctan2(dy, dx)\n    orientation_kappa = orientations / pi\n    orientation_angles = [2 * o * pi / orientations - pi for o in range(orientations)]\n    hist = np.empty((orientations,) + image.shape, dtype=float_dtype)\n    for (i, o) in enumerate(orientation_angles):\n        hist[i, :, :] = exp(orientation_kappa * np.cos(grad_ori - o))\n        hist[i, :, :] = np.multiply(hist[i, :, :], grad_mag)\n    sigmas = [sigmas[0]] + sigmas\n    hist_smooth = np.empty((rings + 1,) + hist.shape, dtype=float_dtype)\n    for i in range(rings + 1):\n        for j in range(orientations):\n            hist_smooth[i, j, :, :] = gaussian(hist[j, :, :], sigma=sigmas[i], mode='reflect')\n    theta = [2 * pi * j / histograms for j in range(histograms)]\n    desc_dims = (rings * histograms + 1) * orientations\n    descs = np.empty((desc_dims, image.shape[0] - 2 * radius, image.shape[1] - 2 * radius), dtype=float_dtype)\n    descs[:orientations, :, :] = hist_smooth[0, :, radius:-radius, radius:-radius]\n    idx = orientations\n    for i in range(rings):\n        for j in range(histograms):\n            y_min = radius + int(round(ring_radii[i] * math.sin(theta[j])))\n            y_max = descs.shape[1] + y_min\n            x_min = radius + int(round(ring_radii[i] * math.cos(theta[j])))\n            x_max = descs.shape[2] + x_min\n            descs[idx:idx + orientations, :, :] = hist_smooth[i + 1, :, y_min:y_max, x_min:x_max]\n            idx += orientations\n    descs = descs[:, ::step, ::step]\n    descs = descs.swapaxes(0, 1).swapaxes(1, 2)\n    if normalization != 'off':\n        descs += 1e-10\n        if normalization == 'l1':\n            descs /= np.sum(descs, axis=2)[:, :, np.newaxis]\n        elif normalization == 'l2':\n            descs /= sqrt(np.sum(descs ** 2, axis=2))[:, :, np.newaxis]\n        elif normalization == 'daisy':\n            for i in range(0, desc_dims, orientations):\n                norms = sqrt(np.sum(descs[:, :, i:i + orientations] ** 2, axis=2))\n                descs[:, :, i:i + orientations] /= norms[:, :, np.newaxis]\n    if visualize:\n        descs_img = gray2rgb(image)\n        for i in range(descs.shape[0]):\n            for j in range(descs.shape[1]):\n                color = [1, 0, 0]\n                desc_y = i * step + radius\n                desc_x = j * step + radius\n                (rows, cols, val) = draw.circle_perimeter_aa(desc_y, desc_x, int(sigmas[0]))\n                draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                max_bin = np.max(descs[i, j, :])\n                for (o_num, o) in enumerate(orientation_angles):\n                    bin_size = descs[i, j, o_num] / max_bin\n                    dy = sigmas[0] * bin_size * math.sin(o)\n                    dx = sigmas[0] * bin_size * math.cos(o)\n                    (rows, cols, val) = draw.line_aa(desc_y, desc_x, int(desc_y + dy), int(desc_x + dx))\n                    draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                for (r_num, r) in enumerate(ring_radii):\n                    color_offset = float(1 + r_num) / rings\n                    color = (1 - color_offset, 1, color_offset)\n                    for (t_num, t) in enumerate(theta):\n                        hist_y = desc_y + int(round(r * math.sin(t)))\n                        hist_x = desc_x + int(round(r * math.cos(t)))\n                        (rows, cols, val) = draw.circle_perimeter_aa(hist_y, hist_x, int(sigmas[r_num + 1]))\n                        draw.set_color(descs_img, (rows, cols), color, alpha=val)\n                        for (o_num, o) in enumerate(orientation_angles):\n                            bin_size = descs[i, j, orientations + r_num * histograms * orientations + t_num * orientations + o_num]\n                            bin_size /= max_bin\n                            dy = sigmas[r_num + 1] * bin_size * math.sin(o)\n                            dx = sigmas[r_num + 1] * bin_size * math.cos(o)\n                            (rows, cols, val) = draw.line_aa(hist_y, hist_x, int(hist_y + dy), int(hist_x + dx))\n                            draw.set_color(descs_img, (rows, cols), color, alpha=val)\n        return (descs, descs_img)\n    else:\n        return descs"
        ]
    }
]