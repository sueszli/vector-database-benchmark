[
    {
        "func_name": "__call__",
        "original": "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    if self.target is Target.DECLARATION:\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack);\\n'\n    else:\n        sig_group = CppSignatureGroup.from_native_function(f, method=Variant.method in f.variants)\n        sig = sig_group.most_faithful_signature()\n        (binding_list, code_list) = convert_arguments(f)\n        code_connector = '\\n\\t'\n        arg_connector = ', '\n        prefix = 'self_base.' if sig.method else 'at::'\n        translated_args = translate(binding_list, sig.arguments(), method=sig.method)\n        args_str = f'{arg_connector.join((e.expr for e in translated_args))}'\n        if len(f.func.returns) == 0:\n            ret_str = ''\n            push_str = ''\n        else:\n            ret_str = 'auto result_ = '\n            push_str = '\\n    pack(stack, std::move(result_));\\n                '\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack) {{\\n    {code_connector.join(code_list)}\\n\\n    drop(stack, {len(binding_list)});\\n\\n    {ret_str}{prefix}{sig.name()}({args_str});\\n    {push_str}\\n}}\\n'",
        "mutated": [
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    if self.target is Target.DECLARATION:\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack);\\n'\n    else:\n        sig_group = CppSignatureGroup.from_native_function(f, method=Variant.method in f.variants)\n        sig = sig_group.most_faithful_signature()\n        (binding_list, code_list) = convert_arguments(f)\n        code_connector = '\\n\\t'\n        arg_connector = ', '\n        prefix = 'self_base.' if sig.method else 'at::'\n        translated_args = translate(binding_list, sig.arguments(), method=sig.method)\n        args_str = f'{arg_connector.join((e.expr for e in translated_args))}'\n        if len(f.func.returns) == 0:\n            ret_str = ''\n            push_str = ''\n        else:\n            ret_str = 'auto result_ = '\n            push_str = '\\n    pack(stack, std::move(result_));\\n                '\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack) {{\\n    {code_connector.join(code_list)}\\n\\n    drop(stack, {len(binding_list)});\\n\\n    {ret_str}{prefix}{sig.name()}({args_str});\\n    {push_str}\\n}}\\n'",
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    if self.target is Target.DECLARATION:\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack);\\n'\n    else:\n        sig_group = CppSignatureGroup.from_native_function(f, method=Variant.method in f.variants)\n        sig = sig_group.most_faithful_signature()\n        (binding_list, code_list) = convert_arguments(f)\n        code_connector = '\\n\\t'\n        arg_connector = ', '\n        prefix = 'self_base.' if sig.method else 'at::'\n        translated_args = translate(binding_list, sig.arguments(), method=sig.method)\n        args_str = f'{arg_connector.join((e.expr for e in translated_args))}'\n        if len(f.func.returns) == 0:\n            ret_str = ''\n            push_str = ''\n        else:\n            ret_str = 'auto result_ = '\n            push_str = '\\n    pack(stack, std::move(result_));\\n                '\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack) {{\\n    {code_connector.join(code_list)}\\n\\n    drop(stack, {len(binding_list)});\\n\\n    {ret_str}{prefix}{sig.name()}({args_str});\\n    {push_str}\\n}}\\n'",
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    if self.target is Target.DECLARATION:\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack);\\n'\n    else:\n        sig_group = CppSignatureGroup.from_native_function(f, method=Variant.method in f.variants)\n        sig = sig_group.most_faithful_signature()\n        (binding_list, code_list) = convert_arguments(f)\n        code_connector = '\\n\\t'\n        arg_connector = ', '\n        prefix = 'self_base.' if sig.method else 'at::'\n        translated_args = translate(binding_list, sig.arguments(), method=sig.method)\n        args_str = f'{arg_connector.join((e.expr for e in translated_args))}'\n        if len(f.func.returns) == 0:\n            ret_str = ''\n            push_str = ''\n        else:\n            ret_str = 'auto result_ = '\n            push_str = '\\n    pack(stack, std::move(result_));\\n                '\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack) {{\\n    {code_connector.join(code_list)}\\n\\n    drop(stack, {len(binding_list)});\\n\\n    {ret_str}{prefix}{sig.name()}({args_str});\\n    {push_str}\\n}}\\n'",
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    if self.target is Target.DECLARATION:\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack);\\n'\n    else:\n        sig_group = CppSignatureGroup.from_native_function(f, method=Variant.method in f.variants)\n        sig = sig_group.most_faithful_signature()\n        (binding_list, code_list) = convert_arguments(f)\n        code_connector = '\\n\\t'\n        arg_connector = ', '\n        prefix = 'self_base.' if sig.method else 'at::'\n        translated_args = translate(binding_list, sig.arguments(), method=sig.method)\n        args_str = f'{arg_connector.join((e.expr for e in translated_args))}'\n        if len(f.func.returns) == 0:\n            ret_str = ''\n            push_str = ''\n        else:\n            ret_str = 'auto result_ = '\n            push_str = '\\n    pack(stack, std::move(result_));\\n                '\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack) {{\\n    {code_connector.join(code_list)}\\n\\n    drop(stack, {len(binding_list)});\\n\\n    {ret_str}{prefix}{sig.name()}({args_str});\\n    {push_str}\\n}}\\n'",
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    if self.target is Target.DECLARATION:\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack);\\n'\n    else:\n        sig_group = CppSignatureGroup.from_native_function(f, method=Variant.method in f.variants)\n        sig = sig_group.most_faithful_signature()\n        (binding_list, code_list) = convert_arguments(f)\n        code_connector = '\\n\\t'\n        arg_connector = ', '\n        prefix = 'self_base.' if sig.method else 'at::'\n        translated_args = translate(binding_list, sig.arguments(), method=sig.method)\n        args_str = f'{arg_connector.join((e.expr for e in translated_args))}'\n        if len(f.func.returns) == 0:\n            ret_str = ''\n            push_str = ''\n        else:\n            ret_str = 'auto result_ = '\n            push_str = '\\n    pack(stack, std::move(result_));\\n                '\n        return f'\\n// aten::{f.func}\\nTORCH_API void {f.func.name.unambiguous_name()}(Stack & stack) {{\\n    {code_connector.join(code_list)}\\n\\n    drop(stack, {len(binding_list)});\\n\\n    {ret_str}{prefix}{sig.name()}({args_str});\\n    {push_str}\\n}}\\n'"
        ]
    },
    {
        "func_name": "__call__",
        "original": "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    sig_group = CppSignatureGroup.from_native_function(f, method=False)\n    sig = sig_group.most_faithful_signature()\n    schema = cpp_string(str(sig.func))[1:-1]\n    args = sig.arguments()\n    connector = ',\\n\\t\\t'\n    args_code = []\n    for arg in args:\n        assert isinstance(arg.argument, Argument)\n        if not arg.argument.default:\n            arg_cpp = 'c10::IValue(c10::nullopt)'\n        else:\n            arg_default = cpp.default_expr(arg.argument.default, arg.argument.type, symint=False)\n            if arg_default.startswith('{'):\n                arg_cpp = f'c10::IntArrayRef({arg_default})'\n            else:\n                arg_cpp = f'c10::IValue({arg_default})'\n        args_code.append(f'c10::Argument(\"{arg.name}\", nullptr, c10::nullopt, {arg_cpp})')\n    returns = f.func.returns\n    returns_code = []\n    for ret in returns:\n        returns_code.append(f'''c10::Argument(\"{(ret.name if ret.name else '')}\")''')\n    return f'\\n// aten::{schema}\\nOperatorGenerator(\\n    \"aten::{f.func.name.name}\",\\n    \"{f.func.name.overload_name}\",\\n    {{\\n        {connector.join(args_code)}\\n    }},\\n    {{\\n        {connector.join(returns_code)}\\n    }},\\n    [](Stack & stack) {{\\n        RECORD_FUNCTION(\"{sig.name()}\", std::vector<c10::IValue>());\\n        at::unboxing::{unboxing.name(f)}(stack);\\n    }},\\n    aliasAnalysisFromSchema()\\n),\\n'",
        "mutated": [
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    sig_group = CppSignatureGroup.from_native_function(f, method=False)\n    sig = sig_group.most_faithful_signature()\n    schema = cpp_string(str(sig.func))[1:-1]\n    args = sig.arguments()\n    connector = ',\\n\\t\\t'\n    args_code = []\n    for arg in args:\n        assert isinstance(arg.argument, Argument)\n        if not arg.argument.default:\n            arg_cpp = 'c10::IValue(c10::nullopt)'\n        else:\n            arg_default = cpp.default_expr(arg.argument.default, arg.argument.type, symint=False)\n            if arg_default.startswith('{'):\n                arg_cpp = f'c10::IntArrayRef({arg_default})'\n            else:\n                arg_cpp = f'c10::IValue({arg_default})'\n        args_code.append(f'c10::Argument(\"{arg.name}\", nullptr, c10::nullopt, {arg_cpp})')\n    returns = f.func.returns\n    returns_code = []\n    for ret in returns:\n        returns_code.append(f'''c10::Argument(\"{(ret.name if ret.name else '')}\")''')\n    return f'\\n// aten::{schema}\\nOperatorGenerator(\\n    \"aten::{f.func.name.name}\",\\n    \"{f.func.name.overload_name}\",\\n    {{\\n        {connector.join(args_code)}\\n    }},\\n    {{\\n        {connector.join(returns_code)}\\n    }},\\n    [](Stack & stack) {{\\n        RECORD_FUNCTION(\"{sig.name()}\", std::vector<c10::IValue>());\\n        at::unboxing::{unboxing.name(f)}(stack);\\n    }},\\n    aliasAnalysisFromSchema()\\n),\\n'",
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    sig_group = CppSignatureGroup.from_native_function(f, method=False)\n    sig = sig_group.most_faithful_signature()\n    schema = cpp_string(str(sig.func))[1:-1]\n    args = sig.arguments()\n    connector = ',\\n\\t\\t'\n    args_code = []\n    for arg in args:\n        assert isinstance(arg.argument, Argument)\n        if not arg.argument.default:\n            arg_cpp = 'c10::IValue(c10::nullopt)'\n        else:\n            arg_default = cpp.default_expr(arg.argument.default, arg.argument.type, symint=False)\n            if arg_default.startswith('{'):\n                arg_cpp = f'c10::IntArrayRef({arg_default})'\n            else:\n                arg_cpp = f'c10::IValue({arg_default})'\n        args_code.append(f'c10::Argument(\"{arg.name}\", nullptr, c10::nullopt, {arg_cpp})')\n    returns = f.func.returns\n    returns_code = []\n    for ret in returns:\n        returns_code.append(f'''c10::Argument(\"{(ret.name if ret.name else '')}\")''')\n    return f'\\n// aten::{schema}\\nOperatorGenerator(\\n    \"aten::{f.func.name.name}\",\\n    \"{f.func.name.overload_name}\",\\n    {{\\n        {connector.join(args_code)}\\n    }},\\n    {{\\n        {connector.join(returns_code)}\\n    }},\\n    [](Stack & stack) {{\\n        RECORD_FUNCTION(\"{sig.name()}\", std::vector<c10::IValue>());\\n        at::unboxing::{unboxing.name(f)}(stack);\\n    }},\\n    aliasAnalysisFromSchema()\\n),\\n'",
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    sig_group = CppSignatureGroup.from_native_function(f, method=False)\n    sig = sig_group.most_faithful_signature()\n    schema = cpp_string(str(sig.func))[1:-1]\n    args = sig.arguments()\n    connector = ',\\n\\t\\t'\n    args_code = []\n    for arg in args:\n        assert isinstance(arg.argument, Argument)\n        if not arg.argument.default:\n            arg_cpp = 'c10::IValue(c10::nullopt)'\n        else:\n            arg_default = cpp.default_expr(arg.argument.default, arg.argument.type, symint=False)\n            if arg_default.startswith('{'):\n                arg_cpp = f'c10::IntArrayRef({arg_default})'\n            else:\n                arg_cpp = f'c10::IValue({arg_default})'\n        args_code.append(f'c10::Argument(\"{arg.name}\", nullptr, c10::nullopt, {arg_cpp})')\n    returns = f.func.returns\n    returns_code = []\n    for ret in returns:\n        returns_code.append(f'''c10::Argument(\"{(ret.name if ret.name else '')}\")''')\n    return f'\\n// aten::{schema}\\nOperatorGenerator(\\n    \"aten::{f.func.name.name}\",\\n    \"{f.func.name.overload_name}\",\\n    {{\\n        {connector.join(args_code)}\\n    }},\\n    {{\\n        {connector.join(returns_code)}\\n    }},\\n    [](Stack & stack) {{\\n        RECORD_FUNCTION(\"{sig.name()}\", std::vector<c10::IValue>());\\n        at::unboxing::{unboxing.name(f)}(stack);\\n    }},\\n    aliasAnalysisFromSchema()\\n),\\n'",
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    sig_group = CppSignatureGroup.from_native_function(f, method=False)\n    sig = sig_group.most_faithful_signature()\n    schema = cpp_string(str(sig.func))[1:-1]\n    args = sig.arguments()\n    connector = ',\\n\\t\\t'\n    args_code = []\n    for arg in args:\n        assert isinstance(arg.argument, Argument)\n        if not arg.argument.default:\n            arg_cpp = 'c10::IValue(c10::nullopt)'\n        else:\n            arg_default = cpp.default_expr(arg.argument.default, arg.argument.type, symint=False)\n            if arg_default.startswith('{'):\n                arg_cpp = f'c10::IntArrayRef({arg_default})'\n            else:\n                arg_cpp = f'c10::IValue({arg_default})'\n        args_code.append(f'c10::Argument(\"{arg.name}\", nullptr, c10::nullopt, {arg_cpp})')\n    returns = f.func.returns\n    returns_code = []\n    for ret in returns:\n        returns_code.append(f'''c10::Argument(\"{(ret.name if ret.name else '')}\")''')\n    return f'\\n// aten::{schema}\\nOperatorGenerator(\\n    \"aten::{f.func.name.name}\",\\n    \"{f.func.name.overload_name}\",\\n    {{\\n        {connector.join(args_code)}\\n    }},\\n    {{\\n        {connector.join(returns_code)}\\n    }},\\n    [](Stack & stack) {{\\n        RECORD_FUNCTION(\"{sig.name()}\", std::vector<c10::IValue>());\\n        at::unboxing::{unboxing.name(f)}(stack);\\n    }},\\n    aliasAnalysisFromSchema()\\n),\\n'",
            "@method_with_native_function\ndef __call__(self, f: NativeFunction) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not self.selector.is_root_operator(f'aten::{f.func.name}'):\n        return ''\n    sig_group = CppSignatureGroup.from_native_function(f, method=False)\n    sig = sig_group.most_faithful_signature()\n    schema = cpp_string(str(sig.func))[1:-1]\n    args = sig.arguments()\n    connector = ',\\n\\t\\t'\n    args_code = []\n    for arg in args:\n        assert isinstance(arg.argument, Argument)\n        if not arg.argument.default:\n            arg_cpp = 'c10::IValue(c10::nullopt)'\n        else:\n            arg_default = cpp.default_expr(arg.argument.default, arg.argument.type, symint=False)\n            if arg_default.startswith('{'):\n                arg_cpp = f'c10::IntArrayRef({arg_default})'\n            else:\n                arg_cpp = f'c10::IValue({arg_default})'\n        args_code.append(f'c10::Argument(\"{arg.name}\", nullptr, c10::nullopt, {arg_cpp})')\n    returns = f.func.returns\n    returns_code = []\n    for ret in returns:\n        returns_code.append(f'''c10::Argument(\"{(ret.name if ret.name else '')}\")''')\n    return f'\\n// aten::{schema}\\nOperatorGenerator(\\n    \"aten::{f.func.name.name}\",\\n    \"{f.func.name.overload_name}\",\\n    {{\\n        {connector.join(args_code)}\\n    }},\\n    {{\\n        {connector.join(returns_code)}\\n    }},\\n    [](Stack & stack) {{\\n        RECORD_FUNCTION(\"{sig.name()}\", std::vector<c10::IValue>());\\n        at::unboxing::{unboxing.name(f)}(stack);\\n    }},\\n    aliasAnalysisFromSchema()\\n),\\n'"
        ]
    },
    {
        "func_name": "key_func",
        "original": "def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n    return fn.root_name",
        "mutated": [
            "def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n    if False:\n        i = 10\n    return fn.root_name",
            "def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return fn.root_name",
            "def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return fn.root_name",
            "def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return fn.root_name",
            "def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return fn.root_name"
        ]
    },
    {
        "func_name": "gen_unboxing",
        "original": "def gen_unboxing(*, native_functions: Sequence[NativeFunction], cpu_fm: FileManager, selector: SelectiveBuilder) -> None:\n\n    def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n        return fn.root_name\n    selected_op_num: int = len(selector.operators)\n    sharding_threshold: int = 100\n    cpu_fm.write_sharded('UnboxingFunctions.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'definitions': [ComputeUnboxingFunctions(Target.DEFINITION, selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 5, sharded_keys={'definitions'})\n    cpu_fm.write('UnboxingFunctions.h', lambda : {'declarations': list(mapMaybe(ComputeUnboxingFunctions(Target.DECLARATION, selector), native_functions))})\n    cpu_fm.write_sharded('RegisterCodegenUnboxedKernels.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'unboxed_ops': [ComputeCodegenUnboxedKernels(selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 10, sharded_keys={'unboxed_ops'})",
        "mutated": [
            "def gen_unboxing(*, native_functions: Sequence[NativeFunction], cpu_fm: FileManager, selector: SelectiveBuilder) -> None:\n    if False:\n        i = 10\n\n    def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n        return fn.root_name\n    selected_op_num: int = len(selector.operators)\n    sharding_threshold: int = 100\n    cpu_fm.write_sharded('UnboxingFunctions.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'definitions': [ComputeUnboxingFunctions(Target.DEFINITION, selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 5, sharded_keys={'definitions'})\n    cpu_fm.write('UnboxingFunctions.h', lambda : {'declarations': list(mapMaybe(ComputeUnboxingFunctions(Target.DECLARATION, selector), native_functions))})\n    cpu_fm.write_sharded('RegisterCodegenUnboxedKernels.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'unboxed_ops': [ComputeCodegenUnboxedKernels(selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 10, sharded_keys={'unboxed_ops'})",
            "def gen_unboxing(*, native_functions: Sequence[NativeFunction], cpu_fm: FileManager, selector: SelectiveBuilder) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n        return fn.root_name\n    selected_op_num: int = len(selector.operators)\n    sharding_threshold: int = 100\n    cpu_fm.write_sharded('UnboxingFunctions.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'definitions': [ComputeUnboxingFunctions(Target.DEFINITION, selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 5, sharded_keys={'definitions'})\n    cpu_fm.write('UnboxingFunctions.h', lambda : {'declarations': list(mapMaybe(ComputeUnboxingFunctions(Target.DECLARATION, selector), native_functions))})\n    cpu_fm.write_sharded('RegisterCodegenUnboxedKernels.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'unboxed_ops': [ComputeCodegenUnboxedKernels(selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 10, sharded_keys={'unboxed_ops'})",
            "def gen_unboxing(*, native_functions: Sequence[NativeFunction], cpu_fm: FileManager, selector: SelectiveBuilder) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n        return fn.root_name\n    selected_op_num: int = len(selector.operators)\n    sharding_threshold: int = 100\n    cpu_fm.write_sharded('UnboxingFunctions.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'definitions': [ComputeUnboxingFunctions(Target.DEFINITION, selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 5, sharded_keys={'definitions'})\n    cpu_fm.write('UnboxingFunctions.h', lambda : {'declarations': list(mapMaybe(ComputeUnboxingFunctions(Target.DECLARATION, selector), native_functions))})\n    cpu_fm.write_sharded('RegisterCodegenUnboxedKernels.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'unboxed_ops': [ComputeCodegenUnboxedKernels(selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 10, sharded_keys={'unboxed_ops'})",
            "def gen_unboxing(*, native_functions: Sequence[NativeFunction], cpu_fm: FileManager, selector: SelectiveBuilder) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n        return fn.root_name\n    selected_op_num: int = len(selector.operators)\n    sharding_threshold: int = 100\n    cpu_fm.write_sharded('UnboxingFunctions.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'definitions': [ComputeUnboxingFunctions(Target.DEFINITION, selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 5, sharded_keys={'definitions'})\n    cpu_fm.write('UnboxingFunctions.h', lambda : {'declarations': list(mapMaybe(ComputeUnboxingFunctions(Target.DECLARATION, selector), native_functions))})\n    cpu_fm.write_sharded('RegisterCodegenUnboxedKernels.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'unboxed_ops': [ComputeCodegenUnboxedKernels(selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 10, sharded_keys={'unboxed_ops'})",
            "def gen_unboxing(*, native_functions: Sequence[NativeFunction], cpu_fm: FileManager, selector: SelectiveBuilder) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def key_func(fn: Union[NativeFunction, NativeFunctionsGroup]) -> str:\n        return fn.root_name\n    selected_op_num: int = len(selector.operators)\n    sharding_threshold: int = 100\n    cpu_fm.write_sharded('UnboxingFunctions.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'definitions': [ComputeUnboxingFunctions(Target.DEFINITION, selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 5, sharded_keys={'definitions'})\n    cpu_fm.write('UnboxingFunctions.h', lambda : {'declarations': list(mapMaybe(ComputeUnboxingFunctions(Target.DECLARATION, selector), native_functions))})\n    cpu_fm.write_sharded('RegisterCodegenUnboxedKernels.cpp', native_functions, key_fn=key_func, env_callable=lambda fn: {'unboxed_ops': [ComputeCodegenUnboxedKernels(selector)(fn)]}, num_shards=1 if selected_op_num < sharding_threshold else 10, sharded_keys={'unboxed_ops'})"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(args: List[str]) -> None:\n    parser = argparse.ArgumentParser(description='Generate unboxing source files')\n    parser.add_argument('-s', '--source-path', help='path to source directory for ATen', default='aten/src/ATen')\n    parser.add_argument('-d', '--install-dir', '--install_dir', help='output directory', default='build/aten/src/ATen')\n    parser.add_argument('-o', '--output-dependencies', help='output a list of dependencies into the given file and exit')\n    parser.add_argument('--dry-run', action='store_true', help='run without writing any files (still updates outputs)')\n    parser.add_argument('--op-selection-yaml-path', '--op_selection_yaml_path', help='Provide a path to the operator selection (for custom build) YAML that contains the information about the set of selected operators and their categories (training, ...). Each operator is either a full operator name with overload or just a bare operator name. The operator names also contain the namespace prefix (e.g. aten::)')\n    parser.add_argument('--op-registration-allowlist', '--op_registration_allowlist', nargs='*', help='filter op registrations by the allowlist (if set); each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    parser.add_argument('--TEST-ONLY-op-registration-allowlist-yaml-path', '--TEST_ONLY_op_registration_allowlist_yaml_path', help='Provide a path to the operator selection (for custom build) YAML which contains a list of operators. It is to serve testing purpose and each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    options = parser.parse_args(args)\n    if options.op_registration_allowlist:\n        op_registration_allowlist = options.op_registration_allowlist\n    elif options.TEST_ONLY_op_registration_allowlist_yaml_path:\n        with open(options.TEST_ONLY_op_registration_allowlist_yaml_path) as f:\n            op_registration_allowlist = yaml.safe_load(f)\n    else:\n        op_registration_allowlist = None\n    selector = get_custom_build_selector(op_registration_allowlist, options.op_selection_yaml_path)\n    native_yaml_path = os.path.join(options.source_path, 'native/native_functions.yaml')\n    tags_yaml_path = os.path.join(options.source_path, 'native/tags.yaml')\n    parsed_yaml = parse_native_yaml(native_yaml_path, tags_yaml_path)\n    (native_functions, backend_indices) = (parsed_yaml.native_functions, parsed_yaml.backend_indices)\n    cpu_fm = make_file_manager(options=options)\n    gen_unboxing(native_functions=native_functions, cpu_fm=cpu_fm, selector=selector)\n    if options.output_dependencies:\n        depfile_path = pathlib.Path(options.output_dependencies).resolve()\n        depfile_name = depfile_path.name\n        depfile_stem = depfile_path.stem\n        path = depfile_path.parent / depfile_name\n        cpu_fm.write_outputs(depfile_stem, str(path))",
        "mutated": [
            "def main(args: List[str]) -> None:\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser(description='Generate unboxing source files')\n    parser.add_argument('-s', '--source-path', help='path to source directory for ATen', default='aten/src/ATen')\n    parser.add_argument('-d', '--install-dir', '--install_dir', help='output directory', default='build/aten/src/ATen')\n    parser.add_argument('-o', '--output-dependencies', help='output a list of dependencies into the given file and exit')\n    parser.add_argument('--dry-run', action='store_true', help='run without writing any files (still updates outputs)')\n    parser.add_argument('--op-selection-yaml-path', '--op_selection_yaml_path', help='Provide a path to the operator selection (for custom build) YAML that contains the information about the set of selected operators and their categories (training, ...). Each operator is either a full operator name with overload or just a bare operator name. The operator names also contain the namespace prefix (e.g. aten::)')\n    parser.add_argument('--op-registration-allowlist', '--op_registration_allowlist', nargs='*', help='filter op registrations by the allowlist (if set); each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    parser.add_argument('--TEST-ONLY-op-registration-allowlist-yaml-path', '--TEST_ONLY_op_registration_allowlist_yaml_path', help='Provide a path to the operator selection (for custom build) YAML which contains a list of operators. It is to serve testing purpose and each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    options = parser.parse_args(args)\n    if options.op_registration_allowlist:\n        op_registration_allowlist = options.op_registration_allowlist\n    elif options.TEST_ONLY_op_registration_allowlist_yaml_path:\n        with open(options.TEST_ONLY_op_registration_allowlist_yaml_path) as f:\n            op_registration_allowlist = yaml.safe_load(f)\n    else:\n        op_registration_allowlist = None\n    selector = get_custom_build_selector(op_registration_allowlist, options.op_selection_yaml_path)\n    native_yaml_path = os.path.join(options.source_path, 'native/native_functions.yaml')\n    tags_yaml_path = os.path.join(options.source_path, 'native/tags.yaml')\n    parsed_yaml = parse_native_yaml(native_yaml_path, tags_yaml_path)\n    (native_functions, backend_indices) = (parsed_yaml.native_functions, parsed_yaml.backend_indices)\n    cpu_fm = make_file_manager(options=options)\n    gen_unboxing(native_functions=native_functions, cpu_fm=cpu_fm, selector=selector)\n    if options.output_dependencies:\n        depfile_path = pathlib.Path(options.output_dependencies).resolve()\n        depfile_name = depfile_path.name\n        depfile_stem = depfile_path.stem\n        path = depfile_path.parent / depfile_name\n        cpu_fm.write_outputs(depfile_stem, str(path))",
            "def main(args: List[str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser(description='Generate unboxing source files')\n    parser.add_argument('-s', '--source-path', help='path to source directory for ATen', default='aten/src/ATen')\n    parser.add_argument('-d', '--install-dir', '--install_dir', help='output directory', default='build/aten/src/ATen')\n    parser.add_argument('-o', '--output-dependencies', help='output a list of dependencies into the given file and exit')\n    parser.add_argument('--dry-run', action='store_true', help='run without writing any files (still updates outputs)')\n    parser.add_argument('--op-selection-yaml-path', '--op_selection_yaml_path', help='Provide a path to the operator selection (for custom build) YAML that contains the information about the set of selected operators and their categories (training, ...). Each operator is either a full operator name with overload or just a bare operator name. The operator names also contain the namespace prefix (e.g. aten::)')\n    parser.add_argument('--op-registration-allowlist', '--op_registration_allowlist', nargs='*', help='filter op registrations by the allowlist (if set); each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    parser.add_argument('--TEST-ONLY-op-registration-allowlist-yaml-path', '--TEST_ONLY_op_registration_allowlist_yaml_path', help='Provide a path to the operator selection (for custom build) YAML which contains a list of operators. It is to serve testing purpose and each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    options = parser.parse_args(args)\n    if options.op_registration_allowlist:\n        op_registration_allowlist = options.op_registration_allowlist\n    elif options.TEST_ONLY_op_registration_allowlist_yaml_path:\n        with open(options.TEST_ONLY_op_registration_allowlist_yaml_path) as f:\n            op_registration_allowlist = yaml.safe_load(f)\n    else:\n        op_registration_allowlist = None\n    selector = get_custom_build_selector(op_registration_allowlist, options.op_selection_yaml_path)\n    native_yaml_path = os.path.join(options.source_path, 'native/native_functions.yaml')\n    tags_yaml_path = os.path.join(options.source_path, 'native/tags.yaml')\n    parsed_yaml = parse_native_yaml(native_yaml_path, tags_yaml_path)\n    (native_functions, backend_indices) = (parsed_yaml.native_functions, parsed_yaml.backend_indices)\n    cpu_fm = make_file_manager(options=options)\n    gen_unboxing(native_functions=native_functions, cpu_fm=cpu_fm, selector=selector)\n    if options.output_dependencies:\n        depfile_path = pathlib.Path(options.output_dependencies).resolve()\n        depfile_name = depfile_path.name\n        depfile_stem = depfile_path.stem\n        path = depfile_path.parent / depfile_name\n        cpu_fm.write_outputs(depfile_stem, str(path))",
            "def main(args: List[str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser(description='Generate unboxing source files')\n    parser.add_argument('-s', '--source-path', help='path to source directory for ATen', default='aten/src/ATen')\n    parser.add_argument('-d', '--install-dir', '--install_dir', help='output directory', default='build/aten/src/ATen')\n    parser.add_argument('-o', '--output-dependencies', help='output a list of dependencies into the given file and exit')\n    parser.add_argument('--dry-run', action='store_true', help='run without writing any files (still updates outputs)')\n    parser.add_argument('--op-selection-yaml-path', '--op_selection_yaml_path', help='Provide a path to the operator selection (for custom build) YAML that contains the information about the set of selected operators and their categories (training, ...). Each operator is either a full operator name with overload or just a bare operator name. The operator names also contain the namespace prefix (e.g. aten::)')\n    parser.add_argument('--op-registration-allowlist', '--op_registration_allowlist', nargs='*', help='filter op registrations by the allowlist (if set); each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    parser.add_argument('--TEST-ONLY-op-registration-allowlist-yaml-path', '--TEST_ONLY_op_registration_allowlist_yaml_path', help='Provide a path to the operator selection (for custom build) YAML which contains a list of operators. It is to serve testing purpose and each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    options = parser.parse_args(args)\n    if options.op_registration_allowlist:\n        op_registration_allowlist = options.op_registration_allowlist\n    elif options.TEST_ONLY_op_registration_allowlist_yaml_path:\n        with open(options.TEST_ONLY_op_registration_allowlist_yaml_path) as f:\n            op_registration_allowlist = yaml.safe_load(f)\n    else:\n        op_registration_allowlist = None\n    selector = get_custom_build_selector(op_registration_allowlist, options.op_selection_yaml_path)\n    native_yaml_path = os.path.join(options.source_path, 'native/native_functions.yaml')\n    tags_yaml_path = os.path.join(options.source_path, 'native/tags.yaml')\n    parsed_yaml = parse_native_yaml(native_yaml_path, tags_yaml_path)\n    (native_functions, backend_indices) = (parsed_yaml.native_functions, parsed_yaml.backend_indices)\n    cpu_fm = make_file_manager(options=options)\n    gen_unboxing(native_functions=native_functions, cpu_fm=cpu_fm, selector=selector)\n    if options.output_dependencies:\n        depfile_path = pathlib.Path(options.output_dependencies).resolve()\n        depfile_name = depfile_path.name\n        depfile_stem = depfile_path.stem\n        path = depfile_path.parent / depfile_name\n        cpu_fm.write_outputs(depfile_stem, str(path))",
            "def main(args: List[str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser(description='Generate unboxing source files')\n    parser.add_argument('-s', '--source-path', help='path to source directory for ATen', default='aten/src/ATen')\n    parser.add_argument('-d', '--install-dir', '--install_dir', help='output directory', default='build/aten/src/ATen')\n    parser.add_argument('-o', '--output-dependencies', help='output a list of dependencies into the given file and exit')\n    parser.add_argument('--dry-run', action='store_true', help='run without writing any files (still updates outputs)')\n    parser.add_argument('--op-selection-yaml-path', '--op_selection_yaml_path', help='Provide a path to the operator selection (for custom build) YAML that contains the information about the set of selected operators and their categories (training, ...). Each operator is either a full operator name with overload or just a bare operator name. The operator names also contain the namespace prefix (e.g. aten::)')\n    parser.add_argument('--op-registration-allowlist', '--op_registration_allowlist', nargs='*', help='filter op registrations by the allowlist (if set); each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    parser.add_argument('--TEST-ONLY-op-registration-allowlist-yaml-path', '--TEST_ONLY_op_registration_allowlist_yaml_path', help='Provide a path to the operator selection (for custom build) YAML which contains a list of operators. It is to serve testing purpose and each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    options = parser.parse_args(args)\n    if options.op_registration_allowlist:\n        op_registration_allowlist = options.op_registration_allowlist\n    elif options.TEST_ONLY_op_registration_allowlist_yaml_path:\n        with open(options.TEST_ONLY_op_registration_allowlist_yaml_path) as f:\n            op_registration_allowlist = yaml.safe_load(f)\n    else:\n        op_registration_allowlist = None\n    selector = get_custom_build_selector(op_registration_allowlist, options.op_selection_yaml_path)\n    native_yaml_path = os.path.join(options.source_path, 'native/native_functions.yaml')\n    tags_yaml_path = os.path.join(options.source_path, 'native/tags.yaml')\n    parsed_yaml = parse_native_yaml(native_yaml_path, tags_yaml_path)\n    (native_functions, backend_indices) = (parsed_yaml.native_functions, parsed_yaml.backend_indices)\n    cpu_fm = make_file_manager(options=options)\n    gen_unboxing(native_functions=native_functions, cpu_fm=cpu_fm, selector=selector)\n    if options.output_dependencies:\n        depfile_path = pathlib.Path(options.output_dependencies).resolve()\n        depfile_name = depfile_path.name\n        depfile_stem = depfile_path.stem\n        path = depfile_path.parent / depfile_name\n        cpu_fm.write_outputs(depfile_stem, str(path))",
            "def main(args: List[str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser(description='Generate unboxing source files')\n    parser.add_argument('-s', '--source-path', help='path to source directory for ATen', default='aten/src/ATen')\n    parser.add_argument('-d', '--install-dir', '--install_dir', help='output directory', default='build/aten/src/ATen')\n    parser.add_argument('-o', '--output-dependencies', help='output a list of dependencies into the given file and exit')\n    parser.add_argument('--dry-run', action='store_true', help='run without writing any files (still updates outputs)')\n    parser.add_argument('--op-selection-yaml-path', '--op_selection_yaml_path', help='Provide a path to the operator selection (for custom build) YAML that contains the information about the set of selected operators and their categories (training, ...). Each operator is either a full operator name with overload or just a bare operator name. The operator names also contain the namespace prefix (e.g. aten::)')\n    parser.add_argument('--op-registration-allowlist', '--op_registration_allowlist', nargs='*', help='filter op registrations by the allowlist (if set); each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    parser.add_argument('--TEST-ONLY-op-registration-allowlist-yaml-path', '--TEST_ONLY_op_registration_allowlist_yaml_path', help='Provide a path to the operator selection (for custom build) YAML which contains a list of operators. It is to serve testing purpose and each item is `namespace`::`operator name` without overload name; e.g.: aten::empty aten::conv2d ...')\n    options = parser.parse_args(args)\n    if options.op_registration_allowlist:\n        op_registration_allowlist = options.op_registration_allowlist\n    elif options.TEST_ONLY_op_registration_allowlist_yaml_path:\n        with open(options.TEST_ONLY_op_registration_allowlist_yaml_path) as f:\n            op_registration_allowlist = yaml.safe_load(f)\n    else:\n        op_registration_allowlist = None\n    selector = get_custom_build_selector(op_registration_allowlist, options.op_selection_yaml_path)\n    native_yaml_path = os.path.join(options.source_path, 'native/native_functions.yaml')\n    tags_yaml_path = os.path.join(options.source_path, 'native/tags.yaml')\n    parsed_yaml = parse_native_yaml(native_yaml_path, tags_yaml_path)\n    (native_functions, backend_indices) = (parsed_yaml.native_functions, parsed_yaml.backend_indices)\n    cpu_fm = make_file_manager(options=options)\n    gen_unboxing(native_functions=native_functions, cpu_fm=cpu_fm, selector=selector)\n    if options.output_dependencies:\n        depfile_path = pathlib.Path(options.output_dependencies).resolve()\n        depfile_name = depfile_path.name\n        depfile_stem = depfile_path.stem\n        path = depfile_path.parent / depfile_name\n        cpu_fm.write_outputs(depfile_stem, str(path))"
        ]
    }
]