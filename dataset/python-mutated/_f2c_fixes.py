import re
from collections.abc import Iterable, Iterator
from pathlib import Path
from textwrap import dedent

def prepare_doctest(x: str) -> list[str]:
    if False:
        for i in range(10):
            print('nop')
    return dedent(x).strip().splitlines(True)

def fix_f2c_input(f2c_input_path: str) -> None:
    if False:
        return 10
    '\n    OpenBLAS has been manually modified to remove useless arguments generated by\n    f2c. But the mismatches between the f2c ABI and the human-curated sensible\n    ABI in OpenBLAS cause us great pain.\n\n    This stuff applies to actual source files, but scipy also has multiple\n    templating engines for Fortran, so these changes have to be applied\n    immediately prior to f2c\'ing a .f file to ensure that they also work\n    correctly on templated files.\n\n    Fortran seems to be mostly case insensitive. The templated files in\n    particular can include weird mixtures of lower and upper case.\n\n    Mostly the issues are related to \'character\' types. Most LAPACK functions\n    that take string arguments use them as enums and only care about the first\n    character of the string. f2c generates a \'length\' argument to indicate how\n    long the string is, but OpenBLAS leaves these length arguments out because\n    the strings are assumed to have length 1.\n\n    So the goal is to cause f2c to generate no length argument. We can achieve\n    this by replacing the string with the ascii code of the first character\n    e.g.,:\n\n        f(\'UPPER\') --> f(85)\n\n    Coming from C this surprises me a bit. I would expect `f(85)` to cause a\n    segfault or something when f tries to find its string at memory address 85.\n\n    f("UPPER") gets f2c\'d to:\n\n        f("UPPER", 5)\n\n    But f2c compiles f(85) to the C code:\n\n        static integer c__85 = 85;\n        f(&c__85);\n\n    This is perfect. Not sure why it does this, but it\'s very convenient for us.\n\n    chla_transtype is a special case. The OpenBLAS version of chla_transtype takes\n    a return argument, whereas f2c thinks it should return the value.\n\n    '
    f2c_input = Path(f2c_input_path)
    with open(f2c_input) as f:
        lines = f.readlines()
    new_lines = []
    lines = char1_args_to_int(lines)
    for line in lines:
        line = fix_string_args(line)
        if f2c_input_path.endswith('_flapack-f2pywrappers.f'):
            line = line.replace('character cmach', 'integer cmach')
            line = line.replace('character norm', 'integer norm')
        if 'id_dist' in str(f2c_input):
            line = line.replace('character*1 jobz', 'integer jobz')
            if 'jobz =' in line:
                line = re.sub("'(.)'", lambda r: str(ord(r.group(1))), line)
        if f2c_input.name in ['_lapack_subroutine_wrappers.f', '_blas_subroutine_wrappers.f']:
            line = line.replace('character', 'integer')
            line = line.replace('ret = chla_transtype(', 'call chla_transtype(ret, 1,')
        if 'PROPACK' in str(f2c_input):
            line = line.replace('ylocal(n)', 'ylocal(123001)')
            line = line.replace('character*1', 'integer')
        if f2c_input.name == 'mvndst.f':
            line = re.sub('(infin|stdev|nlower|nupper)\\(d\\)', '\\1(123001)', line)
            line = line.replace('rho(d*(d-1)/2)', 'rho(123002)')
        new_lines.append(line)
    with open(f2c_input_path, 'w') as f:
        f.writelines(new_lines)

def fix_string_args(line: str) -> str:
    if False:
        i = 10
        return i + 15
    '\n    Replace all single character strings in (the first line of) "call"\n    statements with their ascci codes.\n    '
    if not re.search('call', line, re.I) and 'SIGNST' not in line and ('TRANST' not in line):
        return line
    else:
        return re.sub("'[A-Za-z0-9]'", lambda y: str(ord(y.group(0)[1])), line)

def char1_to_int(x: str) -> str:
    if False:
        while True:
            i = 10
    '\n    Replace multicharacter strings with the ascii code of their first character.\n\n    >>> char1_to_int("CALL sTRSV( \'UPPER\', \'NOTRANS\', \'NONUNIT\', J, H, LDH, Y, 1 )")\n    \'CALL sTRSV( 85, 78, 78, J, H, LDH, Y, 1 )\'\n    '
    return re.sub("'(.)[A-Za-z -]*'", lambda r: str(ord(r.group(1))), x)

def char1_args_to_int(lines: list[str]) -> list[str]:
    if False:
        return 10
    '\n    Replace strings with the ascii code of their first character if they are\n    arguments to one of a long list of hard coded LAPACK functions (see\n    fncstems). This handles multiline function calls.\n\n    >>> print(char1_args_to_int(["CALL sTRSV( \'UPPER\', \'NOTRANS\', \'NONUNIT\', J, H, LDH, Y, 1 )"]))\n    [\'CALL sTRSV( 85, 78, 78, J, H, LDH, Y, 1 )\']\n\n    >>> print("".join(char1_args_to_int(prepare_doctest(\'\'\'\n    ...               call cvout (logfil, nconv, workl(ihbds), ndigit,\n    ...     &            \'_neupd: Last row of the eigenvector matrix for T\')\n    ...     call ctrmm(\'Right\'   , \'Upper\'      , \'No transpose\',\n    ...     &                  \'Non-unit\', n            , nconv         ,\n    ...     &                  one       , workl(invsub), ldq           ,\n    ...     &                  z         , ldz)\n    ... \'\'\'))))\n    call cvout (logfil, nconv, workl(ihbds), ndigit,\n    &            \'_neupd: Last row of the eigenvector matrix for T\')\n    call ctrmm(82   , 85      , 78,\n    &                  78, n            , nconv         ,\n    &                  one       , workl(invsub), ldq           ,\n    &                  z         , ldz)\n    '
    fncstems = ['gemm', 'ggbak', 'gghrd', 'lacpy', 'lamch', 'lanhs', 'lanst', 'larf', 'lascl', 'laset', 'lasr', 'ormqr', 'orm2r', 'steqr', 'stevr', 'trevc', 'trmm', 'trsen', 'trsv', 'unm2r', 'unmqr']
    fncnames = []
    for c in 'cdsz':
        for stem in fncstems:
            fncnames.append(c + stem)
    fncnames += ['lsame']
    funcs_pattern = '|'.join(fncnames)
    new_lines = []
    replace = False
    for line in lines:
        if re.search(funcs_pattern, line, re.IGNORECASE):
            replace = True
        if replace:
            line = char1_to_int(line)
        if not re.search(',\\s*$', line):
            replace = False
        new_lines.append(line)
    return new_lines

def fix_f2c_output(f2c_output_path: str) -> str | None:
    if False:
        for i in range(10):
            print('nop')
    '\n    This function is called on the name of each C output file. It fixes up the C\n    output in various ways to compensate for the lack of f2c support for Fortran\n    90 and Fortran 95.\n    '
    f2c_output = Path(f2c_output_path)
    with open(f2c_output) as f:
        lines = f.readlines()
    if 'id_dist' in f2c_output_path:
        lines = fix_inconsistent_decls(lines)
    if 'odepack' in f2c_output_path or f2c_output.name == 'mvndst.c':
        if f2c_output.name == 'blkdta000.c':
            lines.append('\n                struct {    doublereal rownd2, pdest, pdlast, ratio, cm1[12], cm2[5], pdnorm;\n                    integer iownd2[3], icount, irflag, jtyp, mused, mxordn, mxords;\n                } lsa001_;\n                ')
        else:
            add_externs_to_structs(lines)
    if f2c_output.name == '_lapack_subroutine_wrappers.c':
        lines = [line.replace('integer chla_transtype__', 'void chla_transtype__') for line in lines]
    if f2c_output.name == 'mvndst.c':
        lines = fix_inconsistent_decls(lines)

        def fix_line(line: str) -> str:
            if False:
                while True:
                    i = 10
            if '12300' in line:
                return line.replace('static', '').replace('123001', '(*d__)').replace('123002', '(*d__)*((*d__)-1)/2')
            return line
        lines = list(map(fix_line, lines))
    if 'PROPACK' in str(f2c_output):

        def fix_line(line: str) -> str:
            if False:
                for i in range(10):
                    print('nop')
            if f2c_output.name != 'cgemm_ovwr.c':
                line = line.replace('struct', 'extern struct')
            if '12300' in line:
                return line.replace('static', '').replace('123001', '(*n)')
            return line
        lines = list(map(fix_line, lines))
        if f2c_output.name.endswith('lansvd.c'):
            lines.append('\n                #include <time.h>\n\n                int second_(real *t) {\n                    *t = clock()/1000;\n                    return 0;\n                }\n                ')
    if 'eupd.c' in str(f2c_output):
        regrouped_lines = regroup_lines(lines)
        lines = [re.sub(',?\\s*ftnlen\\s*(howmny_len|bmat_len)', '', line) for line in regrouped_lines]
    if 'REVCOM.c' in str(f2c_output):
        lines = [line.replace('double c_abs(', 'float c_abs(') for line in lines]
    with open(f2c_output, 'w') as f:
        f.writelines(lines)
    return None

def add_externs_to_structs(lines: list[str]) -> None:
    if False:
        for i in range(10):
            print('nop')
    '\n    The fortran "common" keyword is supposed to share variables between a bunch\n    of files. f2c doesn\'t handle this correctly (it isn\'t possible for it to\n    handle it correctly because it only looks one file at a time).\n\n    We mark all the structs as externs and then (separately) add one non extern\n    version to each file.\n    >>> lines = prepare_doctest(\'\'\'\n    ...     struct {    doublereal rls[218];\n    ...         integer ils[39];\n    ...     } ls0001_;\n    ...     struct {    doublereal rlsa[22];\n    ...         integer ilsa[9];\n    ...     } lsa001_;\n    ...     struct {    integer ieh[2];\n    ...     } eh0001_;\n    ... \'\'\')\n    >>> add_externs_to_structs(lines)\n    >>> print("".join(lines))\n    extern struct {    doublereal rls[218];\n        integer ils[39];\n    } ls0001_;\n    extern struct {    doublereal rlsa[22];\n        integer ilsa[9];\n    } lsa001_;\n    extern struct {    integer ieh[2];\n    } eh0001_;\n    '
    for (idx, line) in enumerate(lines):
        if line.startswith('struct'):
            lines[idx] = 'extern ' + lines[idx]

def regroup_lines(lines: Iterable[str]) -> Iterator[str]:
    if False:
        i = 10
        return i + 15
    '\n    Make sure that functions and declarations have their argument list only on\n    one line.\n\n    >>> print("".join(regroup_lines(prepare_doctest(\'\'\'\n    ...     /* Subroutine */ int clanhfwrp_(real *ret, char *norm, char *transr, char *\n    ...     \tuplo, integer *n, complex *a, real *work, ftnlen norm_len, ftnlen\n    ...     \ttransr_len, ftnlen uplo_len)\n    ...     {\n    ...        static doublereal psum[52];\n    ...        extern /* Subroutine */ int dqelg_(integer *, doublereal *, doublereal *,\n    ...            doublereal *, doublereal *, integer *);\n    ... \'\'\'))))\n    /* Subroutine */ int clanhfwrp_(real *ret, char *norm, char *transr, char * uplo, integer *n, complex *a, real *work, ftnlen norm_len, ftnlen transr_len, ftnlen uplo_len){\n       static doublereal psum[52];\n       extern /* Subroutine */ int dqelg_(integer *, doublereal *, doublereal *, doublereal *, doublereal *, integer *);\n\n    '
    line_iter = iter(lines)
    for line in line_iter:
        if '/* Subroutine */' not in line:
            yield line
            continue
        is_definition = line.startswith('/* Subroutine */')
        stop = ')' if is_definition else ';'
        if stop in line:
            yield line
            continue
        sub_lines = [line.rstrip()]
        for line in line_iter:
            sub_lines.append(line.strip())
            if stop in line:
                break
        joined_line = ' '.join(sub_lines)
        if is_definition:
            yield joined_line
        else:
            yield from (x + ';' for x in joined_line.split(';')[:-1])

def fix_inconsistent_decls(lines: list[str]) -> list[str]:
    if False:
        while True:
            i = 10
    '\n    Fortran functions in id_dist use implicit casting of function args which f2c\n    doesn\'t support.\n\n    The fortran equivalent of the following code:\n\n        double f(double x){\n            return x + 5;\n        }\n        double g(int x){\n            return f(x);\n        }\n\n    gets f2c\'d to:\n\n        double f(double x){\n            return x + 5;\n        }\n        double g(int x){\n            double f(int);\n            return f(x);\n        }\n\n    which fails to compile because the declaration of f type clashes with the\n    definition. Gather up all the definitions in each file and then gathers the\n    declarations and fixes them if necessary so that the declaration matches the\n    definition.\n\n    >>> print("".join(fix_inconsistent_decls(prepare_doctest(\'\'\'\n    ...    /* Subroutine */ double f(double x){\n    ...        return x + 5;\n    ...    }\n    ...    /* Subroutine */ double g(int x){\n    ...        extern /* Subroutine */ double f(int);\n    ...        return f(x);\n    ...    }\n    ... \'\'\'))))\n    /* Subroutine */ double f(double x){\n        return x + 5;\n    }\n    /* Subroutine */ double g(int x){\n        extern /* Subroutine */ double f(double);\n        return f(x);\n    }\n    '
    func_types = {}
    lines = list(regroup_lines(lines))
    for line in lines:
        if not line.startswith('/* Subroutine */'):
            continue
        [func_name, types] = get_subroutine_decl(line)
        func_types[func_name] = types
    for (idx, line) in enumerate(lines):
        if 'extern /* Subroutine */' not in line:
            continue
        decls = line.split(')')[:-1]
        for decl in decls:
            [func_name, types] = get_subroutine_decl(decl)
            if func_name not in func_types or types == func_types[func_name]:
                continue
            types = func_types[func_name]
            l = list(line.partition(func_name + '('))
            l[2:] = list(l[2].partition(')'))
            l[2] = ', '.join(types)
            line = ''.join(l)
        lines[idx] = line
    return lines

def get_subroutine_decl(sub: str) -> tuple[str, list[str]]:
    if False:
        return 10
    '\n    >>> get_subroutine_decl(\n    ...     "extern /* Subroutine */ int dqelg_(integer *, doublereal *, doublereal *, doublereal *, doublereal *, integer *);"\n    ... )\n    (\'dqelg_\', [\'integer *\', \'doublereal *\', \'doublereal *\', \'doublereal *\', \'doublereal *\', \'integer *\'])\n    '
    func_name = sub.partition('(')[0].rpartition(' ')[2]
    args_str = sub.partition('(')[2].partition(')')[0]
    args = args_str.split(',')
    types = []
    for arg in args:
        arg = arg.strip()
        if '*' in arg:
            type = ''.join(arg.partition('*')[:-1])
        else:
            type = arg.partition(' ')[0]
        types.append(type.strip())
    return (func_name, types)

def scipy_fix_cfile(path: str) -> None:
    if False:
        for i in range(10):
            print('nop')
    "\n    Replace void return types with int return types in various generated .c and\n    .h files. We can't achieve this with a simple patch because these files are\n    not in the sdist, they are generated as part of the build.\n    "
    source_path = Path(path)
    text = source_path.read_text()
    text = text.replace('extern void F_WRAPPEDFUNC', 'extern int F_WRAPPEDFUNC')
    text = text.replace('extern void F_FUNC', 'extern int F_FUNC')
    text = text.replace('void (*f2py_func)', 'int (*f2py_func)')
    text = text.replace('static void cb_', 'static int cb_')
    text = text.replace('typedef void(*cb_', 'typedef int(*cb_')
    text = text.replace('void(*)', 'int(*)')
    text = text.replace('static void f2py_setup_', 'static int f2py_setup_')
    if path.endswith('_flapackmodule.c'):
        text = text.replace(',size_t', '')
        text = re.sub(',slen\\([a-z]*\\)\\)', ')', text)
    if path.endswith('stats/statlib/spearman.c'):
        text = text.replace('extern real alnorm_', 'extern doublereal alnorm_')
    source_path.write_text(text)
    for lib in ['lapack', 'blas']:
        if path.endswith(f'cython_{lib}.c'):
            header_path = Path(path).with_name(f'_{lib}_subroutines.h')
            header_text = header_path.read_text()
            header_text = header_text.replace('void F_FUNC', 'int F_FUNC')
            header_path.write_text(header_text)

def scipy_fixes(args: list[str]) -> None:
    if False:
        i = 10
        return i + 15
    for arg in args:
        if arg.endswith('.c'):
            scipy_fix_cfile(arg)