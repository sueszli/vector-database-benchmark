[
    {
        "func_name": "smart_cond",
        "original": "@tf_export('__internal__.smart_cond.smart_cond', v1=[])\ndef smart_cond(pred, true_fn=None, false_fn=None, name=None):\n    \"\"\"Return either `true_fn()` if predicate `pred` is true else `false_fn()`.\n\n  If `pred` is a bool or has a constant value, we return either `true_fn()`\n  or `false_fn()`, otherwise we use `tf.cond` to dynamically route to both.\n\n  Args:\n    pred: A scalar determining whether to return the result of `true_fn` or\n      `false_fn`.\n    true_fn: The callable to be performed if pred is true.\n    false_fn: The callable to be performed if pred is false.\n    name: Optional name prefix when using `tf.cond`.\n\n  Returns:\n    Tensors returned by the call to either `true_fn` or `false_fn`.\n\n  Raises:\n    TypeError: If `true_fn` or `false_fn` is not callable.\n  \"\"\"\n    if not callable(true_fn):\n        raise TypeError(f'Argument `true_fn` must be callable. Received {true_fn}')\n    if not callable(false_fn):\n        raise TypeError(f'Argument `false_fn` must be callable. Received {false_fn}')\n    pred_value = smart_constant_value(pred)\n    if pred_value is not None:\n        if pred_value:\n            return true_fn()\n        else:\n            return false_fn()\n    else:\n        return cond.cond(pred, true_fn=true_fn, false_fn=false_fn, name=name)",
        "mutated": [
            "@tf_export('__internal__.smart_cond.smart_cond', v1=[])\ndef smart_cond(pred, true_fn=None, false_fn=None, name=None):\n    if False:\n        i = 10\n    'Return either `true_fn()` if predicate `pred` is true else `false_fn()`.\\n\\n  If `pred` is a bool or has a constant value, we return either `true_fn()`\\n  or `false_fn()`, otherwise we use `tf.cond` to dynamically route to both.\\n\\n  Args:\\n    pred: A scalar determining whether to return the result of `true_fn` or\\n      `false_fn`.\\n    true_fn: The callable to be performed if pred is true.\\n    false_fn: The callable to be performed if pred is false.\\n    name: Optional name prefix when using `tf.cond`.\\n\\n  Returns:\\n    Tensors returned by the call to either `true_fn` or `false_fn`.\\n\\n  Raises:\\n    TypeError: If `true_fn` or `false_fn` is not callable.\\n  '\n    if not callable(true_fn):\n        raise TypeError(f'Argument `true_fn` must be callable. Received {true_fn}')\n    if not callable(false_fn):\n        raise TypeError(f'Argument `false_fn` must be callable. Received {false_fn}')\n    pred_value = smart_constant_value(pred)\n    if pred_value is not None:\n        if pred_value:\n            return true_fn()\n        else:\n            return false_fn()\n    else:\n        return cond.cond(pred, true_fn=true_fn, false_fn=false_fn, name=name)",
            "@tf_export('__internal__.smart_cond.smart_cond', v1=[])\ndef smart_cond(pred, true_fn=None, false_fn=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return either `true_fn()` if predicate `pred` is true else `false_fn()`.\\n\\n  If `pred` is a bool or has a constant value, we return either `true_fn()`\\n  or `false_fn()`, otherwise we use `tf.cond` to dynamically route to both.\\n\\n  Args:\\n    pred: A scalar determining whether to return the result of `true_fn` or\\n      `false_fn`.\\n    true_fn: The callable to be performed if pred is true.\\n    false_fn: The callable to be performed if pred is false.\\n    name: Optional name prefix when using `tf.cond`.\\n\\n  Returns:\\n    Tensors returned by the call to either `true_fn` or `false_fn`.\\n\\n  Raises:\\n    TypeError: If `true_fn` or `false_fn` is not callable.\\n  '\n    if not callable(true_fn):\n        raise TypeError(f'Argument `true_fn` must be callable. Received {true_fn}')\n    if not callable(false_fn):\n        raise TypeError(f'Argument `false_fn` must be callable. Received {false_fn}')\n    pred_value = smart_constant_value(pred)\n    if pred_value is not None:\n        if pred_value:\n            return true_fn()\n        else:\n            return false_fn()\n    else:\n        return cond.cond(pred, true_fn=true_fn, false_fn=false_fn, name=name)",
            "@tf_export('__internal__.smart_cond.smart_cond', v1=[])\ndef smart_cond(pred, true_fn=None, false_fn=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return either `true_fn()` if predicate `pred` is true else `false_fn()`.\\n\\n  If `pred` is a bool or has a constant value, we return either `true_fn()`\\n  or `false_fn()`, otherwise we use `tf.cond` to dynamically route to both.\\n\\n  Args:\\n    pred: A scalar determining whether to return the result of `true_fn` or\\n      `false_fn`.\\n    true_fn: The callable to be performed if pred is true.\\n    false_fn: The callable to be performed if pred is false.\\n    name: Optional name prefix when using `tf.cond`.\\n\\n  Returns:\\n    Tensors returned by the call to either `true_fn` or `false_fn`.\\n\\n  Raises:\\n    TypeError: If `true_fn` or `false_fn` is not callable.\\n  '\n    if not callable(true_fn):\n        raise TypeError(f'Argument `true_fn` must be callable. Received {true_fn}')\n    if not callable(false_fn):\n        raise TypeError(f'Argument `false_fn` must be callable. Received {false_fn}')\n    pred_value = smart_constant_value(pred)\n    if pred_value is not None:\n        if pred_value:\n            return true_fn()\n        else:\n            return false_fn()\n    else:\n        return cond.cond(pred, true_fn=true_fn, false_fn=false_fn, name=name)",
            "@tf_export('__internal__.smart_cond.smart_cond', v1=[])\ndef smart_cond(pred, true_fn=None, false_fn=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return either `true_fn()` if predicate `pred` is true else `false_fn()`.\\n\\n  If `pred` is a bool or has a constant value, we return either `true_fn()`\\n  or `false_fn()`, otherwise we use `tf.cond` to dynamically route to both.\\n\\n  Args:\\n    pred: A scalar determining whether to return the result of `true_fn` or\\n      `false_fn`.\\n    true_fn: The callable to be performed if pred is true.\\n    false_fn: The callable to be performed if pred is false.\\n    name: Optional name prefix when using `tf.cond`.\\n\\n  Returns:\\n    Tensors returned by the call to either `true_fn` or `false_fn`.\\n\\n  Raises:\\n    TypeError: If `true_fn` or `false_fn` is not callable.\\n  '\n    if not callable(true_fn):\n        raise TypeError(f'Argument `true_fn` must be callable. Received {true_fn}')\n    if not callable(false_fn):\n        raise TypeError(f'Argument `false_fn` must be callable. Received {false_fn}')\n    pred_value = smart_constant_value(pred)\n    if pred_value is not None:\n        if pred_value:\n            return true_fn()\n        else:\n            return false_fn()\n    else:\n        return cond.cond(pred, true_fn=true_fn, false_fn=false_fn, name=name)",
            "@tf_export('__internal__.smart_cond.smart_cond', v1=[])\ndef smart_cond(pred, true_fn=None, false_fn=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return either `true_fn()` if predicate `pred` is true else `false_fn()`.\\n\\n  If `pred` is a bool or has a constant value, we return either `true_fn()`\\n  or `false_fn()`, otherwise we use `tf.cond` to dynamically route to both.\\n\\n  Args:\\n    pred: A scalar determining whether to return the result of `true_fn` or\\n      `false_fn`.\\n    true_fn: The callable to be performed if pred is true.\\n    false_fn: The callable to be performed if pred is false.\\n    name: Optional name prefix when using `tf.cond`.\\n\\n  Returns:\\n    Tensors returned by the call to either `true_fn` or `false_fn`.\\n\\n  Raises:\\n    TypeError: If `true_fn` or `false_fn` is not callable.\\n  '\n    if not callable(true_fn):\n        raise TypeError(f'Argument `true_fn` must be callable. Received {true_fn}')\n    if not callable(false_fn):\n        raise TypeError(f'Argument `false_fn` must be callable. Received {false_fn}')\n    pred_value = smart_constant_value(pred)\n    if pred_value is not None:\n        if pred_value:\n            return true_fn()\n        else:\n            return false_fn()\n    else:\n        return cond.cond(pred, true_fn=true_fn, false_fn=false_fn, name=name)"
        ]
    },
    {
        "func_name": "smart_constant_value",
        "original": "def smart_constant_value(pred):\n    \"\"\"Return the bool value for `pred`, or None if `pred` had a dynamic value.\n\n  Args:\n    pred: A scalar, either a Python bool or tensor.\n\n  Returns:\n    True or False if `pred` has a constant boolean value, None otherwise.\n\n  Raises:\n    TypeError: If `pred` is not a Tensor or bool.\n  \"\"\"\n    if isinstance(pred, tensor.Tensor):\n        pred_value = tensor_util.constant_value(pred)\n        if pred_value is None:\n            pred_value = tensor_util.try_evaluate_constant(pred)\n    elif pred in {0, 1}:\n        pred_value = bool(pred)\n    elif isinstance(pred, bool):\n        pred_value = pred\n    else:\n        raise TypeError(f'Argument `pred` must be a Tensor, or a Python bool, or 1 or 0. Received: pred={pred} of type {type(pred).__name__}')\n    return pred_value",
        "mutated": [
            "def smart_constant_value(pred):\n    if False:\n        i = 10\n    'Return the bool value for `pred`, or None if `pred` had a dynamic value.\\n\\n  Args:\\n    pred: A scalar, either a Python bool or tensor.\\n\\n  Returns:\\n    True or False if `pred` has a constant boolean value, None otherwise.\\n\\n  Raises:\\n    TypeError: If `pred` is not a Tensor or bool.\\n  '\n    if isinstance(pred, tensor.Tensor):\n        pred_value = tensor_util.constant_value(pred)\n        if pred_value is None:\n            pred_value = tensor_util.try_evaluate_constant(pred)\n    elif pred in {0, 1}:\n        pred_value = bool(pred)\n    elif isinstance(pred, bool):\n        pred_value = pred\n    else:\n        raise TypeError(f'Argument `pred` must be a Tensor, or a Python bool, or 1 or 0. Received: pred={pred} of type {type(pred).__name__}')\n    return pred_value",
            "def smart_constant_value(pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the bool value for `pred`, or None if `pred` had a dynamic value.\\n\\n  Args:\\n    pred: A scalar, either a Python bool or tensor.\\n\\n  Returns:\\n    True or False if `pred` has a constant boolean value, None otherwise.\\n\\n  Raises:\\n    TypeError: If `pred` is not a Tensor or bool.\\n  '\n    if isinstance(pred, tensor.Tensor):\n        pred_value = tensor_util.constant_value(pred)\n        if pred_value is None:\n            pred_value = tensor_util.try_evaluate_constant(pred)\n    elif pred in {0, 1}:\n        pred_value = bool(pred)\n    elif isinstance(pred, bool):\n        pred_value = pred\n    else:\n        raise TypeError(f'Argument `pred` must be a Tensor, or a Python bool, or 1 or 0. Received: pred={pred} of type {type(pred).__name__}')\n    return pred_value",
            "def smart_constant_value(pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the bool value for `pred`, or None if `pred` had a dynamic value.\\n\\n  Args:\\n    pred: A scalar, either a Python bool or tensor.\\n\\n  Returns:\\n    True or False if `pred` has a constant boolean value, None otherwise.\\n\\n  Raises:\\n    TypeError: If `pred` is not a Tensor or bool.\\n  '\n    if isinstance(pred, tensor.Tensor):\n        pred_value = tensor_util.constant_value(pred)\n        if pred_value is None:\n            pred_value = tensor_util.try_evaluate_constant(pred)\n    elif pred in {0, 1}:\n        pred_value = bool(pred)\n    elif isinstance(pred, bool):\n        pred_value = pred\n    else:\n        raise TypeError(f'Argument `pred` must be a Tensor, or a Python bool, or 1 or 0. Received: pred={pred} of type {type(pred).__name__}')\n    return pred_value",
            "def smart_constant_value(pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the bool value for `pred`, or None if `pred` had a dynamic value.\\n\\n  Args:\\n    pred: A scalar, either a Python bool or tensor.\\n\\n  Returns:\\n    True or False if `pred` has a constant boolean value, None otherwise.\\n\\n  Raises:\\n    TypeError: If `pred` is not a Tensor or bool.\\n  '\n    if isinstance(pred, tensor.Tensor):\n        pred_value = tensor_util.constant_value(pred)\n        if pred_value is None:\n            pred_value = tensor_util.try_evaluate_constant(pred)\n    elif pred in {0, 1}:\n        pred_value = bool(pred)\n    elif isinstance(pred, bool):\n        pred_value = pred\n    else:\n        raise TypeError(f'Argument `pred` must be a Tensor, or a Python bool, or 1 or 0. Received: pred={pred} of type {type(pred).__name__}')\n    return pred_value",
            "def smart_constant_value(pred):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the bool value for `pred`, or None if `pred` had a dynamic value.\\n\\n  Args:\\n    pred: A scalar, either a Python bool or tensor.\\n\\n  Returns:\\n    True or False if `pred` has a constant boolean value, None otherwise.\\n\\n  Raises:\\n    TypeError: If `pred` is not a Tensor or bool.\\n  '\n    if isinstance(pred, tensor.Tensor):\n        pred_value = tensor_util.constant_value(pred)\n        if pred_value is None:\n            pred_value = tensor_util.try_evaluate_constant(pred)\n    elif pred in {0, 1}:\n        pred_value = bool(pred)\n    elif isinstance(pred, bool):\n        pred_value = pred\n    else:\n        raise TypeError(f'Argument `pred` must be a Tensor, or a Python bool, or 1 or 0. Received: pred={pred} of type {type(pred).__name__}')\n    return pred_value"
        ]
    },
    {
        "func_name": "smart_case",
        "original": "def smart_case(pred_fn_pairs, default=None, exclusive=False, name='smart_case'):\n    \"\"\"Like tf.case, except attempts to statically evaluate predicates.\n\n  If any predicate in `pred_fn_pairs` is a bool or has a constant value, the\n  associated callable will be called or omitted depending on its value.\n  Otherwise this functions like tf.case.\n\n  Args:\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a\n                   callable which returns a list of tensors.\n    default: Optional callable that returns a list of tensors.\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\n    name: A name for this operation (optional).\n\n  Returns:\n    The tensors returned by the first pair whose predicate evaluated to True, or\n    those returned by `default` if none does.\n\n  Raises:\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\n               callable.\n  \"\"\"\n    return control_flow_case._case_helper(smart_cond, pred_fn_pairs, default, exclusive, name, allow_python_preds=True)",
        "mutated": [
            "def smart_case(pred_fn_pairs, default=None, exclusive=False, name='smart_case'):\n    if False:\n        i = 10\n    'Like tf.case, except attempts to statically evaluate predicates.\\n\\n  If any predicate in `pred_fn_pairs` is a bool or has a constant value, the\\n  associated callable will be called or omitted depending on its value.\\n  Otherwise this functions like tf.case.\\n\\n  Args:\\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a\\n                   callable which returns a list of tensors.\\n    default: Optional callable that returns a list of tensors.\\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\\n    name: A name for this operation (optional).\\n\\n  Returns:\\n    The tensors returned by the first pair whose predicate evaluated to True, or\\n    those returned by `default` if none does.\\n\\n  Raises:\\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\\n               callable.\\n  '\n    return control_flow_case._case_helper(smart_cond, pred_fn_pairs, default, exclusive, name, allow_python_preds=True)",
            "def smart_case(pred_fn_pairs, default=None, exclusive=False, name='smart_case'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Like tf.case, except attempts to statically evaluate predicates.\\n\\n  If any predicate in `pred_fn_pairs` is a bool or has a constant value, the\\n  associated callable will be called or omitted depending on its value.\\n  Otherwise this functions like tf.case.\\n\\n  Args:\\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a\\n                   callable which returns a list of tensors.\\n    default: Optional callable that returns a list of tensors.\\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\\n    name: A name for this operation (optional).\\n\\n  Returns:\\n    The tensors returned by the first pair whose predicate evaluated to True, or\\n    those returned by `default` if none does.\\n\\n  Raises:\\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\\n               callable.\\n  '\n    return control_flow_case._case_helper(smart_cond, pred_fn_pairs, default, exclusive, name, allow_python_preds=True)",
            "def smart_case(pred_fn_pairs, default=None, exclusive=False, name='smart_case'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Like tf.case, except attempts to statically evaluate predicates.\\n\\n  If any predicate in `pred_fn_pairs` is a bool or has a constant value, the\\n  associated callable will be called or omitted depending on its value.\\n  Otherwise this functions like tf.case.\\n\\n  Args:\\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a\\n                   callable which returns a list of tensors.\\n    default: Optional callable that returns a list of tensors.\\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\\n    name: A name for this operation (optional).\\n\\n  Returns:\\n    The tensors returned by the first pair whose predicate evaluated to True, or\\n    those returned by `default` if none does.\\n\\n  Raises:\\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\\n               callable.\\n  '\n    return control_flow_case._case_helper(smart_cond, pred_fn_pairs, default, exclusive, name, allow_python_preds=True)",
            "def smart_case(pred_fn_pairs, default=None, exclusive=False, name='smart_case'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Like tf.case, except attempts to statically evaluate predicates.\\n\\n  If any predicate in `pred_fn_pairs` is a bool or has a constant value, the\\n  associated callable will be called or omitted depending on its value.\\n  Otherwise this functions like tf.case.\\n\\n  Args:\\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a\\n                   callable which returns a list of tensors.\\n    default: Optional callable that returns a list of tensors.\\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\\n    name: A name for this operation (optional).\\n\\n  Returns:\\n    The tensors returned by the first pair whose predicate evaluated to True, or\\n    those returned by `default` if none does.\\n\\n  Raises:\\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\\n               callable.\\n  '\n    return control_flow_case._case_helper(smart_cond, pred_fn_pairs, default, exclusive, name, allow_python_preds=True)",
            "def smart_case(pred_fn_pairs, default=None, exclusive=False, name='smart_case'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Like tf.case, except attempts to statically evaluate predicates.\\n\\n  If any predicate in `pred_fn_pairs` is a bool or has a constant value, the\\n  associated callable will be called or omitted depending on its value.\\n  Otherwise this functions like tf.case.\\n\\n  Args:\\n    pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a\\n                   callable which returns a list of tensors.\\n    default: Optional callable that returns a list of tensors.\\n    exclusive: True iff at most one predicate is allowed to evaluate to `True`.\\n    name: A name for this operation (optional).\\n\\n  Returns:\\n    The tensors returned by the first pair whose predicate evaluated to True, or\\n    those returned by `default` if none does.\\n\\n  Raises:\\n    TypeError: If `pred_fn_pairs` is not a list/dictionary.\\n    TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\\n    TypeError: If `fns[i]` is not callable for any i, or `default` is not\\n               callable.\\n  '\n    return control_flow_case._case_helper(smart_cond, pred_fn_pairs, default, exclusive, name, allow_python_preds=True)"
        ]
    }
]