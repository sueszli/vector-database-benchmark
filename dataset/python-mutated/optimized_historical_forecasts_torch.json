[
    {
        "func_name": "_optimized_historical_forecasts",
        "original": "def _optimized_historical_forecasts(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, last_points_only: bool=True, show_warnings: bool=True, predict_likelihood_parameters: bool=False, verbose: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    \"\"\"\n    Optimized historical forecasts for TorchForecastingModels\n\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\n    \"\"\"\n    bounds = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        (hist_fct_start, hist_fct_end, _, _, _, _, _, _) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=series_.freq, show_warnings=show_warnings)\n        left_bound = series_.get_index_at_point(hist_fct_start)\n        if hist_fct_end > series_.end_time():\n            right_bound = len(series_)\n        else:\n            right_bound = series_.get_index_at_point(hist_fct_end)\n        bounds.append((left_bound, right_bound))\n    (bounds, cum_lengths) = _process_predict_start_points_bounds(series=series, bounds=np.array(bounds), stride=stride)\n    tfm_cls = [cls for cls in model.__class__.__mro__ if cls.__name__ == 'TorchForecastingModel'][0]\n    super(tfm_cls, model).predict(forecast_horizon, series, past_covariates, future_covariates, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    dataset = model._build_inference_dataset(target=series, n=forecast_horizon, past_covariates=past_covariates, future_covariates=future_covariates, stride=stride, bounds=bounds)\n    predictions = model.predict_from_dataset(forecast_horizon, dataset, trainer=None, verbose=verbose, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    forecasts_list = []\n    for series_idx in range(len(series)):\n        pred_idx_start = 0 if not series_idx else cum_lengths[series_idx - 1]\n        pred_idx_end = cum_lengths[series_idx]\n        preds = predictions[pred_idx_start:pred_idx_end]\n        if last_points_only:\n            preds = TimeSeries.from_times_and_values(times=generate_index(start=preds[0].end_time(), length=len(preds), freq=preds[0].freq * stride), values=np.concatenate([p.all_values(copy=False)[-1:, :, :] for p in preds], axis=0), columns=preds[0].columns, static_covariates=preds[0].static_covariates, hierarchy=preds[0].hierarchy)\n        forecasts_list.append(preds)\n    return forecasts_list if len(forecasts_list) > 1 else forecasts_list[0]",
        "mutated": [
            "def _optimized_historical_forecasts(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, last_points_only: bool=True, show_warnings: bool=True, predict_likelihood_parameters: bool=False, verbose: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n    '\\n    Optimized historical forecasts for TorchForecastingModels\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    bounds = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        (hist_fct_start, hist_fct_end, _, _, _, _, _, _) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=series_.freq, show_warnings=show_warnings)\n        left_bound = series_.get_index_at_point(hist_fct_start)\n        if hist_fct_end > series_.end_time():\n            right_bound = len(series_)\n        else:\n            right_bound = series_.get_index_at_point(hist_fct_end)\n        bounds.append((left_bound, right_bound))\n    (bounds, cum_lengths) = _process_predict_start_points_bounds(series=series, bounds=np.array(bounds), stride=stride)\n    tfm_cls = [cls for cls in model.__class__.__mro__ if cls.__name__ == 'TorchForecastingModel'][0]\n    super(tfm_cls, model).predict(forecast_horizon, series, past_covariates, future_covariates, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    dataset = model._build_inference_dataset(target=series, n=forecast_horizon, past_covariates=past_covariates, future_covariates=future_covariates, stride=stride, bounds=bounds)\n    predictions = model.predict_from_dataset(forecast_horizon, dataset, trainer=None, verbose=verbose, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    forecasts_list = []\n    for series_idx in range(len(series)):\n        pred_idx_start = 0 if not series_idx else cum_lengths[series_idx - 1]\n        pred_idx_end = cum_lengths[series_idx]\n        preds = predictions[pred_idx_start:pred_idx_end]\n        if last_points_only:\n            preds = TimeSeries.from_times_and_values(times=generate_index(start=preds[0].end_time(), length=len(preds), freq=preds[0].freq * stride), values=np.concatenate([p.all_values(copy=False)[-1:, :, :] for p in preds], axis=0), columns=preds[0].columns, static_covariates=preds[0].static_covariates, hierarchy=preds[0].hierarchy)\n        forecasts_list.append(preds)\n    return forecasts_list if len(forecasts_list) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, last_points_only: bool=True, show_warnings: bool=True, predict_likelihood_parameters: bool=False, verbose: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Optimized historical forecasts for TorchForecastingModels\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    bounds = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        (hist_fct_start, hist_fct_end, _, _, _, _, _, _) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=series_.freq, show_warnings=show_warnings)\n        left_bound = series_.get_index_at_point(hist_fct_start)\n        if hist_fct_end > series_.end_time():\n            right_bound = len(series_)\n        else:\n            right_bound = series_.get_index_at_point(hist_fct_end)\n        bounds.append((left_bound, right_bound))\n    (bounds, cum_lengths) = _process_predict_start_points_bounds(series=series, bounds=np.array(bounds), stride=stride)\n    tfm_cls = [cls for cls in model.__class__.__mro__ if cls.__name__ == 'TorchForecastingModel'][0]\n    super(tfm_cls, model).predict(forecast_horizon, series, past_covariates, future_covariates, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    dataset = model._build_inference_dataset(target=series, n=forecast_horizon, past_covariates=past_covariates, future_covariates=future_covariates, stride=stride, bounds=bounds)\n    predictions = model.predict_from_dataset(forecast_horizon, dataset, trainer=None, verbose=verbose, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    forecasts_list = []\n    for series_idx in range(len(series)):\n        pred_idx_start = 0 if not series_idx else cum_lengths[series_idx - 1]\n        pred_idx_end = cum_lengths[series_idx]\n        preds = predictions[pred_idx_start:pred_idx_end]\n        if last_points_only:\n            preds = TimeSeries.from_times_and_values(times=generate_index(start=preds[0].end_time(), length=len(preds), freq=preds[0].freq * stride), values=np.concatenate([p.all_values(copy=False)[-1:, :, :] for p in preds], axis=0), columns=preds[0].columns, static_covariates=preds[0].static_covariates, hierarchy=preds[0].hierarchy)\n        forecasts_list.append(preds)\n    return forecasts_list if len(forecasts_list) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, last_points_only: bool=True, show_warnings: bool=True, predict_likelihood_parameters: bool=False, verbose: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Optimized historical forecasts for TorchForecastingModels\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    bounds = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        (hist_fct_start, hist_fct_end, _, _, _, _, _, _) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=series_.freq, show_warnings=show_warnings)\n        left_bound = series_.get_index_at_point(hist_fct_start)\n        if hist_fct_end > series_.end_time():\n            right_bound = len(series_)\n        else:\n            right_bound = series_.get_index_at_point(hist_fct_end)\n        bounds.append((left_bound, right_bound))\n    (bounds, cum_lengths) = _process_predict_start_points_bounds(series=series, bounds=np.array(bounds), stride=stride)\n    tfm_cls = [cls for cls in model.__class__.__mro__ if cls.__name__ == 'TorchForecastingModel'][0]\n    super(tfm_cls, model).predict(forecast_horizon, series, past_covariates, future_covariates, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    dataset = model._build_inference_dataset(target=series, n=forecast_horizon, past_covariates=past_covariates, future_covariates=future_covariates, stride=stride, bounds=bounds)\n    predictions = model.predict_from_dataset(forecast_horizon, dataset, trainer=None, verbose=verbose, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    forecasts_list = []\n    for series_idx in range(len(series)):\n        pred_idx_start = 0 if not series_idx else cum_lengths[series_idx - 1]\n        pred_idx_end = cum_lengths[series_idx]\n        preds = predictions[pred_idx_start:pred_idx_end]\n        if last_points_only:\n            preds = TimeSeries.from_times_and_values(times=generate_index(start=preds[0].end_time(), length=len(preds), freq=preds[0].freq * stride), values=np.concatenate([p.all_values(copy=False)[-1:, :, :] for p in preds], axis=0), columns=preds[0].columns, static_covariates=preds[0].static_covariates, hierarchy=preds[0].hierarchy)\n        forecasts_list.append(preds)\n    return forecasts_list if len(forecasts_list) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, last_points_only: bool=True, show_warnings: bool=True, predict_likelihood_parameters: bool=False, verbose: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Optimized historical forecasts for TorchForecastingModels\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    bounds = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        (hist_fct_start, hist_fct_end, _, _, _, _, _, _) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=series_.freq, show_warnings=show_warnings)\n        left_bound = series_.get_index_at_point(hist_fct_start)\n        if hist_fct_end > series_.end_time():\n            right_bound = len(series_)\n        else:\n            right_bound = series_.get_index_at_point(hist_fct_end)\n        bounds.append((left_bound, right_bound))\n    (bounds, cum_lengths) = _process_predict_start_points_bounds(series=series, bounds=np.array(bounds), stride=stride)\n    tfm_cls = [cls for cls in model.__class__.__mro__ if cls.__name__ == 'TorchForecastingModel'][0]\n    super(tfm_cls, model).predict(forecast_horizon, series, past_covariates, future_covariates, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    dataset = model._build_inference_dataset(target=series, n=forecast_horizon, past_covariates=past_covariates, future_covariates=future_covariates, stride=stride, bounds=bounds)\n    predictions = model.predict_from_dataset(forecast_horizon, dataset, trainer=None, verbose=verbose, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    forecasts_list = []\n    for series_idx in range(len(series)):\n        pred_idx_start = 0 if not series_idx else cum_lengths[series_idx - 1]\n        pred_idx_end = cum_lengths[series_idx]\n        preds = predictions[pred_idx_start:pred_idx_end]\n        if last_points_only:\n            preds = TimeSeries.from_times_and_values(times=generate_index(start=preds[0].end_time(), length=len(preds), freq=preds[0].freq * stride), values=np.concatenate([p.all_values(copy=False)[-1:, :, :] for p in preds], axis=0), columns=preds[0].columns, static_covariates=preds[0].static_covariates, hierarchy=preds[0].hierarchy)\n        forecasts_list.append(preds)\n    return forecasts_list if len(forecasts_list) > 1 else forecasts_list[0]",
            "def _optimized_historical_forecasts(model, series: Sequence[TimeSeries], past_covariates: Optional[Sequence[TimeSeries]]=None, future_covariates: Optional[Sequence[TimeSeries]]=None, num_samples: int=1, start: Optional[Union[pd.Timestamp, float, int]]=None, start_format: Literal['position', 'value']='value', forecast_horizon: int=1, stride: int=1, overlap_end: bool=False, last_points_only: bool=True, show_warnings: bool=True, predict_likelihood_parameters: bool=False, verbose: bool=False) -> Union[TimeSeries, List[TimeSeries], Sequence[TimeSeries], Sequence[List[TimeSeries]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Optimized historical forecasts for TorchForecastingModels\\n\\n    Rely on _check_optimizable_historical_forecasts() to check that the assumptions are verified.\\n    '\n    bounds = []\n    for (idx, series_) in enumerate(series):\n        past_covariates_ = past_covariates[idx] if past_covariates is not None else None\n        future_covariates_ = future_covariates[idx] if future_covariates is not None else None\n        (hist_fct_start, hist_fct_end, _, _, _, _, _, _) = _get_historical_forecast_boundaries(model=model, series=series_, series_idx=idx, past_covariates=past_covariates_, future_covariates=future_covariates_, start=start, start_format=start_format, forecast_horizon=forecast_horizon, overlap_end=overlap_end, freq=series_.freq, show_warnings=show_warnings)\n        left_bound = series_.get_index_at_point(hist_fct_start)\n        if hist_fct_end > series_.end_time():\n            right_bound = len(series_)\n        else:\n            right_bound = series_.get_index_at_point(hist_fct_end)\n        bounds.append((left_bound, right_bound))\n    (bounds, cum_lengths) = _process_predict_start_points_bounds(series=series, bounds=np.array(bounds), stride=stride)\n    tfm_cls = [cls for cls in model.__class__.__mro__ if cls.__name__ == 'TorchForecastingModel'][0]\n    super(tfm_cls, model).predict(forecast_horizon, series, past_covariates, future_covariates, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    dataset = model._build_inference_dataset(target=series, n=forecast_horizon, past_covariates=past_covariates, future_covariates=future_covariates, stride=stride, bounds=bounds)\n    predictions = model.predict_from_dataset(forecast_horizon, dataset, trainer=None, verbose=verbose, num_samples=num_samples, predict_likelihood_parameters=predict_likelihood_parameters)\n    forecasts_list = []\n    for series_idx in range(len(series)):\n        pred_idx_start = 0 if not series_idx else cum_lengths[series_idx - 1]\n        pred_idx_end = cum_lengths[series_idx]\n        preds = predictions[pred_idx_start:pred_idx_end]\n        if last_points_only:\n            preds = TimeSeries.from_times_and_values(times=generate_index(start=preds[0].end_time(), length=len(preds), freq=preds[0].freq * stride), values=np.concatenate([p.all_values(copy=False)[-1:, :, :] for p in preds], axis=0), columns=preds[0].columns, static_covariates=preds[0].static_covariates, hierarchy=preds[0].hierarchy)\n        forecasts_list.append(preds)\n    return forecasts_list if len(forecasts_list) > 1 else forecasts_list[0]"
        ]
    }
]