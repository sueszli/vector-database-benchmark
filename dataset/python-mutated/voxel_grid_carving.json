[
    {
        "func_name": "xyz_spherical",
        "original": "def xyz_spherical(xyz):\n    x = xyz[0]\n    y = xyz[1]\n    z = xyz[2]\n    r = np.sqrt(x * x + y * y + z * z)\n    r_x = np.arccos(y / r)\n    r_y = np.arctan2(z, x)\n    return [r, r_x, r_y]",
        "mutated": [
            "def xyz_spherical(xyz):\n    if False:\n        i = 10\n    x = xyz[0]\n    y = xyz[1]\n    z = xyz[2]\n    r = np.sqrt(x * x + y * y + z * z)\n    r_x = np.arccos(y / r)\n    r_y = np.arctan2(z, x)\n    return [r, r_x, r_y]",
            "def xyz_spherical(xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = xyz[0]\n    y = xyz[1]\n    z = xyz[2]\n    r = np.sqrt(x * x + y * y + z * z)\n    r_x = np.arccos(y / r)\n    r_y = np.arctan2(z, x)\n    return [r, r_x, r_y]",
            "def xyz_spherical(xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = xyz[0]\n    y = xyz[1]\n    z = xyz[2]\n    r = np.sqrt(x * x + y * y + z * z)\n    r_x = np.arccos(y / r)\n    r_y = np.arctan2(z, x)\n    return [r, r_x, r_y]",
            "def xyz_spherical(xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = xyz[0]\n    y = xyz[1]\n    z = xyz[2]\n    r = np.sqrt(x * x + y * y + z * z)\n    r_x = np.arccos(y / r)\n    r_y = np.arctan2(z, x)\n    return [r, r_x, r_y]",
            "def xyz_spherical(xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = xyz[0]\n    y = xyz[1]\n    z = xyz[2]\n    r = np.sqrt(x * x + y * y + z * z)\n    r_x = np.arccos(y / r)\n    r_y = np.arctan2(z, x)\n    return [r, r_x, r_y]"
        ]
    },
    {
        "func_name": "get_rotation_matrix",
        "original": "def get_rotation_matrix(r_x, r_y):\n    rot_x = np.asarray([[1, 0, 0], [0, np.cos(r_x), -np.sin(r_x)], [0, np.sin(r_x), np.cos(r_x)]])\n    rot_y = np.asarray([[np.cos(r_y), 0, np.sin(r_y)], [0, 1, 0], [-np.sin(r_y), 0, np.cos(r_y)]])\n    return rot_y.dot(rot_x)",
        "mutated": [
            "def get_rotation_matrix(r_x, r_y):\n    if False:\n        i = 10\n    rot_x = np.asarray([[1, 0, 0], [0, np.cos(r_x), -np.sin(r_x)], [0, np.sin(r_x), np.cos(r_x)]])\n    rot_y = np.asarray([[np.cos(r_y), 0, np.sin(r_y)], [0, 1, 0], [-np.sin(r_y), 0, np.cos(r_y)]])\n    return rot_y.dot(rot_x)",
            "def get_rotation_matrix(r_x, r_y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rot_x = np.asarray([[1, 0, 0], [0, np.cos(r_x), -np.sin(r_x)], [0, np.sin(r_x), np.cos(r_x)]])\n    rot_y = np.asarray([[np.cos(r_y), 0, np.sin(r_y)], [0, 1, 0], [-np.sin(r_y), 0, np.cos(r_y)]])\n    return rot_y.dot(rot_x)",
            "def get_rotation_matrix(r_x, r_y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rot_x = np.asarray([[1, 0, 0], [0, np.cos(r_x), -np.sin(r_x)], [0, np.sin(r_x), np.cos(r_x)]])\n    rot_y = np.asarray([[np.cos(r_y), 0, np.sin(r_y)], [0, 1, 0], [-np.sin(r_y), 0, np.cos(r_y)]])\n    return rot_y.dot(rot_x)",
            "def get_rotation_matrix(r_x, r_y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rot_x = np.asarray([[1, 0, 0], [0, np.cos(r_x), -np.sin(r_x)], [0, np.sin(r_x), np.cos(r_x)]])\n    rot_y = np.asarray([[np.cos(r_y), 0, np.sin(r_y)], [0, 1, 0], [-np.sin(r_y), 0, np.cos(r_y)]])\n    return rot_y.dot(rot_x)",
            "def get_rotation_matrix(r_x, r_y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rot_x = np.asarray([[1, 0, 0], [0, np.cos(r_x), -np.sin(r_x)], [0, np.sin(r_x), np.cos(r_x)]])\n    rot_y = np.asarray([[np.cos(r_y), 0, np.sin(r_y)], [0, 1, 0], [-np.sin(r_y), 0, np.cos(r_y)]])\n    return rot_y.dot(rot_x)"
        ]
    },
    {
        "func_name": "get_extrinsic",
        "original": "def get_extrinsic(xyz):\n    rvec = xyz_spherical(xyz)\n    r = get_rotation_matrix(rvec[1], rvec[2])\n    t = np.asarray([0, 0, 2]).transpose()\n    trans = np.eye(4)\n    trans[:3, :3] = r\n    trans[:3, 3] = t\n    return trans",
        "mutated": [
            "def get_extrinsic(xyz):\n    if False:\n        i = 10\n    rvec = xyz_spherical(xyz)\n    r = get_rotation_matrix(rvec[1], rvec[2])\n    t = np.asarray([0, 0, 2]).transpose()\n    trans = np.eye(4)\n    trans[:3, :3] = r\n    trans[:3, 3] = t\n    return trans",
            "def get_extrinsic(xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rvec = xyz_spherical(xyz)\n    r = get_rotation_matrix(rvec[1], rvec[2])\n    t = np.asarray([0, 0, 2]).transpose()\n    trans = np.eye(4)\n    trans[:3, :3] = r\n    trans[:3, 3] = t\n    return trans",
            "def get_extrinsic(xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rvec = xyz_spherical(xyz)\n    r = get_rotation_matrix(rvec[1], rvec[2])\n    t = np.asarray([0, 0, 2]).transpose()\n    trans = np.eye(4)\n    trans[:3, :3] = r\n    trans[:3, 3] = t\n    return trans",
            "def get_extrinsic(xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rvec = xyz_spherical(xyz)\n    r = get_rotation_matrix(rvec[1], rvec[2])\n    t = np.asarray([0, 0, 2]).transpose()\n    trans = np.eye(4)\n    trans[:3, :3] = r\n    trans[:3, 3] = t\n    return trans",
            "def get_extrinsic(xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rvec = xyz_spherical(xyz)\n    r = get_rotation_matrix(rvec[1], rvec[2])\n    t = np.asarray([0, 0, 2]).transpose()\n    trans = np.eye(4)\n    trans[:3, :3] = r\n    trans[:3, 3] = t\n    return trans"
        ]
    },
    {
        "func_name": "preprocess",
        "original": "def preprocess(model):\n    min_bound = model.get_min_bound()\n    max_bound = model.get_max_bound()\n    center = min_bound + (max_bound - min_bound) / 2.0\n    scale = np.linalg.norm(max_bound - min_bound) / 2.0\n    vertices = np.asarray(model.vertices)\n    vertices -= center\n    model.vertices = o3d.utility.Vector3dVector(vertices / scale)\n    return model",
        "mutated": [
            "def preprocess(model):\n    if False:\n        i = 10\n    min_bound = model.get_min_bound()\n    max_bound = model.get_max_bound()\n    center = min_bound + (max_bound - min_bound) / 2.0\n    scale = np.linalg.norm(max_bound - min_bound) / 2.0\n    vertices = np.asarray(model.vertices)\n    vertices -= center\n    model.vertices = o3d.utility.Vector3dVector(vertices / scale)\n    return model",
            "def preprocess(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    min_bound = model.get_min_bound()\n    max_bound = model.get_max_bound()\n    center = min_bound + (max_bound - min_bound) / 2.0\n    scale = np.linalg.norm(max_bound - min_bound) / 2.0\n    vertices = np.asarray(model.vertices)\n    vertices -= center\n    model.vertices = o3d.utility.Vector3dVector(vertices / scale)\n    return model",
            "def preprocess(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    min_bound = model.get_min_bound()\n    max_bound = model.get_max_bound()\n    center = min_bound + (max_bound - min_bound) / 2.0\n    scale = np.linalg.norm(max_bound - min_bound) / 2.0\n    vertices = np.asarray(model.vertices)\n    vertices -= center\n    model.vertices = o3d.utility.Vector3dVector(vertices / scale)\n    return model",
            "def preprocess(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    min_bound = model.get_min_bound()\n    max_bound = model.get_max_bound()\n    center = min_bound + (max_bound - min_bound) / 2.0\n    scale = np.linalg.norm(max_bound - min_bound) / 2.0\n    vertices = np.asarray(model.vertices)\n    vertices -= center\n    model.vertices = o3d.utility.Vector3dVector(vertices / scale)\n    return model",
            "def preprocess(model):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    min_bound = model.get_min_bound()\n    max_bound = model.get_max_bound()\n    center = min_bound + (max_bound - min_bound) / 2.0\n    scale = np.linalg.norm(max_bound - min_bound) / 2.0\n    vertices = np.asarray(model.vertices)\n    vertices -= center\n    model.vertices = o3d.utility.Vector3dVector(vertices / scale)\n    return model"
        ]
    },
    {
        "func_name": "voxel_carving",
        "original": "def voxel_carving(mesh, cubic_size, voxel_resolution, w=300, h=300):\n    mesh.compute_vertex_normals()\n    camera_sphere = o3d.geometry.TriangleMesh.create_sphere(radius=1.0, resolution=10)\n    voxel_carving = o3d.geometry.VoxelGrid.create_dense(width=cubic_size, height=cubic_size, depth=cubic_size, voxel_size=cubic_size / voxel_resolution, origin=[-cubic_size / 2.0, -cubic_size / 2.0, -cubic_size / 2.0], color=[1.0, 0.7, 0.0])\n    camera_sphere = preprocess(camera_sphere)\n    mesh = preprocess(mesh)\n    vis = o3d.visualization.Visualizer()\n    vis.create_window(width=w, height=h, visible=False)\n    vis.add_geometry(mesh)\n    vis.get_render_option().mesh_show_back_face = True\n    ctr = vis.get_view_control()\n    param = ctr.convert_to_pinhole_camera_parameters()\n    centers_pts = np.zeros((len(camera_sphere.vertices), 3))\n    for (cid, xyz) in enumerate(camera_sphere.vertices):\n        trans = get_extrinsic(xyz)\n        param.extrinsic = trans\n        c = np.linalg.inv(trans).dot(np.asarray([0, 0, 0, 1]).transpose())\n        centers_pts[cid, :] = c[:3]\n        ctr.convert_from_pinhole_camera_parameters(param)\n        vis.poll_events()\n        vis.update_renderer()\n        depth = vis.capture_depth_float_buffer(False)\n        voxel_carving.carve_depth_map(o3d.geometry.Image(depth), param)\n        print('Carve view %03d/%03d' % (cid + 1, len(camera_sphere.vertices)))\n    vis.destroy_window()\n    return voxel_carving",
        "mutated": [
            "def voxel_carving(mesh, cubic_size, voxel_resolution, w=300, h=300):\n    if False:\n        i = 10\n    mesh.compute_vertex_normals()\n    camera_sphere = o3d.geometry.TriangleMesh.create_sphere(radius=1.0, resolution=10)\n    voxel_carving = o3d.geometry.VoxelGrid.create_dense(width=cubic_size, height=cubic_size, depth=cubic_size, voxel_size=cubic_size / voxel_resolution, origin=[-cubic_size / 2.0, -cubic_size / 2.0, -cubic_size / 2.0], color=[1.0, 0.7, 0.0])\n    camera_sphere = preprocess(camera_sphere)\n    mesh = preprocess(mesh)\n    vis = o3d.visualization.Visualizer()\n    vis.create_window(width=w, height=h, visible=False)\n    vis.add_geometry(mesh)\n    vis.get_render_option().mesh_show_back_face = True\n    ctr = vis.get_view_control()\n    param = ctr.convert_to_pinhole_camera_parameters()\n    centers_pts = np.zeros((len(camera_sphere.vertices), 3))\n    for (cid, xyz) in enumerate(camera_sphere.vertices):\n        trans = get_extrinsic(xyz)\n        param.extrinsic = trans\n        c = np.linalg.inv(trans).dot(np.asarray([0, 0, 0, 1]).transpose())\n        centers_pts[cid, :] = c[:3]\n        ctr.convert_from_pinhole_camera_parameters(param)\n        vis.poll_events()\n        vis.update_renderer()\n        depth = vis.capture_depth_float_buffer(False)\n        voxel_carving.carve_depth_map(o3d.geometry.Image(depth), param)\n        print('Carve view %03d/%03d' % (cid + 1, len(camera_sphere.vertices)))\n    vis.destroy_window()\n    return voxel_carving",
            "def voxel_carving(mesh, cubic_size, voxel_resolution, w=300, h=300):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mesh.compute_vertex_normals()\n    camera_sphere = o3d.geometry.TriangleMesh.create_sphere(radius=1.0, resolution=10)\n    voxel_carving = o3d.geometry.VoxelGrid.create_dense(width=cubic_size, height=cubic_size, depth=cubic_size, voxel_size=cubic_size / voxel_resolution, origin=[-cubic_size / 2.0, -cubic_size / 2.0, -cubic_size / 2.0], color=[1.0, 0.7, 0.0])\n    camera_sphere = preprocess(camera_sphere)\n    mesh = preprocess(mesh)\n    vis = o3d.visualization.Visualizer()\n    vis.create_window(width=w, height=h, visible=False)\n    vis.add_geometry(mesh)\n    vis.get_render_option().mesh_show_back_face = True\n    ctr = vis.get_view_control()\n    param = ctr.convert_to_pinhole_camera_parameters()\n    centers_pts = np.zeros((len(camera_sphere.vertices), 3))\n    for (cid, xyz) in enumerate(camera_sphere.vertices):\n        trans = get_extrinsic(xyz)\n        param.extrinsic = trans\n        c = np.linalg.inv(trans).dot(np.asarray([0, 0, 0, 1]).transpose())\n        centers_pts[cid, :] = c[:3]\n        ctr.convert_from_pinhole_camera_parameters(param)\n        vis.poll_events()\n        vis.update_renderer()\n        depth = vis.capture_depth_float_buffer(False)\n        voxel_carving.carve_depth_map(o3d.geometry.Image(depth), param)\n        print('Carve view %03d/%03d' % (cid + 1, len(camera_sphere.vertices)))\n    vis.destroy_window()\n    return voxel_carving",
            "def voxel_carving(mesh, cubic_size, voxel_resolution, w=300, h=300):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mesh.compute_vertex_normals()\n    camera_sphere = o3d.geometry.TriangleMesh.create_sphere(radius=1.0, resolution=10)\n    voxel_carving = o3d.geometry.VoxelGrid.create_dense(width=cubic_size, height=cubic_size, depth=cubic_size, voxel_size=cubic_size / voxel_resolution, origin=[-cubic_size / 2.0, -cubic_size / 2.0, -cubic_size / 2.0], color=[1.0, 0.7, 0.0])\n    camera_sphere = preprocess(camera_sphere)\n    mesh = preprocess(mesh)\n    vis = o3d.visualization.Visualizer()\n    vis.create_window(width=w, height=h, visible=False)\n    vis.add_geometry(mesh)\n    vis.get_render_option().mesh_show_back_face = True\n    ctr = vis.get_view_control()\n    param = ctr.convert_to_pinhole_camera_parameters()\n    centers_pts = np.zeros((len(camera_sphere.vertices), 3))\n    for (cid, xyz) in enumerate(camera_sphere.vertices):\n        trans = get_extrinsic(xyz)\n        param.extrinsic = trans\n        c = np.linalg.inv(trans).dot(np.asarray([0, 0, 0, 1]).transpose())\n        centers_pts[cid, :] = c[:3]\n        ctr.convert_from_pinhole_camera_parameters(param)\n        vis.poll_events()\n        vis.update_renderer()\n        depth = vis.capture_depth_float_buffer(False)\n        voxel_carving.carve_depth_map(o3d.geometry.Image(depth), param)\n        print('Carve view %03d/%03d' % (cid + 1, len(camera_sphere.vertices)))\n    vis.destroy_window()\n    return voxel_carving",
            "def voxel_carving(mesh, cubic_size, voxel_resolution, w=300, h=300):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mesh.compute_vertex_normals()\n    camera_sphere = o3d.geometry.TriangleMesh.create_sphere(radius=1.0, resolution=10)\n    voxel_carving = o3d.geometry.VoxelGrid.create_dense(width=cubic_size, height=cubic_size, depth=cubic_size, voxel_size=cubic_size / voxel_resolution, origin=[-cubic_size / 2.0, -cubic_size / 2.0, -cubic_size / 2.0], color=[1.0, 0.7, 0.0])\n    camera_sphere = preprocess(camera_sphere)\n    mesh = preprocess(mesh)\n    vis = o3d.visualization.Visualizer()\n    vis.create_window(width=w, height=h, visible=False)\n    vis.add_geometry(mesh)\n    vis.get_render_option().mesh_show_back_face = True\n    ctr = vis.get_view_control()\n    param = ctr.convert_to_pinhole_camera_parameters()\n    centers_pts = np.zeros((len(camera_sphere.vertices), 3))\n    for (cid, xyz) in enumerate(camera_sphere.vertices):\n        trans = get_extrinsic(xyz)\n        param.extrinsic = trans\n        c = np.linalg.inv(trans).dot(np.asarray([0, 0, 0, 1]).transpose())\n        centers_pts[cid, :] = c[:3]\n        ctr.convert_from_pinhole_camera_parameters(param)\n        vis.poll_events()\n        vis.update_renderer()\n        depth = vis.capture_depth_float_buffer(False)\n        voxel_carving.carve_depth_map(o3d.geometry.Image(depth), param)\n        print('Carve view %03d/%03d' % (cid + 1, len(camera_sphere.vertices)))\n    vis.destroy_window()\n    return voxel_carving",
            "def voxel_carving(mesh, cubic_size, voxel_resolution, w=300, h=300):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mesh.compute_vertex_normals()\n    camera_sphere = o3d.geometry.TriangleMesh.create_sphere(radius=1.0, resolution=10)\n    voxel_carving = o3d.geometry.VoxelGrid.create_dense(width=cubic_size, height=cubic_size, depth=cubic_size, voxel_size=cubic_size / voxel_resolution, origin=[-cubic_size / 2.0, -cubic_size / 2.0, -cubic_size / 2.0], color=[1.0, 0.7, 0.0])\n    camera_sphere = preprocess(camera_sphere)\n    mesh = preprocess(mesh)\n    vis = o3d.visualization.Visualizer()\n    vis.create_window(width=w, height=h, visible=False)\n    vis.add_geometry(mesh)\n    vis.get_render_option().mesh_show_back_face = True\n    ctr = vis.get_view_control()\n    param = ctr.convert_to_pinhole_camera_parameters()\n    centers_pts = np.zeros((len(camera_sphere.vertices), 3))\n    for (cid, xyz) in enumerate(camera_sphere.vertices):\n        trans = get_extrinsic(xyz)\n        param.extrinsic = trans\n        c = np.linalg.inv(trans).dot(np.asarray([0, 0, 0, 1]).transpose())\n        centers_pts[cid, :] = c[:3]\n        ctr.convert_from_pinhole_camera_parameters(param)\n        vis.poll_events()\n        vis.update_renderer()\n        depth = vis.capture_depth_float_buffer(False)\n        voxel_carving.carve_depth_map(o3d.geometry.Image(depth), param)\n        print('Carve view %03d/%03d' % (cid + 1, len(camera_sphere.vertices)))\n    vis.destroy_window()\n    return voxel_carving"
        ]
    }
]