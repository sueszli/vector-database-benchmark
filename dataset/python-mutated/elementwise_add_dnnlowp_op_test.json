[
    {
        "func_name": "test_dnnlowp_elementwise_add_int",
        "original": "@given(N=st.integers(32, 256), is_empty=st.booleans(), in_quantized=st.booleans(), out_quantized=st.booleans(), in_place=st.sampled_from([(False, False), (True, False), (False, True)]), **hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_int(self, N, is_empty, in_quantized, out_quantized, in_place, gc, dc):\n    if is_empty:\n        N = 0\n    if in_place[0] or in_place[1]:\n        in_quantized = True\n        out_quantized = True\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(N) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    if N != 0:\n        A[0] = min_\n        A[1] = max_\n    B = np.round(np.random.rand(N) * 255 / 2 - 64).astype(np.float32)\n    if N != 0:\n        B[0] = -64\n        B[1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        do_quantize = 'DNNLOWP' in engine and in_quantized\n        do_dequantize = 'DNNLOWP' in engine and out_quantized\n        if do_quantize:\n            quantize_A = core.CreateOperator('Quantize', ['A'], ['A_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_A])\n            quantize_B = core.CreateOperator('Quantize', ['B'], ['B_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_B])\n        out = 'Y'\n        if in_place[0]:\n            out = 'A'\n        elif in_place[1]:\n            out = 'B'\n        add = core.CreateOperator(op_type, ['A_q', 'B_q'] if do_quantize else ['A', 'B'], [out + '_q' if do_dequantize else out], dequantize_output=not do_dequantize, engine=engine, device_option=gc)\n        net.Proto().op.extend([add])\n        if do_dequantize:\n            dequantize = core.CreateOperator('Dequantize', [out + '_q'], [out], engine=engine, device_option=gc)\n            net.Proto().op.extend([dequantize])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs[out].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
        "mutated": [
            "@given(N=st.integers(32, 256), is_empty=st.booleans(), in_quantized=st.booleans(), out_quantized=st.booleans(), in_place=st.sampled_from([(False, False), (True, False), (False, True)]), **hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_int(self, N, is_empty, in_quantized, out_quantized, in_place, gc, dc):\n    if False:\n        i = 10\n    if is_empty:\n        N = 0\n    if in_place[0] or in_place[1]:\n        in_quantized = True\n        out_quantized = True\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(N) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    if N != 0:\n        A[0] = min_\n        A[1] = max_\n    B = np.round(np.random.rand(N) * 255 / 2 - 64).astype(np.float32)\n    if N != 0:\n        B[0] = -64\n        B[1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        do_quantize = 'DNNLOWP' in engine and in_quantized\n        do_dequantize = 'DNNLOWP' in engine and out_quantized\n        if do_quantize:\n            quantize_A = core.CreateOperator('Quantize', ['A'], ['A_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_A])\n            quantize_B = core.CreateOperator('Quantize', ['B'], ['B_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_B])\n        out = 'Y'\n        if in_place[0]:\n            out = 'A'\n        elif in_place[1]:\n            out = 'B'\n        add = core.CreateOperator(op_type, ['A_q', 'B_q'] if do_quantize else ['A', 'B'], [out + '_q' if do_dequantize else out], dequantize_output=not do_dequantize, engine=engine, device_option=gc)\n        net.Proto().op.extend([add])\n        if do_dequantize:\n            dequantize = core.CreateOperator('Dequantize', [out + '_q'], [out], engine=engine, device_option=gc)\n            net.Proto().op.extend([dequantize])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs[out].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
            "@given(N=st.integers(32, 256), is_empty=st.booleans(), in_quantized=st.booleans(), out_quantized=st.booleans(), in_place=st.sampled_from([(False, False), (True, False), (False, True)]), **hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_int(self, N, is_empty, in_quantized, out_quantized, in_place, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if is_empty:\n        N = 0\n    if in_place[0] or in_place[1]:\n        in_quantized = True\n        out_quantized = True\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(N) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    if N != 0:\n        A[0] = min_\n        A[1] = max_\n    B = np.round(np.random.rand(N) * 255 / 2 - 64).astype(np.float32)\n    if N != 0:\n        B[0] = -64\n        B[1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        do_quantize = 'DNNLOWP' in engine and in_quantized\n        do_dequantize = 'DNNLOWP' in engine and out_quantized\n        if do_quantize:\n            quantize_A = core.CreateOperator('Quantize', ['A'], ['A_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_A])\n            quantize_B = core.CreateOperator('Quantize', ['B'], ['B_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_B])\n        out = 'Y'\n        if in_place[0]:\n            out = 'A'\n        elif in_place[1]:\n            out = 'B'\n        add = core.CreateOperator(op_type, ['A_q', 'B_q'] if do_quantize else ['A', 'B'], [out + '_q' if do_dequantize else out], dequantize_output=not do_dequantize, engine=engine, device_option=gc)\n        net.Proto().op.extend([add])\n        if do_dequantize:\n            dequantize = core.CreateOperator('Dequantize', [out + '_q'], [out], engine=engine, device_option=gc)\n            net.Proto().op.extend([dequantize])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs[out].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
            "@given(N=st.integers(32, 256), is_empty=st.booleans(), in_quantized=st.booleans(), out_quantized=st.booleans(), in_place=st.sampled_from([(False, False), (True, False), (False, True)]), **hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_int(self, N, is_empty, in_quantized, out_quantized, in_place, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if is_empty:\n        N = 0\n    if in_place[0] or in_place[1]:\n        in_quantized = True\n        out_quantized = True\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(N) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    if N != 0:\n        A[0] = min_\n        A[1] = max_\n    B = np.round(np.random.rand(N) * 255 / 2 - 64).astype(np.float32)\n    if N != 0:\n        B[0] = -64\n        B[1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        do_quantize = 'DNNLOWP' in engine and in_quantized\n        do_dequantize = 'DNNLOWP' in engine and out_quantized\n        if do_quantize:\n            quantize_A = core.CreateOperator('Quantize', ['A'], ['A_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_A])\n            quantize_B = core.CreateOperator('Quantize', ['B'], ['B_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_B])\n        out = 'Y'\n        if in_place[0]:\n            out = 'A'\n        elif in_place[1]:\n            out = 'B'\n        add = core.CreateOperator(op_type, ['A_q', 'B_q'] if do_quantize else ['A', 'B'], [out + '_q' if do_dequantize else out], dequantize_output=not do_dequantize, engine=engine, device_option=gc)\n        net.Proto().op.extend([add])\n        if do_dequantize:\n            dequantize = core.CreateOperator('Dequantize', [out + '_q'], [out], engine=engine, device_option=gc)\n            net.Proto().op.extend([dequantize])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs[out].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
            "@given(N=st.integers(32, 256), is_empty=st.booleans(), in_quantized=st.booleans(), out_quantized=st.booleans(), in_place=st.sampled_from([(False, False), (True, False), (False, True)]), **hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_int(self, N, is_empty, in_quantized, out_quantized, in_place, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if is_empty:\n        N = 0\n    if in_place[0] or in_place[1]:\n        in_quantized = True\n        out_quantized = True\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(N) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    if N != 0:\n        A[0] = min_\n        A[1] = max_\n    B = np.round(np.random.rand(N) * 255 / 2 - 64).astype(np.float32)\n    if N != 0:\n        B[0] = -64\n        B[1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        do_quantize = 'DNNLOWP' in engine and in_quantized\n        do_dequantize = 'DNNLOWP' in engine and out_quantized\n        if do_quantize:\n            quantize_A = core.CreateOperator('Quantize', ['A'], ['A_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_A])\n            quantize_B = core.CreateOperator('Quantize', ['B'], ['B_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_B])\n        out = 'Y'\n        if in_place[0]:\n            out = 'A'\n        elif in_place[1]:\n            out = 'B'\n        add = core.CreateOperator(op_type, ['A_q', 'B_q'] if do_quantize else ['A', 'B'], [out + '_q' if do_dequantize else out], dequantize_output=not do_dequantize, engine=engine, device_option=gc)\n        net.Proto().op.extend([add])\n        if do_dequantize:\n            dequantize = core.CreateOperator('Dequantize', [out + '_q'], [out], engine=engine, device_option=gc)\n            net.Proto().op.extend([dequantize])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs[out].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
            "@given(N=st.integers(32, 256), is_empty=st.booleans(), in_quantized=st.booleans(), out_quantized=st.booleans(), in_place=st.sampled_from([(False, False), (True, False), (False, True)]), **hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_int(self, N, is_empty, in_quantized, out_quantized, in_place, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if is_empty:\n        N = 0\n    if in_place[0] or in_place[1]:\n        in_quantized = True\n        out_quantized = True\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(N) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    if N != 0:\n        A[0] = min_\n        A[1] = max_\n    B = np.round(np.random.rand(N) * 255 / 2 - 64).astype(np.float32)\n    if N != 0:\n        B[0] = -64\n        B[1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        do_quantize = 'DNNLOWP' in engine and in_quantized\n        do_dequantize = 'DNNLOWP' in engine and out_quantized\n        if do_quantize:\n            quantize_A = core.CreateOperator('Quantize', ['A'], ['A_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_A])\n            quantize_B = core.CreateOperator('Quantize', ['B'], ['B_q'], engine=engine, device_option=gc)\n            net.Proto().op.extend([quantize_B])\n        out = 'Y'\n        if in_place[0]:\n            out = 'A'\n        elif in_place[1]:\n            out = 'B'\n        add = core.CreateOperator(op_type, ['A_q', 'B_q'] if do_quantize else ['A', 'B'], [out + '_q' if do_dequantize else out], dequantize_output=not do_dequantize, engine=engine, device_option=gc)\n        net.Proto().op.extend([add])\n        if do_dequantize:\n            dequantize = core.CreateOperator('Dequantize', [out + '_q'], [out], engine=engine, device_option=gc)\n            net.Proto().op.extend([dequantize])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs[out].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)"
        ]
    },
    {
        "func_name": "test_dnnlowp_elementwise_add_broadcast",
        "original": "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast(self, gc, dc):\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    A[0, 0, 0, 0] = min_\n    A[0, 0, 0, 1] = max_\n    B = np.round(np.random.rand(4, 5) * 255 / 2 - 64).astype(np.float32)\n    B[0, 0] = -64\n    B[0, 1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, dequantize_output=1)\n        net.Proto().op.extend([add])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
        "mutated": [
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast(self, gc, dc):\n    if False:\n        i = 10\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    A[0, 0, 0, 0] = min_\n    A[0, 0, 0, 1] = max_\n    B = np.round(np.random.rand(4, 5) * 255 / 2 - 64).astype(np.float32)\n    B[0, 0] = -64\n    B[0, 1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, dequantize_output=1)\n        net.Proto().op.extend([add])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast(self, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    A[0, 0, 0, 0] = min_\n    A[0, 0, 0, 1] = max_\n    B = np.round(np.random.rand(4, 5) * 255 / 2 - 64).astype(np.float32)\n    B[0, 0] = -64\n    B[0, 1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, dequantize_output=1)\n        net.Proto().op.extend([add])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast(self, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    A[0, 0, 0, 0] = min_\n    A[0, 0, 0, 1] = max_\n    B = np.round(np.random.rand(4, 5) * 255 / 2 - 64).astype(np.float32)\n    B[0, 0] = -64\n    B[0, 1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, dequantize_output=1)\n        net.Proto().op.extend([add])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast(self, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    A[0, 0, 0, 0] = min_\n    A[0, 0, 0, 1] = max_\n    B = np.round(np.random.rand(4, 5) * 255 / 2 - 64).astype(np.float32)\n    B[0, 0] = -64\n    B[0, 1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, dequantize_output=1)\n        net.Proto().op.extend([add])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)",
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast(self, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    min_ = -100\n    max_ = min_ + 255\n    A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n    A = A.astype(np.float32)\n    A[0, 0, 0, 0] = min_\n    A[0, 0, 0, 1] = max_\n    B = np.round(np.random.rand(4, 5) * 255 / 2 - 64).astype(np.float32)\n    B[0, 0] = -64\n    B[0, 1] = 127.0 / 2\n    Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n    outputs = []\n    op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n    for (op_type, engine) in op_engine_list:\n        net = core.Net('test_net')\n        add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, dequantize_output=1)\n        net.Proto().op.extend([add])\n        self.ws.create_blob('A').feed(A, device_option=gc)\n        self.ws.create_blob('B').feed(B, device_option=gc)\n        self.ws.run(net)\n        outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n    check_quantized_results_close(outputs)"
        ]
    },
    {
        "func_name": "test_dnnlowp_elementwise_add_broadcast_axis",
        "original": "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast_axis(self, gc, dc):\n    for (bdim, axis) in [((3, 4), 1), ((2,), 0), ((1, 4, 1), 1)]:\n        min_ = -100\n        max_ = min_ + 255\n        A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n        A = A.astype(np.float32)\n        B = np.round(np.random.rand(*bdim) * 255 / 2 - 64).astype(np.float32)\n        A.flat[0] = min_\n        A.flat[1] = max_\n        B.flat[0] = -64\n        B.flat[1] = 127.0 / 2\n        Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n        outputs = []\n        op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n        for (op_type, engine) in op_engine_list:\n            net = core.Net('test_net')\n            add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, axis=axis, dequantize_output=1)\n            net.Proto().op.extend([add])\n            self.ws.create_blob('A').feed(A, device_option=gc)\n            self.ws.create_blob('B').feed(B, device_option=gc)\n            self.ws.run(net)\n            outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n        check_quantized_results_close(outputs)",
        "mutated": [
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast_axis(self, gc, dc):\n    if False:\n        i = 10\n    for (bdim, axis) in [((3, 4), 1), ((2,), 0), ((1, 4, 1), 1)]:\n        min_ = -100\n        max_ = min_ + 255\n        A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n        A = A.astype(np.float32)\n        B = np.round(np.random.rand(*bdim) * 255 / 2 - 64).astype(np.float32)\n        A.flat[0] = min_\n        A.flat[1] = max_\n        B.flat[0] = -64\n        B.flat[1] = 127.0 / 2\n        Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n        outputs = []\n        op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n        for (op_type, engine) in op_engine_list:\n            net = core.Net('test_net')\n            add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, axis=axis, dequantize_output=1)\n            net.Proto().op.extend([add])\n            self.ws.create_blob('A').feed(A, device_option=gc)\n            self.ws.create_blob('B').feed(B, device_option=gc)\n            self.ws.run(net)\n            outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n        check_quantized_results_close(outputs)",
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast_axis(self, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for (bdim, axis) in [((3, 4), 1), ((2,), 0), ((1, 4, 1), 1)]:\n        min_ = -100\n        max_ = min_ + 255\n        A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n        A = A.astype(np.float32)\n        B = np.round(np.random.rand(*bdim) * 255 / 2 - 64).astype(np.float32)\n        A.flat[0] = min_\n        A.flat[1] = max_\n        B.flat[0] = -64\n        B.flat[1] = 127.0 / 2\n        Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n        outputs = []\n        op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n        for (op_type, engine) in op_engine_list:\n            net = core.Net('test_net')\n            add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, axis=axis, dequantize_output=1)\n            net.Proto().op.extend([add])\n            self.ws.create_blob('A').feed(A, device_option=gc)\n            self.ws.create_blob('B').feed(B, device_option=gc)\n            self.ws.run(net)\n            outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n        check_quantized_results_close(outputs)",
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast_axis(self, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for (bdim, axis) in [((3, 4), 1), ((2,), 0), ((1, 4, 1), 1)]:\n        min_ = -100\n        max_ = min_ + 255\n        A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n        A = A.astype(np.float32)\n        B = np.round(np.random.rand(*bdim) * 255 / 2 - 64).astype(np.float32)\n        A.flat[0] = min_\n        A.flat[1] = max_\n        B.flat[0] = -64\n        B.flat[1] = 127.0 / 2\n        Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n        outputs = []\n        op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n        for (op_type, engine) in op_engine_list:\n            net = core.Net('test_net')\n            add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, axis=axis, dequantize_output=1)\n            net.Proto().op.extend([add])\n            self.ws.create_blob('A').feed(A, device_option=gc)\n            self.ws.create_blob('B').feed(B, device_option=gc)\n            self.ws.run(net)\n            outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n        check_quantized_results_close(outputs)",
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast_axis(self, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for (bdim, axis) in [((3, 4), 1), ((2,), 0), ((1, 4, 1), 1)]:\n        min_ = -100\n        max_ = min_ + 255\n        A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n        A = A.astype(np.float32)\n        B = np.round(np.random.rand(*bdim) * 255 / 2 - 64).astype(np.float32)\n        A.flat[0] = min_\n        A.flat[1] = max_\n        B.flat[0] = -64\n        B.flat[1] = 127.0 / 2\n        Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n        outputs = []\n        op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n        for (op_type, engine) in op_engine_list:\n            net = core.Net('test_net')\n            add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, axis=axis, dequantize_output=1)\n            net.Proto().op.extend([add])\n            self.ws.create_blob('A').feed(A, device_option=gc)\n            self.ws.create_blob('B').feed(B, device_option=gc)\n            self.ws.run(net)\n            outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n        check_quantized_results_close(outputs)",
            "@given(**hu.gcs_cpu_only)\ndef test_dnnlowp_elementwise_add_broadcast_axis(self, gc, dc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for (bdim, axis) in [((3, 4), 1), ((2,), 0), ((1, 4, 1), 1)]:\n        min_ = -100\n        max_ = min_ + 255\n        A = np.round(np.random.rand(2, 3, 4, 5) * (max_ - min_) + min_)\n        A = A.astype(np.float32)\n        B = np.round(np.random.rand(*bdim) * 255 / 2 - 64).astype(np.float32)\n        A.flat[0] = min_\n        A.flat[1] = max_\n        B.flat[0] = -64\n        B.flat[1] = 127.0 / 2\n        Output = collections.namedtuple('Output', ['Y', 'op_type', 'engine'])\n        outputs = []\n        op_engine_list = [('Add', ''), ('Add', 'DNNLOWP'), ('Int8Add', 'DNNLOWP')]\n        for (op_type, engine) in op_engine_list:\n            net = core.Net('test_net')\n            add = core.CreateOperator(op_type, ['A', 'B'], ['Y'], engine=engine, device_option=gc, broadcast=1, axis=axis, dequantize_output=1)\n            net.Proto().op.extend([add])\n            self.ws.create_blob('A').feed(A, device_option=gc)\n            self.ws.create_blob('B').feed(B, device_option=gc)\n            self.ws.run(net)\n            outputs.append(Output(Y=self.ws.blobs['Y'].fetch(), op_type=op_type, engine=engine))\n        check_quantized_results_close(outputs)"
        ]
    }
]