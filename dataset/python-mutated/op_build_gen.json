[
    {
        "func_name": "GenBuildInputArgsStr",
        "original": "def GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, for_func_define=True, mutable_attr_is_input=False, attr_args_is_map=False):\n    \"\"\"\n    Example: pir::Builder &builder, pir::OperationArgument &argument, pir::Value x_, phi::DataType dtype=phi::DataType::UNDEFINED, phi::Place place={}\n    \"\"\"\n    build_args_str = 'pir::Builder &builder, pir::OperationArgument &argument'\n    if len(op_input_name_list) > 0:\n        for input_name in op_input_name_list:\n            build_args_str += ', pir::Value ' + input_name + '_'\n    if mutable_attr_is_input:\n        if len(op_mutable_attribute_name_list) > 0:\n            for mutable_attr in op_mutable_attribute_name_list:\n                build_args_str += ', pir::Value ' + mutable_attr + '_'\n        if attr_args_is_map:\n            build_args_str += ', pir::AttributeMap attributes'\n        else:\n            for attr_idx in range(len(op_non_mutable_attribute_name_list)):\n                build_args_str += ', ' + op_non_mutable_attribute_build_arg_type_list[attr_idx] + ' ' + op_non_mutable_attribute_name_list[attr_idx]\n                if for_func_define:\n                    if op_non_mutable_attribute_default_value_list[attr_idx] is not None:\n                        default_value = op_non_mutable_attribute_default_value_list[attr_idx]\n                        if op_non_mutable_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                            if default_value[0] == \"'\" or default_value[0] == '\"':\n                                default_value = default_value[1:]\n                            if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                                default_value = default_value[0:-1]\n                        build_args_str += '=' + default_value\n    elif attr_args_is_map:\n        build_args_str += ', pir::AttributeMap attributes'\n    else:\n        for attr_idx in range(len(op_attribute_name_list)):\n            build_args_str += ', ' + op_attribute_build_arg_type_list[attr_idx] + ' ' + op_attribute_name_list[attr_idx]\n            if for_func_define:\n                if op_attribute_default_value_list[attr_idx] is not None:\n                    default_value = op_attribute_default_value_list[attr_idx]\n                    if op_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                        if default_value[0] == \"'\" or default_value[0] == '\"':\n                            default_value = default_value[1:]\n                        if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                            default_value = default_value[0:-1]\n                    build_args_str += '=' + default_value\n    return build_args_str",
        "mutated": [
            "def GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, for_func_define=True, mutable_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n    '\\n    Example: pir::Builder &builder, pir::OperationArgument &argument, pir::Value x_, phi::DataType dtype=phi::DataType::UNDEFINED, phi::Place place={}\\n    '\n    build_args_str = 'pir::Builder &builder, pir::OperationArgument &argument'\n    if len(op_input_name_list) > 0:\n        for input_name in op_input_name_list:\n            build_args_str += ', pir::Value ' + input_name + '_'\n    if mutable_attr_is_input:\n        if len(op_mutable_attribute_name_list) > 0:\n            for mutable_attr in op_mutable_attribute_name_list:\n                build_args_str += ', pir::Value ' + mutable_attr + '_'\n        if attr_args_is_map:\n            build_args_str += ', pir::AttributeMap attributes'\n        else:\n            for attr_idx in range(len(op_non_mutable_attribute_name_list)):\n                build_args_str += ', ' + op_non_mutable_attribute_build_arg_type_list[attr_idx] + ' ' + op_non_mutable_attribute_name_list[attr_idx]\n                if for_func_define:\n                    if op_non_mutable_attribute_default_value_list[attr_idx] is not None:\n                        default_value = op_non_mutable_attribute_default_value_list[attr_idx]\n                        if op_non_mutable_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                            if default_value[0] == \"'\" or default_value[0] == '\"':\n                                default_value = default_value[1:]\n                            if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                                default_value = default_value[0:-1]\n                        build_args_str += '=' + default_value\n    elif attr_args_is_map:\n        build_args_str += ', pir::AttributeMap attributes'\n    else:\n        for attr_idx in range(len(op_attribute_name_list)):\n            build_args_str += ', ' + op_attribute_build_arg_type_list[attr_idx] + ' ' + op_attribute_name_list[attr_idx]\n            if for_func_define:\n                if op_attribute_default_value_list[attr_idx] is not None:\n                    default_value = op_attribute_default_value_list[attr_idx]\n                    if op_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                        if default_value[0] == \"'\" or default_value[0] == '\"':\n                            default_value = default_value[1:]\n                        if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                            default_value = default_value[0:-1]\n                    build_args_str += '=' + default_value\n    return build_args_str",
            "def GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, for_func_define=True, mutable_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Example: pir::Builder &builder, pir::OperationArgument &argument, pir::Value x_, phi::DataType dtype=phi::DataType::UNDEFINED, phi::Place place={}\\n    '\n    build_args_str = 'pir::Builder &builder, pir::OperationArgument &argument'\n    if len(op_input_name_list) > 0:\n        for input_name in op_input_name_list:\n            build_args_str += ', pir::Value ' + input_name + '_'\n    if mutable_attr_is_input:\n        if len(op_mutable_attribute_name_list) > 0:\n            for mutable_attr in op_mutable_attribute_name_list:\n                build_args_str += ', pir::Value ' + mutable_attr + '_'\n        if attr_args_is_map:\n            build_args_str += ', pir::AttributeMap attributes'\n        else:\n            for attr_idx in range(len(op_non_mutable_attribute_name_list)):\n                build_args_str += ', ' + op_non_mutable_attribute_build_arg_type_list[attr_idx] + ' ' + op_non_mutable_attribute_name_list[attr_idx]\n                if for_func_define:\n                    if op_non_mutable_attribute_default_value_list[attr_idx] is not None:\n                        default_value = op_non_mutable_attribute_default_value_list[attr_idx]\n                        if op_non_mutable_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                            if default_value[0] == \"'\" or default_value[0] == '\"':\n                                default_value = default_value[1:]\n                            if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                                default_value = default_value[0:-1]\n                        build_args_str += '=' + default_value\n    elif attr_args_is_map:\n        build_args_str += ', pir::AttributeMap attributes'\n    else:\n        for attr_idx in range(len(op_attribute_name_list)):\n            build_args_str += ', ' + op_attribute_build_arg_type_list[attr_idx] + ' ' + op_attribute_name_list[attr_idx]\n            if for_func_define:\n                if op_attribute_default_value_list[attr_idx] is not None:\n                    default_value = op_attribute_default_value_list[attr_idx]\n                    if op_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                        if default_value[0] == \"'\" or default_value[0] == '\"':\n                            default_value = default_value[1:]\n                        if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                            default_value = default_value[0:-1]\n                    build_args_str += '=' + default_value\n    return build_args_str",
            "def GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, for_func_define=True, mutable_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Example: pir::Builder &builder, pir::OperationArgument &argument, pir::Value x_, phi::DataType dtype=phi::DataType::UNDEFINED, phi::Place place={}\\n    '\n    build_args_str = 'pir::Builder &builder, pir::OperationArgument &argument'\n    if len(op_input_name_list) > 0:\n        for input_name in op_input_name_list:\n            build_args_str += ', pir::Value ' + input_name + '_'\n    if mutable_attr_is_input:\n        if len(op_mutable_attribute_name_list) > 0:\n            for mutable_attr in op_mutable_attribute_name_list:\n                build_args_str += ', pir::Value ' + mutable_attr + '_'\n        if attr_args_is_map:\n            build_args_str += ', pir::AttributeMap attributes'\n        else:\n            for attr_idx in range(len(op_non_mutable_attribute_name_list)):\n                build_args_str += ', ' + op_non_mutable_attribute_build_arg_type_list[attr_idx] + ' ' + op_non_mutable_attribute_name_list[attr_idx]\n                if for_func_define:\n                    if op_non_mutable_attribute_default_value_list[attr_idx] is not None:\n                        default_value = op_non_mutable_attribute_default_value_list[attr_idx]\n                        if op_non_mutable_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                            if default_value[0] == \"'\" or default_value[0] == '\"':\n                                default_value = default_value[1:]\n                            if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                                default_value = default_value[0:-1]\n                        build_args_str += '=' + default_value\n    elif attr_args_is_map:\n        build_args_str += ', pir::AttributeMap attributes'\n    else:\n        for attr_idx in range(len(op_attribute_name_list)):\n            build_args_str += ', ' + op_attribute_build_arg_type_list[attr_idx] + ' ' + op_attribute_name_list[attr_idx]\n            if for_func_define:\n                if op_attribute_default_value_list[attr_idx] is not None:\n                    default_value = op_attribute_default_value_list[attr_idx]\n                    if op_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                        if default_value[0] == \"'\" or default_value[0] == '\"':\n                            default_value = default_value[1:]\n                        if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                            default_value = default_value[0:-1]\n                    build_args_str += '=' + default_value\n    return build_args_str",
            "def GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, for_func_define=True, mutable_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Example: pir::Builder &builder, pir::OperationArgument &argument, pir::Value x_, phi::DataType dtype=phi::DataType::UNDEFINED, phi::Place place={}\\n    '\n    build_args_str = 'pir::Builder &builder, pir::OperationArgument &argument'\n    if len(op_input_name_list) > 0:\n        for input_name in op_input_name_list:\n            build_args_str += ', pir::Value ' + input_name + '_'\n    if mutable_attr_is_input:\n        if len(op_mutable_attribute_name_list) > 0:\n            for mutable_attr in op_mutable_attribute_name_list:\n                build_args_str += ', pir::Value ' + mutable_attr + '_'\n        if attr_args_is_map:\n            build_args_str += ', pir::AttributeMap attributes'\n        else:\n            for attr_idx in range(len(op_non_mutable_attribute_name_list)):\n                build_args_str += ', ' + op_non_mutable_attribute_build_arg_type_list[attr_idx] + ' ' + op_non_mutable_attribute_name_list[attr_idx]\n                if for_func_define:\n                    if op_non_mutable_attribute_default_value_list[attr_idx] is not None:\n                        default_value = op_non_mutable_attribute_default_value_list[attr_idx]\n                        if op_non_mutable_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                            if default_value[0] == \"'\" or default_value[0] == '\"':\n                                default_value = default_value[1:]\n                            if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                                default_value = default_value[0:-1]\n                        build_args_str += '=' + default_value\n    elif attr_args_is_map:\n        build_args_str += ', pir::AttributeMap attributes'\n    else:\n        for attr_idx in range(len(op_attribute_name_list)):\n            build_args_str += ', ' + op_attribute_build_arg_type_list[attr_idx] + ' ' + op_attribute_name_list[attr_idx]\n            if for_func_define:\n                if op_attribute_default_value_list[attr_idx] is not None:\n                    default_value = op_attribute_default_value_list[attr_idx]\n                    if op_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                        if default_value[0] == \"'\" or default_value[0] == '\"':\n                            default_value = default_value[1:]\n                        if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                            default_value = default_value[0:-1]\n                    build_args_str += '=' + default_value\n    return build_args_str",
            "def GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, for_func_define=True, mutable_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Example: pir::Builder &builder, pir::OperationArgument &argument, pir::Value x_, phi::DataType dtype=phi::DataType::UNDEFINED, phi::Place place={}\\n    '\n    build_args_str = 'pir::Builder &builder, pir::OperationArgument &argument'\n    if len(op_input_name_list) > 0:\n        for input_name in op_input_name_list:\n            build_args_str += ', pir::Value ' + input_name + '_'\n    if mutable_attr_is_input:\n        if len(op_mutable_attribute_name_list) > 0:\n            for mutable_attr in op_mutable_attribute_name_list:\n                build_args_str += ', pir::Value ' + mutable_attr + '_'\n        if attr_args_is_map:\n            build_args_str += ', pir::AttributeMap attributes'\n        else:\n            for attr_idx in range(len(op_non_mutable_attribute_name_list)):\n                build_args_str += ', ' + op_non_mutable_attribute_build_arg_type_list[attr_idx] + ' ' + op_non_mutable_attribute_name_list[attr_idx]\n                if for_func_define:\n                    if op_non_mutable_attribute_default_value_list[attr_idx] is not None:\n                        default_value = op_non_mutable_attribute_default_value_list[attr_idx]\n                        if op_non_mutable_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                            if default_value[0] == \"'\" or default_value[0] == '\"':\n                                default_value = default_value[1:]\n                            if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                                default_value = default_value[0:-1]\n                        build_args_str += '=' + default_value\n    elif attr_args_is_map:\n        build_args_str += ', pir::AttributeMap attributes'\n    else:\n        for attr_idx in range(len(op_attribute_name_list)):\n            build_args_str += ', ' + op_attribute_build_arg_type_list[attr_idx] + ' ' + op_attribute_name_list[attr_idx]\n            if for_func_define:\n                if op_attribute_default_value_list[attr_idx] is not None:\n                    default_value = op_attribute_default_value_list[attr_idx]\n                    if op_attribute_build_arg_type_list[attr_idx] != 'const std::string&':\n                        if default_value[0] == \"'\" or default_value[0] == '\"':\n                            default_value = default_value[1:]\n                        if default_value[-1] == \"'\" or default_value[-1] == '\"':\n                            default_value = default_value[0:-1]\n                    build_args_str += '=' + default_value\n    return build_args_str"
        ]
    },
    {
        "func_name": "GenBuildInserFullForMutableAttribute",
        "original": "def GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list):\n    build_mutable_attribute = ''\n    BUILD_INTARRAY_ATTRIBUTE_TEMPLATE = '  // Generate int_array mutable attribute: {attr_name}\\n  paddle::dialect::FullIntArrayOp full_{attr_name}_op = builder.Build<paddle::dialect::FullIntArrayOp>({attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    BUILD_SCALAR_ATTRIBUTE_TEMPLATE = '  // Generate scalar mutable attribute: {attr_name}\\n  paddle::dialect::FullOp full_{attr_name}_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{{1}}, {attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    for idx in range(len(op_mutable_attribute_name_list)):\n        attr_name = op_mutable_attribute_name_list[idx]\n        attr_type = op_mutable_attribute_type_list[idx][0]\n        if attr_name in op_attribute_name_list:\n            phi_dtype = mutable_attribute_phi_type_maps[op_attribute_build_arg_type_list[op_attribute_name_list.index(attr_name)]]\n        else:\n            phi_dtype = mutable_attribute_phi_type_maps[op_mutable_attribute_type_list[idx][1]]\n        if attr_type == 'paddle::dialect::IntArrayAttribute':\n            build_mutable_attribute += BUILD_INTARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n        else:\n            build_mutable_attribute += BUILD_SCALAR_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n    return build_mutable_attribute",
        "mutated": [
            "def GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list):\n    if False:\n        i = 10\n    build_mutable_attribute = ''\n    BUILD_INTARRAY_ATTRIBUTE_TEMPLATE = '  // Generate int_array mutable attribute: {attr_name}\\n  paddle::dialect::FullIntArrayOp full_{attr_name}_op = builder.Build<paddle::dialect::FullIntArrayOp>({attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    BUILD_SCALAR_ATTRIBUTE_TEMPLATE = '  // Generate scalar mutable attribute: {attr_name}\\n  paddle::dialect::FullOp full_{attr_name}_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{{1}}, {attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    for idx in range(len(op_mutable_attribute_name_list)):\n        attr_name = op_mutable_attribute_name_list[idx]\n        attr_type = op_mutable_attribute_type_list[idx][0]\n        if attr_name in op_attribute_name_list:\n            phi_dtype = mutable_attribute_phi_type_maps[op_attribute_build_arg_type_list[op_attribute_name_list.index(attr_name)]]\n        else:\n            phi_dtype = mutable_attribute_phi_type_maps[op_mutable_attribute_type_list[idx][1]]\n        if attr_type == 'paddle::dialect::IntArrayAttribute':\n            build_mutable_attribute += BUILD_INTARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n        else:\n            build_mutable_attribute += BUILD_SCALAR_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n    return build_mutable_attribute",
            "def GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    build_mutable_attribute = ''\n    BUILD_INTARRAY_ATTRIBUTE_TEMPLATE = '  // Generate int_array mutable attribute: {attr_name}\\n  paddle::dialect::FullIntArrayOp full_{attr_name}_op = builder.Build<paddle::dialect::FullIntArrayOp>({attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    BUILD_SCALAR_ATTRIBUTE_TEMPLATE = '  // Generate scalar mutable attribute: {attr_name}\\n  paddle::dialect::FullOp full_{attr_name}_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{{1}}, {attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    for idx in range(len(op_mutable_attribute_name_list)):\n        attr_name = op_mutable_attribute_name_list[idx]\n        attr_type = op_mutable_attribute_type_list[idx][0]\n        if attr_name in op_attribute_name_list:\n            phi_dtype = mutable_attribute_phi_type_maps[op_attribute_build_arg_type_list[op_attribute_name_list.index(attr_name)]]\n        else:\n            phi_dtype = mutable_attribute_phi_type_maps[op_mutable_attribute_type_list[idx][1]]\n        if attr_type == 'paddle::dialect::IntArrayAttribute':\n            build_mutable_attribute += BUILD_INTARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n        else:\n            build_mutable_attribute += BUILD_SCALAR_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n    return build_mutable_attribute",
            "def GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    build_mutable_attribute = ''\n    BUILD_INTARRAY_ATTRIBUTE_TEMPLATE = '  // Generate int_array mutable attribute: {attr_name}\\n  paddle::dialect::FullIntArrayOp full_{attr_name}_op = builder.Build<paddle::dialect::FullIntArrayOp>({attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    BUILD_SCALAR_ATTRIBUTE_TEMPLATE = '  // Generate scalar mutable attribute: {attr_name}\\n  paddle::dialect::FullOp full_{attr_name}_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{{1}}, {attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    for idx in range(len(op_mutable_attribute_name_list)):\n        attr_name = op_mutable_attribute_name_list[idx]\n        attr_type = op_mutable_attribute_type_list[idx][0]\n        if attr_name in op_attribute_name_list:\n            phi_dtype = mutable_attribute_phi_type_maps[op_attribute_build_arg_type_list[op_attribute_name_list.index(attr_name)]]\n        else:\n            phi_dtype = mutable_attribute_phi_type_maps[op_mutable_attribute_type_list[idx][1]]\n        if attr_type == 'paddle::dialect::IntArrayAttribute':\n            build_mutable_attribute += BUILD_INTARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n        else:\n            build_mutable_attribute += BUILD_SCALAR_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n    return build_mutable_attribute",
            "def GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    build_mutable_attribute = ''\n    BUILD_INTARRAY_ATTRIBUTE_TEMPLATE = '  // Generate int_array mutable attribute: {attr_name}\\n  paddle::dialect::FullIntArrayOp full_{attr_name}_op = builder.Build<paddle::dialect::FullIntArrayOp>({attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    BUILD_SCALAR_ATTRIBUTE_TEMPLATE = '  // Generate scalar mutable attribute: {attr_name}\\n  paddle::dialect::FullOp full_{attr_name}_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{{1}}, {attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    for idx in range(len(op_mutable_attribute_name_list)):\n        attr_name = op_mutable_attribute_name_list[idx]\n        attr_type = op_mutable_attribute_type_list[idx][0]\n        if attr_name in op_attribute_name_list:\n            phi_dtype = mutable_attribute_phi_type_maps[op_attribute_build_arg_type_list[op_attribute_name_list.index(attr_name)]]\n        else:\n            phi_dtype = mutable_attribute_phi_type_maps[op_mutable_attribute_type_list[idx][1]]\n        if attr_type == 'paddle::dialect::IntArrayAttribute':\n            build_mutable_attribute += BUILD_INTARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n        else:\n            build_mutable_attribute += BUILD_SCALAR_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n    return build_mutable_attribute",
            "def GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    build_mutable_attribute = ''\n    BUILD_INTARRAY_ATTRIBUTE_TEMPLATE = '  // Generate int_array mutable attribute: {attr_name}\\n  paddle::dialect::FullIntArrayOp full_{attr_name}_op = builder.Build<paddle::dialect::FullIntArrayOp>({attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    BUILD_SCALAR_ATTRIBUTE_TEMPLATE = '  // Generate scalar mutable attribute: {attr_name}\\n  paddle::dialect::FullOp full_{attr_name}_op = builder.Build<paddle::dialect::FullOp>(std::vector<int64_t>{{1}}, {attr_name}, {phi_dtype}, phi::CPUPlace());\\n  pir::OpResult {attr_name}_ = full_{attr_name}_op->result(0);\\n    '\n    for idx in range(len(op_mutable_attribute_name_list)):\n        attr_name = op_mutable_attribute_name_list[idx]\n        attr_type = op_mutable_attribute_type_list[idx][0]\n        if attr_name in op_attribute_name_list:\n            phi_dtype = mutable_attribute_phi_type_maps[op_attribute_build_arg_type_list[op_attribute_name_list.index(attr_name)]]\n        else:\n            phi_dtype = mutable_attribute_phi_type_maps[op_mutable_attribute_type_list[idx][1]]\n        if attr_type == 'paddle::dialect::IntArrayAttribute':\n            build_mutable_attribute += BUILD_INTARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n        else:\n            build_mutable_attribute += BUILD_SCALAR_ATTRIBUTE_TEMPLATE.format(attr_name=attr_name, phi_dtype=phi_dtype)\n    return build_mutable_attribute"
        ]
    },
    {
        "func_name": "GenBuildInputs",
        "original": "def GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list):\n    BUILD_INPUT_TEMPLATE = '  std::vector<pir::Value> argument_inputs = {{{inputs_args}}};\\n  argument.AddInputs(argument_inputs);\\n'\n    build_input_str = '  VLOG(4) << \"Builder construction inputs\";\\n'\n    input_name_list = op_input_name_list + op_mutable_attribute_name_list\n    if len(input_name_list) > 0:\n        inputs_args_str = ''\n        inputs_args_str += '_, '.join(input_name_list) + '_'\n        build_input_str += BUILD_INPUT_TEMPLATE.format(inputs_args=inputs_args_str)\n    return build_input_str",
        "mutated": [
            "def GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list):\n    if False:\n        i = 10\n    BUILD_INPUT_TEMPLATE = '  std::vector<pir::Value> argument_inputs = {{{inputs_args}}};\\n  argument.AddInputs(argument_inputs);\\n'\n    build_input_str = '  VLOG(4) << \"Builder construction inputs\";\\n'\n    input_name_list = op_input_name_list + op_mutable_attribute_name_list\n    if len(input_name_list) > 0:\n        inputs_args_str = ''\n        inputs_args_str += '_, '.join(input_name_list) + '_'\n        build_input_str += BUILD_INPUT_TEMPLATE.format(inputs_args=inputs_args_str)\n    return build_input_str",
            "def GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    BUILD_INPUT_TEMPLATE = '  std::vector<pir::Value> argument_inputs = {{{inputs_args}}};\\n  argument.AddInputs(argument_inputs);\\n'\n    build_input_str = '  VLOG(4) << \"Builder construction inputs\";\\n'\n    input_name_list = op_input_name_list + op_mutable_attribute_name_list\n    if len(input_name_list) > 0:\n        inputs_args_str = ''\n        inputs_args_str += '_, '.join(input_name_list) + '_'\n        build_input_str += BUILD_INPUT_TEMPLATE.format(inputs_args=inputs_args_str)\n    return build_input_str",
            "def GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    BUILD_INPUT_TEMPLATE = '  std::vector<pir::Value> argument_inputs = {{{inputs_args}}};\\n  argument.AddInputs(argument_inputs);\\n'\n    build_input_str = '  VLOG(4) << \"Builder construction inputs\";\\n'\n    input_name_list = op_input_name_list + op_mutable_attribute_name_list\n    if len(input_name_list) > 0:\n        inputs_args_str = ''\n        inputs_args_str += '_, '.join(input_name_list) + '_'\n        build_input_str += BUILD_INPUT_TEMPLATE.format(inputs_args=inputs_args_str)\n    return build_input_str",
            "def GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    BUILD_INPUT_TEMPLATE = '  std::vector<pir::Value> argument_inputs = {{{inputs_args}}};\\n  argument.AddInputs(argument_inputs);\\n'\n    build_input_str = '  VLOG(4) << \"Builder construction inputs\";\\n'\n    input_name_list = op_input_name_list + op_mutable_attribute_name_list\n    if len(input_name_list) > 0:\n        inputs_args_str = ''\n        inputs_args_str += '_, '.join(input_name_list) + '_'\n        build_input_str += BUILD_INPUT_TEMPLATE.format(inputs_args=inputs_args_str)\n    return build_input_str",
            "def GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    BUILD_INPUT_TEMPLATE = '  std::vector<pir::Value> argument_inputs = {{{inputs_args}}};\\n  argument.AddInputs(argument_inputs);\\n'\n    build_input_str = '  VLOG(4) << \"Builder construction inputs\";\\n'\n    input_name_list = op_input_name_list + op_mutable_attribute_name_list\n    if len(input_name_list) > 0:\n        inputs_args_str = ''\n        inputs_args_str += '_, '.join(input_name_list) + '_'\n        build_input_str += BUILD_INPUT_TEMPLATE.format(inputs_args=inputs_args_str)\n    return build_input_str"
        ]
    },
    {
        "func_name": "GenBuildAttributes",
        "original": "def GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list):\n    INTARRAY_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), phi::IntArray({attr}));\\n'\n    SCALAR_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = paddle::dialect::TransToIrAttribute({attr}, pir::IrContext::Instance());\\n'\n    STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), {attr});\\n'\n    ARRAY_ATTRIBUTE_TEMPLATE = '  std::vector<pir::Attribute> vec_{attr_name};\\n  for (size_t i = 0; i < static_cast<size_t>({attr_size}); i++) {{\\n    {create_attribute}\\n    vec_{attr_name}.push_back(attr_{attr_name});\\n  }}\\n  pir::Attribute attr_{attr_name} = pir::ArrayAttribute::get(pir::IrContext::Instance(), vec_{attr_name});\\n'\n    attr_str = '  VLOG(4) << \"Builder construction attributes\";\\n'\n    array_attr_type = 'pir::ArrayAttribute<'\n    for idx in range(len(op_non_mutable_attribute_name_list)):\n        if array_attr_type in op_non_mutable_attribute_type_list[idx]:\n            inner_attribute_type = op_non_mutable_attribute_type_list[idx][len(array_attr_type):-1]\n            if inner_attribute_type == 'paddle::dialect::IntArrayAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            elif inner_attribute_type == 'paddle::dialect::ScalarAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            else:\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::IntArrayAttribute':\n            attr_str += INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::ScalarAttribute':\n            attr_str += SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        else:\n            attr_str += STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        attr_str += '  argument.AddAttribute(\"{attr_name}\", attr_{attr_name});\\n'.format(attr_name=op_non_mutable_attribute_name_list[idx])\n    return attr_str",
        "mutated": [
            "def GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list):\n    if False:\n        i = 10\n    INTARRAY_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), phi::IntArray({attr}));\\n'\n    SCALAR_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = paddle::dialect::TransToIrAttribute({attr}, pir::IrContext::Instance());\\n'\n    STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), {attr});\\n'\n    ARRAY_ATTRIBUTE_TEMPLATE = '  std::vector<pir::Attribute> vec_{attr_name};\\n  for (size_t i = 0; i < static_cast<size_t>({attr_size}); i++) {{\\n    {create_attribute}\\n    vec_{attr_name}.push_back(attr_{attr_name});\\n  }}\\n  pir::Attribute attr_{attr_name} = pir::ArrayAttribute::get(pir::IrContext::Instance(), vec_{attr_name});\\n'\n    attr_str = '  VLOG(4) << \"Builder construction attributes\";\\n'\n    array_attr_type = 'pir::ArrayAttribute<'\n    for idx in range(len(op_non_mutable_attribute_name_list)):\n        if array_attr_type in op_non_mutable_attribute_type_list[idx]:\n            inner_attribute_type = op_non_mutable_attribute_type_list[idx][len(array_attr_type):-1]\n            if inner_attribute_type == 'paddle::dialect::IntArrayAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            elif inner_attribute_type == 'paddle::dialect::ScalarAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            else:\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::IntArrayAttribute':\n            attr_str += INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::ScalarAttribute':\n            attr_str += SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        else:\n            attr_str += STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        attr_str += '  argument.AddAttribute(\"{attr_name}\", attr_{attr_name});\\n'.format(attr_name=op_non_mutable_attribute_name_list[idx])\n    return attr_str",
            "def GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    INTARRAY_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), phi::IntArray({attr}));\\n'\n    SCALAR_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = paddle::dialect::TransToIrAttribute({attr}, pir::IrContext::Instance());\\n'\n    STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), {attr});\\n'\n    ARRAY_ATTRIBUTE_TEMPLATE = '  std::vector<pir::Attribute> vec_{attr_name};\\n  for (size_t i = 0; i < static_cast<size_t>({attr_size}); i++) {{\\n    {create_attribute}\\n    vec_{attr_name}.push_back(attr_{attr_name});\\n  }}\\n  pir::Attribute attr_{attr_name} = pir::ArrayAttribute::get(pir::IrContext::Instance(), vec_{attr_name});\\n'\n    attr_str = '  VLOG(4) << \"Builder construction attributes\";\\n'\n    array_attr_type = 'pir::ArrayAttribute<'\n    for idx in range(len(op_non_mutable_attribute_name_list)):\n        if array_attr_type in op_non_mutable_attribute_type_list[idx]:\n            inner_attribute_type = op_non_mutable_attribute_type_list[idx][len(array_attr_type):-1]\n            if inner_attribute_type == 'paddle::dialect::IntArrayAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            elif inner_attribute_type == 'paddle::dialect::ScalarAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            else:\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::IntArrayAttribute':\n            attr_str += INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::ScalarAttribute':\n            attr_str += SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        else:\n            attr_str += STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        attr_str += '  argument.AddAttribute(\"{attr_name}\", attr_{attr_name});\\n'.format(attr_name=op_non_mutable_attribute_name_list[idx])\n    return attr_str",
            "def GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    INTARRAY_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), phi::IntArray({attr}));\\n'\n    SCALAR_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = paddle::dialect::TransToIrAttribute({attr}, pir::IrContext::Instance());\\n'\n    STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), {attr});\\n'\n    ARRAY_ATTRIBUTE_TEMPLATE = '  std::vector<pir::Attribute> vec_{attr_name};\\n  for (size_t i = 0; i < static_cast<size_t>({attr_size}); i++) {{\\n    {create_attribute}\\n    vec_{attr_name}.push_back(attr_{attr_name});\\n  }}\\n  pir::Attribute attr_{attr_name} = pir::ArrayAttribute::get(pir::IrContext::Instance(), vec_{attr_name});\\n'\n    attr_str = '  VLOG(4) << \"Builder construction attributes\";\\n'\n    array_attr_type = 'pir::ArrayAttribute<'\n    for idx in range(len(op_non_mutable_attribute_name_list)):\n        if array_attr_type in op_non_mutable_attribute_type_list[idx]:\n            inner_attribute_type = op_non_mutable_attribute_type_list[idx][len(array_attr_type):-1]\n            if inner_attribute_type == 'paddle::dialect::IntArrayAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            elif inner_attribute_type == 'paddle::dialect::ScalarAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            else:\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::IntArrayAttribute':\n            attr_str += INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::ScalarAttribute':\n            attr_str += SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        else:\n            attr_str += STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        attr_str += '  argument.AddAttribute(\"{attr_name}\", attr_{attr_name});\\n'.format(attr_name=op_non_mutable_attribute_name_list[idx])\n    return attr_str",
            "def GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    INTARRAY_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), phi::IntArray({attr}));\\n'\n    SCALAR_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = paddle::dialect::TransToIrAttribute({attr}, pir::IrContext::Instance());\\n'\n    STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), {attr});\\n'\n    ARRAY_ATTRIBUTE_TEMPLATE = '  std::vector<pir::Attribute> vec_{attr_name};\\n  for (size_t i = 0; i < static_cast<size_t>({attr_size}); i++) {{\\n    {create_attribute}\\n    vec_{attr_name}.push_back(attr_{attr_name});\\n  }}\\n  pir::Attribute attr_{attr_name} = pir::ArrayAttribute::get(pir::IrContext::Instance(), vec_{attr_name});\\n'\n    attr_str = '  VLOG(4) << \"Builder construction attributes\";\\n'\n    array_attr_type = 'pir::ArrayAttribute<'\n    for idx in range(len(op_non_mutable_attribute_name_list)):\n        if array_attr_type in op_non_mutable_attribute_type_list[idx]:\n            inner_attribute_type = op_non_mutable_attribute_type_list[idx][len(array_attr_type):-1]\n            if inner_attribute_type == 'paddle::dialect::IntArrayAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            elif inner_attribute_type == 'paddle::dialect::ScalarAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            else:\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::IntArrayAttribute':\n            attr_str += INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::ScalarAttribute':\n            attr_str += SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        else:\n            attr_str += STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        attr_str += '  argument.AddAttribute(\"{attr_name}\", attr_{attr_name});\\n'.format(attr_name=op_non_mutable_attribute_name_list[idx])\n    return attr_str",
            "def GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    INTARRAY_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), phi::IntArray({attr}));\\n'\n    SCALAR_STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = paddle::dialect::TransToIrAttribute({attr}, pir::IrContext::Instance());\\n'\n    STR_TEMPLATE = '  pir::Attribute attr_{attr_name} = {op_attribute_type}::get(pir::IrContext::Instance(), {attr});\\n'\n    ARRAY_ATTRIBUTE_TEMPLATE = '  std::vector<pir::Attribute> vec_{attr_name};\\n  for (size_t i = 0; i < static_cast<size_t>({attr_size}); i++) {{\\n    {create_attribute}\\n    vec_{attr_name}.push_back(attr_{attr_name});\\n  }}\\n  pir::Attribute attr_{attr_name} = pir::ArrayAttribute::get(pir::IrContext::Instance(), vec_{attr_name});\\n'\n    attr_str = '  VLOG(4) << \"Builder construction attributes\";\\n'\n    array_attr_type = 'pir::ArrayAttribute<'\n    for idx in range(len(op_non_mutable_attribute_name_list)):\n        if array_attr_type in op_non_mutable_attribute_type_list[idx]:\n            inner_attribute_type = op_non_mutable_attribute_type_list[idx][len(array_attr_type):-1]\n            if inner_attribute_type == 'paddle::dialect::IntArrayAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            elif inner_attribute_type == 'paddle::dialect::ScalarAttribute':\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n            else:\n                attr_str += ARRAY_ATTRIBUTE_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr_size=op_non_mutable_attribute_name_list[idx] + '.size()', create_attribute=STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=inner_attribute_type, attr=op_non_mutable_attribute_name_list[idx] + '[i]'))\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::IntArrayAttribute':\n            attr_str += INTARRAY_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        elif op_non_mutable_attribute_type_list[idx] == 'paddle::dialect::ScalarAttribute':\n            attr_str += SCALAR_STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        else:\n            attr_str += STR_TEMPLATE.format(attr_name=op_non_mutable_attribute_name_list[idx], op_attribute_type=op_non_mutable_attribute_type_list[idx], attr=op_non_mutable_attribute_name_list[idx])\n        attr_str += '  argument.AddAttribute(\"{attr_name}\", attr_{attr_name});\\n'.format(attr_name=op_non_mutable_attribute_name_list[idx])\n    return attr_str"
        ]
    },
    {
        "func_name": "GenBuildOutputs",
        "original": "def GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, mutable_attr_is_input=False):\n    build_output_str = '  VLOG(4) << \"Builder construction outputs\";\\n'\n    CREATE_INPUT_METATENSOR_TEMPLATE = '\\n  VLOG(4) << \"Builder construction  dense_{name}\";\\n  paddle::dialect::IrTensor ir_tensor_{name}(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                      {name}.dims(),\\n                                                      {name}.data_layout(),\\n                                                      {name}.lod(),\\n                                                      {name}.offset());\\n  VLOG(4) << \"Builder construction  meta_{name}\";\\n  paddle::dialect::IrMetaTensor meta_{name}(&ir_tensor_{name});\\n'\n    CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE = '\\n  paddle::dialect::IrMetaTensor meta_{name};\\n  paddle::dialect::IrTensor ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>();\\n    VLOG(4) << \"Builder construction  dense_{name}\";\\n    ir_tensor_{name} = paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                        {name}.dims(),\\n                                                        {name}.data_layout(),\\n                                                        {name}.lod(),\\n                                                        {name}.offset());\\n    VLOG(4) << \"Builder construction  meta_{name}\";\\n    meta_{name} = paddle::dialect::IrMetaTensor(&ir_tensor_{name});\\n  }}\\n\\n'\n    CREATE_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n    vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n  }}\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n '\n    CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>();\\n    for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n        vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n    }}\\n  }}\\n\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n\\n'\n    CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::IntArray {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = std::move(phi::IntArray(paddle::dialect::GetInt64Vector(\\n                          {name}_.dyn_cast<pir::OpResult>().owner()\\n                          ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                          .attribute(\"value\"))));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  std::vector<int64_t> {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = paddle::dialect::GetInt64Vector(\\n                    {name}_.dyn_cast<pir::OpResult>().owner()\\n                    ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                    .attribute(\"value\"));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::Scalar {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {{\\n    {name} = std::move(phi::Scalar({name}_.dyn_cast<pir::OpResult>().owner()\\n                                  ->dyn_cast<paddle::dialect::FullOp>()\\n                                  .attribute(\"value\")\\n                                  .dyn_cast<paddle::dialect::ScalarAttribute>()\\n                                  .data()\\n                                  .to<int>()));\\n  }}\\n  else {{\\n    {name} = std::move(phi::Scalar(-1));\\n    {name}.SetFromTensor(true);\\n  }}\\n'\n    CREATE_OUTPUT_METATENSOR_TEMPLATE = '  paddle::dialect::IrTensor dense_{name};\\n  paddle::dialect::IrMetaTensor meta_{name}(&dense_{name});\\n'\n    CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_dense_{name}(({output_size}), paddle::dialect::IrTensor());\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_dense_{name}[i]));\\n  }}\\n  std::vector<phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n'\n    for idx in range(len(op_input_name_list)):\n        if 'pir::VectorType' in op_input_type_list[idx]:\n            if op_input_optional_list[idx] == 'false':\n                build_output_str += '  pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n        elif op_input_optional_list[idx] == 'false':\n            build_output_str += '  paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n    if mutable_attr_is_input:\n        for idx in range(len(op_mutable_attribute_name_list)):\n            attr_dtype = op_mutable_attribute_type_list[idx]\n            if attr_dtype[0] == 'paddle::dialect::IntArrayAttribute':\n                if op_class_name in _PREPARE_DATA_WITH_VECTOR_INT64_MTTABLE_ATTRIBUTE:\n                    build_output_str += CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n                else:\n                    build_output_str += CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n            elif attr_dtype[0] == 'paddle::dialect::ScalarAttribute':\n                build_output_str += CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx], dtype=attr_dtype[1])\n            elif attr_dtype[0] == 'pir::StrAttribute':\n                build_output_str += ''\n            else:\n                assert 'mutable attribtue type is not right.'\n        build_output_str += '\\n'\n    infer_meta_args = []\n    for idx in range(len(op_infer_meta_map['param'])):\n        if op_infer_meta_map['param'][idx] in op_input_name_list:\n            if 'meta_' + op_infer_meta_map['param'][idx] not in infer_meta_args:\n                if 'pir::VectorType' in op_input_type_list[op_input_name_list.index(op_infer_meta_map['param'][idx])]:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                else:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n            infer_meta_args.append('meta_' + op_infer_meta_map['param'][idx])\n        else:\n            infer_meta_args.append(op_infer_meta_map['param'][idx])\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n            infer_meta_args.append(f'meta_{op_output_name_list[idx]}')\n        else:\n            build_output_str += CREATE_OUTPUT_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx])\n            infer_meta_args.append(f'&meta_{op_output_name_list[idx]}')\n    CREATE_INFER_META_FUNC_TEMPLATE = '\\n  phi::{func}({args});\\n'\n    CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE = '\\n  phi::{func}({args}, phi::MetaConfig(false, false));\\n'\n    if op_infer_meta_map['func'] in _INFERMETA_NEED_META_CONFIG:\n        build_output_str += CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    else:\n        build_output_str += CREATE_INFER_META_FUNC_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    build_output_str += '\\n  std::vector<pir::Type> argument_outputs;'\n    CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE = '\\n  pir::Type {name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{name}.dtype()), dense_{name}.dims(), dense_{name}.layout(), dense_{name}.lod(), dense_{name}.offset());\\n  argument_outputs.push_back({name}_dense_tensor_type);\\n'\n    CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE = '\\n  if ({input_name}_.impl() != nullptr) {{\\n    pir::Type {output_name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{output_name}.dtype()), dense_{output_name}.dims(), dense_{output_name}.layout(), dense_{output_name}.lod(), dense_{output_name}.offset());\\n    argument_outputs.push_back({output_name}_dense_tensor_type);\\n  }} else {{\\n    pir::Type {output_name}_type;\\n    argument_outputs.push_back({output_name}_type);\\n  }}\\n\\n'\n    CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE = '\\n  std::vector<pir::Type> {name}_types;\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    {name}_types.push_back(paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(vec_dense_{name}[i].dtype()), vec_dense_{name}[i].dims(), vec_dense_{name}[i].layout(), vec_dense_{name}[i].lod(), vec_dense_{name}[i].offset()));\\n  }}\\n  pir::Type {name}_vector_type = pir::VectorType::get(pir::IrContext::Instance(), {name}_types);\\n  argument_outputs.push_back({name}_vector_type);\\n'\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n        else:\n            output_name = op_output_name_list[idx]\n            has_input_inplace = op_inplace_map is not None and output_name in op_inplace_map.keys()\n            if op_output_optional_list[idx] == 'true' and has_input_inplace:\n                build_output_str += CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE.format(input_name=op_inplace_map[output_name], output_name=output_name)\n            else:\n                build_output_str += CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE.format(name=output_name)\n    build_output_str += '  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());\\n'\n    build_output_str += '  ::pir::PassStopGradientsDefaultly(argument);\\n'\n    return build_output_str",
        "mutated": [
            "def GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, mutable_attr_is_input=False):\n    if False:\n        i = 10\n    build_output_str = '  VLOG(4) << \"Builder construction outputs\";\\n'\n    CREATE_INPUT_METATENSOR_TEMPLATE = '\\n  VLOG(4) << \"Builder construction  dense_{name}\";\\n  paddle::dialect::IrTensor ir_tensor_{name}(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                      {name}.dims(),\\n                                                      {name}.data_layout(),\\n                                                      {name}.lod(),\\n                                                      {name}.offset());\\n  VLOG(4) << \"Builder construction  meta_{name}\";\\n  paddle::dialect::IrMetaTensor meta_{name}(&ir_tensor_{name});\\n'\n    CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE = '\\n  paddle::dialect::IrMetaTensor meta_{name};\\n  paddle::dialect::IrTensor ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>();\\n    VLOG(4) << \"Builder construction  dense_{name}\";\\n    ir_tensor_{name} = paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                        {name}.dims(),\\n                                                        {name}.data_layout(),\\n                                                        {name}.lod(),\\n                                                        {name}.offset());\\n    VLOG(4) << \"Builder construction  meta_{name}\";\\n    meta_{name} = paddle::dialect::IrMetaTensor(&ir_tensor_{name});\\n  }}\\n\\n'\n    CREATE_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n    vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n  }}\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n '\n    CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>();\\n    for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n        vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n    }}\\n  }}\\n\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n\\n'\n    CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::IntArray {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = std::move(phi::IntArray(paddle::dialect::GetInt64Vector(\\n                          {name}_.dyn_cast<pir::OpResult>().owner()\\n                          ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                          .attribute(\"value\"))));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  std::vector<int64_t> {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = paddle::dialect::GetInt64Vector(\\n                    {name}_.dyn_cast<pir::OpResult>().owner()\\n                    ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                    .attribute(\"value\"));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::Scalar {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {{\\n    {name} = std::move(phi::Scalar({name}_.dyn_cast<pir::OpResult>().owner()\\n                                  ->dyn_cast<paddle::dialect::FullOp>()\\n                                  .attribute(\"value\")\\n                                  .dyn_cast<paddle::dialect::ScalarAttribute>()\\n                                  .data()\\n                                  .to<int>()));\\n  }}\\n  else {{\\n    {name} = std::move(phi::Scalar(-1));\\n    {name}.SetFromTensor(true);\\n  }}\\n'\n    CREATE_OUTPUT_METATENSOR_TEMPLATE = '  paddle::dialect::IrTensor dense_{name};\\n  paddle::dialect::IrMetaTensor meta_{name}(&dense_{name});\\n'\n    CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_dense_{name}(({output_size}), paddle::dialect::IrTensor());\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_dense_{name}[i]));\\n  }}\\n  std::vector<phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n'\n    for idx in range(len(op_input_name_list)):\n        if 'pir::VectorType' in op_input_type_list[idx]:\n            if op_input_optional_list[idx] == 'false':\n                build_output_str += '  pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n        elif op_input_optional_list[idx] == 'false':\n            build_output_str += '  paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n    if mutable_attr_is_input:\n        for idx in range(len(op_mutable_attribute_name_list)):\n            attr_dtype = op_mutable_attribute_type_list[idx]\n            if attr_dtype[0] == 'paddle::dialect::IntArrayAttribute':\n                if op_class_name in _PREPARE_DATA_WITH_VECTOR_INT64_MTTABLE_ATTRIBUTE:\n                    build_output_str += CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n                else:\n                    build_output_str += CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n            elif attr_dtype[0] == 'paddle::dialect::ScalarAttribute':\n                build_output_str += CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx], dtype=attr_dtype[1])\n            elif attr_dtype[0] == 'pir::StrAttribute':\n                build_output_str += ''\n            else:\n                assert 'mutable attribtue type is not right.'\n        build_output_str += '\\n'\n    infer_meta_args = []\n    for idx in range(len(op_infer_meta_map['param'])):\n        if op_infer_meta_map['param'][idx] in op_input_name_list:\n            if 'meta_' + op_infer_meta_map['param'][idx] not in infer_meta_args:\n                if 'pir::VectorType' in op_input_type_list[op_input_name_list.index(op_infer_meta_map['param'][idx])]:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                else:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n            infer_meta_args.append('meta_' + op_infer_meta_map['param'][idx])\n        else:\n            infer_meta_args.append(op_infer_meta_map['param'][idx])\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n            infer_meta_args.append(f'meta_{op_output_name_list[idx]}')\n        else:\n            build_output_str += CREATE_OUTPUT_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx])\n            infer_meta_args.append(f'&meta_{op_output_name_list[idx]}')\n    CREATE_INFER_META_FUNC_TEMPLATE = '\\n  phi::{func}({args});\\n'\n    CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE = '\\n  phi::{func}({args}, phi::MetaConfig(false, false));\\n'\n    if op_infer_meta_map['func'] in _INFERMETA_NEED_META_CONFIG:\n        build_output_str += CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    else:\n        build_output_str += CREATE_INFER_META_FUNC_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    build_output_str += '\\n  std::vector<pir::Type> argument_outputs;'\n    CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE = '\\n  pir::Type {name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{name}.dtype()), dense_{name}.dims(), dense_{name}.layout(), dense_{name}.lod(), dense_{name}.offset());\\n  argument_outputs.push_back({name}_dense_tensor_type);\\n'\n    CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE = '\\n  if ({input_name}_.impl() != nullptr) {{\\n    pir::Type {output_name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{output_name}.dtype()), dense_{output_name}.dims(), dense_{output_name}.layout(), dense_{output_name}.lod(), dense_{output_name}.offset());\\n    argument_outputs.push_back({output_name}_dense_tensor_type);\\n  }} else {{\\n    pir::Type {output_name}_type;\\n    argument_outputs.push_back({output_name}_type);\\n  }}\\n\\n'\n    CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE = '\\n  std::vector<pir::Type> {name}_types;\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    {name}_types.push_back(paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(vec_dense_{name}[i].dtype()), vec_dense_{name}[i].dims(), vec_dense_{name}[i].layout(), vec_dense_{name}[i].lod(), vec_dense_{name}[i].offset()));\\n  }}\\n  pir::Type {name}_vector_type = pir::VectorType::get(pir::IrContext::Instance(), {name}_types);\\n  argument_outputs.push_back({name}_vector_type);\\n'\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n        else:\n            output_name = op_output_name_list[idx]\n            has_input_inplace = op_inplace_map is not None and output_name in op_inplace_map.keys()\n            if op_output_optional_list[idx] == 'true' and has_input_inplace:\n                build_output_str += CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE.format(input_name=op_inplace_map[output_name], output_name=output_name)\n            else:\n                build_output_str += CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE.format(name=output_name)\n    build_output_str += '  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());\\n'\n    build_output_str += '  ::pir::PassStopGradientsDefaultly(argument);\\n'\n    return build_output_str",
            "def GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, mutable_attr_is_input=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    build_output_str = '  VLOG(4) << \"Builder construction outputs\";\\n'\n    CREATE_INPUT_METATENSOR_TEMPLATE = '\\n  VLOG(4) << \"Builder construction  dense_{name}\";\\n  paddle::dialect::IrTensor ir_tensor_{name}(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                      {name}.dims(),\\n                                                      {name}.data_layout(),\\n                                                      {name}.lod(),\\n                                                      {name}.offset());\\n  VLOG(4) << \"Builder construction  meta_{name}\";\\n  paddle::dialect::IrMetaTensor meta_{name}(&ir_tensor_{name});\\n'\n    CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE = '\\n  paddle::dialect::IrMetaTensor meta_{name};\\n  paddle::dialect::IrTensor ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>();\\n    VLOG(4) << \"Builder construction  dense_{name}\";\\n    ir_tensor_{name} = paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                        {name}.dims(),\\n                                                        {name}.data_layout(),\\n                                                        {name}.lod(),\\n                                                        {name}.offset());\\n    VLOG(4) << \"Builder construction  meta_{name}\";\\n    meta_{name} = paddle::dialect::IrMetaTensor(&ir_tensor_{name});\\n  }}\\n\\n'\n    CREATE_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n    vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n  }}\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n '\n    CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>();\\n    for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n        vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n    }}\\n  }}\\n\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n\\n'\n    CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::IntArray {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = std::move(phi::IntArray(paddle::dialect::GetInt64Vector(\\n                          {name}_.dyn_cast<pir::OpResult>().owner()\\n                          ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                          .attribute(\"value\"))));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  std::vector<int64_t> {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = paddle::dialect::GetInt64Vector(\\n                    {name}_.dyn_cast<pir::OpResult>().owner()\\n                    ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                    .attribute(\"value\"));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::Scalar {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {{\\n    {name} = std::move(phi::Scalar({name}_.dyn_cast<pir::OpResult>().owner()\\n                                  ->dyn_cast<paddle::dialect::FullOp>()\\n                                  .attribute(\"value\")\\n                                  .dyn_cast<paddle::dialect::ScalarAttribute>()\\n                                  .data()\\n                                  .to<int>()));\\n  }}\\n  else {{\\n    {name} = std::move(phi::Scalar(-1));\\n    {name}.SetFromTensor(true);\\n  }}\\n'\n    CREATE_OUTPUT_METATENSOR_TEMPLATE = '  paddle::dialect::IrTensor dense_{name};\\n  paddle::dialect::IrMetaTensor meta_{name}(&dense_{name});\\n'\n    CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_dense_{name}(({output_size}), paddle::dialect::IrTensor());\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_dense_{name}[i]));\\n  }}\\n  std::vector<phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n'\n    for idx in range(len(op_input_name_list)):\n        if 'pir::VectorType' in op_input_type_list[idx]:\n            if op_input_optional_list[idx] == 'false':\n                build_output_str += '  pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n        elif op_input_optional_list[idx] == 'false':\n            build_output_str += '  paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n    if mutable_attr_is_input:\n        for idx in range(len(op_mutable_attribute_name_list)):\n            attr_dtype = op_mutable_attribute_type_list[idx]\n            if attr_dtype[0] == 'paddle::dialect::IntArrayAttribute':\n                if op_class_name in _PREPARE_DATA_WITH_VECTOR_INT64_MTTABLE_ATTRIBUTE:\n                    build_output_str += CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n                else:\n                    build_output_str += CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n            elif attr_dtype[0] == 'paddle::dialect::ScalarAttribute':\n                build_output_str += CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx], dtype=attr_dtype[1])\n            elif attr_dtype[0] == 'pir::StrAttribute':\n                build_output_str += ''\n            else:\n                assert 'mutable attribtue type is not right.'\n        build_output_str += '\\n'\n    infer_meta_args = []\n    for idx in range(len(op_infer_meta_map['param'])):\n        if op_infer_meta_map['param'][idx] in op_input_name_list:\n            if 'meta_' + op_infer_meta_map['param'][idx] not in infer_meta_args:\n                if 'pir::VectorType' in op_input_type_list[op_input_name_list.index(op_infer_meta_map['param'][idx])]:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                else:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n            infer_meta_args.append('meta_' + op_infer_meta_map['param'][idx])\n        else:\n            infer_meta_args.append(op_infer_meta_map['param'][idx])\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n            infer_meta_args.append(f'meta_{op_output_name_list[idx]}')\n        else:\n            build_output_str += CREATE_OUTPUT_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx])\n            infer_meta_args.append(f'&meta_{op_output_name_list[idx]}')\n    CREATE_INFER_META_FUNC_TEMPLATE = '\\n  phi::{func}({args});\\n'\n    CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE = '\\n  phi::{func}({args}, phi::MetaConfig(false, false));\\n'\n    if op_infer_meta_map['func'] in _INFERMETA_NEED_META_CONFIG:\n        build_output_str += CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    else:\n        build_output_str += CREATE_INFER_META_FUNC_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    build_output_str += '\\n  std::vector<pir::Type> argument_outputs;'\n    CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE = '\\n  pir::Type {name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{name}.dtype()), dense_{name}.dims(), dense_{name}.layout(), dense_{name}.lod(), dense_{name}.offset());\\n  argument_outputs.push_back({name}_dense_tensor_type);\\n'\n    CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE = '\\n  if ({input_name}_.impl() != nullptr) {{\\n    pir::Type {output_name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{output_name}.dtype()), dense_{output_name}.dims(), dense_{output_name}.layout(), dense_{output_name}.lod(), dense_{output_name}.offset());\\n    argument_outputs.push_back({output_name}_dense_tensor_type);\\n  }} else {{\\n    pir::Type {output_name}_type;\\n    argument_outputs.push_back({output_name}_type);\\n  }}\\n\\n'\n    CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE = '\\n  std::vector<pir::Type> {name}_types;\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    {name}_types.push_back(paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(vec_dense_{name}[i].dtype()), vec_dense_{name}[i].dims(), vec_dense_{name}[i].layout(), vec_dense_{name}[i].lod(), vec_dense_{name}[i].offset()));\\n  }}\\n  pir::Type {name}_vector_type = pir::VectorType::get(pir::IrContext::Instance(), {name}_types);\\n  argument_outputs.push_back({name}_vector_type);\\n'\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n        else:\n            output_name = op_output_name_list[idx]\n            has_input_inplace = op_inplace_map is not None and output_name in op_inplace_map.keys()\n            if op_output_optional_list[idx] == 'true' and has_input_inplace:\n                build_output_str += CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE.format(input_name=op_inplace_map[output_name], output_name=output_name)\n            else:\n                build_output_str += CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE.format(name=output_name)\n    build_output_str += '  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());\\n'\n    build_output_str += '  ::pir::PassStopGradientsDefaultly(argument);\\n'\n    return build_output_str",
            "def GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, mutable_attr_is_input=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    build_output_str = '  VLOG(4) << \"Builder construction outputs\";\\n'\n    CREATE_INPUT_METATENSOR_TEMPLATE = '\\n  VLOG(4) << \"Builder construction  dense_{name}\";\\n  paddle::dialect::IrTensor ir_tensor_{name}(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                      {name}.dims(),\\n                                                      {name}.data_layout(),\\n                                                      {name}.lod(),\\n                                                      {name}.offset());\\n  VLOG(4) << \"Builder construction  meta_{name}\";\\n  paddle::dialect::IrMetaTensor meta_{name}(&ir_tensor_{name});\\n'\n    CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE = '\\n  paddle::dialect::IrMetaTensor meta_{name};\\n  paddle::dialect::IrTensor ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>();\\n    VLOG(4) << \"Builder construction  dense_{name}\";\\n    ir_tensor_{name} = paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                        {name}.dims(),\\n                                                        {name}.data_layout(),\\n                                                        {name}.lod(),\\n                                                        {name}.offset());\\n    VLOG(4) << \"Builder construction  meta_{name}\";\\n    meta_{name} = paddle::dialect::IrMetaTensor(&ir_tensor_{name});\\n  }}\\n\\n'\n    CREATE_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n    vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n  }}\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n '\n    CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>();\\n    for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n        vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n    }}\\n  }}\\n\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n\\n'\n    CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::IntArray {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = std::move(phi::IntArray(paddle::dialect::GetInt64Vector(\\n                          {name}_.dyn_cast<pir::OpResult>().owner()\\n                          ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                          .attribute(\"value\"))));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  std::vector<int64_t> {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = paddle::dialect::GetInt64Vector(\\n                    {name}_.dyn_cast<pir::OpResult>().owner()\\n                    ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                    .attribute(\"value\"));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::Scalar {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {{\\n    {name} = std::move(phi::Scalar({name}_.dyn_cast<pir::OpResult>().owner()\\n                                  ->dyn_cast<paddle::dialect::FullOp>()\\n                                  .attribute(\"value\")\\n                                  .dyn_cast<paddle::dialect::ScalarAttribute>()\\n                                  .data()\\n                                  .to<int>()));\\n  }}\\n  else {{\\n    {name} = std::move(phi::Scalar(-1));\\n    {name}.SetFromTensor(true);\\n  }}\\n'\n    CREATE_OUTPUT_METATENSOR_TEMPLATE = '  paddle::dialect::IrTensor dense_{name};\\n  paddle::dialect::IrMetaTensor meta_{name}(&dense_{name});\\n'\n    CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_dense_{name}(({output_size}), paddle::dialect::IrTensor());\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_dense_{name}[i]));\\n  }}\\n  std::vector<phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n'\n    for idx in range(len(op_input_name_list)):\n        if 'pir::VectorType' in op_input_type_list[idx]:\n            if op_input_optional_list[idx] == 'false':\n                build_output_str += '  pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n        elif op_input_optional_list[idx] == 'false':\n            build_output_str += '  paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n    if mutable_attr_is_input:\n        for idx in range(len(op_mutable_attribute_name_list)):\n            attr_dtype = op_mutable_attribute_type_list[idx]\n            if attr_dtype[0] == 'paddle::dialect::IntArrayAttribute':\n                if op_class_name in _PREPARE_DATA_WITH_VECTOR_INT64_MTTABLE_ATTRIBUTE:\n                    build_output_str += CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n                else:\n                    build_output_str += CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n            elif attr_dtype[0] == 'paddle::dialect::ScalarAttribute':\n                build_output_str += CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx], dtype=attr_dtype[1])\n            elif attr_dtype[0] == 'pir::StrAttribute':\n                build_output_str += ''\n            else:\n                assert 'mutable attribtue type is not right.'\n        build_output_str += '\\n'\n    infer_meta_args = []\n    for idx in range(len(op_infer_meta_map['param'])):\n        if op_infer_meta_map['param'][idx] in op_input_name_list:\n            if 'meta_' + op_infer_meta_map['param'][idx] not in infer_meta_args:\n                if 'pir::VectorType' in op_input_type_list[op_input_name_list.index(op_infer_meta_map['param'][idx])]:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                else:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n            infer_meta_args.append('meta_' + op_infer_meta_map['param'][idx])\n        else:\n            infer_meta_args.append(op_infer_meta_map['param'][idx])\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n            infer_meta_args.append(f'meta_{op_output_name_list[idx]}')\n        else:\n            build_output_str += CREATE_OUTPUT_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx])\n            infer_meta_args.append(f'&meta_{op_output_name_list[idx]}')\n    CREATE_INFER_META_FUNC_TEMPLATE = '\\n  phi::{func}({args});\\n'\n    CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE = '\\n  phi::{func}({args}, phi::MetaConfig(false, false));\\n'\n    if op_infer_meta_map['func'] in _INFERMETA_NEED_META_CONFIG:\n        build_output_str += CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    else:\n        build_output_str += CREATE_INFER_META_FUNC_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    build_output_str += '\\n  std::vector<pir::Type> argument_outputs;'\n    CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE = '\\n  pir::Type {name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{name}.dtype()), dense_{name}.dims(), dense_{name}.layout(), dense_{name}.lod(), dense_{name}.offset());\\n  argument_outputs.push_back({name}_dense_tensor_type);\\n'\n    CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE = '\\n  if ({input_name}_.impl() != nullptr) {{\\n    pir::Type {output_name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{output_name}.dtype()), dense_{output_name}.dims(), dense_{output_name}.layout(), dense_{output_name}.lod(), dense_{output_name}.offset());\\n    argument_outputs.push_back({output_name}_dense_tensor_type);\\n  }} else {{\\n    pir::Type {output_name}_type;\\n    argument_outputs.push_back({output_name}_type);\\n  }}\\n\\n'\n    CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE = '\\n  std::vector<pir::Type> {name}_types;\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    {name}_types.push_back(paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(vec_dense_{name}[i].dtype()), vec_dense_{name}[i].dims(), vec_dense_{name}[i].layout(), vec_dense_{name}[i].lod(), vec_dense_{name}[i].offset()));\\n  }}\\n  pir::Type {name}_vector_type = pir::VectorType::get(pir::IrContext::Instance(), {name}_types);\\n  argument_outputs.push_back({name}_vector_type);\\n'\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n        else:\n            output_name = op_output_name_list[idx]\n            has_input_inplace = op_inplace_map is not None and output_name in op_inplace_map.keys()\n            if op_output_optional_list[idx] == 'true' and has_input_inplace:\n                build_output_str += CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE.format(input_name=op_inplace_map[output_name], output_name=output_name)\n            else:\n                build_output_str += CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE.format(name=output_name)\n    build_output_str += '  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());\\n'\n    build_output_str += '  ::pir::PassStopGradientsDefaultly(argument);\\n'\n    return build_output_str",
            "def GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, mutable_attr_is_input=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    build_output_str = '  VLOG(4) << \"Builder construction outputs\";\\n'\n    CREATE_INPUT_METATENSOR_TEMPLATE = '\\n  VLOG(4) << \"Builder construction  dense_{name}\";\\n  paddle::dialect::IrTensor ir_tensor_{name}(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                      {name}.dims(),\\n                                                      {name}.data_layout(),\\n                                                      {name}.lod(),\\n                                                      {name}.offset());\\n  VLOG(4) << \"Builder construction  meta_{name}\";\\n  paddle::dialect::IrMetaTensor meta_{name}(&ir_tensor_{name});\\n'\n    CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE = '\\n  paddle::dialect::IrMetaTensor meta_{name};\\n  paddle::dialect::IrTensor ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>();\\n    VLOG(4) << \"Builder construction  dense_{name}\";\\n    ir_tensor_{name} = paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                        {name}.dims(),\\n                                                        {name}.data_layout(),\\n                                                        {name}.lod(),\\n                                                        {name}.offset());\\n    VLOG(4) << \"Builder construction  meta_{name}\";\\n    meta_{name} = paddle::dialect::IrMetaTensor(&ir_tensor_{name});\\n  }}\\n\\n'\n    CREATE_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n    vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n  }}\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n '\n    CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>();\\n    for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n        vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n    }}\\n  }}\\n\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n\\n'\n    CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::IntArray {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = std::move(phi::IntArray(paddle::dialect::GetInt64Vector(\\n                          {name}_.dyn_cast<pir::OpResult>().owner()\\n                          ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                          .attribute(\"value\"))));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  std::vector<int64_t> {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = paddle::dialect::GetInt64Vector(\\n                    {name}_.dyn_cast<pir::OpResult>().owner()\\n                    ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                    .attribute(\"value\"));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::Scalar {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {{\\n    {name} = std::move(phi::Scalar({name}_.dyn_cast<pir::OpResult>().owner()\\n                                  ->dyn_cast<paddle::dialect::FullOp>()\\n                                  .attribute(\"value\")\\n                                  .dyn_cast<paddle::dialect::ScalarAttribute>()\\n                                  .data()\\n                                  .to<int>()));\\n  }}\\n  else {{\\n    {name} = std::move(phi::Scalar(-1));\\n    {name}.SetFromTensor(true);\\n  }}\\n'\n    CREATE_OUTPUT_METATENSOR_TEMPLATE = '  paddle::dialect::IrTensor dense_{name};\\n  paddle::dialect::IrMetaTensor meta_{name}(&dense_{name});\\n'\n    CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_dense_{name}(({output_size}), paddle::dialect::IrTensor());\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_dense_{name}[i]));\\n  }}\\n  std::vector<phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n'\n    for idx in range(len(op_input_name_list)):\n        if 'pir::VectorType' in op_input_type_list[idx]:\n            if op_input_optional_list[idx] == 'false':\n                build_output_str += '  pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n        elif op_input_optional_list[idx] == 'false':\n            build_output_str += '  paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n    if mutable_attr_is_input:\n        for idx in range(len(op_mutable_attribute_name_list)):\n            attr_dtype = op_mutable_attribute_type_list[idx]\n            if attr_dtype[0] == 'paddle::dialect::IntArrayAttribute':\n                if op_class_name in _PREPARE_DATA_WITH_VECTOR_INT64_MTTABLE_ATTRIBUTE:\n                    build_output_str += CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n                else:\n                    build_output_str += CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n            elif attr_dtype[0] == 'paddle::dialect::ScalarAttribute':\n                build_output_str += CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx], dtype=attr_dtype[1])\n            elif attr_dtype[0] == 'pir::StrAttribute':\n                build_output_str += ''\n            else:\n                assert 'mutable attribtue type is not right.'\n        build_output_str += '\\n'\n    infer_meta_args = []\n    for idx in range(len(op_infer_meta_map['param'])):\n        if op_infer_meta_map['param'][idx] in op_input_name_list:\n            if 'meta_' + op_infer_meta_map['param'][idx] not in infer_meta_args:\n                if 'pir::VectorType' in op_input_type_list[op_input_name_list.index(op_infer_meta_map['param'][idx])]:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                else:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n            infer_meta_args.append('meta_' + op_infer_meta_map['param'][idx])\n        else:\n            infer_meta_args.append(op_infer_meta_map['param'][idx])\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n            infer_meta_args.append(f'meta_{op_output_name_list[idx]}')\n        else:\n            build_output_str += CREATE_OUTPUT_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx])\n            infer_meta_args.append(f'&meta_{op_output_name_list[idx]}')\n    CREATE_INFER_META_FUNC_TEMPLATE = '\\n  phi::{func}({args});\\n'\n    CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE = '\\n  phi::{func}({args}, phi::MetaConfig(false, false));\\n'\n    if op_infer_meta_map['func'] in _INFERMETA_NEED_META_CONFIG:\n        build_output_str += CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    else:\n        build_output_str += CREATE_INFER_META_FUNC_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    build_output_str += '\\n  std::vector<pir::Type> argument_outputs;'\n    CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE = '\\n  pir::Type {name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{name}.dtype()), dense_{name}.dims(), dense_{name}.layout(), dense_{name}.lod(), dense_{name}.offset());\\n  argument_outputs.push_back({name}_dense_tensor_type);\\n'\n    CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE = '\\n  if ({input_name}_.impl() != nullptr) {{\\n    pir::Type {output_name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{output_name}.dtype()), dense_{output_name}.dims(), dense_{output_name}.layout(), dense_{output_name}.lod(), dense_{output_name}.offset());\\n    argument_outputs.push_back({output_name}_dense_tensor_type);\\n  }} else {{\\n    pir::Type {output_name}_type;\\n    argument_outputs.push_back({output_name}_type);\\n  }}\\n\\n'\n    CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE = '\\n  std::vector<pir::Type> {name}_types;\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    {name}_types.push_back(paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(vec_dense_{name}[i].dtype()), vec_dense_{name}[i].dims(), vec_dense_{name}[i].layout(), vec_dense_{name}[i].lod(), vec_dense_{name}[i].offset()));\\n  }}\\n  pir::Type {name}_vector_type = pir::VectorType::get(pir::IrContext::Instance(), {name}_types);\\n  argument_outputs.push_back({name}_vector_type);\\n'\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n        else:\n            output_name = op_output_name_list[idx]\n            has_input_inplace = op_inplace_map is not None and output_name in op_inplace_map.keys()\n            if op_output_optional_list[idx] == 'true' and has_input_inplace:\n                build_output_str += CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE.format(input_name=op_inplace_map[output_name], output_name=output_name)\n            else:\n                build_output_str += CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE.format(name=output_name)\n    build_output_str += '  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());\\n'\n    build_output_str += '  ::pir::PassStopGradientsDefaultly(argument);\\n'\n    return build_output_str",
            "def GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, mutable_attr_is_input=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    build_output_str = '  VLOG(4) << \"Builder construction outputs\";\\n'\n    CREATE_INPUT_METATENSOR_TEMPLATE = '\\n  VLOG(4) << \"Builder construction  dense_{name}\";\\n  paddle::dialect::IrTensor ir_tensor_{name}(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                      {name}.dims(),\\n                                                      {name}.data_layout(),\\n                                                      {name}.lod(),\\n                                                      {name}.offset());\\n  VLOG(4) << \"Builder construction  meta_{name}\";\\n  paddle::dialect::IrMetaTensor meta_{name}(&ir_tensor_{name});\\n'\n    CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE = '\\n  paddle::dialect::IrMetaTensor meta_{name};\\n  paddle::dialect::IrTensor ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>();\\n    VLOG(4) << \"Builder construction  dense_{name}\";\\n    ir_tensor_{name} = paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}.dtype()),\\n                                                        {name}.dims(),\\n                                                        {name}.data_layout(),\\n                                                        {name}.lod(),\\n                                                        {name}.offset());\\n    VLOG(4) << \"Builder construction  meta_{name}\";\\n    meta_{name} = paddle::dialect::IrMetaTensor(&ir_tensor_{name});\\n  }}\\n\\n'\n    CREATE_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n    vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                     {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n  }}\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n '\n    CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_ir_tensor_{name};\\n  if ({name}_.impl() != nullptr) {{\\n    pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>();\\n    for (size_t i=0; i < static_cast<size_t>({name}.size()); i++) {{\\n        vec_ir_tensor_{name}.push_back(paddle::dialect::IrTensor(paddle::dialect::TransToPhiDataType({name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dtype()),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().dims(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().data_layout(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().lod(),\\n                                                                        {name}[i].dyn_cast<paddle::dialect::DenseTensorType>().offset()));\\n    }}\\n  }}\\n\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < vec_ir_tensor_{name}.size(); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_ir_tensor_{name}[i]));\\n  }}\\n\\n  std::vector<const phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n\\n'\n    CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::IntArray {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = std::move(phi::IntArray(paddle::dialect::GetInt64Vector(\\n                          {name}_.dyn_cast<pir::OpResult>().owner()\\n                          ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                          .attribute(\"value\"))));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::move(phi::IntArray(std::vector<int64_t>({name}_size, -1)));\\n    {name}.SetFromTensor(true);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  std::vector<int64_t> {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullIntArrayOp>()) {{\\n    {name} = paddle::dialect::GetInt64Vector(\\n                    {name}_.dyn_cast<pir::OpResult>().owner()\\n                    ->dyn_cast<paddle::dialect::FullIntArrayOp>()\\n                    .attribute(\"value\"));\\n  }} else if ({name}_.type().isa<pir::VectorType>()) {{\\n    size_t {name}_size = {name}_.type().dyn_cast<pir::VectorType>().size();\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else if ({name}_.type().isa<paddle::dialect::DenseTensorType>()) {{\\n    size_t {name}_size = phi::product({name}_.type().dyn_cast<paddle::dialect::DenseTensorType>().dims());\\n    {name} = std::vector<int64_t>({name}_size, -1);\\n  }} else {{\\n    PADDLE_THROW(phi::errors::Unimplemented(\"Only support VectorType or DenseTensorType\"));\\n  }}\\n'\n    CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE = '  phi::Scalar {name};\\n  if ({name}_.dyn_cast<pir::OpResult>().owner()->isa<paddle::dialect::FullOp>()) {{\\n    {name} = std::move(phi::Scalar({name}_.dyn_cast<pir::OpResult>().owner()\\n                                  ->dyn_cast<paddle::dialect::FullOp>()\\n                                  .attribute(\"value\")\\n                                  .dyn_cast<paddle::dialect::ScalarAttribute>()\\n                                  .data()\\n                                  .to<int>()));\\n  }}\\n  else {{\\n    {name} = std::move(phi::Scalar(-1));\\n    {name}.SetFromTensor(true);\\n  }}\\n'\n    CREATE_OUTPUT_METATENSOR_TEMPLATE = '  paddle::dialect::IrTensor dense_{name};\\n  paddle::dialect::IrMetaTensor meta_{name}(&dense_{name});\\n'\n    CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE = '  std::vector<paddle::dialect::IrTensor> vec_dense_{name}(({output_size}), paddle::dialect::IrTensor());\\n  std::vector<paddle::dialect::IrMetaTensor> vec_meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    vec_meta_{name}.push_back(paddle::dialect::IrMetaTensor(&vec_dense_{name}[i]));\\n  }}\\n  std::vector<phi::MetaTensor*> meta_{name};\\n  for (size_t i=0; i < static_cast<size_t>(vec_meta_{name}.size()); i++) {{\\n    meta_{name}.push_back(&vec_meta_{name}[i]);\\n  }}\\n'\n    for idx in range(len(op_input_name_list)):\n        if 'pir::VectorType' in op_input_type_list[idx]:\n            if op_input_optional_list[idx] == 'false':\n                build_output_str += '  pir::VectorType {name} = {name}_.type().dyn_cast<pir::VectorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n        elif op_input_optional_list[idx] == 'false':\n            build_output_str += '  paddle::dialect::DenseTensorType {name} = {name}_.type().dyn_cast<paddle::dialect::DenseTensorType>(); (void){name};\\n'.format(name=op_input_name_list[idx])\n    if mutable_attr_is_input:\n        for idx in range(len(op_mutable_attribute_name_list)):\n            attr_dtype = op_mutable_attribute_type_list[idx]\n            if attr_dtype[0] == 'paddle::dialect::IntArrayAttribute':\n                if op_class_name in _PREPARE_DATA_WITH_VECTOR_INT64_MTTABLE_ATTRIBUTE:\n                    build_output_str += CREATE_VECTOR_INT_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n                else:\n                    build_output_str += CREATE_INTARRAY_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx])\n            elif attr_dtype[0] == 'paddle::dialect::ScalarAttribute':\n                build_output_str += CREATE_SCALAR_MUTABLE_ATTRIBUE_WITH_UNKONW_DATA_TEMPLATE.format(name=op_mutable_attribute_name_list[idx], dtype=attr_dtype[1])\n            elif attr_dtype[0] == 'pir::StrAttribute':\n                build_output_str += ''\n            else:\n                assert 'mutable attribtue type is not right.'\n        build_output_str += '\\n'\n    infer_meta_args = []\n    for idx in range(len(op_infer_meta_map['param'])):\n        if op_infer_meta_map['param'][idx] in op_input_name_list:\n            if 'meta_' + op_infer_meta_map['param'][idx] not in infer_meta_args:\n                if 'pir::VectorType' in op_input_type_list[op_input_name_list.index(op_infer_meta_map['param'][idx])]:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_VEC_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                else:\n                    input_index = op_input_name_list.index(op_infer_meta_map['param'][idx])\n                    if op_input_optional_list[input_index] == 'true':\n                        build_output_str += CREATE_OPTIONAL_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n                    else:\n                        build_output_str += CREATE_INPUT_METATENSOR_TEMPLATE.format(name=op_infer_meta_map['param'][idx])\n            infer_meta_args.append('meta_' + op_infer_meta_map['param'][idx])\n        else:\n            infer_meta_args.append(op_infer_meta_map['param'][idx])\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n            infer_meta_args.append(f'meta_{op_output_name_list[idx]}')\n        else:\n            build_output_str += CREATE_OUTPUT_METATENSOR_TEMPLATE.format(name=op_output_name_list[idx])\n            infer_meta_args.append(f'&meta_{op_output_name_list[idx]}')\n    CREATE_INFER_META_FUNC_TEMPLATE = '\\n  phi::{func}({args});\\n'\n    CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE = '\\n  phi::{func}({args}, phi::MetaConfig(false, false));\\n'\n    if op_infer_meta_map['func'] in _INFERMETA_NEED_META_CONFIG:\n        build_output_str += CREATE_INFER_META_FUNC_WITH_METACINFIG_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    else:\n        build_output_str += CREATE_INFER_META_FUNC_TEMPLATE.format(func=op_infer_meta_map['func'], args=', '.join(infer_meta_args))\n    build_output_str += '\\n  std::vector<pir::Type> argument_outputs;'\n    CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE = '\\n  pir::Type {name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{name}.dtype()), dense_{name}.dims(), dense_{name}.layout(), dense_{name}.lod(), dense_{name}.offset());\\n  argument_outputs.push_back({name}_dense_tensor_type);\\n'\n    CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE = '\\n  if ({input_name}_.impl() != nullptr) {{\\n    pir::Type {output_name}_dense_tensor_type = paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(dense_{output_name}.dtype()), dense_{output_name}.dims(), dense_{output_name}.layout(), dense_{output_name}.lod(), dense_{output_name}.offset());\\n    argument_outputs.push_back({output_name}_dense_tensor_type);\\n  }} else {{\\n    pir::Type {output_name}_type;\\n    argument_outputs.push_back({output_name}_type);\\n  }}\\n\\n'\n    CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE = '\\n  std::vector<pir::Type> {name}_types;\\n  for (size_t i=0; i < static_cast<size_t>({output_size}); i++) {{\\n    {name}_types.push_back(paddle::dialect::DenseTensorType::get(pir::IrContext::Instance(), paddle::dialect::TransToIrDataType(vec_dense_{name}[i].dtype()), vec_dense_{name}[i].dims(), vec_dense_{name}[i].layout(), vec_dense_{name}[i].lod(), vec_dense_{name}[i].offset()));\\n  }}\\n  pir::Type {name}_vector_type = pir::VectorType::get(pir::IrContext::Instance(), {name}_types);\\n  argument_outputs.push_back({name}_vector_type);\\n'\n    for idx in range(len(op_output_name_list)):\n        if 'pir::VectorType' in op_output_type_list[idx]:\n            build_output_str += CREATE_OUTPUT_VEC_DENSE_TENSOR_TEMPLATE.format(name=op_output_name_list[idx], output_size=op_output_size_list[idx])\n        else:\n            output_name = op_output_name_list[idx]\n            has_input_inplace = op_inplace_map is not None and output_name in op_inplace_map.keys()\n            if op_output_optional_list[idx] == 'true' and has_input_inplace:\n                build_output_str += CREATE_OUTPUT_INPLACE_OPTIONAL_DENSE_TENSOR_TEMPLATE.format(input_name=op_inplace_map[output_name], output_name=output_name)\n            else:\n                build_output_str += CREATE_OUTPUT_DENSE_TENSOR_TEMPLATE.format(name=output_name)\n    build_output_str += '  argument.AddOutputs(argument_outputs.begin(), argument_outputs.end());\\n'\n    build_output_str += '  ::pir::PassStopGradientsDefaultly(argument);\\n'\n    return build_output_str"
        ]
    },
    {
        "func_name": "gen_build_func_str",
        "original": "def gen_build_func_str(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input=False, attr_args_is_map=False):\n    build_args_for_declare = ''\n    build_func = ''\n    build_info_str = OP_INFO_TEMPLATE.format(op_name=op_class_name)\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, muta_attr_is_input, attr_args_is_map)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, muta_attr_is_input, attr_args_is_map)\n    inset_full_for_mutable_attributes_str = ''\n    if not muta_attr_is_input:\n        inset_full_for_mutable_attributes_str = GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list)\n    build_inputs_str = GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list)\n    build_attributes_str = GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list)\n    build_outputs_str = GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input)\n    GET_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<{attr_ir_type}>().data();\\n'\n    GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<pir::StrAttribute>().AsString();\\n'\n    GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name};\\n  for (size_t i = 0; i < attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().size(); i++) {{\\n    {attribute_name}.push_back(attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().at(i).dyn_cast<{inner_type}>().{data_name}());\\n  }}\\n'\n    GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::IntArrayAttribute>().data().GetData();\\n'\n    GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::ScalarAttribute>().data().to<{attr_type}>();\\n'\n    get_attributes_str = ''\n    array_attr_str = 'pir::ArrayAttribute'\n    attr_names = []\n    attr_types = []\n    attr_build_arg_types = []\n    if not muta_attr_is_input:\n        attr_names = op_attribute_name_list\n        attr_types = op_attribute_type_list\n        attr_build_arg_types = op_attribute_build_arg_type_list\n    else:\n        attr_names = op_non_mutable_attribute_name_list\n        attr_types = op_non_mutable_attribute_type_list\n        attr_build_arg_types = op_non_mutable_attribute_build_arg_type_list\n    if attr_args_is_map:\n        for idx in range(len(attr_names)):\n            attr_type = attr_build_arg_types[idx]\n            attr_type = attr_type.replace('const ', '')\n            attr_type = attr_type.replace('&', '')\n            if array_attr_str in attr_types[idx]:\n                inner_type = attr_types[idx][len(array_attr_str) + 1:-1]\n                data_name = 'data'\n                if inner_type == 'pir::StrAttribute':\n                    data_name = 'AsString'\n                get_attributes_str += GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], inner_type=inner_type, data_name=data_name)\n            elif 'paddle::dialect::IntArrayAttribute' in attr_types[idx]:\n                get_attributes_str += GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'paddle::dialect::ScalarAttribute' in attr_types[idx]:\n                get_attributes_str += GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'pir::StrAttribute' in attr_types[idx]:\n                get_attributes_str += GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n            else:\n                get_attributes_str += GET_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n    build_func = OP_BUILD_TEMPLATE.format(op_name=op_class_name, build_info=build_info_str, build_args=build_args_for_define, build_mutable_attributes=inset_full_for_mutable_attributes_str, get_attributes=get_attributes_str, build_inputs=build_inputs_str, build_attributes=build_attributes_str, build_outputs=build_outputs_str)\n    return (build_args_for_declare, build_func)",
        "mutated": [
            "def gen_build_func_str(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n    build_args_for_declare = ''\n    build_func = ''\n    build_info_str = OP_INFO_TEMPLATE.format(op_name=op_class_name)\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, muta_attr_is_input, attr_args_is_map)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, muta_attr_is_input, attr_args_is_map)\n    inset_full_for_mutable_attributes_str = ''\n    if not muta_attr_is_input:\n        inset_full_for_mutable_attributes_str = GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list)\n    build_inputs_str = GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list)\n    build_attributes_str = GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list)\n    build_outputs_str = GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input)\n    GET_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<{attr_ir_type}>().data();\\n'\n    GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<pir::StrAttribute>().AsString();\\n'\n    GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name};\\n  for (size_t i = 0; i < attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().size(); i++) {{\\n    {attribute_name}.push_back(attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().at(i).dyn_cast<{inner_type}>().{data_name}());\\n  }}\\n'\n    GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::IntArrayAttribute>().data().GetData();\\n'\n    GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::ScalarAttribute>().data().to<{attr_type}>();\\n'\n    get_attributes_str = ''\n    array_attr_str = 'pir::ArrayAttribute'\n    attr_names = []\n    attr_types = []\n    attr_build_arg_types = []\n    if not muta_attr_is_input:\n        attr_names = op_attribute_name_list\n        attr_types = op_attribute_type_list\n        attr_build_arg_types = op_attribute_build_arg_type_list\n    else:\n        attr_names = op_non_mutable_attribute_name_list\n        attr_types = op_non_mutable_attribute_type_list\n        attr_build_arg_types = op_non_mutable_attribute_build_arg_type_list\n    if attr_args_is_map:\n        for idx in range(len(attr_names)):\n            attr_type = attr_build_arg_types[idx]\n            attr_type = attr_type.replace('const ', '')\n            attr_type = attr_type.replace('&', '')\n            if array_attr_str in attr_types[idx]:\n                inner_type = attr_types[idx][len(array_attr_str) + 1:-1]\n                data_name = 'data'\n                if inner_type == 'pir::StrAttribute':\n                    data_name = 'AsString'\n                get_attributes_str += GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], inner_type=inner_type, data_name=data_name)\n            elif 'paddle::dialect::IntArrayAttribute' in attr_types[idx]:\n                get_attributes_str += GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'paddle::dialect::ScalarAttribute' in attr_types[idx]:\n                get_attributes_str += GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'pir::StrAttribute' in attr_types[idx]:\n                get_attributes_str += GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n            else:\n                get_attributes_str += GET_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n    build_func = OP_BUILD_TEMPLATE.format(op_name=op_class_name, build_info=build_info_str, build_args=build_args_for_define, build_mutable_attributes=inset_full_for_mutable_attributes_str, get_attributes=get_attributes_str, build_inputs=build_inputs_str, build_attributes=build_attributes_str, build_outputs=build_outputs_str)\n    return (build_args_for_declare, build_func)",
            "def gen_build_func_str(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    build_args_for_declare = ''\n    build_func = ''\n    build_info_str = OP_INFO_TEMPLATE.format(op_name=op_class_name)\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, muta_attr_is_input, attr_args_is_map)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, muta_attr_is_input, attr_args_is_map)\n    inset_full_for_mutable_attributes_str = ''\n    if not muta_attr_is_input:\n        inset_full_for_mutable_attributes_str = GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list)\n    build_inputs_str = GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list)\n    build_attributes_str = GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list)\n    build_outputs_str = GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input)\n    GET_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<{attr_ir_type}>().data();\\n'\n    GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<pir::StrAttribute>().AsString();\\n'\n    GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name};\\n  for (size_t i = 0; i < attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().size(); i++) {{\\n    {attribute_name}.push_back(attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().at(i).dyn_cast<{inner_type}>().{data_name}());\\n  }}\\n'\n    GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::IntArrayAttribute>().data().GetData();\\n'\n    GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::ScalarAttribute>().data().to<{attr_type}>();\\n'\n    get_attributes_str = ''\n    array_attr_str = 'pir::ArrayAttribute'\n    attr_names = []\n    attr_types = []\n    attr_build_arg_types = []\n    if not muta_attr_is_input:\n        attr_names = op_attribute_name_list\n        attr_types = op_attribute_type_list\n        attr_build_arg_types = op_attribute_build_arg_type_list\n    else:\n        attr_names = op_non_mutable_attribute_name_list\n        attr_types = op_non_mutable_attribute_type_list\n        attr_build_arg_types = op_non_mutable_attribute_build_arg_type_list\n    if attr_args_is_map:\n        for idx in range(len(attr_names)):\n            attr_type = attr_build_arg_types[idx]\n            attr_type = attr_type.replace('const ', '')\n            attr_type = attr_type.replace('&', '')\n            if array_attr_str in attr_types[idx]:\n                inner_type = attr_types[idx][len(array_attr_str) + 1:-1]\n                data_name = 'data'\n                if inner_type == 'pir::StrAttribute':\n                    data_name = 'AsString'\n                get_attributes_str += GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], inner_type=inner_type, data_name=data_name)\n            elif 'paddle::dialect::IntArrayAttribute' in attr_types[idx]:\n                get_attributes_str += GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'paddle::dialect::ScalarAttribute' in attr_types[idx]:\n                get_attributes_str += GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'pir::StrAttribute' in attr_types[idx]:\n                get_attributes_str += GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n            else:\n                get_attributes_str += GET_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n    build_func = OP_BUILD_TEMPLATE.format(op_name=op_class_name, build_info=build_info_str, build_args=build_args_for_define, build_mutable_attributes=inset_full_for_mutable_attributes_str, get_attributes=get_attributes_str, build_inputs=build_inputs_str, build_attributes=build_attributes_str, build_outputs=build_outputs_str)\n    return (build_args_for_declare, build_func)",
            "def gen_build_func_str(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    build_args_for_declare = ''\n    build_func = ''\n    build_info_str = OP_INFO_TEMPLATE.format(op_name=op_class_name)\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, muta_attr_is_input, attr_args_is_map)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, muta_attr_is_input, attr_args_is_map)\n    inset_full_for_mutable_attributes_str = ''\n    if not muta_attr_is_input:\n        inset_full_for_mutable_attributes_str = GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list)\n    build_inputs_str = GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list)\n    build_attributes_str = GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list)\n    build_outputs_str = GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input)\n    GET_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<{attr_ir_type}>().data();\\n'\n    GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<pir::StrAttribute>().AsString();\\n'\n    GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name};\\n  for (size_t i = 0; i < attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().size(); i++) {{\\n    {attribute_name}.push_back(attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().at(i).dyn_cast<{inner_type}>().{data_name}());\\n  }}\\n'\n    GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::IntArrayAttribute>().data().GetData();\\n'\n    GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::ScalarAttribute>().data().to<{attr_type}>();\\n'\n    get_attributes_str = ''\n    array_attr_str = 'pir::ArrayAttribute'\n    attr_names = []\n    attr_types = []\n    attr_build_arg_types = []\n    if not muta_attr_is_input:\n        attr_names = op_attribute_name_list\n        attr_types = op_attribute_type_list\n        attr_build_arg_types = op_attribute_build_arg_type_list\n    else:\n        attr_names = op_non_mutable_attribute_name_list\n        attr_types = op_non_mutable_attribute_type_list\n        attr_build_arg_types = op_non_mutable_attribute_build_arg_type_list\n    if attr_args_is_map:\n        for idx in range(len(attr_names)):\n            attr_type = attr_build_arg_types[idx]\n            attr_type = attr_type.replace('const ', '')\n            attr_type = attr_type.replace('&', '')\n            if array_attr_str in attr_types[idx]:\n                inner_type = attr_types[idx][len(array_attr_str) + 1:-1]\n                data_name = 'data'\n                if inner_type == 'pir::StrAttribute':\n                    data_name = 'AsString'\n                get_attributes_str += GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], inner_type=inner_type, data_name=data_name)\n            elif 'paddle::dialect::IntArrayAttribute' in attr_types[idx]:\n                get_attributes_str += GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'paddle::dialect::ScalarAttribute' in attr_types[idx]:\n                get_attributes_str += GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'pir::StrAttribute' in attr_types[idx]:\n                get_attributes_str += GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n            else:\n                get_attributes_str += GET_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n    build_func = OP_BUILD_TEMPLATE.format(op_name=op_class_name, build_info=build_info_str, build_args=build_args_for_define, build_mutable_attributes=inset_full_for_mutable_attributes_str, get_attributes=get_attributes_str, build_inputs=build_inputs_str, build_attributes=build_attributes_str, build_outputs=build_outputs_str)\n    return (build_args_for_declare, build_func)",
            "def gen_build_func_str(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    build_args_for_declare = ''\n    build_func = ''\n    build_info_str = OP_INFO_TEMPLATE.format(op_name=op_class_name)\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, muta_attr_is_input, attr_args_is_map)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, muta_attr_is_input, attr_args_is_map)\n    inset_full_for_mutable_attributes_str = ''\n    if not muta_attr_is_input:\n        inset_full_for_mutable_attributes_str = GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list)\n    build_inputs_str = GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list)\n    build_attributes_str = GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list)\n    build_outputs_str = GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input)\n    GET_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<{attr_ir_type}>().data();\\n'\n    GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<pir::StrAttribute>().AsString();\\n'\n    GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name};\\n  for (size_t i = 0; i < attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().size(); i++) {{\\n    {attribute_name}.push_back(attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().at(i).dyn_cast<{inner_type}>().{data_name}());\\n  }}\\n'\n    GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::IntArrayAttribute>().data().GetData();\\n'\n    GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::ScalarAttribute>().data().to<{attr_type}>();\\n'\n    get_attributes_str = ''\n    array_attr_str = 'pir::ArrayAttribute'\n    attr_names = []\n    attr_types = []\n    attr_build_arg_types = []\n    if not muta_attr_is_input:\n        attr_names = op_attribute_name_list\n        attr_types = op_attribute_type_list\n        attr_build_arg_types = op_attribute_build_arg_type_list\n    else:\n        attr_names = op_non_mutable_attribute_name_list\n        attr_types = op_non_mutable_attribute_type_list\n        attr_build_arg_types = op_non_mutable_attribute_build_arg_type_list\n    if attr_args_is_map:\n        for idx in range(len(attr_names)):\n            attr_type = attr_build_arg_types[idx]\n            attr_type = attr_type.replace('const ', '')\n            attr_type = attr_type.replace('&', '')\n            if array_attr_str in attr_types[idx]:\n                inner_type = attr_types[idx][len(array_attr_str) + 1:-1]\n                data_name = 'data'\n                if inner_type == 'pir::StrAttribute':\n                    data_name = 'AsString'\n                get_attributes_str += GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], inner_type=inner_type, data_name=data_name)\n            elif 'paddle::dialect::IntArrayAttribute' in attr_types[idx]:\n                get_attributes_str += GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'paddle::dialect::ScalarAttribute' in attr_types[idx]:\n                get_attributes_str += GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'pir::StrAttribute' in attr_types[idx]:\n                get_attributes_str += GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n            else:\n                get_attributes_str += GET_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n    build_func = OP_BUILD_TEMPLATE.format(op_name=op_class_name, build_info=build_info_str, build_args=build_args_for_define, build_mutable_attributes=inset_full_for_mutable_attributes_str, get_attributes=get_attributes_str, build_inputs=build_inputs_str, build_attributes=build_attributes_str, build_outputs=build_outputs_str)\n    return (build_args_for_declare, build_func)",
            "def gen_build_func_str(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input=False, attr_args_is_map=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    build_args_for_declare = ''\n    build_func = ''\n    build_info_str = OP_INFO_TEMPLATE.format(op_name=op_class_name)\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, muta_attr_is_input, attr_args_is_map)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, muta_attr_is_input, attr_args_is_map)\n    inset_full_for_mutable_attributes_str = ''\n    if not muta_attr_is_input:\n        inset_full_for_mutable_attributes_str = GenBuildInserFullForMutableAttribute(op_class_name, op_attribute_name_list, op_attribute_build_arg_type_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list)\n    build_inputs_str = GenBuildInputs(op_input_name_list, op_mutable_attribute_name_list)\n    build_attributes_str = GenBuildAttributes(op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list)\n    build_outputs_str = GenBuildOutputs(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_output_name_list, op_output_type_list, op_output_size_list, op_output_optional_list, op_infer_meta_map, op_inplace_map, muta_attr_is_input)\n    GET_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<{attr_ir_type}>().data();\\n'\n    GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<pir::StrAttribute>().AsString();\\n'\n    GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name};\\n  for (size_t i = 0; i < attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().size(); i++) {{\\n    {attribute_name}.push_back(attributes.at(\"{attribute_name}\").dyn_cast<pir::ArrayAttribute>().at(i).dyn_cast<{inner_type}>().{data_name}());\\n  }}\\n'\n    GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::IntArrayAttribute>().data().GetData();\\n'\n    GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE = '\\n  IR_ENFORCE(\\n      attributes.find(\"{attribute_name}\") != attributes.end(),\\n          \"\\'{attribute_name}\\' Attribute is expected for {op_name}. \");\\n  {attr_type} {attribute_name} = attributes.at(\"{attribute_name}\").dyn_cast<paddle::dialect::ScalarAttribute>().data().to<{attr_type}>();\\n'\n    get_attributes_str = ''\n    array_attr_str = 'pir::ArrayAttribute'\n    attr_names = []\n    attr_types = []\n    attr_build_arg_types = []\n    if not muta_attr_is_input:\n        attr_names = op_attribute_name_list\n        attr_types = op_attribute_type_list\n        attr_build_arg_types = op_attribute_build_arg_type_list\n    else:\n        attr_names = op_non_mutable_attribute_name_list\n        attr_types = op_non_mutable_attribute_type_list\n        attr_build_arg_types = op_non_mutable_attribute_build_arg_type_list\n    if attr_args_is_map:\n        for idx in range(len(attr_names)):\n            attr_type = attr_build_arg_types[idx]\n            attr_type = attr_type.replace('const ', '')\n            attr_type = attr_type.replace('&', '')\n            if array_attr_str in attr_types[idx]:\n                inner_type = attr_types[idx][len(array_attr_str) + 1:-1]\n                data_name = 'data'\n                if inner_type == 'pir::StrAttribute':\n                    data_name = 'AsString'\n                get_attributes_str += GET_ARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], inner_type=inner_type, data_name=data_name)\n            elif 'paddle::dialect::IntArrayAttribute' in attr_types[idx]:\n                get_attributes_str += GET_INTARRAY_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'paddle::dialect::ScalarAttribute' in attr_types[idx]:\n                get_attributes_str += GET_SCALAR_ATTRIBUTE_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx])\n            elif 'pir::StrAttribute' in attr_types[idx]:\n                get_attributes_str += GET_STR_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n            else:\n                get_attributes_str += GET_ATTRIBUTES_FROM_MAP_TEMPLATE.format(op_name=op_class_name, attr_type=attr_type, attribute_name=attr_names[idx], attr_ir_type=attr_types[idx])\n    build_func = OP_BUILD_TEMPLATE.format(op_name=op_class_name, build_info=build_info_str, build_args=build_args_for_define, build_mutable_attributes=inset_full_for_mutable_attributes_str, get_attributes=get_attributes_str, build_inputs=build_inputs_str, build_attributes=build_attributes_str, build_outputs=build_outputs_str)\n    return (build_args_for_declare, build_func)"
        ]
    },
    {
        "func_name": "gen_build_func_str_by_invoke",
        "original": "def gen_build_func_str_by_invoke(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_invoke_class_name, op_invoke_map):\n    build_args_for_declare = ''\n    build_func = ''\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, False, False)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, False, False)\n    invoke_args = op_invoke_map['args'].split(', ')\n    invoke_args_str = ''\n    for item in invoke_args:\n        if item in op_input_name_list:\n            invoke_args_str += ', ' + item + '_'\n        elif '.dtype()' in item:\n            invoke_args_str += ', paddle::dialect::TransToPhiDataType(' + item[:-8] + '_' + '.type().dyn_cast<paddle::dialect::DenseTensorType>().dtype())'\n        else:\n            invoke_args_str += ', ' + item\n    build_func = OP_BUILD_BY_INVOKE_TEMPLATE.format(op_name=op_class_name, build_args=build_args_for_define, invoke_class=op_invoke_class_name, invoke_args=invoke_args_str)\n    return (build_args_for_declare, build_func)",
        "mutated": [
            "def gen_build_func_str_by_invoke(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_invoke_class_name, op_invoke_map):\n    if False:\n        i = 10\n    build_args_for_declare = ''\n    build_func = ''\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, False, False)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, False, False)\n    invoke_args = op_invoke_map['args'].split(', ')\n    invoke_args_str = ''\n    for item in invoke_args:\n        if item in op_input_name_list:\n            invoke_args_str += ', ' + item + '_'\n        elif '.dtype()' in item:\n            invoke_args_str += ', paddle::dialect::TransToPhiDataType(' + item[:-8] + '_' + '.type().dyn_cast<paddle::dialect::DenseTensorType>().dtype())'\n        else:\n            invoke_args_str += ', ' + item\n    build_func = OP_BUILD_BY_INVOKE_TEMPLATE.format(op_name=op_class_name, build_args=build_args_for_define, invoke_class=op_invoke_class_name, invoke_args=invoke_args_str)\n    return (build_args_for_declare, build_func)",
            "def gen_build_func_str_by_invoke(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_invoke_class_name, op_invoke_map):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    build_args_for_declare = ''\n    build_func = ''\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, False, False)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, False, False)\n    invoke_args = op_invoke_map['args'].split(', ')\n    invoke_args_str = ''\n    for item in invoke_args:\n        if item in op_input_name_list:\n            invoke_args_str += ', ' + item + '_'\n        elif '.dtype()' in item:\n            invoke_args_str += ', paddle::dialect::TransToPhiDataType(' + item[:-8] + '_' + '.type().dyn_cast<paddle::dialect::DenseTensorType>().dtype())'\n        else:\n            invoke_args_str += ', ' + item\n    build_func = OP_BUILD_BY_INVOKE_TEMPLATE.format(op_name=op_class_name, build_args=build_args_for_define, invoke_class=op_invoke_class_name, invoke_args=invoke_args_str)\n    return (build_args_for_declare, build_func)",
            "def gen_build_func_str_by_invoke(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_invoke_class_name, op_invoke_map):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    build_args_for_declare = ''\n    build_func = ''\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, False, False)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, False, False)\n    invoke_args = op_invoke_map['args'].split(', ')\n    invoke_args_str = ''\n    for item in invoke_args:\n        if item in op_input_name_list:\n            invoke_args_str += ', ' + item + '_'\n        elif '.dtype()' in item:\n            invoke_args_str += ', paddle::dialect::TransToPhiDataType(' + item[:-8] + '_' + '.type().dyn_cast<paddle::dialect::DenseTensorType>().dtype())'\n        else:\n            invoke_args_str += ', ' + item\n    build_func = OP_BUILD_BY_INVOKE_TEMPLATE.format(op_name=op_class_name, build_args=build_args_for_define, invoke_class=op_invoke_class_name, invoke_args=invoke_args_str)\n    return (build_args_for_declare, build_func)",
            "def gen_build_func_str_by_invoke(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_invoke_class_name, op_invoke_map):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    build_args_for_declare = ''\n    build_func = ''\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, False, False)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, False, False)\n    invoke_args = op_invoke_map['args'].split(', ')\n    invoke_args_str = ''\n    for item in invoke_args:\n        if item in op_input_name_list:\n            invoke_args_str += ', ' + item + '_'\n        elif '.dtype()' in item:\n            invoke_args_str += ', paddle::dialect::TransToPhiDataType(' + item[:-8] + '_' + '.type().dyn_cast<paddle::dialect::DenseTensorType>().dtype())'\n        else:\n            invoke_args_str += ', ' + item\n    build_func = OP_BUILD_BY_INVOKE_TEMPLATE.format(op_name=op_class_name, build_args=build_args_for_define, invoke_class=op_invoke_class_name, invoke_args=invoke_args_str)\n    return (build_args_for_declare, build_func)",
            "def gen_build_func_str_by_invoke(op_class_name, op_input_name_list, op_input_type_list, op_input_optional_list, op_attribute_name_list, op_attribute_type_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_mutable_attribute_type_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_type_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, op_invoke_class_name, op_invoke_map):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    build_args_for_declare = ''\n    build_func = ''\n    build_args_for_declare = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, True, False, False)\n    build_args_for_define = GenBuildInputArgsStr(op_input_name_list, op_attribute_name_list, op_attribute_build_arg_type_list, op_attribute_default_value_list, op_mutable_attribute_name_list, op_non_mutable_attribute_name_list, op_non_mutable_attribute_build_arg_type_list, op_non_mutable_attribute_default_value_list, False, False, False)\n    invoke_args = op_invoke_map['args'].split(', ')\n    invoke_args_str = ''\n    for item in invoke_args:\n        if item in op_input_name_list:\n            invoke_args_str += ', ' + item + '_'\n        elif '.dtype()' in item:\n            invoke_args_str += ', paddle::dialect::TransToPhiDataType(' + item[:-8] + '_' + '.type().dyn_cast<paddle::dialect::DenseTensorType>().dtype())'\n        else:\n            invoke_args_str += ', ' + item\n    build_func = OP_BUILD_BY_INVOKE_TEMPLATE.format(op_name=op_class_name, build_args=build_args_for_define, invoke_class=op_invoke_class_name, invoke_args=invoke_args_str)\n    return (build_args_for_declare, build_func)"
        ]
    }
]