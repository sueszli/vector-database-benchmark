[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    This module requires both NAPALM and Capirca.\n    \"\"\"\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl (napalm_acl) module cannot be loaded. Please install capirca and napalm.')",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl (napalm_acl) module cannot be loaded. Please install capirca and napalm.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl (napalm_acl) module cannot be loaded. Please install capirca and napalm.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl (napalm_acl) module cannot be loaded. Please install capirca and napalm.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl (napalm_acl) module cannot be loaded. Please install capirca and napalm.')",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    This module requires both NAPALM and Capirca.\\n    '\n    if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):\n        return __virtualname__\n    else:\n        return (False, 'The netacl (napalm_acl) module cannot be loaded. Please install capirca and napalm.')"
        ]
    },
    {
        "func_name": "_get_capirca_platform",
        "original": "def _get_capirca_platform():\n    \"\"\"\n    Given the following NAPALM grains, we can determine the Capirca platform name:\n\n    - vendor\n    - device model\n    - operating system\n\n    Not the most optimal.\n    \"\"\"\n    vendor = __grains__['vendor'].lower()\n    os_ = __grains__['os'].lower()\n    model = __grains__['model'].lower()\n    if vendor == 'juniper' and 'srx' in model:\n        return 'junipersrx'\n    elif vendor == 'cisco' and os_ == 'ios':\n        return 'cisco'\n    elif vendor == 'cisco' and os_ == 'iosxr':\n        return 'ciscoxr'\n    elif vendor == 'cisco' and os_ == 'asa':\n        return 'ciscoasa'\n    elif os_ == 'linux':\n        return 'iptables'\n    elif vendor == 'palo alto networks':\n        return 'paloaltofw'\n    return vendor",
        "mutated": [
            "def _get_capirca_platform():\n    if False:\n        i = 10\n    '\\n    Given the following NAPALM grains, we can determine the Capirca platform name:\\n\\n    - vendor\\n    - device model\\n    - operating system\\n\\n    Not the most optimal.\\n    '\n    vendor = __grains__['vendor'].lower()\n    os_ = __grains__['os'].lower()\n    model = __grains__['model'].lower()\n    if vendor == 'juniper' and 'srx' in model:\n        return 'junipersrx'\n    elif vendor == 'cisco' and os_ == 'ios':\n        return 'cisco'\n    elif vendor == 'cisco' and os_ == 'iosxr':\n        return 'ciscoxr'\n    elif vendor == 'cisco' and os_ == 'asa':\n        return 'ciscoasa'\n    elif os_ == 'linux':\n        return 'iptables'\n    elif vendor == 'palo alto networks':\n        return 'paloaltofw'\n    return vendor",
            "def _get_capirca_platform():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given the following NAPALM grains, we can determine the Capirca platform name:\\n\\n    - vendor\\n    - device model\\n    - operating system\\n\\n    Not the most optimal.\\n    '\n    vendor = __grains__['vendor'].lower()\n    os_ = __grains__['os'].lower()\n    model = __grains__['model'].lower()\n    if vendor == 'juniper' and 'srx' in model:\n        return 'junipersrx'\n    elif vendor == 'cisco' and os_ == 'ios':\n        return 'cisco'\n    elif vendor == 'cisco' and os_ == 'iosxr':\n        return 'ciscoxr'\n    elif vendor == 'cisco' and os_ == 'asa':\n        return 'ciscoasa'\n    elif os_ == 'linux':\n        return 'iptables'\n    elif vendor == 'palo alto networks':\n        return 'paloaltofw'\n    return vendor",
            "def _get_capirca_platform():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given the following NAPALM grains, we can determine the Capirca platform name:\\n\\n    - vendor\\n    - device model\\n    - operating system\\n\\n    Not the most optimal.\\n    '\n    vendor = __grains__['vendor'].lower()\n    os_ = __grains__['os'].lower()\n    model = __grains__['model'].lower()\n    if vendor == 'juniper' and 'srx' in model:\n        return 'junipersrx'\n    elif vendor == 'cisco' and os_ == 'ios':\n        return 'cisco'\n    elif vendor == 'cisco' and os_ == 'iosxr':\n        return 'ciscoxr'\n    elif vendor == 'cisco' and os_ == 'asa':\n        return 'ciscoasa'\n    elif os_ == 'linux':\n        return 'iptables'\n    elif vendor == 'palo alto networks':\n        return 'paloaltofw'\n    return vendor",
            "def _get_capirca_platform():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given the following NAPALM grains, we can determine the Capirca platform name:\\n\\n    - vendor\\n    - device model\\n    - operating system\\n\\n    Not the most optimal.\\n    '\n    vendor = __grains__['vendor'].lower()\n    os_ = __grains__['os'].lower()\n    model = __grains__['model'].lower()\n    if vendor == 'juniper' and 'srx' in model:\n        return 'junipersrx'\n    elif vendor == 'cisco' and os_ == 'ios':\n        return 'cisco'\n    elif vendor == 'cisco' and os_ == 'iosxr':\n        return 'ciscoxr'\n    elif vendor == 'cisco' and os_ == 'asa':\n        return 'ciscoasa'\n    elif os_ == 'linux':\n        return 'iptables'\n    elif vendor == 'palo alto networks':\n        return 'paloaltofw'\n    return vendor",
            "def _get_capirca_platform():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given the following NAPALM grains, we can determine the Capirca platform name:\\n\\n    - vendor\\n    - device model\\n    - operating system\\n\\n    Not the most optimal.\\n    '\n    vendor = __grains__['vendor'].lower()\n    os_ = __grains__['os'].lower()\n    model = __grains__['model'].lower()\n    if vendor == 'juniper' and 'srx' in model:\n        return 'junipersrx'\n    elif vendor == 'cisco' and os_ == 'ios':\n        return 'cisco'\n    elif vendor == 'cisco' and os_ == 'iosxr':\n        return 'ciscoxr'\n    elif vendor == 'cisco' and os_ == 'asa':\n        return 'ciscoasa'\n    elif os_ == 'linux':\n        return 'iptables'\n    elif vendor == 'palo alto networks':\n        return 'paloaltofw'\n    return vendor"
        ]
    },
    {
        "func_name": "load_term_config",
        "original": "@proxy_napalm_wrap\ndef load_term_config(filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    \"\"\"\n    Generate and load the configuration of a policy term.\n\n    filter_name\n        The name of the policy filter.\n\n    term_name\n        The name of the term.\n\n    filter_options\n        Additional filter options. These options are platform-specific.\n        See the complete list of options_.\n\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\n\n    pillar_key: ``acl``\n        The key in the pillar containing the default attributes values. Default: ``acl``.\n        If the pillar contains the following structure:\n\n        .. code-block:: yaml\n\n            firewall:\n              - my-filter:\n                  terms:\n                    - my-term:\n                        source_port: 1234\n                        source_address:\n                            - 1.2.3.4/32\n                            - 5.6.7.8/32\n\n        The ``pillar_key`` field would be specified as ``firewall``.\n\n    pillarenv\n        Query the master to generate fresh pillar data on the fly,\n        specifically from the requested pillar environment.\n\n    saltenv\n        Included only for compatibility with\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\n\n    merge_pillar: ``True``\n        Merge the CLI variables with the pillar. Default: ``True``.\n\n        The properties specified through the CLI have higher priority than the pillar.\n\n    revision_id\n        Add a comment in the term config having the description for the changes applied.\n\n    revision_no\n        The revision count.\n\n    revision_date: ``True``\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\n\n    revision_date_format: ``%Y/%m/%d``\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\n        Default: ``False`` and will commit the changes on the device.\n\n    commit: ``True``\n        Commit? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key under the output dictionary,\n        as ``loaded_config`` containing the raw configuration loaded on the device.\n\n    source_service\n        A special service to choose from. This is a helper so the user is able to\n        select a source just using the name, instead of specifying a source_port and protocol.\n\n        As this module is available on Unix platforms only,\n        it reads the IANA_ port assignment from /etc/services.\n\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\n        which can be managed using the :mod:`file state <salt.states.file>`.\n\n        .. _IANA: http://www.iana.org/assignments/port-numbers\n\n    destination_service\n        A special service to choose from. This is a helper so the user is able to\n        select a source just using the name, instead of specifying a destination_port and protocol.\n        Allows the same options as ``source_service``.\n\n    term_fields\n        Term attributes. To see what fields are supported, please consult the\n        list of supported keywords_. Some platforms have a few other optional_\n        keywords.\n\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\n\n    .. note::\n        The following fields are accepted (some being platform-specific):\n\n        - action\n        - address\n        - address_exclude\n        - comment\n        - counter\n        - expiration\n        - destination_address\n        - destination_address_exclude\n        - destination_port\n        - destination_prefix\n        - forwarding_class\n        - forwarding_class_except\n        - logging\n        - log_name\n        - loss_priority\n        - option\n        - policer\n        - port\n        - precedence\n        - principals\n        - protocol\n        - protocol_except\n        - qos\n        - pan_application\n        - routing_instance\n        - source_address\n        - source_address_exclude\n        - source_port\n        - source_prefix\n        - verbatim\n        - packet_length\n        - fragment_offset\n        - hop_limit\n        - icmp_type\n        - ether_type\n        - traffic_class_count\n        - traffic_type\n        - translated\n        - dscp_set\n        - dscp_match\n        - dscp_except\n        - next_ip\n        - flexible_match_range\n        - source_prefix_except\n        - destination_prefix_except\n        - vpn\n        - source_tag\n        - destination_tag\n        - source_interface\n        - destination_interface\n        - flattened\n        - flattened_addr\n        - flattened_saddr\n        - flattened_daddr\n        - priority\n\n    .. note::\n        The following fields can be also a single value and a list of values:\n\n        - action\n        - address\n        - address_exclude\n        - comment\n        - destination_address\n        - destination_address_exclude\n        - destination_port\n        - destination_prefix\n        - forwarding_class\n        - forwarding_class_except\n        - logging\n        - option\n        - port\n        - precedence\n        - principals\n        - protocol\n        - protocol_except\n        - pan_application\n        - source_address\n        - source_address_exclude\n        - source_port\n        - source_prefix\n        - verbatim\n        - icmp_type\n        - ether_type\n        - traffic_type\n        - dscp_match\n        - dscp_except\n        - flexible_match_range\n        - source_prefix_except\n        - destination_prefix_except\n        - source_tag\n        - destination_tag\n        - source_service\n        - destination_service\n\n        Example: ``destination_address`` can be either defined as:\n\n        .. code-block:: yaml\n\n            destination_address: 172.17.17.1/24\n\n        or as a list of destination IP addresses:\n\n        .. code-block:: yaml\n\n            destination_address:\n                - 172.17.17.1/24\n                - 172.17.19.1/24\n\n        or a list of services to be matched:\n\n        .. code-block:: yaml\n\n            source_service:\n                - ntp\n                - snmp\n                - ldap\n                - bgpd\n\n    .. note::\n        The port fields ``source_port`` and ``destination_port`` can be used as above to select either\n        a single value, either a list of values, but also they can select port ranges. Example:\n\n        .. code-block:: yaml\n\n            source_port:\n                - - 1000\n                  - 2000\n                - - 3000\n                  - 4000\n\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\n\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt 'edge01.bjm01' netacl.load_term_config filter-name term-name source_address=1.2.3.4 destination_address=5.6.7.8 action=accept test=True debug=True\n\n    Output Example:\n\n    .. code-block:: jinja\n\n        edge01.bjm01:\n            ----------\n            already_configured:\n                False\n            comment:\n                Configuration discarded.\n            diff:\n                [edit firewall]\n                +    family inet {\n                +        /*\n                +         ** $Date: 2017/03/22 $\n                +         **\n                +         */\n                +        filter filter-name {\n                +            interface-specific;\n                +            term term-name {\n                +                from {\n                +                    source-address {\n                +                        1.2.3.4/32;\n                +                    }\n                +                    destination-address {\n                +                        5.6.7.8/32;\n                +                    }\n                +                }\n                +                then accept;\n                +            }\n                +        }\n                +    }\n            loaded_config:\n                firewall {\n                    family inet {\n                        replace:\n                        /*\n                        ** $Date: 2017/03/22 $\n                        **\n                        */\n                        filter filter-name {\n                            interface-specific;\n                            term term-name {\n                                from {\n                                    source-address {\n                                        1.2.3.4/32;\n                                    }\n                                    destination-address {\n                                        5.6.7.8/32;\n                                    }\n                                }\n                                then accept;\n                            }\n                        }\n                    }\n                }\n            result:\n                True\n    \"\"\"\n    if not filter_options:\n        filter_options = []\n    platform = _get_capirca_platform()\n    term_config = __salt__['capirca.get_term_config'](platform, filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, **term_fields)\n    return __salt__['net.load_config'](text=term_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
        "mutated": [
            "@proxy_napalm_wrap\ndef load_term_config(filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n    \"\\n    Generate and load the configuration of a policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n        If the pillar contains the following structure:\\n\\n        .. code-block:: yaml\\n\\n            firewall:\\n              - my-filter:\\n                  terms:\\n                    - my-term:\\n                        source_port: 1234\\n                        source_address:\\n                            - 1.2.3.4/32\\n                            - 5.6.7.8/32\\n\\n        The ``pillar_key`` field would be specified as ``firewall``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The properties specified through the CLI have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have a few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted (some being platform-specific):\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as above to select either\\n        a single value, either a list of values, but also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - - 1000\\n                  - 2000\\n                - - 3000\\n                  - 4000\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_term_config filter-name term-name source_address=1.2.3.4 destination_address=5.6.7.8 action=accept test=True debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter filter-name {\\n                +            interface-specific;\\n                +            term term-name {\\n                +                from {\\n                +                    source-address {\\n                +                        1.2.3.4/32;\\n                +                    }\\n                +                    destination-address {\\n                +                        5.6.7.8/32;\\n                +                    }\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter filter-name {\\n                            interface-specific;\\n                            term term-name {\\n                                from {\\n                                    source-address {\\n                                        1.2.3.4/32;\\n                                    }\\n                                    destination-address {\\n                                        5.6.7.8/32;\\n                                    }\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n    \"\n    if not filter_options:\n        filter_options = []\n    platform = _get_capirca_platform()\n    term_config = __salt__['capirca.get_term_config'](platform, filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, **term_fields)\n    return __salt__['net.load_config'](text=term_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_term_config(filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Generate and load the configuration of a policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n        If the pillar contains the following structure:\\n\\n        .. code-block:: yaml\\n\\n            firewall:\\n              - my-filter:\\n                  terms:\\n                    - my-term:\\n                        source_port: 1234\\n                        source_address:\\n                            - 1.2.3.4/32\\n                            - 5.6.7.8/32\\n\\n        The ``pillar_key`` field would be specified as ``firewall``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The properties specified through the CLI have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have a few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted (some being platform-specific):\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as above to select either\\n        a single value, either a list of values, but also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - - 1000\\n                  - 2000\\n                - - 3000\\n                  - 4000\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_term_config filter-name term-name source_address=1.2.3.4 destination_address=5.6.7.8 action=accept test=True debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter filter-name {\\n                +            interface-specific;\\n                +            term term-name {\\n                +                from {\\n                +                    source-address {\\n                +                        1.2.3.4/32;\\n                +                    }\\n                +                    destination-address {\\n                +                        5.6.7.8/32;\\n                +                    }\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter filter-name {\\n                            interface-specific;\\n                            term term-name {\\n                                from {\\n                                    source-address {\\n                                        1.2.3.4/32;\\n                                    }\\n                                    destination-address {\\n                                        5.6.7.8/32;\\n                                    }\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n    \"\n    if not filter_options:\n        filter_options = []\n    platform = _get_capirca_platform()\n    term_config = __salt__['capirca.get_term_config'](platform, filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, **term_fields)\n    return __salt__['net.load_config'](text=term_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_term_config(filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Generate and load the configuration of a policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n        If the pillar contains the following structure:\\n\\n        .. code-block:: yaml\\n\\n            firewall:\\n              - my-filter:\\n                  terms:\\n                    - my-term:\\n                        source_port: 1234\\n                        source_address:\\n                            - 1.2.3.4/32\\n                            - 5.6.7.8/32\\n\\n        The ``pillar_key`` field would be specified as ``firewall``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The properties specified through the CLI have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have a few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted (some being platform-specific):\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as above to select either\\n        a single value, either a list of values, but also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - - 1000\\n                  - 2000\\n                - - 3000\\n                  - 4000\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_term_config filter-name term-name source_address=1.2.3.4 destination_address=5.6.7.8 action=accept test=True debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter filter-name {\\n                +            interface-specific;\\n                +            term term-name {\\n                +                from {\\n                +                    source-address {\\n                +                        1.2.3.4/32;\\n                +                    }\\n                +                    destination-address {\\n                +                        5.6.7.8/32;\\n                +                    }\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter filter-name {\\n                            interface-specific;\\n                            term term-name {\\n                                from {\\n                                    source-address {\\n                                        1.2.3.4/32;\\n                                    }\\n                                    destination-address {\\n                                        5.6.7.8/32;\\n                                    }\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n    \"\n    if not filter_options:\n        filter_options = []\n    platform = _get_capirca_platform()\n    term_config = __salt__['capirca.get_term_config'](platform, filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, **term_fields)\n    return __salt__['net.load_config'](text=term_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_term_config(filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Generate and load the configuration of a policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n        If the pillar contains the following structure:\\n\\n        .. code-block:: yaml\\n\\n            firewall:\\n              - my-filter:\\n                  terms:\\n                    - my-term:\\n                        source_port: 1234\\n                        source_address:\\n                            - 1.2.3.4/32\\n                            - 5.6.7.8/32\\n\\n        The ``pillar_key`` field would be specified as ``firewall``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The properties specified through the CLI have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have a few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted (some being platform-specific):\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as above to select either\\n        a single value, either a list of values, but also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - - 1000\\n                  - 2000\\n                - - 3000\\n                  - 4000\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_term_config filter-name term-name source_address=1.2.3.4 destination_address=5.6.7.8 action=accept test=True debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter filter-name {\\n                +            interface-specific;\\n                +            term term-name {\\n                +                from {\\n                +                    source-address {\\n                +                        1.2.3.4/32;\\n                +                    }\\n                +                    destination-address {\\n                +                        5.6.7.8/32;\\n                +                    }\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter filter-name {\\n                            interface-specific;\\n                            term term-name {\\n                                from {\\n                                    source-address {\\n                                        1.2.3.4/32;\\n                                    }\\n                                    destination-address {\\n                                        5.6.7.8/32;\\n                                    }\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n    \"\n    if not filter_options:\n        filter_options = []\n    platform = _get_capirca_platform()\n    term_config = __salt__['capirca.get_term_config'](platform, filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, **term_fields)\n    return __salt__['net.load_config'](text=term_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_term_config(filter_name, term_name, filter_options=None, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, source_service=None, destination_service=None, **term_fields):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Generate and load the configuration of a policy term.\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n        If the pillar contains the following structure:\\n\\n        .. code-block:: yaml\\n\\n            firewall:\\n              - my-filter:\\n                  terms:\\n                    - my-term:\\n                        source_port: 1234\\n                        source_address:\\n                            - 1.2.3.4/32\\n                            - 5.6.7.8/32\\n\\n        The ``pillar_key`` field would be specified as ``firewall``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The properties specified through the CLI have higher priority than the pillar.\\n\\n    revision_id\\n        Add a comment in the term config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the term configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    source_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a source_port and protocol.\\n\\n        As this module is available on Unix platforms only,\\n        it reads the IANA_ port assignment from /etc/services.\\n\\n        If the user requires additional shortcuts to be referenced, they can add entries under /etc/services,\\n        which can be managed using the :mod:`file state <salt.states.file>`.\\n\\n        .. _IANA: http://www.iana.org/assignments/port-numbers\\n\\n    destination_service\\n        A special service to choose from. This is a helper so the user is able to\\n        select a source just using the name, instead of specifying a destination_port and protocol.\\n        Allows the same options as ``source_service``.\\n\\n    term_fields\\n        Term attributes. To see what fields are supported, please consult the\\n        list of supported keywords_. Some platforms have a few other optional_\\n        keywords.\\n\\n        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords\\n        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords\\n\\n    .. note::\\n        The following fields are accepted (some being platform-specific):\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - counter\\n        - expiration\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - log_name\\n        - loss_priority\\n        - option\\n        - policer\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - qos\\n        - pan_application\\n        - routing_instance\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - packet_length\\n        - fragment_offset\\n        - hop_limit\\n        - icmp_type\\n        - ether_type\\n        - traffic_class_count\\n        - traffic_type\\n        - translated\\n        - dscp_set\\n        - dscp_match\\n        - dscp_except\\n        - next_ip\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - vpn\\n        - source_tag\\n        - destination_tag\\n        - source_interface\\n        - destination_interface\\n        - flattened\\n        - flattened_addr\\n        - flattened_saddr\\n        - flattened_daddr\\n        - priority\\n\\n    .. note::\\n        The following fields can be also a single value and a list of values:\\n\\n        - action\\n        - address\\n        - address_exclude\\n        - comment\\n        - destination_address\\n        - destination_address_exclude\\n        - destination_port\\n        - destination_prefix\\n        - forwarding_class\\n        - forwarding_class_except\\n        - logging\\n        - option\\n        - port\\n        - precedence\\n        - principals\\n        - protocol\\n        - protocol_except\\n        - pan_application\\n        - source_address\\n        - source_address_exclude\\n        - source_port\\n        - source_prefix\\n        - verbatim\\n        - icmp_type\\n        - ether_type\\n        - traffic_type\\n        - dscp_match\\n        - dscp_except\\n        - flexible_match_range\\n        - source_prefix_except\\n        - destination_prefix_except\\n        - source_tag\\n        - destination_tag\\n        - source_service\\n        - destination_service\\n\\n        Example: ``destination_address`` can be either defined as:\\n\\n        .. code-block:: yaml\\n\\n            destination_address: 172.17.17.1/24\\n\\n        or as a list of destination IP addresses:\\n\\n        .. code-block:: yaml\\n\\n            destination_address:\\n                - 172.17.17.1/24\\n                - 172.17.19.1/24\\n\\n        or a list of services to be matched:\\n\\n        .. code-block:: yaml\\n\\n            source_service:\\n                - ntp\\n                - snmp\\n                - ldap\\n                - bgpd\\n\\n    .. note::\\n        The port fields ``source_port`` and ``destination_port`` can be used as above to select either\\n        a single value, either a list of values, but also they can select port ranges. Example:\\n\\n        .. code-block:: yaml\\n\\n            source_port:\\n                - - 1000\\n                  - 2000\\n                - - 3000\\n                  - 4000\\n\\n        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_term_config filter-name term-name source_address=1.2.3.4 destination_address=5.6.7.8 action=accept test=True debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n                Configuration discarded.\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter filter-name {\\n                +            interface-specific;\\n                +            term term-name {\\n                +                from {\\n                +                    source-address {\\n                +                        1.2.3.4/32;\\n                +                    }\\n                +                    destination-address {\\n                +                        5.6.7.8/32;\\n                +                    }\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter filter-name {\\n                            interface-specific;\\n                            term term-name {\\n                                from {\\n                                    source-address {\\n                                        1.2.3.4/32;\\n                                    }\\n                                    destination-address {\\n                                        5.6.7.8/32;\\n                                    }\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n    \"\n    if not filter_options:\n        filter_options = []\n    platform = _get_capirca_platform()\n    term_config = __salt__['capirca.get_term_config'](platform, filter_name, term_name, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format, source_service=source_service, destination_service=destination_service, **term_fields)\n    return __salt__['net.load_config'](text=term_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)"
        ]
    },
    {
        "func_name": "load_filter_config",
        "original": "@proxy_napalm_wrap\ndef load_filter_config(filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    \"\"\"\n    Generate and load the configuration of a policy filter.\n\n    .. note::\n\n        The order of the terms is very important. The configuration loaded\n        on the device respects the order defined in the ``terms`` and/or\n        inside the pillar.\n\n        When merging the ``terms`` with the pillar data, consider the\n        ``prepend`` argument to make sure the order is correct!\n\n    filter_name\n        The name of the policy filter.\n\n    filter_options\n        Additional filter options. These options are platform-specific.\n        See the complete list of options_.\n\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\n\n    terms\n        List of terms for this policy filter.\n        If not specified or empty, will try to load the configuration from the pillar,\n        unless ``merge_pillar`` is set as ``False``.\n\n    prepend: ``True``\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\n        at the beginning, while existing ones will preserve the position. To add the new terms\n        at the end of the list, set this argument to ``False``.\n\n    pillar_key: ``acl``\n        The key in the pillar containing the default attributes values. Default: ``acl``.\n\n    pillarenv\n        Query the master to generate fresh pillar data on the fly,\n        specifically from the requested pillar environment.\n\n    saltenv\n        Included only for compatibility with\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\n\n    merge_pillar: ``True``\n        Merge the CLI variables with the pillar. Default: ``True``.\n\n        The merge logic depends on the ``prepend`` argument and\n        the CLI has higher priority than the pillar.\n\n    only_lower_merge: ``False``\n        Specify if it should merge only the terms fields. Otherwise it will try\n        to merge also filters fields. Default: ``False``.\n        This option requires ``merge_pillar``, otherwise it is ignored.\n\n    revision_id\n        Add a comment in the filter config having the description for the changes applied.\n\n    revision_no\n        The revision count.\n\n    revision_date: ``True``\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\n\n    revision_date_format: ``%Y/%m/%d``\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\n        Default: ``False`` and will commit the changes on the device.\n\n    commit: ``True``\n        Commit? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key under the output dictionary,\n        as ``loaded_config`` containing the raw configuration loaded on the device.\n\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt 'edge01.bjm01' netacl.load_filter_config my-filter pillar_key=netacl debug=True\n\n    Output Example:\n\n    .. code-block:: jinja\n\n        edge01.bjm01:\n            ----------\n            already_configured:\n                False\n            comment:\n            diff:\n                [edit firewall]\n                +    family inet {\n                +        /*\n                +         ** $Date: 2017/03/22 $\n                +         **\n                +         */\n                +        filter my-filter {\n                +            interface-specific;\n                +            term my-term {\n                +                from {\n                +                    source-port [ 1234 1235 ];\n                +                }\n                +                then {\n                +                    reject;\n                +                }\n                +            }\n                +            term my-other-term {\n                +                from {\n                +                    protocol tcp;\n                +                    source-port 5678-5680;\n                +                }\n                +                then accept;\n                +            }\n                +        }\n                +    }\n            loaded_config:\n                firewall {\n                    family inet {\n                        replace:\n                        /*\n                        ** $Date: 2017/03/22 $\n                        **\n                        */\n                        filter my-filter {\n                            interface-specific;\n                            term my-term {\n                                from {\n                                    source-port [ 1234 1235 ];\n                                }\n                                then {\n                                    reject;\n                                }\n                            }\n                            term my-other-term {\n                                from {\n                                    protocol tcp;\n                                    source-port 5678-5680;\n                                }\n                                then accept;\n                            }\n                        }\n                    }\n                }\n            result:\n                True\n\n    The filter configuration has been loaded from the pillar, having the following structure:\n\n    .. code-block:: yaml\n\n        netacl:\n          - my-filter:\n              terms:\n                - my-term:\n                    source_port:\n                     - 1234\n                     - 1235\n                    action: reject\n                - my-other-term:\n                    source_port:\n                      - - 5678\n                        - 5680\n                    protocol: tcp\n                    action: accept\n    \"\"\"\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    platform = _get_capirca_platform()\n    filter_config = __salt__['capirca.get_filter_config'](platform, filter_name, terms=terms, prepend=prepend, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=filter_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
        "mutated": [
            "@proxy_napalm_wrap\ndef load_filter_config(filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    .. note::\\n\\n        The order of the terms is very important. The configuration loaded\\n        on the device respects the order defined in the ``terms`` and/or\\n        inside the pillar.\\n\\n        When merging the ``terms`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        List of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_filter_config my-filter pillar_key=netacl debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter my-filter {\\n                +            interface-specific;\\n                +            term my-term {\\n                +                from {\\n                +                    source-port [ 1234 1235 ];\\n                +                }\\n                +                then {\\n                +                    reject;\\n                +                }\\n                +            }\\n                +            term my-other-term {\\n                +                from {\\n                +                    protocol tcp;\\n                +                    source-port 5678-5680;\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter my-filter {\\n                            interface-specific;\\n                            term my-term {\\n                                from {\\n                                    source-port [ 1234 1235 ];\\n                                }\\n                                then {\\n                                    reject;\\n                                }\\n                            }\\n                            term my-other-term {\\n                                from {\\n                                    protocol tcp;\\n                                    source-port 5678-5680;\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n\\n    The filter configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        netacl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - - 5678\\n                        - 5680\\n                    protocol: tcp\\n                    action: accept\\n    \"\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    platform = _get_capirca_platform()\n    filter_config = __salt__['capirca.get_filter_config'](platform, filter_name, terms=terms, prepend=prepend, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=filter_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_filter_config(filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    .. note::\\n\\n        The order of the terms is very important. The configuration loaded\\n        on the device respects the order defined in the ``terms`` and/or\\n        inside the pillar.\\n\\n        When merging the ``terms`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        List of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_filter_config my-filter pillar_key=netacl debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter my-filter {\\n                +            interface-specific;\\n                +            term my-term {\\n                +                from {\\n                +                    source-port [ 1234 1235 ];\\n                +                }\\n                +                then {\\n                +                    reject;\\n                +                }\\n                +            }\\n                +            term my-other-term {\\n                +                from {\\n                +                    protocol tcp;\\n                +                    source-port 5678-5680;\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter my-filter {\\n                            interface-specific;\\n                            term my-term {\\n                                from {\\n                                    source-port [ 1234 1235 ];\\n                                }\\n                                then {\\n                                    reject;\\n                                }\\n                            }\\n                            term my-other-term {\\n                                from {\\n                                    protocol tcp;\\n                                    source-port 5678-5680;\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n\\n    The filter configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        netacl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - - 5678\\n                        - 5680\\n                    protocol: tcp\\n                    action: accept\\n    \"\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    platform = _get_capirca_platform()\n    filter_config = __salt__['capirca.get_filter_config'](platform, filter_name, terms=terms, prepend=prepend, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=filter_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_filter_config(filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    .. note::\\n\\n        The order of the terms is very important. The configuration loaded\\n        on the device respects the order defined in the ``terms`` and/or\\n        inside the pillar.\\n\\n        When merging the ``terms`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        List of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_filter_config my-filter pillar_key=netacl debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter my-filter {\\n                +            interface-specific;\\n                +            term my-term {\\n                +                from {\\n                +                    source-port [ 1234 1235 ];\\n                +                }\\n                +                then {\\n                +                    reject;\\n                +                }\\n                +            }\\n                +            term my-other-term {\\n                +                from {\\n                +                    protocol tcp;\\n                +                    source-port 5678-5680;\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter my-filter {\\n                            interface-specific;\\n                            term my-term {\\n                                from {\\n                                    source-port [ 1234 1235 ];\\n                                }\\n                                then {\\n                                    reject;\\n                                }\\n                            }\\n                            term my-other-term {\\n                                from {\\n                                    protocol tcp;\\n                                    source-port 5678-5680;\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n\\n    The filter configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        netacl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - - 5678\\n                        - 5680\\n                    protocol: tcp\\n                    action: accept\\n    \"\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    platform = _get_capirca_platform()\n    filter_config = __salt__['capirca.get_filter_config'](platform, filter_name, terms=terms, prepend=prepend, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=filter_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_filter_config(filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    .. note::\\n\\n        The order of the terms is very important. The configuration loaded\\n        on the device respects the order defined in the ``terms`` and/or\\n        inside the pillar.\\n\\n        When merging the ``terms`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        List of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_filter_config my-filter pillar_key=netacl debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter my-filter {\\n                +            interface-specific;\\n                +            term my-term {\\n                +                from {\\n                +                    source-port [ 1234 1235 ];\\n                +                }\\n                +                then {\\n                +                    reject;\\n                +                }\\n                +            }\\n                +            term my-other-term {\\n                +                from {\\n                +                    protocol tcp;\\n                +                    source-port 5678-5680;\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter my-filter {\\n                            interface-specific;\\n                            term my-term {\\n                                from {\\n                                    source-port [ 1234 1235 ];\\n                                }\\n                                then {\\n                                    reject;\\n                                }\\n                            }\\n                            term my-other-term {\\n                                from {\\n                                    protocol tcp;\\n                                    source-port 5678-5680;\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n\\n    The filter configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        netacl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - - 5678\\n                        - 5680\\n                    protocol: tcp\\n                    action: accept\\n    \"\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    platform = _get_capirca_platform()\n    filter_config = __salt__['capirca.get_filter_config'](platform, filter_name, terms=terms, prepend=prepend, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=filter_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_filter_config(filter_name, filter_options=None, terms=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Generate and load the configuration of a policy filter.\\n\\n    .. note::\\n\\n        The order of the terms is very important. The configuration loaded\\n        on the device respects the order defined in the ``terms`` and/or\\n        inside the pillar.\\n\\n        When merging the ``terms`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filter_name\\n        The name of the policy filter.\\n\\n    filter_options\\n        Additional filter options. These options are platform-specific.\\n        See the complete list of options_.\\n\\n        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section\\n\\n    terms\\n        List of terms for this policy filter.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging\\n        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new terms\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the terms fields. Otherwise it will try\\n        to merge also filters fields. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the filter config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.bjm01' netacl.load_filter_config my-filter pillar_key=netacl debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: jinja\\n\\n        edge01.bjm01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                [edit firewall]\\n                +    family inet {\\n                +        /*\\n                +         ** $Date: 2017/03/22 $\\n                +         **\\n                +         */\\n                +        filter my-filter {\\n                +            interface-specific;\\n                +            term my-term {\\n                +                from {\\n                +                    source-port [ 1234 1235 ];\\n                +                }\\n                +                then {\\n                +                    reject;\\n                +                }\\n                +            }\\n                +            term my-other-term {\\n                +                from {\\n                +                    protocol tcp;\\n                +                    source-port 5678-5680;\\n                +                }\\n                +                then accept;\\n                +            }\\n                +        }\\n                +    }\\n            loaded_config:\\n                firewall {\\n                    family inet {\\n                        replace:\\n                        /*\\n                        ** $Date: 2017/03/22 $\\n                        **\\n                        */\\n                        filter my-filter {\\n                            interface-specific;\\n                            term my-term {\\n                                from {\\n                                    source-port [ 1234 1235 ];\\n                                }\\n                                then {\\n                                    reject;\\n                                }\\n                            }\\n                            term my-other-term {\\n                                from {\\n                                    protocol tcp;\\n                                    source-port 5678-5680;\\n                                }\\n                                then accept;\\n                            }\\n                        }\\n                    }\\n                }\\n            result:\\n                True\\n\\n    The filter configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        netacl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - - 5678\\n                        - 5680\\n                    protocol: tcp\\n                    action: accept\\n    \"\n    if not filter_options:\n        filter_options = []\n    if not terms:\n        terms = []\n    platform = _get_capirca_platform()\n    filter_config = __salt__['capirca.get_filter_config'](platform, filter_name, terms=terms, prepend=prepend, filter_options=filter_options, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=filter_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)"
        ]
    },
    {
        "func_name": "load_policy_config",
        "original": "@proxy_napalm_wrap\ndef load_policy_config(filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    \"\"\"\n    Generate and load the configuration of the whole policy.\n\n    .. note::\n\n        The order of the filters and their terms is very important.\n        The configuration loaded on the device respects the order\n        defined in the ``filters`` and/or inside the pillar.\n\n        When merging the ``filters`` with the pillar data, consider the\n        ``prepend`` argument to make sure the order is correct!\n\n    filters\n        List of filters for this policy.\n        If not specified or empty, will try to load the configuration from the pillar,\n        unless ``merge_pillar`` is set as ``False``.\n\n    prepend: ``True``\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\n        at the beginning, while existing ones will preserve the position. To add the new filters\n        at the end of the list, set this argument to ``False``.\n\n    pillar_key: ``acl``\n        The key in the pillar containing the default attributes values. Default: ``acl``.\n\n    pillarenv\n        Query the master to generate fresh pillar data on the fly,\n        specifically from the requested pillar environment.\n\n    saltenv\n        Included only for compatibility with\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\n\n    merge_pillar: ``True``\n        Merge the CLI variables with the pillar. Default: ``True``.\n\n        The merge logic depends on the ``prepend`` argument and\n        the CLI has higher priority than the pillar.\n\n    only_lower_merge: ``False``\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\n        to merge everything at the policy level. Default: ``False``.\n        This option requires ``merge_pillar``, otherwise it is ignored.\n\n    revision_id\n        Add a comment in the policy config having the description for the changes applied.\n\n    revision_no\n        The revision count.\n\n    revision_date: ``True``\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\n\n    revision_date_format: ``%Y/%m/%d``\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\n        Default: ``False`` and will commit the changes on the device.\n\n    commit: ``True``\n        Commit? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key under the output dictionary,\n        as ``loaded_config`` containing the raw configuration loaded on the device.\n\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt 'edge01.flw01' netacl.load_policy_config debug=True\n\n    Output Example:\n\n    .. code-block:: text\n\n        edge01.flw01:\n            ----------\n            already_configured:\n                False\n            comment:\n            diff:\n                ---\n                +++\n                @@ -1228,9 +1228,24 @@\n                 !\n                +ipv4 access-list my-filter\n                + 10 remark my-term\n                + 20 deny tcp host 1.2.3.4 eq 1234 any\n                + 30 deny udp host 1.2.3.4 eq 1234 any\n                + 40 deny tcp host 1.2.3.4 eq 1235 any\n                + 50 deny udp host 1.2.3.4 eq 1235 any\n                + 60 remark my-other-term\n                + 70 permit tcp any range 5678 5680 any\n                +!\n                +!\n                +ipv4 access-list block-icmp\n                + 10 remark first-term\n                + 20 deny icmp any any\n                 !\n            loaded_config:\n                ! $Date: 2017/03/22 $\n                no ipv4 access-list my-filter\n                ipv4 access-list my-filter\n                 remark my-term\n                 deny tcp host 1.2.3.4 eq 1234 any\n                 deny udp host 1.2.3.4 eq 1234 any\n                 deny tcp host 1.2.3.4 eq 1235 any\n                 deny udp host 1.2.3.4 eq 1235 any\n                 remark my-other-term\n                 permit tcp any range 5678 5680 any\n                exit\n                no ipv4 access-list block-icmp\n                ipv4 access-list block-icmp\n                 remark first-term\n                 deny icmp any any\n                exit\n            result:\n                True\n\n    The policy configuration has been loaded from the pillar, having the following structure:\n\n    .. code-block:: yaml\n\n        acl:\n          - my-filter:\n              terms:\n                - my-term:\n                    source_port:\n                     - 1234\n                     - 1235\n                    protocol:\n                      - tcp\n                      - udp\n                    source_address: 1.2.3.4\n                    action: reject\n                - my-other-term:\n                    source_port:\n                      - [5678, 5680]\n                    protocol: tcp\n                    action: accept\n          - block-icmp:\n              terms:\n                - first-term:\n                    protocol:\n                      - icmp\n                    action: reject\n    \"\"\"\n    if not filters:\n        filters = []\n    platform = _get_capirca_platform()\n    policy_config = __salt__['capirca.get_policy_config'](platform, filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=policy_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
        "mutated": [
            "@proxy_napalm_wrap\ndef load_policy_config(filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Generate and load the configuration of the whole policy.\\n\\n    .. note::\\n\\n        The order of the filters and their terms is very important.\\n        The configuration loaded on the device respects the order\\n        defined in the ``filters`` and/or inside the pillar.\\n\\n        When merging the ``filters`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filters\\n        List of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' netacl.load_policy_config debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                ---\\n                +++\\n                @@ -1228,9 +1228,24 @@\\n                 !\\n                +ipv4 access-list my-filter\\n                + 10 remark my-term\\n                + 20 deny tcp host 1.2.3.4 eq 1234 any\\n                + 30 deny udp host 1.2.3.4 eq 1234 any\\n                + 40 deny tcp host 1.2.3.4 eq 1235 any\\n                + 50 deny udp host 1.2.3.4 eq 1235 any\\n                + 60 remark my-other-term\\n                + 70 permit tcp any range 5678 5680 any\\n                +!\\n                +!\\n                +ipv4 access-list block-icmp\\n                + 10 remark first-term\\n                + 20 deny icmp any any\\n                 !\\n            loaded_config:\\n                ! $Date: 2017/03/22 $\\n                no ipv4 access-list my-filter\\n                ipv4 access-list my-filter\\n                 remark my-term\\n                 deny tcp host 1.2.3.4 eq 1234 any\\n                 deny udp host 1.2.3.4 eq 1234 any\\n                 deny tcp host 1.2.3.4 eq 1235 any\\n                 deny udp host 1.2.3.4 eq 1235 any\\n                 remark my-other-term\\n                 permit tcp any range 5678 5680 any\\n                exit\\n                no ipv4 access-list block-icmp\\n                ipv4 access-list block-icmp\\n                 remark first-term\\n                 deny icmp any any\\n                exit\\n            result:\\n                True\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n    \"\n    if not filters:\n        filters = []\n    platform = _get_capirca_platform()\n    policy_config = __salt__['capirca.get_policy_config'](platform, filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=policy_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_policy_config(filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Generate and load the configuration of the whole policy.\\n\\n    .. note::\\n\\n        The order of the filters and their terms is very important.\\n        The configuration loaded on the device respects the order\\n        defined in the ``filters`` and/or inside the pillar.\\n\\n        When merging the ``filters`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filters\\n        List of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' netacl.load_policy_config debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                ---\\n                +++\\n                @@ -1228,9 +1228,24 @@\\n                 !\\n                +ipv4 access-list my-filter\\n                + 10 remark my-term\\n                + 20 deny tcp host 1.2.3.4 eq 1234 any\\n                + 30 deny udp host 1.2.3.4 eq 1234 any\\n                + 40 deny tcp host 1.2.3.4 eq 1235 any\\n                + 50 deny udp host 1.2.3.4 eq 1235 any\\n                + 60 remark my-other-term\\n                + 70 permit tcp any range 5678 5680 any\\n                +!\\n                +!\\n                +ipv4 access-list block-icmp\\n                + 10 remark first-term\\n                + 20 deny icmp any any\\n                 !\\n            loaded_config:\\n                ! $Date: 2017/03/22 $\\n                no ipv4 access-list my-filter\\n                ipv4 access-list my-filter\\n                 remark my-term\\n                 deny tcp host 1.2.3.4 eq 1234 any\\n                 deny udp host 1.2.3.4 eq 1234 any\\n                 deny tcp host 1.2.3.4 eq 1235 any\\n                 deny udp host 1.2.3.4 eq 1235 any\\n                 remark my-other-term\\n                 permit tcp any range 5678 5680 any\\n                exit\\n                no ipv4 access-list block-icmp\\n                ipv4 access-list block-icmp\\n                 remark first-term\\n                 deny icmp any any\\n                exit\\n            result:\\n                True\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n    \"\n    if not filters:\n        filters = []\n    platform = _get_capirca_platform()\n    policy_config = __salt__['capirca.get_policy_config'](platform, filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=policy_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_policy_config(filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Generate and load the configuration of the whole policy.\\n\\n    .. note::\\n\\n        The order of the filters and their terms is very important.\\n        The configuration loaded on the device respects the order\\n        defined in the ``filters`` and/or inside the pillar.\\n\\n        When merging the ``filters`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filters\\n        List of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' netacl.load_policy_config debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                ---\\n                +++\\n                @@ -1228,9 +1228,24 @@\\n                 !\\n                +ipv4 access-list my-filter\\n                + 10 remark my-term\\n                + 20 deny tcp host 1.2.3.4 eq 1234 any\\n                + 30 deny udp host 1.2.3.4 eq 1234 any\\n                + 40 deny tcp host 1.2.3.4 eq 1235 any\\n                + 50 deny udp host 1.2.3.4 eq 1235 any\\n                + 60 remark my-other-term\\n                + 70 permit tcp any range 5678 5680 any\\n                +!\\n                +!\\n                +ipv4 access-list block-icmp\\n                + 10 remark first-term\\n                + 20 deny icmp any any\\n                 !\\n            loaded_config:\\n                ! $Date: 2017/03/22 $\\n                no ipv4 access-list my-filter\\n                ipv4 access-list my-filter\\n                 remark my-term\\n                 deny tcp host 1.2.3.4 eq 1234 any\\n                 deny udp host 1.2.3.4 eq 1234 any\\n                 deny tcp host 1.2.3.4 eq 1235 any\\n                 deny udp host 1.2.3.4 eq 1235 any\\n                 remark my-other-term\\n                 permit tcp any range 5678 5680 any\\n                exit\\n                no ipv4 access-list block-icmp\\n                ipv4 access-list block-icmp\\n                 remark first-term\\n                 deny icmp any any\\n                exit\\n            result:\\n                True\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n    \"\n    if not filters:\n        filters = []\n    platform = _get_capirca_platform()\n    policy_config = __salt__['capirca.get_policy_config'](platform, filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=policy_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_policy_config(filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Generate and load the configuration of the whole policy.\\n\\n    .. note::\\n\\n        The order of the filters and their terms is very important.\\n        The configuration loaded on the device respects the order\\n        defined in the ``filters`` and/or inside the pillar.\\n\\n        When merging the ``filters`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filters\\n        List of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' netacl.load_policy_config debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                ---\\n                +++\\n                @@ -1228,9 +1228,24 @@\\n                 !\\n                +ipv4 access-list my-filter\\n                + 10 remark my-term\\n                + 20 deny tcp host 1.2.3.4 eq 1234 any\\n                + 30 deny udp host 1.2.3.4 eq 1234 any\\n                + 40 deny tcp host 1.2.3.4 eq 1235 any\\n                + 50 deny udp host 1.2.3.4 eq 1235 any\\n                + 60 remark my-other-term\\n                + 70 permit tcp any range 5678 5680 any\\n                +!\\n                +!\\n                +ipv4 access-list block-icmp\\n                + 10 remark first-term\\n                + 20 deny icmp any any\\n                 !\\n            loaded_config:\\n                ! $Date: 2017/03/22 $\\n                no ipv4 access-list my-filter\\n                ipv4 access-list my-filter\\n                 remark my-term\\n                 deny tcp host 1.2.3.4 eq 1234 any\\n                 deny udp host 1.2.3.4 eq 1234 any\\n                 deny tcp host 1.2.3.4 eq 1235 any\\n                 deny udp host 1.2.3.4 eq 1235 any\\n                 remark my-other-term\\n                 permit tcp any range 5678 5680 any\\n                exit\\n                no ipv4 access-list block-icmp\\n                ipv4 access-list block-icmp\\n                 remark first-term\\n                 deny icmp any any\\n                exit\\n            result:\\n                True\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n    \"\n    if not filters:\n        filters = []\n    platform = _get_capirca_platform()\n    policy_config = __salt__['capirca.get_policy_config'](platform, filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=policy_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)",
            "@proxy_napalm_wrap\ndef load_policy_config(filters=None, prepend=True, pillar_key='acl', pillarenv=None, saltenv=None, merge_pillar=True, only_lower_merge=False, revision_id=None, revision_no=None, revision_date=True, revision_date_format='%Y/%m/%d', test=False, commit=True, debug=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Generate and load the configuration of the whole policy.\\n\\n    .. note::\\n\\n        The order of the filters and their terms is very important.\\n        The configuration loaded on the device respects the order\\n        defined in the ``filters`` and/or inside the pillar.\\n\\n        When merging the ``filters`` with the pillar data, consider the\\n        ``prepend`` argument to make sure the order is correct!\\n\\n    filters\\n        List of filters for this policy.\\n        If not specified or empty, will try to load the configuration from the pillar,\\n        unless ``merge_pillar`` is set as ``False``.\\n\\n    prepend: ``True``\\n        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging\\n        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended\\n        at the beginning, while existing ones will preserve the position. To add the new filters\\n        at the end of the list, set this argument to ``False``.\\n\\n    pillar_key: ``acl``\\n        The key in the pillar containing the default attributes values. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n\\n    merge_pillar: ``True``\\n        Merge the CLI variables with the pillar. Default: ``True``.\\n\\n        The merge logic depends on the ``prepend`` argument and\\n        the CLI has higher priority than the pillar.\\n\\n    only_lower_merge: ``False``\\n        Specify if it should merge only the filters and terms fields. Otherwise it will try\\n        to merge everything at the policy level. Default: ``False``.\\n        This option requires ``merge_pillar``, otherwise it is ignored.\\n\\n    revision_id\\n        Add a comment in the policy config having the description for the changes applied.\\n\\n    revision_no\\n        The revision count.\\n\\n    revision_date: ``True``\\n        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.\\n\\n    revision_date_format: ``%Y/%m/%d``\\n        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (<year>/<month>/<day>).\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return the changes.\\n        Default: ``False`` and will commit the changes on the device.\\n\\n    commit: ``True``\\n        Commit? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key under the output dictionary,\\n        as ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    The output is a dictionary having the same form as :mod:`net.load_config <salt.modules.napalm_network.load_config>`.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt 'edge01.flw01' netacl.load_policy_config debug=True\\n\\n    Output Example:\\n\\n    .. code-block:: text\\n\\n        edge01.flw01:\\n            ----------\\n            already_configured:\\n                False\\n            comment:\\n            diff:\\n                ---\\n                +++\\n                @@ -1228,9 +1228,24 @@\\n                 !\\n                +ipv4 access-list my-filter\\n                + 10 remark my-term\\n                + 20 deny tcp host 1.2.3.4 eq 1234 any\\n                + 30 deny udp host 1.2.3.4 eq 1234 any\\n                + 40 deny tcp host 1.2.3.4 eq 1235 any\\n                + 50 deny udp host 1.2.3.4 eq 1235 any\\n                + 60 remark my-other-term\\n                + 70 permit tcp any range 5678 5680 any\\n                +!\\n                +!\\n                +ipv4 access-list block-icmp\\n                + 10 remark first-term\\n                + 20 deny icmp any any\\n                 !\\n            loaded_config:\\n                ! $Date: 2017/03/22 $\\n                no ipv4 access-list my-filter\\n                ipv4 access-list my-filter\\n                 remark my-term\\n                 deny tcp host 1.2.3.4 eq 1234 any\\n                 deny udp host 1.2.3.4 eq 1234 any\\n                 deny tcp host 1.2.3.4 eq 1235 any\\n                 deny udp host 1.2.3.4 eq 1235 any\\n                 remark my-other-term\\n                 permit tcp any range 5678 5680 any\\n                exit\\n                no ipv4 access-list block-icmp\\n                ipv4 access-list block-icmp\\n                 remark first-term\\n                 deny icmp any any\\n                exit\\n            result:\\n                True\\n\\n    The policy configuration has been loaded from the pillar, having the following structure:\\n\\n    .. code-block:: yaml\\n\\n        acl:\\n          - my-filter:\\n              terms:\\n                - my-term:\\n                    source_port:\\n                     - 1234\\n                     - 1235\\n                    protocol:\\n                      - tcp\\n                      - udp\\n                    source_address: 1.2.3.4\\n                    action: reject\\n                - my-other-term:\\n                    source_port:\\n                      - [5678, 5680]\\n                    protocol: tcp\\n                    action: accept\\n          - block-icmp:\\n              terms:\\n                - first-term:\\n                    protocol:\\n                      - icmp\\n                    action: reject\\n    \"\n    if not filters:\n        filters = []\n    platform = _get_capirca_platform()\n    policy_config = __salt__['capirca.get_policy_config'](platform, filters=filters, prepend=prepend, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv, merge_pillar=merge_pillar, only_lower_merge=only_lower_merge, revision_id=revision_id, revision_no=revision_no, revision_date=revision_date, revision_date_format=revision_date_format)\n    return __salt__['net.load_config'](text=policy_config, test=test, commit=commit, debug=debug, inherit_napalm_device=napalm_device)"
        ]
    },
    {
        "func_name": "get_filter_pillar",
        "original": "def get_filter_pillar(filter_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    \"\"\"\n    Helper that can be used inside a state SLS,\n    in order to get the filter configuration given its name.\n\n    filter_name\n        The name of the filter.\n\n    pillar_key\n        The root key of the whole policy config.\n\n    pillarenv\n        Query the master to generate fresh pillar data on the fly,\n        specifically from the requested pillar environment.\n\n    saltenv\n        Included only for compatibility with\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\n    \"\"\"\n    return __salt__['capirca.get_filter_pillar'](filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
        "mutated": [
            "def get_filter_pillar(filter_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the filter configuration given its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    pillar_key\\n        The root key of the whole policy config.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_filter_pillar'](filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
            "def get_filter_pillar(filter_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the filter configuration given its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    pillar_key\\n        The root key of the whole policy config.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_filter_pillar'](filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
            "def get_filter_pillar(filter_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the filter configuration given its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    pillar_key\\n        The root key of the whole policy config.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_filter_pillar'](filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
            "def get_filter_pillar(filter_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the filter configuration given its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    pillar_key\\n        The root key of the whole policy config.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_filter_pillar'](filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
            "def get_filter_pillar(filter_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the filter configuration given its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    pillar_key\\n        The root key of the whole policy config.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_filter_pillar'](filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)"
        ]
    },
    {
        "func_name": "get_term_pillar",
        "original": "def get_term_pillar(filter_name, term_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    \"\"\"\n    Helper that can be used inside a state SLS,\n    in order to get the term configuration given its name,\n    under a certain filter uniquely identified by its name.\n\n    filter_name\n        The name of the filter.\n\n    term_name\n        The name of the term.\n\n    pillar_key: ``acl``\n        The root key of the whole policy config. Default: ``acl``.\n\n    pillarenv\n        Query the master to generate fresh pillar data on the fly,\n        specifically from the requested pillar environment.\n\n    saltenv\n        Included only for compatibility with\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\n    \"\"\"\n    return __salt__['capirca.get_term_pillar'](filter_name, term_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
        "mutated": [
            "def get_term_pillar(filter_name, term_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the term configuration given its name,\\n    under a certain filter uniquely identified by its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    pillar_key: ``acl``\\n        The root key of the whole policy config. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_term_pillar'](filter_name, term_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
            "def get_term_pillar(filter_name, term_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the term configuration given its name,\\n    under a certain filter uniquely identified by its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    pillar_key: ``acl``\\n        The root key of the whole policy config. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_term_pillar'](filter_name, term_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
            "def get_term_pillar(filter_name, term_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the term configuration given its name,\\n    under a certain filter uniquely identified by its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    pillar_key: ``acl``\\n        The root key of the whole policy config. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_term_pillar'](filter_name, term_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
            "def get_term_pillar(filter_name, term_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the term configuration given its name,\\n    under a certain filter uniquely identified by its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    pillar_key: ``acl``\\n        The root key of the whole policy config. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_term_pillar'](filter_name, term_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)",
            "def get_term_pillar(filter_name, term_name, pillar_key='acl', pillarenv=None, saltenv=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Helper that can be used inside a state SLS,\\n    in order to get the term configuration given its name,\\n    under a certain filter uniquely identified by its name.\\n\\n    filter_name\\n        The name of the filter.\\n\\n    term_name\\n        The name of the term.\\n\\n    pillar_key: ``acl``\\n        The root key of the whole policy config. Default: ``acl``.\\n\\n    pillarenv\\n        Query the master to generate fresh pillar data on the fly,\\n        specifically from the requested pillar environment.\\n\\n    saltenv\\n        Included only for compatibility with\\n        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.\\n    '\n    return __salt__['capirca.get_term_pillar'](filter_name, term_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv)"
        ]
    }
]