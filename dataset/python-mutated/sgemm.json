[
    {
        "func_name": "sgemm",
        "original": "def sgemm(A, B, dim_x=16, dim_y=16, blk_m=64, blk_n=64, blk_k=4, dim_xa=64, dim_ya=4, dim_xb=4, dim_yb=64):\n    assert A.dtype == cp.float32\n    assert B.dtype == cp.float32\n    assert dim_x * dim_y == dim_xa * dim_ya == dim_xb * dim_yb\n    (m, k) = A.shape\n    (k, n) = B.shape\n    A = cp.asfortranarray(A)\n    B = cp.asfortranarray(B)\n    C = cp.empty((m, n), dtype=cp.float32, order='F')\n    config = {'DIM_X': dim_x, 'DIM_Y': dim_y, 'BLK_M': blk_m, 'BLK_N': blk_n, 'BLK_K': blk_k, 'DIM_XA': dim_xa, 'DIM_YA': dim_ya, 'DIM_XB': dim_xb, 'DIM_YB': dim_yb, 'THR_M': blk_m // dim_x, 'THR_N': blk_n // dim_y}\n    code = read_code(sgemm_file, params=config)\n    kern = cp.RawKernel(code, 'sgemm')\n    grid = (int(math.ceil(m / blk_m)), int(math.ceil(n / blk_n)), 1)\n    block = (dim_x, dim_y, 1)\n    args = (m, n, k, A, B, C)\n    shared_mem = blk_k * (blk_m + 1) * 4 + blk_n * (blk_k + 1) * 4\n    kern(grid, block, args=args, shared_mem=shared_mem)\n    return C",
        "mutated": [
            "def sgemm(A, B, dim_x=16, dim_y=16, blk_m=64, blk_n=64, blk_k=4, dim_xa=64, dim_ya=4, dim_xb=4, dim_yb=64):\n    if False:\n        i = 10\n    assert A.dtype == cp.float32\n    assert B.dtype == cp.float32\n    assert dim_x * dim_y == dim_xa * dim_ya == dim_xb * dim_yb\n    (m, k) = A.shape\n    (k, n) = B.shape\n    A = cp.asfortranarray(A)\n    B = cp.asfortranarray(B)\n    C = cp.empty((m, n), dtype=cp.float32, order='F')\n    config = {'DIM_X': dim_x, 'DIM_Y': dim_y, 'BLK_M': blk_m, 'BLK_N': blk_n, 'BLK_K': blk_k, 'DIM_XA': dim_xa, 'DIM_YA': dim_ya, 'DIM_XB': dim_xb, 'DIM_YB': dim_yb, 'THR_M': blk_m // dim_x, 'THR_N': blk_n // dim_y}\n    code = read_code(sgemm_file, params=config)\n    kern = cp.RawKernel(code, 'sgemm')\n    grid = (int(math.ceil(m / blk_m)), int(math.ceil(n / blk_n)), 1)\n    block = (dim_x, dim_y, 1)\n    args = (m, n, k, A, B, C)\n    shared_mem = blk_k * (blk_m + 1) * 4 + blk_n * (blk_k + 1) * 4\n    kern(grid, block, args=args, shared_mem=shared_mem)\n    return C",
            "def sgemm(A, B, dim_x=16, dim_y=16, blk_m=64, blk_n=64, blk_k=4, dim_xa=64, dim_ya=4, dim_xb=4, dim_yb=64):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert A.dtype == cp.float32\n    assert B.dtype == cp.float32\n    assert dim_x * dim_y == dim_xa * dim_ya == dim_xb * dim_yb\n    (m, k) = A.shape\n    (k, n) = B.shape\n    A = cp.asfortranarray(A)\n    B = cp.asfortranarray(B)\n    C = cp.empty((m, n), dtype=cp.float32, order='F')\n    config = {'DIM_X': dim_x, 'DIM_Y': dim_y, 'BLK_M': blk_m, 'BLK_N': blk_n, 'BLK_K': blk_k, 'DIM_XA': dim_xa, 'DIM_YA': dim_ya, 'DIM_XB': dim_xb, 'DIM_YB': dim_yb, 'THR_M': blk_m // dim_x, 'THR_N': blk_n // dim_y}\n    code = read_code(sgemm_file, params=config)\n    kern = cp.RawKernel(code, 'sgemm')\n    grid = (int(math.ceil(m / blk_m)), int(math.ceil(n / blk_n)), 1)\n    block = (dim_x, dim_y, 1)\n    args = (m, n, k, A, B, C)\n    shared_mem = blk_k * (blk_m + 1) * 4 + blk_n * (blk_k + 1) * 4\n    kern(grid, block, args=args, shared_mem=shared_mem)\n    return C",
            "def sgemm(A, B, dim_x=16, dim_y=16, blk_m=64, blk_n=64, blk_k=4, dim_xa=64, dim_ya=4, dim_xb=4, dim_yb=64):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert A.dtype == cp.float32\n    assert B.dtype == cp.float32\n    assert dim_x * dim_y == dim_xa * dim_ya == dim_xb * dim_yb\n    (m, k) = A.shape\n    (k, n) = B.shape\n    A = cp.asfortranarray(A)\n    B = cp.asfortranarray(B)\n    C = cp.empty((m, n), dtype=cp.float32, order='F')\n    config = {'DIM_X': dim_x, 'DIM_Y': dim_y, 'BLK_M': blk_m, 'BLK_N': blk_n, 'BLK_K': blk_k, 'DIM_XA': dim_xa, 'DIM_YA': dim_ya, 'DIM_XB': dim_xb, 'DIM_YB': dim_yb, 'THR_M': blk_m // dim_x, 'THR_N': blk_n // dim_y}\n    code = read_code(sgemm_file, params=config)\n    kern = cp.RawKernel(code, 'sgemm')\n    grid = (int(math.ceil(m / blk_m)), int(math.ceil(n / blk_n)), 1)\n    block = (dim_x, dim_y, 1)\n    args = (m, n, k, A, B, C)\n    shared_mem = blk_k * (blk_m + 1) * 4 + blk_n * (blk_k + 1) * 4\n    kern(grid, block, args=args, shared_mem=shared_mem)\n    return C",
            "def sgemm(A, B, dim_x=16, dim_y=16, blk_m=64, blk_n=64, blk_k=4, dim_xa=64, dim_ya=4, dim_xb=4, dim_yb=64):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert A.dtype == cp.float32\n    assert B.dtype == cp.float32\n    assert dim_x * dim_y == dim_xa * dim_ya == dim_xb * dim_yb\n    (m, k) = A.shape\n    (k, n) = B.shape\n    A = cp.asfortranarray(A)\n    B = cp.asfortranarray(B)\n    C = cp.empty((m, n), dtype=cp.float32, order='F')\n    config = {'DIM_X': dim_x, 'DIM_Y': dim_y, 'BLK_M': blk_m, 'BLK_N': blk_n, 'BLK_K': blk_k, 'DIM_XA': dim_xa, 'DIM_YA': dim_ya, 'DIM_XB': dim_xb, 'DIM_YB': dim_yb, 'THR_M': blk_m // dim_x, 'THR_N': blk_n // dim_y}\n    code = read_code(sgemm_file, params=config)\n    kern = cp.RawKernel(code, 'sgemm')\n    grid = (int(math.ceil(m / blk_m)), int(math.ceil(n / blk_n)), 1)\n    block = (dim_x, dim_y, 1)\n    args = (m, n, k, A, B, C)\n    shared_mem = blk_k * (blk_m + 1) * 4 + blk_n * (blk_k + 1) * 4\n    kern(grid, block, args=args, shared_mem=shared_mem)\n    return C",
            "def sgemm(A, B, dim_x=16, dim_y=16, blk_m=64, blk_n=64, blk_k=4, dim_xa=64, dim_ya=4, dim_xb=4, dim_yb=64):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert A.dtype == cp.float32\n    assert B.dtype == cp.float32\n    assert dim_x * dim_y == dim_xa * dim_ya == dim_xb * dim_yb\n    (m, k) = A.shape\n    (k, n) = B.shape\n    A = cp.asfortranarray(A)\n    B = cp.asfortranarray(B)\n    C = cp.empty((m, n), dtype=cp.float32, order='F')\n    config = {'DIM_X': dim_x, 'DIM_Y': dim_y, 'BLK_M': blk_m, 'BLK_N': blk_n, 'BLK_K': blk_k, 'DIM_XA': dim_xa, 'DIM_YA': dim_ya, 'DIM_XB': dim_xb, 'DIM_YB': dim_yb, 'THR_M': blk_m // dim_x, 'THR_N': blk_n // dim_y}\n    code = read_code(sgemm_file, params=config)\n    kern = cp.RawKernel(code, 'sgemm')\n    grid = (int(math.ceil(m / blk_m)), int(math.ceil(n / blk_n)), 1)\n    block = (dim_x, dim_y, 1)\n    args = (m, n, k, A, B, C)\n    shared_mem = blk_k * (blk_m + 1) * 4 + blk_n * (blk_k + 1) * 4\n    kern(grid, block, args=args, shared_mem=shared_mem)\n    return C"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    parser = argparse.ArgumentParser(description='SGEMM kernel call from CuPy')\n    parser.add_argument('--gpu', '-g', default=0, type=int, help='ID of GPU.')\n    parser.add_argument('--m', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--n', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--k', type=int, default=np.random.randint(500, 3000))\n    args = parser.parse_args()\n    print('m={} n={} k={}'.format(args.m, args.n, args.k))\n    print('start benchmarking')\n    print('')\n    with cp.cuda.Device(args.gpu):\n        A = cp.random.uniform(low=-1.0, high=1.0, size=(args.m, args.k)).astype(cp.float32)\n        B = cp.random.uniform(low=-1.0, high=1.0, size=(args.k, args.n)).astype(cp.float32)\n        cp.testing.assert_array_almost_equal(sgemm(A, B), cp.dot(A, B), decimal=3)\n        for _ in range(3):\n            sgemm(A, B)\n        kernel_times = benchmark(sgemm, (A, B), n_run=5)\n        for _ in range(3):\n            cp.dot(A, B)\n        cublas_times = benchmark(cp.dot, (A, B), n_run=5)\n    print('=============================Result===============================')\n    print('hand written kernel time {} ms'.format(np.mean(kernel_times)))\n    print('cuBLAS              time {} ms'.format(np.mean(cublas_times)))",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    parser = argparse.ArgumentParser(description='SGEMM kernel call from CuPy')\n    parser.add_argument('--gpu', '-g', default=0, type=int, help='ID of GPU.')\n    parser.add_argument('--m', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--n', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--k', type=int, default=np.random.randint(500, 3000))\n    args = parser.parse_args()\n    print('m={} n={} k={}'.format(args.m, args.n, args.k))\n    print('start benchmarking')\n    print('')\n    with cp.cuda.Device(args.gpu):\n        A = cp.random.uniform(low=-1.0, high=1.0, size=(args.m, args.k)).astype(cp.float32)\n        B = cp.random.uniform(low=-1.0, high=1.0, size=(args.k, args.n)).astype(cp.float32)\n        cp.testing.assert_array_almost_equal(sgemm(A, B), cp.dot(A, B), decimal=3)\n        for _ in range(3):\n            sgemm(A, B)\n        kernel_times = benchmark(sgemm, (A, B), n_run=5)\n        for _ in range(3):\n            cp.dot(A, B)\n        cublas_times = benchmark(cp.dot, (A, B), n_run=5)\n    print('=============================Result===============================')\n    print('hand written kernel time {} ms'.format(np.mean(kernel_times)))\n    print('cuBLAS              time {} ms'.format(np.mean(cublas_times)))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = argparse.ArgumentParser(description='SGEMM kernel call from CuPy')\n    parser.add_argument('--gpu', '-g', default=0, type=int, help='ID of GPU.')\n    parser.add_argument('--m', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--n', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--k', type=int, default=np.random.randint(500, 3000))\n    args = parser.parse_args()\n    print('m={} n={} k={}'.format(args.m, args.n, args.k))\n    print('start benchmarking')\n    print('')\n    with cp.cuda.Device(args.gpu):\n        A = cp.random.uniform(low=-1.0, high=1.0, size=(args.m, args.k)).astype(cp.float32)\n        B = cp.random.uniform(low=-1.0, high=1.0, size=(args.k, args.n)).astype(cp.float32)\n        cp.testing.assert_array_almost_equal(sgemm(A, B), cp.dot(A, B), decimal=3)\n        for _ in range(3):\n            sgemm(A, B)\n        kernel_times = benchmark(sgemm, (A, B), n_run=5)\n        for _ in range(3):\n            cp.dot(A, B)\n        cublas_times = benchmark(cp.dot, (A, B), n_run=5)\n    print('=============================Result===============================')\n    print('hand written kernel time {} ms'.format(np.mean(kernel_times)))\n    print('cuBLAS              time {} ms'.format(np.mean(cublas_times)))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = argparse.ArgumentParser(description='SGEMM kernel call from CuPy')\n    parser.add_argument('--gpu', '-g', default=0, type=int, help='ID of GPU.')\n    parser.add_argument('--m', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--n', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--k', type=int, default=np.random.randint(500, 3000))\n    args = parser.parse_args()\n    print('m={} n={} k={}'.format(args.m, args.n, args.k))\n    print('start benchmarking')\n    print('')\n    with cp.cuda.Device(args.gpu):\n        A = cp.random.uniform(low=-1.0, high=1.0, size=(args.m, args.k)).astype(cp.float32)\n        B = cp.random.uniform(low=-1.0, high=1.0, size=(args.k, args.n)).astype(cp.float32)\n        cp.testing.assert_array_almost_equal(sgemm(A, B), cp.dot(A, B), decimal=3)\n        for _ in range(3):\n            sgemm(A, B)\n        kernel_times = benchmark(sgemm, (A, B), n_run=5)\n        for _ in range(3):\n            cp.dot(A, B)\n        cublas_times = benchmark(cp.dot, (A, B), n_run=5)\n    print('=============================Result===============================')\n    print('hand written kernel time {} ms'.format(np.mean(kernel_times)))\n    print('cuBLAS              time {} ms'.format(np.mean(cublas_times)))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = argparse.ArgumentParser(description='SGEMM kernel call from CuPy')\n    parser.add_argument('--gpu', '-g', default=0, type=int, help='ID of GPU.')\n    parser.add_argument('--m', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--n', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--k', type=int, default=np.random.randint(500, 3000))\n    args = parser.parse_args()\n    print('m={} n={} k={}'.format(args.m, args.n, args.k))\n    print('start benchmarking')\n    print('')\n    with cp.cuda.Device(args.gpu):\n        A = cp.random.uniform(low=-1.0, high=1.0, size=(args.m, args.k)).astype(cp.float32)\n        B = cp.random.uniform(low=-1.0, high=1.0, size=(args.k, args.n)).astype(cp.float32)\n        cp.testing.assert_array_almost_equal(sgemm(A, B), cp.dot(A, B), decimal=3)\n        for _ in range(3):\n            sgemm(A, B)\n        kernel_times = benchmark(sgemm, (A, B), n_run=5)\n        for _ in range(3):\n            cp.dot(A, B)\n        cublas_times = benchmark(cp.dot, (A, B), n_run=5)\n    print('=============================Result===============================')\n    print('hand written kernel time {} ms'.format(np.mean(kernel_times)))\n    print('cuBLAS              time {} ms'.format(np.mean(cublas_times)))",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = argparse.ArgumentParser(description='SGEMM kernel call from CuPy')\n    parser.add_argument('--gpu', '-g', default=0, type=int, help='ID of GPU.')\n    parser.add_argument('--m', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--n', type=int, default=np.random.randint(1000, 1500))\n    parser.add_argument('--k', type=int, default=np.random.randint(500, 3000))\n    args = parser.parse_args()\n    print('m={} n={} k={}'.format(args.m, args.n, args.k))\n    print('start benchmarking')\n    print('')\n    with cp.cuda.Device(args.gpu):\n        A = cp.random.uniform(low=-1.0, high=1.0, size=(args.m, args.k)).astype(cp.float32)\n        B = cp.random.uniform(low=-1.0, high=1.0, size=(args.k, args.n)).astype(cp.float32)\n        cp.testing.assert_array_almost_equal(sgemm(A, B), cp.dot(A, B), decimal=3)\n        for _ in range(3):\n            sgemm(A, B)\n        kernel_times = benchmark(sgemm, (A, B), n_run=5)\n        for _ in range(3):\n            cp.dot(A, B)\n        cublas_times = benchmark(cp.dot, (A, B), n_run=5)\n    print('=============================Result===============================')\n    print('hand written kernel time {} ms'.format(np.mean(kernel_times)))\n    print('cuBLAS              time {} ms'.format(np.mean(cublas_times)))"
        ]
    }
]