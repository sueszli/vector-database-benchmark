[
    {
        "func_name": "__init__",
        "original": "def __init__(self, protein_sequence, aa_content=None):\n    \"\"\"Initialize the class.\"\"\"\n    self.sequence = protein_sequence.upper()\n    if not aa_content:\n        from Bio.SeqUtils.ProtParam import ProteinAnalysis as _PA\n        aa_content = _PA(self.sequence).count_amino_acids()\n    self.charged_aas_content = self._select_charged(aa_content)\n    (self.pos_pKs, self.neg_pKs) = self._update_pKs_tables()",
        "mutated": [
            "def __init__(self, protein_sequence, aa_content=None):\n    if False:\n        i = 10\n    'Initialize the class.'\n    self.sequence = protein_sequence.upper()\n    if not aa_content:\n        from Bio.SeqUtils.ProtParam import ProteinAnalysis as _PA\n        aa_content = _PA(self.sequence).count_amino_acids()\n    self.charged_aas_content = self._select_charged(aa_content)\n    (self.pos_pKs, self.neg_pKs) = self._update_pKs_tables()",
            "def __init__(self, protein_sequence, aa_content=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Initialize the class.'\n    self.sequence = protein_sequence.upper()\n    if not aa_content:\n        from Bio.SeqUtils.ProtParam import ProteinAnalysis as _PA\n        aa_content = _PA(self.sequence).count_amino_acids()\n    self.charged_aas_content = self._select_charged(aa_content)\n    (self.pos_pKs, self.neg_pKs) = self._update_pKs_tables()",
            "def __init__(self, protein_sequence, aa_content=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Initialize the class.'\n    self.sequence = protein_sequence.upper()\n    if not aa_content:\n        from Bio.SeqUtils.ProtParam import ProteinAnalysis as _PA\n        aa_content = _PA(self.sequence).count_amino_acids()\n    self.charged_aas_content = self._select_charged(aa_content)\n    (self.pos_pKs, self.neg_pKs) = self._update_pKs_tables()",
            "def __init__(self, protein_sequence, aa_content=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Initialize the class.'\n    self.sequence = protein_sequence.upper()\n    if not aa_content:\n        from Bio.SeqUtils.ProtParam import ProteinAnalysis as _PA\n        aa_content = _PA(self.sequence).count_amino_acids()\n    self.charged_aas_content = self._select_charged(aa_content)\n    (self.pos_pKs, self.neg_pKs) = self._update_pKs_tables()",
            "def __init__(self, protein_sequence, aa_content=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Initialize the class.'\n    self.sequence = protein_sequence.upper()\n    if not aa_content:\n        from Bio.SeqUtils.ProtParam import ProteinAnalysis as _PA\n        aa_content = _PA(self.sequence).count_amino_acids()\n    self.charged_aas_content = self._select_charged(aa_content)\n    (self.pos_pKs, self.neg_pKs) = self._update_pKs_tables()"
        ]
    },
    {
        "func_name": "_select_charged",
        "original": "def _select_charged(self, aa_content):\n    charged = {}\n    for aa in charged_aas:\n        charged[aa] = float(aa_content[aa])\n    charged['Nterm'] = 1.0\n    charged['Cterm'] = 1.0\n    return charged",
        "mutated": [
            "def _select_charged(self, aa_content):\n    if False:\n        i = 10\n    charged = {}\n    for aa in charged_aas:\n        charged[aa] = float(aa_content[aa])\n    charged['Nterm'] = 1.0\n    charged['Cterm'] = 1.0\n    return charged",
            "def _select_charged(self, aa_content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    charged = {}\n    for aa in charged_aas:\n        charged[aa] = float(aa_content[aa])\n    charged['Nterm'] = 1.0\n    charged['Cterm'] = 1.0\n    return charged",
            "def _select_charged(self, aa_content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    charged = {}\n    for aa in charged_aas:\n        charged[aa] = float(aa_content[aa])\n    charged['Nterm'] = 1.0\n    charged['Cterm'] = 1.0\n    return charged",
            "def _select_charged(self, aa_content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    charged = {}\n    for aa in charged_aas:\n        charged[aa] = float(aa_content[aa])\n    charged['Nterm'] = 1.0\n    charged['Cterm'] = 1.0\n    return charged",
            "def _select_charged(self, aa_content):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    charged = {}\n    for aa in charged_aas:\n        charged[aa] = float(aa_content[aa])\n    charged['Nterm'] = 1.0\n    charged['Cterm'] = 1.0\n    return charged"
        ]
    },
    {
        "func_name": "_update_pKs_tables",
        "original": "def _update_pKs_tables(self):\n    \"\"\"Update pKs tables with seq specific values for N- and C-termini.\"\"\"\n    pos_pKs = positive_pKs.copy()\n    neg_pKs = negative_pKs.copy()\n    (nterm, cterm) = (self.sequence[0], self.sequence[-1])\n    if nterm in pKnterminal:\n        pos_pKs['Nterm'] = pKnterminal[nterm]\n    if cterm in pKcterminal:\n        neg_pKs['Cterm'] = pKcterminal[cterm]\n    return (pos_pKs, neg_pKs)",
        "mutated": [
            "def _update_pKs_tables(self):\n    if False:\n        i = 10\n    'Update pKs tables with seq specific values for N- and C-termini.'\n    pos_pKs = positive_pKs.copy()\n    neg_pKs = negative_pKs.copy()\n    (nterm, cterm) = (self.sequence[0], self.sequence[-1])\n    if nterm in pKnterminal:\n        pos_pKs['Nterm'] = pKnterminal[nterm]\n    if cterm in pKcterminal:\n        neg_pKs['Cterm'] = pKcterminal[cterm]\n    return (pos_pKs, neg_pKs)",
            "def _update_pKs_tables(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Update pKs tables with seq specific values for N- and C-termini.'\n    pos_pKs = positive_pKs.copy()\n    neg_pKs = negative_pKs.copy()\n    (nterm, cterm) = (self.sequence[0], self.sequence[-1])\n    if nterm in pKnterminal:\n        pos_pKs['Nterm'] = pKnterminal[nterm]\n    if cterm in pKcterminal:\n        neg_pKs['Cterm'] = pKcterminal[cterm]\n    return (pos_pKs, neg_pKs)",
            "def _update_pKs_tables(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Update pKs tables with seq specific values for N- and C-termini.'\n    pos_pKs = positive_pKs.copy()\n    neg_pKs = negative_pKs.copy()\n    (nterm, cterm) = (self.sequence[0], self.sequence[-1])\n    if nterm in pKnterminal:\n        pos_pKs['Nterm'] = pKnterminal[nterm]\n    if cterm in pKcterminal:\n        neg_pKs['Cterm'] = pKcterminal[cterm]\n    return (pos_pKs, neg_pKs)",
            "def _update_pKs_tables(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Update pKs tables with seq specific values for N- and C-termini.'\n    pos_pKs = positive_pKs.copy()\n    neg_pKs = negative_pKs.copy()\n    (nterm, cterm) = (self.sequence[0], self.sequence[-1])\n    if nterm in pKnterminal:\n        pos_pKs['Nterm'] = pKnterminal[nterm]\n    if cterm in pKcterminal:\n        neg_pKs['Cterm'] = pKcterminal[cterm]\n    return (pos_pKs, neg_pKs)",
            "def _update_pKs_tables(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Update pKs tables with seq specific values for N- and C-termini.'\n    pos_pKs = positive_pKs.copy()\n    neg_pKs = negative_pKs.copy()\n    (nterm, cterm) = (self.sequence[0], self.sequence[-1])\n    if nterm in pKnterminal:\n        pos_pKs['Nterm'] = pKnterminal[nterm]\n    if cterm in pKcterminal:\n        neg_pKs['Cterm'] = pKcterminal[cterm]\n    return (pos_pKs, neg_pKs)"
        ]
    },
    {
        "func_name": "charge_at_pH",
        "original": "def charge_at_pH(self, pH):\n    \"\"\"Calculate the charge of a protein at given pH.\"\"\"\n    positive_charge = 0.0\n    for (aa, pK) in self.pos_pKs.items():\n        partial_charge = 1.0 / (10 ** (pH - pK) + 1.0)\n        positive_charge += self.charged_aas_content[aa] * partial_charge\n    negative_charge = 0.0\n    for (aa, pK) in self.neg_pKs.items():\n        partial_charge = 1.0 / (10 ** (pK - pH) + 1.0)\n        negative_charge += self.charged_aas_content[aa] * partial_charge\n    return positive_charge - negative_charge",
        "mutated": [
            "def charge_at_pH(self, pH):\n    if False:\n        i = 10\n    'Calculate the charge of a protein at given pH.'\n    positive_charge = 0.0\n    for (aa, pK) in self.pos_pKs.items():\n        partial_charge = 1.0 / (10 ** (pH - pK) + 1.0)\n        positive_charge += self.charged_aas_content[aa] * partial_charge\n    negative_charge = 0.0\n    for (aa, pK) in self.neg_pKs.items():\n        partial_charge = 1.0 / (10 ** (pK - pH) + 1.0)\n        negative_charge += self.charged_aas_content[aa] * partial_charge\n    return positive_charge - negative_charge",
            "def charge_at_pH(self, pH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate the charge of a protein at given pH.'\n    positive_charge = 0.0\n    for (aa, pK) in self.pos_pKs.items():\n        partial_charge = 1.0 / (10 ** (pH - pK) + 1.0)\n        positive_charge += self.charged_aas_content[aa] * partial_charge\n    negative_charge = 0.0\n    for (aa, pK) in self.neg_pKs.items():\n        partial_charge = 1.0 / (10 ** (pK - pH) + 1.0)\n        negative_charge += self.charged_aas_content[aa] * partial_charge\n    return positive_charge - negative_charge",
            "def charge_at_pH(self, pH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate the charge of a protein at given pH.'\n    positive_charge = 0.0\n    for (aa, pK) in self.pos_pKs.items():\n        partial_charge = 1.0 / (10 ** (pH - pK) + 1.0)\n        positive_charge += self.charged_aas_content[aa] * partial_charge\n    negative_charge = 0.0\n    for (aa, pK) in self.neg_pKs.items():\n        partial_charge = 1.0 / (10 ** (pK - pH) + 1.0)\n        negative_charge += self.charged_aas_content[aa] * partial_charge\n    return positive_charge - negative_charge",
            "def charge_at_pH(self, pH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate the charge of a protein at given pH.'\n    positive_charge = 0.0\n    for (aa, pK) in self.pos_pKs.items():\n        partial_charge = 1.0 / (10 ** (pH - pK) + 1.0)\n        positive_charge += self.charged_aas_content[aa] * partial_charge\n    negative_charge = 0.0\n    for (aa, pK) in self.neg_pKs.items():\n        partial_charge = 1.0 / (10 ** (pK - pH) + 1.0)\n        negative_charge += self.charged_aas_content[aa] * partial_charge\n    return positive_charge - negative_charge",
            "def charge_at_pH(self, pH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate the charge of a protein at given pH.'\n    positive_charge = 0.0\n    for (aa, pK) in self.pos_pKs.items():\n        partial_charge = 1.0 / (10 ** (pH - pK) + 1.0)\n        positive_charge += self.charged_aas_content[aa] * partial_charge\n    negative_charge = 0.0\n    for (aa, pK) in self.neg_pKs.items():\n        partial_charge = 1.0 / (10 ** (pK - pH) + 1.0)\n        negative_charge += self.charged_aas_content[aa] * partial_charge\n    return positive_charge - negative_charge"
        ]
    },
    {
        "func_name": "pi",
        "original": "def pi(self, pH=7.775, min_=4.05, max_=12):\n    \"\"\"Calculate and return the isoelectric point as float.\n\n        This is a recursive function that uses bisection method.\n        Wiki on bisection: https://en.wikipedia.org/wiki/Bisection_method\n\n        Arguments:\n         - pH: the pH at which the current charge of the protein is computed.\n           This pH lies at the centre of the interval (mean of `min_` and `max_`).\n         - min\\\\_: the minimum of the interval. Initial value defaults to 4.05,\n           which is below the theoretical minimum, when the protein is composed\n           exclusively of aspartate.\n         - max\\\\_: the maximum of the the interval. Initial value defaults to 12,\n           which is above the theoretical maximum, when the protein is composed\n           exclusively of arginine.\n        \"\"\"\n    charge = self.charge_at_pH(pH)\n    if max_ - min_ > 0.0001:\n        if charge > 0.0:\n            min_ = pH\n        else:\n            max_ = pH\n        next_pH = (min_ + max_) / 2\n        return self.pi(next_pH, min_, max_)\n    return pH",
        "mutated": [
            "def pi(self, pH=7.775, min_=4.05, max_=12):\n    if False:\n        i = 10\n    'Calculate and return the isoelectric point as float.\\n\\n        This is a recursive function that uses bisection method.\\n        Wiki on bisection: https://en.wikipedia.org/wiki/Bisection_method\\n\\n        Arguments:\\n         - pH: the pH at which the current charge of the protein is computed.\\n           This pH lies at the centre of the interval (mean of `min_` and `max_`).\\n         - min\\\\_: the minimum of the interval. Initial value defaults to 4.05,\\n           which is below the theoretical minimum, when the protein is composed\\n           exclusively of aspartate.\\n         - max\\\\_: the maximum of the the interval. Initial value defaults to 12,\\n           which is above the theoretical maximum, when the protein is composed\\n           exclusively of arginine.\\n        '\n    charge = self.charge_at_pH(pH)\n    if max_ - min_ > 0.0001:\n        if charge > 0.0:\n            min_ = pH\n        else:\n            max_ = pH\n        next_pH = (min_ + max_) / 2\n        return self.pi(next_pH, min_, max_)\n    return pH",
            "def pi(self, pH=7.775, min_=4.05, max_=12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate and return the isoelectric point as float.\\n\\n        This is a recursive function that uses bisection method.\\n        Wiki on bisection: https://en.wikipedia.org/wiki/Bisection_method\\n\\n        Arguments:\\n         - pH: the pH at which the current charge of the protein is computed.\\n           This pH lies at the centre of the interval (mean of `min_` and `max_`).\\n         - min\\\\_: the minimum of the interval. Initial value defaults to 4.05,\\n           which is below the theoretical minimum, when the protein is composed\\n           exclusively of aspartate.\\n         - max\\\\_: the maximum of the the interval. Initial value defaults to 12,\\n           which is above the theoretical maximum, when the protein is composed\\n           exclusively of arginine.\\n        '\n    charge = self.charge_at_pH(pH)\n    if max_ - min_ > 0.0001:\n        if charge > 0.0:\n            min_ = pH\n        else:\n            max_ = pH\n        next_pH = (min_ + max_) / 2\n        return self.pi(next_pH, min_, max_)\n    return pH",
            "def pi(self, pH=7.775, min_=4.05, max_=12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate and return the isoelectric point as float.\\n\\n        This is a recursive function that uses bisection method.\\n        Wiki on bisection: https://en.wikipedia.org/wiki/Bisection_method\\n\\n        Arguments:\\n         - pH: the pH at which the current charge of the protein is computed.\\n           This pH lies at the centre of the interval (mean of `min_` and `max_`).\\n         - min\\\\_: the minimum of the interval. Initial value defaults to 4.05,\\n           which is below the theoretical minimum, when the protein is composed\\n           exclusively of aspartate.\\n         - max\\\\_: the maximum of the the interval. Initial value defaults to 12,\\n           which is above the theoretical maximum, when the protein is composed\\n           exclusively of arginine.\\n        '\n    charge = self.charge_at_pH(pH)\n    if max_ - min_ > 0.0001:\n        if charge > 0.0:\n            min_ = pH\n        else:\n            max_ = pH\n        next_pH = (min_ + max_) / 2\n        return self.pi(next_pH, min_, max_)\n    return pH",
            "def pi(self, pH=7.775, min_=4.05, max_=12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate and return the isoelectric point as float.\\n\\n        This is a recursive function that uses bisection method.\\n        Wiki on bisection: https://en.wikipedia.org/wiki/Bisection_method\\n\\n        Arguments:\\n         - pH: the pH at which the current charge of the protein is computed.\\n           This pH lies at the centre of the interval (mean of `min_` and `max_`).\\n         - min\\\\_: the minimum of the interval. Initial value defaults to 4.05,\\n           which is below the theoretical minimum, when the protein is composed\\n           exclusively of aspartate.\\n         - max\\\\_: the maximum of the the interval. Initial value defaults to 12,\\n           which is above the theoretical maximum, when the protein is composed\\n           exclusively of arginine.\\n        '\n    charge = self.charge_at_pH(pH)\n    if max_ - min_ > 0.0001:\n        if charge > 0.0:\n            min_ = pH\n        else:\n            max_ = pH\n        next_pH = (min_ + max_) / 2\n        return self.pi(next_pH, min_, max_)\n    return pH",
            "def pi(self, pH=7.775, min_=4.05, max_=12):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate and return the isoelectric point as float.\\n\\n        This is a recursive function that uses bisection method.\\n        Wiki on bisection: https://en.wikipedia.org/wiki/Bisection_method\\n\\n        Arguments:\\n         - pH: the pH at which the current charge of the protein is computed.\\n           This pH lies at the centre of the interval (mean of `min_` and `max_`).\\n         - min\\\\_: the minimum of the interval. Initial value defaults to 4.05,\\n           which is below the theoretical minimum, when the protein is composed\\n           exclusively of aspartate.\\n         - max\\\\_: the maximum of the the interval. Initial value defaults to 12,\\n           which is above the theoretical maximum, when the protein is composed\\n           exclusively of arginine.\\n        '\n    charge = self.charge_at_pH(pH)\n    if max_ - min_ > 0.0001:\n        if charge > 0.0:\n            min_ = pH\n        else:\n            max_ = pH\n        next_pH = (min_ + max_) / 2\n        return self.pi(next_pH, min_, max_)\n    return pH"
        ]
    }
]