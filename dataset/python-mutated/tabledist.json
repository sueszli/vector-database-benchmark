[
    {
        "func_name": "__init__",
        "original": "def __init__(self, alpha, size, crit_table, asymptotic=None, min_nobs=None, max_nobs=None):\n    self.alpha = np.asarray(alpha)\n    if self.alpha.ndim != 1:\n        raise ValueError('alpha is not 1d')\n    elif (np.diff(self.alpha) <= 0).any():\n        raise ValueError('alpha is not sorted')\n    self.size = np.asarray(size)\n    if self.size.ndim != 1:\n        raise ValueError('size is not 1d')\n    elif (np.diff(self.size) <= 0).any():\n        raise ValueError('size is not sorted')\n    if self.size.ndim == 1:\n        if (np.diff(alpha) <= 0).any():\n            raise ValueError('alpha is not sorted')\n    self.crit_table = np.asarray(crit_table)\n    if self.crit_table.shape != (self.size.shape[0], self.alpha.shape[0]):\n        raise ValueError('crit_table must have shape(len(size), len(alpha))')\n    self.n_alpha = len(alpha)\n    self.signcrit = np.sign(np.diff(self.crit_table, 1).mean())\n    if self.signcrit > 0:\n        self.critv_bounds = self.crit_table[:, [0, 1]]\n    else:\n        self.critv_bounds = self.crit_table[:, [1, 0]]\n    self.asymptotic = None\n    max_size = self.max_size = max(size)\n    if asymptotic is not None:\n        try:\n            cv = asymptotic(self.max_size + 1)\n        except Exception as exc:\n            raise type(exc)('Calling asymptotic(self.size+1) failed. The error message was:\\n\\n{err_msg}'.format(err_msg=exc.args[0]))\n        if len(cv) != len(alpha):\n            raise ValueError('asymptotic does not return len(alpha) values')\n        self.asymptotic = asymptotic\n    self.min_nobs = max_size if min_nobs is None else min_nobs\n    self.max_nobs = max_size if max_nobs is None else max_nobs\n    if self.min_nobs > max_size:\n        raise ValueError('min_nobs > max(size)')\n    if self.max_nobs > max_size:\n        raise ValueError('max_nobs > max(size)')",
        "mutated": [
            "def __init__(self, alpha, size, crit_table, asymptotic=None, min_nobs=None, max_nobs=None):\n    if False:\n        i = 10\n    self.alpha = np.asarray(alpha)\n    if self.alpha.ndim != 1:\n        raise ValueError('alpha is not 1d')\n    elif (np.diff(self.alpha) <= 0).any():\n        raise ValueError('alpha is not sorted')\n    self.size = np.asarray(size)\n    if self.size.ndim != 1:\n        raise ValueError('size is not 1d')\n    elif (np.diff(self.size) <= 0).any():\n        raise ValueError('size is not sorted')\n    if self.size.ndim == 1:\n        if (np.diff(alpha) <= 0).any():\n            raise ValueError('alpha is not sorted')\n    self.crit_table = np.asarray(crit_table)\n    if self.crit_table.shape != (self.size.shape[0], self.alpha.shape[0]):\n        raise ValueError('crit_table must have shape(len(size), len(alpha))')\n    self.n_alpha = len(alpha)\n    self.signcrit = np.sign(np.diff(self.crit_table, 1).mean())\n    if self.signcrit > 0:\n        self.critv_bounds = self.crit_table[:, [0, 1]]\n    else:\n        self.critv_bounds = self.crit_table[:, [1, 0]]\n    self.asymptotic = None\n    max_size = self.max_size = max(size)\n    if asymptotic is not None:\n        try:\n            cv = asymptotic(self.max_size + 1)\n        except Exception as exc:\n            raise type(exc)('Calling asymptotic(self.size+1) failed. The error message was:\\n\\n{err_msg}'.format(err_msg=exc.args[0]))\n        if len(cv) != len(alpha):\n            raise ValueError('asymptotic does not return len(alpha) values')\n        self.asymptotic = asymptotic\n    self.min_nobs = max_size if min_nobs is None else min_nobs\n    self.max_nobs = max_size if max_nobs is None else max_nobs\n    if self.min_nobs > max_size:\n        raise ValueError('min_nobs > max(size)')\n    if self.max_nobs > max_size:\n        raise ValueError('max_nobs > max(size)')",
            "def __init__(self, alpha, size, crit_table, asymptotic=None, min_nobs=None, max_nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.alpha = np.asarray(alpha)\n    if self.alpha.ndim != 1:\n        raise ValueError('alpha is not 1d')\n    elif (np.diff(self.alpha) <= 0).any():\n        raise ValueError('alpha is not sorted')\n    self.size = np.asarray(size)\n    if self.size.ndim != 1:\n        raise ValueError('size is not 1d')\n    elif (np.diff(self.size) <= 0).any():\n        raise ValueError('size is not sorted')\n    if self.size.ndim == 1:\n        if (np.diff(alpha) <= 0).any():\n            raise ValueError('alpha is not sorted')\n    self.crit_table = np.asarray(crit_table)\n    if self.crit_table.shape != (self.size.shape[0], self.alpha.shape[0]):\n        raise ValueError('crit_table must have shape(len(size), len(alpha))')\n    self.n_alpha = len(alpha)\n    self.signcrit = np.sign(np.diff(self.crit_table, 1).mean())\n    if self.signcrit > 0:\n        self.critv_bounds = self.crit_table[:, [0, 1]]\n    else:\n        self.critv_bounds = self.crit_table[:, [1, 0]]\n    self.asymptotic = None\n    max_size = self.max_size = max(size)\n    if asymptotic is not None:\n        try:\n            cv = asymptotic(self.max_size + 1)\n        except Exception as exc:\n            raise type(exc)('Calling asymptotic(self.size+1) failed. The error message was:\\n\\n{err_msg}'.format(err_msg=exc.args[0]))\n        if len(cv) != len(alpha):\n            raise ValueError('asymptotic does not return len(alpha) values')\n        self.asymptotic = asymptotic\n    self.min_nobs = max_size if min_nobs is None else min_nobs\n    self.max_nobs = max_size if max_nobs is None else max_nobs\n    if self.min_nobs > max_size:\n        raise ValueError('min_nobs > max(size)')\n    if self.max_nobs > max_size:\n        raise ValueError('max_nobs > max(size)')",
            "def __init__(self, alpha, size, crit_table, asymptotic=None, min_nobs=None, max_nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.alpha = np.asarray(alpha)\n    if self.alpha.ndim != 1:\n        raise ValueError('alpha is not 1d')\n    elif (np.diff(self.alpha) <= 0).any():\n        raise ValueError('alpha is not sorted')\n    self.size = np.asarray(size)\n    if self.size.ndim != 1:\n        raise ValueError('size is not 1d')\n    elif (np.diff(self.size) <= 0).any():\n        raise ValueError('size is not sorted')\n    if self.size.ndim == 1:\n        if (np.diff(alpha) <= 0).any():\n            raise ValueError('alpha is not sorted')\n    self.crit_table = np.asarray(crit_table)\n    if self.crit_table.shape != (self.size.shape[0], self.alpha.shape[0]):\n        raise ValueError('crit_table must have shape(len(size), len(alpha))')\n    self.n_alpha = len(alpha)\n    self.signcrit = np.sign(np.diff(self.crit_table, 1).mean())\n    if self.signcrit > 0:\n        self.critv_bounds = self.crit_table[:, [0, 1]]\n    else:\n        self.critv_bounds = self.crit_table[:, [1, 0]]\n    self.asymptotic = None\n    max_size = self.max_size = max(size)\n    if asymptotic is not None:\n        try:\n            cv = asymptotic(self.max_size + 1)\n        except Exception as exc:\n            raise type(exc)('Calling asymptotic(self.size+1) failed. The error message was:\\n\\n{err_msg}'.format(err_msg=exc.args[0]))\n        if len(cv) != len(alpha):\n            raise ValueError('asymptotic does not return len(alpha) values')\n        self.asymptotic = asymptotic\n    self.min_nobs = max_size if min_nobs is None else min_nobs\n    self.max_nobs = max_size if max_nobs is None else max_nobs\n    if self.min_nobs > max_size:\n        raise ValueError('min_nobs > max(size)')\n    if self.max_nobs > max_size:\n        raise ValueError('max_nobs > max(size)')",
            "def __init__(self, alpha, size, crit_table, asymptotic=None, min_nobs=None, max_nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.alpha = np.asarray(alpha)\n    if self.alpha.ndim != 1:\n        raise ValueError('alpha is not 1d')\n    elif (np.diff(self.alpha) <= 0).any():\n        raise ValueError('alpha is not sorted')\n    self.size = np.asarray(size)\n    if self.size.ndim != 1:\n        raise ValueError('size is not 1d')\n    elif (np.diff(self.size) <= 0).any():\n        raise ValueError('size is not sorted')\n    if self.size.ndim == 1:\n        if (np.diff(alpha) <= 0).any():\n            raise ValueError('alpha is not sorted')\n    self.crit_table = np.asarray(crit_table)\n    if self.crit_table.shape != (self.size.shape[0], self.alpha.shape[0]):\n        raise ValueError('crit_table must have shape(len(size), len(alpha))')\n    self.n_alpha = len(alpha)\n    self.signcrit = np.sign(np.diff(self.crit_table, 1).mean())\n    if self.signcrit > 0:\n        self.critv_bounds = self.crit_table[:, [0, 1]]\n    else:\n        self.critv_bounds = self.crit_table[:, [1, 0]]\n    self.asymptotic = None\n    max_size = self.max_size = max(size)\n    if asymptotic is not None:\n        try:\n            cv = asymptotic(self.max_size + 1)\n        except Exception as exc:\n            raise type(exc)('Calling asymptotic(self.size+1) failed. The error message was:\\n\\n{err_msg}'.format(err_msg=exc.args[0]))\n        if len(cv) != len(alpha):\n            raise ValueError('asymptotic does not return len(alpha) values')\n        self.asymptotic = asymptotic\n    self.min_nobs = max_size if min_nobs is None else min_nobs\n    self.max_nobs = max_size if max_nobs is None else max_nobs\n    if self.min_nobs > max_size:\n        raise ValueError('min_nobs > max(size)')\n    if self.max_nobs > max_size:\n        raise ValueError('max_nobs > max(size)')",
            "def __init__(self, alpha, size, crit_table, asymptotic=None, min_nobs=None, max_nobs=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.alpha = np.asarray(alpha)\n    if self.alpha.ndim != 1:\n        raise ValueError('alpha is not 1d')\n    elif (np.diff(self.alpha) <= 0).any():\n        raise ValueError('alpha is not sorted')\n    self.size = np.asarray(size)\n    if self.size.ndim != 1:\n        raise ValueError('size is not 1d')\n    elif (np.diff(self.size) <= 0).any():\n        raise ValueError('size is not sorted')\n    if self.size.ndim == 1:\n        if (np.diff(alpha) <= 0).any():\n            raise ValueError('alpha is not sorted')\n    self.crit_table = np.asarray(crit_table)\n    if self.crit_table.shape != (self.size.shape[0], self.alpha.shape[0]):\n        raise ValueError('crit_table must have shape(len(size), len(alpha))')\n    self.n_alpha = len(alpha)\n    self.signcrit = np.sign(np.diff(self.crit_table, 1).mean())\n    if self.signcrit > 0:\n        self.critv_bounds = self.crit_table[:, [0, 1]]\n    else:\n        self.critv_bounds = self.crit_table[:, [1, 0]]\n    self.asymptotic = None\n    max_size = self.max_size = max(size)\n    if asymptotic is not None:\n        try:\n            cv = asymptotic(self.max_size + 1)\n        except Exception as exc:\n            raise type(exc)('Calling asymptotic(self.size+1) failed. The error message was:\\n\\n{err_msg}'.format(err_msg=exc.args[0]))\n        if len(cv) != len(alpha):\n            raise ValueError('asymptotic does not return len(alpha) values')\n        self.asymptotic = asymptotic\n    self.min_nobs = max_size if min_nobs is None else min_nobs\n    self.max_nobs = max_size if max_nobs is None else max_nobs\n    if self.min_nobs > max_size:\n        raise ValueError('min_nobs > max(size)')\n    if self.max_nobs > max_size:\n        raise ValueError('max_nobs > max(size)')"
        ]
    },
    {
        "func_name": "polyn",
        "original": "@cache_readonly\ndef polyn(self):\n    polyn = [interp1d(self.size, self.crit_table[:, i]) for i in range(self.n_alpha)]\n    return polyn",
        "mutated": [
            "@cache_readonly\ndef polyn(self):\n    if False:\n        i = 10\n    polyn = [interp1d(self.size, self.crit_table[:, i]) for i in range(self.n_alpha)]\n    return polyn",
            "@cache_readonly\ndef polyn(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    polyn = [interp1d(self.size, self.crit_table[:, i]) for i in range(self.n_alpha)]\n    return polyn",
            "@cache_readonly\ndef polyn(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    polyn = [interp1d(self.size, self.crit_table[:, i]) for i in range(self.n_alpha)]\n    return polyn",
            "@cache_readonly\ndef polyn(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    polyn = [interp1d(self.size, self.crit_table[:, i]) for i in range(self.n_alpha)]\n    return polyn",
            "@cache_readonly\ndef polyn(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    polyn = [interp1d(self.size, self.crit_table[:, i]) for i in range(self.n_alpha)]\n    return polyn"
        ]
    },
    {
        "func_name": "poly2d",
        "original": "@cache_readonly\ndef poly2d(self):\n    poly2d = interp2d(self.size, self.alpha, self.crit_table)\n    return poly2d",
        "mutated": [
            "@cache_readonly\ndef poly2d(self):\n    if False:\n        i = 10\n    poly2d = interp2d(self.size, self.alpha, self.crit_table)\n    return poly2d",
            "@cache_readonly\ndef poly2d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    poly2d = interp2d(self.size, self.alpha, self.crit_table)\n    return poly2d",
            "@cache_readonly\ndef poly2d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    poly2d = interp2d(self.size, self.alpha, self.crit_table)\n    return poly2d",
            "@cache_readonly\ndef poly2d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    poly2d = interp2d(self.size, self.alpha, self.crit_table)\n    return poly2d",
            "@cache_readonly\ndef poly2d(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    poly2d = interp2d(self.size, self.alpha, self.crit_table)\n    return poly2d"
        ]
    },
    {
        "func_name": "polyrbf",
        "original": "@cache_readonly\ndef polyrbf(self):\n    (xs, xa) = np.meshgrid(self.size.astype(float), self.alpha)\n    polyrbf = Rbf(xs.ravel(), xa.ravel(), self.crit_table.T.ravel(), function='linear')\n    return polyrbf",
        "mutated": [
            "@cache_readonly\ndef polyrbf(self):\n    if False:\n        i = 10\n    (xs, xa) = np.meshgrid(self.size.astype(float), self.alpha)\n    polyrbf = Rbf(xs.ravel(), xa.ravel(), self.crit_table.T.ravel(), function='linear')\n    return polyrbf",
            "@cache_readonly\ndef polyrbf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (xs, xa) = np.meshgrid(self.size.astype(float), self.alpha)\n    polyrbf = Rbf(xs.ravel(), xa.ravel(), self.crit_table.T.ravel(), function='linear')\n    return polyrbf",
            "@cache_readonly\ndef polyrbf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (xs, xa) = np.meshgrid(self.size.astype(float), self.alpha)\n    polyrbf = Rbf(xs.ravel(), xa.ravel(), self.crit_table.T.ravel(), function='linear')\n    return polyrbf",
            "@cache_readonly\ndef polyrbf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (xs, xa) = np.meshgrid(self.size.astype(float), self.alpha)\n    polyrbf = Rbf(xs.ravel(), xa.ravel(), self.crit_table.T.ravel(), function='linear')\n    return polyrbf",
            "@cache_readonly\ndef polyrbf(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (xs, xa) = np.meshgrid(self.size.astype(float), self.alpha)\n    polyrbf = Rbf(xs.ravel(), xa.ravel(), self.crit_table.T.ravel(), function='linear')\n    return polyrbf"
        ]
    },
    {
        "func_name": "_critvals",
        "original": "def _critvals(self, n):\n    \"\"\"\n        Rows of the table, linearly interpolated for given sample size\n\n        Parameters\n        ----------\n        n : float\n            sample size, second parameter of the table\n\n        Returns\n        -------\n        critv : ndarray, 1d\n            critical values (ppf) corresponding to a row of the table\n\n        Notes\n        -----\n        This is used in two step interpolation, or if we want to know the\n        critical values for all alphas for any sample size that we can obtain\n        through interpolation\n        \"\"\"\n    if n > self.max_size:\n        if self.asymptotic is not None:\n            cv = self.asymptotic(n)\n        else:\n            raise ValueError('n is above max(size) and no asymptotic distribtuion is provided')\n    else:\n        cv = [p(n) for p in self.polyn]\n        if n > self.min_nobs:\n            w = (n - self.min_nobs) / (self.max_nobs - self.min_nobs)\n            w = min(1.0, w)\n            a_cv = self.asymptotic(n)\n            cv = w * a_cv + (1 - w) * cv\n    return cv",
        "mutated": [
            "def _critvals(self, n):\n    if False:\n        i = 10\n    '\\n        Rows of the table, linearly interpolated for given sample size\\n\\n        Parameters\\n        ----------\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        critv : ndarray, 1d\\n            critical values (ppf) corresponding to a row of the table\\n\\n        Notes\\n        -----\\n        This is used in two step interpolation, or if we want to know the\\n        critical values for all alphas for any sample size that we can obtain\\n        through interpolation\\n        '\n    if n > self.max_size:\n        if self.asymptotic is not None:\n            cv = self.asymptotic(n)\n        else:\n            raise ValueError('n is above max(size) and no asymptotic distribtuion is provided')\n    else:\n        cv = [p(n) for p in self.polyn]\n        if n > self.min_nobs:\n            w = (n - self.min_nobs) / (self.max_nobs - self.min_nobs)\n            w = min(1.0, w)\n            a_cv = self.asymptotic(n)\n            cv = w * a_cv + (1 - w) * cv\n    return cv",
            "def _critvals(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Rows of the table, linearly interpolated for given sample size\\n\\n        Parameters\\n        ----------\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        critv : ndarray, 1d\\n            critical values (ppf) corresponding to a row of the table\\n\\n        Notes\\n        -----\\n        This is used in two step interpolation, or if we want to know the\\n        critical values for all alphas for any sample size that we can obtain\\n        through interpolation\\n        '\n    if n > self.max_size:\n        if self.asymptotic is not None:\n            cv = self.asymptotic(n)\n        else:\n            raise ValueError('n is above max(size) and no asymptotic distribtuion is provided')\n    else:\n        cv = [p(n) for p in self.polyn]\n        if n > self.min_nobs:\n            w = (n - self.min_nobs) / (self.max_nobs - self.min_nobs)\n            w = min(1.0, w)\n            a_cv = self.asymptotic(n)\n            cv = w * a_cv + (1 - w) * cv\n    return cv",
            "def _critvals(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Rows of the table, linearly interpolated for given sample size\\n\\n        Parameters\\n        ----------\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        critv : ndarray, 1d\\n            critical values (ppf) corresponding to a row of the table\\n\\n        Notes\\n        -----\\n        This is used in two step interpolation, or if we want to know the\\n        critical values for all alphas for any sample size that we can obtain\\n        through interpolation\\n        '\n    if n > self.max_size:\n        if self.asymptotic is not None:\n            cv = self.asymptotic(n)\n        else:\n            raise ValueError('n is above max(size) and no asymptotic distribtuion is provided')\n    else:\n        cv = [p(n) for p in self.polyn]\n        if n > self.min_nobs:\n            w = (n - self.min_nobs) / (self.max_nobs - self.min_nobs)\n            w = min(1.0, w)\n            a_cv = self.asymptotic(n)\n            cv = w * a_cv + (1 - w) * cv\n    return cv",
            "def _critvals(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Rows of the table, linearly interpolated for given sample size\\n\\n        Parameters\\n        ----------\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        critv : ndarray, 1d\\n            critical values (ppf) corresponding to a row of the table\\n\\n        Notes\\n        -----\\n        This is used in two step interpolation, or if we want to know the\\n        critical values for all alphas for any sample size that we can obtain\\n        through interpolation\\n        '\n    if n > self.max_size:\n        if self.asymptotic is not None:\n            cv = self.asymptotic(n)\n        else:\n            raise ValueError('n is above max(size) and no asymptotic distribtuion is provided')\n    else:\n        cv = [p(n) for p in self.polyn]\n        if n > self.min_nobs:\n            w = (n - self.min_nobs) / (self.max_nobs - self.min_nobs)\n            w = min(1.0, w)\n            a_cv = self.asymptotic(n)\n            cv = w * a_cv + (1 - w) * cv\n    return cv",
            "def _critvals(self, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Rows of the table, linearly interpolated for given sample size\\n\\n        Parameters\\n        ----------\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        critv : ndarray, 1d\\n            critical values (ppf) corresponding to a row of the table\\n\\n        Notes\\n        -----\\n        This is used in two step interpolation, or if we want to know the\\n        critical values for all alphas for any sample size that we can obtain\\n        through interpolation\\n        '\n    if n > self.max_size:\n        if self.asymptotic is not None:\n            cv = self.asymptotic(n)\n        else:\n            raise ValueError('n is above max(size) and no asymptotic distribtuion is provided')\n    else:\n        cv = [p(n) for p in self.polyn]\n        if n > self.min_nobs:\n            w = (n - self.min_nobs) / (self.max_nobs - self.min_nobs)\n            w = min(1.0, w)\n            a_cv = self.asymptotic(n)\n            cv = w * a_cv + (1 - w) * cv\n    return cv"
        ]
    },
    {
        "func_name": "prob",
        "original": "def prob(self, x, n):\n    \"\"\"\n        Find pvalues by interpolation, either cdf(x)\n\n        Returns extreme probabilities, 0.001 and 0.2, for out of range\n\n        Parameters\n        ----------\n        x : array_like\n            observed value, assumed to follow the distribution in the table\n        n : float\n            sample size, second parameter of the table\n\n        Returns\n        -------\n        prob : array_like\n            This is the probability for each value of x, the p-value in\n            underlying distribution is for a statistical test.\n        \"\"\"\n    critv = self._critvals(n)\n    alpha = self.alpha\n    if self.signcrit < 1:\n        (critv, alpha) = (critv[::-1], alpha[::-1])\n    if np.size(x) == 1:\n        if x < critv[0]:\n            return alpha[0]\n        elif x > critv[-1]:\n            return alpha[-1]\n        return interp1d(critv, alpha)(x)[()]\n    else:\n        cond_low = x < critv[0]\n        cond_high = x > critv[-1]\n        cond_interior = ~np.logical_or(cond_low, cond_high)\n        probs = np.nan * np.ones(x.shape)\n        probs[cond_low] = alpha[0]\n        probs[cond_low] = alpha[-1]\n        probs[cond_interior] = interp1d(critv, alpha)(x[cond_interior])\n        return probs",
        "mutated": [
            "def prob(self, x, n):\n    if False:\n        i = 10\n    '\\n        Find pvalues by interpolation, either cdf(x)\\n\\n        Returns extreme probabilities, 0.001 and 0.2, for out of range\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            observed value, assumed to follow the distribution in the table\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        prob : array_like\\n            This is the probability for each value of x, the p-value in\\n            underlying distribution is for a statistical test.\\n        '\n    critv = self._critvals(n)\n    alpha = self.alpha\n    if self.signcrit < 1:\n        (critv, alpha) = (critv[::-1], alpha[::-1])\n    if np.size(x) == 1:\n        if x < critv[0]:\n            return alpha[0]\n        elif x > critv[-1]:\n            return alpha[-1]\n        return interp1d(critv, alpha)(x)[()]\n    else:\n        cond_low = x < critv[0]\n        cond_high = x > critv[-1]\n        cond_interior = ~np.logical_or(cond_low, cond_high)\n        probs = np.nan * np.ones(x.shape)\n        probs[cond_low] = alpha[0]\n        probs[cond_low] = alpha[-1]\n        probs[cond_interior] = interp1d(critv, alpha)(x[cond_interior])\n        return probs",
            "def prob(self, x, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Find pvalues by interpolation, either cdf(x)\\n\\n        Returns extreme probabilities, 0.001 and 0.2, for out of range\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            observed value, assumed to follow the distribution in the table\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        prob : array_like\\n            This is the probability for each value of x, the p-value in\\n            underlying distribution is for a statistical test.\\n        '\n    critv = self._critvals(n)\n    alpha = self.alpha\n    if self.signcrit < 1:\n        (critv, alpha) = (critv[::-1], alpha[::-1])\n    if np.size(x) == 1:\n        if x < critv[0]:\n            return alpha[0]\n        elif x > critv[-1]:\n            return alpha[-1]\n        return interp1d(critv, alpha)(x)[()]\n    else:\n        cond_low = x < critv[0]\n        cond_high = x > critv[-1]\n        cond_interior = ~np.logical_or(cond_low, cond_high)\n        probs = np.nan * np.ones(x.shape)\n        probs[cond_low] = alpha[0]\n        probs[cond_low] = alpha[-1]\n        probs[cond_interior] = interp1d(critv, alpha)(x[cond_interior])\n        return probs",
            "def prob(self, x, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Find pvalues by interpolation, either cdf(x)\\n\\n        Returns extreme probabilities, 0.001 and 0.2, for out of range\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            observed value, assumed to follow the distribution in the table\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        prob : array_like\\n            This is the probability for each value of x, the p-value in\\n            underlying distribution is for a statistical test.\\n        '\n    critv = self._critvals(n)\n    alpha = self.alpha\n    if self.signcrit < 1:\n        (critv, alpha) = (critv[::-1], alpha[::-1])\n    if np.size(x) == 1:\n        if x < critv[0]:\n            return alpha[0]\n        elif x > critv[-1]:\n            return alpha[-1]\n        return interp1d(critv, alpha)(x)[()]\n    else:\n        cond_low = x < critv[0]\n        cond_high = x > critv[-1]\n        cond_interior = ~np.logical_or(cond_low, cond_high)\n        probs = np.nan * np.ones(x.shape)\n        probs[cond_low] = alpha[0]\n        probs[cond_low] = alpha[-1]\n        probs[cond_interior] = interp1d(critv, alpha)(x[cond_interior])\n        return probs",
            "def prob(self, x, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Find pvalues by interpolation, either cdf(x)\\n\\n        Returns extreme probabilities, 0.001 and 0.2, for out of range\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            observed value, assumed to follow the distribution in the table\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        prob : array_like\\n            This is the probability for each value of x, the p-value in\\n            underlying distribution is for a statistical test.\\n        '\n    critv = self._critvals(n)\n    alpha = self.alpha\n    if self.signcrit < 1:\n        (critv, alpha) = (critv[::-1], alpha[::-1])\n    if np.size(x) == 1:\n        if x < critv[0]:\n            return alpha[0]\n        elif x > critv[-1]:\n            return alpha[-1]\n        return interp1d(critv, alpha)(x)[()]\n    else:\n        cond_low = x < critv[0]\n        cond_high = x > critv[-1]\n        cond_interior = ~np.logical_or(cond_low, cond_high)\n        probs = np.nan * np.ones(x.shape)\n        probs[cond_low] = alpha[0]\n        probs[cond_low] = alpha[-1]\n        probs[cond_interior] = interp1d(critv, alpha)(x[cond_interior])\n        return probs",
            "def prob(self, x, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Find pvalues by interpolation, either cdf(x)\\n\\n        Returns extreme probabilities, 0.001 and 0.2, for out of range\\n\\n        Parameters\\n        ----------\\n        x : array_like\\n            observed value, assumed to follow the distribution in the table\\n        n : float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        prob : array_like\\n            This is the probability for each value of x, the p-value in\\n            underlying distribution is for a statistical test.\\n        '\n    critv = self._critvals(n)\n    alpha = self.alpha\n    if self.signcrit < 1:\n        (critv, alpha) = (critv[::-1], alpha[::-1])\n    if np.size(x) == 1:\n        if x < critv[0]:\n            return alpha[0]\n        elif x > critv[-1]:\n            return alpha[-1]\n        return interp1d(critv, alpha)(x)[()]\n    else:\n        cond_low = x < critv[0]\n        cond_high = x > critv[-1]\n        cond_interior = ~np.logical_or(cond_low, cond_high)\n        probs = np.nan * np.ones(x.shape)\n        probs[cond_low] = alpha[0]\n        probs[cond_low] = alpha[-1]\n        probs[cond_interior] = interp1d(critv, alpha)(x[cond_interior])\n        return probs"
        ]
    },
    {
        "func_name": "crit",
        "original": "def crit(self, prob, n):\n    \"\"\"\n        Returns interpolated quantiles, similar to ppf or isf\n\n        use two sequential 1d interpolation, first by n then by prob\n\n        Parameters\n        ----------\n        prob : array_like\n            probabilities corresponding to the definition of table columns\n        n : int or float\n            sample size, second parameter of the table\n\n        Returns\n        -------\n        ppf : array_like\n            critical values with same shape as prob\n        \"\"\"\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    critv = self._critvals(n)\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return interp1d(alpha, critv)(prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = interp1d(alpha, critv)(prob[cond_interior])\n    return quantile",
        "mutated": [
            "def crit(self, prob, n):\n    if False:\n        i = 10\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        use two sequential 1d interpolation, first by n then by prob\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    critv = self._critvals(n)\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return interp1d(alpha, critv)(prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = interp1d(alpha, critv)(prob[cond_interior])\n    return quantile",
            "def crit(self, prob, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        use two sequential 1d interpolation, first by n then by prob\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    critv = self._critvals(n)\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return interp1d(alpha, critv)(prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = interp1d(alpha, critv)(prob[cond_interior])\n    return quantile",
            "def crit(self, prob, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        use two sequential 1d interpolation, first by n then by prob\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    critv = self._critvals(n)\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return interp1d(alpha, critv)(prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = interp1d(alpha, critv)(prob[cond_interior])\n    return quantile",
            "def crit(self, prob, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        use two sequential 1d interpolation, first by n then by prob\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    critv = self._critvals(n)\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return interp1d(alpha, critv)(prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = interp1d(alpha, critv)(prob[cond_interior])\n    return quantile",
            "def crit(self, prob, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        use two sequential 1d interpolation, first by n then by prob\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    critv = self._critvals(n)\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return interp1d(alpha, critv)(prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = interp1d(alpha, critv)(prob[cond_interior])\n    return quantile"
        ]
    },
    {
        "func_name": "crit3",
        "original": "def crit3(self, prob, n):\n    \"\"\"\n        Returns interpolated quantiles, similar to ppf or isf\n\n        uses Rbf to interpolate critical values as function of `prob` and `n`\n\n        Parameters\n        ----------\n        prob : array_like\n            probabilities corresponding to the definition of table columns\n        n : int or float\n            sample size, second parameter of the table\n\n        Returns\n        -------\n        ppf : array_like\n            critical values with same shape as prob, returns nan for arguments\n            that are outside of the table bounds\n        \"\"\"\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return self.polyrbf(n, prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = self.polyrbf(n, prob[cond_interior])\n    return quantile",
        "mutated": [
            "def crit3(self, prob, n):\n    if False:\n        i = 10\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        uses Rbf to interpolate critical values as function of `prob` and `n`\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob, returns nan for arguments\\n            that are outside of the table bounds\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return self.polyrbf(n, prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = self.polyrbf(n, prob[cond_interior])\n    return quantile",
            "def crit3(self, prob, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        uses Rbf to interpolate critical values as function of `prob` and `n`\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob, returns nan for arguments\\n            that are outside of the table bounds\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return self.polyrbf(n, prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = self.polyrbf(n, prob[cond_interior])\n    return quantile",
            "def crit3(self, prob, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        uses Rbf to interpolate critical values as function of `prob` and `n`\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob, returns nan for arguments\\n            that are outside of the table bounds\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return self.polyrbf(n, prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = self.polyrbf(n, prob[cond_interior])\n    return quantile",
            "def crit3(self, prob, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        uses Rbf to interpolate critical values as function of `prob` and `n`\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob, returns nan for arguments\\n            that are outside of the table bounds\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return self.polyrbf(n, prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = self.polyrbf(n, prob[cond_interior])\n    return quantile",
            "def crit3(self, prob, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns interpolated quantiles, similar to ppf or isf\\n\\n        uses Rbf to interpolate critical values as function of `prob` and `n`\\n\\n        Parameters\\n        ----------\\n        prob : array_like\\n            probabilities corresponding to the definition of table columns\\n        n : int or float\\n            sample size, second parameter of the table\\n\\n        Returns\\n        -------\\n        ppf : array_like\\n            critical values with same shape as prob, returns nan for arguments\\n            that are outside of the table bounds\\n        '\n    prob = np.asarray(prob)\n    alpha = self.alpha\n    cond_ilow = prob > alpha[0]\n    cond_ihigh = prob < alpha[-1]\n    cond_interior = np.logical_or(cond_ilow, cond_ihigh)\n    if prob.size == 1:\n        if cond_interior:\n            return self.polyrbf(n, prob)\n        else:\n            return np.nan\n    quantile = np.nan * np.ones(prob.shape)\n    quantile[cond_interior] = self.polyrbf(n, prob[cond_interior])\n    return quantile"
        ]
    }
]