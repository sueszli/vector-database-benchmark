[
    {
        "func_name": "is_nilpotent_number",
        "original": "def is_nilpotent_number(n):\n    \"\"\"\n    Check whether `n` is a nilpotent number. A number `n` is said to be\n    nilpotent if and only if every finite group of order `n` is nilpotent.\n    For more information see [1]_.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.group_numbers import is_nilpotent_number\n    >>> from sympy import randprime\n    >>> is_nilpotent_number(21)\n    False\n    >>> is_nilpotent_number(randprime(1, 30)**12)\n    True\n\n    References\n    ==========\n\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\n            The American Mathematical Monthly, 107(7), 631-634.\n\n\n    \"\"\"\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    prime_factors = list(factorint(n).items())\n    is_nilpotent = True\n    for (p_j, a_j) in prime_factors:\n        for (p_i, a_i) in prime_factors:\n            if any((Mod(Pow(p_i, k), p_j) == 1 for k in range(1, a_i + 1))):\n                is_nilpotent = False\n                break\n        if not is_nilpotent:\n            break\n    return is_nilpotent",
        "mutated": [
            "def is_nilpotent_number(n):\n    if False:\n        i = 10\n    '\\n    Check whether `n` is a nilpotent number. A number `n` is said to be\\n    nilpotent if and only if every finite group of order `n` is nilpotent.\\n    For more information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_nilpotent_number\\n    >>> from sympy import randprime\\n    >>> is_nilpotent_number(21)\\n    False\\n    >>> is_nilpotent_number(randprime(1, 30)**12)\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    prime_factors = list(factorint(n).items())\n    is_nilpotent = True\n    for (p_j, a_j) in prime_factors:\n        for (p_i, a_i) in prime_factors:\n            if any((Mod(Pow(p_i, k), p_j) == 1 for k in range(1, a_i + 1))):\n                is_nilpotent = False\n                break\n        if not is_nilpotent:\n            break\n    return is_nilpotent",
            "def is_nilpotent_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check whether `n` is a nilpotent number. A number `n` is said to be\\n    nilpotent if and only if every finite group of order `n` is nilpotent.\\n    For more information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_nilpotent_number\\n    >>> from sympy import randprime\\n    >>> is_nilpotent_number(21)\\n    False\\n    >>> is_nilpotent_number(randprime(1, 30)**12)\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    prime_factors = list(factorint(n).items())\n    is_nilpotent = True\n    for (p_j, a_j) in prime_factors:\n        for (p_i, a_i) in prime_factors:\n            if any((Mod(Pow(p_i, k), p_j) == 1 for k in range(1, a_i + 1))):\n                is_nilpotent = False\n                break\n        if not is_nilpotent:\n            break\n    return is_nilpotent",
            "def is_nilpotent_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check whether `n` is a nilpotent number. A number `n` is said to be\\n    nilpotent if and only if every finite group of order `n` is nilpotent.\\n    For more information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_nilpotent_number\\n    >>> from sympy import randprime\\n    >>> is_nilpotent_number(21)\\n    False\\n    >>> is_nilpotent_number(randprime(1, 30)**12)\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    prime_factors = list(factorint(n).items())\n    is_nilpotent = True\n    for (p_j, a_j) in prime_factors:\n        for (p_i, a_i) in prime_factors:\n            if any((Mod(Pow(p_i, k), p_j) == 1 for k in range(1, a_i + 1))):\n                is_nilpotent = False\n                break\n        if not is_nilpotent:\n            break\n    return is_nilpotent",
            "def is_nilpotent_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check whether `n` is a nilpotent number. A number `n` is said to be\\n    nilpotent if and only if every finite group of order `n` is nilpotent.\\n    For more information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_nilpotent_number\\n    >>> from sympy import randprime\\n    >>> is_nilpotent_number(21)\\n    False\\n    >>> is_nilpotent_number(randprime(1, 30)**12)\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    prime_factors = list(factorint(n).items())\n    is_nilpotent = True\n    for (p_j, a_j) in prime_factors:\n        for (p_i, a_i) in prime_factors:\n            if any((Mod(Pow(p_i, k), p_j) == 1 for k in range(1, a_i + 1))):\n                is_nilpotent = False\n                break\n        if not is_nilpotent:\n            break\n    return is_nilpotent",
            "def is_nilpotent_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check whether `n` is a nilpotent number. A number `n` is said to be\\n    nilpotent if and only if every finite group of order `n` is nilpotent.\\n    For more information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_nilpotent_number\\n    >>> from sympy import randprime\\n    >>> is_nilpotent_number(21)\\n    False\\n    >>> is_nilpotent_number(randprime(1, 30)**12)\\n    True\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    prime_factors = list(factorint(n).items())\n    is_nilpotent = True\n    for (p_j, a_j) in prime_factors:\n        for (p_i, a_i) in prime_factors:\n            if any((Mod(Pow(p_i, k), p_j) == 1 for k in range(1, a_i + 1))):\n                is_nilpotent = False\n                break\n        if not is_nilpotent:\n            break\n    return is_nilpotent"
        ]
    },
    {
        "func_name": "is_abelian_number",
        "original": "def is_abelian_number(n):\n    \"\"\"\n    Check whether `n` is an abelian number. A number `n` is said to be abelian\n    if and only if every finite group of order `n` is abelian. For more\n    information see [1]_.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.group_numbers import is_abelian_number\n    >>> from sympy import randprime\n    >>> is_abelian_number(4)\n    True\n    >>> is_abelian_number(randprime(1, 2000)**2)\n    True\n    >>> is_abelian_number(60)\n    False\n\n    References\n    ==========\n\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\n            The American Mathematical Monthly, 107(7), 631-634.\n\n\n    \"\"\"\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_abelian = all((a_i < 3 for (p_i, a_i) in prime_factors))\n    return is_abelian",
        "mutated": [
            "def is_abelian_number(n):\n    if False:\n        i = 10\n    '\\n    Check whether `n` is an abelian number. A number `n` is said to be abelian\\n    if and only if every finite group of order `n` is abelian. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_abelian_number\\n    >>> from sympy import randprime\\n    >>> is_abelian_number(4)\\n    True\\n    >>> is_abelian_number(randprime(1, 2000)**2)\\n    True\\n    >>> is_abelian_number(60)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_abelian = all((a_i < 3 for (p_i, a_i) in prime_factors))\n    return is_abelian",
            "def is_abelian_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check whether `n` is an abelian number. A number `n` is said to be abelian\\n    if and only if every finite group of order `n` is abelian. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_abelian_number\\n    >>> from sympy import randprime\\n    >>> is_abelian_number(4)\\n    True\\n    >>> is_abelian_number(randprime(1, 2000)**2)\\n    True\\n    >>> is_abelian_number(60)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_abelian = all((a_i < 3 for (p_i, a_i) in prime_factors))\n    return is_abelian",
            "def is_abelian_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check whether `n` is an abelian number. A number `n` is said to be abelian\\n    if and only if every finite group of order `n` is abelian. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_abelian_number\\n    >>> from sympy import randprime\\n    >>> is_abelian_number(4)\\n    True\\n    >>> is_abelian_number(randprime(1, 2000)**2)\\n    True\\n    >>> is_abelian_number(60)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_abelian = all((a_i < 3 for (p_i, a_i) in prime_factors))\n    return is_abelian",
            "def is_abelian_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check whether `n` is an abelian number. A number `n` is said to be abelian\\n    if and only if every finite group of order `n` is abelian. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_abelian_number\\n    >>> from sympy import randprime\\n    >>> is_abelian_number(4)\\n    True\\n    >>> is_abelian_number(randprime(1, 2000)**2)\\n    True\\n    >>> is_abelian_number(60)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_abelian = all((a_i < 3 for (p_i, a_i) in prime_factors))\n    return is_abelian",
            "def is_abelian_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check whether `n` is an abelian number. A number `n` is said to be abelian\\n    if and only if every finite group of order `n` is abelian. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_abelian_number\\n    >>> from sympy import randprime\\n    >>> is_abelian_number(4)\\n    True\\n    >>> is_abelian_number(randprime(1, 2000)**2)\\n    True\\n    >>> is_abelian_number(60)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_abelian = all((a_i < 3 for (p_i, a_i) in prime_factors))\n    return is_abelian"
        ]
    },
    {
        "func_name": "is_cyclic_number",
        "original": "def is_cyclic_number(n):\n    \"\"\"\n    Check whether `n` is a cyclic number. A number `n` is said to be cyclic\n    if and only if every finite group of order `n` is cyclic. For more\n    information see [1]_.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.group_numbers import is_cyclic_number\n    >>> from sympy import randprime\n    >>> is_cyclic_number(15)\n    True\n    >>> is_cyclic_number(randprime(1, 2000)**2)\n    False\n    >>> is_cyclic_number(4)\n    False\n\n    References\n    ==========\n\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\n            The American Mathematical Monthly, 107(7), 631-634.\n\n    \"\"\"\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_cyclic = all((a_i < 2 for (p_i, a_i) in prime_factors))\n    return is_cyclic",
        "mutated": [
            "def is_cyclic_number(n):\n    if False:\n        i = 10\n    '\\n    Check whether `n` is a cyclic number. A number `n` is said to be cyclic\\n    if and only if every finite group of order `n` is cyclic. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_cyclic_number\\n    >>> from sympy import randprime\\n    >>> is_cyclic_number(15)\\n    True\\n    >>> is_cyclic_number(randprime(1, 2000)**2)\\n    False\\n    >>> is_cyclic_number(4)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_cyclic = all((a_i < 2 for (p_i, a_i) in prime_factors))\n    return is_cyclic",
            "def is_cyclic_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Check whether `n` is a cyclic number. A number `n` is said to be cyclic\\n    if and only if every finite group of order `n` is cyclic. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_cyclic_number\\n    >>> from sympy import randprime\\n    >>> is_cyclic_number(15)\\n    True\\n    >>> is_cyclic_number(randprime(1, 2000)**2)\\n    False\\n    >>> is_cyclic_number(4)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_cyclic = all((a_i < 2 for (p_i, a_i) in prime_factors))\n    return is_cyclic",
            "def is_cyclic_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Check whether `n` is a cyclic number. A number `n` is said to be cyclic\\n    if and only if every finite group of order `n` is cyclic. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_cyclic_number\\n    >>> from sympy import randprime\\n    >>> is_cyclic_number(15)\\n    True\\n    >>> is_cyclic_number(randprime(1, 2000)**2)\\n    False\\n    >>> is_cyclic_number(4)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_cyclic = all((a_i < 2 for (p_i, a_i) in prime_factors))\n    return is_cyclic",
            "def is_cyclic_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Check whether `n` is a cyclic number. A number `n` is said to be cyclic\\n    if and only if every finite group of order `n` is cyclic. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_cyclic_number\\n    >>> from sympy import randprime\\n    >>> is_cyclic_number(15)\\n    True\\n    >>> is_cyclic_number(randprime(1, 2000)**2)\\n    False\\n    >>> is_cyclic_number(4)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_cyclic = all((a_i < 2 for (p_i, a_i) in prime_factors))\n    return is_cyclic",
            "def is_cyclic_number(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Check whether `n` is a cyclic number. A number `n` is said to be cyclic\\n    if and only if every finite group of order `n` is cyclic. For more\\n    information see [1]_.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.combinatorics.group_numbers import is_cyclic_number\\n    >>> from sympy import randprime\\n    >>> is_cyclic_number(15)\\n    True\\n    >>> is_cyclic_number(randprime(1, 2000)**2)\\n    False\\n    >>> is_cyclic_number(4)\\n    False\\n\\n    References\\n    ==========\\n\\n    .. [1] Pakianathan, J., Shankar, K., *Nilpotent Numbers*,\\n            The American Mathematical Monthly, 107(7), 631-634.\\n\\n    '\n    if n <= 0 or int(n) != n:\n        raise ValueError('n must be a positive integer, not %i' % n)\n    n = Integer(n)\n    if not is_nilpotent_number(n):\n        return False\n    prime_factors = list(factorint(n).items())\n    is_cyclic = all((a_i < 2 for (p_i, a_i) in prime_factors))\n    return is_cyclic"
        ]
    }
]