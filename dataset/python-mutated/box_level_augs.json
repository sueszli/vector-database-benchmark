[
    {
        "func_name": "_box_sample_prob",
        "original": "def _box_sample_prob(bbox, scale_ratios_splits, box_prob=0.3):\n    (scale_ratios, scale_splits) = scale_ratios_splits\n    ratios = np.array(scale_ratios)\n    ratios = ratios / ratios.sum()\n    area = (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])\n    if area == 0:\n        return 0\n    if area < scale_splits[0]:\n        scale_ratio = ratios[0]\n    elif area < scale_splits[1]:\n        scale_ratio = ratios[1]\n    else:\n        scale_ratio = ratios[2]\n    return box_prob * scale_ratio",
        "mutated": [
            "def _box_sample_prob(bbox, scale_ratios_splits, box_prob=0.3):\n    if False:\n        i = 10\n    (scale_ratios, scale_splits) = scale_ratios_splits\n    ratios = np.array(scale_ratios)\n    ratios = ratios / ratios.sum()\n    area = (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])\n    if area == 0:\n        return 0\n    if area < scale_splits[0]:\n        scale_ratio = ratios[0]\n    elif area < scale_splits[1]:\n        scale_ratio = ratios[1]\n    else:\n        scale_ratio = ratios[2]\n    return box_prob * scale_ratio",
            "def _box_sample_prob(bbox, scale_ratios_splits, box_prob=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (scale_ratios, scale_splits) = scale_ratios_splits\n    ratios = np.array(scale_ratios)\n    ratios = ratios / ratios.sum()\n    area = (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])\n    if area == 0:\n        return 0\n    if area < scale_splits[0]:\n        scale_ratio = ratios[0]\n    elif area < scale_splits[1]:\n        scale_ratio = ratios[1]\n    else:\n        scale_ratio = ratios[2]\n    return box_prob * scale_ratio",
            "def _box_sample_prob(bbox, scale_ratios_splits, box_prob=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (scale_ratios, scale_splits) = scale_ratios_splits\n    ratios = np.array(scale_ratios)\n    ratios = ratios / ratios.sum()\n    area = (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])\n    if area == 0:\n        return 0\n    if area < scale_splits[0]:\n        scale_ratio = ratios[0]\n    elif area < scale_splits[1]:\n        scale_ratio = ratios[1]\n    else:\n        scale_ratio = ratios[2]\n    return box_prob * scale_ratio",
            "def _box_sample_prob(bbox, scale_ratios_splits, box_prob=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (scale_ratios, scale_splits) = scale_ratios_splits\n    ratios = np.array(scale_ratios)\n    ratios = ratios / ratios.sum()\n    area = (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])\n    if area == 0:\n        return 0\n    if area < scale_splits[0]:\n        scale_ratio = ratios[0]\n    elif area < scale_splits[1]:\n        scale_ratio = ratios[1]\n    else:\n        scale_ratio = ratios[2]\n    return box_prob * scale_ratio",
            "def _box_sample_prob(bbox, scale_ratios_splits, box_prob=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (scale_ratios, scale_splits) = scale_ratios_splits\n    ratios = np.array(scale_ratios)\n    ratios = ratios / ratios.sum()\n    area = (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])\n    if area == 0:\n        return 0\n    if area < scale_splits[0]:\n        scale_ratio = ratios[0]\n    elif area < scale_splits[1]:\n        scale_ratio = ratios[1]\n    else:\n        scale_ratio = ratios[2]\n    return box_prob * scale_ratio"
        ]
    },
    {
        "func_name": "_box_aug_per_img",
        "original": "def _box_aug_per_img(img, target, aug_type=None, scale_ratios=None, scale_splits=None, img_prob=0.1, box_prob=0.3, level=1):\n    if random.random() > img_prob:\n        return (img, target)\n    img /= 255.0\n    tag = 'prob' if aug_type in geometric_aug_func else 'area'\n    scale_ratios_splits = [scale_ratios[tag], scale_splits]\n    if scale_ratios is None:\n        box_sample_prob = [box_prob] * len(target.bbox)\n    else:\n        box_sample_prob = [_box_sample_prob(bbox, scale_ratios_splits, box_prob=box_prob) for bbox in target.bbox]\n    if aug_type in color_aug_func:\n        img_aug = color_aug_func[aug_type](img, level, target, [scale_ratios['area'], scale_splits], box_sample_prob)\n    elif aug_type in geometric_aug_func:\n        (img_aug, target) = geometric_aug_func[aug_type](img, level, target, box_sample_prob)\n    else:\n        raise ValueError('Unknown box-level augmentation function %s.' % aug_type)\n    out = img_aug * 255.0\n    return (out, target)",
        "mutated": [
            "def _box_aug_per_img(img, target, aug_type=None, scale_ratios=None, scale_splits=None, img_prob=0.1, box_prob=0.3, level=1):\n    if False:\n        i = 10\n    if random.random() > img_prob:\n        return (img, target)\n    img /= 255.0\n    tag = 'prob' if aug_type in geometric_aug_func else 'area'\n    scale_ratios_splits = [scale_ratios[tag], scale_splits]\n    if scale_ratios is None:\n        box_sample_prob = [box_prob] * len(target.bbox)\n    else:\n        box_sample_prob = [_box_sample_prob(bbox, scale_ratios_splits, box_prob=box_prob) for bbox in target.bbox]\n    if aug_type in color_aug_func:\n        img_aug = color_aug_func[aug_type](img, level, target, [scale_ratios['area'], scale_splits], box_sample_prob)\n    elif aug_type in geometric_aug_func:\n        (img_aug, target) = geometric_aug_func[aug_type](img, level, target, box_sample_prob)\n    else:\n        raise ValueError('Unknown box-level augmentation function %s.' % aug_type)\n    out = img_aug * 255.0\n    return (out, target)",
            "def _box_aug_per_img(img, target, aug_type=None, scale_ratios=None, scale_splits=None, img_prob=0.1, box_prob=0.3, level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if random.random() > img_prob:\n        return (img, target)\n    img /= 255.0\n    tag = 'prob' if aug_type in geometric_aug_func else 'area'\n    scale_ratios_splits = [scale_ratios[tag], scale_splits]\n    if scale_ratios is None:\n        box_sample_prob = [box_prob] * len(target.bbox)\n    else:\n        box_sample_prob = [_box_sample_prob(bbox, scale_ratios_splits, box_prob=box_prob) for bbox in target.bbox]\n    if aug_type in color_aug_func:\n        img_aug = color_aug_func[aug_type](img, level, target, [scale_ratios['area'], scale_splits], box_sample_prob)\n    elif aug_type in geometric_aug_func:\n        (img_aug, target) = geometric_aug_func[aug_type](img, level, target, box_sample_prob)\n    else:\n        raise ValueError('Unknown box-level augmentation function %s.' % aug_type)\n    out = img_aug * 255.0\n    return (out, target)",
            "def _box_aug_per_img(img, target, aug_type=None, scale_ratios=None, scale_splits=None, img_prob=0.1, box_prob=0.3, level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if random.random() > img_prob:\n        return (img, target)\n    img /= 255.0\n    tag = 'prob' if aug_type in geometric_aug_func else 'area'\n    scale_ratios_splits = [scale_ratios[tag], scale_splits]\n    if scale_ratios is None:\n        box_sample_prob = [box_prob] * len(target.bbox)\n    else:\n        box_sample_prob = [_box_sample_prob(bbox, scale_ratios_splits, box_prob=box_prob) for bbox in target.bbox]\n    if aug_type in color_aug_func:\n        img_aug = color_aug_func[aug_type](img, level, target, [scale_ratios['area'], scale_splits], box_sample_prob)\n    elif aug_type in geometric_aug_func:\n        (img_aug, target) = geometric_aug_func[aug_type](img, level, target, box_sample_prob)\n    else:\n        raise ValueError('Unknown box-level augmentation function %s.' % aug_type)\n    out = img_aug * 255.0\n    return (out, target)",
            "def _box_aug_per_img(img, target, aug_type=None, scale_ratios=None, scale_splits=None, img_prob=0.1, box_prob=0.3, level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if random.random() > img_prob:\n        return (img, target)\n    img /= 255.0\n    tag = 'prob' if aug_type in geometric_aug_func else 'area'\n    scale_ratios_splits = [scale_ratios[tag], scale_splits]\n    if scale_ratios is None:\n        box_sample_prob = [box_prob] * len(target.bbox)\n    else:\n        box_sample_prob = [_box_sample_prob(bbox, scale_ratios_splits, box_prob=box_prob) for bbox in target.bbox]\n    if aug_type in color_aug_func:\n        img_aug = color_aug_func[aug_type](img, level, target, [scale_ratios['area'], scale_splits], box_sample_prob)\n    elif aug_type in geometric_aug_func:\n        (img_aug, target) = geometric_aug_func[aug_type](img, level, target, box_sample_prob)\n    else:\n        raise ValueError('Unknown box-level augmentation function %s.' % aug_type)\n    out = img_aug * 255.0\n    return (out, target)",
            "def _box_aug_per_img(img, target, aug_type=None, scale_ratios=None, scale_splits=None, img_prob=0.1, box_prob=0.3, level=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if random.random() > img_prob:\n        return (img, target)\n    img /= 255.0\n    tag = 'prob' if aug_type in geometric_aug_func else 'area'\n    scale_ratios_splits = [scale_ratios[tag], scale_splits]\n    if scale_ratios is None:\n        box_sample_prob = [box_prob] * len(target.bbox)\n    else:\n        box_sample_prob = [_box_sample_prob(bbox, scale_ratios_splits, box_prob=box_prob) for bbox in target.bbox]\n    if aug_type in color_aug_func:\n        img_aug = color_aug_func[aug_type](img, level, target, [scale_ratios['area'], scale_splits], box_sample_prob)\n    elif aug_type in geometric_aug_func:\n        (img_aug, target) = geometric_aug_func[aug_type](img, level, target, box_sample_prob)\n    else:\n        raise ValueError('Unknown box-level augmentation function %s.' % aug_type)\n    out = img_aug * 255.0\n    return (out, target)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, box_augs_dict, max_iters, scale_splits, box_prob=0.3):\n    self.max_iters = max_iters\n    self.box_prob = box_prob\n    self.scale_splits = scale_splits\n    self.policies = box_augs_dict['policies']\n    self.scale_ratios = box_augs_dict['scale_ratios']",
        "mutated": [
            "def __init__(self, box_augs_dict, max_iters, scale_splits, box_prob=0.3):\n    if False:\n        i = 10\n    self.max_iters = max_iters\n    self.box_prob = box_prob\n    self.scale_splits = scale_splits\n    self.policies = box_augs_dict['policies']\n    self.scale_ratios = box_augs_dict['scale_ratios']",
            "def __init__(self, box_augs_dict, max_iters, scale_splits, box_prob=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.max_iters = max_iters\n    self.box_prob = box_prob\n    self.scale_splits = scale_splits\n    self.policies = box_augs_dict['policies']\n    self.scale_ratios = box_augs_dict['scale_ratios']",
            "def __init__(self, box_augs_dict, max_iters, scale_splits, box_prob=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.max_iters = max_iters\n    self.box_prob = box_prob\n    self.scale_splits = scale_splits\n    self.policies = box_augs_dict['policies']\n    self.scale_ratios = box_augs_dict['scale_ratios']",
            "def __init__(self, box_augs_dict, max_iters, scale_splits, box_prob=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.max_iters = max_iters\n    self.box_prob = box_prob\n    self.scale_splits = scale_splits\n    self.policies = box_augs_dict['policies']\n    self.scale_ratios = box_augs_dict['scale_ratios']",
            "def __init__(self, box_augs_dict, max_iters, scale_splits, box_prob=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.max_iters = max_iters\n    self.box_prob = box_prob\n    self.scale_splits = scale_splits\n    self.policies = box_augs_dict['policies']\n    self.scale_ratios = box_augs_dict['scale_ratios']"
        ]
    },
    {
        "func_name": "__call__",
        "original": "def __call__(self, tensor, target, iteration):\n    iter_ratio = float(iteration) / self.max_iters\n    sub_policy = random.choice(self.policies)\n    (h, w) = tensor.shape[-2:]\n    ratio = min(h, w) / 800\n    scale_splits = [area * ratio for area in self.scale_splits]\n    if iter_ratio <= 1:\n        (tensor, _) = _box_aug_per_img(tensor, target, aug_type=sub_policy[0][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[0][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[0][2])\n        (tensor, target) = _box_aug_per_img(tensor, target, aug_type=sub_policy[1][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[1][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[1][2])\n    return (tensor, target)",
        "mutated": [
            "def __call__(self, tensor, target, iteration):\n    if False:\n        i = 10\n    iter_ratio = float(iteration) / self.max_iters\n    sub_policy = random.choice(self.policies)\n    (h, w) = tensor.shape[-2:]\n    ratio = min(h, w) / 800\n    scale_splits = [area * ratio for area in self.scale_splits]\n    if iter_ratio <= 1:\n        (tensor, _) = _box_aug_per_img(tensor, target, aug_type=sub_policy[0][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[0][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[0][2])\n        (tensor, target) = _box_aug_per_img(tensor, target, aug_type=sub_policy[1][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[1][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[1][2])\n    return (tensor, target)",
            "def __call__(self, tensor, target, iteration):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    iter_ratio = float(iteration) / self.max_iters\n    sub_policy = random.choice(self.policies)\n    (h, w) = tensor.shape[-2:]\n    ratio = min(h, w) / 800\n    scale_splits = [area * ratio for area in self.scale_splits]\n    if iter_ratio <= 1:\n        (tensor, _) = _box_aug_per_img(tensor, target, aug_type=sub_policy[0][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[0][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[0][2])\n        (tensor, target) = _box_aug_per_img(tensor, target, aug_type=sub_policy[1][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[1][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[1][2])\n    return (tensor, target)",
            "def __call__(self, tensor, target, iteration):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    iter_ratio = float(iteration) / self.max_iters\n    sub_policy = random.choice(self.policies)\n    (h, w) = tensor.shape[-2:]\n    ratio = min(h, w) / 800\n    scale_splits = [area * ratio for area in self.scale_splits]\n    if iter_ratio <= 1:\n        (tensor, _) = _box_aug_per_img(tensor, target, aug_type=sub_policy[0][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[0][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[0][2])\n        (tensor, target) = _box_aug_per_img(tensor, target, aug_type=sub_policy[1][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[1][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[1][2])\n    return (tensor, target)",
            "def __call__(self, tensor, target, iteration):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    iter_ratio = float(iteration) / self.max_iters\n    sub_policy = random.choice(self.policies)\n    (h, w) = tensor.shape[-2:]\n    ratio = min(h, w) / 800\n    scale_splits = [area * ratio for area in self.scale_splits]\n    if iter_ratio <= 1:\n        (tensor, _) = _box_aug_per_img(tensor, target, aug_type=sub_policy[0][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[0][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[0][2])\n        (tensor, target) = _box_aug_per_img(tensor, target, aug_type=sub_policy[1][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[1][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[1][2])\n    return (tensor, target)",
            "def __call__(self, tensor, target, iteration):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    iter_ratio = float(iteration) / self.max_iters\n    sub_policy = random.choice(self.policies)\n    (h, w) = tensor.shape[-2:]\n    ratio = min(h, w) / 800\n    scale_splits = [area * ratio for area in self.scale_splits]\n    if iter_ratio <= 1:\n        (tensor, _) = _box_aug_per_img(tensor, target, aug_type=sub_policy[0][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[0][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[0][2])\n        (tensor, target) = _box_aug_per_img(tensor, target, aug_type=sub_policy[1][0], scale_ratios=self.scale_ratios, scale_splits=scale_splits, img_prob=sub_policy[1][1] * iter_ratio, box_prob=self.box_prob, level=sub_policy[1][2])\n    return (tensor, target)"
        ]
    }
]