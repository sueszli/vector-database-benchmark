[
    {
        "func_name": "issue_search_query_to_conditions",
        "original": "def issue_search_query_to_conditions(query: str, group: Group, user: User, environments: Sequence[Environment]) -> Sequence[Condition]:\n    from sentry.utils.snuba import resolve_column, resolve_conditions\n    dataset = Dataset.Events if group.issue_category == GroupCategory.ERROR else Dataset.IssuePlatform\n    search_filters = parse_and_convert_issue_search_query(query, group.project.organization, [group.project], environments, user)\n    legacy_conditions = []\n    if search_filters:\n        for search_filter in search_filters:\n            from sentry.api.serializers import GroupSerializerSnuba\n            if search_filter.key.name not in GroupSerializerSnuba.skip_snuba_fields:\n                filter_keys = {'organization_id': group.project.organization.id, 'project_id': [group.project.id], 'environment': [env.name for env in environments]}\n                (legacy_condition, projects_to_filter, group_ids) = format_search_filter(search_filter, params=filter_keys)\n                new_condition = None\n                if legacy_condition:\n                    new_condition = legacy_condition[0]\n                elif group_ids:\n                    new_condition = convert_search_filter_to_snuba_query(search_filter, params=filter_keys)\n                if new_condition:\n                    legacy_conditions.append(new_condition)\n    resolved_legacy_conditions = resolve_conditions(legacy_conditions, resolve_column(dataset))\n    snql_conditions = []\n    for cond in resolved_legacy_conditions or ():\n        if not is_condition(cond):\n            or_conditions = []\n            for or_cond in cond:\n                or_conditions.append(parse_condition(or_cond))\n            if len(or_conditions) > 1:\n                snql_conditions.append(Or(or_conditions))\n            else:\n                snql_conditions.extend(or_conditions)\n        else:\n            snql_conditions.append(parse_condition(cond))\n    return snql_conditions",
        "mutated": [
            "def issue_search_query_to_conditions(query: str, group: Group, user: User, environments: Sequence[Environment]) -> Sequence[Condition]:\n    if False:\n        i = 10\n    from sentry.utils.snuba import resolve_column, resolve_conditions\n    dataset = Dataset.Events if group.issue_category == GroupCategory.ERROR else Dataset.IssuePlatform\n    search_filters = parse_and_convert_issue_search_query(query, group.project.organization, [group.project], environments, user)\n    legacy_conditions = []\n    if search_filters:\n        for search_filter in search_filters:\n            from sentry.api.serializers import GroupSerializerSnuba\n            if search_filter.key.name not in GroupSerializerSnuba.skip_snuba_fields:\n                filter_keys = {'organization_id': group.project.organization.id, 'project_id': [group.project.id], 'environment': [env.name for env in environments]}\n                (legacy_condition, projects_to_filter, group_ids) = format_search_filter(search_filter, params=filter_keys)\n                new_condition = None\n                if legacy_condition:\n                    new_condition = legacy_condition[0]\n                elif group_ids:\n                    new_condition = convert_search_filter_to_snuba_query(search_filter, params=filter_keys)\n                if new_condition:\n                    legacy_conditions.append(new_condition)\n    resolved_legacy_conditions = resolve_conditions(legacy_conditions, resolve_column(dataset))\n    snql_conditions = []\n    for cond in resolved_legacy_conditions or ():\n        if not is_condition(cond):\n            or_conditions = []\n            for or_cond in cond:\n                or_conditions.append(parse_condition(or_cond))\n            if len(or_conditions) > 1:\n                snql_conditions.append(Or(or_conditions))\n            else:\n                snql_conditions.extend(or_conditions)\n        else:\n            snql_conditions.append(parse_condition(cond))\n    return snql_conditions",
            "def issue_search_query_to_conditions(query: str, group: Group, user: User, environments: Sequence[Environment]) -> Sequence[Condition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from sentry.utils.snuba import resolve_column, resolve_conditions\n    dataset = Dataset.Events if group.issue_category == GroupCategory.ERROR else Dataset.IssuePlatform\n    search_filters = parse_and_convert_issue_search_query(query, group.project.organization, [group.project], environments, user)\n    legacy_conditions = []\n    if search_filters:\n        for search_filter in search_filters:\n            from sentry.api.serializers import GroupSerializerSnuba\n            if search_filter.key.name not in GroupSerializerSnuba.skip_snuba_fields:\n                filter_keys = {'organization_id': group.project.organization.id, 'project_id': [group.project.id], 'environment': [env.name for env in environments]}\n                (legacy_condition, projects_to_filter, group_ids) = format_search_filter(search_filter, params=filter_keys)\n                new_condition = None\n                if legacy_condition:\n                    new_condition = legacy_condition[0]\n                elif group_ids:\n                    new_condition = convert_search_filter_to_snuba_query(search_filter, params=filter_keys)\n                if new_condition:\n                    legacy_conditions.append(new_condition)\n    resolved_legacy_conditions = resolve_conditions(legacy_conditions, resolve_column(dataset))\n    snql_conditions = []\n    for cond in resolved_legacy_conditions or ():\n        if not is_condition(cond):\n            or_conditions = []\n            for or_cond in cond:\n                or_conditions.append(parse_condition(or_cond))\n            if len(or_conditions) > 1:\n                snql_conditions.append(Or(or_conditions))\n            else:\n                snql_conditions.extend(or_conditions)\n        else:\n            snql_conditions.append(parse_condition(cond))\n    return snql_conditions",
            "def issue_search_query_to_conditions(query: str, group: Group, user: User, environments: Sequence[Environment]) -> Sequence[Condition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from sentry.utils.snuba import resolve_column, resolve_conditions\n    dataset = Dataset.Events if group.issue_category == GroupCategory.ERROR else Dataset.IssuePlatform\n    search_filters = parse_and_convert_issue_search_query(query, group.project.organization, [group.project], environments, user)\n    legacy_conditions = []\n    if search_filters:\n        for search_filter in search_filters:\n            from sentry.api.serializers import GroupSerializerSnuba\n            if search_filter.key.name not in GroupSerializerSnuba.skip_snuba_fields:\n                filter_keys = {'organization_id': group.project.organization.id, 'project_id': [group.project.id], 'environment': [env.name for env in environments]}\n                (legacy_condition, projects_to_filter, group_ids) = format_search_filter(search_filter, params=filter_keys)\n                new_condition = None\n                if legacy_condition:\n                    new_condition = legacy_condition[0]\n                elif group_ids:\n                    new_condition = convert_search_filter_to_snuba_query(search_filter, params=filter_keys)\n                if new_condition:\n                    legacy_conditions.append(new_condition)\n    resolved_legacy_conditions = resolve_conditions(legacy_conditions, resolve_column(dataset))\n    snql_conditions = []\n    for cond in resolved_legacy_conditions or ():\n        if not is_condition(cond):\n            or_conditions = []\n            for or_cond in cond:\n                or_conditions.append(parse_condition(or_cond))\n            if len(or_conditions) > 1:\n                snql_conditions.append(Or(or_conditions))\n            else:\n                snql_conditions.extend(or_conditions)\n        else:\n            snql_conditions.append(parse_condition(cond))\n    return snql_conditions",
            "def issue_search_query_to_conditions(query: str, group: Group, user: User, environments: Sequence[Environment]) -> Sequence[Condition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from sentry.utils.snuba import resolve_column, resolve_conditions\n    dataset = Dataset.Events if group.issue_category == GroupCategory.ERROR else Dataset.IssuePlatform\n    search_filters = parse_and_convert_issue_search_query(query, group.project.organization, [group.project], environments, user)\n    legacy_conditions = []\n    if search_filters:\n        for search_filter in search_filters:\n            from sentry.api.serializers import GroupSerializerSnuba\n            if search_filter.key.name not in GroupSerializerSnuba.skip_snuba_fields:\n                filter_keys = {'organization_id': group.project.organization.id, 'project_id': [group.project.id], 'environment': [env.name for env in environments]}\n                (legacy_condition, projects_to_filter, group_ids) = format_search_filter(search_filter, params=filter_keys)\n                new_condition = None\n                if legacy_condition:\n                    new_condition = legacy_condition[0]\n                elif group_ids:\n                    new_condition = convert_search_filter_to_snuba_query(search_filter, params=filter_keys)\n                if new_condition:\n                    legacy_conditions.append(new_condition)\n    resolved_legacy_conditions = resolve_conditions(legacy_conditions, resolve_column(dataset))\n    snql_conditions = []\n    for cond in resolved_legacy_conditions or ():\n        if not is_condition(cond):\n            or_conditions = []\n            for or_cond in cond:\n                or_conditions.append(parse_condition(or_cond))\n            if len(or_conditions) > 1:\n                snql_conditions.append(Or(or_conditions))\n            else:\n                snql_conditions.extend(or_conditions)\n        else:\n            snql_conditions.append(parse_condition(cond))\n    return snql_conditions",
            "def issue_search_query_to_conditions(query: str, group: Group, user: User, environments: Sequence[Environment]) -> Sequence[Condition]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from sentry.utils.snuba import resolve_column, resolve_conditions\n    dataset = Dataset.Events if group.issue_category == GroupCategory.ERROR else Dataset.IssuePlatform\n    search_filters = parse_and_convert_issue_search_query(query, group.project.organization, [group.project], environments, user)\n    legacy_conditions = []\n    if search_filters:\n        for search_filter in search_filters:\n            from sentry.api.serializers import GroupSerializerSnuba\n            if search_filter.key.name not in GroupSerializerSnuba.skip_snuba_fields:\n                filter_keys = {'organization_id': group.project.organization.id, 'project_id': [group.project.id], 'environment': [env.name for env in environments]}\n                (legacy_condition, projects_to_filter, group_ids) = format_search_filter(search_filter, params=filter_keys)\n                new_condition = None\n                if legacy_condition:\n                    new_condition = legacy_condition[0]\n                elif group_ids:\n                    new_condition = convert_search_filter_to_snuba_query(search_filter, params=filter_keys)\n                if new_condition:\n                    legacy_conditions.append(new_condition)\n    resolved_legacy_conditions = resolve_conditions(legacy_conditions, resolve_column(dataset))\n    snql_conditions = []\n    for cond in resolved_legacy_conditions or ():\n        if not is_condition(cond):\n            or_conditions = []\n            for or_cond in cond:\n                or_conditions.append(parse_condition(or_cond))\n            if len(or_conditions) > 1:\n                snql_conditions.append(Or(or_conditions))\n            else:\n                snql_conditions.extend(or_conditions)\n        else:\n            snql_conditions.append(parse_condition(cond))\n    return snql_conditions"
        ]
    },
    {
        "func_name": "get",
        "original": "def get(self, request: Request, group: Group, event_id: str) -> Response:\n    \"\"\"\n        Retrieve the latest(most recent), oldest, or most helpful Event for an Issue\n        ``````````````````````````````````````\n\n        Retrieves the details of the latest/oldest/most-helpful event for an issue.\n\n        :pparam string group_id: the ID of the issue\n        \"\"\"\n    environments = [e for e in get_environments(request, group.project.organization)]\n    environment_names = [e.name for e in environments]\n    if event_id == 'latest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'latest'}):\n            event = group.get_latest_event_for_environments(environment_names)\n    elif event_id == 'oldest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'oldest'}):\n            event = group.get_oldest_event_for_environments(environment_names)\n    elif event_id in ('helpful', 'recommended'):\n        query = request.GET.get('query')\n        if query:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': True}):\n                try:\n                    conditions = issue_search_query_to_conditions(query, group, request.user, environments)\n                    event = group.get_recommended_event_for_environments(environments, conditions)\n                except ValidationError:\n                    return Response(status=400)\n                except Exception:\n                    logging.error('group_event_details:get_helpful', exc_info=True)\n                    return Response(status=500)\n        else:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': False}):\n                event = group.get_recommended_event_for_environments(environments)\n    else:\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'event'}):\n            event = eventstore.backend.get_event_by_id(group.project.id, event_id, group_id=group.id)\n        if hasattr(event, 'for_group') and event.group:\n            event = event.for_group(event.group)\n    if event is None:\n        return Response({'detail': 'Event not found'}, status=404)\n    collapse = request.GET.getlist('collapse', [])\n    if 'stacktraceOnly' in collapse:\n        return Response(serialize(event, request.user, EventSerializer()))\n    data = wrap_event_response(request.user, event, environment_names, include_full_release_data='fullRelease' not in collapse)\n    return Response(data)",
        "mutated": [
            "def get(self, request: Request, group: Group, event_id: str) -> Response:\n    if False:\n        i = 10\n    '\\n        Retrieve the latest(most recent), oldest, or most helpful Event for an Issue\\n        ``````````````````````````````````````\\n\\n        Retrieves the details of the latest/oldest/most-helpful event for an issue.\\n\\n        :pparam string group_id: the ID of the issue\\n        '\n    environments = [e for e in get_environments(request, group.project.organization)]\n    environment_names = [e.name for e in environments]\n    if event_id == 'latest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'latest'}):\n            event = group.get_latest_event_for_environments(environment_names)\n    elif event_id == 'oldest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'oldest'}):\n            event = group.get_oldest_event_for_environments(environment_names)\n    elif event_id in ('helpful', 'recommended'):\n        query = request.GET.get('query')\n        if query:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': True}):\n                try:\n                    conditions = issue_search_query_to_conditions(query, group, request.user, environments)\n                    event = group.get_recommended_event_for_environments(environments, conditions)\n                except ValidationError:\n                    return Response(status=400)\n                except Exception:\n                    logging.error('group_event_details:get_helpful', exc_info=True)\n                    return Response(status=500)\n        else:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': False}):\n                event = group.get_recommended_event_for_environments(environments)\n    else:\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'event'}):\n            event = eventstore.backend.get_event_by_id(group.project.id, event_id, group_id=group.id)\n        if hasattr(event, 'for_group') and event.group:\n            event = event.for_group(event.group)\n    if event is None:\n        return Response({'detail': 'Event not found'}, status=404)\n    collapse = request.GET.getlist('collapse', [])\n    if 'stacktraceOnly' in collapse:\n        return Response(serialize(event, request.user, EventSerializer()))\n    data = wrap_event_response(request.user, event, environment_names, include_full_release_data='fullRelease' not in collapse)\n    return Response(data)",
            "def get(self, request: Request, group: Group, event_id: str) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Retrieve the latest(most recent), oldest, or most helpful Event for an Issue\\n        ``````````````````````````````````````\\n\\n        Retrieves the details of the latest/oldest/most-helpful event for an issue.\\n\\n        :pparam string group_id: the ID of the issue\\n        '\n    environments = [e for e in get_environments(request, group.project.organization)]\n    environment_names = [e.name for e in environments]\n    if event_id == 'latest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'latest'}):\n            event = group.get_latest_event_for_environments(environment_names)\n    elif event_id == 'oldest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'oldest'}):\n            event = group.get_oldest_event_for_environments(environment_names)\n    elif event_id in ('helpful', 'recommended'):\n        query = request.GET.get('query')\n        if query:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': True}):\n                try:\n                    conditions = issue_search_query_to_conditions(query, group, request.user, environments)\n                    event = group.get_recommended_event_for_environments(environments, conditions)\n                except ValidationError:\n                    return Response(status=400)\n                except Exception:\n                    logging.error('group_event_details:get_helpful', exc_info=True)\n                    return Response(status=500)\n        else:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': False}):\n                event = group.get_recommended_event_for_environments(environments)\n    else:\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'event'}):\n            event = eventstore.backend.get_event_by_id(group.project.id, event_id, group_id=group.id)\n        if hasattr(event, 'for_group') and event.group:\n            event = event.for_group(event.group)\n    if event is None:\n        return Response({'detail': 'Event not found'}, status=404)\n    collapse = request.GET.getlist('collapse', [])\n    if 'stacktraceOnly' in collapse:\n        return Response(serialize(event, request.user, EventSerializer()))\n    data = wrap_event_response(request.user, event, environment_names, include_full_release_data='fullRelease' not in collapse)\n    return Response(data)",
            "def get(self, request: Request, group: Group, event_id: str) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Retrieve the latest(most recent), oldest, or most helpful Event for an Issue\\n        ``````````````````````````````````````\\n\\n        Retrieves the details of the latest/oldest/most-helpful event for an issue.\\n\\n        :pparam string group_id: the ID of the issue\\n        '\n    environments = [e for e in get_environments(request, group.project.organization)]\n    environment_names = [e.name for e in environments]\n    if event_id == 'latest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'latest'}):\n            event = group.get_latest_event_for_environments(environment_names)\n    elif event_id == 'oldest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'oldest'}):\n            event = group.get_oldest_event_for_environments(environment_names)\n    elif event_id in ('helpful', 'recommended'):\n        query = request.GET.get('query')\n        if query:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': True}):\n                try:\n                    conditions = issue_search_query_to_conditions(query, group, request.user, environments)\n                    event = group.get_recommended_event_for_environments(environments, conditions)\n                except ValidationError:\n                    return Response(status=400)\n                except Exception:\n                    logging.error('group_event_details:get_helpful', exc_info=True)\n                    return Response(status=500)\n        else:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': False}):\n                event = group.get_recommended_event_for_environments(environments)\n    else:\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'event'}):\n            event = eventstore.backend.get_event_by_id(group.project.id, event_id, group_id=group.id)\n        if hasattr(event, 'for_group') and event.group:\n            event = event.for_group(event.group)\n    if event is None:\n        return Response({'detail': 'Event not found'}, status=404)\n    collapse = request.GET.getlist('collapse', [])\n    if 'stacktraceOnly' in collapse:\n        return Response(serialize(event, request.user, EventSerializer()))\n    data = wrap_event_response(request.user, event, environment_names, include_full_release_data='fullRelease' not in collapse)\n    return Response(data)",
            "def get(self, request: Request, group: Group, event_id: str) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Retrieve the latest(most recent), oldest, or most helpful Event for an Issue\\n        ``````````````````````````````````````\\n\\n        Retrieves the details of the latest/oldest/most-helpful event for an issue.\\n\\n        :pparam string group_id: the ID of the issue\\n        '\n    environments = [e for e in get_environments(request, group.project.organization)]\n    environment_names = [e.name for e in environments]\n    if event_id == 'latest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'latest'}):\n            event = group.get_latest_event_for_environments(environment_names)\n    elif event_id == 'oldest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'oldest'}):\n            event = group.get_oldest_event_for_environments(environment_names)\n    elif event_id in ('helpful', 'recommended'):\n        query = request.GET.get('query')\n        if query:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': True}):\n                try:\n                    conditions = issue_search_query_to_conditions(query, group, request.user, environments)\n                    event = group.get_recommended_event_for_environments(environments, conditions)\n                except ValidationError:\n                    return Response(status=400)\n                except Exception:\n                    logging.error('group_event_details:get_helpful', exc_info=True)\n                    return Response(status=500)\n        else:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': False}):\n                event = group.get_recommended_event_for_environments(environments)\n    else:\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'event'}):\n            event = eventstore.backend.get_event_by_id(group.project.id, event_id, group_id=group.id)\n        if hasattr(event, 'for_group') and event.group:\n            event = event.for_group(event.group)\n    if event is None:\n        return Response({'detail': 'Event not found'}, status=404)\n    collapse = request.GET.getlist('collapse', [])\n    if 'stacktraceOnly' in collapse:\n        return Response(serialize(event, request.user, EventSerializer()))\n    data = wrap_event_response(request.user, event, environment_names, include_full_release_data='fullRelease' not in collapse)\n    return Response(data)",
            "def get(self, request: Request, group: Group, event_id: str) -> Response:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Retrieve the latest(most recent), oldest, or most helpful Event for an Issue\\n        ``````````````````````````````````````\\n\\n        Retrieves the details of the latest/oldest/most-helpful event for an issue.\\n\\n        :pparam string group_id: the ID of the issue\\n        '\n    environments = [e for e in get_environments(request, group.project.organization)]\n    environment_names = [e.name for e in environments]\n    if event_id == 'latest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'latest'}):\n            event = group.get_latest_event_for_environments(environment_names)\n    elif event_id == 'oldest':\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'oldest'}):\n            event = group.get_oldest_event_for_environments(environment_names)\n    elif event_id in ('helpful', 'recommended'):\n        query = request.GET.get('query')\n        if query:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': True}):\n                try:\n                    conditions = issue_search_query_to_conditions(query, group, request.user, environments)\n                    event = group.get_recommended_event_for_environments(environments, conditions)\n                except ValidationError:\n                    return Response(status=400)\n                except Exception:\n                    logging.error('group_event_details:get_helpful', exc_info=True)\n                    return Response(status=500)\n        else:\n            with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'helpful', 'query': False}):\n                event = group.get_recommended_event_for_environments(environments)\n    else:\n        with metrics.timer('api.endpoints.group_event_details.get', tags={'type': 'event'}):\n            event = eventstore.backend.get_event_by_id(group.project.id, event_id, group_id=group.id)\n        if hasattr(event, 'for_group') and event.group:\n            event = event.for_group(event.group)\n    if event is None:\n        return Response({'detail': 'Event not found'}, status=404)\n    collapse = request.GET.getlist('collapse', [])\n    if 'stacktraceOnly' in collapse:\n        return Response(serialize(event, request.user, EventSerializer()))\n    data = wrap_event_response(request.user, event, environment_names, include_full_release_data='fullRelease' not in collapse)\n    return Response(data)"
        ]
    }
]