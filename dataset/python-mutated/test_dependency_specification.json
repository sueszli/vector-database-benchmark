[
    {
        "func_name": "_mock",
        "original": "def _mock(self: Path) -> bool:\n    if '/' in requirement and self == Path.cwd().joinpath(requirement):\n        return True\n    return original(self)",
        "mutated": [
            "def _mock(self: Path) -> bool:\n    if False:\n        i = 10\n    if '/' in requirement and self == Path.cwd().joinpath(requirement):\n        return True\n    return original(self)",
            "def _mock(self: Path) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if '/' in requirement and self == Path.cwd().joinpath(requirement):\n        return True\n    return original(self)",
            "def _mock(self: Path) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if '/' in requirement and self == Path.cwd().joinpath(requirement):\n        return True\n    return original(self)",
            "def _mock(self: Path) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if '/' in requirement and self == Path.cwd().joinpath(requirement):\n        return True\n    return original(self)",
            "def _mock(self: Path) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if '/' in requirement and self == Path.cwd().joinpath(requirement):\n        return True\n    return original(self)"
        ]
    },
    {
        "func_name": "test_parse_dependency_specification",
        "original": "@pytest.mark.parametrize(('requirement', 'expected_variants'), [('git+http://github.com/demo/demo.git', ({'git': 'http://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo'},)), ('git+ssh://github.com/demo/demo.git', ({'git': 'ssh://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git#main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/demo.git@main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/subdirectories.git@main#subdirectory=two', ({'git': 'https://github.com/demo/subdirectories.git', 'name': 'two', 'rev': 'main', 'subdirectory': 'two'},)), ('demo', ({'name': 'demo'},)), ('demo@1.0.0', ({'name': 'demo', 'version': '1.0.0'},)), ('demo@^1.0.0', ({'name': 'demo', 'version': '^1.0.0'},)), ('demo@==1.0.0', ({'name': 'demo', 'version': '==1.0.0'},)), ('demo@!=1.0.0', ({'name': 'demo', 'version': '!=1.0.0'},)), ('demo@~1.0.0', ({'name': 'demo', 'version': '~1.0.0'},)), ('demo[a,b]@1.0.0', ({'name': 'demo', 'version': '1.0.0', 'extras': ['a', 'b']},)), ('demo[a,b]', ({'name': 'demo', 'extras': ['a', 'b']},)), ('../demo', ({'name': 'demo', 'path': '../demo'},)), ('../demo/demo.whl', ({'name': 'demo', 'path': '../demo/demo.whl'},)), ('https://example.com/distributions/demo-0.1.0.tar.gz', ({'name': 'demo', 'url': 'https://example.com/distributions/demo-0.1.0.tar.gz'},)), ('poetry-core (>=1.0.7,<1.1.0)', ({'name': 'poetry-core', 'version': '>=1.0.7,<1.1.0'},)), ('requests [security,tests] >= 2.8.1, == 2.8.* ; python_version < \"2.7\"', ({'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,==2.8.*', 'extras': ['security', 'tests']})), ('name (>=3,<4)', ({'name': 'name', 'version': '>=3,<4'},)), ('name@http://foo.com', ({'name': 'name', 'url': 'http://foo.com'},)), (\"name [fred,bar] @ http://foo.com ; python_version=='2.7'\", ({'name': 'name', 'markers': 'python_version == \"2.7\"', 'url': 'http://foo.com', 'extras': ['fred', 'bar']},)), ('cachecontrol[filecache] (>=0.12.9,<0.13.0); python_version >= \"3.6\" and python_version < \"4.0\"', ({'version': '>=0.12.9,<0.13.0', 'markers': 'python_version >= \"3.6\" and python_version < \"4.0\"', 'extras': ['filecache'], 'name': 'cachecontrol'},))])\ndef test_parse_dependency_specification(requirement: str, expected_variants: Collection[DependencySpec], mocker: MockerFixture, artifact_cache: ArtifactCache) -> None:\n    original = Path.exists\n\n    def _mock(self: Path) -> bool:\n        if '/' in requirement and self == Path.cwd().joinpath(requirement):\n            return True\n        return original(self)\n    mocker.patch('pathlib.Path.exists', _mock)\n    assert any((not DeepDiff(RequirementsParser(artifact_cache=artifact_cache).parse(requirement), specification, ignore_order=True) for specification in expected_variants))",
        "mutated": [
            "@pytest.mark.parametrize(('requirement', 'expected_variants'), [('git+http://github.com/demo/demo.git', ({'git': 'http://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo'},)), ('git+ssh://github.com/demo/demo.git', ({'git': 'ssh://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git#main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/demo.git@main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/subdirectories.git@main#subdirectory=two', ({'git': 'https://github.com/demo/subdirectories.git', 'name': 'two', 'rev': 'main', 'subdirectory': 'two'},)), ('demo', ({'name': 'demo'},)), ('demo@1.0.0', ({'name': 'demo', 'version': '1.0.0'},)), ('demo@^1.0.0', ({'name': 'demo', 'version': '^1.0.0'},)), ('demo@==1.0.0', ({'name': 'demo', 'version': '==1.0.0'},)), ('demo@!=1.0.0', ({'name': 'demo', 'version': '!=1.0.0'},)), ('demo@~1.0.0', ({'name': 'demo', 'version': '~1.0.0'},)), ('demo[a,b]@1.0.0', ({'name': 'demo', 'version': '1.0.0', 'extras': ['a', 'b']},)), ('demo[a,b]', ({'name': 'demo', 'extras': ['a', 'b']},)), ('../demo', ({'name': 'demo', 'path': '../demo'},)), ('../demo/demo.whl', ({'name': 'demo', 'path': '../demo/demo.whl'},)), ('https://example.com/distributions/demo-0.1.0.tar.gz', ({'name': 'demo', 'url': 'https://example.com/distributions/demo-0.1.0.tar.gz'},)), ('poetry-core (>=1.0.7,<1.1.0)', ({'name': 'poetry-core', 'version': '>=1.0.7,<1.1.0'},)), ('requests [security,tests] >= 2.8.1, == 2.8.* ; python_version < \"2.7\"', ({'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,==2.8.*', 'extras': ['security', 'tests']})), ('name (>=3,<4)', ({'name': 'name', 'version': '>=3,<4'},)), ('name@http://foo.com', ({'name': 'name', 'url': 'http://foo.com'},)), (\"name [fred,bar] @ http://foo.com ; python_version=='2.7'\", ({'name': 'name', 'markers': 'python_version == \"2.7\"', 'url': 'http://foo.com', 'extras': ['fred', 'bar']},)), ('cachecontrol[filecache] (>=0.12.9,<0.13.0); python_version >= \"3.6\" and python_version < \"4.0\"', ({'version': '>=0.12.9,<0.13.0', 'markers': 'python_version >= \"3.6\" and python_version < \"4.0\"', 'extras': ['filecache'], 'name': 'cachecontrol'},))])\ndef test_parse_dependency_specification(requirement: str, expected_variants: Collection[DependencySpec], mocker: MockerFixture, artifact_cache: ArtifactCache) -> None:\n    if False:\n        i = 10\n    original = Path.exists\n\n    def _mock(self: Path) -> bool:\n        if '/' in requirement and self == Path.cwd().joinpath(requirement):\n            return True\n        return original(self)\n    mocker.patch('pathlib.Path.exists', _mock)\n    assert any((not DeepDiff(RequirementsParser(artifact_cache=artifact_cache).parse(requirement), specification, ignore_order=True) for specification in expected_variants))",
            "@pytest.mark.parametrize(('requirement', 'expected_variants'), [('git+http://github.com/demo/demo.git', ({'git': 'http://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo'},)), ('git+ssh://github.com/demo/demo.git', ({'git': 'ssh://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git#main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/demo.git@main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/subdirectories.git@main#subdirectory=two', ({'git': 'https://github.com/demo/subdirectories.git', 'name': 'two', 'rev': 'main', 'subdirectory': 'two'},)), ('demo', ({'name': 'demo'},)), ('demo@1.0.0', ({'name': 'demo', 'version': '1.0.0'},)), ('demo@^1.0.0', ({'name': 'demo', 'version': '^1.0.0'},)), ('demo@==1.0.0', ({'name': 'demo', 'version': '==1.0.0'},)), ('demo@!=1.0.0', ({'name': 'demo', 'version': '!=1.0.0'},)), ('demo@~1.0.0', ({'name': 'demo', 'version': '~1.0.0'},)), ('demo[a,b]@1.0.0', ({'name': 'demo', 'version': '1.0.0', 'extras': ['a', 'b']},)), ('demo[a,b]', ({'name': 'demo', 'extras': ['a', 'b']},)), ('../demo', ({'name': 'demo', 'path': '../demo'},)), ('../demo/demo.whl', ({'name': 'demo', 'path': '../demo/demo.whl'},)), ('https://example.com/distributions/demo-0.1.0.tar.gz', ({'name': 'demo', 'url': 'https://example.com/distributions/demo-0.1.0.tar.gz'},)), ('poetry-core (>=1.0.7,<1.1.0)', ({'name': 'poetry-core', 'version': '>=1.0.7,<1.1.0'},)), ('requests [security,tests] >= 2.8.1, == 2.8.* ; python_version < \"2.7\"', ({'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,==2.8.*', 'extras': ['security', 'tests']})), ('name (>=3,<4)', ({'name': 'name', 'version': '>=3,<4'},)), ('name@http://foo.com', ({'name': 'name', 'url': 'http://foo.com'},)), (\"name [fred,bar] @ http://foo.com ; python_version=='2.7'\", ({'name': 'name', 'markers': 'python_version == \"2.7\"', 'url': 'http://foo.com', 'extras': ['fred', 'bar']},)), ('cachecontrol[filecache] (>=0.12.9,<0.13.0); python_version >= \"3.6\" and python_version < \"4.0\"', ({'version': '>=0.12.9,<0.13.0', 'markers': 'python_version >= \"3.6\" and python_version < \"4.0\"', 'extras': ['filecache'], 'name': 'cachecontrol'},))])\ndef test_parse_dependency_specification(requirement: str, expected_variants: Collection[DependencySpec], mocker: MockerFixture, artifact_cache: ArtifactCache) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    original = Path.exists\n\n    def _mock(self: Path) -> bool:\n        if '/' in requirement and self == Path.cwd().joinpath(requirement):\n            return True\n        return original(self)\n    mocker.patch('pathlib.Path.exists', _mock)\n    assert any((not DeepDiff(RequirementsParser(artifact_cache=artifact_cache).parse(requirement), specification, ignore_order=True) for specification in expected_variants))",
            "@pytest.mark.parametrize(('requirement', 'expected_variants'), [('git+http://github.com/demo/demo.git', ({'git': 'http://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo'},)), ('git+ssh://github.com/demo/demo.git', ({'git': 'ssh://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git#main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/demo.git@main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/subdirectories.git@main#subdirectory=two', ({'git': 'https://github.com/demo/subdirectories.git', 'name': 'two', 'rev': 'main', 'subdirectory': 'two'},)), ('demo', ({'name': 'demo'},)), ('demo@1.0.0', ({'name': 'demo', 'version': '1.0.0'},)), ('demo@^1.0.0', ({'name': 'demo', 'version': '^1.0.0'},)), ('demo@==1.0.0', ({'name': 'demo', 'version': '==1.0.0'},)), ('demo@!=1.0.0', ({'name': 'demo', 'version': '!=1.0.0'},)), ('demo@~1.0.0', ({'name': 'demo', 'version': '~1.0.0'},)), ('demo[a,b]@1.0.0', ({'name': 'demo', 'version': '1.0.0', 'extras': ['a', 'b']},)), ('demo[a,b]', ({'name': 'demo', 'extras': ['a', 'b']},)), ('../demo', ({'name': 'demo', 'path': '../demo'},)), ('../demo/demo.whl', ({'name': 'demo', 'path': '../demo/demo.whl'},)), ('https://example.com/distributions/demo-0.1.0.tar.gz', ({'name': 'demo', 'url': 'https://example.com/distributions/demo-0.1.0.tar.gz'},)), ('poetry-core (>=1.0.7,<1.1.0)', ({'name': 'poetry-core', 'version': '>=1.0.7,<1.1.0'},)), ('requests [security,tests] >= 2.8.1, == 2.8.* ; python_version < \"2.7\"', ({'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,==2.8.*', 'extras': ['security', 'tests']})), ('name (>=3,<4)', ({'name': 'name', 'version': '>=3,<4'},)), ('name@http://foo.com', ({'name': 'name', 'url': 'http://foo.com'},)), (\"name [fred,bar] @ http://foo.com ; python_version=='2.7'\", ({'name': 'name', 'markers': 'python_version == \"2.7\"', 'url': 'http://foo.com', 'extras': ['fred', 'bar']},)), ('cachecontrol[filecache] (>=0.12.9,<0.13.0); python_version >= \"3.6\" and python_version < \"4.0\"', ({'version': '>=0.12.9,<0.13.0', 'markers': 'python_version >= \"3.6\" and python_version < \"4.0\"', 'extras': ['filecache'], 'name': 'cachecontrol'},))])\ndef test_parse_dependency_specification(requirement: str, expected_variants: Collection[DependencySpec], mocker: MockerFixture, artifact_cache: ArtifactCache) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    original = Path.exists\n\n    def _mock(self: Path) -> bool:\n        if '/' in requirement and self == Path.cwd().joinpath(requirement):\n            return True\n        return original(self)\n    mocker.patch('pathlib.Path.exists', _mock)\n    assert any((not DeepDiff(RequirementsParser(artifact_cache=artifact_cache).parse(requirement), specification, ignore_order=True) for specification in expected_variants))",
            "@pytest.mark.parametrize(('requirement', 'expected_variants'), [('git+http://github.com/demo/demo.git', ({'git': 'http://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo'},)), ('git+ssh://github.com/demo/demo.git', ({'git': 'ssh://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git#main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/demo.git@main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/subdirectories.git@main#subdirectory=two', ({'git': 'https://github.com/demo/subdirectories.git', 'name': 'two', 'rev': 'main', 'subdirectory': 'two'},)), ('demo', ({'name': 'demo'},)), ('demo@1.0.0', ({'name': 'demo', 'version': '1.0.0'},)), ('demo@^1.0.0', ({'name': 'demo', 'version': '^1.0.0'},)), ('demo@==1.0.0', ({'name': 'demo', 'version': '==1.0.0'},)), ('demo@!=1.0.0', ({'name': 'demo', 'version': '!=1.0.0'},)), ('demo@~1.0.0', ({'name': 'demo', 'version': '~1.0.0'},)), ('demo[a,b]@1.0.0', ({'name': 'demo', 'version': '1.0.0', 'extras': ['a', 'b']},)), ('demo[a,b]', ({'name': 'demo', 'extras': ['a', 'b']},)), ('../demo', ({'name': 'demo', 'path': '../demo'},)), ('../demo/demo.whl', ({'name': 'demo', 'path': '../demo/demo.whl'},)), ('https://example.com/distributions/demo-0.1.0.tar.gz', ({'name': 'demo', 'url': 'https://example.com/distributions/demo-0.1.0.tar.gz'},)), ('poetry-core (>=1.0.7,<1.1.0)', ({'name': 'poetry-core', 'version': '>=1.0.7,<1.1.0'},)), ('requests [security,tests] >= 2.8.1, == 2.8.* ; python_version < \"2.7\"', ({'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,==2.8.*', 'extras': ['security', 'tests']})), ('name (>=3,<4)', ({'name': 'name', 'version': '>=3,<4'},)), ('name@http://foo.com', ({'name': 'name', 'url': 'http://foo.com'},)), (\"name [fred,bar] @ http://foo.com ; python_version=='2.7'\", ({'name': 'name', 'markers': 'python_version == \"2.7\"', 'url': 'http://foo.com', 'extras': ['fred', 'bar']},)), ('cachecontrol[filecache] (>=0.12.9,<0.13.0); python_version >= \"3.6\" and python_version < \"4.0\"', ({'version': '>=0.12.9,<0.13.0', 'markers': 'python_version >= \"3.6\" and python_version < \"4.0\"', 'extras': ['filecache'], 'name': 'cachecontrol'},))])\ndef test_parse_dependency_specification(requirement: str, expected_variants: Collection[DependencySpec], mocker: MockerFixture, artifact_cache: ArtifactCache) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    original = Path.exists\n\n    def _mock(self: Path) -> bool:\n        if '/' in requirement and self == Path.cwd().joinpath(requirement):\n            return True\n        return original(self)\n    mocker.patch('pathlib.Path.exists', _mock)\n    assert any((not DeepDiff(RequirementsParser(artifact_cache=artifact_cache).parse(requirement), specification, ignore_order=True) for specification in expected_variants))",
            "@pytest.mark.parametrize(('requirement', 'expected_variants'), [('git+http://github.com/demo/demo.git', ({'git': 'http://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo'},)), ('git+ssh://github.com/demo/demo.git', ({'git': 'ssh://github.com/demo/demo.git', 'name': 'demo'},)), ('git+https://github.com/demo/demo.git#main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/demo.git@main', ({'git': 'https://github.com/demo/demo.git', 'name': 'demo', 'rev': 'main'},)), ('git+https://github.com/demo/subdirectories.git@main#subdirectory=two', ({'git': 'https://github.com/demo/subdirectories.git', 'name': 'two', 'rev': 'main', 'subdirectory': 'two'},)), ('demo', ({'name': 'demo'},)), ('demo@1.0.0', ({'name': 'demo', 'version': '1.0.0'},)), ('demo@^1.0.0', ({'name': 'demo', 'version': '^1.0.0'},)), ('demo@==1.0.0', ({'name': 'demo', 'version': '==1.0.0'},)), ('demo@!=1.0.0', ({'name': 'demo', 'version': '!=1.0.0'},)), ('demo@~1.0.0', ({'name': 'demo', 'version': '~1.0.0'},)), ('demo[a,b]@1.0.0', ({'name': 'demo', 'version': '1.0.0', 'extras': ['a', 'b']},)), ('demo[a,b]', ({'name': 'demo', 'extras': ['a', 'b']},)), ('../demo', ({'name': 'demo', 'path': '../demo'},)), ('../demo/demo.whl', ({'name': 'demo', 'path': '../demo/demo.whl'},)), ('https://example.com/distributions/demo-0.1.0.tar.gz', ({'name': 'demo', 'url': 'https://example.com/distributions/demo-0.1.0.tar.gz'},)), ('poetry-core (>=1.0.7,<1.1.0)', ({'name': 'poetry-core', 'version': '>=1.0.7,<1.1.0'},)), ('requests [security,tests] >= 2.8.1, == 2.8.* ; python_version < \"2.7\"', ({'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,<2.9.0.dev0', 'extras': ['security', 'tests']}, {'name': 'requests', 'markers': 'python_version < \"2.7\"', 'version': '>=2.8.1,==2.8.*', 'extras': ['security', 'tests']})), ('name (>=3,<4)', ({'name': 'name', 'version': '>=3,<4'},)), ('name@http://foo.com', ({'name': 'name', 'url': 'http://foo.com'},)), (\"name [fred,bar] @ http://foo.com ; python_version=='2.7'\", ({'name': 'name', 'markers': 'python_version == \"2.7\"', 'url': 'http://foo.com', 'extras': ['fred', 'bar']},)), ('cachecontrol[filecache] (>=0.12.9,<0.13.0); python_version >= \"3.6\" and python_version < \"4.0\"', ({'version': '>=0.12.9,<0.13.0', 'markers': 'python_version >= \"3.6\" and python_version < \"4.0\"', 'extras': ['filecache'], 'name': 'cachecontrol'},))])\ndef test_parse_dependency_specification(requirement: str, expected_variants: Collection[DependencySpec], mocker: MockerFixture, artifact_cache: ArtifactCache) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    original = Path.exists\n\n    def _mock(self: Path) -> bool:\n        if '/' in requirement and self == Path.cwd().joinpath(requirement):\n            return True\n        return original(self)\n    mocker.patch('pathlib.Path.exists', _mock)\n    assert any((not DeepDiff(RequirementsParser(artifact_cache=artifact_cache).parse(requirement), specification, ignore_order=True) for specification in expected_variants))"
        ]
    }
]