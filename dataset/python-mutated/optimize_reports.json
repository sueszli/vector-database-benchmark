[
    {
        "func_name": "generate_trade_signal_candles",
        "original": "def generate_trade_signal_candles(preprocessed_df: Dict[str, DataFrame], bt_results: Dict[str, Any]) -> DataFrame:\n    signal_candles_only = {}\n    for pair in preprocessed_df.keys():\n        signal_candles_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        resdf = bt_results['results']\n        pairresults = resdf.loc[resdf['pair'] == pair]\n        if pairdf.shape[0] > 0:\n            for (t, v) in pairresults.open_date.items():\n                allinds = pairdf.loc[pairdf['date'] < v]\n                signal_inds = allinds.iloc[[-1]]\n                signal_candles_only_df = concat([signal_candles_only_df.infer_objects(), signal_inds.infer_objects()])\n            signal_candles_only[pair] = signal_candles_only_df\n    return signal_candles_only",
        "mutated": [
            "def generate_trade_signal_candles(preprocessed_df: Dict[str, DataFrame], bt_results: Dict[str, Any]) -> DataFrame:\n    if False:\n        i = 10\n    signal_candles_only = {}\n    for pair in preprocessed_df.keys():\n        signal_candles_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        resdf = bt_results['results']\n        pairresults = resdf.loc[resdf['pair'] == pair]\n        if pairdf.shape[0] > 0:\n            for (t, v) in pairresults.open_date.items():\n                allinds = pairdf.loc[pairdf['date'] < v]\n                signal_inds = allinds.iloc[[-1]]\n                signal_candles_only_df = concat([signal_candles_only_df.infer_objects(), signal_inds.infer_objects()])\n            signal_candles_only[pair] = signal_candles_only_df\n    return signal_candles_only",
            "def generate_trade_signal_candles(preprocessed_df: Dict[str, DataFrame], bt_results: Dict[str, Any]) -> DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    signal_candles_only = {}\n    for pair in preprocessed_df.keys():\n        signal_candles_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        resdf = bt_results['results']\n        pairresults = resdf.loc[resdf['pair'] == pair]\n        if pairdf.shape[0] > 0:\n            for (t, v) in pairresults.open_date.items():\n                allinds = pairdf.loc[pairdf['date'] < v]\n                signal_inds = allinds.iloc[[-1]]\n                signal_candles_only_df = concat([signal_candles_only_df.infer_objects(), signal_inds.infer_objects()])\n            signal_candles_only[pair] = signal_candles_only_df\n    return signal_candles_only",
            "def generate_trade_signal_candles(preprocessed_df: Dict[str, DataFrame], bt_results: Dict[str, Any]) -> DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    signal_candles_only = {}\n    for pair in preprocessed_df.keys():\n        signal_candles_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        resdf = bt_results['results']\n        pairresults = resdf.loc[resdf['pair'] == pair]\n        if pairdf.shape[0] > 0:\n            for (t, v) in pairresults.open_date.items():\n                allinds = pairdf.loc[pairdf['date'] < v]\n                signal_inds = allinds.iloc[[-1]]\n                signal_candles_only_df = concat([signal_candles_only_df.infer_objects(), signal_inds.infer_objects()])\n            signal_candles_only[pair] = signal_candles_only_df\n    return signal_candles_only",
            "def generate_trade_signal_candles(preprocessed_df: Dict[str, DataFrame], bt_results: Dict[str, Any]) -> DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    signal_candles_only = {}\n    for pair in preprocessed_df.keys():\n        signal_candles_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        resdf = bt_results['results']\n        pairresults = resdf.loc[resdf['pair'] == pair]\n        if pairdf.shape[0] > 0:\n            for (t, v) in pairresults.open_date.items():\n                allinds = pairdf.loc[pairdf['date'] < v]\n                signal_inds = allinds.iloc[[-1]]\n                signal_candles_only_df = concat([signal_candles_only_df.infer_objects(), signal_inds.infer_objects()])\n            signal_candles_only[pair] = signal_candles_only_df\n    return signal_candles_only",
            "def generate_trade_signal_candles(preprocessed_df: Dict[str, DataFrame], bt_results: Dict[str, Any]) -> DataFrame:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    signal_candles_only = {}\n    for pair in preprocessed_df.keys():\n        signal_candles_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        resdf = bt_results['results']\n        pairresults = resdf.loc[resdf['pair'] == pair]\n        if pairdf.shape[0] > 0:\n            for (t, v) in pairresults.open_date.items():\n                allinds = pairdf.loc[pairdf['date'] < v]\n                signal_inds = allinds.iloc[[-1]]\n                signal_candles_only_df = concat([signal_candles_only_df.infer_objects(), signal_inds.infer_objects()])\n            signal_candles_only[pair] = signal_candles_only_df\n    return signal_candles_only"
        ]
    },
    {
        "func_name": "generate_rejected_signals",
        "original": "def generate_rejected_signals(preprocessed_df: Dict[str, DataFrame], rejected_dict: Dict[str, DataFrame]) -> Dict[str, DataFrame]:\n    rejected_candles_only = {}\n    for (pair, signals) in rejected_dict.items():\n        rejected_signals_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        for t in signals:\n            data_df_row = pairdf.loc[pairdf['date'] == t[0]].copy()\n            data_df_row['pair'] = pair\n            data_df_row['enter_tag'] = t[1]\n            rejected_signals_only_df = concat([rejected_signals_only_df.infer_objects(), data_df_row.infer_objects()])\n        rejected_candles_only[pair] = rejected_signals_only_df\n    return rejected_candles_only",
        "mutated": [
            "def generate_rejected_signals(preprocessed_df: Dict[str, DataFrame], rejected_dict: Dict[str, DataFrame]) -> Dict[str, DataFrame]:\n    if False:\n        i = 10\n    rejected_candles_only = {}\n    for (pair, signals) in rejected_dict.items():\n        rejected_signals_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        for t in signals:\n            data_df_row = pairdf.loc[pairdf['date'] == t[0]].copy()\n            data_df_row['pair'] = pair\n            data_df_row['enter_tag'] = t[1]\n            rejected_signals_only_df = concat([rejected_signals_only_df.infer_objects(), data_df_row.infer_objects()])\n        rejected_candles_only[pair] = rejected_signals_only_df\n    return rejected_candles_only",
            "def generate_rejected_signals(preprocessed_df: Dict[str, DataFrame], rejected_dict: Dict[str, DataFrame]) -> Dict[str, DataFrame]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rejected_candles_only = {}\n    for (pair, signals) in rejected_dict.items():\n        rejected_signals_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        for t in signals:\n            data_df_row = pairdf.loc[pairdf['date'] == t[0]].copy()\n            data_df_row['pair'] = pair\n            data_df_row['enter_tag'] = t[1]\n            rejected_signals_only_df = concat([rejected_signals_only_df.infer_objects(), data_df_row.infer_objects()])\n        rejected_candles_only[pair] = rejected_signals_only_df\n    return rejected_candles_only",
            "def generate_rejected_signals(preprocessed_df: Dict[str, DataFrame], rejected_dict: Dict[str, DataFrame]) -> Dict[str, DataFrame]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rejected_candles_only = {}\n    for (pair, signals) in rejected_dict.items():\n        rejected_signals_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        for t in signals:\n            data_df_row = pairdf.loc[pairdf['date'] == t[0]].copy()\n            data_df_row['pair'] = pair\n            data_df_row['enter_tag'] = t[1]\n            rejected_signals_only_df = concat([rejected_signals_only_df.infer_objects(), data_df_row.infer_objects()])\n        rejected_candles_only[pair] = rejected_signals_only_df\n    return rejected_candles_only",
            "def generate_rejected_signals(preprocessed_df: Dict[str, DataFrame], rejected_dict: Dict[str, DataFrame]) -> Dict[str, DataFrame]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rejected_candles_only = {}\n    for (pair, signals) in rejected_dict.items():\n        rejected_signals_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        for t in signals:\n            data_df_row = pairdf.loc[pairdf['date'] == t[0]].copy()\n            data_df_row['pair'] = pair\n            data_df_row['enter_tag'] = t[1]\n            rejected_signals_only_df = concat([rejected_signals_only_df.infer_objects(), data_df_row.infer_objects()])\n        rejected_candles_only[pair] = rejected_signals_only_df\n    return rejected_candles_only",
            "def generate_rejected_signals(preprocessed_df: Dict[str, DataFrame], rejected_dict: Dict[str, DataFrame]) -> Dict[str, DataFrame]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rejected_candles_only = {}\n    for (pair, signals) in rejected_dict.items():\n        rejected_signals_only_df = DataFrame()\n        pairdf = preprocessed_df[pair]\n        for t in signals:\n            data_df_row = pairdf.loc[pairdf['date'] == t[0]].copy()\n            data_df_row['pair'] = pair\n            data_df_row['enter_tag'] = t[1]\n            rejected_signals_only_df = concat([rejected_signals_only_df.infer_objects(), data_df_row.infer_objects()])\n        rejected_candles_only[pair] = rejected_signals_only_df\n    return rejected_candles_only"
        ]
    },
    {
        "func_name": "_generate_result_line",
        "original": "def _generate_result_line(result: DataFrame, starting_balance: int, first_column: str) -> Dict:\n    \"\"\"\n    Generate one result dict, with \"first_column\" as key.\n    \"\"\"\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': result['profit_ratio'].mean() if len(result) > 0 else 0.0, 'profit_mean_pct': result['profit_ratio'].mean() * 100.0 if len(result) > 0 else 0.0, 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg': str(timedelta(minutes=round(result['trade_duration'].mean()))) if not result.empty else '0:00', 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0}",
        "mutated": [
            "def _generate_result_line(result: DataFrame, starting_balance: int, first_column: str) -> Dict:\n    if False:\n        i = 10\n    '\\n    Generate one result dict, with \"first_column\" as key.\\n    '\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': result['profit_ratio'].mean() if len(result) > 0 else 0.0, 'profit_mean_pct': result['profit_ratio'].mean() * 100.0 if len(result) > 0 else 0.0, 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg': str(timedelta(minutes=round(result['trade_duration'].mean()))) if not result.empty else '0:00', 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0}",
            "def _generate_result_line(result: DataFrame, starting_balance: int, first_column: str) -> Dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate one result dict, with \"first_column\" as key.\\n    '\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': result['profit_ratio'].mean() if len(result) > 0 else 0.0, 'profit_mean_pct': result['profit_ratio'].mean() * 100.0 if len(result) > 0 else 0.0, 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg': str(timedelta(minutes=round(result['trade_duration'].mean()))) if not result.empty else '0:00', 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0}",
            "def _generate_result_line(result: DataFrame, starting_balance: int, first_column: str) -> Dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate one result dict, with \"first_column\" as key.\\n    '\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': result['profit_ratio'].mean() if len(result) > 0 else 0.0, 'profit_mean_pct': result['profit_ratio'].mean() * 100.0 if len(result) > 0 else 0.0, 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg': str(timedelta(minutes=round(result['trade_duration'].mean()))) if not result.empty else '0:00', 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0}",
            "def _generate_result_line(result: DataFrame, starting_balance: int, first_column: str) -> Dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate one result dict, with \"first_column\" as key.\\n    '\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': result['profit_ratio'].mean() if len(result) > 0 else 0.0, 'profit_mean_pct': result['profit_ratio'].mean() * 100.0 if len(result) > 0 else 0.0, 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg': str(timedelta(minutes=round(result['trade_duration'].mean()))) if not result.empty else '0:00', 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0}",
            "def _generate_result_line(result: DataFrame, starting_balance: int, first_column: str) -> Dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate one result dict, with \"first_column\" as key.\\n    '\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': result['profit_ratio'].mean() if len(result) > 0 else 0.0, 'profit_mean_pct': result['profit_ratio'].mean() * 100.0 if len(result) > 0 else 0.0, 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg': str(timedelta(minutes=round(result['trade_duration'].mean()))) if not result.empty else '0:00', 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0}"
        ]
    },
    {
        "func_name": "generate_pair_metrics",
        "original": "def generate_pair_metrics(pairlist: List[str], stake_currency: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    \"\"\"\n    Generates and returns a list  for the given backtest data and the results dataframe\n    :param pairlist: Pairlist used\n    :param stake_currency: stake-currency - used to correctly name headers\n    :param starting_balance: Starting balance\n    :param results: Dataframe containing the backtest results\n    :param skip_nan: Print \"left open\" open trades\n    :return: List of Dicts containing the metrics per pair\n    \"\"\"\n    tabular_data = []\n    for pair in pairlist:\n        result = results[results['pair'] == pair]\n        if skip_nan and result['profit_abs'].isnull().all():\n            continue\n        tabular_data.append(_generate_result_line(result, starting_balance, pair))\n    tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n    tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n    return tabular_data",
        "mutated": [
            "def generate_pair_metrics(pairlist: List[str], stake_currency: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n    '\\n    Generates and returns a list  for the given backtest data and the results dataframe\\n    :param pairlist: Pairlist used\\n    :param stake_currency: stake-currency - used to correctly name headers\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    for pair in pairlist:\n        result = results[results['pair'] == pair]\n        if skip_nan and result['profit_abs'].isnull().all():\n            continue\n        tabular_data.append(_generate_result_line(result, starting_balance, pair))\n    tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n    tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n    return tabular_data",
            "def generate_pair_metrics(pairlist: List[str], stake_currency: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generates and returns a list  for the given backtest data and the results dataframe\\n    :param pairlist: Pairlist used\\n    :param stake_currency: stake-currency - used to correctly name headers\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    for pair in pairlist:\n        result = results[results['pair'] == pair]\n        if skip_nan and result['profit_abs'].isnull().all():\n            continue\n        tabular_data.append(_generate_result_line(result, starting_balance, pair))\n    tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n    tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n    return tabular_data",
            "def generate_pair_metrics(pairlist: List[str], stake_currency: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generates and returns a list  for the given backtest data and the results dataframe\\n    :param pairlist: Pairlist used\\n    :param stake_currency: stake-currency - used to correctly name headers\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    for pair in pairlist:\n        result = results[results['pair'] == pair]\n        if skip_nan and result['profit_abs'].isnull().all():\n            continue\n        tabular_data.append(_generate_result_line(result, starting_balance, pair))\n    tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n    tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n    return tabular_data",
            "def generate_pair_metrics(pairlist: List[str], stake_currency: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generates and returns a list  for the given backtest data and the results dataframe\\n    :param pairlist: Pairlist used\\n    :param stake_currency: stake-currency - used to correctly name headers\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    for pair in pairlist:\n        result = results[results['pair'] == pair]\n        if skip_nan and result['profit_abs'].isnull().all():\n            continue\n        tabular_data.append(_generate_result_line(result, starting_balance, pair))\n    tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n    tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n    return tabular_data",
            "def generate_pair_metrics(pairlist: List[str], stake_currency: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generates and returns a list  for the given backtest data and the results dataframe\\n    :param pairlist: Pairlist used\\n    :param stake_currency: stake-currency - used to correctly name headers\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    for pair in pairlist:\n        result = results[results['pair'] == pair]\n        if skip_nan and result['profit_abs'].isnull().all():\n            continue\n        tabular_data.append(_generate_result_line(result, starting_balance, pair))\n    tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n    tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n    return tabular_data"
        ]
    },
    {
        "func_name": "generate_tag_metrics",
        "original": "def generate_tag_metrics(tag_type: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    \"\"\"\n    Generates and returns a list of metrics for the given tag trades and the results dataframe\n    :param starting_balance: Starting balance\n    :param results: Dataframe containing the backtest results\n    :param skip_nan: Print \"left open\" open trades\n    :return: List of Dicts containing the metrics per pair\n    \"\"\"\n    tabular_data = []\n    if tag_type in results.columns:\n        for (tag, count) in results[tag_type].value_counts().items():\n            result = results[results[tag_type] == tag]\n            if skip_nan and result['profit_abs'].isnull().all():\n                continue\n            tabular_data.append(_generate_result_line(result, starting_balance, tag))\n        tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n        tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n        return tabular_data\n    else:\n        return []",
        "mutated": [
            "def generate_tag_metrics(tag_type: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n    '\\n    Generates and returns a list of metrics for the given tag trades and the results dataframe\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    if tag_type in results.columns:\n        for (tag, count) in results[tag_type].value_counts().items():\n            result = results[results[tag_type] == tag]\n            if skip_nan and result['profit_abs'].isnull().all():\n                continue\n            tabular_data.append(_generate_result_line(result, starting_balance, tag))\n        tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n        tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n        return tabular_data\n    else:\n        return []",
            "def generate_tag_metrics(tag_type: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generates and returns a list of metrics for the given tag trades and the results dataframe\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    if tag_type in results.columns:\n        for (tag, count) in results[tag_type].value_counts().items():\n            result = results[results[tag_type] == tag]\n            if skip_nan and result['profit_abs'].isnull().all():\n                continue\n            tabular_data.append(_generate_result_line(result, starting_balance, tag))\n        tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n        tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n        return tabular_data\n    else:\n        return []",
            "def generate_tag_metrics(tag_type: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generates and returns a list of metrics for the given tag trades and the results dataframe\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    if tag_type in results.columns:\n        for (tag, count) in results[tag_type].value_counts().items():\n            result = results[results[tag_type] == tag]\n            if skip_nan and result['profit_abs'].isnull().all():\n                continue\n            tabular_data.append(_generate_result_line(result, starting_balance, tag))\n        tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n        tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n        return tabular_data\n    else:\n        return []",
            "def generate_tag_metrics(tag_type: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generates and returns a list of metrics for the given tag trades and the results dataframe\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    if tag_type in results.columns:\n        for (tag, count) in results[tag_type].value_counts().items():\n            result = results[results[tag_type] == tag]\n            if skip_nan and result['profit_abs'].isnull().all():\n                continue\n            tabular_data.append(_generate_result_line(result, starting_balance, tag))\n        tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n        tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n        return tabular_data\n    else:\n        return []",
            "def generate_tag_metrics(tag_type: str, starting_balance: int, results: DataFrame, skip_nan: bool=False) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generates and returns a list of metrics for the given tag trades and the results dataframe\\n    :param starting_balance: Starting balance\\n    :param results: Dataframe containing the backtest results\\n    :param skip_nan: Print \"left open\" open trades\\n    :return: List of Dicts containing the metrics per pair\\n    '\n    tabular_data = []\n    if tag_type in results.columns:\n        for (tag, count) in results[tag_type].value_counts().items():\n            result = results[results[tag_type] == tag]\n            if skip_nan and result['profit_abs'].isnull().all():\n                continue\n            tabular_data.append(_generate_result_line(result, starting_balance, tag))\n        tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'], reverse=True)\n        tabular_data.append(_generate_result_line(results, starting_balance, 'TOTAL'))\n        return tabular_data\n    else:\n        return []"
        ]
    },
    {
        "func_name": "generate_exit_reason_stats",
        "original": "def generate_exit_reason_stats(max_open_trades: IntOrInf, results: DataFrame) -> List[Dict]:\n    \"\"\"\n    Generate small table outlining Backtest results\n    :param max_open_trades: Max_open_trades parameter\n    :param results: Dataframe containing the backtest result for one strategy\n    :return: List of Dicts containing the metrics per Sell reason\n    \"\"\"\n    tabular_data = []\n    for (reason, count) in results['exit_reason'].value_counts().items():\n        result = results.loc[results['exit_reason'] == reason]\n        profit_mean = result['profit_ratio'].mean()\n        profit_sum = result['profit_ratio'].sum()\n        profit_total = profit_sum / max_open_trades\n        tabular_data.append({'exit_reason': reason, 'trades': count, 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / count if count else 0.0, 'profit_mean': profit_mean, 'profit_mean_pct': round(profit_mean * 100, 2), 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100, 2)})\n    return tabular_data",
        "mutated": [
            "def generate_exit_reason_stats(max_open_trades: IntOrInf, results: DataFrame) -> List[Dict]:\n    if False:\n        i = 10\n    '\\n    Generate small table outlining Backtest results\\n    :param max_open_trades: Max_open_trades parameter\\n    :param results: Dataframe containing the backtest result for one strategy\\n    :return: List of Dicts containing the metrics per Sell reason\\n    '\n    tabular_data = []\n    for (reason, count) in results['exit_reason'].value_counts().items():\n        result = results.loc[results['exit_reason'] == reason]\n        profit_mean = result['profit_ratio'].mean()\n        profit_sum = result['profit_ratio'].sum()\n        profit_total = profit_sum / max_open_trades\n        tabular_data.append({'exit_reason': reason, 'trades': count, 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / count if count else 0.0, 'profit_mean': profit_mean, 'profit_mean_pct': round(profit_mean * 100, 2), 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100, 2)})\n    return tabular_data",
            "def generate_exit_reason_stats(max_open_trades: IntOrInf, results: DataFrame) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate small table outlining Backtest results\\n    :param max_open_trades: Max_open_trades parameter\\n    :param results: Dataframe containing the backtest result for one strategy\\n    :return: List of Dicts containing the metrics per Sell reason\\n    '\n    tabular_data = []\n    for (reason, count) in results['exit_reason'].value_counts().items():\n        result = results.loc[results['exit_reason'] == reason]\n        profit_mean = result['profit_ratio'].mean()\n        profit_sum = result['profit_ratio'].sum()\n        profit_total = profit_sum / max_open_trades\n        tabular_data.append({'exit_reason': reason, 'trades': count, 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / count if count else 0.0, 'profit_mean': profit_mean, 'profit_mean_pct': round(profit_mean * 100, 2), 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100, 2)})\n    return tabular_data",
            "def generate_exit_reason_stats(max_open_trades: IntOrInf, results: DataFrame) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate small table outlining Backtest results\\n    :param max_open_trades: Max_open_trades parameter\\n    :param results: Dataframe containing the backtest result for one strategy\\n    :return: List of Dicts containing the metrics per Sell reason\\n    '\n    tabular_data = []\n    for (reason, count) in results['exit_reason'].value_counts().items():\n        result = results.loc[results['exit_reason'] == reason]\n        profit_mean = result['profit_ratio'].mean()\n        profit_sum = result['profit_ratio'].sum()\n        profit_total = profit_sum / max_open_trades\n        tabular_data.append({'exit_reason': reason, 'trades': count, 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / count if count else 0.0, 'profit_mean': profit_mean, 'profit_mean_pct': round(profit_mean * 100, 2), 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100, 2)})\n    return tabular_data",
            "def generate_exit_reason_stats(max_open_trades: IntOrInf, results: DataFrame) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate small table outlining Backtest results\\n    :param max_open_trades: Max_open_trades parameter\\n    :param results: Dataframe containing the backtest result for one strategy\\n    :return: List of Dicts containing the metrics per Sell reason\\n    '\n    tabular_data = []\n    for (reason, count) in results['exit_reason'].value_counts().items():\n        result = results.loc[results['exit_reason'] == reason]\n        profit_mean = result['profit_ratio'].mean()\n        profit_sum = result['profit_ratio'].sum()\n        profit_total = profit_sum / max_open_trades\n        tabular_data.append({'exit_reason': reason, 'trades': count, 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / count if count else 0.0, 'profit_mean': profit_mean, 'profit_mean_pct': round(profit_mean * 100, 2), 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100, 2)})\n    return tabular_data",
            "def generate_exit_reason_stats(max_open_trades: IntOrInf, results: DataFrame) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate small table outlining Backtest results\\n    :param max_open_trades: Max_open_trades parameter\\n    :param results: Dataframe containing the backtest result for one strategy\\n    :return: List of Dicts containing the metrics per Sell reason\\n    '\n    tabular_data = []\n    for (reason, count) in results['exit_reason'].value_counts().items():\n        result = results.loc[results['exit_reason'] == reason]\n        profit_mean = result['profit_ratio'].mean()\n        profit_sum = result['profit_ratio'].sum()\n        profit_total = profit_sum / max_open_trades\n        tabular_data.append({'exit_reason': reason, 'trades': count, 'wins': len(result[result['profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(result[result['profit_abs'] > 0]) / count if count else 0.0, 'profit_mean': profit_mean, 'profit_mean_pct': round(profit_mean * 100, 2), 'profit_sum': profit_sum, 'profit_sum_pct': round(profit_sum * 100, 2), 'profit_total_abs': result['profit_abs'].sum(), 'profit_total': profit_total, 'profit_total_pct': round(profit_total * 100, 2)})\n    return tabular_data"
        ]
    },
    {
        "func_name": "generate_strategy_comparison",
        "original": "def generate_strategy_comparison(bt_stats: Dict) -> List[Dict]:\n    \"\"\"\n    Generate summary per strategy\n    :param bt_stats: Dict of <Strategyname: DataFrame> containing results for all strategies\n    :return: List of Dicts containing the metrics per Strategy\n    \"\"\"\n    tabular_data = []\n    for (strategy, result) in bt_stats.items():\n        tabular_data.append(deepcopy(result['results_per_pair'][-1]))\n        tabular_data[-1]['key'] = strategy\n        tabular_data[-1]['max_drawdown_account'] = result['max_drawdown_account']\n        tabular_data[-1]['max_drawdown_abs'] = round_coin_value(result['max_drawdown_abs'], result['stake_currency'], False)\n    return tabular_data",
        "mutated": [
            "def generate_strategy_comparison(bt_stats: Dict) -> List[Dict]:\n    if False:\n        i = 10\n    '\\n    Generate summary per strategy\\n    :param bt_stats: Dict of <Strategyname: DataFrame> containing results for all strategies\\n    :return: List of Dicts containing the metrics per Strategy\\n    '\n    tabular_data = []\n    for (strategy, result) in bt_stats.items():\n        tabular_data.append(deepcopy(result['results_per_pair'][-1]))\n        tabular_data[-1]['key'] = strategy\n        tabular_data[-1]['max_drawdown_account'] = result['max_drawdown_account']\n        tabular_data[-1]['max_drawdown_abs'] = round_coin_value(result['max_drawdown_abs'], result['stake_currency'], False)\n    return tabular_data",
            "def generate_strategy_comparison(bt_stats: Dict) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Generate summary per strategy\\n    :param bt_stats: Dict of <Strategyname: DataFrame> containing results for all strategies\\n    :return: List of Dicts containing the metrics per Strategy\\n    '\n    tabular_data = []\n    for (strategy, result) in bt_stats.items():\n        tabular_data.append(deepcopy(result['results_per_pair'][-1]))\n        tabular_data[-1]['key'] = strategy\n        tabular_data[-1]['max_drawdown_account'] = result['max_drawdown_account']\n        tabular_data[-1]['max_drawdown_abs'] = round_coin_value(result['max_drawdown_abs'], result['stake_currency'], False)\n    return tabular_data",
            "def generate_strategy_comparison(bt_stats: Dict) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Generate summary per strategy\\n    :param bt_stats: Dict of <Strategyname: DataFrame> containing results for all strategies\\n    :return: List of Dicts containing the metrics per Strategy\\n    '\n    tabular_data = []\n    for (strategy, result) in bt_stats.items():\n        tabular_data.append(deepcopy(result['results_per_pair'][-1]))\n        tabular_data[-1]['key'] = strategy\n        tabular_data[-1]['max_drawdown_account'] = result['max_drawdown_account']\n        tabular_data[-1]['max_drawdown_abs'] = round_coin_value(result['max_drawdown_abs'], result['stake_currency'], False)\n    return tabular_data",
            "def generate_strategy_comparison(bt_stats: Dict) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Generate summary per strategy\\n    :param bt_stats: Dict of <Strategyname: DataFrame> containing results for all strategies\\n    :return: List of Dicts containing the metrics per Strategy\\n    '\n    tabular_data = []\n    for (strategy, result) in bt_stats.items():\n        tabular_data.append(deepcopy(result['results_per_pair'][-1]))\n        tabular_data[-1]['key'] = strategy\n        tabular_data[-1]['max_drawdown_account'] = result['max_drawdown_account']\n        tabular_data[-1]['max_drawdown_abs'] = round_coin_value(result['max_drawdown_abs'], result['stake_currency'], False)\n    return tabular_data",
            "def generate_strategy_comparison(bt_stats: Dict) -> List[Dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Generate summary per strategy\\n    :param bt_stats: Dict of <Strategyname: DataFrame> containing results for all strategies\\n    :return: List of Dicts containing the metrics per Strategy\\n    '\n    tabular_data = []\n    for (strategy, result) in bt_stats.items():\n        tabular_data.append(deepcopy(result['results_per_pair'][-1]))\n        tabular_data[-1]['key'] = strategy\n        tabular_data[-1]['max_drawdown_account'] = result['max_drawdown_account']\n        tabular_data[-1]['max_drawdown_abs'] = round_coin_value(result['max_drawdown_abs'], result['stake_currency'], False)\n    return tabular_data"
        ]
    },
    {
        "func_name": "_get_resample_from_period",
        "original": "def _get_resample_from_period(period: str) -> str:\n    if period == 'day':\n        return '1d'\n    if period == 'week':\n        return '1W-MON'\n    if period == 'month':\n        return '1M'\n    raise ValueError(f'Period {period} is not supported.')",
        "mutated": [
            "def _get_resample_from_period(period: str) -> str:\n    if False:\n        i = 10\n    if period == 'day':\n        return '1d'\n    if period == 'week':\n        return '1W-MON'\n    if period == 'month':\n        return '1M'\n    raise ValueError(f'Period {period} is not supported.')",
            "def _get_resample_from_period(period: str) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if period == 'day':\n        return '1d'\n    if period == 'week':\n        return '1W-MON'\n    if period == 'month':\n        return '1M'\n    raise ValueError(f'Period {period} is not supported.')",
            "def _get_resample_from_period(period: str) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if period == 'day':\n        return '1d'\n    if period == 'week':\n        return '1W-MON'\n    if period == 'month':\n        return '1M'\n    raise ValueError(f'Period {period} is not supported.')",
            "def _get_resample_from_period(period: str) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if period == 'day':\n        return '1d'\n    if period == 'week':\n        return '1W-MON'\n    if period == 'month':\n        return '1M'\n    raise ValueError(f'Period {period} is not supported.')",
            "def _get_resample_from_period(period: str) -> str:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if period == 'day':\n        return '1d'\n    if period == 'week':\n        return '1W-MON'\n    if period == 'month':\n        return '1M'\n    raise ValueError(f'Period {period} is not supported.')"
        ]
    },
    {
        "func_name": "generate_periodic_breakdown_stats",
        "original": "def generate_periodic_breakdown_stats(trade_list: Union[List, DataFrame], period: str) -> List[Dict[str, Any]]:\n    results = trade_list if not isinstance(trade_list, list) else DataFrame.from_records(trade_list)\n    if len(results) == 0:\n        return []\n    results['close_date'] = to_datetime(results['close_date'], utc=True)\n    resample_period = _get_resample_from_period(period)\n    resampled = results.resample(resample_period, on='close_date')\n    stats = []\n    for (name, day) in resampled:\n        profit_abs = day['profit_abs'].sum().round(10)\n        wins = sum(day['profit_abs'] > 0)\n        draws = sum(day['profit_abs'] == 0)\n        loses = sum(day['profit_abs'] < 0)\n        trades = wins + draws + loses\n        stats.append({'date': name.strftime('%d/%m/%Y'), 'date_ts': int(name.to_pydatetime().timestamp() * 1000), 'profit_abs': profit_abs, 'wins': wins, 'draws': draws, 'loses': loses, 'winrate': wins / trades if trades else 0.0})\n    return stats",
        "mutated": [
            "def generate_periodic_breakdown_stats(trade_list: Union[List, DataFrame], period: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n    results = trade_list if not isinstance(trade_list, list) else DataFrame.from_records(trade_list)\n    if len(results) == 0:\n        return []\n    results['close_date'] = to_datetime(results['close_date'], utc=True)\n    resample_period = _get_resample_from_period(period)\n    resampled = results.resample(resample_period, on='close_date')\n    stats = []\n    for (name, day) in resampled:\n        profit_abs = day['profit_abs'].sum().round(10)\n        wins = sum(day['profit_abs'] > 0)\n        draws = sum(day['profit_abs'] == 0)\n        loses = sum(day['profit_abs'] < 0)\n        trades = wins + draws + loses\n        stats.append({'date': name.strftime('%d/%m/%Y'), 'date_ts': int(name.to_pydatetime().timestamp() * 1000), 'profit_abs': profit_abs, 'wins': wins, 'draws': draws, 'loses': loses, 'winrate': wins / trades if trades else 0.0})\n    return stats",
            "def generate_periodic_breakdown_stats(trade_list: Union[List, DataFrame], period: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    results = trade_list if not isinstance(trade_list, list) else DataFrame.from_records(trade_list)\n    if len(results) == 0:\n        return []\n    results['close_date'] = to_datetime(results['close_date'], utc=True)\n    resample_period = _get_resample_from_period(period)\n    resampled = results.resample(resample_period, on='close_date')\n    stats = []\n    for (name, day) in resampled:\n        profit_abs = day['profit_abs'].sum().round(10)\n        wins = sum(day['profit_abs'] > 0)\n        draws = sum(day['profit_abs'] == 0)\n        loses = sum(day['profit_abs'] < 0)\n        trades = wins + draws + loses\n        stats.append({'date': name.strftime('%d/%m/%Y'), 'date_ts': int(name.to_pydatetime().timestamp() * 1000), 'profit_abs': profit_abs, 'wins': wins, 'draws': draws, 'loses': loses, 'winrate': wins / trades if trades else 0.0})\n    return stats",
            "def generate_periodic_breakdown_stats(trade_list: Union[List, DataFrame], period: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    results = trade_list if not isinstance(trade_list, list) else DataFrame.from_records(trade_list)\n    if len(results) == 0:\n        return []\n    results['close_date'] = to_datetime(results['close_date'], utc=True)\n    resample_period = _get_resample_from_period(period)\n    resampled = results.resample(resample_period, on='close_date')\n    stats = []\n    for (name, day) in resampled:\n        profit_abs = day['profit_abs'].sum().round(10)\n        wins = sum(day['profit_abs'] > 0)\n        draws = sum(day['profit_abs'] == 0)\n        loses = sum(day['profit_abs'] < 0)\n        trades = wins + draws + loses\n        stats.append({'date': name.strftime('%d/%m/%Y'), 'date_ts': int(name.to_pydatetime().timestamp() * 1000), 'profit_abs': profit_abs, 'wins': wins, 'draws': draws, 'loses': loses, 'winrate': wins / trades if trades else 0.0})\n    return stats",
            "def generate_periodic_breakdown_stats(trade_list: Union[List, DataFrame], period: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    results = trade_list if not isinstance(trade_list, list) else DataFrame.from_records(trade_list)\n    if len(results) == 0:\n        return []\n    results['close_date'] = to_datetime(results['close_date'], utc=True)\n    resample_period = _get_resample_from_period(period)\n    resampled = results.resample(resample_period, on='close_date')\n    stats = []\n    for (name, day) in resampled:\n        profit_abs = day['profit_abs'].sum().round(10)\n        wins = sum(day['profit_abs'] > 0)\n        draws = sum(day['profit_abs'] == 0)\n        loses = sum(day['profit_abs'] < 0)\n        trades = wins + draws + loses\n        stats.append({'date': name.strftime('%d/%m/%Y'), 'date_ts': int(name.to_pydatetime().timestamp() * 1000), 'profit_abs': profit_abs, 'wins': wins, 'draws': draws, 'loses': loses, 'winrate': wins / trades if trades else 0.0})\n    return stats",
            "def generate_periodic_breakdown_stats(trade_list: Union[List, DataFrame], period: str) -> List[Dict[str, Any]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    results = trade_list if not isinstance(trade_list, list) else DataFrame.from_records(trade_list)\n    if len(results) == 0:\n        return []\n    results['close_date'] = to_datetime(results['close_date'], utc=True)\n    resample_period = _get_resample_from_period(period)\n    resampled = results.resample(resample_period, on='close_date')\n    stats = []\n    for (name, day) in resampled:\n        profit_abs = day['profit_abs'].sum().round(10)\n        wins = sum(day['profit_abs'] > 0)\n        draws = sum(day['profit_abs'] == 0)\n        loses = sum(day['profit_abs'] < 0)\n        trades = wins + draws + loses\n        stats.append({'date': name.strftime('%d/%m/%Y'), 'date_ts': int(name.to_pydatetime().timestamp() * 1000), 'profit_abs': profit_abs, 'wins': wins, 'draws': draws, 'loses': loses, 'winrate': wins / trades if trades else 0.0})\n    return stats"
        ]
    },
    {
        "func_name": "generate_all_periodic_breakdown_stats",
        "original": "def generate_all_periodic_breakdown_stats(trade_list: List) -> Dict[str, List]:\n    result = {}\n    for period in BACKTEST_BREAKDOWNS:\n        result[period] = generate_periodic_breakdown_stats(trade_list, period)\n    return result",
        "mutated": [
            "def generate_all_periodic_breakdown_stats(trade_list: List) -> Dict[str, List]:\n    if False:\n        i = 10\n    result = {}\n    for period in BACKTEST_BREAKDOWNS:\n        result[period] = generate_periodic_breakdown_stats(trade_list, period)\n    return result",
            "def generate_all_periodic_breakdown_stats(trade_list: List) -> Dict[str, List]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    result = {}\n    for period in BACKTEST_BREAKDOWNS:\n        result[period] = generate_periodic_breakdown_stats(trade_list, period)\n    return result",
            "def generate_all_periodic_breakdown_stats(trade_list: List) -> Dict[str, List]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    result = {}\n    for period in BACKTEST_BREAKDOWNS:\n        result[period] = generate_periodic_breakdown_stats(trade_list, period)\n    return result",
            "def generate_all_periodic_breakdown_stats(trade_list: List) -> Dict[str, List]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    result = {}\n    for period in BACKTEST_BREAKDOWNS:\n        result[period] = generate_periodic_breakdown_stats(trade_list, period)\n    return result",
            "def generate_all_periodic_breakdown_stats(trade_list: List) -> Dict[str, List]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    result = {}\n    for period in BACKTEST_BREAKDOWNS:\n        result[period] = generate_periodic_breakdown_stats(trade_list, period)\n    return result"
        ]
    },
    {
        "func_name": "calc_streak",
        "original": "def calc_streak(dataframe: DataFrame) -> Tuple[int, int]:\n    \"\"\"\n    Calculate consecutive win and loss streaks\n    :param dataframe: Dataframe containing the trades dataframe, with profit_ratio column\n    :return: Tuple containing consecutive wins and losses\n    \"\"\"\n    df = Series(np.where(dataframe['profit_ratio'] > 0, 'win', 'loss')).to_frame('result')\n    df['streaks'] = df['result'].ne(df['result'].shift()).cumsum().rename('streaks')\n    df['counter'] = df['streaks'].groupby(df['streaks']).cumcount() + 1\n    res = df.groupby(df['result']).max()\n    cons_wins = int(res.loc['win', 'counter']) if 'win' in res.index else 0\n    cons_losses = int(res.loc['loss', 'counter']) if 'loss' in res.index else 0\n    return (cons_wins, cons_losses)",
        "mutated": [
            "def calc_streak(dataframe: DataFrame) -> Tuple[int, int]:\n    if False:\n        i = 10\n    '\\n    Calculate consecutive win and loss streaks\\n    :param dataframe: Dataframe containing the trades dataframe, with profit_ratio column\\n    :return: Tuple containing consecutive wins and losses\\n    '\n    df = Series(np.where(dataframe['profit_ratio'] > 0, 'win', 'loss')).to_frame('result')\n    df['streaks'] = df['result'].ne(df['result'].shift()).cumsum().rename('streaks')\n    df['counter'] = df['streaks'].groupby(df['streaks']).cumcount() + 1\n    res = df.groupby(df['result']).max()\n    cons_wins = int(res.loc['win', 'counter']) if 'win' in res.index else 0\n    cons_losses = int(res.loc['loss', 'counter']) if 'loss' in res.index else 0\n    return (cons_wins, cons_losses)",
            "def calc_streak(dataframe: DataFrame) -> Tuple[int, int]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculate consecutive win and loss streaks\\n    :param dataframe: Dataframe containing the trades dataframe, with profit_ratio column\\n    :return: Tuple containing consecutive wins and losses\\n    '\n    df = Series(np.where(dataframe['profit_ratio'] > 0, 'win', 'loss')).to_frame('result')\n    df['streaks'] = df['result'].ne(df['result'].shift()).cumsum().rename('streaks')\n    df['counter'] = df['streaks'].groupby(df['streaks']).cumcount() + 1\n    res = df.groupby(df['result']).max()\n    cons_wins = int(res.loc['win', 'counter']) if 'win' in res.index else 0\n    cons_losses = int(res.loc['loss', 'counter']) if 'loss' in res.index else 0\n    return (cons_wins, cons_losses)",
            "def calc_streak(dataframe: DataFrame) -> Tuple[int, int]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculate consecutive win and loss streaks\\n    :param dataframe: Dataframe containing the trades dataframe, with profit_ratio column\\n    :return: Tuple containing consecutive wins and losses\\n    '\n    df = Series(np.where(dataframe['profit_ratio'] > 0, 'win', 'loss')).to_frame('result')\n    df['streaks'] = df['result'].ne(df['result'].shift()).cumsum().rename('streaks')\n    df['counter'] = df['streaks'].groupby(df['streaks']).cumcount() + 1\n    res = df.groupby(df['result']).max()\n    cons_wins = int(res.loc['win', 'counter']) if 'win' in res.index else 0\n    cons_losses = int(res.loc['loss', 'counter']) if 'loss' in res.index else 0\n    return (cons_wins, cons_losses)",
            "def calc_streak(dataframe: DataFrame) -> Tuple[int, int]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculate consecutive win and loss streaks\\n    :param dataframe: Dataframe containing the trades dataframe, with profit_ratio column\\n    :return: Tuple containing consecutive wins and losses\\n    '\n    df = Series(np.where(dataframe['profit_ratio'] > 0, 'win', 'loss')).to_frame('result')\n    df['streaks'] = df['result'].ne(df['result'].shift()).cumsum().rename('streaks')\n    df['counter'] = df['streaks'].groupby(df['streaks']).cumcount() + 1\n    res = df.groupby(df['result']).max()\n    cons_wins = int(res.loc['win', 'counter']) if 'win' in res.index else 0\n    cons_losses = int(res.loc['loss', 'counter']) if 'loss' in res.index else 0\n    return (cons_wins, cons_losses)",
            "def calc_streak(dataframe: DataFrame) -> Tuple[int, int]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculate consecutive win and loss streaks\\n    :param dataframe: Dataframe containing the trades dataframe, with profit_ratio column\\n    :return: Tuple containing consecutive wins and losses\\n    '\n    df = Series(np.where(dataframe['profit_ratio'] > 0, 'win', 'loss')).to_frame('result')\n    df['streaks'] = df['result'].ne(df['result'].shift()).cumsum().rename('streaks')\n    df['counter'] = df['streaks'].groupby(df['streaks']).cumcount() + 1\n    res = df.groupby(df['result']).max()\n    cons_wins = int(res.loc['win', 'counter']) if 'win' in res.index else 0\n    cons_losses = int(res.loc['loss', 'counter']) if 'loss' in res.index else 0\n    return (cons_wins, cons_losses)"
        ]
    },
    {
        "func_name": "generate_trading_stats",
        "original": "def generate_trading_stats(results: DataFrame) -> Dict[str, Any]:\n    \"\"\" Generate overall trade statistics \"\"\"\n    if len(results) == 0:\n        return {'wins': 0, 'losses': 0, 'draws': 0, 'winrate': 0, 'holding_avg': timedelta(), 'winner_holding_avg': timedelta(), 'loser_holding_avg': timedelta(), 'max_consecutive_wins': 0, 'max_consecutive_losses': 0}\n    winning_trades = results.loc[results['profit_ratio'] > 0]\n    draw_trades = results.loc[results['profit_ratio'] == 0]\n    losing_trades = results.loc[results['profit_ratio'] < 0]\n    holding_avg = timedelta(minutes=round(results['trade_duration'].mean())) if not results.empty else timedelta()\n    winner_holding_avg = timedelta(minutes=round(winning_trades['trade_duration'].mean())) if not winning_trades.empty else timedelta()\n    loser_holding_avg = timedelta(minutes=round(losing_trades['trade_duration'].mean())) if not losing_trades.empty else timedelta()\n    (winstreak, loss_streak) = calc_streak(results)\n    return {'wins': len(winning_trades), 'losses': len(losing_trades), 'draws': len(draw_trades), 'winrate': len(winning_trades) / len(results) if len(results) else 0.0, 'holding_avg': holding_avg, 'holding_avg_s': holding_avg.total_seconds(), 'winner_holding_avg': winner_holding_avg, 'winner_holding_avg_s': winner_holding_avg.total_seconds(), 'loser_holding_avg': loser_holding_avg, 'loser_holding_avg_s': loser_holding_avg.total_seconds(), 'max_consecutive_wins': winstreak, 'max_consecutive_losses': loss_streak}",
        "mutated": [
            "def generate_trading_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n    ' Generate overall trade statistics '\n    if len(results) == 0:\n        return {'wins': 0, 'losses': 0, 'draws': 0, 'winrate': 0, 'holding_avg': timedelta(), 'winner_holding_avg': timedelta(), 'loser_holding_avg': timedelta(), 'max_consecutive_wins': 0, 'max_consecutive_losses': 0}\n    winning_trades = results.loc[results['profit_ratio'] > 0]\n    draw_trades = results.loc[results['profit_ratio'] == 0]\n    losing_trades = results.loc[results['profit_ratio'] < 0]\n    holding_avg = timedelta(minutes=round(results['trade_duration'].mean())) if not results.empty else timedelta()\n    winner_holding_avg = timedelta(minutes=round(winning_trades['trade_duration'].mean())) if not winning_trades.empty else timedelta()\n    loser_holding_avg = timedelta(minutes=round(losing_trades['trade_duration'].mean())) if not losing_trades.empty else timedelta()\n    (winstreak, loss_streak) = calc_streak(results)\n    return {'wins': len(winning_trades), 'losses': len(losing_trades), 'draws': len(draw_trades), 'winrate': len(winning_trades) / len(results) if len(results) else 0.0, 'holding_avg': holding_avg, 'holding_avg_s': holding_avg.total_seconds(), 'winner_holding_avg': winner_holding_avg, 'winner_holding_avg_s': winner_holding_avg.total_seconds(), 'loser_holding_avg': loser_holding_avg, 'loser_holding_avg_s': loser_holding_avg.total_seconds(), 'max_consecutive_wins': winstreak, 'max_consecutive_losses': loss_streak}",
            "def generate_trading_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Generate overall trade statistics '\n    if len(results) == 0:\n        return {'wins': 0, 'losses': 0, 'draws': 0, 'winrate': 0, 'holding_avg': timedelta(), 'winner_holding_avg': timedelta(), 'loser_holding_avg': timedelta(), 'max_consecutive_wins': 0, 'max_consecutive_losses': 0}\n    winning_trades = results.loc[results['profit_ratio'] > 0]\n    draw_trades = results.loc[results['profit_ratio'] == 0]\n    losing_trades = results.loc[results['profit_ratio'] < 0]\n    holding_avg = timedelta(minutes=round(results['trade_duration'].mean())) if not results.empty else timedelta()\n    winner_holding_avg = timedelta(minutes=round(winning_trades['trade_duration'].mean())) if not winning_trades.empty else timedelta()\n    loser_holding_avg = timedelta(minutes=round(losing_trades['trade_duration'].mean())) if not losing_trades.empty else timedelta()\n    (winstreak, loss_streak) = calc_streak(results)\n    return {'wins': len(winning_trades), 'losses': len(losing_trades), 'draws': len(draw_trades), 'winrate': len(winning_trades) / len(results) if len(results) else 0.0, 'holding_avg': holding_avg, 'holding_avg_s': holding_avg.total_seconds(), 'winner_holding_avg': winner_holding_avg, 'winner_holding_avg_s': winner_holding_avg.total_seconds(), 'loser_holding_avg': loser_holding_avg, 'loser_holding_avg_s': loser_holding_avg.total_seconds(), 'max_consecutive_wins': winstreak, 'max_consecutive_losses': loss_streak}",
            "def generate_trading_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Generate overall trade statistics '\n    if len(results) == 0:\n        return {'wins': 0, 'losses': 0, 'draws': 0, 'winrate': 0, 'holding_avg': timedelta(), 'winner_holding_avg': timedelta(), 'loser_holding_avg': timedelta(), 'max_consecutive_wins': 0, 'max_consecutive_losses': 0}\n    winning_trades = results.loc[results['profit_ratio'] > 0]\n    draw_trades = results.loc[results['profit_ratio'] == 0]\n    losing_trades = results.loc[results['profit_ratio'] < 0]\n    holding_avg = timedelta(minutes=round(results['trade_duration'].mean())) if not results.empty else timedelta()\n    winner_holding_avg = timedelta(minutes=round(winning_trades['trade_duration'].mean())) if not winning_trades.empty else timedelta()\n    loser_holding_avg = timedelta(minutes=round(losing_trades['trade_duration'].mean())) if not losing_trades.empty else timedelta()\n    (winstreak, loss_streak) = calc_streak(results)\n    return {'wins': len(winning_trades), 'losses': len(losing_trades), 'draws': len(draw_trades), 'winrate': len(winning_trades) / len(results) if len(results) else 0.0, 'holding_avg': holding_avg, 'holding_avg_s': holding_avg.total_seconds(), 'winner_holding_avg': winner_holding_avg, 'winner_holding_avg_s': winner_holding_avg.total_seconds(), 'loser_holding_avg': loser_holding_avg, 'loser_holding_avg_s': loser_holding_avg.total_seconds(), 'max_consecutive_wins': winstreak, 'max_consecutive_losses': loss_streak}",
            "def generate_trading_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Generate overall trade statistics '\n    if len(results) == 0:\n        return {'wins': 0, 'losses': 0, 'draws': 0, 'winrate': 0, 'holding_avg': timedelta(), 'winner_holding_avg': timedelta(), 'loser_holding_avg': timedelta(), 'max_consecutive_wins': 0, 'max_consecutive_losses': 0}\n    winning_trades = results.loc[results['profit_ratio'] > 0]\n    draw_trades = results.loc[results['profit_ratio'] == 0]\n    losing_trades = results.loc[results['profit_ratio'] < 0]\n    holding_avg = timedelta(minutes=round(results['trade_duration'].mean())) if not results.empty else timedelta()\n    winner_holding_avg = timedelta(minutes=round(winning_trades['trade_duration'].mean())) if not winning_trades.empty else timedelta()\n    loser_holding_avg = timedelta(minutes=round(losing_trades['trade_duration'].mean())) if not losing_trades.empty else timedelta()\n    (winstreak, loss_streak) = calc_streak(results)\n    return {'wins': len(winning_trades), 'losses': len(losing_trades), 'draws': len(draw_trades), 'winrate': len(winning_trades) / len(results) if len(results) else 0.0, 'holding_avg': holding_avg, 'holding_avg_s': holding_avg.total_seconds(), 'winner_holding_avg': winner_holding_avg, 'winner_holding_avg_s': winner_holding_avg.total_seconds(), 'loser_holding_avg': loser_holding_avg, 'loser_holding_avg_s': loser_holding_avg.total_seconds(), 'max_consecutive_wins': winstreak, 'max_consecutive_losses': loss_streak}",
            "def generate_trading_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Generate overall trade statistics '\n    if len(results) == 0:\n        return {'wins': 0, 'losses': 0, 'draws': 0, 'winrate': 0, 'holding_avg': timedelta(), 'winner_holding_avg': timedelta(), 'loser_holding_avg': timedelta(), 'max_consecutive_wins': 0, 'max_consecutive_losses': 0}\n    winning_trades = results.loc[results['profit_ratio'] > 0]\n    draw_trades = results.loc[results['profit_ratio'] == 0]\n    losing_trades = results.loc[results['profit_ratio'] < 0]\n    holding_avg = timedelta(minutes=round(results['trade_duration'].mean())) if not results.empty else timedelta()\n    winner_holding_avg = timedelta(minutes=round(winning_trades['trade_duration'].mean())) if not winning_trades.empty else timedelta()\n    loser_holding_avg = timedelta(minutes=round(losing_trades['trade_duration'].mean())) if not losing_trades.empty else timedelta()\n    (winstreak, loss_streak) = calc_streak(results)\n    return {'wins': len(winning_trades), 'losses': len(losing_trades), 'draws': len(draw_trades), 'winrate': len(winning_trades) / len(results) if len(results) else 0.0, 'holding_avg': holding_avg, 'holding_avg_s': holding_avg.total_seconds(), 'winner_holding_avg': winner_holding_avg, 'winner_holding_avg_s': winner_holding_avg.total_seconds(), 'loser_holding_avg': loser_holding_avg, 'loser_holding_avg_s': loser_holding_avg.total_seconds(), 'max_consecutive_wins': winstreak, 'max_consecutive_losses': loss_streak}"
        ]
    },
    {
        "func_name": "generate_daily_stats",
        "original": "def generate_daily_stats(results: DataFrame) -> Dict[str, Any]:\n    \"\"\" Generate daily statistics \"\"\"\n    if len(results) == 0:\n        return {'backtest_best_day': 0, 'backtest_worst_day': 0, 'backtest_best_day_abs': 0, 'backtest_worst_day_abs': 0, 'winning_days': 0, 'draw_days': 0, 'losing_days': 0, 'daily_profit_list': []}\n    daily_profit_rel = results.resample('1d', on='close_date')['profit_ratio'].sum()\n    daily_profit = results.resample('1d', on='close_date')['profit_abs'].sum().round(10)\n    worst_rel = min(daily_profit_rel)\n    best_rel = max(daily_profit_rel)\n    worst = min(daily_profit)\n    best = max(daily_profit)\n    winning_days = sum(daily_profit > 0)\n    draw_days = sum(daily_profit == 0)\n    losing_days = sum(daily_profit < 0)\n    daily_profit_list = [(str(idx.date()), val) for (idx, val) in daily_profit.items()]\n    return {'backtest_best_day': best_rel, 'backtest_worst_day': worst_rel, 'backtest_best_day_abs': best, 'backtest_worst_day_abs': worst, 'winning_days': winning_days, 'draw_days': draw_days, 'losing_days': losing_days, 'daily_profit': daily_profit_list}",
        "mutated": [
            "def generate_daily_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n    ' Generate daily statistics '\n    if len(results) == 0:\n        return {'backtest_best_day': 0, 'backtest_worst_day': 0, 'backtest_best_day_abs': 0, 'backtest_worst_day_abs': 0, 'winning_days': 0, 'draw_days': 0, 'losing_days': 0, 'daily_profit_list': []}\n    daily_profit_rel = results.resample('1d', on='close_date')['profit_ratio'].sum()\n    daily_profit = results.resample('1d', on='close_date')['profit_abs'].sum().round(10)\n    worst_rel = min(daily_profit_rel)\n    best_rel = max(daily_profit_rel)\n    worst = min(daily_profit)\n    best = max(daily_profit)\n    winning_days = sum(daily_profit > 0)\n    draw_days = sum(daily_profit == 0)\n    losing_days = sum(daily_profit < 0)\n    daily_profit_list = [(str(idx.date()), val) for (idx, val) in daily_profit.items()]\n    return {'backtest_best_day': best_rel, 'backtest_worst_day': worst_rel, 'backtest_best_day_abs': best, 'backtest_worst_day_abs': worst, 'winning_days': winning_days, 'draw_days': draw_days, 'losing_days': losing_days, 'daily_profit': daily_profit_list}",
            "def generate_daily_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ' Generate daily statistics '\n    if len(results) == 0:\n        return {'backtest_best_day': 0, 'backtest_worst_day': 0, 'backtest_best_day_abs': 0, 'backtest_worst_day_abs': 0, 'winning_days': 0, 'draw_days': 0, 'losing_days': 0, 'daily_profit_list': []}\n    daily_profit_rel = results.resample('1d', on='close_date')['profit_ratio'].sum()\n    daily_profit = results.resample('1d', on='close_date')['profit_abs'].sum().round(10)\n    worst_rel = min(daily_profit_rel)\n    best_rel = max(daily_profit_rel)\n    worst = min(daily_profit)\n    best = max(daily_profit)\n    winning_days = sum(daily_profit > 0)\n    draw_days = sum(daily_profit == 0)\n    losing_days = sum(daily_profit < 0)\n    daily_profit_list = [(str(idx.date()), val) for (idx, val) in daily_profit.items()]\n    return {'backtest_best_day': best_rel, 'backtest_worst_day': worst_rel, 'backtest_best_day_abs': best, 'backtest_worst_day_abs': worst, 'winning_days': winning_days, 'draw_days': draw_days, 'losing_days': losing_days, 'daily_profit': daily_profit_list}",
            "def generate_daily_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ' Generate daily statistics '\n    if len(results) == 0:\n        return {'backtest_best_day': 0, 'backtest_worst_day': 0, 'backtest_best_day_abs': 0, 'backtest_worst_day_abs': 0, 'winning_days': 0, 'draw_days': 0, 'losing_days': 0, 'daily_profit_list': []}\n    daily_profit_rel = results.resample('1d', on='close_date')['profit_ratio'].sum()\n    daily_profit = results.resample('1d', on='close_date')['profit_abs'].sum().round(10)\n    worst_rel = min(daily_profit_rel)\n    best_rel = max(daily_profit_rel)\n    worst = min(daily_profit)\n    best = max(daily_profit)\n    winning_days = sum(daily_profit > 0)\n    draw_days = sum(daily_profit == 0)\n    losing_days = sum(daily_profit < 0)\n    daily_profit_list = [(str(idx.date()), val) for (idx, val) in daily_profit.items()]\n    return {'backtest_best_day': best_rel, 'backtest_worst_day': worst_rel, 'backtest_best_day_abs': best, 'backtest_worst_day_abs': worst, 'winning_days': winning_days, 'draw_days': draw_days, 'losing_days': losing_days, 'daily_profit': daily_profit_list}",
            "def generate_daily_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ' Generate daily statistics '\n    if len(results) == 0:\n        return {'backtest_best_day': 0, 'backtest_worst_day': 0, 'backtest_best_day_abs': 0, 'backtest_worst_day_abs': 0, 'winning_days': 0, 'draw_days': 0, 'losing_days': 0, 'daily_profit_list': []}\n    daily_profit_rel = results.resample('1d', on='close_date')['profit_ratio'].sum()\n    daily_profit = results.resample('1d', on='close_date')['profit_abs'].sum().round(10)\n    worst_rel = min(daily_profit_rel)\n    best_rel = max(daily_profit_rel)\n    worst = min(daily_profit)\n    best = max(daily_profit)\n    winning_days = sum(daily_profit > 0)\n    draw_days = sum(daily_profit == 0)\n    losing_days = sum(daily_profit < 0)\n    daily_profit_list = [(str(idx.date()), val) for (idx, val) in daily_profit.items()]\n    return {'backtest_best_day': best_rel, 'backtest_worst_day': worst_rel, 'backtest_best_day_abs': best, 'backtest_worst_day_abs': worst, 'winning_days': winning_days, 'draw_days': draw_days, 'losing_days': losing_days, 'daily_profit': daily_profit_list}",
            "def generate_daily_stats(results: DataFrame) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ' Generate daily statistics '\n    if len(results) == 0:\n        return {'backtest_best_day': 0, 'backtest_worst_day': 0, 'backtest_best_day_abs': 0, 'backtest_worst_day_abs': 0, 'winning_days': 0, 'draw_days': 0, 'losing_days': 0, 'daily_profit_list': []}\n    daily_profit_rel = results.resample('1d', on='close_date')['profit_ratio'].sum()\n    daily_profit = results.resample('1d', on='close_date')['profit_abs'].sum().round(10)\n    worst_rel = min(daily_profit_rel)\n    best_rel = max(daily_profit_rel)\n    worst = min(daily_profit)\n    best = max(daily_profit)\n    winning_days = sum(daily_profit > 0)\n    draw_days = sum(daily_profit == 0)\n    losing_days = sum(daily_profit < 0)\n    daily_profit_list = [(str(idx.date()), val) for (idx, val) in daily_profit.items()]\n    return {'backtest_best_day': best_rel, 'backtest_worst_day': worst_rel, 'backtest_best_day_abs': best, 'backtest_worst_day_abs': worst, 'winning_days': winning_days, 'draw_days': draw_days, 'losing_days': losing_days, 'daily_profit': daily_profit_list}"
        ]
    },
    {
        "func_name": "generate_strategy_stats",
        "original": "def generate_strategy_stats(pairlist: List[str], strategy: str, content: Dict[str, Any], min_date: datetime, max_date: datetime, market_change: float, is_hyperopt: bool=False) -> Dict[str, Any]:\n    \"\"\"\n    :param pairlist: List of pairs to backtest\n    :param strategy: Strategy name\n    :param content: Backtest result data in the format:\n                    {'results: results, 'config: config}}.\n    :param min_date: Backtest start date\n    :param max_date: Backtest end date\n    :param market_change: float indicating the market change\n    :return: Dictionary containing results per strategy and a strategy summary.\n    \"\"\"\n    results: Dict[str, DataFrame] = content['results']\n    if not isinstance(results, DataFrame):\n        return {}\n    config = content['config']\n    max_open_trades = min(config['max_open_trades'], len(pairlist))\n    start_balance = config['dry_run_wallet']\n    stake_currency = config['stake_currency']\n    pair_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results, skip_nan=False)\n    enter_tag_results = generate_tag_metrics('enter_tag', starting_balance=start_balance, results=results, skip_nan=False)\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=max_open_trades, results=results)\n    left_open_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results.loc[results['exit_reason'] == 'force_exit'], skip_nan=True)\n    daily_stats = generate_daily_stats(results)\n    trade_stats = generate_trading_stats(results)\n    periodic_breakdown = {}\n    if not is_hyperopt:\n        periodic_breakdown = {'periodic_breakdown': generate_all_periodic_breakdown_stats(results)}\n    best_pair = max([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    worst_pair = min([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    winning_profit = results.loc[results['profit_abs'] > 0, 'profit_abs'].sum()\n    losing_profit = results.loc[results['profit_abs'] < 0, 'profit_abs'].sum()\n    profit_factor = winning_profit / abs(losing_profit) if losing_profit else 0.0\n    (expectancy, expectancy_ratio) = calculate_expectancy(results)\n    backtest_days = (max_date - min_date).days or 1\n    strat_stats = {'trades': results.to_dict(orient='records'), 'locks': [lock.to_json() for lock in content['locks']], 'best_pair': best_pair, 'worst_pair': worst_pair, 'results_per_pair': pair_results, 'results_per_enter_tag': enter_tag_results, 'exit_reason_summary': exit_reason_stats, 'left_open_trades': left_open_results, 'total_trades': len(results), 'trade_count_long': len(results.loc[~results['is_short']]), 'trade_count_short': len(results.loc[results['is_short']]), 'total_volume': float(results['stake_amount'].sum()), 'avg_stake_amount': results['stake_amount'].mean() if len(results) > 0 else 0, 'profit_mean': results['profit_ratio'].mean() if len(results) > 0 else 0, 'profit_median': results['profit_ratio'].median() if len(results) > 0 else 0, 'profit_total': results['profit_abs'].sum() / start_balance, 'profit_total_long': results.loc[~results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_short': results.loc[results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_abs': results['profit_abs'].sum(), 'profit_total_long_abs': results.loc[~results['is_short'], 'profit_abs'].sum(), 'profit_total_short_abs': results.loc[results['is_short'], 'profit_abs'].sum(), 'cagr': calculate_cagr(backtest_days, start_balance, content['final_balance']), 'expectancy': expectancy, 'expectancy_ratio': expectancy_ratio, 'sortino': calculate_sortino(results, min_date, max_date, start_balance), 'sharpe': calculate_sharpe(results, min_date, max_date, start_balance), 'calmar': calculate_calmar(results, min_date, max_date, start_balance), 'profit_factor': profit_factor, 'backtest_start': min_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_start_ts': int(min_date.timestamp() * 1000), 'backtest_end': max_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_end_ts': int(max_date.timestamp() * 1000), 'backtest_days': backtest_days, 'backtest_run_start_ts': content['backtest_start_time'], 'backtest_run_end_ts': content['backtest_end_time'], 'trades_per_day': round(len(results) / backtest_days, 2), 'market_change': market_change, 'pairlist': pairlist, 'stake_amount': config['stake_amount'], 'stake_currency': config['stake_currency'], 'stake_currency_decimals': decimals_per_coin(config['stake_currency']), 'starting_balance': start_balance, 'dry_run_wallet': start_balance, 'final_balance': content['final_balance'], 'rejected_signals': content['rejected_signals'], 'timedout_entry_orders': content['timedout_entry_orders'], 'timedout_exit_orders': content['timedout_exit_orders'], 'canceled_trade_entries': content['canceled_trade_entries'], 'canceled_entry_orders': content['canceled_entry_orders'], 'replaced_entry_orders': content['replaced_entry_orders'], 'max_open_trades': max_open_trades, 'max_open_trades_setting': config['max_open_trades'] if config['max_open_trades'] != float('inf') else -1, 'timeframe': config['timeframe'], 'timeframe_detail': config.get('timeframe_detail', ''), 'timerange': config.get('timerange', ''), 'enable_protections': config.get('enable_protections', False), 'strategy_name': strategy, 'stoploss': config['stoploss'], 'trailing_stop': config.get('trailing_stop', False), 'trailing_stop_positive': config.get('trailing_stop_positive'), 'trailing_stop_positive_offset': config.get('trailing_stop_positive_offset', 0.0), 'trailing_only_offset_is_reached': config.get('trailing_only_offset_is_reached', False), 'use_custom_stoploss': config.get('use_custom_stoploss', False), 'minimal_roi': config['minimal_roi'], 'use_exit_signal': config['use_exit_signal'], 'exit_profit_only': config['exit_profit_only'], 'exit_profit_offset': config['exit_profit_offset'], 'ignore_roi_if_entry_signal': config['ignore_roi_if_entry_signal'], **periodic_breakdown, **daily_stats, **trade_stats}\n    try:\n        (max_drawdown_legacy, _, _, _, _, _) = calculate_max_drawdown(results, value_col='profit_ratio')\n        (drawdown_abs, drawdown_start, drawdown_end, high_val, low_val, max_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance)\n        (_, _, _, _, _, max_relative_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance, relative=True)\n        strat_stats.update({'max_drawdown': max_drawdown_legacy, 'max_drawdown_account': max_drawdown, 'max_relative_drawdown': max_relative_drawdown, 'max_drawdown_abs': drawdown_abs, 'drawdown_start': drawdown_start.strftime(DATETIME_PRINT_FORMAT), 'drawdown_start_ts': drawdown_start.timestamp() * 1000, 'drawdown_end': drawdown_end.strftime(DATETIME_PRINT_FORMAT), 'drawdown_end_ts': drawdown_end.timestamp() * 1000, 'max_drawdown_low': low_val, 'max_drawdown_high': high_val})\n        (csum_min, csum_max) = calculate_csum(results, start_balance)\n        strat_stats.update({'csum_min': csum_min, 'csum_max': csum_max})\n    except ValueError:\n        strat_stats.update({'max_drawdown': 0.0, 'max_drawdown_account': 0.0, 'max_relative_drawdown': 0.0, 'max_drawdown_abs': 0.0, 'max_drawdown_low': 0.0, 'max_drawdown_high': 0.0, 'drawdown_start': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_start_ts': 0, 'drawdown_end': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_end_ts': 0, 'csum_min': 0, 'csum_max': 0})\n    return strat_stats",
        "mutated": [
            "def generate_strategy_stats(pairlist: List[str], strategy: str, content: Dict[str, Any], min_date: datetime, max_date: datetime, market_change: float, is_hyperopt: bool=False) -> Dict[str, Any]:\n    if False:\n        i = 10\n    \"\\n    :param pairlist: List of pairs to backtest\\n    :param strategy: Strategy name\\n    :param content: Backtest result data in the format:\\n                    {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :param market_change: float indicating the market change\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    results: Dict[str, DataFrame] = content['results']\n    if not isinstance(results, DataFrame):\n        return {}\n    config = content['config']\n    max_open_trades = min(config['max_open_trades'], len(pairlist))\n    start_balance = config['dry_run_wallet']\n    stake_currency = config['stake_currency']\n    pair_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results, skip_nan=False)\n    enter_tag_results = generate_tag_metrics('enter_tag', starting_balance=start_balance, results=results, skip_nan=False)\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=max_open_trades, results=results)\n    left_open_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results.loc[results['exit_reason'] == 'force_exit'], skip_nan=True)\n    daily_stats = generate_daily_stats(results)\n    trade_stats = generate_trading_stats(results)\n    periodic_breakdown = {}\n    if not is_hyperopt:\n        periodic_breakdown = {'periodic_breakdown': generate_all_periodic_breakdown_stats(results)}\n    best_pair = max([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    worst_pair = min([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    winning_profit = results.loc[results['profit_abs'] > 0, 'profit_abs'].sum()\n    losing_profit = results.loc[results['profit_abs'] < 0, 'profit_abs'].sum()\n    profit_factor = winning_profit / abs(losing_profit) if losing_profit else 0.0\n    (expectancy, expectancy_ratio) = calculate_expectancy(results)\n    backtest_days = (max_date - min_date).days or 1\n    strat_stats = {'trades': results.to_dict(orient='records'), 'locks': [lock.to_json() for lock in content['locks']], 'best_pair': best_pair, 'worst_pair': worst_pair, 'results_per_pair': pair_results, 'results_per_enter_tag': enter_tag_results, 'exit_reason_summary': exit_reason_stats, 'left_open_trades': left_open_results, 'total_trades': len(results), 'trade_count_long': len(results.loc[~results['is_short']]), 'trade_count_short': len(results.loc[results['is_short']]), 'total_volume': float(results['stake_amount'].sum()), 'avg_stake_amount': results['stake_amount'].mean() if len(results) > 0 else 0, 'profit_mean': results['profit_ratio'].mean() if len(results) > 0 else 0, 'profit_median': results['profit_ratio'].median() if len(results) > 0 else 0, 'profit_total': results['profit_abs'].sum() / start_balance, 'profit_total_long': results.loc[~results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_short': results.loc[results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_abs': results['profit_abs'].sum(), 'profit_total_long_abs': results.loc[~results['is_short'], 'profit_abs'].sum(), 'profit_total_short_abs': results.loc[results['is_short'], 'profit_abs'].sum(), 'cagr': calculate_cagr(backtest_days, start_balance, content['final_balance']), 'expectancy': expectancy, 'expectancy_ratio': expectancy_ratio, 'sortino': calculate_sortino(results, min_date, max_date, start_balance), 'sharpe': calculate_sharpe(results, min_date, max_date, start_balance), 'calmar': calculate_calmar(results, min_date, max_date, start_balance), 'profit_factor': profit_factor, 'backtest_start': min_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_start_ts': int(min_date.timestamp() * 1000), 'backtest_end': max_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_end_ts': int(max_date.timestamp() * 1000), 'backtest_days': backtest_days, 'backtest_run_start_ts': content['backtest_start_time'], 'backtest_run_end_ts': content['backtest_end_time'], 'trades_per_day': round(len(results) / backtest_days, 2), 'market_change': market_change, 'pairlist': pairlist, 'stake_amount': config['stake_amount'], 'stake_currency': config['stake_currency'], 'stake_currency_decimals': decimals_per_coin(config['stake_currency']), 'starting_balance': start_balance, 'dry_run_wallet': start_balance, 'final_balance': content['final_balance'], 'rejected_signals': content['rejected_signals'], 'timedout_entry_orders': content['timedout_entry_orders'], 'timedout_exit_orders': content['timedout_exit_orders'], 'canceled_trade_entries': content['canceled_trade_entries'], 'canceled_entry_orders': content['canceled_entry_orders'], 'replaced_entry_orders': content['replaced_entry_orders'], 'max_open_trades': max_open_trades, 'max_open_trades_setting': config['max_open_trades'] if config['max_open_trades'] != float('inf') else -1, 'timeframe': config['timeframe'], 'timeframe_detail': config.get('timeframe_detail', ''), 'timerange': config.get('timerange', ''), 'enable_protections': config.get('enable_protections', False), 'strategy_name': strategy, 'stoploss': config['stoploss'], 'trailing_stop': config.get('trailing_stop', False), 'trailing_stop_positive': config.get('trailing_stop_positive'), 'trailing_stop_positive_offset': config.get('trailing_stop_positive_offset', 0.0), 'trailing_only_offset_is_reached': config.get('trailing_only_offset_is_reached', False), 'use_custom_stoploss': config.get('use_custom_stoploss', False), 'minimal_roi': config['minimal_roi'], 'use_exit_signal': config['use_exit_signal'], 'exit_profit_only': config['exit_profit_only'], 'exit_profit_offset': config['exit_profit_offset'], 'ignore_roi_if_entry_signal': config['ignore_roi_if_entry_signal'], **periodic_breakdown, **daily_stats, **trade_stats}\n    try:\n        (max_drawdown_legacy, _, _, _, _, _) = calculate_max_drawdown(results, value_col='profit_ratio')\n        (drawdown_abs, drawdown_start, drawdown_end, high_val, low_val, max_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance)\n        (_, _, _, _, _, max_relative_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance, relative=True)\n        strat_stats.update({'max_drawdown': max_drawdown_legacy, 'max_drawdown_account': max_drawdown, 'max_relative_drawdown': max_relative_drawdown, 'max_drawdown_abs': drawdown_abs, 'drawdown_start': drawdown_start.strftime(DATETIME_PRINT_FORMAT), 'drawdown_start_ts': drawdown_start.timestamp() * 1000, 'drawdown_end': drawdown_end.strftime(DATETIME_PRINT_FORMAT), 'drawdown_end_ts': drawdown_end.timestamp() * 1000, 'max_drawdown_low': low_val, 'max_drawdown_high': high_val})\n        (csum_min, csum_max) = calculate_csum(results, start_balance)\n        strat_stats.update({'csum_min': csum_min, 'csum_max': csum_max})\n    except ValueError:\n        strat_stats.update({'max_drawdown': 0.0, 'max_drawdown_account': 0.0, 'max_relative_drawdown': 0.0, 'max_drawdown_abs': 0.0, 'max_drawdown_low': 0.0, 'max_drawdown_high': 0.0, 'drawdown_start': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_start_ts': 0, 'drawdown_end': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_end_ts': 0, 'csum_min': 0, 'csum_max': 0})\n    return strat_stats",
            "def generate_strategy_stats(pairlist: List[str], strategy: str, content: Dict[str, Any], min_date: datetime, max_date: datetime, market_change: float, is_hyperopt: bool=False) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    :param pairlist: List of pairs to backtest\\n    :param strategy: Strategy name\\n    :param content: Backtest result data in the format:\\n                    {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :param market_change: float indicating the market change\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    results: Dict[str, DataFrame] = content['results']\n    if not isinstance(results, DataFrame):\n        return {}\n    config = content['config']\n    max_open_trades = min(config['max_open_trades'], len(pairlist))\n    start_balance = config['dry_run_wallet']\n    stake_currency = config['stake_currency']\n    pair_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results, skip_nan=False)\n    enter_tag_results = generate_tag_metrics('enter_tag', starting_balance=start_balance, results=results, skip_nan=False)\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=max_open_trades, results=results)\n    left_open_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results.loc[results['exit_reason'] == 'force_exit'], skip_nan=True)\n    daily_stats = generate_daily_stats(results)\n    trade_stats = generate_trading_stats(results)\n    periodic_breakdown = {}\n    if not is_hyperopt:\n        periodic_breakdown = {'periodic_breakdown': generate_all_periodic_breakdown_stats(results)}\n    best_pair = max([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    worst_pair = min([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    winning_profit = results.loc[results['profit_abs'] > 0, 'profit_abs'].sum()\n    losing_profit = results.loc[results['profit_abs'] < 0, 'profit_abs'].sum()\n    profit_factor = winning_profit / abs(losing_profit) if losing_profit else 0.0\n    (expectancy, expectancy_ratio) = calculate_expectancy(results)\n    backtest_days = (max_date - min_date).days or 1\n    strat_stats = {'trades': results.to_dict(orient='records'), 'locks': [lock.to_json() for lock in content['locks']], 'best_pair': best_pair, 'worst_pair': worst_pair, 'results_per_pair': pair_results, 'results_per_enter_tag': enter_tag_results, 'exit_reason_summary': exit_reason_stats, 'left_open_trades': left_open_results, 'total_trades': len(results), 'trade_count_long': len(results.loc[~results['is_short']]), 'trade_count_short': len(results.loc[results['is_short']]), 'total_volume': float(results['stake_amount'].sum()), 'avg_stake_amount': results['stake_amount'].mean() if len(results) > 0 else 0, 'profit_mean': results['profit_ratio'].mean() if len(results) > 0 else 0, 'profit_median': results['profit_ratio'].median() if len(results) > 0 else 0, 'profit_total': results['profit_abs'].sum() / start_balance, 'profit_total_long': results.loc[~results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_short': results.loc[results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_abs': results['profit_abs'].sum(), 'profit_total_long_abs': results.loc[~results['is_short'], 'profit_abs'].sum(), 'profit_total_short_abs': results.loc[results['is_short'], 'profit_abs'].sum(), 'cagr': calculate_cagr(backtest_days, start_balance, content['final_balance']), 'expectancy': expectancy, 'expectancy_ratio': expectancy_ratio, 'sortino': calculate_sortino(results, min_date, max_date, start_balance), 'sharpe': calculate_sharpe(results, min_date, max_date, start_balance), 'calmar': calculate_calmar(results, min_date, max_date, start_balance), 'profit_factor': profit_factor, 'backtest_start': min_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_start_ts': int(min_date.timestamp() * 1000), 'backtest_end': max_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_end_ts': int(max_date.timestamp() * 1000), 'backtest_days': backtest_days, 'backtest_run_start_ts': content['backtest_start_time'], 'backtest_run_end_ts': content['backtest_end_time'], 'trades_per_day': round(len(results) / backtest_days, 2), 'market_change': market_change, 'pairlist': pairlist, 'stake_amount': config['stake_amount'], 'stake_currency': config['stake_currency'], 'stake_currency_decimals': decimals_per_coin(config['stake_currency']), 'starting_balance': start_balance, 'dry_run_wallet': start_balance, 'final_balance': content['final_balance'], 'rejected_signals': content['rejected_signals'], 'timedout_entry_orders': content['timedout_entry_orders'], 'timedout_exit_orders': content['timedout_exit_orders'], 'canceled_trade_entries': content['canceled_trade_entries'], 'canceled_entry_orders': content['canceled_entry_orders'], 'replaced_entry_orders': content['replaced_entry_orders'], 'max_open_trades': max_open_trades, 'max_open_trades_setting': config['max_open_trades'] if config['max_open_trades'] != float('inf') else -1, 'timeframe': config['timeframe'], 'timeframe_detail': config.get('timeframe_detail', ''), 'timerange': config.get('timerange', ''), 'enable_protections': config.get('enable_protections', False), 'strategy_name': strategy, 'stoploss': config['stoploss'], 'trailing_stop': config.get('trailing_stop', False), 'trailing_stop_positive': config.get('trailing_stop_positive'), 'trailing_stop_positive_offset': config.get('trailing_stop_positive_offset', 0.0), 'trailing_only_offset_is_reached': config.get('trailing_only_offset_is_reached', False), 'use_custom_stoploss': config.get('use_custom_stoploss', False), 'minimal_roi': config['minimal_roi'], 'use_exit_signal': config['use_exit_signal'], 'exit_profit_only': config['exit_profit_only'], 'exit_profit_offset': config['exit_profit_offset'], 'ignore_roi_if_entry_signal': config['ignore_roi_if_entry_signal'], **periodic_breakdown, **daily_stats, **trade_stats}\n    try:\n        (max_drawdown_legacy, _, _, _, _, _) = calculate_max_drawdown(results, value_col='profit_ratio')\n        (drawdown_abs, drawdown_start, drawdown_end, high_val, low_val, max_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance)\n        (_, _, _, _, _, max_relative_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance, relative=True)\n        strat_stats.update({'max_drawdown': max_drawdown_legacy, 'max_drawdown_account': max_drawdown, 'max_relative_drawdown': max_relative_drawdown, 'max_drawdown_abs': drawdown_abs, 'drawdown_start': drawdown_start.strftime(DATETIME_PRINT_FORMAT), 'drawdown_start_ts': drawdown_start.timestamp() * 1000, 'drawdown_end': drawdown_end.strftime(DATETIME_PRINT_FORMAT), 'drawdown_end_ts': drawdown_end.timestamp() * 1000, 'max_drawdown_low': low_val, 'max_drawdown_high': high_val})\n        (csum_min, csum_max) = calculate_csum(results, start_balance)\n        strat_stats.update({'csum_min': csum_min, 'csum_max': csum_max})\n    except ValueError:\n        strat_stats.update({'max_drawdown': 0.0, 'max_drawdown_account': 0.0, 'max_relative_drawdown': 0.0, 'max_drawdown_abs': 0.0, 'max_drawdown_low': 0.0, 'max_drawdown_high': 0.0, 'drawdown_start': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_start_ts': 0, 'drawdown_end': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_end_ts': 0, 'csum_min': 0, 'csum_max': 0})\n    return strat_stats",
            "def generate_strategy_stats(pairlist: List[str], strategy: str, content: Dict[str, Any], min_date: datetime, max_date: datetime, market_change: float, is_hyperopt: bool=False) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    :param pairlist: List of pairs to backtest\\n    :param strategy: Strategy name\\n    :param content: Backtest result data in the format:\\n                    {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :param market_change: float indicating the market change\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    results: Dict[str, DataFrame] = content['results']\n    if not isinstance(results, DataFrame):\n        return {}\n    config = content['config']\n    max_open_trades = min(config['max_open_trades'], len(pairlist))\n    start_balance = config['dry_run_wallet']\n    stake_currency = config['stake_currency']\n    pair_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results, skip_nan=False)\n    enter_tag_results = generate_tag_metrics('enter_tag', starting_balance=start_balance, results=results, skip_nan=False)\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=max_open_trades, results=results)\n    left_open_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results.loc[results['exit_reason'] == 'force_exit'], skip_nan=True)\n    daily_stats = generate_daily_stats(results)\n    trade_stats = generate_trading_stats(results)\n    periodic_breakdown = {}\n    if not is_hyperopt:\n        periodic_breakdown = {'periodic_breakdown': generate_all_periodic_breakdown_stats(results)}\n    best_pair = max([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    worst_pair = min([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    winning_profit = results.loc[results['profit_abs'] > 0, 'profit_abs'].sum()\n    losing_profit = results.loc[results['profit_abs'] < 0, 'profit_abs'].sum()\n    profit_factor = winning_profit / abs(losing_profit) if losing_profit else 0.0\n    (expectancy, expectancy_ratio) = calculate_expectancy(results)\n    backtest_days = (max_date - min_date).days or 1\n    strat_stats = {'trades': results.to_dict(orient='records'), 'locks': [lock.to_json() for lock in content['locks']], 'best_pair': best_pair, 'worst_pair': worst_pair, 'results_per_pair': pair_results, 'results_per_enter_tag': enter_tag_results, 'exit_reason_summary': exit_reason_stats, 'left_open_trades': left_open_results, 'total_trades': len(results), 'trade_count_long': len(results.loc[~results['is_short']]), 'trade_count_short': len(results.loc[results['is_short']]), 'total_volume': float(results['stake_amount'].sum()), 'avg_stake_amount': results['stake_amount'].mean() if len(results) > 0 else 0, 'profit_mean': results['profit_ratio'].mean() if len(results) > 0 else 0, 'profit_median': results['profit_ratio'].median() if len(results) > 0 else 0, 'profit_total': results['profit_abs'].sum() / start_balance, 'profit_total_long': results.loc[~results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_short': results.loc[results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_abs': results['profit_abs'].sum(), 'profit_total_long_abs': results.loc[~results['is_short'], 'profit_abs'].sum(), 'profit_total_short_abs': results.loc[results['is_short'], 'profit_abs'].sum(), 'cagr': calculate_cagr(backtest_days, start_balance, content['final_balance']), 'expectancy': expectancy, 'expectancy_ratio': expectancy_ratio, 'sortino': calculate_sortino(results, min_date, max_date, start_balance), 'sharpe': calculate_sharpe(results, min_date, max_date, start_balance), 'calmar': calculate_calmar(results, min_date, max_date, start_balance), 'profit_factor': profit_factor, 'backtest_start': min_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_start_ts': int(min_date.timestamp() * 1000), 'backtest_end': max_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_end_ts': int(max_date.timestamp() * 1000), 'backtest_days': backtest_days, 'backtest_run_start_ts': content['backtest_start_time'], 'backtest_run_end_ts': content['backtest_end_time'], 'trades_per_day': round(len(results) / backtest_days, 2), 'market_change': market_change, 'pairlist': pairlist, 'stake_amount': config['stake_amount'], 'stake_currency': config['stake_currency'], 'stake_currency_decimals': decimals_per_coin(config['stake_currency']), 'starting_balance': start_balance, 'dry_run_wallet': start_balance, 'final_balance': content['final_balance'], 'rejected_signals': content['rejected_signals'], 'timedout_entry_orders': content['timedout_entry_orders'], 'timedout_exit_orders': content['timedout_exit_orders'], 'canceled_trade_entries': content['canceled_trade_entries'], 'canceled_entry_orders': content['canceled_entry_orders'], 'replaced_entry_orders': content['replaced_entry_orders'], 'max_open_trades': max_open_trades, 'max_open_trades_setting': config['max_open_trades'] if config['max_open_trades'] != float('inf') else -1, 'timeframe': config['timeframe'], 'timeframe_detail': config.get('timeframe_detail', ''), 'timerange': config.get('timerange', ''), 'enable_protections': config.get('enable_protections', False), 'strategy_name': strategy, 'stoploss': config['stoploss'], 'trailing_stop': config.get('trailing_stop', False), 'trailing_stop_positive': config.get('trailing_stop_positive'), 'trailing_stop_positive_offset': config.get('trailing_stop_positive_offset', 0.0), 'trailing_only_offset_is_reached': config.get('trailing_only_offset_is_reached', False), 'use_custom_stoploss': config.get('use_custom_stoploss', False), 'minimal_roi': config['minimal_roi'], 'use_exit_signal': config['use_exit_signal'], 'exit_profit_only': config['exit_profit_only'], 'exit_profit_offset': config['exit_profit_offset'], 'ignore_roi_if_entry_signal': config['ignore_roi_if_entry_signal'], **periodic_breakdown, **daily_stats, **trade_stats}\n    try:\n        (max_drawdown_legacy, _, _, _, _, _) = calculate_max_drawdown(results, value_col='profit_ratio')\n        (drawdown_abs, drawdown_start, drawdown_end, high_val, low_val, max_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance)\n        (_, _, _, _, _, max_relative_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance, relative=True)\n        strat_stats.update({'max_drawdown': max_drawdown_legacy, 'max_drawdown_account': max_drawdown, 'max_relative_drawdown': max_relative_drawdown, 'max_drawdown_abs': drawdown_abs, 'drawdown_start': drawdown_start.strftime(DATETIME_PRINT_FORMAT), 'drawdown_start_ts': drawdown_start.timestamp() * 1000, 'drawdown_end': drawdown_end.strftime(DATETIME_PRINT_FORMAT), 'drawdown_end_ts': drawdown_end.timestamp() * 1000, 'max_drawdown_low': low_val, 'max_drawdown_high': high_val})\n        (csum_min, csum_max) = calculate_csum(results, start_balance)\n        strat_stats.update({'csum_min': csum_min, 'csum_max': csum_max})\n    except ValueError:\n        strat_stats.update({'max_drawdown': 0.0, 'max_drawdown_account': 0.0, 'max_relative_drawdown': 0.0, 'max_drawdown_abs': 0.0, 'max_drawdown_low': 0.0, 'max_drawdown_high': 0.0, 'drawdown_start': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_start_ts': 0, 'drawdown_end': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_end_ts': 0, 'csum_min': 0, 'csum_max': 0})\n    return strat_stats",
            "def generate_strategy_stats(pairlist: List[str], strategy: str, content: Dict[str, Any], min_date: datetime, max_date: datetime, market_change: float, is_hyperopt: bool=False) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    :param pairlist: List of pairs to backtest\\n    :param strategy: Strategy name\\n    :param content: Backtest result data in the format:\\n                    {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :param market_change: float indicating the market change\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    results: Dict[str, DataFrame] = content['results']\n    if not isinstance(results, DataFrame):\n        return {}\n    config = content['config']\n    max_open_trades = min(config['max_open_trades'], len(pairlist))\n    start_balance = config['dry_run_wallet']\n    stake_currency = config['stake_currency']\n    pair_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results, skip_nan=False)\n    enter_tag_results = generate_tag_metrics('enter_tag', starting_balance=start_balance, results=results, skip_nan=False)\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=max_open_trades, results=results)\n    left_open_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results.loc[results['exit_reason'] == 'force_exit'], skip_nan=True)\n    daily_stats = generate_daily_stats(results)\n    trade_stats = generate_trading_stats(results)\n    periodic_breakdown = {}\n    if not is_hyperopt:\n        periodic_breakdown = {'periodic_breakdown': generate_all_periodic_breakdown_stats(results)}\n    best_pair = max([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    worst_pair = min([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    winning_profit = results.loc[results['profit_abs'] > 0, 'profit_abs'].sum()\n    losing_profit = results.loc[results['profit_abs'] < 0, 'profit_abs'].sum()\n    profit_factor = winning_profit / abs(losing_profit) if losing_profit else 0.0\n    (expectancy, expectancy_ratio) = calculate_expectancy(results)\n    backtest_days = (max_date - min_date).days or 1\n    strat_stats = {'trades': results.to_dict(orient='records'), 'locks': [lock.to_json() for lock in content['locks']], 'best_pair': best_pair, 'worst_pair': worst_pair, 'results_per_pair': pair_results, 'results_per_enter_tag': enter_tag_results, 'exit_reason_summary': exit_reason_stats, 'left_open_trades': left_open_results, 'total_trades': len(results), 'trade_count_long': len(results.loc[~results['is_short']]), 'trade_count_short': len(results.loc[results['is_short']]), 'total_volume': float(results['stake_amount'].sum()), 'avg_stake_amount': results['stake_amount'].mean() if len(results) > 0 else 0, 'profit_mean': results['profit_ratio'].mean() if len(results) > 0 else 0, 'profit_median': results['profit_ratio'].median() if len(results) > 0 else 0, 'profit_total': results['profit_abs'].sum() / start_balance, 'profit_total_long': results.loc[~results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_short': results.loc[results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_abs': results['profit_abs'].sum(), 'profit_total_long_abs': results.loc[~results['is_short'], 'profit_abs'].sum(), 'profit_total_short_abs': results.loc[results['is_short'], 'profit_abs'].sum(), 'cagr': calculate_cagr(backtest_days, start_balance, content['final_balance']), 'expectancy': expectancy, 'expectancy_ratio': expectancy_ratio, 'sortino': calculate_sortino(results, min_date, max_date, start_balance), 'sharpe': calculate_sharpe(results, min_date, max_date, start_balance), 'calmar': calculate_calmar(results, min_date, max_date, start_balance), 'profit_factor': profit_factor, 'backtest_start': min_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_start_ts': int(min_date.timestamp() * 1000), 'backtest_end': max_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_end_ts': int(max_date.timestamp() * 1000), 'backtest_days': backtest_days, 'backtest_run_start_ts': content['backtest_start_time'], 'backtest_run_end_ts': content['backtest_end_time'], 'trades_per_day': round(len(results) / backtest_days, 2), 'market_change': market_change, 'pairlist': pairlist, 'stake_amount': config['stake_amount'], 'stake_currency': config['stake_currency'], 'stake_currency_decimals': decimals_per_coin(config['stake_currency']), 'starting_balance': start_balance, 'dry_run_wallet': start_balance, 'final_balance': content['final_balance'], 'rejected_signals': content['rejected_signals'], 'timedout_entry_orders': content['timedout_entry_orders'], 'timedout_exit_orders': content['timedout_exit_orders'], 'canceled_trade_entries': content['canceled_trade_entries'], 'canceled_entry_orders': content['canceled_entry_orders'], 'replaced_entry_orders': content['replaced_entry_orders'], 'max_open_trades': max_open_trades, 'max_open_trades_setting': config['max_open_trades'] if config['max_open_trades'] != float('inf') else -1, 'timeframe': config['timeframe'], 'timeframe_detail': config.get('timeframe_detail', ''), 'timerange': config.get('timerange', ''), 'enable_protections': config.get('enable_protections', False), 'strategy_name': strategy, 'stoploss': config['stoploss'], 'trailing_stop': config.get('trailing_stop', False), 'trailing_stop_positive': config.get('trailing_stop_positive'), 'trailing_stop_positive_offset': config.get('trailing_stop_positive_offset', 0.0), 'trailing_only_offset_is_reached': config.get('trailing_only_offset_is_reached', False), 'use_custom_stoploss': config.get('use_custom_stoploss', False), 'minimal_roi': config['minimal_roi'], 'use_exit_signal': config['use_exit_signal'], 'exit_profit_only': config['exit_profit_only'], 'exit_profit_offset': config['exit_profit_offset'], 'ignore_roi_if_entry_signal': config['ignore_roi_if_entry_signal'], **periodic_breakdown, **daily_stats, **trade_stats}\n    try:\n        (max_drawdown_legacy, _, _, _, _, _) = calculate_max_drawdown(results, value_col='profit_ratio')\n        (drawdown_abs, drawdown_start, drawdown_end, high_val, low_val, max_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance)\n        (_, _, _, _, _, max_relative_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance, relative=True)\n        strat_stats.update({'max_drawdown': max_drawdown_legacy, 'max_drawdown_account': max_drawdown, 'max_relative_drawdown': max_relative_drawdown, 'max_drawdown_abs': drawdown_abs, 'drawdown_start': drawdown_start.strftime(DATETIME_PRINT_FORMAT), 'drawdown_start_ts': drawdown_start.timestamp() * 1000, 'drawdown_end': drawdown_end.strftime(DATETIME_PRINT_FORMAT), 'drawdown_end_ts': drawdown_end.timestamp() * 1000, 'max_drawdown_low': low_val, 'max_drawdown_high': high_val})\n        (csum_min, csum_max) = calculate_csum(results, start_balance)\n        strat_stats.update({'csum_min': csum_min, 'csum_max': csum_max})\n    except ValueError:\n        strat_stats.update({'max_drawdown': 0.0, 'max_drawdown_account': 0.0, 'max_relative_drawdown': 0.0, 'max_drawdown_abs': 0.0, 'max_drawdown_low': 0.0, 'max_drawdown_high': 0.0, 'drawdown_start': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_start_ts': 0, 'drawdown_end': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_end_ts': 0, 'csum_min': 0, 'csum_max': 0})\n    return strat_stats",
            "def generate_strategy_stats(pairlist: List[str], strategy: str, content: Dict[str, Any], min_date: datetime, max_date: datetime, market_change: float, is_hyperopt: bool=False) -> Dict[str, Any]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    :param pairlist: List of pairs to backtest\\n    :param strategy: Strategy name\\n    :param content: Backtest result data in the format:\\n                    {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :param market_change: float indicating the market change\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    results: Dict[str, DataFrame] = content['results']\n    if not isinstance(results, DataFrame):\n        return {}\n    config = content['config']\n    max_open_trades = min(config['max_open_trades'], len(pairlist))\n    start_balance = config['dry_run_wallet']\n    stake_currency = config['stake_currency']\n    pair_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results, skip_nan=False)\n    enter_tag_results = generate_tag_metrics('enter_tag', starting_balance=start_balance, results=results, skip_nan=False)\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=max_open_trades, results=results)\n    left_open_results = generate_pair_metrics(pairlist, stake_currency=stake_currency, starting_balance=start_balance, results=results.loc[results['exit_reason'] == 'force_exit'], skip_nan=True)\n    daily_stats = generate_daily_stats(results)\n    trade_stats = generate_trading_stats(results)\n    periodic_breakdown = {}\n    if not is_hyperopt:\n        periodic_breakdown = {'periodic_breakdown': generate_all_periodic_breakdown_stats(results)}\n    best_pair = max([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    worst_pair = min([pair for pair in pair_results if pair['key'] != 'TOTAL'], key=lambda x: x['profit_sum']) if len(pair_results) > 1 else None\n    winning_profit = results.loc[results['profit_abs'] > 0, 'profit_abs'].sum()\n    losing_profit = results.loc[results['profit_abs'] < 0, 'profit_abs'].sum()\n    profit_factor = winning_profit / abs(losing_profit) if losing_profit else 0.0\n    (expectancy, expectancy_ratio) = calculate_expectancy(results)\n    backtest_days = (max_date - min_date).days or 1\n    strat_stats = {'trades': results.to_dict(orient='records'), 'locks': [lock.to_json() for lock in content['locks']], 'best_pair': best_pair, 'worst_pair': worst_pair, 'results_per_pair': pair_results, 'results_per_enter_tag': enter_tag_results, 'exit_reason_summary': exit_reason_stats, 'left_open_trades': left_open_results, 'total_trades': len(results), 'trade_count_long': len(results.loc[~results['is_short']]), 'trade_count_short': len(results.loc[results['is_short']]), 'total_volume': float(results['stake_amount'].sum()), 'avg_stake_amount': results['stake_amount'].mean() if len(results) > 0 else 0, 'profit_mean': results['profit_ratio'].mean() if len(results) > 0 else 0, 'profit_median': results['profit_ratio'].median() if len(results) > 0 else 0, 'profit_total': results['profit_abs'].sum() / start_balance, 'profit_total_long': results.loc[~results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_short': results.loc[results['is_short'], 'profit_abs'].sum() / start_balance, 'profit_total_abs': results['profit_abs'].sum(), 'profit_total_long_abs': results.loc[~results['is_short'], 'profit_abs'].sum(), 'profit_total_short_abs': results.loc[results['is_short'], 'profit_abs'].sum(), 'cagr': calculate_cagr(backtest_days, start_balance, content['final_balance']), 'expectancy': expectancy, 'expectancy_ratio': expectancy_ratio, 'sortino': calculate_sortino(results, min_date, max_date, start_balance), 'sharpe': calculate_sharpe(results, min_date, max_date, start_balance), 'calmar': calculate_calmar(results, min_date, max_date, start_balance), 'profit_factor': profit_factor, 'backtest_start': min_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_start_ts': int(min_date.timestamp() * 1000), 'backtest_end': max_date.strftime(DATETIME_PRINT_FORMAT), 'backtest_end_ts': int(max_date.timestamp() * 1000), 'backtest_days': backtest_days, 'backtest_run_start_ts': content['backtest_start_time'], 'backtest_run_end_ts': content['backtest_end_time'], 'trades_per_day': round(len(results) / backtest_days, 2), 'market_change': market_change, 'pairlist': pairlist, 'stake_amount': config['stake_amount'], 'stake_currency': config['stake_currency'], 'stake_currency_decimals': decimals_per_coin(config['stake_currency']), 'starting_balance': start_balance, 'dry_run_wallet': start_balance, 'final_balance': content['final_balance'], 'rejected_signals': content['rejected_signals'], 'timedout_entry_orders': content['timedout_entry_orders'], 'timedout_exit_orders': content['timedout_exit_orders'], 'canceled_trade_entries': content['canceled_trade_entries'], 'canceled_entry_orders': content['canceled_entry_orders'], 'replaced_entry_orders': content['replaced_entry_orders'], 'max_open_trades': max_open_trades, 'max_open_trades_setting': config['max_open_trades'] if config['max_open_trades'] != float('inf') else -1, 'timeframe': config['timeframe'], 'timeframe_detail': config.get('timeframe_detail', ''), 'timerange': config.get('timerange', ''), 'enable_protections': config.get('enable_protections', False), 'strategy_name': strategy, 'stoploss': config['stoploss'], 'trailing_stop': config.get('trailing_stop', False), 'trailing_stop_positive': config.get('trailing_stop_positive'), 'trailing_stop_positive_offset': config.get('trailing_stop_positive_offset', 0.0), 'trailing_only_offset_is_reached': config.get('trailing_only_offset_is_reached', False), 'use_custom_stoploss': config.get('use_custom_stoploss', False), 'minimal_roi': config['minimal_roi'], 'use_exit_signal': config['use_exit_signal'], 'exit_profit_only': config['exit_profit_only'], 'exit_profit_offset': config['exit_profit_offset'], 'ignore_roi_if_entry_signal': config['ignore_roi_if_entry_signal'], **periodic_breakdown, **daily_stats, **trade_stats}\n    try:\n        (max_drawdown_legacy, _, _, _, _, _) = calculate_max_drawdown(results, value_col='profit_ratio')\n        (drawdown_abs, drawdown_start, drawdown_end, high_val, low_val, max_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance)\n        (_, _, _, _, _, max_relative_drawdown) = calculate_max_drawdown(results, value_col='profit_abs', starting_balance=start_balance, relative=True)\n        strat_stats.update({'max_drawdown': max_drawdown_legacy, 'max_drawdown_account': max_drawdown, 'max_relative_drawdown': max_relative_drawdown, 'max_drawdown_abs': drawdown_abs, 'drawdown_start': drawdown_start.strftime(DATETIME_PRINT_FORMAT), 'drawdown_start_ts': drawdown_start.timestamp() * 1000, 'drawdown_end': drawdown_end.strftime(DATETIME_PRINT_FORMAT), 'drawdown_end_ts': drawdown_end.timestamp() * 1000, 'max_drawdown_low': low_val, 'max_drawdown_high': high_val})\n        (csum_min, csum_max) = calculate_csum(results, start_balance)\n        strat_stats.update({'csum_min': csum_min, 'csum_max': csum_max})\n    except ValueError:\n        strat_stats.update({'max_drawdown': 0.0, 'max_drawdown_account': 0.0, 'max_relative_drawdown': 0.0, 'max_drawdown_abs': 0.0, 'max_drawdown_low': 0.0, 'max_drawdown_high': 0.0, 'drawdown_start': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_start_ts': 0, 'drawdown_end': datetime(1970, 1, 1, tzinfo=timezone.utc), 'drawdown_end_ts': 0, 'csum_min': 0, 'csum_max': 0})\n    return strat_stats"
        ]
    },
    {
        "func_name": "generate_backtest_stats",
        "original": "def generate_backtest_stats(btdata: Dict[str, DataFrame], all_results: Dict[str, Dict[str, Union[DataFrame, Dict]]], min_date: datetime, max_date: datetime) -> BacktestResultType:\n    \"\"\"\n    :param btdata: Backtest data\n    :param all_results: backtest result - dictionary in the form:\n                     { Strategy: {'results: results, 'config: config}}.\n    :param min_date: Backtest start date\n    :param max_date: Backtest end date\n    :return: Dictionary containing results per strategy and a strategy summary.\n    \"\"\"\n    result: BacktestResultType = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    market_change = calculate_market_change(btdata, 'close')\n    metadata = {}\n    pairlist = list(btdata.keys())\n    for (strategy, content) in all_results.items():\n        strat_stats = generate_strategy_stats(pairlist, strategy, content, min_date, max_date, market_change=market_change)\n        metadata[strategy] = {'run_id': content['run_id'], 'backtest_start_time': content['backtest_start_time']}\n        result['strategy'][strategy] = strat_stats\n    strategy_results = generate_strategy_comparison(bt_stats=result['strategy'])\n    result['metadata'] = metadata\n    result['strategy_comparison'] = strategy_results\n    return result",
        "mutated": [
            "def generate_backtest_stats(btdata: Dict[str, DataFrame], all_results: Dict[str, Dict[str, Union[DataFrame, Dict]]], min_date: datetime, max_date: datetime) -> BacktestResultType:\n    if False:\n        i = 10\n    \"\\n    :param btdata: Backtest data\\n    :param all_results: backtest result - dictionary in the form:\\n                     { Strategy: {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    result: BacktestResultType = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    market_change = calculate_market_change(btdata, 'close')\n    metadata = {}\n    pairlist = list(btdata.keys())\n    for (strategy, content) in all_results.items():\n        strat_stats = generate_strategy_stats(pairlist, strategy, content, min_date, max_date, market_change=market_change)\n        metadata[strategy] = {'run_id': content['run_id'], 'backtest_start_time': content['backtest_start_time']}\n        result['strategy'][strategy] = strat_stats\n    strategy_results = generate_strategy_comparison(bt_stats=result['strategy'])\n    result['metadata'] = metadata\n    result['strategy_comparison'] = strategy_results\n    return result",
            "def generate_backtest_stats(btdata: Dict[str, DataFrame], all_results: Dict[str, Dict[str, Union[DataFrame, Dict]]], min_date: datetime, max_date: datetime) -> BacktestResultType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    :param btdata: Backtest data\\n    :param all_results: backtest result - dictionary in the form:\\n                     { Strategy: {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    result: BacktestResultType = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    market_change = calculate_market_change(btdata, 'close')\n    metadata = {}\n    pairlist = list(btdata.keys())\n    for (strategy, content) in all_results.items():\n        strat_stats = generate_strategy_stats(pairlist, strategy, content, min_date, max_date, market_change=market_change)\n        metadata[strategy] = {'run_id': content['run_id'], 'backtest_start_time': content['backtest_start_time']}\n        result['strategy'][strategy] = strat_stats\n    strategy_results = generate_strategy_comparison(bt_stats=result['strategy'])\n    result['metadata'] = metadata\n    result['strategy_comparison'] = strategy_results\n    return result",
            "def generate_backtest_stats(btdata: Dict[str, DataFrame], all_results: Dict[str, Dict[str, Union[DataFrame, Dict]]], min_date: datetime, max_date: datetime) -> BacktestResultType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    :param btdata: Backtest data\\n    :param all_results: backtest result - dictionary in the form:\\n                     { Strategy: {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    result: BacktestResultType = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    market_change = calculate_market_change(btdata, 'close')\n    metadata = {}\n    pairlist = list(btdata.keys())\n    for (strategy, content) in all_results.items():\n        strat_stats = generate_strategy_stats(pairlist, strategy, content, min_date, max_date, market_change=market_change)\n        metadata[strategy] = {'run_id': content['run_id'], 'backtest_start_time': content['backtest_start_time']}\n        result['strategy'][strategy] = strat_stats\n    strategy_results = generate_strategy_comparison(bt_stats=result['strategy'])\n    result['metadata'] = metadata\n    result['strategy_comparison'] = strategy_results\n    return result",
            "def generate_backtest_stats(btdata: Dict[str, DataFrame], all_results: Dict[str, Dict[str, Union[DataFrame, Dict]]], min_date: datetime, max_date: datetime) -> BacktestResultType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    :param btdata: Backtest data\\n    :param all_results: backtest result - dictionary in the form:\\n                     { Strategy: {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    result: BacktestResultType = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    market_change = calculate_market_change(btdata, 'close')\n    metadata = {}\n    pairlist = list(btdata.keys())\n    for (strategy, content) in all_results.items():\n        strat_stats = generate_strategy_stats(pairlist, strategy, content, min_date, max_date, market_change=market_change)\n        metadata[strategy] = {'run_id': content['run_id'], 'backtest_start_time': content['backtest_start_time']}\n        result['strategy'][strategy] = strat_stats\n    strategy_results = generate_strategy_comparison(bt_stats=result['strategy'])\n    result['metadata'] = metadata\n    result['strategy_comparison'] = strategy_results\n    return result",
            "def generate_backtest_stats(btdata: Dict[str, DataFrame], all_results: Dict[str, Dict[str, Union[DataFrame, Dict]]], min_date: datetime, max_date: datetime) -> BacktestResultType:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    :param btdata: Backtest data\\n    :param all_results: backtest result - dictionary in the form:\\n                     { Strategy: {'results: results, 'config: config}}.\\n    :param min_date: Backtest start date\\n    :param max_date: Backtest end date\\n    :return: Dictionary containing results per strategy and a strategy summary.\\n    \"\n    result: BacktestResultType = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    market_change = calculate_market_change(btdata, 'close')\n    metadata = {}\n    pairlist = list(btdata.keys())\n    for (strategy, content) in all_results.items():\n        strat_stats = generate_strategy_stats(pairlist, strategy, content, min_date, max_date, market_change=market_change)\n        metadata[strategy] = {'run_id': content['run_id'], 'backtest_start_time': content['backtest_start_time']}\n        result['strategy'][strategy] = strat_stats\n    strategy_results = generate_strategy_comparison(bt_stats=result['strategy'])\n    result['metadata'] = metadata\n    result['strategy_comparison'] = strategy_results\n    return result"
        ]
    }
]