[
    {
        "func_name": "generate_random_sframe",
        "original": "def generate_random_sframe(num_rows, column_codes, random_seed=0):\n    \"\"\"\n    Creates a random SFrame with `num_rows` rows and randomly\n    generated column types determined by `column_codes`.  The output\n    SFrame is deterministic based on `random_seed`.\n\n     `column_types` is a string with each character denoting one type\n     of column, with the output SFrame having one column for each\n     character in the string.  The legend is as follows:\n\n        n:  numeric column, uniform 0-1 distribution.\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\n        r:  numeric column, uniform -100 to 100 distribution.\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\n        b:  binary integer column, uniform distribution\n        z:  integer column with random integers between 1 and 10.\n        Z:  integer column with random integers between 1 and 100.\n        s:  categorical string column with 10 different unique short strings.\n        S:  categorical string column with 100 different unique short strings.\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\n        h:  column with unique 128bit hex hashes.\n        H:  column with unique 256bit hex hashes.\n\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\n\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\n\n        d: dictionary with with between 0 and 10 string keys from a\n           pool of 100 unique keys, and random 0-1 values.\n\n        D: dictionary with with between 0 and 100 string keys from a\n           pool of 1000 unique keys, and random 0-1 values.\n\n    For example::\n\n      X = generate_random_sframe(10, 'nnv')\n\n    will generate a 10 row SFrame with 2 floating point columns and\n    one column of length 10 vectors.\n    \"\"\"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, False, 0)\n    X.materialize()\n    return X",
        "mutated": [
            "def generate_random_sframe(num_rows, column_codes, random_seed=0):\n    if False:\n        i = 10\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, False, 0)\n    X.materialize()\n    return X",
            "def generate_random_sframe(num_rows, column_codes, random_seed=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, False, 0)\n    X.materialize()\n    return X",
            "def generate_random_sframe(num_rows, column_codes, random_seed=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, False, 0)\n    X.materialize()\n    return X",
            "def generate_random_sframe(num_rows, column_codes, random_seed=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, False, 0)\n    X.materialize()\n    return X",
            "def generate_random_sframe(num_rows, column_codes, random_seed=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, False, 0)\n    X.materialize()\n    return X"
        ]
    },
    {
        "func_name": "generate_random_regression_sframe",
        "original": "def generate_random_regression_sframe(num_rows, column_codes, random_seed=0, target_noise_level=0.25):\n    \"\"\"\n    Creates a random SFrame with `num_rows` rows and randomly\n    generated column types determined by `column_codes`.  The output\n    SFrame is deterministic based on `random_seed`.  In addition, a\n    target column is generated with values dependent on the randomly\n    generated features in a given row.\n\n     `column_types` is a string with each character denoting one type\n     of column, with the output SFrame having one column for each\n     character in the string.  The legend is as follows:\n\n        n:  numeric column, uniform 0-1 distribution.\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\n        r:  numeric column, uniform -100 to 100 distribution.\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\n        b:  binary integer column, uniform distribution\n        z:  integer column with random integers between 1 and 10.\n        Z:  integer column with random integers between 1 and 100.\n        s:  categorical string column with 10 different unique short strings.\n        S:  categorical string column with 100 different unique short strings.\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\n        h:  column with unique 128bit hex hashes.\n        H:  column with unique 256bit hex hashes.\n\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\n\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\n\n        d: dictionary with with between 0 and 10 string keys from a\n           pool of 100 unique keys, and random 0-1 values.\n\n        D: dictionary with with between 0 and 100 string keys from a\n           pool of 1000 unique keys, and random 0-1 values.\n\n    For example::\n\n      X = generate_random_sframe(10, 'nnv')\n\n    will generate a 10 row SFrame with 2 floating point columns and\n    one column of length 10 vectors.\n\n    Target Generation\n    -----------------\n\n    the target value is a linear\n    combination of the features chosen for each row plus uniform noise.\n\n    - For each numeric and vector columns, each value, with the range\n      scaled to [-0.5, 0.5] (so r and R type values affect the target just\n      as much as n an N), is added to the target value.  NaNs are ignored.\n\n    - For each categorical or string values, it is hash-mapped to a lookup\n      table of 512 randomly chosen values, each in [-0.5, 0.5], and the\n      result is added to the target.\n\n    - For dictionary columns, the keys are treated as adding a categorical\n      value and the values are treated as adding a numeric value.\n\n    At the end, a uniform random value is added to the target in the\n    range [(max_target - min_target) * noise_level], where max_target\n    and min_target are the maximum and minimum target values generated\n    by the above process.\n\n    The final target values are then scaled to [0, 1].\n    \"\"\"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, True, target_noise_level)\n    X.materialize()\n    return X",
        "mutated": [
            "def generate_random_regression_sframe(num_rows, column_codes, random_seed=0, target_noise_level=0.25):\n    if False:\n        i = 10\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    the target value is a linear\\n    combination of the features chosen for each row plus uniform noise.\\n\\n    - For each numeric and vector columns, each value, with the range\\n      scaled to [-0.5, 0.5] (so r and R type values affect the target just\\n      as much as n an N), is added to the target value.  NaNs are ignored.\\n\\n    - For each categorical or string values, it is hash-mapped to a lookup\\n      table of 512 randomly chosen values, each in [-0.5, 0.5], and the\\n      result is added to the target.\\n\\n    - For dictionary columns, the keys are treated as adding a categorical\\n      value and the values are treated as adding a numeric value.\\n\\n    At the end, a uniform random value is added to the target in the\\n    range [(max_target - min_target) * noise_level], where max_target\\n    and min_target are the maximum and minimum target values generated\\n    by the above process.\\n\\n    The final target values are then scaled to [0, 1].\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, True, target_noise_level)\n    X.materialize()\n    return X",
            "def generate_random_regression_sframe(num_rows, column_codes, random_seed=0, target_noise_level=0.25):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    the target value is a linear\\n    combination of the features chosen for each row plus uniform noise.\\n\\n    - For each numeric and vector columns, each value, with the range\\n      scaled to [-0.5, 0.5] (so r and R type values affect the target just\\n      as much as n an N), is added to the target value.  NaNs are ignored.\\n\\n    - For each categorical or string values, it is hash-mapped to a lookup\\n      table of 512 randomly chosen values, each in [-0.5, 0.5], and the\\n      result is added to the target.\\n\\n    - For dictionary columns, the keys are treated as adding a categorical\\n      value and the values are treated as adding a numeric value.\\n\\n    At the end, a uniform random value is added to the target in the\\n    range [(max_target - min_target) * noise_level], where max_target\\n    and min_target are the maximum and minimum target values generated\\n    by the above process.\\n\\n    The final target values are then scaled to [0, 1].\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, True, target_noise_level)\n    X.materialize()\n    return X",
            "def generate_random_regression_sframe(num_rows, column_codes, random_seed=0, target_noise_level=0.25):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    the target value is a linear\\n    combination of the features chosen for each row plus uniform noise.\\n\\n    - For each numeric and vector columns, each value, with the range\\n      scaled to [-0.5, 0.5] (so r and R type values affect the target just\\n      as much as n an N), is added to the target value.  NaNs are ignored.\\n\\n    - For each categorical or string values, it is hash-mapped to a lookup\\n      table of 512 randomly chosen values, each in [-0.5, 0.5], and the\\n      result is added to the target.\\n\\n    - For dictionary columns, the keys are treated as adding a categorical\\n      value and the values are treated as adding a numeric value.\\n\\n    At the end, a uniform random value is added to the target in the\\n    range [(max_target - min_target) * noise_level], where max_target\\n    and min_target are the maximum and minimum target values generated\\n    by the above process.\\n\\n    The final target values are then scaled to [0, 1].\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, True, target_noise_level)\n    X.materialize()\n    return X",
            "def generate_random_regression_sframe(num_rows, column_codes, random_seed=0, target_noise_level=0.25):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    the target value is a linear\\n    combination of the features chosen for each row plus uniform noise.\\n\\n    - For each numeric and vector columns, each value, with the range\\n      scaled to [-0.5, 0.5] (so r and R type values affect the target just\\n      as much as n an N), is added to the target value.  NaNs are ignored.\\n\\n    - For each categorical or string values, it is hash-mapped to a lookup\\n      table of 512 randomly chosen values, each in [-0.5, 0.5], and the\\n      result is added to the target.\\n\\n    - For dictionary columns, the keys are treated as adding a categorical\\n      value and the values are treated as adding a numeric value.\\n\\n    At the end, a uniform random value is added to the target in the\\n    range [(max_target - min_target) * noise_level], where max_target\\n    and min_target are the maximum and minimum target values generated\\n    by the above process.\\n\\n    The final target values are then scaled to [0, 1].\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, True, target_noise_level)\n    X.materialize()\n    return X",
            "def generate_random_regression_sframe(num_rows, column_codes, random_seed=0, target_noise_level=0.25):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, 'nnv')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    the target value is a linear\\n    combination of the features chosen for each row plus uniform noise.\\n\\n    - For each numeric and vector columns, each value, with the range\\n      scaled to [-0.5, 0.5] (so r and R type values affect the target just\\n      as much as n an N), is added to the target value.  NaNs are ignored.\\n\\n    - For each categorical or string values, it is hash-mapped to a lookup\\n      table of 512 randomly chosen values, each in [-0.5, 0.5], and the\\n      result is added to the target.\\n\\n    - For dictionary columns, the keys are treated as adding a categorical\\n      value and the values are treated as adding a numeric value.\\n\\n    At the end, a uniform random value is added to the target in the\\n    range [(max_target - min_target) * noise_level], where max_target\\n    and min_target are the maximum and minimum target values generated\\n    by the above process.\\n\\n    The final target values are then scaled to [0, 1].\\n    \"\n    from ..extensions import _generate_random_sframe\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    X = _generate_random_sframe(num_rows, column_codes, random_seed, True, target_noise_level)\n    X.materialize()\n    return X"
        ]
    },
    {
        "func_name": "generate_random_classification_sframe",
        "original": "def generate_random_classification_sframe(num_rows, column_codes, num_classes, misclassification_spread=0.25, num_extra_class_bins=None, random_seed=0):\n    \"\"\"\n    Creates a random SFrame with `num_rows` rows and randomly\n    generated column types determined by `column_codes`.  The output\n    SFrame is deterministic based on `random_seed`.  In addition, a\n    target column is generated with values dependent on the randomly\n    generated features in a given row.\n\n     `column_types` is a string with each character denoting one type\n     of column, with the output SFrame having one column for each\n     character in the string.  The legend is as follows:\n\n        n:  numeric column, uniform 0-1 distribution.\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\n        r:  numeric column, uniform -100 to 100 distribution.\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\n        b:  binary integer column, uniform distribution\n        z:  integer column with random integers between 1 and 10.\n        Z:  integer column with random integers between 1 and 100.\n        s:  categorical string column with 10 different unique short strings.\n        S:  categorical string column with 100 different unique short strings.\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\n        h:  column with unique 128bit hex hashes.\n        H:  column with unique 256bit hex hashes.\n\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\n\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\n\n        d: dictionary with with between 0 and 10 string keys from a\n           pool of 100 unique keys, and random 0-1 values.\n\n        D: dictionary with with between 0 and 100 string keys from a\n           pool of 1000 unique keys, and random 0-1 values.\n\n    For example::\n\n      X = generate_random_sframe(10, 'nnv')\n\n    will generate a 10 row SFrame with 2 floating point columns and\n    one column of length 10 vectors.\n\n    Target Generation\n    -----------------\n\n    The target column, called \"target\", is an integer value that\n    represents the binning of the output of a noisy linear function of\n    the chosen random variables into `num_classes + num_extra_class_bins`\n    bins, shuffled, and then each bin is mapped to a class.  This\n    means that some non-linearity is present if num_extra_class_bins > 0.\n    The default value for num_extra_class_bins is 2*num_classes.\n\n    The `misclassification_probability` controls the spread of the\n    binning -- if misclassification_spread equals 0.25, then a random\n    variable of 0.25 * bin_width is added to the numeric prediction of\n    the class, meaning the actual class may be mispredicted.\n    \"\"\"\n    from ..extensions import _generate_random_classification_sframe\n    if num_classes < 2:\n        raise ValueError('num_classes must be >= 2.')\n    if num_extra_class_bins is None:\n        num_extra_class_bins = 2 * num_classes\n    if num_extra_class_bins < 0:\n        raise ValueError('num_extra_class_bins must be >= 0.')\n    if misclassification_spread < 0:\n        raise ValueError('misclassification_spread must be >= 0.')\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    assert isinstance(num_classes, int)\n    assert isinstance(num_extra_class_bins, int)\n    X = _generate_random_classification_sframe(num_rows, column_codes, random_seed, num_classes, num_extra_class_bins, misclassification_spread)\n    X.materialize()\n    return X",
        "mutated": [
            "def generate_random_classification_sframe(num_rows, column_codes, num_classes, misclassification_spread=0.25, num_extra_class_bins=None, random_seed=0):\n    if False:\n        i = 10\n    '\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, \\'nnv\\')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    The target column, called \"target\", is an integer value that\\n    represents the binning of the output of a noisy linear function of\\n    the chosen random variables into `num_classes + num_extra_class_bins`\\n    bins, shuffled, and then each bin is mapped to a class.  This\\n    means that some non-linearity is present if num_extra_class_bins > 0.\\n    The default value for num_extra_class_bins is 2*num_classes.\\n\\n    The `misclassification_probability` controls the spread of the\\n    binning -- if misclassification_spread equals 0.25, then a random\\n    variable of 0.25 * bin_width is added to the numeric prediction of\\n    the class, meaning the actual class may be mispredicted.\\n    '\n    from ..extensions import _generate_random_classification_sframe\n    if num_classes < 2:\n        raise ValueError('num_classes must be >= 2.')\n    if num_extra_class_bins is None:\n        num_extra_class_bins = 2 * num_classes\n    if num_extra_class_bins < 0:\n        raise ValueError('num_extra_class_bins must be >= 0.')\n    if misclassification_spread < 0:\n        raise ValueError('misclassification_spread must be >= 0.')\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    assert isinstance(num_classes, int)\n    assert isinstance(num_extra_class_bins, int)\n    X = _generate_random_classification_sframe(num_rows, column_codes, random_seed, num_classes, num_extra_class_bins, misclassification_spread)\n    X.materialize()\n    return X",
            "def generate_random_classification_sframe(num_rows, column_codes, num_classes, misclassification_spread=0.25, num_extra_class_bins=None, random_seed=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, \\'nnv\\')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    The target column, called \"target\", is an integer value that\\n    represents the binning of the output of a noisy linear function of\\n    the chosen random variables into `num_classes + num_extra_class_bins`\\n    bins, shuffled, and then each bin is mapped to a class.  This\\n    means that some non-linearity is present if num_extra_class_bins > 0.\\n    The default value for num_extra_class_bins is 2*num_classes.\\n\\n    The `misclassification_probability` controls the spread of the\\n    binning -- if misclassification_spread equals 0.25, then a random\\n    variable of 0.25 * bin_width is added to the numeric prediction of\\n    the class, meaning the actual class may be mispredicted.\\n    '\n    from ..extensions import _generate_random_classification_sframe\n    if num_classes < 2:\n        raise ValueError('num_classes must be >= 2.')\n    if num_extra_class_bins is None:\n        num_extra_class_bins = 2 * num_classes\n    if num_extra_class_bins < 0:\n        raise ValueError('num_extra_class_bins must be >= 0.')\n    if misclassification_spread < 0:\n        raise ValueError('misclassification_spread must be >= 0.')\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    assert isinstance(num_classes, int)\n    assert isinstance(num_extra_class_bins, int)\n    X = _generate_random_classification_sframe(num_rows, column_codes, random_seed, num_classes, num_extra_class_bins, misclassification_spread)\n    X.materialize()\n    return X",
            "def generate_random_classification_sframe(num_rows, column_codes, num_classes, misclassification_spread=0.25, num_extra_class_bins=None, random_seed=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, \\'nnv\\')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    The target column, called \"target\", is an integer value that\\n    represents the binning of the output of a noisy linear function of\\n    the chosen random variables into `num_classes + num_extra_class_bins`\\n    bins, shuffled, and then each bin is mapped to a class.  This\\n    means that some non-linearity is present if num_extra_class_bins > 0.\\n    The default value for num_extra_class_bins is 2*num_classes.\\n\\n    The `misclassification_probability` controls the spread of the\\n    binning -- if misclassification_spread equals 0.25, then a random\\n    variable of 0.25 * bin_width is added to the numeric prediction of\\n    the class, meaning the actual class may be mispredicted.\\n    '\n    from ..extensions import _generate_random_classification_sframe\n    if num_classes < 2:\n        raise ValueError('num_classes must be >= 2.')\n    if num_extra_class_bins is None:\n        num_extra_class_bins = 2 * num_classes\n    if num_extra_class_bins < 0:\n        raise ValueError('num_extra_class_bins must be >= 0.')\n    if misclassification_spread < 0:\n        raise ValueError('misclassification_spread must be >= 0.')\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    assert isinstance(num_classes, int)\n    assert isinstance(num_extra_class_bins, int)\n    X = _generate_random_classification_sframe(num_rows, column_codes, random_seed, num_classes, num_extra_class_bins, misclassification_spread)\n    X.materialize()\n    return X",
            "def generate_random_classification_sframe(num_rows, column_codes, num_classes, misclassification_spread=0.25, num_extra_class_bins=None, random_seed=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, \\'nnv\\')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    The target column, called \"target\", is an integer value that\\n    represents the binning of the output of a noisy linear function of\\n    the chosen random variables into `num_classes + num_extra_class_bins`\\n    bins, shuffled, and then each bin is mapped to a class.  This\\n    means that some non-linearity is present if num_extra_class_bins > 0.\\n    The default value for num_extra_class_bins is 2*num_classes.\\n\\n    The `misclassification_probability` controls the spread of the\\n    binning -- if misclassification_spread equals 0.25, then a random\\n    variable of 0.25 * bin_width is added to the numeric prediction of\\n    the class, meaning the actual class may be mispredicted.\\n    '\n    from ..extensions import _generate_random_classification_sframe\n    if num_classes < 2:\n        raise ValueError('num_classes must be >= 2.')\n    if num_extra_class_bins is None:\n        num_extra_class_bins = 2 * num_classes\n    if num_extra_class_bins < 0:\n        raise ValueError('num_extra_class_bins must be >= 0.')\n    if misclassification_spread < 0:\n        raise ValueError('misclassification_spread must be >= 0.')\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    assert isinstance(num_classes, int)\n    assert isinstance(num_extra_class_bins, int)\n    X = _generate_random_classification_sframe(num_rows, column_codes, random_seed, num_classes, num_extra_class_bins, misclassification_spread)\n    X.materialize()\n    return X",
            "def generate_random_classification_sframe(num_rows, column_codes, num_classes, misclassification_spread=0.25, num_extra_class_bins=None, random_seed=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Creates a random SFrame with `num_rows` rows and randomly\\n    generated column types determined by `column_codes`.  The output\\n    SFrame is deterministic based on `random_seed`.  In addition, a\\n    target column is generated with values dependent on the randomly\\n    generated features in a given row.\\n\\n     `column_types` is a string with each character denoting one type\\n     of column, with the output SFrame having one column for each\\n     character in the string.  The legend is as follows:\\n\\n        n:  numeric column, uniform 0-1 distribution.\\n        N:  numeric column, uniform 0-1 distribution, 1% NaNs.\\n        r:  numeric column, uniform -100 to 100 distribution.\\n        R:  numeric column, uniform -10000 to 10000 distribution, 1% NaNs.\\n        b:  binary integer column, uniform distribution\\n        z:  integer column with random integers between 1 and 10.\\n        Z:  integer column with random integers between 1 and 100.\\n        s:  categorical string column with 10 different unique short strings.\\n        S:  categorical string column with 100 different unique short strings.\\n        c:  categorical column with short string keys and 1000 unique values, triangle distribution.\\n        C:  categorical column with short string keys and 100000 unique values, triangle distribution.\\n        x:  categorical column with 128bit hex hashes and 1000 unique values.\\n        X:  categorical column with 256bit hex hashes and 100000 unique values.\\n        h:  column with unique 128bit hex hashes.\\n        H:  column with unique 256bit hex hashes.\\n\\n        l:  categorical list with between 0 and 10 unique integer elements from a pool of 100 unique values.\\n        L:  categorical list with between 0 and 100 unique integer elements from a pool of 1000 unique values.\\n        M:  categorical list with between 0 and 10 unique string elements from a pool of 100 unique values.\\n        m:  categorical list with between 0 and 100 unique string elements from a pool of 1000 unique values.\\n\\n        v:  numeric vector with 10 elements and uniform 0-1 elements.\\n        V:  numeric vector with 1000 elements and uniform 0-1 elements.\\n        w:  numeric vector with 10 elements and uniform 0-1 elements, 1% NANs.\\n        W:  numeric vector with 1000 elements and uniform 0-1 elements, 1% NANs.\\n\\n        d: dictionary with with between 0 and 10 string keys from a\\n           pool of 100 unique keys, and random 0-1 values.\\n\\n        D: dictionary with with between 0 and 100 string keys from a\\n           pool of 1000 unique keys, and random 0-1 values.\\n\\n    For example::\\n\\n      X = generate_random_sframe(10, \\'nnv\\')\\n\\n    will generate a 10 row SFrame with 2 floating point columns and\\n    one column of length 10 vectors.\\n\\n    Target Generation\\n    -----------------\\n\\n    The target column, called \"target\", is an integer value that\\n    represents the binning of the output of a noisy linear function of\\n    the chosen random variables into `num_classes + num_extra_class_bins`\\n    bins, shuffled, and then each bin is mapped to a class.  This\\n    means that some non-linearity is present if num_extra_class_bins > 0.\\n    The default value for num_extra_class_bins is 2*num_classes.\\n\\n    The `misclassification_probability` controls the spread of the\\n    binning -- if misclassification_spread equals 0.25, then a random\\n    variable of 0.25 * bin_width is added to the numeric prediction of\\n    the class, meaning the actual class may be mispredicted.\\n    '\n    from ..extensions import _generate_random_classification_sframe\n    if num_classes < 2:\n        raise ValueError('num_classes must be >= 2.')\n    if num_extra_class_bins is None:\n        num_extra_class_bins = 2 * num_classes\n    if num_extra_class_bins < 0:\n        raise ValueError('num_extra_class_bins must be >= 0.')\n    if misclassification_spread < 0:\n        raise ValueError('misclassification_spread must be >= 0.')\n    assert isinstance(column_codes, str)\n    assert isinstance(num_rows, int)\n    assert isinstance(random_seed, int)\n    assert isinstance(num_classes, int)\n    assert isinstance(num_extra_class_bins, int)\n    X = _generate_random_classification_sframe(num_rows, column_codes, random_seed, num_classes, num_extra_class_bins, misclassification_spread)\n    X.materialize()\n    return X"
        ]
    }
]