[
    {
        "func_name": "get_proc_maps",
        "original": "def get_proc_maps():\n    \"\"\"\n        Example info proc mappings:\n\n    pwndbg> info proc mappings\n    process 26781\n    Mapped address spaces:\n\n              Start Addr           End Addr       Size     Offset objfile\n                0x400000           0x401000     0x1000        0x0 /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\n          0x7ffff7ffa000     0x7ffff7ffd000     0x3000        0x0 [vvar]\n          0x7ffff7ffd000     0x7ffff7fff000     0x2000        0x0 [vdso]\n          0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]\n      0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]\n    \"\"\"\n    maps = []\n    with open('/proc/%d/maps' % pwndbg.gdblib.proc.pid) as f:\n        for line in f.read().splitlines():\n            (addrs, perms, offset, _inode, size, objfile) = line.split(maxsplit=6)\n            (start, end) = map(lambda v: int(v, 16), addrs.split('-'))\n            offset = offset.lstrip('0') or '0'\n            size = end - start\n            maps.append([hex(start), hex(end), perms, hex(size)[2:], offset, objfile])\n    maps.sort()\n    return maps",
        "mutated": [
            "def get_proc_maps():\n    if False:\n        i = 10\n    '\\n        Example info proc mappings:\\n\\n    pwndbg> info proc mappings\\n    process 26781\\n    Mapped address spaces:\\n\\n              Start Addr           End Addr       Size     Offset objfile\\n                0x400000           0x401000     0x1000        0x0 /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n          0x7ffff7ffa000     0x7ffff7ffd000     0x3000        0x0 [vvar]\\n          0x7ffff7ffd000     0x7ffff7fff000     0x2000        0x0 [vdso]\\n          0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]\\n      0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]\\n    '\n    maps = []\n    with open('/proc/%d/maps' % pwndbg.gdblib.proc.pid) as f:\n        for line in f.read().splitlines():\n            (addrs, perms, offset, _inode, size, objfile) = line.split(maxsplit=6)\n            (start, end) = map(lambda v: int(v, 16), addrs.split('-'))\n            offset = offset.lstrip('0') or '0'\n            size = end - start\n            maps.append([hex(start), hex(end), perms, hex(size)[2:], offset, objfile])\n    maps.sort()\n    return maps",
            "def get_proc_maps():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Example info proc mappings:\\n\\n    pwndbg> info proc mappings\\n    process 26781\\n    Mapped address spaces:\\n\\n              Start Addr           End Addr       Size     Offset objfile\\n                0x400000           0x401000     0x1000        0x0 /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n          0x7ffff7ffa000     0x7ffff7ffd000     0x3000        0x0 [vvar]\\n          0x7ffff7ffd000     0x7ffff7fff000     0x2000        0x0 [vdso]\\n          0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]\\n      0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]\\n    '\n    maps = []\n    with open('/proc/%d/maps' % pwndbg.gdblib.proc.pid) as f:\n        for line in f.read().splitlines():\n            (addrs, perms, offset, _inode, size, objfile) = line.split(maxsplit=6)\n            (start, end) = map(lambda v: int(v, 16), addrs.split('-'))\n            offset = offset.lstrip('0') or '0'\n            size = end - start\n            maps.append([hex(start), hex(end), perms, hex(size)[2:], offset, objfile])\n    maps.sort()\n    return maps",
            "def get_proc_maps():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Example info proc mappings:\\n\\n    pwndbg> info proc mappings\\n    process 26781\\n    Mapped address spaces:\\n\\n              Start Addr           End Addr       Size     Offset objfile\\n                0x400000           0x401000     0x1000        0x0 /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n          0x7ffff7ffa000     0x7ffff7ffd000     0x3000        0x0 [vvar]\\n          0x7ffff7ffd000     0x7ffff7fff000     0x2000        0x0 [vdso]\\n          0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]\\n      0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]\\n    '\n    maps = []\n    with open('/proc/%d/maps' % pwndbg.gdblib.proc.pid) as f:\n        for line in f.read().splitlines():\n            (addrs, perms, offset, _inode, size, objfile) = line.split(maxsplit=6)\n            (start, end) = map(lambda v: int(v, 16), addrs.split('-'))\n            offset = offset.lstrip('0') or '0'\n            size = end - start\n            maps.append([hex(start), hex(end), perms, hex(size)[2:], offset, objfile])\n    maps.sort()\n    return maps",
            "def get_proc_maps():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Example info proc mappings:\\n\\n    pwndbg> info proc mappings\\n    process 26781\\n    Mapped address spaces:\\n\\n              Start Addr           End Addr       Size     Offset objfile\\n                0x400000           0x401000     0x1000        0x0 /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n          0x7ffff7ffa000     0x7ffff7ffd000     0x3000        0x0 [vvar]\\n          0x7ffff7ffd000     0x7ffff7fff000     0x2000        0x0 [vdso]\\n          0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]\\n      0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]\\n    '\n    maps = []\n    with open('/proc/%d/maps' % pwndbg.gdblib.proc.pid) as f:\n        for line in f.read().splitlines():\n            (addrs, perms, offset, _inode, size, objfile) = line.split(maxsplit=6)\n            (start, end) = map(lambda v: int(v, 16), addrs.split('-'))\n            offset = offset.lstrip('0') or '0'\n            size = end - start\n            maps.append([hex(start), hex(end), perms, hex(size)[2:], offset, objfile])\n    maps.sort()\n    return maps",
            "def get_proc_maps():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Example info proc mappings:\\n\\n    pwndbg> info proc mappings\\n    process 26781\\n    Mapped address spaces:\\n\\n              Start Addr           End Addr       Size     Offset objfile\\n                0x400000           0x401000     0x1000        0x0 /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n          0x7ffff7ffa000     0x7ffff7ffd000     0x3000        0x0 [vvar]\\n          0x7ffff7ffd000     0x7ffff7fff000     0x2000        0x0 [vdso]\\n          0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]\\n      0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]\\n    '\n    maps = []\n    with open('/proc/%d/maps' % pwndbg.gdblib.proc.pid) as f:\n        for line in f.read().splitlines():\n            (addrs, perms, offset, _inode, size, objfile) = line.split(maxsplit=6)\n            (start, end) = map(lambda v: int(v, 16), addrs.split('-'))\n            offset = offset.lstrip('0') or '0'\n            size = end - start\n            maps.append([hex(start), hex(end), perms, hex(size)[2:], offset, objfile])\n    maps.sort()\n    return maps"
        ]
    },
    {
        "func_name": "assert_maps",
        "original": "def assert_maps():\n    for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n        if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n            assert vmmap[:2] == expected_map[:2]\n            assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n            assert vmmap[4:] == expected_map[4:]\n            continue\n        assert vmmap[:-1] == expected_map[:-1]\n        if vmmap[-1].startswith('load'):\n            continue\n        assert vmmap[-1] == expected_map[-1]",
        "mutated": [
            "def assert_maps():\n    if False:\n        i = 10\n    for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n        if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n            assert vmmap[:2] == expected_map[:2]\n            assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n            assert vmmap[4:] == expected_map[4:]\n            continue\n        assert vmmap[:-1] == expected_map[:-1]\n        if vmmap[-1].startswith('load'):\n            continue\n        assert vmmap[-1] == expected_map[-1]",
            "def assert_maps():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n        if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n            assert vmmap[:2] == expected_map[:2]\n            assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n            assert vmmap[4:] == expected_map[4:]\n            continue\n        assert vmmap[:-1] == expected_map[:-1]\n        if vmmap[-1].startswith('load'):\n            continue\n        assert vmmap[-1] == expected_map[-1]",
            "def assert_maps():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n        if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n            assert vmmap[:2] == expected_map[:2]\n            assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n            assert vmmap[4:] == expected_map[4:]\n            continue\n        assert vmmap[:-1] == expected_map[:-1]\n        if vmmap[-1].startswith('load'):\n            continue\n        assert vmmap[-1] == expected_map[-1]",
            "def assert_maps():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n        if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n            assert vmmap[:2] == expected_map[:2]\n            assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n            assert vmmap[4:] == expected_map[4:]\n            continue\n        assert vmmap[:-1] == expected_map[:-1]\n        if vmmap[-1].startswith('load'):\n            continue\n        assert vmmap[-1] == expected_map[-1]",
            "def assert_maps():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n        if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n            assert vmmap[:2] == expected_map[:2]\n            assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n            assert vmmap[4:] == expected_map[4:]\n            continue\n        assert vmmap[:-1] == expected_map[:-1]\n        if vmmap[-1].startswith('load'):\n            continue\n        assert vmmap[-1] == expected_map[-1]"
        ]
    },
    {
        "func_name": "test_command_vmmap_on_coredump_on_crash_simple_binary",
        "original": "@pytest.mark.parametrize('unload_file', (False, True))\ndef test_command_vmmap_on_coredump_on_crash_simple_binary(start_binary, unload_file):\n    \"\"\"\n    Example vmmap when debugging binary:\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\n            0x7ffff7ffa000     0x7ffff7ffd000 r--p     3000 0      [vvar]\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 0      [vdso]\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 0      [stack]\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]\n\n    The same vmmap when debugging coredump:\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 1158   load2\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 3158   [stack]\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 24158  [vsyscall]\n\n    Note that for a core-file, we display the [vdso] page as load2 and we are missing the [vvar] page.\n    This is... how it is. It just seems that core files (at least those I met) have no info about\n    the vvar page and also GDB can't access the [vvar] memory with its x/ command during core debugging.\n    \"\"\"\n    start_binary(CRASH_SIMPLE_BINARY)\n    gdb.execute('continue')\n    expected_maps = get_proc_maps()\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert len(vmmaps) == len(expected_maps) + 2\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert vmmaps == expected_maps\n    core = tempfile.mktemp()\n    gdb.execute(f'generate-core-file {core}')\n    if unload_file:\n        gdb.execute('file')\n    gdb.execute(f'core-file {core}')\n    old_len_vmmaps = len(vmmaps)\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    has_proc_maps = 'warning: unable to find mappings in core file' not in gdb.execute('info proc mappings', to_string=True)\n    if has_proc_maps:\n        assert len(vmmaps) == old_len_vmmaps - 1\n    else:\n        assert len(vmmaps) == old_len_vmmaps - 2\n        binary_map = next((i for i in expected_maps if CRASH_SIMPLE_BINARY in i[-1]))\n        expected_maps.remove(binary_map)\n    next((i for i in expected_maps if i[-1] == '[vdso]'))[-1] = 'load2'\n    vdso_map = next((i for i in expected_maps if i[-1] == '[vvar]'))\n    expected_maps.remove(vdso_map)\n\n    def assert_maps():\n        for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n            if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n                assert vmmap[:2] == expected_map[:2]\n                assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n                assert vmmap[4:] == expected_map[4:]\n                continue\n            assert vmmap[:-1] == expected_map[:-1]\n            if vmmap[-1].startswith('load'):\n                continue\n            assert vmmap[-1] == expected_map[-1]\n    assert_maps()\n    gdb.execute('file')\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert_maps()",
        "mutated": [
            "@pytest.mark.parametrize('unload_file', (False, True))\ndef test_command_vmmap_on_coredump_on_crash_simple_binary(start_binary, unload_file):\n    if False:\n        i = 10\n    \"\\n    Example vmmap when debugging binary:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffa000     0x7ffff7ffd000 r--p     3000 0      [vvar]\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 0      [vdso]\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 0      [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]\\n\\n    The same vmmap when debugging coredump:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 1158   load2\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 3158   [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 24158  [vsyscall]\\n\\n    Note that for a core-file, we display the [vdso] page as load2 and we are missing the [vvar] page.\\n    This is... how it is. It just seems that core files (at least those I met) have no info about\\n    the vvar page and also GDB can't access the [vvar] memory with its x/ command during core debugging.\\n    \"\n    start_binary(CRASH_SIMPLE_BINARY)\n    gdb.execute('continue')\n    expected_maps = get_proc_maps()\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert len(vmmaps) == len(expected_maps) + 2\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert vmmaps == expected_maps\n    core = tempfile.mktemp()\n    gdb.execute(f'generate-core-file {core}')\n    if unload_file:\n        gdb.execute('file')\n    gdb.execute(f'core-file {core}')\n    old_len_vmmaps = len(vmmaps)\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    has_proc_maps = 'warning: unable to find mappings in core file' not in gdb.execute('info proc mappings', to_string=True)\n    if has_proc_maps:\n        assert len(vmmaps) == old_len_vmmaps - 1\n    else:\n        assert len(vmmaps) == old_len_vmmaps - 2\n        binary_map = next((i for i in expected_maps if CRASH_SIMPLE_BINARY in i[-1]))\n        expected_maps.remove(binary_map)\n    next((i for i in expected_maps if i[-1] == '[vdso]'))[-1] = 'load2'\n    vdso_map = next((i for i in expected_maps if i[-1] == '[vvar]'))\n    expected_maps.remove(vdso_map)\n\n    def assert_maps():\n        for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n            if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n                assert vmmap[:2] == expected_map[:2]\n                assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n                assert vmmap[4:] == expected_map[4:]\n                continue\n            assert vmmap[:-1] == expected_map[:-1]\n            if vmmap[-1].startswith('load'):\n                continue\n            assert vmmap[-1] == expected_map[-1]\n    assert_maps()\n    gdb.execute('file')\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert_maps()",
            "@pytest.mark.parametrize('unload_file', (False, True))\ndef test_command_vmmap_on_coredump_on_crash_simple_binary(start_binary, unload_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Example vmmap when debugging binary:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffa000     0x7ffff7ffd000 r--p     3000 0      [vvar]\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 0      [vdso]\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 0      [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]\\n\\n    The same vmmap when debugging coredump:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 1158   load2\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 3158   [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 24158  [vsyscall]\\n\\n    Note that for a core-file, we display the [vdso] page as load2 and we are missing the [vvar] page.\\n    This is... how it is. It just seems that core files (at least those I met) have no info about\\n    the vvar page and also GDB can't access the [vvar] memory with its x/ command during core debugging.\\n    \"\n    start_binary(CRASH_SIMPLE_BINARY)\n    gdb.execute('continue')\n    expected_maps = get_proc_maps()\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert len(vmmaps) == len(expected_maps) + 2\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert vmmaps == expected_maps\n    core = tempfile.mktemp()\n    gdb.execute(f'generate-core-file {core}')\n    if unload_file:\n        gdb.execute('file')\n    gdb.execute(f'core-file {core}')\n    old_len_vmmaps = len(vmmaps)\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    has_proc_maps = 'warning: unable to find mappings in core file' not in gdb.execute('info proc mappings', to_string=True)\n    if has_proc_maps:\n        assert len(vmmaps) == old_len_vmmaps - 1\n    else:\n        assert len(vmmaps) == old_len_vmmaps - 2\n        binary_map = next((i for i in expected_maps if CRASH_SIMPLE_BINARY in i[-1]))\n        expected_maps.remove(binary_map)\n    next((i for i in expected_maps if i[-1] == '[vdso]'))[-1] = 'load2'\n    vdso_map = next((i for i in expected_maps if i[-1] == '[vvar]'))\n    expected_maps.remove(vdso_map)\n\n    def assert_maps():\n        for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n            if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n                assert vmmap[:2] == expected_map[:2]\n                assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n                assert vmmap[4:] == expected_map[4:]\n                continue\n            assert vmmap[:-1] == expected_map[:-1]\n            if vmmap[-1].startswith('load'):\n                continue\n            assert vmmap[-1] == expected_map[-1]\n    assert_maps()\n    gdb.execute('file')\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert_maps()",
            "@pytest.mark.parametrize('unload_file', (False, True))\ndef test_command_vmmap_on_coredump_on_crash_simple_binary(start_binary, unload_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Example vmmap when debugging binary:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffa000     0x7ffff7ffd000 r--p     3000 0      [vvar]\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 0      [vdso]\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 0      [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]\\n\\n    The same vmmap when debugging coredump:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 1158   load2\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 3158   [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 24158  [vsyscall]\\n\\n    Note that for a core-file, we display the [vdso] page as load2 and we are missing the [vvar] page.\\n    This is... how it is. It just seems that core files (at least those I met) have no info about\\n    the vvar page and also GDB can't access the [vvar] memory with its x/ command during core debugging.\\n    \"\n    start_binary(CRASH_SIMPLE_BINARY)\n    gdb.execute('continue')\n    expected_maps = get_proc_maps()\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert len(vmmaps) == len(expected_maps) + 2\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert vmmaps == expected_maps\n    core = tempfile.mktemp()\n    gdb.execute(f'generate-core-file {core}')\n    if unload_file:\n        gdb.execute('file')\n    gdb.execute(f'core-file {core}')\n    old_len_vmmaps = len(vmmaps)\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    has_proc_maps = 'warning: unable to find mappings in core file' not in gdb.execute('info proc mappings', to_string=True)\n    if has_proc_maps:\n        assert len(vmmaps) == old_len_vmmaps - 1\n    else:\n        assert len(vmmaps) == old_len_vmmaps - 2\n        binary_map = next((i for i in expected_maps if CRASH_SIMPLE_BINARY in i[-1]))\n        expected_maps.remove(binary_map)\n    next((i for i in expected_maps if i[-1] == '[vdso]'))[-1] = 'load2'\n    vdso_map = next((i for i in expected_maps if i[-1] == '[vvar]'))\n    expected_maps.remove(vdso_map)\n\n    def assert_maps():\n        for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n            if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n                assert vmmap[:2] == expected_map[:2]\n                assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n                assert vmmap[4:] == expected_map[4:]\n                continue\n            assert vmmap[:-1] == expected_map[:-1]\n            if vmmap[-1].startswith('load'):\n                continue\n            assert vmmap[-1] == expected_map[-1]\n    assert_maps()\n    gdb.execute('file')\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert_maps()",
            "@pytest.mark.parametrize('unload_file', (False, True))\ndef test_command_vmmap_on_coredump_on_crash_simple_binary(start_binary, unload_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Example vmmap when debugging binary:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffa000     0x7ffff7ffd000 r--p     3000 0      [vvar]\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 0      [vdso]\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 0      [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]\\n\\n    The same vmmap when debugging coredump:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 1158   load2\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 3158   [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 24158  [vsyscall]\\n\\n    Note that for a core-file, we display the [vdso] page as load2 and we are missing the [vvar] page.\\n    This is... how it is. It just seems that core files (at least those I met) have no info about\\n    the vvar page and also GDB can't access the [vvar] memory with its x/ command during core debugging.\\n    \"\n    start_binary(CRASH_SIMPLE_BINARY)\n    gdb.execute('continue')\n    expected_maps = get_proc_maps()\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert len(vmmaps) == len(expected_maps) + 2\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert vmmaps == expected_maps\n    core = tempfile.mktemp()\n    gdb.execute(f'generate-core-file {core}')\n    if unload_file:\n        gdb.execute('file')\n    gdb.execute(f'core-file {core}')\n    old_len_vmmaps = len(vmmaps)\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    has_proc_maps = 'warning: unable to find mappings in core file' not in gdb.execute('info proc mappings', to_string=True)\n    if has_proc_maps:\n        assert len(vmmaps) == old_len_vmmaps - 1\n    else:\n        assert len(vmmaps) == old_len_vmmaps - 2\n        binary_map = next((i for i in expected_maps if CRASH_SIMPLE_BINARY in i[-1]))\n        expected_maps.remove(binary_map)\n    next((i for i in expected_maps if i[-1] == '[vdso]'))[-1] = 'load2'\n    vdso_map = next((i for i in expected_maps if i[-1] == '[vvar]'))\n    expected_maps.remove(vdso_map)\n\n    def assert_maps():\n        for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n            if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n                assert vmmap[:2] == expected_map[:2]\n                assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n                assert vmmap[4:] == expected_map[4:]\n                continue\n            assert vmmap[:-1] == expected_map[:-1]\n            if vmmap[-1].startswith('load'):\n                continue\n            assert vmmap[-1] == expected_map[-1]\n    assert_maps()\n    gdb.execute('file')\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert_maps()",
            "@pytest.mark.parametrize('unload_file', (False, True))\ndef test_command_vmmap_on_coredump_on_crash_simple_binary(start_binary, unload_file):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Example vmmap when debugging binary:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffa000     0x7ffff7ffd000 r--p     3000 0      [vvar]\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 0      [vdso]\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 0      [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]\\n\\n    The same vmmap when debugging coredump:\\n        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\\n                  0x400000           0x401000 r-xp     1000 0      /opt/pwndbg/tests/gdb-tests/tests/binaries/crash_simple.out\\n            0x7ffff7ffd000     0x7ffff7fff000 r-xp     2000 1158   load2\\n            0x7ffffffde000     0x7ffffffff000 rwxp    21000 3158   [stack]\\n        0xffffffffff600000 0xffffffffff601000 r-xp     1000 24158  [vsyscall]\\n\\n    Note that for a core-file, we display the [vdso] page as load2 and we are missing the [vvar] page.\\n    This is... how it is. It just seems that core files (at least those I met) have no info about\\n    the vvar page and also GDB can't access the [vvar] memory with its x/ command during core debugging.\\n    \"\n    start_binary(CRASH_SIMPLE_BINARY)\n    gdb.execute('continue')\n    expected_maps = get_proc_maps()\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert len(vmmaps) == len(expected_maps) + 2\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert vmmaps == expected_maps\n    core = tempfile.mktemp()\n    gdb.execute(f'generate-core-file {core}')\n    if unload_file:\n        gdb.execute('file')\n    gdb.execute(f'core-file {core}')\n    old_len_vmmaps = len(vmmaps)\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    assert vmmaps[0] == 'LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA'\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    has_proc_maps = 'warning: unable to find mappings in core file' not in gdb.execute('info proc mappings', to_string=True)\n    if has_proc_maps:\n        assert len(vmmaps) == old_len_vmmaps - 1\n    else:\n        assert len(vmmaps) == old_len_vmmaps - 2\n        binary_map = next((i for i in expected_maps if CRASH_SIMPLE_BINARY in i[-1]))\n        expected_maps.remove(binary_map)\n    next((i for i in expected_maps if i[-1] == '[vdso]'))[-1] = 'load2'\n    vdso_map = next((i for i in expected_maps if i[-1] == '[vvar]'))\n    expected_maps.remove(vdso_map)\n\n    def assert_maps():\n        for (vmmap, expected_map) in zip(vmmaps, expected_maps):\n            if vmmap[-1] == expected_map[-1] == '[vsyscall]':\n                assert vmmap[:2] == expected_map[:2]\n                assert vmmap[3] == expected_map[3] or vmmap[3] in ('r-xp', '--xp')\n                assert vmmap[4:] == expected_map[4:]\n                continue\n            assert vmmap[:-1] == expected_map[:-1]\n            if vmmap[-1].startswith('load'):\n                continue\n            assert vmmap[-1] == expected_map[-1]\n    assert_maps()\n    gdb.execute('file')\n    vmmaps = gdb.execute('vmmap', to_string=True).splitlines()\n    vmmaps = [i.split() for i in vmmaps[2:]]\n    assert_maps()"
        ]
    },
    {
        "func_name": "test_vmmap_issue_1565",
        "original": "def test_vmmap_issue_1565(start_binary):\n    \"\"\"\n    https://github.com/pwndbg/pwndbg/issues/1565\n\n    In tests this bug is reported as:\n    >       gdb.execute(\"context\")\n    E       gdb.error: Error occurred in Python: maximum recursion depth exceeded in comparison\n\n    In a normal GDB session this is reported as:\n        Exception occurred: context: maximum recursion depth exceeded while calling a Python object (<class 'RecursionError'>)\n    \"\"\"\n    gdb.execute(f'file {BINARY_ISSUE_1565}')\n    gdb.execute('break thread_function')\n    gdb.execute('run')\n    gdb.execute('next')\n    gdb.execute('context')",
        "mutated": [
            "def test_vmmap_issue_1565(start_binary):\n    if False:\n        i = 10\n    '\\n    https://github.com/pwndbg/pwndbg/issues/1565\\n\\n    In tests this bug is reported as:\\n    >       gdb.execute(\"context\")\\n    E       gdb.error: Error occurred in Python: maximum recursion depth exceeded in comparison\\n\\n    In a normal GDB session this is reported as:\\n        Exception occurred: context: maximum recursion depth exceeded while calling a Python object (<class \\'RecursionError\\'>)\\n    '\n    gdb.execute(f'file {BINARY_ISSUE_1565}')\n    gdb.execute('break thread_function')\n    gdb.execute('run')\n    gdb.execute('next')\n    gdb.execute('context')",
            "def test_vmmap_issue_1565(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    https://github.com/pwndbg/pwndbg/issues/1565\\n\\n    In tests this bug is reported as:\\n    >       gdb.execute(\"context\")\\n    E       gdb.error: Error occurred in Python: maximum recursion depth exceeded in comparison\\n\\n    In a normal GDB session this is reported as:\\n        Exception occurred: context: maximum recursion depth exceeded while calling a Python object (<class \\'RecursionError\\'>)\\n    '\n    gdb.execute(f'file {BINARY_ISSUE_1565}')\n    gdb.execute('break thread_function')\n    gdb.execute('run')\n    gdb.execute('next')\n    gdb.execute('context')",
            "def test_vmmap_issue_1565(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    https://github.com/pwndbg/pwndbg/issues/1565\\n\\n    In tests this bug is reported as:\\n    >       gdb.execute(\"context\")\\n    E       gdb.error: Error occurred in Python: maximum recursion depth exceeded in comparison\\n\\n    In a normal GDB session this is reported as:\\n        Exception occurred: context: maximum recursion depth exceeded while calling a Python object (<class \\'RecursionError\\'>)\\n    '\n    gdb.execute(f'file {BINARY_ISSUE_1565}')\n    gdb.execute('break thread_function')\n    gdb.execute('run')\n    gdb.execute('next')\n    gdb.execute('context')",
            "def test_vmmap_issue_1565(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    https://github.com/pwndbg/pwndbg/issues/1565\\n\\n    In tests this bug is reported as:\\n    >       gdb.execute(\"context\")\\n    E       gdb.error: Error occurred in Python: maximum recursion depth exceeded in comparison\\n\\n    In a normal GDB session this is reported as:\\n        Exception occurred: context: maximum recursion depth exceeded while calling a Python object (<class \\'RecursionError\\'>)\\n    '\n    gdb.execute(f'file {BINARY_ISSUE_1565}')\n    gdb.execute('break thread_function')\n    gdb.execute('run')\n    gdb.execute('next')\n    gdb.execute('context')",
            "def test_vmmap_issue_1565(start_binary):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    https://github.com/pwndbg/pwndbg/issues/1565\\n\\n    In tests this bug is reported as:\\n    >       gdb.execute(\"context\")\\n    E       gdb.error: Error occurred in Python: maximum recursion depth exceeded in comparison\\n\\n    In a normal GDB session this is reported as:\\n        Exception occurred: context: maximum recursion depth exceeded while calling a Python object (<class \\'RecursionError\\'>)\\n    '\n    gdb.execute(f'file {BINARY_ISSUE_1565}')\n    gdb.execute('break thread_function')\n    gdb.execute('run')\n    gdb.execute('next')\n    gdb.execute('context')"
        ]
    }
]