[
    {
        "func_name": "mutual_weight",
        "original": "@nx._dispatch(edge_attrs='weight')\ndef mutual_weight(G, u, v, weight=None):\n    \"\"\"Returns the sum of the weights of the edge from `u` to `v` and\n    the edge from `v` to `u` in `G`.\n\n    `weight` is the edge data key that represents the edge weight. If\n    the specified key is `None` or is not in the edge data for an edge,\n    that edge is assumed to have weight 1.\n\n    Pre-conditions: `u` and `v` must both be in `G`.\n\n    \"\"\"\n    try:\n        a_uv = G[u][v].get(weight, 1)\n    except KeyError:\n        a_uv = 0\n    try:\n        a_vu = G[v][u].get(weight, 1)\n    except KeyError:\n        a_vu = 0\n    return a_uv + a_vu",
        "mutated": [
            "@nx._dispatch(edge_attrs='weight')\ndef mutual_weight(G, u, v, weight=None):\n    if False:\n        i = 10\n    'Returns the sum of the weights of the edge from `u` to `v` and\\n    the edge from `v` to `u` in `G`.\\n\\n    `weight` is the edge data key that represents the edge weight. If\\n    the specified key is `None` or is not in the edge data for an edge,\\n    that edge is assumed to have weight 1.\\n\\n    Pre-conditions: `u` and `v` must both be in `G`.\\n\\n    '\n    try:\n        a_uv = G[u][v].get(weight, 1)\n    except KeyError:\n        a_uv = 0\n    try:\n        a_vu = G[v][u].get(weight, 1)\n    except KeyError:\n        a_vu = 0\n    return a_uv + a_vu",
            "@nx._dispatch(edge_attrs='weight')\ndef mutual_weight(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the sum of the weights of the edge from `u` to `v` and\\n    the edge from `v` to `u` in `G`.\\n\\n    `weight` is the edge data key that represents the edge weight. If\\n    the specified key is `None` or is not in the edge data for an edge,\\n    that edge is assumed to have weight 1.\\n\\n    Pre-conditions: `u` and `v` must both be in `G`.\\n\\n    '\n    try:\n        a_uv = G[u][v].get(weight, 1)\n    except KeyError:\n        a_uv = 0\n    try:\n        a_vu = G[v][u].get(weight, 1)\n    except KeyError:\n        a_vu = 0\n    return a_uv + a_vu",
            "@nx._dispatch(edge_attrs='weight')\ndef mutual_weight(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the sum of the weights of the edge from `u` to `v` and\\n    the edge from `v` to `u` in `G`.\\n\\n    `weight` is the edge data key that represents the edge weight. If\\n    the specified key is `None` or is not in the edge data for an edge,\\n    that edge is assumed to have weight 1.\\n\\n    Pre-conditions: `u` and `v` must both be in `G`.\\n\\n    '\n    try:\n        a_uv = G[u][v].get(weight, 1)\n    except KeyError:\n        a_uv = 0\n    try:\n        a_vu = G[v][u].get(weight, 1)\n    except KeyError:\n        a_vu = 0\n    return a_uv + a_vu",
            "@nx._dispatch(edge_attrs='weight')\ndef mutual_weight(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the sum of the weights of the edge from `u` to `v` and\\n    the edge from `v` to `u` in `G`.\\n\\n    `weight` is the edge data key that represents the edge weight. If\\n    the specified key is `None` or is not in the edge data for an edge,\\n    that edge is assumed to have weight 1.\\n\\n    Pre-conditions: `u` and `v` must both be in `G`.\\n\\n    '\n    try:\n        a_uv = G[u][v].get(weight, 1)\n    except KeyError:\n        a_uv = 0\n    try:\n        a_vu = G[v][u].get(weight, 1)\n    except KeyError:\n        a_vu = 0\n    return a_uv + a_vu",
            "@nx._dispatch(edge_attrs='weight')\ndef mutual_weight(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the sum of the weights of the edge from `u` to `v` and\\n    the edge from `v` to `u` in `G`.\\n\\n    `weight` is the edge data key that represents the edge weight. If\\n    the specified key is `None` or is not in the edge data for an edge,\\n    that edge is assumed to have weight 1.\\n\\n    Pre-conditions: `u` and `v` must both be in `G`.\\n\\n    '\n    try:\n        a_uv = G[u][v].get(weight, 1)\n    except KeyError:\n        a_uv = 0\n    try:\n        a_vu = G[v][u].get(weight, 1)\n    except KeyError:\n        a_vu = 0\n    return a_uv + a_vu"
        ]
    },
    {
        "func_name": "normalized_mutual_weight",
        "original": "@nx._dispatch(edge_attrs='weight')\ndef normalized_mutual_weight(G, u, v, norm=sum, weight=None):\n    \"\"\"Returns normalized mutual weight of the edges from `u` to `v`\n    with respect to the mutual weights of the neighbors of `u` in `G`.\n\n    `norm` specifies how the normalization factor is computed. It must\n    be a function that takes a single argument and returns a number.\n    The argument will be an iterable of mutual weights\n    of pairs ``(u, w)``, where ``w`` ranges over each (in- and\n    out-)neighbor of ``u``. Commons values for `normalization` are\n    ``sum`` and ``max``.\n\n    `weight` can be ``None`` or a string, if None, all edge weights\n    are considered equal. Otherwise holds the name of the edge\n    attribute used as weight.\n\n    \"\"\"\n    scale = norm((mutual_weight(G, u, w, weight) for w in set(nx.all_neighbors(G, u))))\n    return 0 if scale == 0 else mutual_weight(G, u, v, weight) / scale",
        "mutated": [
            "@nx._dispatch(edge_attrs='weight')\ndef normalized_mutual_weight(G, u, v, norm=sum, weight=None):\n    if False:\n        i = 10\n    'Returns normalized mutual weight of the edges from `u` to `v`\\n    with respect to the mutual weights of the neighbors of `u` in `G`.\\n\\n    `norm` specifies how the normalization factor is computed. It must\\n    be a function that takes a single argument and returns a number.\\n    The argument will be an iterable of mutual weights\\n    of pairs ``(u, w)``, where ``w`` ranges over each (in- and\\n    out-)neighbor of ``u``. Commons values for `normalization` are\\n    ``sum`` and ``max``.\\n\\n    `weight` can be ``None`` or a string, if None, all edge weights\\n    are considered equal. Otherwise holds the name of the edge\\n    attribute used as weight.\\n\\n    '\n    scale = norm((mutual_weight(G, u, w, weight) for w in set(nx.all_neighbors(G, u))))\n    return 0 if scale == 0 else mutual_weight(G, u, v, weight) / scale",
            "@nx._dispatch(edge_attrs='weight')\ndef normalized_mutual_weight(G, u, v, norm=sum, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns normalized mutual weight of the edges from `u` to `v`\\n    with respect to the mutual weights of the neighbors of `u` in `G`.\\n\\n    `norm` specifies how the normalization factor is computed. It must\\n    be a function that takes a single argument and returns a number.\\n    The argument will be an iterable of mutual weights\\n    of pairs ``(u, w)``, where ``w`` ranges over each (in- and\\n    out-)neighbor of ``u``. Commons values for `normalization` are\\n    ``sum`` and ``max``.\\n\\n    `weight` can be ``None`` or a string, if None, all edge weights\\n    are considered equal. Otherwise holds the name of the edge\\n    attribute used as weight.\\n\\n    '\n    scale = norm((mutual_weight(G, u, w, weight) for w in set(nx.all_neighbors(G, u))))\n    return 0 if scale == 0 else mutual_weight(G, u, v, weight) / scale",
            "@nx._dispatch(edge_attrs='weight')\ndef normalized_mutual_weight(G, u, v, norm=sum, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns normalized mutual weight of the edges from `u` to `v`\\n    with respect to the mutual weights of the neighbors of `u` in `G`.\\n\\n    `norm` specifies how the normalization factor is computed. It must\\n    be a function that takes a single argument and returns a number.\\n    The argument will be an iterable of mutual weights\\n    of pairs ``(u, w)``, where ``w`` ranges over each (in- and\\n    out-)neighbor of ``u``. Commons values for `normalization` are\\n    ``sum`` and ``max``.\\n\\n    `weight` can be ``None`` or a string, if None, all edge weights\\n    are considered equal. Otherwise holds the name of the edge\\n    attribute used as weight.\\n\\n    '\n    scale = norm((mutual_weight(G, u, w, weight) for w in set(nx.all_neighbors(G, u))))\n    return 0 if scale == 0 else mutual_weight(G, u, v, weight) / scale",
            "@nx._dispatch(edge_attrs='weight')\ndef normalized_mutual_weight(G, u, v, norm=sum, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns normalized mutual weight of the edges from `u` to `v`\\n    with respect to the mutual weights of the neighbors of `u` in `G`.\\n\\n    `norm` specifies how the normalization factor is computed. It must\\n    be a function that takes a single argument and returns a number.\\n    The argument will be an iterable of mutual weights\\n    of pairs ``(u, w)``, where ``w`` ranges over each (in- and\\n    out-)neighbor of ``u``. Commons values for `normalization` are\\n    ``sum`` and ``max``.\\n\\n    `weight` can be ``None`` or a string, if None, all edge weights\\n    are considered equal. Otherwise holds the name of the edge\\n    attribute used as weight.\\n\\n    '\n    scale = norm((mutual_weight(G, u, w, weight) for w in set(nx.all_neighbors(G, u))))\n    return 0 if scale == 0 else mutual_weight(G, u, v, weight) / scale",
            "@nx._dispatch(edge_attrs='weight')\ndef normalized_mutual_weight(G, u, v, norm=sum, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns normalized mutual weight of the edges from `u` to `v`\\n    with respect to the mutual weights of the neighbors of `u` in `G`.\\n\\n    `norm` specifies how the normalization factor is computed. It must\\n    be a function that takes a single argument and returns a number.\\n    The argument will be an iterable of mutual weights\\n    of pairs ``(u, w)``, where ``w`` ranges over each (in- and\\n    out-)neighbor of ``u``. Commons values for `normalization` are\\n    ``sum`` and ``max``.\\n\\n    `weight` can be ``None`` or a string, if None, all edge weights\\n    are considered equal. Otherwise holds the name of the edge\\n    attribute used as weight.\\n\\n    '\n    scale = norm((mutual_weight(G, u, w, weight) for w in set(nx.all_neighbors(G, u))))\n    return 0 if scale == 0 else mutual_weight(G, u, v, weight) / scale"
        ]
    },
    {
        "func_name": "redundancy",
        "original": "def redundancy(G, u, v, weight=None):\n    nmw = normalized_mutual_weight\n    r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return 1 - r",
        "mutated": [
            "def redundancy(G, u, v, weight=None):\n    if False:\n        i = 10\n    nmw = normalized_mutual_weight\n    r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return 1 - r",
            "def redundancy(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    nmw = normalized_mutual_weight\n    r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return 1 - r",
            "def redundancy(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    nmw = normalized_mutual_weight\n    r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return 1 - r",
            "def redundancy(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    nmw = normalized_mutual_weight\n    r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return 1 - r",
            "def redundancy(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    nmw = normalized_mutual_weight\n    r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return 1 - r"
        ]
    },
    {
        "func_name": "effective_size",
        "original": "@nx._dispatch(edge_attrs='weight')\ndef effective_size(G, nodes=None, weight=None):\n    \"\"\"Returns the effective size of all nodes in the graph ``G``.\n\n    The *effective size* of a node's ego network is based on the concept\n    of redundancy. A person's ego network has redundancy to the extent\n    that her contacts are connected to each other as well. The\n    nonredundant part of a person's relationships is the effective\n    size of her ego network [1]_.  Formally, the effective size of a\n    node $u$, denoted $e(u)$, is defined by\n\n    .. math::\n\n       e(u) = \\\\sum_{v \\\\in N(u) \\\\setminus \\\\{u\\\\}}\n       \\\\left(1 - \\\\sum_{w \\\\in N(v)} p_{uw} m_{vw}\\\\right)\n\n    where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the\n    normalized mutual weight of the (directed or undirected) edges\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. And $m_{vw}$\n    is the mutual weight of $v$ and $w$ divided by $v$ highest mutual\n    weight with any of its neighbors. The *mutual weight* of $u$ and $v$\n    is the sum of the weights of edges joining them (edge weights are\n    assumed to be one if the graph is unweighted).\n\n    For the case of unweighted and undirected graphs, Borgatti proposed\n    a simplified formula to compute effective size [2]_\n\n    .. math::\n\n       e(u) = n - \\\\frac{2t}{n}\n\n    where `t` is the number of ties in the ego network (not including\n    ties to ego) and `n` is the number of nodes (excluding ego).\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        The graph containing ``v``. Directed graphs are treated like\n        undirected graphs when computing neighbors of ``v``.\n\n    nodes : container, optional\n        Container of nodes in the graph ``G`` to compute the effective size.\n        If None, the effective size of every node is computed.\n\n    weight : None or string, optional\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n\n    Returns\n    -------\n    dict\n        Dictionary with nodes as keys and the effective size of the node as values.\n\n    Notes\n    -----\n    Burt also defined the related concept of *efficiency* of a node's ego\n    network, which is its effective size divided by the degree of that\n    node [1]_. So you can easily compute efficiency:\n\n    >>> G = nx.DiGraph()\n    >>> G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])\n    >>> esize = nx.effective_size(G)\n    >>> efficiency = {n: v / G.degree(n) for n, v in esize.items()}\n\n    See also\n    --------\n    constraint\n\n    References\n    ----------\n    .. [1] Burt, Ronald S.\n           *Structural Holes: The Social Structure of Competition.*\n           Cambridge: Harvard University Press, 1995.\n\n    .. [2] Borgatti, S.\n           \"Structural Holes: Unpacking Burt's Redundancy Measures\"\n           CONNECTIONS 20(1):35-38.\n           http://www.analytictech.com/connections/v20(1)/holes.htm\n\n    \"\"\"\n\n    def redundancy(G, u, v, weight=None):\n        nmw = normalized_mutual_weight\n        r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n        return 1 - r\n    effective_size = {}\n    if nodes is None:\n        nodes = G\n    if not G.is_directed() and weight is None:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            E = nx.ego_graph(G, v, center=False, undirected=True)\n            effective_size[v] = len(E) - 2 * E.size() / len(E)\n    else:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            effective_size[v] = sum((redundancy(G, v, u, weight) for u in set(nx.all_neighbors(G, v))))\n    return effective_size",
        "mutated": [
            "@nx._dispatch(edge_attrs='weight')\ndef effective_size(G, nodes=None, weight=None):\n    if False:\n        i = 10\n    'Returns the effective size of all nodes in the graph ``G``.\\n\\n    The *effective size* of a node\\'s ego network is based on the concept\\n    of redundancy. A person\\'s ego network has redundancy to the extent\\n    that her contacts are connected to each other as well. The\\n    nonredundant part of a person\\'s relationships is the effective\\n    size of her ego network [1]_.  Formally, the effective size of a\\n    node $u$, denoted $e(u)$, is defined by\\n\\n    .. math::\\n\\n       e(u) = \\\\sum_{v \\\\in N(u) \\\\setminus \\\\{u\\\\}}\\n       \\\\left(1 - \\\\sum_{w \\\\in N(v)} p_{uw} m_{vw}\\\\right)\\n\\n    where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. And $m_{vw}$\\n    is the mutual weight of $v$ and $w$ divided by $v$ highest mutual\\n    weight with any of its neighbors. The *mutual weight* of $u$ and $v$\\n    is the sum of the weights of edges joining them (edge weights are\\n    assumed to be one if the graph is unweighted).\\n\\n    For the case of unweighted and undirected graphs, Borgatti proposed\\n    a simplified formula to compute effective size [2]_\\n\\n    .. math::\\n\\n       e(u) = n - \\\\frac{2t}{n}\\n\\n    where `t` is the number of ties in the ego network (not including\\n    ties to ego) and `n` is the number of nodes (excluding ego).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. Directed graphs are treated like\\n        undirected graphs when computing neighbors of ``v``.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the effective size.\\n        If None, the effective size of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the effective size of the node as values.\\n\\n    Notes\\n    -----\\n    Burt also defined the related concept of *efficiency* of a node\\'s ego\\n    network, which is its effective size divided by the degree of that\\n    node [1]_. So you can easily compute efficiency:\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])\\n    >>> esize = nx.effective_size(G)\\n    >>> efficiency = {n: v / G.degree(n) for n, v in esize.items()}\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           *Structural Holes: The Social Structure of Competition.*\\n           Cambridge: Harvard University Press, 1995.\\n\\n    .. [2] Borgatti, S.\\n           \"Structural Holes: Unpacking Burt\\'s Redundancy Measures\"\\n           CONNECTIONS 20(1):35-38.\\n           http://www.analytictech.com/connections/v20(1)/holes.htm\\n\\n    '\n\n    def redundancy(G, u, v, weight=None):\n        nmw = normalized_mutual_weight\n        r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n        return 1 - r\n    effective_size = {}\n    if nodes is None:\n        nodes = G\n    if not G.is_directed() and weight is None:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            E = nx.ego_graph(G, v, center=False, undirected=True)\n            effective_size[v] = len(E) - 2 * E.size() / len(E)\n    else:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            effective_size[v] = sum((redundancy(G, v, u, weight) for u in set(nx.all_neighbors(G, v))))\n    return effective_size",
            "@nx._dispatch(edge_attrs='weight')\ndef effective_size(G, nodes=None, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the effective size of all nodes in the graph ``G``.\\n\\n    The *effective size* of a node\\'s ego network is based on the concept\\n    of redundancy. A person\\'s ego network has redundancy to the extent\\n    that her contacts are connected to each other as well. The\\n    nonredundant part of a person\\'s relationships is the effective\\n    size of her ego network [1]_.  Formally, the effective size of a\\n    node $u$, denoted $e(u)$, is defined by\\n\\n    .. math::\\n\\n       e(u) = \\\\sum_{v \\\\in N(u) \\\\setminus \\\\{u\\\\}}\\n       \\\\left(1 - \\\\sum_{w \\\\in N(v)} p_{uw} m_{vw}\\\\right)\\n\\n    where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. And $m_{vw}$\\n    is the mutual weight of $v$ and $w$ divided by $v$ highest mutual\\n    weight with any of its neighbors. The *mutual weight* of $u$ and $v$\\n    is the sum of the weights of edges joining them (edge weights are\\n    assumed to be one if the graph is unweighted).\\n\\n    For the case of unweighted and undirected graphs, Borgatti proposed\\n    a simplified formula to compute effective size [2]_\\n\\n    .. math::\\n\\n       e(u) = n - \\\\frac{2t}{n}\\n\\n    where `t` is the number of ties in the ego network (not including\\n    ties to ego) and `n` is the number of nodes (excluding ego).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. Directed graphs are treated like\\n        undirected graphs when computing neighbors of ``v``.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the effective size.\\n        If None, the effective size of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the effective size of the node as values.\\n\\n    Notes\\n    -----\\n    Burt also defined the related concept of *efficiency* of a node\\'s ego\\n    network, which is its effective size divided by the degree of that\\n    node [1]_. So you can easily compute efficiency:\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])\\n    >>> esize = nx.effective_size(G)\\n    >>> efficiency = {n: v / G.degree(n) for n, v in esize.items()}\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           *Structural Holes: The Social Structure of Competition.*\\n           Cambridge: Harvard University Press, 1995.\\n\\n    .. [2] Borgatti, S.\\n           \"Structural Holes: Unpacking Burt\\'s Redundancy Measures\"\\n           CONNECTIONS 20(1):35-38.\\n           http://www.analytictech.com/connections/v20(1)/holes.htm\\n\\n    '\n\n    def redundancy(G, u, v, weight=None):\n        nmw = normalized_mutual_weight\n        r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n        return 1 - r\n    effective_size = {}\n    if nodes is None:\n        nodes = G\n    if not G.is_directed() and weight is None:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            E = nx.ego_graph(G, v, center=False, undirected=True)\n            effective_size[v] = len(E) - 2 * E.size() / len(E)\n    else:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            effective_size[v] = sum((redundancy(G, v, u, weight) for u in set(nx.all_neighbors(G, v))))\n    return effective_size",
            "@nx._dispatch(edge_attrs='weight')\ndef effective_size(G, nodes=None, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the effective size of all nodes in the graph ``G``.\\n\\n    The *effective size* of a node\\'s ego network is based on the concept\\n    of redundancy. A person\\'s ego network has redundancy to the extent\\n    that her contacts are connected to each other as well. The\\n    nonredundant part of a person\\'s relationships is the effective\\n    size of her ego network [1]_.  Formally, the effective size of a\\n    node $u$, denoted $e(u)$, is defined by\\n\\n    .. math::\\n\\n       e(u) = \\\\sum_{v \\\\in N(u) \\\\setminus \\\\{u\\\\}}\\n       \\\\left(1 - \\\\sum_{w \\\\in N(v)} p_{uw} m_{vw}\\\\right)\\n\\n    where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. And $m_{vw}$\\n    is the mutual weight of $v$ and $w$ divided by $v$ highest mutual\\n    weight with any of its neighbors. The *mutual weight* of $u$ and $v$\\n    is the sum of the weights of edges joining them (edge weights are\\n    assumed to be one if the graph is unweighted).\\n\\n    For the case of unweighted and undirected graphs, Borgatti proposed\\n    a simplified formula to compute effective size [2]_\\n\\n    .. math::\\n\\n       e(u) = n - \\\\frac{2t}{n}\\n\\n    where `t` is the number of ties in the ego network (not including\\n    ties to ego) and `n` is the number of nodes (excluding ego).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. Directed graphs are treated like\\n        undirected graphs when computing neighbors of ``v``.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the effective size.\\n        If None, the effective size of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the effective size of the node as values.\\n\\n    Notes\\n    -----\\n    Burt also defined the related concept of *efficiency* of a node\\'s ego\\n    network, which is its effective size divided by the degree of that\\n    node [1]_. So you can easily compute efficiency:\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])\\n    >>> esize = nx.effective_size(G)\\n    >>> efficiency = {n: v / G.degree(n) for n, v in esize.items()}\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           *Structural Holes: The Social Structure of Competition.*\\n           Cambridge: Harvard University Press, 1995.\\n\\n    .. [2] Borgatti, S.\\n           \"Structural Holes: Unpacking Burt\\'s Redundancy Measures\"\\n           CONNECTIONS 20(1):35-38.\\n           http://www.analytictech.com/connections/v20(1)/holes.htm\\n\\n    '\n\n    def redundancy(G, u, v, weight=None):\n        nmw = normalized_mutual_weight\n        r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n        return 1 - r\n    effective_size = {}\n    if nodes is None:\n        nodes = G\n    if not G.is_directed() and weight is None:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            E = nx.ego_graph(G, v, center=False, undirected=True)\n            effective_size[v] = len(E) - 2 * E.size() / len(E)\n    else:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            effective_size[v] = sum((redundancy(G, v, u, weight) for u in set(nx.all_neighbors(G, v))))\n    return effective_size",
            "@nx._dispatch(edge_attrs='weight')\ndef effective_size(G, nodes=None, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the effective size of all nodes in the graph ``G``.\\n\\n    The *effective size* of a node\\'s ego network is based on the concept\\n    of redundancy. A person\\'s ego network has redundancy to the extent\\n    that her contacts are connected to each other as well. The\\n    nonredundant part of a person\\'s relationships is the effective\\n    size of her ego network [1]_.  Formally, the effective size of a\\n    node $u$, denoted $e(u)$, is defined by\\n\\n    .. math::\\n\\n       e(u) = \\\\sum_{v \\\\in N(u) \\\\setminus \\\\{u\\\\}}\\n       \\\\left(1 - \\\\sum_{w \\\\in N(v)} p_{uw} m_{vw}\\\\right)\\n\\n    where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. And $m_{vw}$\\n    is the mutual weight of $v$ and $w$ divided by $v$ highest mutual\\n    weight with any of its neighbors. The *mutual weight* of $u$ and $v$\\n    is the sum of the weights of edges joining them (edge weights are\\n    assumed to be one if the graph is unweighted).\\n\\n    For the case of unweighted and undirected graphs, Borgatti proposed\\n    a simplified formula to compute effective size [2]_\\n\\n    .. math::\\n\\n       e(u) = n - \\\\frac{2t}{n}\\n\\n    where `t` is the number of ties in the ego network (not including\\n    ties to ego) and `n` is the number of nodes (excluding ego).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. Directed graphs are treated like\\n        undirected graphs when computing neighbors of ``v``.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the effective size.\\n        If None, the effective size of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the effective size of the node as values.\\n\\n    Notes\\n    -----\\n    Burt also defined the related concept of *efficiency* of a node\\'s ego\\n    network, which is its effective size divided by the degree of that\\n    node [1]_. So you can easily compute efficiency:\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])\\n    >>> esize = nx.effective_size(G)\\n    >>> efficiency = {n: v / G.degree(n) for n, v in esize.items()}\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           *Structural Holes: The Social Structure of Competition.*\\n           Cambridge: Harvard University Press, 1995.\\n\\n    .. [2] Borgatti, S.\\n           \"Structural Holes: Unpacking Burt\\'s Redundancy Measures\"\\n           CONNECTIONS 20(1):35-38.\\n           http://www.analytictech.com/connections/v20(1)/holes.htm\\n\\n    '\n\n    def redundancy(G, u, v, weight=None):\n        nmw = normalized_mutual_weight\n        r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n        return 1 - r\n    effective_size = {}\n    if nodes is None:\n        nodes = G\n    if not G.is_directed() and weight is None:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            E = nx.ego_graph(G, v, center=False, undirected=True)\n            effective_size[v] = len(E) - 2 * E.size() / len(E)\n    else:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            effective_size[v] = sum((redundancy(G, v, u, weight) for u in set(nx.all_neighbors(G, v))))\n    return effective_size",
            "@nx._dispatch(edge_attrs='weight')\ndef effective_size(G, nodes=None, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the effective size of all nodes in the graph ``G``.\\n\\n    The *effective size* of a node\\'s ego network is based on the concept\\n    of redundancy. A person\\'s ego network has redundancy to the extent\\n    that her contacts are connected to each other as well. The\\n    nonredundant part of a person\\'s relationships is the effective\\n    size of her ego network [1]_.  Formally, the effective size of a\\n    node $u$, denoted $e(u)$, is defined by\\n\\n    .. math::\\n\\n       e(u) = \\\\sum_{v \\\\in N(u) \\\\setminus \\\\{u\\\\}}\\n       \\\\left(1 - \\\\sum_{w \\\\in N(v)} p_{uw} m_{vw}\\\\right)\\n\\n    where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. And $m_{vw}$\\n    is the mutual weight of $v$ and $w$ divided by $v$ highest mutual\\n    weight with any of its neighbors. The *mutual weight* of $u$ and $v$\\n    is the sum of the weights of edges joining them (edge weights are\\n    assumed to be one if the graph is unweighted).\\n\\n    For the case of unweighted and undirected graphs, Borgatti proposed\\n    a simplified formula to compute effective size [2]_\\n\\n    .. math::\\n\\n       e(u) = n - \\\\frac{2t}{n}\\n\\n    where `t` is the number of ties in the ego network (not including\\n    ties to ego) and `n` is the number of nodes (excluding ego).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. Directed graphs are treated like\\n        undirected graphs when computing neighbors of ``v``.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the effective size.\\n        If None, the effective size of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the effective size of the node as values.\\n\\n    Notes\\n    -----\\n    Burt also defined the related concept of *efficiency* of a node\\'s ego\\n    network, which is its effective size divided by the degree of that\\n    node [1]_. So you can easily compute efficiency:\\n\\n    >>> G = nx.DiGraph()\\n    >>> G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])\\n    >>> esize = nx.effective_size(G)\\n    >>> efficiency = {n: v / G.degree(n) for n, v in esize.items()}\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           *Structural Holes: The Social Structure of Competition.*\\n           Cambridge: Harvard University Press, 1995.\\n\\n    .. [2] Borgatti, S.\\n           \"Structural Holes: Unpacking Burt\\'s Redundancy Measures\"\\n           CONNECTIONS 20(1):35-38.\\n           http://www.analytictech.com/connections/v20(1)/holes.htm\\n\\n    '\n\n    def redundancy(G, u, v, weight=None):\n        nmw = normalized_mutual_weight\n        r = sum((nmw(G, u, w, weight=weight) * nmw(G, v, w, norm=max, weight=weight) for w in set(nx.all_neighbors(G, u))))\n        return 1 - r\n    effective_size = {}\n    if nodes is None:\n        nodes = G\n    if not G.is_directed() and weight is None:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            E = nx.ego_graph(G, v, center=False, undirected=True)\n            effective_size[v] = len(E) - 2 * E.size() / len(E)\n    else:\n        for v in nodes:\n            if len(G[v]) == 0:\n                effective_size[v] = float('nan')\n                continue\n            effective_size[v] = sum((redundancy(G, v, u, weight) for u in set(nx.all_neighbors(G, v))))\n    return effective_size"
        ]
    },
    {
        "func_name": "constraint",
        "original": "@nx._dispatch(edge_attrs='weight')\ndef constraint(G, nodes=None, weight=None):\n    \"\"\"Returns the constraint on all nodes in the graph ``G``.\n\n    The *constraint* is a measure of the extent to which a node *v* is\n    invested in those nodes that are themselves invested in the\n    neighbors of *v*. Formally, the *constraint on v*, denoted `c(v)`,\n    is defined by\n\n    .. math::\n\n       c(v) = \\\\sum_{w \\\\in N(v) \\\\setminus \\\\{v\\\\}} \\\\ell(v, w)\n\n    where $N(v)$ is the subset of the neighbors of `v` that are either\n    predecessors or successors of `v` and $\\\\ell(v, w)$ is the local\n    constraint on `v` with respect to `w` [1]_. For the definition of local\n    constraint, see :func:`local_constraint`.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        The graph containing ``v``. This can be either directed or undirected.\n\n    nodes : container, optional\n        Container of nodes in the graph ``G`` to compute the constraint. If\n        None, the constraint of every node is computed.\n\n    weight : None or string, optional\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n\n    Returns\n    -------\n    dict\n        Dictionary with nodes as keys and the constraint on the node as values.\n\n    See also\n    --------\n    local_constraint\n\n    References\n    ----------\n    .. [1] Burt, Ronald S.\n           \"Structural holes and good ideas\".\n           American Journal of Sociology (110): 349\u2013399.\n\n    \"\"\"\n    if nodes is None:\n        nodes = G\n    constraint = {}\n    for v in nodes:\n        if len(G[v]) == 0:\n            constraint[v] = float('nan')\n            continue\n        constraint[v] = sum((local_constraint(G, v, n, weight) for n in set(nx.all_neighbors(G, v))))\n    return constraint",
        "mutated": [
            "@nx._dispatch(edge_attrs='weight')\ndef constraint(G, nodes=None, weight=None):\n    if False:\n        i = 10\n    'Returns the constraint on all nodes in the graph ``G``.\\n\\n    The *constraint* is a measure of the extent to which a node *v* is\\n    invested in those nodes that are themselves invested in the\\n    neighbors of *v*. Formally, the *constraint on v*, denoted `c(v)`,\\n    is defined by\\n\\n    .. math::\\n\\n       c(v) = \\\\sum_{w \\\\in N(v) \\\\setminus \\\\{v\\\\}} \\\\ell(v, w)\\n\\n    where $N(v)$ is the subset of the neighbors of `v` that are either\\n    predecessors or successors of `v` and $\\\\ell(v, w)$ is the local\\n    constraint on `v` with respect to `w` [1]_. For the definition of local\\n    constraint, see :func:`local_constraint`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. This can be either directed or undirected.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the constraint. If\\n        None, the constraint of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the constraint on the node as values.\\n\\n    See also\\n    --------\\n    local_constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    if nodes is None:\n        nodes = G\n    constraint = {}\n    for v in nodes:\n        if len(G[v]) == 0:\n            constraint[v] = float('nan')\n            continue\n        constraint[v] = sum((local_constraint(G, v, n, weight) for n in set(nx.all_neighbors(G, v))))\n    return constraint",
            "@nx._dispatch(edge_attrs='weight')\ndef constraint(G, nodes=None, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the constraint on all nodes in the graph ``G``.\\n\\n    The *constraint* is a measure of the extent to which a node *v* is\\n    invested in those nodes that are themselves invested in the\\n    neighbors of *v*. Formally, the *constraint on v*, denoted `c(v)`,\\n    is defined by\\n\\n    .. math::\\n\\n       c(v) = \\\\sum_{w \\\\in N(v) \\\\setminus \\\\{v\\\\}} \\\\ell(v, w)\\n\\n    where $N(v)$ is the subset of the neighbors of `v` that are either\\n    predecessors or successors of `v` and $\\\\ell(v, w)$ is the local\\n    constraint on `v` with respect to `w` [1]_. For the definition of local\\n    constraint, see :func:`local_constraint`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. This can be either directed or undirected.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the constraint. If\\n        None, the constraint of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the constraint on the node as values.\\n\\n    See also\\n    --------\\n    local_constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    if nodes is None:\n        nodes = G\n    constraint = {}\n    for v in nodes:\n        if len(G[v]) == 0:\n            constraint[v] = float('nan')\n            continue\n        constraint[v] = sum((local_constraint(G, v, n, weight) for n in set(nx.all_neighbors(G, v))))\n    return constraint",
            "@nx._dispatch(edge_attrs='weight')\ndef constraint(G, nodes=None, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the constraint on all nodes in the graph ``G``.\\n\\n    The *constraint* is a measure of the extent to which a node *v* is\\n    invested in those nodes that are themselves invested in the\\n    neighbors of *v*. Formally, the *constraint on v*, denoted `c(v)`,\\n    is defined by\\n\\n    .. math::\\n\\n       c(v) = \\\\sum_{w \\\\in N(v) \\\\setminus \\\\{v\\\\}} \\\\ell(v, w)\\n\\n    where $N(v)$ is the subset of the neighbors of `v` that are either\\n    predecessors or successors of `v` and $\\\\ell(v, w)$ is the local\\n    constraint on `v` with respect to `w` [1]_. For the definition of local\\n    constraint, see :func:`local_constraint`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. This can be either directed or undirected.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the constraint. If\\n        None, the constraint of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the constraint on the node as values.\\n\\n    See also\\n    --------\\n    local_constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    if nodes is None:\n        nodes = G\n    constraint = {}\n    for v in nodes:\n        if len(G[v]) == 0:\n            constraint[v] = float('nan')\n            continue\n        constraint[v] = sum((local_constraint(G, v, n, weight) for n in set(nx.all_neighbors(G, v))))\n    return constraint",
            "@nx._dispatch(edge_attrs='weight')\ndef constraint(G, nodes=None, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the constraint on all nodes in the graph ``G``.\\n\\n    The *constraint* is a measure of the extent to which a node *v* is\\n    invested in those nodes that are themselves invested in the\\n    neighbors of *v*. Formally, the *constraint on v*, denoted `c(v)`,\\n    is defined by\\n\\n    .. math::\\n\\n       c(v) = \\\\sum_{w \\\\in N(v) \\\\setminus \\\\{v\\\\}} \\\\ell(v, w)\\n\\n    where $N(v)$ is the subset of the neighbors of `v` that are either\\n    predecessors or successors of `v` and $\\\\ell(v, w)$ is the local\\n    constraint on `v` with respect to `w` [1]_. For the definition of local\\n    constraint, see :func:`local_constraint`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. This can be either directed or undirected.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the constraint. If\\n        None, the constraint of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the constraint on the node as values.\\n\\n    See also\\n    --------\\n    local_constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    if nodes is None:\n        nodes = G\n    constraint = {}\n    for v in nodes:\n        if len(G[v]) == 0:\n            constraint[v] = float('nan')\n            continue\n        constraint[v] = sum((local_constraint(G, v, n, weight) for n in set(nx.all_neighbors(G, v))))\n    return constraint",
            "@nx._dispatch(edge_attrs='weight')\ndef constraint(G, nodes=None, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the constraint on all nodes in the graph ``G``.\\n\\n    The *constraint* is a measure of the extent to which a node *v* is\\n    invested in those nodes that are themselves invested in the\\n    neighbors of *v*. Formally, the *constraint on v*, denoted `c(v)`,\\n    is defined by\\n\\n    .. math::\\n\\n       c(v) = \\\\sum_{w \\\\in N(v) \\\\setminus \\\\{v\\\\}} \\\\ell(v, w)\\n\\n    where $N(v)$ is the subset of the neighbors of `v` that are either\\n    predecessors or successors of `v` and $\\\\ell(v, w)$ is the local\\n    constraint on `v` with respect to `w` [1]_. For the definition of local\\n    constraint, see :func:`local_constraint`.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``v``. This can be either directed or undirected.\\n\\n    nodes : container, optional\\n        Container of nodes in the graph ``G`` to compute the constraint. If\\n        None, the constraint of every node is computed.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    dict\\n        Dictionary with nodes as keys and the constraint on the node as values.\\n\\n    See also\\n    --------\\n    local_constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    if nodes is None:\n        nodes = G\n    constraint = {}\n    for v in nodes:\n        if len(G[v]) == 0:\n            constraint[v] = float('nan')\n            continue\n        constraint[v] = sum((local_constraint(G, v, n, weight) for n in set(nx.all_neighbors(G, v))))\n    return constraint"
        ]
    },
    {
        "func_name": "local_constraint",
        "original": "@nx._dispatch(edge_attrs='weight')\ndef local_constraint(G, u, v, weight=None):\n    \"\"\"Returns the local constraint on the node ``u`` with respect to\n    the node ``v`` in the graph ``G``.\n\n    Formally, the *local constraint on u with respect to v*, denoted\n    $\\\\ell(v)$, is defined by\n\n    .. math::\n\n       \\\\ell(u, v) = \\\\left(p_{uv} + \\\\sum_{w \\\\in N(v)} p_{uw} p_{wv}\\\\right)^2,\n\n    where $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the\n    normalized mutual weight of the (directed or undirected) edges\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. The *mutual\n    weight* of $u$ and $v$ is the sum of the weights of edges joining\n    them (edge weights are assumed to be one if the graph is\n    unweighted).\n\n    Parameters\n    ----------\n    G : NetworkX graph\n        The graph containing ``u`` and ``v``. This can be either\n        directed or undirected.\n\n    u : node\n        A node in the graph ``G``.\n\n    v : node\n        A node in the graph ``G``.\n\n    weight : None or string, optional\n      If None, all edge weights are considered equal.\n      Otherwise holds the name of the edge attribute used as weight.\n\n    Returns\n    -------\n    float\n        The constraint of the node ``v`` in the graph ``G``.\n\n    See also\n    --------\n    constraint\n\n    References\n    ----------\n    .. [1] Burt, Ronald S.\n           \"Structural holes and good ideas\".\n           American Journal of Sociology (110): 349\u2013399.\n\n    \"\"\"\n    nmw = normalized_mutual_weight\n    direct = nmw(G, u, v, weight=weight)\n    indirect = sum((nmw(G, u, w, weight=weight) * nmw(G, w, v, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return (direct + indirect) ** 2",
        "mutated": [
            "@nx._dispatch(edge_attrs='weight')\ndef local_constraint(G, u, v, weight=None):\n    if False:\n        i = 10\n    'Returns the local constraint on the node ``u`` with respect to\\n    the node ``v`` in the graph ``G``.\\n\\n    Formally, the *local constraint on u with respect to v*, denoted\\n    $\\\\ell(v)$, is defined by\\n\\n    .. math::\\n\\n       \\\\ell(u, v) = \\\\left(p_{uv} + \\\\sum_{w \\\\in N(v)} p_{uw} p_{wv}\\\\right)^2,\\n\\n    where $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. The *mutual\\n    weight* of $u$ and $v$ is the sum of the weights of edges joining\\n    them (edge weights are assumed to be one if the graph is\\n    unweighted).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``u`` and ``v``. This can be either\\n        directed or undirected.\\n\\n    u : node\\n        A node in the graph ``G``.\\n\\n    v : node\\n        A node in the graph ``G``.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    float\\n        The constraint of the node ``v`` in the graph ``G``.\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    nmw = normalized_mutual_weight\n    direct = nmw(G, u, v, weight=weight)\n    indirect = sum((nmw(G, u, w, weight=weight) * nmw(G, w, v, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return (direct + indirect) ** 2",
            "@nx._dispatch(edge_attrs='weight')\ndef local_constraint(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the local constraint on the node ``u`` with respect to\\n    the node ``v`` in the graph ``G``.\\n\\n    Formally, the *local constraint on u with respect to v*, denoted\\n    $\\\\ell(v)$, is defined by\\n\\n    .. math::\\n\\n       \\\\ell(u, v) = \\\\left(p_{uv} + \\\\sum_{w \\\\in N(v)} p_{uw} p_{wv}\\\\right)^2,\\n\\n    where $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. The *mutual\\n    weight* of $u$ and $v$ is the sum of the weights of edges joining\\n    them (edge weights are assumed to be one if the graph is\\n    unweighted).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``u`` and ``v``. This can be either\\n        directed or undirected.\\n\\n    u : node\\n        A node in the graph ``G``.\\n\\n    v : node\\n        A node in the graph ``G``.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    float\\n        The constraint of the node ``v`` in the graph ``G``.\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    nmw = normalized_mutual_weight\n    direct = nmw(G, u, v, weight=weight)\n    indirect = sum((nmw(G, u, w, weight=weight) * nmw(G, w, v, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return (direct + indirect) ** 2",
            "@nx._dispatch(edge_attrs='weight')\ndef local_constraint(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the local constraint on the node ``u`` with respect to\\n    the node ``v`` in the graph ``G``.\\n\\n    Formally, the *local constraint on u with respect to v*, denoted\\n    $\\\\ell(v)$, is defined by\\n\\n    .. math::\\n\\n       \\\\ell(u, v) = \\\\left(p_{uv} + \\\\sum_{w \\\\in N(v)} p_{uw} p_{wv}\\\\right)^2,\\n\\n    where $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. The *mutual\\n    weight* of $u$ and $v$ is the sum of the weights of edges joining\\n    them (edge weights are assumed to be one if the graph is\\n    unweighted).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``u`` and ``v``. This can be either\\n        directed or undirected.\\n\\n    u : node\\n        A node in the graph ``G``.\\n\\n    v : node\\n        A node in the graph ``G``.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    float\\n        The constraint of the node ``v`` in the graph ``G``.\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    nmw = normalized_mutual_weight\n    direct = nmw(G, u, v, weight=weight)\n    indirect = sum((nmw(G, u, w, weight=weight) * nmw(G, w, v, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return (direct + indirect) ** 2",
            "@nx._dispatch(edge_attrs='weight')\ndef local_constraint(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the local constraint on the node ``u`` with respect to\\n    the node ``v`` in the graph ``G``.\\n\\n    Formally, the *local constraint on u with respect to v*, denoted\\n    $\\\\ell(v)$, is defined by\\n\\n    .. math::\\n\\n       \\\\ell(u, v) = \\\\left(p_{uv} + \\\\sum_{w \\\\in N(v)} p_{uw} p_{wv}\\\\right)^2,\\n\\n    where $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. The *mutual\\n    weight* of $u$ and $v$ is the sum of the weights of edges joining\\n    them (edge weights are assumed to be one if the graph is\\n    unweighted).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``u`` and ``v``. This can be either\\n        directed or undirected.\\n\\n    u : node\\n        A node in the graph ``G``.\\n\\n    v : node\\n        A node in the graph ``G``.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    float\\n        The constraint of the node ``v`` in the graph ``G``.\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    nmw = normalized_mutual_weight\n    direct = nmw(G, u, v, weight=weight)\n    indirect = sum((nmw(G, u, w, weight=weight) * nmw(G, w, v, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return (direct + indirect) ** 2",
            "@nx._dispatch(edge_attrs='weight')\ndef local_constraint(G, u, v, weight=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the local constraint on the node ``u`` with respect to\\n    the node ``v`` in the graph ``G``.\\n\\n    Formally, the *local constraint on u with respect to v*, denoted\\n    $\\\\ell(v)$, is defined by\\n\\n    .. math::\\n\\n       \\\\ell(u, v) = \\\\left(p_{uv} + \\\\sum_{w \\\\in N(v)} p_{uw} p_{wv}\\\\right)^2,\\n\\n    where $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the\\n    normalized mutual weight of the (directed or undirected) edges\\n    joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. The *mutual\\n    weight* of $u$ and $v$ is the sum of the weights of edges joining\\n    them (edge weights are assumed to be one if the graph is\\n    unweighted).\\n\\n    Parameters\\n    ----------\\n    G : NetworkX graph\\n        The graph containing ``u`` and ``v``. This can be either\\n        directed or undirected.\\n\\n    u : node\\n        A node in the graph ``G``.\\n\\n    v : node\\n        A node in the graph ``G``.\\n\\n    weight : None or string, optional\\n      If None, all edge weights are considered equal.\\n      Otherwise holds the name of the edge attribute used as weight.\\n\\n    Returns\\n    -------\\n    float\\n        The constraint of the node ``v`` in the graph ``G``.\\n\\n    See also\\n    --------\\n    constraint\\n\\n    References\\n    ----------\\n    .. [1] Burt, Ronald S.\\n           \"Structural holes and good ideas\".\\n           American Journal of Sociology (110): 349\u2013399.\\n\\n    '\n    nmw = normalized_mutual_weight\n    direct = nmw(G, u, v, weight=weight)\n    indirect = sum((nmw(G, u, w, weight=weight) * nmw(G, w, v, weight=weight) for w in set(nx.all_neighbors(G, u))))\n    return (direct + indirect) ** 2"
        ]
    }
]