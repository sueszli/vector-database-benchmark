[
    {
        "func_name": "_design_resample_poly",
        "original": "def _design_resample_poly(up, down, window):\n    \"\"\"\n    Design a prototype FIR low-pass filter using the window method\n    for use in polyphase rational resampling.\n\n    Parameters\n    ----------\n    up : int\n        The upsampling factor.\n    down : int\n        The downsampling factor.\n    window : string or tuple\n        Desired window to use to design the low-pass filter.\n        See below for details.\n\n    Returns\n    -------\n    h : array\n        The computed FIR filter coefficients.\n\n    See Also\n    --------\n    resample_poly : Resample up or down using the polyphase method.\n\n    Notes\n    -----\n    The argument `window` specifies the FIR low-pass filter design.\n    The functions `cusignal.get_window` and `cusignal.firwin`\n    are called to generate the appropriate filter coefficients.\n\n    The returned array of coefficients will always be of data type\n    `complex128` to maintain precision. For use in lower-precision\n    filter operations, this array should be converted to the desired\n    data type before providing it to `cusignal.resample_poly`.\n\n    \"\"\"\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    max_rate = max(up, down)\n    f_c = 1.0 / max_rate\n    half_len = 10 * max_rate\n    h = firwin(2 * half_len + 1, f_c, window=window)\n    return h",
        "mutated": [
            "def _design_resample_poly(up, down, window):\n    if False:\n        i = 10\n    '\\n    Design a prototype FIR low-pass filter using the window method\\n    for use in polyphase rational resampling.\\n\\n    Parameters\\n    ----------\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    window : string or tuple\\n        Desired window to use to design the low-pass filter.\\n        See below for details.\\n\\n    Returns\\n    -------\\n    h : array\\n        The computed FIR filter coefficients.\\n\\n    See Also\\n    --------\\n    resample_poly : Resample up or down using the polyphase method.\\n\\n    Notes\\n    -----\\n    The argument `window` specifies the FIR low-pass filter design.\\n    The functions `cusignal.get_window` and `cusignal.firwin`\\n    are called to generate the appropriate filter coefficients.\\n\\n    The returned array of coefficients will always be of data type\\n    `complex128` to maintain precision. For use in lower-precision\\n    filter operations, this array should be converted to the desired\\n    data type before providing it to `cusignal.resample_poly`.\\n\\n    '\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    max_rate = max(up, down)\n    f_c = 1.0 / max_rate\n    half_len = 10 * max_rate\n    h = firwin(2 * half_len + 1, f_c, window=window)\n    return h",
            "def _design_resample_poly(up, down, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Design a prototype FIR low-pass filter using the window method\\n    for use in polyphase rational resampling.\\n\\n    Parameters\\n    ----------\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    window : string or tuple\\n        Desired window to use to design the low-pass filter.\\n        See below for details.\\n\\n    Returns\\n    -------\\n    h : array\\n        The computed FIR filter coefficients.\\n\\n    See Also\\n    --------\\n    resample_poly : Resample up or down using the polyphase method.\\n\\n    Notes\\n    -----\\n    The argument `window` specifies the FIR low-pass filter design.\\n    The functions `cusignal.get_window` and `cusignal.firwin`\\n    are called to generate the appropriate filter coefficients.\\n\\n    The returned array of coefficients will always be of data type\\n    `complex128` to maintain precision. For use in lower-precision\\n    filter operations, this array should be converted to the desired\\n    data type before providing it to `cusignal.resample_poly`.\\n\\n    '\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    max_rate = max(up, down)\n    f_c = 1.0 / max_rate\n    half_len = 10 * max_rate\n    h = firwin(2 * half_len + 1, f_c, window=window)\n    return h",
            "def _design_resample_poly(up, down, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Design a prototype FIR low-pass filter using the window method\\n    for use in polyphase rational resampling.\\n\\n    Parameters\\n    ----------\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    window : string or tuple\\n        Desired window to use to design the low-pass filter.\\n        See below for details.\\n\\n    Returns\\n    -------\\n    h : array\\n        The computed FIR filter coefficients.\\n\\n    See Also\\n    --------\\n    resample_poly : Resample up or down using the polyphase method.\\n\\n    Notes\\n    -----\\n    The argument `window` specifies the FIR low-pass filter design.\\n    The functions `cusignal.get_window` and `cusignal.firwin`\\n    are called to generate the appropriate filter coefficients.\\n\\n    The returned array of coefficients will always be of data type\\n    `complex128` to maintain precision. For use in lower-precision\\n    filter operations, this array should be converted to the desired\\n    data type before providing it to `cusignal.resample_poly`.\\n\\n    '\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    max_rate = max(up, down)\n    f_c = 1.0 / max_rate\n    half_len = 10 * max_rate\n    h = firwin(2 * half_len + 1, f_c, window=window)\n    return h",
            "def _design_resample_poly(up, down, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Design a prototype FIR low-pass filter using the window method\\n    for use in polyphase rational resampling.\\n\\n    Parameters\\n    ----------\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    window : string or tuple\\n        Desired window to use to design the low-pass filter.\\n        See below for details.\\n\\n    Returns\\n    -------\\n    h : array\\n        The computed FIR filter coefficients.\\n\\n    See Also\\n    --------\\n    resample_poly : Resample up or down using the polyphase method.\\n\\n    Notes\\n    -----\\n    The argument `window` specifies the FIR low-pass filter design.\\n    The functions `cusignal.get_window` and `cusignal.firwin`\\n    are called to generate the appropriate filter coefficients.\\n\\n    The returned array of coefficients will always be of data type\\n    `complex128` to maintain precision. For use in lower-precision\\n    filter operations, this array should be converted to the desired\\n    data type before providing it to `cusignal.resample_poly`.\\n\\n    '\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    max_rate = max(up, down)\n    f_c = 1.0 / max_rate\n    half_len = 10 * max_rate\n    h = firwin(2 * half_len + 1, f_c, window=window)\n    return h",
            "def _design_resample_poly(up, down, window):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Design a prototype FIR low-pass filter using the window method\\n    for use in polyphase rational resampling.\\n\\n    Parameters\\n    ----------\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    window : string or tuple\\n        Desired window to use to design the low-pass filter.\\n        See below for details.\\n\\n    Returns\\n    -------\\n    h : array\\n        The computed FIR filter coefficients.\\n\\n    See Also\\n    --------\\n    resample_poly : Resample up or down using the polyphase method.\\n\\n    Notes\\n    -----\\n    The argument `window` specifies the FIR low-pass filter design.\\n    The functions `cusignal.get_window` and `cusignal.firwin`\\n    are called to generate the appropriate filter coefficients.\\n\\n    The returned array of coefficients will always be of data type\\n    `complex128` to maintain precision. For use in lower-precision\\n    filter operations, this array should be converted to the desired\\n    data type before providing it to `cusignal.resample_poly`.\\n\\n    '\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    max_rate = max(up, down)\n    f_c = 1.0 / max_rate\n    half_len = 10 * max_rate\n    h = firwin(2 * half_len + 1, f_c, window=window)\n    return h"
        ]
    },
    {
        "func_name": "decimate",
        "original": "def decimate(x, q, n=None, ftype='iir', axis=-1, zero_phase=True):\n    \"\"\"\n    Downsample the signal after applying an anti-aliasing filter.\n\n    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR\n    filter with Hamming window is used if `ftype` is 'fir'.\n\n    Parameters\n    ----------\n    x : array_like\n        The signal to be downsampled, as an N-dimensional array.\n    q : int\n        The downsampling factor. When using IIR downsampling, it is recommended\n        to call `decimate` multiple times for downsampling factors higher than\n        13.\n    n : int, optional\n        The order of the filter (1 less than the length for 'fir'). Defaults to\n        8 for 'iir' and 20 times the downsampling factor for 'fir'.\n    ftype : str {'iir', 'fir'} or ``dlti`` instance, optional\n        If 'iir' or 'fir', specifies the type of lowpass filter. If an instance\n        of an `dlti` object, uses that object to filter before downsampling.\n    axis : int, optional\n        The axis along which to decimate.\n    zero_phase : bool, optional\n        Prevent phase shift by filtering with `filtfilt` instead of `lfilter`\n        when using an IIR filter, and shifting the outputs back by the filter's\n        group delay when using an FIR filter. The default value of ``True`` is\n        recommended, since a phase shift is generally not desired.\n\n    Returns\n    -------\n    y : ndarray\n        The down-sampled signal.\n\n    See Also\n    --------\n    resample : Resample up or down using the FFT method.\n    resample_poly : Resample using polyphase filtering and an FIR filter.\n    \"\"\"\n    x = cupy.asarray(x)\n    q = operator.index(q)\n    if n is not None:\n        n = operator.index(n)\n    result_type = x.dtype\n    if not cupy.issubdtype(result_type, cupy.inexact) or result_type.type == cupy.float16:\n        result_type = cupy.float64\n    if ftype == 'fir':\n        if n is None:\n            half_len = 10 * q\n            n = 2 * half_len\n        (b, a) = (firwin(n + 1, 1.0 / q, window='hamming'), 1.0)\n        b = cupy.asarray(b, dtype=result_type)\n        a = cupy.asarray(a, dtype=result_type)\n    elif ftype == 'iir':\n        iir_use_sos = True\n        if n is None:\n            n = 8\n        sos = cheby1(n, 0.05, 0.8 / q, output='sos')\n        sos = cupy.asarray(sos, dtype=result_type)\n    elif isinstance(ftype, dlti):\n        system = ftype._as_zpk()\n        if system.poles.shape[0] == 0:\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n            ftype = 'fir'\n        elif any(cupy.iscomplex(system.poles)) or any(cupy.iscomplex(system.poles)) or cupy.iscomplex(system.gain):\n            iir_use_sos = False\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n        else:\n            iir_use_sos = True\n            sos = zpk2sos(system.zeros, system.poles, system.gain)\n            sos = cupy.asarray(sos, dtype=result_type)\n    else:\n        raise ValueError('invalid ftype')\n    sl = [slice(None)] * x.ndim\n    if ftype == 'fir':\n        b = b / a\n        if zero_phase:\n            y = resample_poly(x, 1, q, axis=axis, window=b)\n        else:\n            n_out = x.shape[axis] // q + bool(x.shape[axis] % q)\n            y = upfirdn(b, x, up=1, down=q, axis=axis)\n            sl[axis] = slice(None, n_out, None)\n    else:\n        if zero_phase:\n            if iir_use_sos:\n                y = sosfiltfilt(sos, x, axis=axis)\n            else:\n                y = filtfilt(b, a, x, axis=axis)\n        elif iir_use_sos:\n            y = sosfilt(sos, x, axis=axis)\n        else:\n            y = lfilter(b, a, x, axis=axis)\n        sl[axis] = slice(None, None, q)\n    return y[tuple(sl)]",
        "mutated": [
            "def decimate(x, q, n=None, ftype='iir', axis=-1, zero_phase=True):\n    if False:\n        i = 10\n    \"\\n    Downsample the signal after applying an anti-aliasing filter.\\n\\n    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR\\n    filter with Hamming window is used if `ftype` is 'fir'.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The signal to be downsampled, as an N-dimensional array.\\n    q : int\\n        The downsampling factor. When using IIR downsampling, it is recommended\\n        to call `decimate` multiple times for downsampling factors higher than\\n        13.\\n    n : int, optional\\n        The order of the filter (1 less than the length for 'fir'). Defaults to\\n        8 for 'iir' and 20 times the downsampling factor for 'fir'.\\n    ftype : str {'iir', 'fir'} or ``dlti`` instance, optional\\n        If 'iir' or 'fir', specifies the type of lowpass filter. If an instance\\n        of an `dlti` object, uses that object to filter before downsampling.\\n    axis : int, optional\\n        The axis along which to decimate.\\n    zero_phase : bool, optional\\n        Prevent phase shift by filtering with `filtfilt` instead of `lfilter`\\n        when using an IIR filter, and shifting the outputs back by the filter's\\n        group delay when using an FIR filter. The default value of ``True`` is\\n        recommended, since a phase shift is generally not desired.\\n\\n    Returns\\n    -------\\n    y : ndarray\\n        The down-sampled signal.\\n\\n    See Also\\n    --------\\n    resample : Resample up or down using the FFT method.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n    \"\n    x = cupy.asarray(x)\n    q = operator.index(q)\n    if n is not None:\n        n = operator.index(n)\n    result_type = x.dtype\n    if not cupy.issubdtype(result_type, cupy.inexact) or result_type.type == cupy.float16:\n        result_type = cupy.float64\n    if ftype == 'fir':\n        if n is None:\n            half_len = 10 * q\n            n = 2 * half_len\n        (b, a) = (firwin(n + 1, 1.0 / q, window='hamming'), 1.0)\n        b = cupy.asarray(b, dtype=result_type)\n        a = cupy.asarray(a, dtype=result_type)\n    elif ftype == 'iir':\n        iir_use_sos = True\n        if n is None:\n            n = 8\n        sos = cheby1(n, 0.05, 0.8 / q, output='sos')\n        sos = cupy.asarray(sos, dtype=result_type)\n    elif isinstance(ftype, dlti):\n        system = ftype._as_zpk()\n        if system.poles.shape[0] == 0:\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n            ftype = 'fir'\n        elif any(cupy.iscomplex(system.poles)) or any(cupy.iscomplex(system.poles)) or cupy.iscomplex(system.gain):\n            iir_use_sos = False\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n        else:\n            iir_use_sos = True\n            sos = zpk2sos(system.zeros, system.poles, system.gain)\n            sos = cupy.asarray(sos, dtype=result_type)\n    else:\n        raise ValueError('invalid ftype')\n    sl = [slice(None)] * x.ndim\n    if ftype == 'fir':\n        b = b / a\n        if zero_phase:\n            y = resample_poly(x, 1, q, axis=axis, window=b)\n        else:\n            n_out = x.shape[axis] // q + bool(x.shape[axis] % q)\n            y = upfirdn(b, x, up=1, down=q, axis=axis)\n            sl[axis] = slice(None, n_out, None)\n    else:\n        if zero_phase:\n            if iir_use_sos:\n                y = sosfiltfilt(sos, x, axis=axis)\n            else:\n                y = filtfilt(b, a, x, axis=axis)\n        elif iir_use_sos:\n            y = sosfilt(sos, x, axis=axis)\n        else:\n            y = lfilter(b, a, x, axis=axis)\n        sl[axis] = slice(None, None, q)\n    return y[tuple(sl)]",
            "def decimate(x, q, n=None, ftype='iir', axis=-1, zero_phase=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Downsample the signal after applying an anti-aliasing filter.\\n\\n    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR\\n    filter with Hamming window is used if `ftype` is 'fir'.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The signal to be downsampled, as an N-dimensional array.\\n    q : int\\n        The downsampling factor. When using IIR downsampling, it is recommended\\n        to call `decimate` multiple times for downsampling factors higher than\\n        13.\\n    n : int, optional\\n        The order of the filter (1 less than the length for 'fir'). Defaults to\\n        8 for 'iir' and 20 times the downsampling factor for 'fir'.\\n    ftype : str {'iir', 'fir'} or ``dlti`` instance, optional\\n        If 'iir' or 'fir', specifies the type of lowpass filter. If an instance\\n        of an `dlti` object, uses that object to filter before downsampling.\\n    axis : int, optional\\n        The axis along which to decimate.\\n    zero_phase : bool, optional\\n        Prevent phase shift by filtering with `filtfilt` instead of `lfilter`\\n        when using an IIR filter, and shifting the outputs back by the filter's\\n        group delay when using an FIR filter. The default value of ``True`` is\\n        recommended, since a phase shift is generally not desired.\\n\\n    Returns\\n    -------\\n    y : ndarray\\n        The down-sampled signal.\\n\\n    See Also\\n    --------\\n    resample : Resample up or down using the FFT method.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n    \"\n    x = cupy.asarray(x)\n    q = operator.index(q)\n    if n is not None:\n        n = operator.index(n)\n    result_type = x.dtype\n    if not cupy.issubdtype(result_type, cupy.inexact) or result_type.type == cupy.float16:\n        result_type = cupy.float64\n    if ftype == 'fir':\n        if n is None:\n            half_len = 10 * q\n            n = 2 * half_len\n        (b, a) = (firwin(n + 1, 1.0 / q, window='hamming'), 1.0)\n        b = cupy.asarray(b, dtype=result_type)\n        a = cupy.asarray(a, dtype=result_type)\n    elif ftype == 'iir':\n        iir_use_sos = True\n        if n is None:\n            n = 8\n        sos = cheby1(n, 0.05, 0.8 / q, output='sos')\n        sos = cupy.asarray(sos, dtype=result_type)\n    elif isinstance(ftype, dlti):\n        system = ftype._as_zpk()\n        if system.poles.shape[0] == 0:\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n            ftype = 'fir'\n        elif any(cupy.iscomplex(system.poles)) or any(cupy.iscomplex(system.poles)) or cupy.iscomplex(system.gain):\n            iir_use_sos = False\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n        else:\n            iir_use_sos = True\n            sos = zpk2sos(system.zeros, system.poles, system.gain)\n            sos = cupy.asarray(sos, dtype=result_type)\n    else:\n        raise ValueError('invalid ftype')\n    sl = [slice(None)] * x.ndim\n    if ftype == 'fir':\n        b = b / a\n        if zero_phase:\n            y = resample_poly(x, 1, q, axis=axis, window=b)\n        else:\n            n_out = x.shape[axis] // q + bool(x.shape[axis] % q)\n            y = upfirdn(b, x, up=1, down=q, axis=axis)\n            sl[axis] = slice(None, n_out, None)\n    else:\n        if zero_phase:\n            if iir_use_sos:\n                y = sosfiltfilt(sos, x, axis=axis)\n            else:\n                y = filtfilt(b, a, x, axis=axis)\n        elif iir_use_sos:\n            y = sosfilt(sos, x, axis=axis)\n        else:\n            y = lfilter(b, a, x, axis=axis)\n        sl[axis] = slice(None, None, q)\n    return y[tuple(sl)]",
            "def decimate(x, q, n=None, ftype='iir', axis=-1, zero_phase=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Downsample the signal after applying an anti-aliasing filter.\\n\\n    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR\\n    filter with Hamming window is used if `ftype` is 'fir'.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The signal to be downsampled, as an N-dimensional array.\\n    q : int\\n        The downsampling factor. When using IIR downsampling, it is recommended\\n        to call `decimate` multiple times for downsampling factors higher than\\n        13.\\n    n : int, optional\\n        The order of the filter (1 less than the length for 'fir'). Defaults to\\n        8 for 'iir' and 20 times the downsampling factor for 'fir'.\\n    ftype : str {'iir', 'fir'} or ``dlti`` instance, optional\\n        If 'iir' or 'fir', specifies the type of lowpass filter. If an instance\\n        of an `dlti` object, uses that object to filter before downsampling.\\n    axis : int, optional\\n        The axis along which to decimate.\\n    zero_phase : bool, optional\\n        Prevent phase shift by filtering with `filtfilt` instead of `lfilter`\\n        when using an IIR filter, and shifting the outputs back by the filter's\\n        group delay when using an FIR filter. The default value of ``True`` is\\n        recommended, since a phase shift is generally not desired.\\n\\n    Returns\\n    -------\\n    y : ndarray\\n        The down-sampled signal.\\n\\n    See Also\\n    --------\\n    resample : Resample up or down using the FFT method.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n    \"\n    x = cupy.asarray(x)\n    q = operator.index(q)\n    if n is not None:\n        n = operator.index(n)\n    result_type = x.dtype\n    if not cupy.issubdtype(result_type, cupy.inexact) or result_type.type == cupy.float16:\n        result_type = cupy.float64\n    if ftype == 'fir':\n        if n is None:\n            half_len = 10 * q\n            n = 2 * half_len\n        (b, a) = (firwin(n + 1, 1.0 / q, window='hamming'), 1.0)\n        b = cupy.asarray(b, dtype=result_type)\n        a = cupy.asarray(a, dtype=result_type)\n    elif ftype == 'iir':\n        iir_use_sos = True\n        if n is None:\n            n = 8\n        sos = cheby1(n, 0.05, 0.8 / q, output='sos')\n        sos = cupy.asarray(sos, dtype=result_type)\n    elif isinstance(ftype, dlti):\n        system = ftype._as_zpk()\n        if system.poles.shape[0] == 0:\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n            ftype = 'fir'\n        elif any(cupy.iscomplex(system.poles)) or any(cupy.iscomplex(system.poles)) or cupy.iscomplex(system.gain):\n            iir_use_sos = False\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n        else:\n            iir_use_sos = True\n            sos = zpk2sos(system.zeros, system.poles, system.gain)\n            sos = cupy.asarray(sos, dtype=result_type)\n    else:\n        raise ValueError('invalid ftype')\n    sl = [slice(None)] * x.ndim\n    if ftype == 'fir':\n        b = b / a\n        if zero_phase:\n            y = resample_poly(x, 1, q, axis=axis, window=b)\n        else:\n            n_out = x.shape[axis] // q + bool(x.shape[axis] % q)\n            y = upfirdn(b, x, up=1, down=q, axis=axis)\n            sl[axis] = slice(None, n_out, None)\n    else:\n        if zero_phase:\n            if iir_use_sos:\n                y = sosfiltfilt(sos, x, axis=axis)\n            else:\n                y = filtfilt(b, a, x, axis=axis)\n        elif iir_use_sos:\n            y = sosfilt(sos, x, axis=axis)\n        else:\n            y = lfilter(b, a, x, axis=axis)\n        sl[axis] = slice(None, None, q)\n    return y[tuple(sl)]",
            "def decimate(x, q, n=None, ftype='iir', axis=-1, zero_phase=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Downsample the signal after applying an anti-aliasing filter.\\n\\n    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR\\n    filter with Hamming window is used if `ftype` is 'fir'.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The signal to be downsampled, as an N-dimensional array.\\n    q : int\\n        The downsampling factor. When using IIR downsampling, it is recommended\\n        to call `decimate` multiple times for downsampling factors higher than\\n        13.\\n    n : int, optional\\n        The order of the filter (1 less than the length for 'fir'). Defaults to\\n        8 for 'iir' and 20 times the downsampling factor for 'fir'.\\n    ftype : str {'iir', 'fir'} or ``dlti`` instance, optional\\n        If 'iir' or 'fir', specifies the type of lowpass filter. If an instance\\n        of an `dlti` object, uses that object to filter before downsampling.\\n    axis : int, optional\\n        The axis along which to decimate.\\n    zero_phase : bool, optional\\n        Prevent phase shift by filtering with `filtfilt` instead of `lfilter`\\n        when using an IIR filter, and shifting the outputs back by the filter's\\n        group delay when using an FIR filter. The default value of ``True`` is\\n        recommended, since a phase shift is generally not desired.\\n\\n    Returns\\n    -------\\n    y : ndarray\\n        The down-sampled signal.\\n\\n    See Also\\n    --------\\n    resample : Resample up or down using the FFT method.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n    \"\n    x = cupy.asarray(x)\n    q = operator.index(q)\n    if n is not None:\n        n = operator.index(n)\n    result_type = x.dtype\n    if not cupy.issubdtype(result_type, cupy.inexact) or result_type.type == cupy.float16:\n        result_type = cupy.float64\n    if ftype == 'fir':\n        if n is None:\n            half_len = 10 * q\n            n = 2 * half_len\n        (b, a) = (firwin(n + 1, 1.0 / q, window='hamming'), 1.0)\n        b = cupy.asarray(b, dtype=result_type)\n        a = cupy.asarray(a, dtype=result_type)\n    elif ftype == 'iir':\n        iir_use_sos = True\n        if n is None:\n            n = 8\n        sos = cheby1(n, 0.05, 0.8 / q, output='sos')\n        sos = cupy.asarray(sos, dtype=result_type)\n    elif isinstance(ftype, dlti):\n        system = ftype._as_zpk()\n        if system.poles.shape[0] == 0:\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n            ftype = 'fir'\n        elif any(cupy.iscomplex(system.poles)) or any(cupy.iscomplex(system.poles)) or cupy.iscomplex(system.gain):\n            iir_use_sos = False\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n        else:\n            iir_use_sos = True\n            sos = zpk2sos(system.zeros, system.poles, system.gain)\n            sos = cupy.asarray(sos, dtype=result_type)\n    else:\n        raise ValueError('invalid ftype')\n    sl = [slice(None)] * x.ndim\n    if ftype == 'fir':\n        b = b / a\n        if zero_phase:\n            y = resample_poly(x, 1, q, axis=axis, window=b)\n        else:\n            n_out = x.shape[axis] // q + bool(x.shape[axis] % q)\n            y = upfirdn(b, x, up=1, down=q, axis=axis)\n            sl[axis] = slice(None, n_out, None)\n    else:\n        if zero_phase:\n            if iir_use_sos:\n                y = sosfiltfilt(sos, x, axis=axis)\n            else:\n                y = filtfilt(b, a, x, axis=axis)\n        elif iir_use_sos:\n            y = sosfilt(sos, x, axis=axis)\n        else:\n            y = lfilter(b, a, x, axis=axis)\n        sl[axis] = slice(None, None, q)\n    return y[tuple(sl)]",
            "def decimate(x, q, n=None, ftype='iir', axis=-1, zero_phase=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Downsample the signal after applying an anti-aliasing filter.\\n\\n    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR\\n    filter with Hamming window is used if `ftype` is 'fir'.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The signal to be downsampled, as an N-dimensional array.\\n    q : int\\n        The downsampling factor. When using IIR downsampling, it is recommended\\n        to call `decimate` multiple times for downsampling factors higher than\\n        13.\\n    n : int, optional\\n        The order of the filter (1 less than the length for 'fir'). Defaults to\\n        8 for 'iir' and 20 times the downsampling factor for 'fir'.\\n    ftype : str {'iir', 'fir'} or ``dlti`` instance, optional\\n        If 'iir' or 'fir', specifies the type of lowpass filter. If an instance\\n        of an `dlti` object, uses that object to filter before downsampling.\\n    axis : int, optional\\n        The axis along which to decimate.\\n    zero_phase : bool, optional\\n        Prevent phase shift by filtering with `filtfilt` instead of `lfilter`\\n        when using an IIR filter, and shifting the outputs back by the filter's\\n        group delay when using an FIR filter. The default value of ``True`` is\\n        recommended, since a phase shift is generally not desired.\\n\\n    Returns\\n    -------\\n    y : ndarray\\n        The down-sampled signal.\\n\\n    See Also\\n    --------\\n    resample : Resample up or down using the FFT method.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n    \"\n    x = cupy.asarray(x)\n    q = operator.index(q)\n    if n is not None:\n        n = operator.index(n)\n    result_type = x.dtype\n    if not cupy.issubdtype(result_type, cupy.inexact) or result_type.type == cupy.float16:\n        result_type = cupy.float64\n    if ftype == 'fir':\n        if n is None:\n            half_len = 10 * q\n            n = 2 * half_len\n        (b, a) = (firwin(n + 1, 1.0 / q, window='hamming'), 1.0)\n        b = cupy.asarray(b, dtype=result_type)\n        a = cupy.asarray(a, dtype=result_type)\n    elif ftype == 'iir':\n        iir_use_sos = True\n        if n is None:\n            n = 8\n        sos = cheby1(n, 0.05, 0.8 / q, output='sos')\n        sos = cupy.asarray(sos, dtype=result_type)\n    elif isinstance(ftype, dlti):\n        system = ftype._as_zpk()\n        if system.poles.shape[0] == 0:\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n            ftype = 'fir'\n        elif any(cupy.iscomplex(system.poles)) or any(cupy.iscomplex(system.poles)) or cupy.iscomplex(system.gain):\n            iir_use_sos = False\n            system = ftype._as_tf()\n            (b, a) = (system.num, system.den)\n        else:\n            iir_use_sos = True\n            sos = zpk2sos(system.zeros, system.poles, system.gain)\n            sos = cupy.asarray(sos, dtype=result_type)\n    else:\n        raise ValueError('invalid ftype')\n    sl = [slice(None)] * x.ndim\n    if ftype == 'fir':\n        b = b / a\n        if zero_phase:\n            y = resample_poly(x, 1, q, axis=axis, window=b)\n        else:\n            n_out = x.shape[axis] // q + bool(x.shape[axis] % q)\n            y = upfirdn(b, x, up=1, down=q, axis=axis)\n            sl[axis] = slice(None, n_out, None)\n    else:\n        if zero_phase:\n            if iir_use_sos:\n                y = sosfiltfilt(sos, x, axis=axis)\n            else:\n                y = filtfilt(b, a, x, axis=axis)\n        elif iir_use_sos:\n            y = sosfilt(sos, x, axis=axis)\n        else:\n            y = lfilter(b, a, x, axis=axis)\n        sl[axis] = slice(None, None, q)\n    return y[tuple(sl)]"
        ]
    },
    {
        "func_name": "resample",
        "original": "def resample(x, num, t=None, axis=0, window=None, domain='time'):\n    \"\"\"\n    Resample `x` to `num` samples using Fourier method along the given axis.\n\n    The resampled signal starts at the same value as `x` but is sampled\n    with a spacing of ``len(x) / num * (spacing of x)``.  Because a\n    Fourier method is used, the signal is assumed to be periodic.\n\n    Parameters\n    ----------\n    x : array_like\n        The data to be resampled.\n    num : int\n        The number of samples in the resampled signal.\n    t : array_like, optional\n        If `t` is given, it is assumed to be the sample positions\n        associated with the signal data in `x`.\n    axis : int, optional\n        The axis of `x` that is resampled.  Default is 0.\n    window : array_like, callable, string, float, or tuple, optional\n        Specifies the window applied to the signal in the Fourier\n        domain.  See below for details.\n    domain : string, optional\n        A string indicating the domain of the input `x`:\n\n        ``time``\n           Consider the input `x` as time-domain. (Default)\n        ``freq``\n           Consider the input `x` as frequency-domain.\n\n    Returns\n    -------\n    resampled_x or (resampled_x, resampled_t)\n        Either the resampled array, or, if `t` was given, a tuple\n        containing the resampled array and the corresponding resampled\n        positions.\n\n    See Also\n    --------\n    decimate : Downsample the signal after applying an FIR or IIR filter.\n    resample_poly : Resample using polyphase filtering and an FIR filter.\n\n    Notes\n    -----\n    The argument `window` controls a Fourier-domain window that tapers\n    the Fourier spectrum before zero-padding to alleviate ringing in\n    the resampled values for sampled signals you didn't intend to be\n    interpreted as band-limited.\n\n    If `window` is a function, then it is called with a vector of inputs\n    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).\n\n    If `window` is an array of the same length as `x.shape[axis]` it is\n    assumed to be the window to be applied directly in the Fourier\n    domain (with dc and low-frequency first).\n\n    For any other type of `window`, the function `cusignal.get_window`\n    is called to generate the window.\n\n    The first sample of the returned vector is the same as the first\n    sample of the input vector.  The spacing between samples is changed\n    from ``dx`` to ``dx * len(x) / num``.\n\n    If `t` is not None, then it represents the old sample positions,\n    and the new sample positions will be returned as well as the new\n    samples.\n\n    As noted, `resample` uses FFT transformations, which can be very\n    slow if the number of input or output samples is large and prime;\n    see `scipy.fftpack.fft`.\n\n    Examples\n    --------\n    Note that the end of the resampled data rises to meet the first\n    sample of the next cycle:\n\n    >>> import cupy as cp\n    >>> import cupyx.scipy.signal import resample\n\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\n    >>> y = cupy.cos(-x**2/6.0)\n    >>> f = resample(y, 100)\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'go-', cupy.asnumpy(xnew),                 cupy.asnumpy(f), '.-', 10, cupy.asnumpy(y[0]), 'ro')\n    >>> plt.legend(['data', 'resampled'], loc='best')\n    >>> plt.show()\n    \"\"\"\n    if domain not in ('time', 'freq'):\n        raise ValueError(\"Acceptable domain flags are 'time' or 'freq', not domain={}\".format(domain))\n    x = cupy.asarray(x)\n    Nx = x.shape[axis]\n    real_input = cupy.isrealobj(x)\n    if domain == 'time':\n        if real_input:\n            X = rfft(x, axis=axis)\n        else:\n            X = fft(x, axis=axis)\n    else:\n        X = x\n    if window is not None:\n        if callable(window):\n            W = window(fftfreq(Nx))\n        elif isinstance(window, cupy.ndarray):\n            if window.shape != (Nx,):\n                raise ValueError('window must have the same length as data')\n            W = window\n        else:\n            W = ifftshift(get_window(window, Nx))\n        newshape_W = [1] * x.ndim\n        newshape_W[axis] = X.shape[axis]\n        if real_input:\n            W_real = W.copy()\n            W_real[1:] += W_real[-1:0:-1]\n            W_real[1:] *= 0.5\n            X *= W_real[:newshape_W[axis]].reshape(newshape_W)\n        else:\n            X *= W.reshape(newshape_W)\n    newshape = list(x.shape)\n    if real_input:\n        newshape[axis] = num // 2 + 1\n    else:\n        newshape[axis] = num\n    Y = cupy.zeros(newshape, X.dtype)\n    N = min(num, Nx)\n    nyq = N // 2 + 1\n    sl = [slice(None)] * x.ndim\n    sl[axis] = slice(0, nyq)\n    Y[tuple(sl)] = X[tuple(sl)]\n    if not real_input:\n        if N > 2:\n            sl[axis] = slice(nyq - N, None)\n            Y[tuple(sl)] = X[tuple(sl)]\n    if N % 2 == 0:\n        if num < Nx:\n            if real_input:\n                sl[axis] = slice(N // 2, N // 2 + 1)\n                Y[tuple(sl)] *= 2.0\n            else:\n                sl[axis] = slice(-N // 2, -N // 2 + 1)\n                Y[tuple(sl)] += X[tuple(sl)]\n        elif Nx < num:\n            sl[axis] = slice(N // 2, N // 2 + 1)\n            Y[tuple(sl)] *= 0.5\n            if not real_input:\n                temp = Y[tuple(sl)]\n                sl[axis] = slice(num - N // 2, num - N // 2 + 1)\n                Y[tuple(sl)] = temp\n    if real_input:\n        y = irfft(Y, num, axis=axis)\n    else:\n        y = ifft(Y, axis=axis, overwrite_x=True)\n    y *= float(num) / float(Nx)\n    if t is None:\n        return y\n    else:\n        new_t = cupy.arange(0, num) * (t[1] - t[0]) * Nx / float(num) + t[0]\n        return (y, new_t)",
        "mutated": [
            "def resample(x, num, t=None, axis=0, window=None, domain='time'):\n    if False:\n        i = 10\n    \"\\n    Resample `x` to `num` samples using Fourier method along the given axis.\\n\\n    The resampled signal starts at the same value as `x` but is sampled\\n    with a spacing of ``len(x) / num * (spacing of x)``.  Because a\\n    Fourier method is used, the signal is assumed to be periodic.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    num : int\\n        The number of samples in the resampled signal.\\n    t : array_like, optional\\n        If `t` is given, it is assumed to be the sample positions\\n        associated with the signal data in `x`.\\n    axis : int, optional\\n        The axis of `x` that is resampled.  Default is 0.\\n    window : array_like, callable, string, float, or tuple, optional\\n        Specifies the window applied to the signal in the Fourier\\n        domain.  See below for details.\\n    domain : string, optional\\n        A string indicating the domain of the input `x`:\\n\\n        ``time``\\n           Consider the input `x` as time-domain. (Default)\\n        ``freq``\\n           Consider the input `x` as frequency-domain.\\n\\n    Returns\\n    -------\\n    resampled_x or (resampled_x, resampled_t)\\n        Either the resampled array, or, if `t` was given, a tuple\\n        containing the resampled array and the corresponding resampled\\n        positions.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n\\n    Notes\\n    -----\\n    The argument `window` controls a Fourier-domain window that tapers\\n    the Fourier spectrum before zero-padding to alleviate ringing in\\n    the resampled values for sampled signals you didn't intend to be\\n    interpreted as band-limited.\\n\\n    If `window` is a function, then it is called with a vector of inputs\\n    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).\\n\\n    If `window` is an array of the same length as `x.shape[axis]` it is\\n    assumed to be the window to be applied directly in the Fourier\\n    domain (with dc and low-frequency first).\\n\\n    For any other type of `window`, the function `cusignal.get_window`\\n    is called to generate the window.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector.  The spacing between samples is changed\\n    from ``dx`` to ``dx * len(x) / num``.\\n\\n    If `t` is not None, then it represents the old sample positions,\\n    and the new sample positions will be returned as well as the new\\n    samples.\\n\\n    As noted, `resample` uses FFT transformations, which can be very\\n    slow if the number of input or output samples is large and prime;\\n    see `scipy.fftpack.fft`.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle:\\n\\n    >>> import cupy as cp\\n    >>> import cupyx.scipy.signal import resample\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f = resample(y, 100)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'go-', cupy.asnumpy(xnew),                 cupy.asnumpy(f), '.-', 10, cupy.asnumpy(y[0]), 'ro')\\n    >>> plt.legend(['data', 'resampled'], loc='best')\\n    >>> plt.show()\\n    \"\n    if domain not in ('time', 'freq'):\n        raise ValueError(\"Acceptable domain flags are 'time' or 'freq', not domain={}\".format(domain))\n    x = cupy.asarray(x)\n    Nx = x.shape[axis]\n    real_input = cupy.isrealobj(x)\n    if domain == 'time':\n        if real_input:\n            X = rfft(x, axis=axis)\n        else:\n            X = fft(x, axis=axis)\n    else:\n        X = x\n    if window is not None:\n        if callable(window):\n            W = window(fftfreq(Nx))\n        elif isinstance(window, cupy.ndarray):\n            if window.shape != (Nx,):\n                raise ValueError('window must have the same length as data')\n            W = window\n        else:\n            W = ifftshift(get_window(window, Nx))\n        newshape_W = [1] * x.ndim\n        newshape_W[axis] = X.shape[axis]\n        if real_input:\n            W_real = W.copy()\n            W_real[1:] += W_real[-1:0:-1]\n            W_real[1:] *= 0.5\n            X *= W_real[:newshape_W[axis]].reshape(newshape_W)\n        else:\n            X *= W.reshape(newshape_W)\n    newshape = list(x.shape)\n    if real_input:\n        newshape[axis] = num // 2 + 1\n    else:\n        newshape[axis] = num\n    Y = cupy.zeros(newshape, X.dtype)\n    N = min(num, Nx)\n    nyq = N // 2 + 1\n    sl = [slice(None)] * x.ndim\n    sl[axis] = slice(0, nyq)\n    Y[tuple(sl)] = X[tuple(sl)]\n    if not real_input:\n        if N > 2:\n            sl[axis] = slice(nyq - N, None)\n            Y[tuple(sl)] = X[tuple(sl)]\n    if N % 2 == 0:\n        if num < Nx:\n            if real_input:\n                sl[axis] = slice(N // 2, N // 2 + 1)\n                Y[tuple(sl)] *= 2.0\n            else:\n                sl[axis] = slice(-N // 2, -N // 2 + 1)\n                Y[tuple(sl)] += X[tuple(sl)]\n        elif Nx < num:\n            sl[axis] = slice(N // 2, N // 2 + 1)\n            Y[tuple(sl)] *= 0.5\n            if not real_input:\n                temp = Y[tuple(sl)]\n                sl[axis] = slice(num - N // 2, num - N // 2 + 1)\n                Y[tuple(sl)] = temp\n    if real_input:\n        y = irfft(Y, num, axis=axis)\n    else:\n        y = ifft(Y, axis=axis, overwrite_x=True)\n    y *= float(num) / float(Nx)\n    if t is None:\n        return y\n    else:\n        new_t = cupy.arange(0, num) * (t[1] - t[0]) * Nx / float(num) + t[0]\n        return (y, new_t)",
            "def resample(x, num, t=None, axis=0, window=None, domain='time'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Resample `x` to `num` samples using Fourier method along the given axis.\\n\\n    The resampled signal starts at the same value as `x` but is sampled\\n    with a spacing of ``len(x) / num * (spacing of x)``.  Because a\\n    Fourier method is used, the signal is assumed to be periodic.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    num : int\\n        The number of samples in the resampled signal.\\n    t : array_like, optional\\n        If `t` is given, it is assumed to be the sample positions\\n        associated with the signal data in `x`.\\n    axis : int, optional\\n        The axis of `x` that is resampled.  Default is 0.\\n    window : array_like, callable, string, float, or tuple, optional\\n        Specifies the window applied to the signal in the Fourier\\n        domain.  See below for details.\\n    domain : string, optional\\n        A string indicating the domain of the input `x`:\\n\\n        ``time``\\n           Consider the input `x` as time-domain. (Default)\\n        ``freq``\\n           Consider the input `x` as frequency-domain.\\n\\n    Returns\\n    -------\\n    resampled_x or (resampled_x, resampled_t)\\n        Either the resampled array, or, if `t` was given, a tuple\\n        containing the resampled array and the corresponding resampled\\n        positions.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n\\n    Notes\\n    -----\\n    The argument `window` controls a Fourier-domain window that tapers\\n    the Fourier spectrum before zero-padding to alleviate ringing in\\n    the resampled values for sampled signals you didn't intend to be\\n    interpreted as band-limited.\\n\\n    If `window` is a function, then it is called with a vector of inputs\\n    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).\\n\\n    If `window` is an array of the same length as `x.shape[axis]` it is\\n    assumed to be the window to be applied directly in the Fourier\\n    domain (with dc and low-frequency first).\\n\\n    For any other type of `window`, the function `cusignal.get_window`\\n    is called to generate the window.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector.  The spacing between samples is changed\\n    from ``dx`` to ``dx * len(x) / num``.\\n\\n    If `t` is not None, then it represents the old sample positions,\\n    and the new sample positions will be returned as well as the new\\n    samples.\\n\\n    As noted, `resample` uses FFT transformations, which can be very\\n    slow if the number of input or output samples is large and prime;\\n    see `scipy.fftpack.fft`.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle:\\n\\n    >>> import cupy as cp\\n    >>> import cupyx.scipy.signal import resample\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f = resample(y, 100)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'go-', cupy.asnumpy(xnew),                 cupy.asnumpy(f), '.-', 10, cupy.asnumpy(y[0]), 'ro')\\n    >>> plt.legend(['data', 'resampled'], loc='best')\\n    >>> plt.show()\\n    \"\n    if domain not in ('time', 'freq'):\n        raise ValueError(\"Acceptable domain flags are 'time' or 'freq', not domain={}\".format(domain))\n    x = cupy.asarray(x)\n    Nx = x.shape[axis]\n    real_input = cupy.isrealobj(x)\n    if domain == 'time':\n        if real_input:\n            X = rfft(x, axis=axis)\n        else:\n            X = fft(x, axis=axis)\n    else:\n        X = x\n    if window is not None:\n        if callable(window):\n            W = window(fftfreq(Nx))\n        elif isinstance(window, cupy.ndarray):\n            if window.shape != (Nx,):\n                raise ValueError('window must have the same length as data')\n            W = window\n        else:\n            W = ifftshift(get_window(window, Nx))\n        newshape_W = [1] * x.ndim\n        newshape_W[axis] = X.shape[axis]\n        if real_input:\n            W_real = W.copy()\n            W_real[1:] += W_real[-1:0:-1]\n            W_real[1:] *= 0.5\n            X *= W_real[:newshape_W[axis]].reshape(newshape_W)\n        else:\n            X *= W.reshape(newshape_W)\n    newshape = list(x.shape)\n    if real_input:\n        newshape[axis] = num // 2 + 1\n    else:\n        newshape[axis] = num\n    Y = cupy.zeros(newshape, X.dtype)\n    N = min(num, Nx)\n    nyq = N // 2 + 1\n    sl = [slice(None)] * x.ndim\n    sl[axis] = slice(0, nyq)\n    Y[tuple(sl)] = X[tuple(sl)]\n    if not real_input:\n        if N > 2:\n            sl[axis] = slice(nyq - N, None)\n            Y[tuple(sl)] = X[tuple(sl)]\n    if N % 2 == 0:\n        if num < Nx:\n            if real_input:\n                sl[axis] = slice(N // 2, N // 2 + 1)\n                Y[tuple(sl)] *= 2.0\n            else:\n                sl[axis] = slice(-N // 2, -N // 2 + 1)\n                Y[tuple(sl)] += X[tuple(sl)]\n        elif Nx < num:\n            sl[axis] = slice(N // 2, N // 2 + 1)\n            Y[tuple(sl)] *= 0.5\n            if not real_input:\n                temp = Y[tuple(sl)]\n                sl[axis] = slice(num - N // 2, num - N // 2 + 1)\n                Y[tuple(sl)] = temp\n    if real_input:\n        y = irfft(Y, num, axis=axis)\n    else:\n        y = ifft(Y, axis=axis, overwrite_x=True)\n    y *= float(num) / float(Nx)\n    if t is None:\n        return y\n    else:\n        new_t = cupy.arange(0, num) * (t[1] - t[0]) * Nx / float(num) + t[0]\n        return (y, new_t)",
            "def resample(x, num, t=None, axis=0, window=None, domain='time'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Resample `x` to `num` samples using Fourier method along the given axis.\\n\\n    The resampled signal starts at the same value as `x` but is sampled\\n    with a spacing of ``len(x) / num * (spacing of x)``.  Because a\\n    Fourier method is used, the signal is assumed to be periodic.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    num : int\\n        The number of samples in the resampled signal.\\n    t : array_like, optional\\n        If `t` is given, it is assumed to be the sample positions\\n        associated with the signal data in `x`.\\n    axis : int, optional\\n        The axis of `x` that is resampled.  Default is 0.\\n    window : array_like, callable, string, float, or tuple, optional\\n        Specifies the window applied to the signal in the Fourier\\n        domain.  See below for details.\\n    domain : string, optional\\n        A string indicating the domain of the input `x`:\\n\\n        ``time``\\n           Consider the input `x` as time-domain. (Default)\\n        ``freq``\\n           Consider the input `x` as frequency-domain.\\n\\n    Returns\\n    -------\\n    resampled_x or (resampled_x, resampled_t)\\n        Either the resampled array, or, if `t` was given, a tuple\\n        containing the resampled array and the corresponding resampled\\n        positions.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n\\n    Notes\\n    -----\\n    The argument `window` controls a Fourier-domain window that tapers\\n    the Fourier spectrum before zero-padding to alleviate ringing in\\n    the resampled values for sampled signals you didn't intend to be\\n    interpreted as band-limited.\\n\\n    If `window` is a function, then it is called with a vector of inputs\\n    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).\\n\\n    If `window` is an array of the same length as `x.shape[axis]` it is\\n    assumed to be the window to be applied directly in the Fourier\\n    domain (with dc and low-frequency first).\\n\\n    For any other type of `window`, the function `cusignal.get_window`\\n    is called to generate the window.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector.  The spacing between samples is changed\\n    from ``dx`` to ``dx * len(x) / num``.\\n\\n    If `t` is not None, then it represents the old sample positions,\\n    and the new sample positions will be returned as well as the new\\n    samples.\\n\\n    As noted, `resample` uses FFT transformations, which can be very\\n    slow if the number of input or output samples is large and prime;\\n    see `scipy.fftpack.fft`.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle:\\n\\n    >>> import cupy as cp\\n    >>> import cupyx.scipy.signal import resample\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f = resample(y, 100)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'go-', cupy.asnumpy(xnew),                 cupy.asnumpy(f), '.-', 10, cupy.asnumpy(y[0]), 'ro')\\n    >>> plt.legend(['data', 'resampled'], loc='best')\\n    >>> plt.show()\\n    \"\n    if domain not in ('time', 'freq'):\n        raise ValueError(\"Acceptable domain flags are 'time' or 'freq', not domain={}\".format(domain))\n    x = cupy.asarray(x)\n    Nx = x.shape[axis]\n    real_input = cupy.isrealobj(x)\n    if domain == 'time':\n        if real_input:\n            X = rfft(x, axis=axis)\n        else:\n            X = fft(x, axis=axis)\n    else:\n        X = x\n    if window is not None:\n        if callable(window):\n            W = window(fftfreq(Nx))\n        elif isinstance(window, cupy.ndarray):\n            if window.shape != (Nx,):\n                raise ValueError('window must have the same length as data')\n            W = window\n        else:\n            W = ifftshift(get_window(window, Nx))\n        newshape_W = [1] * x.ndim\n        newshape_W[axis] = X.shape[axis]\n        if real_input:\n            W_real = W.copy()\n            W_real[1:] += W_real[-1:0:-1]\n            W_real[1:] *= 0.5\n            X *= W_real[:newshape_W[axis]].reshape(newshape_W)\n        else:\n            X *= W.reshape(newshape_W)\n    newshape = list(x.shape)\n    if real_input:\n        newshape[axis] = num // 2 + 1\n    else:\n        newshape[axis] = num\n    Y = cupy.zeros(newshape, X.dtype)\n    N = min(num, Nx)\n    nyq = N // 2 + 1\n    sl = [slice(None)] * x.ndim\n    sl[axis] = slice(0, nyq)\n    Y[tuple(sl)] = X[tuple(sl)]\n    if not real_input:\n        if N > 2:\n            sl[axis] = slice(nyq - N, None)\n            Y[tuple(sl)] = X[tuple(sl)]\n    if N % 2 == 0:\n        if num < Nx:\n            if real_input:\n                sl[axis] = slice(N // 2, N // 2 + 1)\n                Y[tuple(sl)] *= 2.0\n            else:\n                sl[axis] = slice(-N // 2, -N // 2 + 1)\n                Y[tuple(sl)] += X[tuple(sl)]\n        elif Nx < num:\n            sl[axis] = slice(N // 2, N // 2 + 1)\n            Y[tuple(sl)] *= 0.5\n            if not real_input:\n                temp = Y[tuple(sl)]\n                sl[axis] = slice(num - N // 2, num - N // 2 + 1)\n                Y[tuple(sl)] = temp\n    if real_input:\n        y = irfft(Y, num, axis=axis)\n    else:\n        y = ifft(Y, axis=axis, overwrite_x=True)\n    y *= float(num) / float(Nx)\n    if t is None:\n        return y\n    else:\n        new_t = cupy.arange(0, num) * (t[1] - t[0]) * Nx / float(num) + t[0]\n        return (y, new_t)",
            "def resample(x, num, t=None, axis=0, window=None, domain='time'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Resample `x` to `num` samples using Fourier method along the given axis.\\n\\n    The resampled signal starts at the same value as `x` but is sampled\\n    with a spacing of ``len(x) / num * (spacing of x)``.  Because a\\n    Fourier method is used, the signal is assumed to be periodic.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    num : int\\n        The number of samples in the resampled signal.\\n    t : array_like, optional\\n        If `t` is given, it is assumed to be the sample positions\\n        associated with the signal data in `x`.\\n    axis : int, optional\\n        The axis of `x` that is resampled.  Default is 0.\\n    window : array_like, callable, string, float, or tuple, optional\\n        Specifies the window applied to the signal in the Fourier\\n        domain.  See below for details.\\n    domain : string, optional\\n        A string indicating the domain of the input `x`:\\n\\n        ``time``\\n           Consider the input `x` as time-domain. (Default)\\n        ``freq``\\n           Consider the input `x` as frequency-domain.\\n\\n    Returns\\n    -------\\n    resampled_x or (resampled_x, resampled_t)\\n        Either the resampled array, or, if `t` was given, a tuple\\n        containing the resampled array and the corresponding resampled\\n        positions.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n\\n    Notes\\n    -----\\n    The argument `window` controls a Fourier-domain window that tapers\\n    the Fourier spectrum before zero-padding to alleviate ringing in\\n    the resampled values for sampled signals you didn't intend to be\\n    interpreted as band-limited.\\n\\n    If `window` is a function, then it is called with a vector of inputs\\n    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).\\n\\n    If `window` is an array of the same length as `x.shape[axis]` it is\\n    assumed to be the window to be applied directly in the Fourier\\n    domain (with dc and low-frequency first).\\n\\n    For any other type of `window`, the function `cusignal.get_window`\\n    is called to generate the window.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector.  The spacing between samples is changed\\n    from ``dx`` to ``dx * len(x) / num``.\\n\\n    If `t` is not None, then it represents the old sample positions,\\n    and the new sample positions will be returned as well as the new\\n    samples.\\n\\n    As noted, `resample` uses FFT transformations, which can be very\\n    slow if the number of input or output samples is large and prime;\\n    see `scipy.fftpack.fft`.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle:\\n\\n    >>> import cupy as cp\\n    >>> import cupyx.scipy.signal import resample\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f = resample(y, 100)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'go-', cupy.asnumpy(xnew),                 cupy.asnumpy(f), '.-', 10, cupy.asnumpy(y[0]), 'ro')\\n    >>> plt.legend(['data', 'resampled'], loc='best')\\n    >>> plt.show()\\n    \"\n    if domain not in ('time', 'freq'):\n        raise ValueError(\"Acceptable domain flags are 'time' or 'freq', not domain={}\".format(domain))\n    x = cupy.asarray(x)\n    Nx = x.shape[axis]\n    real_input = cupy.isrealobj(x)\n    if domain == 'time':\n        if real_input:\n            X = rfft(x, axis=axis)\n        else:\n            X = fft(x, axis=axis)\n    else:\n        X = x\n    if window is not None:\n        if callable(window):\n            W = window(fftfreq(Nx))\n        elif isinstance(window, cupy.ndarray):\n            if window.shape != (Nx,):\n                raise ValueError('window must have the same length as data')\n            W = window\n        else:\n            W = ifftshift(get_window(window, Nx))\n        newshape_W = [1] * x.ndim\n        newshape_W[axis] = X.shape[axis]\n        if real_input:\n            W_real = W.copy()\n            W_real[1:] += W_real[-1:0:-1]\n            W_real[1:] *= 0.5\n            X *= W_real[:newshape_W[axis]].reshape(newshape_W)\n        else:\n            X *= W.reshape(newshape_W)\n    newshape = list(x.shape)\n    if real_input:\n        newshape[axis] = num // 2 + 1\n    else:\n        newshape[axis] = num\n    Y = cupy.zeros(newshape, X.dtype)\n    N = min(num, Nx)\n    nyq = N // 2 + 1\n    sl = [slice(None)] * x.ndim\n    sl[axis] = slice(0, nyq)\n    Y[tuple(sl)] = X[tuple(sl)]\n    if not real_input:\n        if N > 2:\n            sl[axis] = slice(nyq - N, None)\n            Y[tuple(sl)] = X[tuple(sl)]\n    if N % 2 == 0:\n        if num < Nx:\n            if real_input:\n                sl[axis] = slice(N // 2, N // 2 + 1)\n                Y[tuple(sl)] *= 2.0\n            else:\n                sl[axis] = slice(-N // 2, -N // 2 + 1)\n                Y[tuple(sl)] += X[tuple(sl)]\n        elif Nx < num:\n            sl[axis] = slice(N // 2, N // 2 + 1)\n            Y[tuple(sl)] *= 0.5\n            if not real_input:\n                temp = Y[tuple(sl)]\n                sl[axis] = slice(num - N // 2, num - N // 2 + 1)\n                Y[tuple(sl)] = temp\n    if real_input:\n        y = irfft(Y, num, axis=axis)\n    else:\n        y = ifft(Y, axis=axis, overwrite_x=True)\n    y *= float(num) / float(Nx)\n    if t is None:\n        return y\n    else:\n        new_t = cupy.arange(0, num) * (t[1] - t[0]) * Nx / float(num) + t[0]\n        return (y, new_t)",
            "def resample(x, num, t=None, axis=0, window=None, domain='time'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Resample `x` to `num` samples using Fourier method along the given axis.\\n\\n    The resampled signal starts at the same value as `x` but is sampled\\n    with a spacing of ``len(x) / num * (spacing of x)``.  Because a\\n    Fourier method is used, the signal is assumed to be periodic.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    num : int\\n        The number of samples in the resampled signal.\\n    t : array_like, optional\\n        If `t` is given, it is assumed to be the sample positions\\n        associated with the signal data in `x`.\\n    axis : int, optional\\n        The axis of `x` that is resampled.  Default is 0.\\n    window : array_like, callable, string, float, or tuple, optional\\n        Specifies the window applied to the signal in the Fourier\\n        domain.  See below for details.\\n    domain : string, optional\\n        A string indicating the domain of the input `x`:\\n\\n        ``time``\\n           Consider the input `x` as time-domain. (Default)\\n        ``freq``\\n           Consider the input `x` as frequency-domain.\\n\\n    Returns\\n    -------\\n    resampled_x or (resampled_x, resampled_t)\\n        Either the resampled array, or, if `t` was given, a tuple\\n        containing the resampled array and the corresponding resampled\\n        positions.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample_poly : Resample using polyphase filtering and an FIR filter.\\n\\n    Notes\\n    -----\\n    The argument `window` controls a Fourier-domain window that tapers\\n    the Fourier spectrum before zero-padding to alleviate ringing in\\n    the resampled values for sampled signals you didn't intend to be\\n    interpreted as band-limited.\\n\\n    If `window` is a function, then it is called with a vector of inputs\\n    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).\\n\\n    If `window` is an array of the same length as `x.shape[axis]` it is\\n    assumed to be the window to be applied directly in the Fourier\\n    domain (with dc and low-frequency first).\\n\\n    For any other type of `window`, the function `cusignal.get_window`\\n    is called to generate the window.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector.  The spacing between samples is changed\\n    from ``dx`` to ``dx * len(x) / num``.\\n\\n    If `t` is not None, then it represents the old sample positions,\\n    and the new sample positions will be returned as well as the new\\n    samples.\\n\\n    As noted, `resample` uses FFT transformations, which can be very\\n    slow if the number of input or output samples is large and prime;\\n    see `scipy.fftpack.fft`.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle:\\n\\n    >>> import cupy as cp\\n    >>> import cupyx.scipy.signal import resample\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f = resample(y, 100)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'go-', cupy.asnumpy(xnew),                 cupy.asnumpy(f), '.-', 10, cupy.asnumpy(y[0]), 'ro')\\n    >>> plt.legend(['data', 'resampled'], loc='best')\\n    >>> plt.show()\\n    \"\n    if domain not in ('time', 'freq'):\n        raise ValueError(\"Acceptable domain flags are 'time' or 'freq', not domain={}\".format(domain))\n    x = cupy.asarray(x)\n    Nx = x.shape[axis]\n    real_input = cupy.isrealobj(x)\n    if domain == 'time':\n        if real_input:\n            X = rfft(x, axis=axis)\n        else:\n            X = fft(x, axis=axis)\n    else:\n        X = x\n    if window is not None:\n        if callable(window):\n            W = window(fftfreq(Nx))\n        elif isinstance(window, cupy.ndarray):\n            if window.shape != (Nx,):\n                raise ValueError('window must have the same length as data')\n            W = window\n        else:\n            W = ifftshift(get_window(window, Nx))\n        newshape_W = [1] * x.ndim\n        newshape_W[axis] = X.shape[axis]\n        if real_input:\n            W_real = W.copy()\n            W_real[1:] += W_real[-1:0:-1]\n            W_real[1:] *= 0.5\n            X *= W_real[:newshape_W[axis]].reshape(newshape_W)\n        else:\n            X *= W.reshape(newshape_W)\n    newshape = list(x.shape)\n    if real_input:\n        newshape[axis] = num // 2 + 1\n    else:\n        newshape[axis] = num\n    Y = cupy.zeros(newshape, X.dtype)\n    N = min(num, Nx)\n    nyq = N // 2 + 1\n    sl = [slice(None)] * x.ndim\n    sl[axis] = slice(0, nyq)\n    Y[tuple(sl)] = X[tuple(sl)]\n    if not real_input:\n        if N > 2:\n            sl[axis] = slice(nyq - N, None)\n            Y[tuple(sl)] = X[tuple(sl)]\n    if N % 2 == 0:\n        if num < Nx:\n            if real_input:\n                sl[axis] = slice(N // 2, N // 2 + 1)\n                Y[tuple(sl)] *= 2.0\n            else:\n                sl[axis] = slice(-N // 2, -N // 2 + 1)\n                Y[tuple(sl)] += X[tuple(sl)]\n        elif Nx < num:\n            sl[axis] = slice(N // 2, N // 2 + 1)\n            Y[tuple(sl)] *= 0.5\n            if not real_input:\n                temp = Y[tuple(sl)]\n                sl[axis] = slice(num - N // 2, num - N // 2 + 1)\n                Y[tuple(sl)] = temp\n    if real_input:\n        y = irfft(Y, num, axis=axis)\n    else:\n        y = ifft(Y, axis=axis, overwrite_x=True)\n    y *= float(num) / float(Nx)\n    if t is None:\n        return y\n    else:\n        new_t = cupy.arange(0, num) * (t[1] - t[0]) * Nx / float(num) + t[0]\n        return (y, new_t)"
        ]
    },
    {
        "func_name": "resample_poly",
        "original": "def resample_poly(x, up, down, axis=0, window=('kaiser', 5.0), padtype='constant', cval=None):\n    \"\"\"\n    Resample `x` along the given axis using polyphase filtering.\n\n    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass\n    FIR filter is applied, and then it is downsampled by the factor `down`.\n    The resulting sample rate is ``up / down`` times the original sample\n    rate. Values beyond the boundary of the signal are assumed to be zero\n    during the filtering step.\n\n    Parameters\n    ----------\n    x : array_like\n        The data to be resampled.\n    up : int\n        The upsampling factor.\n    down : int\n        The downsampling factor.\n    axis : int, optional\n        The axis of `x` that is resampled. Default is 0.\n    window : string, tuple, or array_like, optional\n        Desired window to use to design the low-pass filter, or the FIR filter\n        coefficients to employ. See below for details.\n    padtype : string, optional\n        `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of\n        the other signal extension modes supported by\n        `cupyx.scipy.signal.upfirdn`. Changes assumptions on values beyond\n        the boundary. If `constant`, assumed to be `cval` (default zero).\n        If `line` assumed to continue a linear trend defined by the first and\n        last points. `mean`, `median`, `maximum` and `minimum` work as in\n        `cupy.pad` and assume that the values beyond the boundary are the mean,\n        median, maximum or minimum respectively of the array along the axis.\n    cval : float, optional\n        Value to use if `padtype='constant'`. Default is zero.\n\n    Returns\n    -------\n    resampled_x : array\n        The resampled array.\n\n    See Also\n    --------\n    decimate : Downsample the signal after applying an FIR or IIR filter.\n    resample : Resample up or down using the FFT method.\n\n    Notes\n    -----\n    This polyphase method will likely be faster than the Fourier method\n    in `cusignal.resample` when the number of samples is large and\n    prime, or when the number of samples is large and `up` and `down`\n    share a large greatest common denominator. The length of the FIR\n    filter used will depend on ``max(up, down) // gcd(up, down)``, and\n    the number of operations during polyphase filtering will depend on\n    the filter length and `down` (see `cusignal.upfirdn` for details).\n\n    The argument `window` specifies the FIR low-pass filter design.\n\n    If `window` is an array_like it is assumed to be the FIR filter\n    coefficients. Note that the FIR filter is applied after the upsampling\n    step, so it should be designed to operate on a signal at a sampling\n    frequency higher than the original by a factor of `up//gcd(up, down)`.\n    This function's output will be centered with respect to this array, so it\n    is best to pass a symmetric filter with an odd number of samples if, as\n    is usually the case, a zero-phase filter is desired.\n\n    For any other type of `window`, the functions `cusignal.get_window`\n    and `cusignal.firwin` are called to generate the appropriate filter\n    coefficients.\n\n    The first sample of the returned vector is the same as the first\n    sample of the input vector. The spacing between samples is changed\n    from ``dx`` to ``dx * down / float(up)``.\n\n    Examples\n    --------\n    Note that the end of the resampled data rises to meet the first\n    sample of the next cycle for the FFT method, and gets closer to zero\n    for the polyphase method:\n\n    >>> import cupy\n    >>> import cupyx.scipy.signal import resample, resample_poly\n\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\n    >>> y = cupy.cos(-x**2/6.0)\n    >>> f_fft = resample(y, 100)\n    >>> f_poly = resample_poly(y, 100, 20)\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(cupy.asnumpy(xnew), cupy.asnumpy(f_fft), 'b.-',                  cupy.asnumpy(xnew), cupy.asnumpy(f_poly), 'r.-')\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'ko-')\n    >>> plt.plot(10, cupy.asnumpy(y[0]), 'bo', 10, 0., 'ro')  # boundaries\n    >>> plt.legend(['resample', 'resamp_poly', 'data'], loc='best')\n    >>> plt.show()\n    \"\"\"\n    if padtype != 'constant' or cval is not None:\n        raise ValueError('padtype and cval arguments are not supported by upfirdn')\n    x = cupy.asarray(x)\n    up = int(up)\n    down = int(down)\n    if up < 1 or down < 1:\n        raise ValueError('up and down must be >= 1')\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    if up == down == 1:\n        return x.copy()\n    n_out = x.shape[axis] * up\n    n_out = n_out // down + bool(n_out % down)\n    if isinstance(window, (list, cupy.ndarray)):\n        window = cupy.asarray(window)\n        if window.ndim > 1:\n            raise ValueError('window must be 1-D')\n        half_len = (window.size - 1) // 2\n        h = up * window\n    else:\n        half_len = 10 * max(up, down)\n        h = up * _design_resample_poly(up, down, window)\n    n_pre_pad = down - half_len % down\n    n_post_pad = 0\n    n_pre_remove = (half_len + n_pre_pad) // down\n    while _output_len(len(h) + n_pre_pad + n_post_pad, x.shape[axis], up, down) < n_out + n_pre_remove:\n        n_post_pad += 1\n    h = cupy.concatenate((cupy.zeros(n_pre_pad, h.dtype), h, cupy.zeros(n_post_pad, h.dtype)))\n    n_pre_remove_end = n_pre_remove + n_out\n    y = upfirdn(h, x, up, down, axis)\n    keep = [slice(None)] * x.ndim\n    keep[axis] = slice(n_pre_remove, n_pre_remove_end)\n    return y[tuple(keep)]",
        "mutated": [
            "def resample_poly(x, up, down, axis=0, window=('kaiser', 5.0), padtype='constant', cval=None):\n    if False:\n        i = 10\n    \"\\n    Resample `x` along the given axis using polyphase filtering.\\n\\n    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass\\n    FIR filter is applied, and then it is downsampled by the factor `down`.\\n    The resulting sample rate is ``up / down`` times the original sample\\n    rate. Values beyond the boundary of the signal are assumed to be zero\\n    during the filtering step.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    axis : int, optional\\n        The axis of `x` that is resampled. Default is 0.\\n    window : string, tuple, or array_like, optional\\n        Desired window to use to design the low-pass filter, or the FIR filter\\n        coefficients to employ. See below for details.\\n    padtype : string, optional\\n        `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of\\n        the other signal extension modes supported by\\n        `cupyx.scipy.signal.upfirdn`. Changes assumptions on values beyond\\n        the boundary. If `constant`, assumed to be `cval` (default zero).\\n        If `line` assumed to continue a linear trend defined by the first and\\n        last points. `mean`, `median`, `maximum` and `minimum` work as in\\n        `cupy.pad` and assume that the values beyond the boundary are the mean,\\n        median, maximum or minimum respectively of the array along the axis.\\n    cval : float, optional\\n        Value to use if `padtype='constant'`. Default is zero.\\n\\n    Returns\\n    -------\\n    resampled_x : array\\n        The resampled array.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample : Resample up or down using the FFT method.\\n\\n    Notes\\n    -----\\n    This polyphase method will likely be faster than the Fourier method\\n    in `cusignal.resample` when the number of samples is large and\\n    prime, or when the number of samples is large and `up` and `down`\\n    share a large greatest common denominator. The length of the FIR\\n    filter used will depend on ``max(up, down) // gcd(up, down)``, and\\n    the number of operations during polyphase filtering will depend on\\n    the filter length and `down` (see `cusignal.upfirdn` for details).\\n\\n    The argument `window` specifies the FIR low-pass filter design.\\n\\n    If `window` is an array_like it is assumed to be the FIR filter\\n    coefficients. Note that the FIR filter is applied after the upsampling\\n    step, so it should be designed to operate on a signal at a sampling\\n    frequency higher than the original by a factor of `up//gcd(up, down)`.\\n    This function's output will be centered with respect to this array, so it\\n    is best to pass a symmetric filter with an odd number of samples if, as\\n    is usually the case, a zero-phase filter is desired.\\n\\n    For any other type of `window`, the functions `cusignal.get_window`\\n    and `cusignal.firwin` are called to generate the appropriate filter\\n    coefficients.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector. The spacing between samples is changed\\n    from ``dx`` to ``dx * down / float(up)``.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle for the FFT method, and gets closer to zero\\n    for the polyphase method:\\n\\n    >>> import cupy\\n    >>> import cupyx.scipy.signal import resample, resample_poly\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f_fft = resample(y, 100)\\n    >>> f_poly = resample_poly(y, 100, 20)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(xnew), cupy.asnumpy(f_fft), 'b.-',                  cupy.asnumpy(xnew), cupy.asnumpy(f_poly), 'r.-')\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'ko-')\\n    >>> plt.plot(10, cupy.asnumpy(y[0]), 'bo', 10, 0., 'ro')  # boundaries\\n    >>> plt.legend(['resample', 'resamp_poly', 'data'], loc='best')\\n    >>> plt.show()\\n    \"\n    if padtype != 'constant' or cval is not None:\n        raise ValueError('padtype and cval arguments are not supported by upfirdn')\n    x = cupy.asarray(x)\n    up = int(up)\n    down = int(down)\n    if up < 1 or down < 1:\n        raise ValueError('up and down must be >= 1')\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    if up == down == 1:\n        return x.copy()\n    n_out = x.shape[axis] * up\n    n_out = n_out // down + bool(n_out % down)\n    if isinstance(window, (list, cupy.ndarray)):\n        window = cupy.asarray(window)\n        if window.ndim > 1:\n            raise ValueError('window must be 1-D')\n        half_len = (window.size - 1) // 2\n        h = up * window\n    else:\n        half_len = 10 * max(up, down)\n        h = up * _design_resample_poly(up, down, window)\n    n_pre_pad = down - half_len % down\n    n_post_pad = 0\n    n_pre_remove = (half_len + n_pre_pad) // down\n    while _output_len(len(h) + n_pre_pad + n_post_pad, x.shape[axis], up, down) < n_out + n_pre_remove:\n        n_post_pad += 1\n    h = cupy.concatenate((cupy.zeros(n_pre_pad, h.dtype), h, cupy.zeros(n_post_pad, h.dtype)))\n    n_pre_remove_end = n_pre_remove + n_out\n    y = upfirdn(h, x, up, down, axis)\n    keep = [slice(None)] * x.ndim\n    keep[axis] = slice(n_pre_remove, n_pre_remove_end)\n    return y[tuple(keep)]",
            "def resample_poly(x, up, down, axis=0, window=('kaiser', 5.0), padtype='constant', cval=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Resample `x` along the given axis using polyphase filtering.\\n\\n    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass\\n    FIR filter is applied, and then it is downsampled by the factor `down`.\\n    The resulting sample rate is ``up / down`` times the original sample\\n    rate. Values beyond the boundary of the signal are assumed to be zero\\n    during the filtering step.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    axis : int, optional\\n        The axis of `x` that is resampled. Default is 0.\\n    window : string, tuple, or array_like, optional\\n        Desired window to use to design the low-pass filter, or the FIR filter\\n        coefficients to employ. See below for details.\\n    padtype : string, optional\\n        `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of\\n        the other signal extension modes supported by\\n        `cupyx.scipy.signal.upfirdn`. Changes assumptions on values beyond\\n        the boundary. If `constant`, assumed to be `cval` (default zero).\\n        If `line` assumed to continue a linear trend defined by the first and\\n        last points. `mean`, `median`, `maximum` and `minimum` work as in\\n        `cupy.pad` and assume that the values beyond the boundary are the mean,\\n        median, maximum or minimum respectively of the array along the axis.\\n    cval : float, optional\\n        Value to use if `padtype='constant'`. Default is zero.\\n\\n    Returns\\n    -------\\n    resampled_x : array\\n        The resampled array.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample : Resample up or down using the FFT method.\\n\\n    Notes\\n    -----\\n    This polyphase method will likely be faster than the Fourier method\\n    in `cusignal.resample` when the number of samples is large and\\n    prime, or when the number of samples is large and `up` and `down`\\n    share a large greatest common denominator. The length of the FIR\\n    filter used will depend on ``max(up, down) // gcd(up, down)``, and\\n    the number of operations during polyphase filtering will depend on\\n    the filter length and `down` (see `cusignal.upfirdn` for details).\\n\\n    The argument `window` specifies the FIR low-pass filter design.\\n\\n    If `window` is an array_like it is assumed to be the FIR filter\\n    coefficients. Note that the FIR filter is applied after the upsampling\\n    step, so it should be designed to operate on a signal at a sampling\\n    frequency higher than the original by a factor of `up//gcd(up, down)`.\\n    This function's output will be centered with respect to this array, so it\\n    is best to pass a symmetric filter with an odd number of samples if, as\\n    is usually the case, a zero-phase filter is desired.\\n\\n    For any other type of `window`, the functions `cusignal.get_window`\\n    and `cusignal.firwin` are called to generate the appropriate filter\\n    coefficients.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector. The spacing between samples is changed\\n    from ``dx`` to ``dx * down / float(up)``.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle for the FFT method, and gets closer to zero\\n    for the polyphase method:\\n\\n    >>> import cupy\\n    >>> import cupyx.scipy.signal import resample, resample_poly\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f_fft = resample(y, 100)\\n    >>> f_poly = resample_poly(y, 100, 20)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(xnew), cupy.asnumpy(f_fft), 'b.-',                  cupy.asnumpy(xnew), cupy.asnumpy(f_poly), 'r.-')\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'ko-')\\n    >>> plt.plot(10, cupy.asnumpy(y[0]), 'bo', 10, 0., 'ro')  # boundaries\\n    >>> plt.legend(['resample', 'resamp_poly', 'data'], loc='best')\\n    >>> plt.show()\\n    \"\n    if padtype != 'constant' or cval is not None:\n        raise ValueError('padtype and cval arguments are not supported by upfirdn')\n    x = cupy.asarray(x)\n    up = int(up)\n    down = int(down)\n    if up < 1 or down < 1:\n        raise ValueError('up and down must be >= 1')\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    if up == down == 1:\n        return x.copy()\n    n_out = x.shape[axis] * up\n    n_out = n_out // down + bool(n_out % down)\n    if isinstance(window, (list, cupy.ndarray)):\n        window = cupy.asarray(window)\n        if window.ndim > 1:\n            raise ValueError('window must be 1-D')\n        half_len = (window.size - 1) // 2\n        h = up * window\n    else:\n        half_len = 10 * max(up, down)\n        h = up * _design_resample_poly(up, down, window)\n    n_pre_pad = down - half_len % down\n    n_post_pad = 0\n    n_pre_remove = (half_len + n_pre_pad) // down\n    while _output_len(len(h) + n_pre_pad + n_post_pad, x.shape[axis], up, down) < n_out + n_pre_remove:\n        n_post_pad += 1\n    h = cupy.concatenate((cupy.zeros(n_pre_pad, h.dtype), h, cupy.zeros(n_post_pad, h.dtype)))\n    n_pre_remove_end = n_pre_remove + n_out\n    y = upfirdn(h, x, up, down, axis)\n    keep = [slice(None)] * x.ndim\n    keep[axis] = slice(n_pre_remove, n_pre_remove_end)\n    return y[tuple(keep)]",
            "def resample_poly(x, up, down, axis=0, window=('kaiser', 5.0), padtype='constant', cval=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Resample `x` along the given axis using polyphase filtering.\\n\\n    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass\\n    FIR filter is applied, and then it is downsampled by the factor `down`.\\n    The resulting sample rate is ``up / down`` times the original sample\\n    rate. Values beyond the boundary of the signal are assumed to be zero\\n    during the filtering step.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    axis : int, optional\\n        The axis of `x` that is resampled. Default is 0.\\n    window : string, tuple, or array_like, optional\\n        Desired window to use to design the low-pass filter, or the FIR filter\\n        coefficients to employ. See below for details.\\n    padtype : string, optional\\n        `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of\\n        the other signal extension modes supported by\\n        `cupyx.scipy.signal.upfirdn`. Changes assumptions on values beyond\\n        the boundary. If `constant`, assumed to be `cval` (default zero).\\n        If `line` assumed to continue a linear trend defined by the first and\\n        last points. `mean`, `median`, `maximum` and `minimum` work as in\\n        `cupy.pad` and assume that the values beyond the boundary are the mean,\\n        median, maximum or minimum respectively of the array along the axis.\\n    cval : float, optional\\n        Value to use if `padtype='constant'`. Default is zero.\\n\\n    Returns\\n    -------\\n    resampled_x : array\\n        The resampled array.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample : Resample up or down using the FFT method.\\n\\n    Notes\\n    -----\\n    This polyphase method will likely be faster than the Fourier method\\n    in `cusignal.resample` when the number of samples is large and\\n    prime, or when the number of samples is large and `up` and `down`\\n    share a large greatest common denominator. The length of the FIR\\n    filter used will depend on ``max(up, down) // gcd(up, down)``, and\\n    the number of operations during polyphase filtering will depend on\\n    the filter length and `down` (see `cusignal.upfirdn` for details).\\n\\n    The argument `window` specifies the FIR low-pass filter design.\\n\\n    If `window` is an array_like it is assumed to be the FIR filter\\n    coefficients. Note that the FIR filter is applied after the upsampling\\n    step, so it should be designed to operate on a signal at a sampling\\n    frequency higher than the original by a factor of `up//gcd(up, down)`.\\n    This function's output will be centered with respect to this array, so it\\n    is best to pass a symmetric filter with an odd number of samples if, as\\n    is usually the case, a zero-phase filter is desired.\\n\\n    For any other type of `window`, the functions `cusignal.get_window`\\n    and `cusignal.firwin` are called to generate the appropriate filter\\n    coefficients.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector. The spacing between samples is changed\\n    from ``dx`` to ``dx * down / float(up)``.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle for the FFT method, and gets closer to zero\\n    for the polyphase method:\\n\\n    >>> import cupy\\n    >>> import cupyx.scipy.signal import resample, resample_poly\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f_fft = resample(y, 100)\\n    >>> f_poly = resample_poly(y, 100, 20)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(xnew), cupy.asnumpy(f_fft), 'b.-',                  cupy.asnumpy(xnew), cupy.asnumpy(f_poly), 'r.-')\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'ko-')\\n    >>> plt.plot(10, cupy.asnumpy(y[0]), 'bo', 10, 0., 'ro')  # boundaries\\n    >>> plt.legend(['resample', 'resamp_poly', 'data'], loc='best')\\n    >>> plt.show()\\n    \"\n    if padtype != 'constant' or cval is not None:\n        raise ValueError('padtype and cval arguments are not supported by upfirdn')\n    x = cupy.asarray(x)\n    up = int(up)\n    down = int(down)\n    if up < 1 or down < 1:\n        raise ValueError('up and down must be >= 1')\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    if up == down == 1:\n        return x.copy()\n    n_out = x.shape[axis] * up\n    n_out = n_out // down + bool(n_out % down)\n    if isinstance(window, (list, cupy.ndarray)):\n        window = cupy.asarray(window)\n        if window.ndim > 1:\n            raise ValueError('window must be 1-D')\n        half_len = (window.size - 1) // 2\n        h = up * window\n    else:\n        half_len = 10 * max(up, down)\n        h = up * _design_resample_poly(up, down, window)\n    n_pre_pad = down - half_len % down\n    n_post_pad = 0\n    n_pre_remove = (half_len + n_pre_pad) // down\n    while _output_len(len(h) + n_pre_pad + n_post_pad, x.shape[axis], up, down) < n_out + n_pre_remove:\n        n_post_pad += 1\n    h = cupy.concatenate((cupy.zeros(n_pre_pad, h.dtype), h, cupy.zeros(n_post_pad, h.dtype)))\n    n_pre_remove_end = n_pre_remove + n_out\n    y = upfirdn(h, x, up, down, axis)\n    keep = [slice(None)] * x.ndim\n    keep[axis] = slice(n_pre_remove, n_pre_remove_end)\n    return y[tuple(keep)]",
            "def resample_poly(x, up, down, axis=0, window=('kaiser', 5.0), padtype='constant', cval=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Resample `x` along the given axis using polyphase filtering.\\n\\n    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass\\n    FIR filter is applied, and then it is downsampled by the factor `down`.\\n    The resulting sample rate is ``up / down`` times the original sample\\n    rate. Values beyond the boundary of the signal are assumed to be zero\\n    during the filtering step.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    axis : int, optional\\n        The axis of `x` that is resampled. Default is 0.\\n    window : string, tuple, or array_like, optional\\n        Desired window to use to design the low-pass filter, or the FIR filter\\n        coefficients to employ. See below for details.\\n    padtype : string, optional\\n        `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of\\n        the other signal extension modes supported by\\n        `cupyx.scipy.signal.upfirdn`. Changes assumptions on values beyond\\n        the boundary. If `constant`, assumed to be `cval` (default zero).\\n        If `line` assumed to continue a linear trend defined by the first and\\n        last points. `mean`, `median`, `maximum` and `minimum` work as in\\n        `cupy.pad` and assume that the values beyond the boundary are the mean,\\n        median, maximum or minimum respectively of the array along the axis.\\n    cval : float, optional\\n        Value to use if `padtype='constant'`. Default is zero.\\n\\n    Returns\\n    -------\\n    resampled_x : array\\n        The resampled array.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample : Resample up or down using the FFT method.\\n\\n    Notes\\n    -----\\n    This polyphase method will likely be faster than the Fourier method\\n    in `cusignal.resample` when the number of samples is large and\\n    prime, or when the number of samples is large and `up` and `down`\\n    share a large greatest common denominator. The length of the FIR\\n    filter used will depend on ``max(up, down) // gcd(up, down)``, and\\n    the number of operations during polyphase filtering will depend on\\n    the filter length and `down` (see `cusignal.upfirdn` for details).\\n\\n    The argument `window` specifies the FIR low-pass filter design.\\n\\n    If `window` is an array_like it is assumed to be the FIR filter\\n    coefficients. Note that the FIR filter is applied after the upsampling\\n    step, so it should be designed to operate on a signal at a sampling\\n    frequency higher than the original by a factor of `up//gcd(up, down)`.\\n    This function's output will be centered with respect to this array, so it\\n    is best to pass a symmetric filter with an odd number of samples if, as\\n    is usually the case, a zero-phase filter is desired.\\n\\n    For any other type of `window`, the functions `cusignal.get_window`\\n    and `cusignal.firwin` are called to generate the appropriate filter\\n    coefficients.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector. The spacing between samples is changed\\n    from ``dx`` to ``dx * down / float(up)``.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle for the FFT method, and gets closer to zero\\n    for the polyphase method:\\n\\n    >>> import cupy\\n    >>> import cupyx.scipy.signal import resample, resample_poly\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f_fft = resample(y, 100)\\n    >>> f_poly = resample_poly(y, 100, 20)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(xnew), cupy.asnumpy(f_fft), 'b.-',                  cupy.asnumpy(xnew), cupy.asnumpy(f_poly), 'r.-')\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'ko-')\\n    >>> plt.plot(10, cupy.asnumpy(y[0]), 'bo', 10, 0., 'ro')  # boundaries\\n    >>> plt.legend(['resample', 'resamp_poly', 'data'], loc='best')\\n    >>> plt.show()\\n    \"\n    if padtype != 'constant' or cval is not None:\n        raise ValueError('padtype and cval arguments are not supported by upfirdn')\n    x = cupy.asarray(x)\n    up = int(up)\n    down = int(down)\n    if up < 1 or down < 1:\n        raise ValueError('up and down must be >= 1')\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    if up == down == 1:\n        return x.copy()\n    n_out = x.shape[axis] * up\n    n_out = n_out // down + bool(n_out % down)\n    if isinstance(window, (list, cupy.ndarray)):\n        window = cupy.asarray(window)\n        if window.ndim > 1:\n            raise ValueError('window must be 1-D')\n        half_len = (window.size - 1) // 2\n        h = up * window\n    else:\n        half_len = 10 * max(up, down)\n        h = up * _design_resample_poly(up, down, window)\n    n_pre_pad = down - half_len % down\n    n_post_pad = 0\n    n_pre_remove = (half_len + n_pre_pad) // down\n    while _output_len(len(h) + n_pre_pad + n_post_pad, x.shape[axis], up, down) < n_out + n_pre_remove:\n        n_post_pad += 1\n    h = cupy.concatenate((cupy.zeros(n_pre_pad, h.dtype), h, cupy.zeros(n_post_pad, h.dtype)))\n    n_pre_remove_end = n_pre_remove + n_out\n    y = upfirdn(h, x, up, down, axis)\n    keep = [slice(None)] * x.ndim\n    keep[axis] = slice(n_pre_remove, n_pre_remove_end)\n    return y[tuple(keep)]",
            "def resample_poly(x, up, down, axis=0, window=('kaiser', 5.0), padtype='constant', cval=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Resample `x` along the given axis using polyphase filtering.\\n\\n    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass\\n    FIR filter is applied, and then it is downsampled by the factor `down`.\\n    The resulting sample rate is ``up / down`` times the original sample\\n    rate. Values beyond the boundary of the signal are assumed to be zero\\n    during the filtering step.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        The data to be resampled.\\n    up : int\\n        The upsampling factor.\\n    down : int\\n        The downsampling factor.\\n    axis : int, optional\\n        The axis of `x` that is resampled. Default is 0.\\n    window : string, tuple, or array_like, optional\\n        Desired window to use to design the low-pass filter, or the FIR filter\\n        coefficients to employ. See below for details.\\n    padtype : string, optional\\n        `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of\\n        the other signal extension modes supported by\\n        `cupyx.scipy.signal.upfirdn`. Changes assumptions on values beyond\\n        the boundary. If `constant`, assumed to be `cval` (default zero).\\n        If `line` assumed to continue a linear trend defined by the first and\\n        last points. `mean`, `median`, `maximum` and `minimum` work as in\\n        `cupy.pad` and assume that the values beyond the boundary are the mean,\\n        median, maximum or minimum respectively of the array along the axis.\\n    cval : float, optional\\n        Value to use if `padtype='constant'`. Default is zero.\\n\\n    Returns\\n    -------\\n    resampled_x : array\\n        The resampled array.\\n\\n    See Also\\n    --------\\n    decimate : Downsample the signal after applying an FIR or IIR filter.\\n    resample : Resample up or down using the FFT method.\\n\\n    Notes\\n    -----\\n    This polyphase method will likely be faster than the Fourier method\\n    in `cusignal.resample` when the number of samples is large and\\n    prime, or when the number of samples is large and `up` and `down`\\n    share a large greatest common denominator. The length of the FIR\\n    filter used will depend on ``max(up, down) // gcd(up, down)``, and\\n    the number of operations during polyphase filtering will depend on\\n    the filter length and `down` (see `cusignal.upfirdn` for details).\\n\\n    The argument `window` specifies the FIR low-pass filter design.\\n\\n    If `window` is an array_like it is assumed to be the FIR filter\\n    coefficients. Note that the FIR filter is applied after the upsampling\\n    step, so it should be designed to operate on a signal at a sampling\\n    frequency higher than the original by a factor of `up//gcd(up, down)`.\\n    This function's output will be centered with respect to this array, so it\\n    is best to pass a symmetric filter with an odd number of samples if, as\\n    is usually the case, a zero-phase filter is desired.\\n\\n    For any other type of `window`, the functions `cusignal.get_window`\\n    and `cusignal.firwin` are called to generate the appropriate filter\\n    coefficients.\\n\\n    The first sample of the returned vector is the same as the first\\n    sample of the input vector. The spacing between samples is changed\\n    from ``dx`` to ``dx * down / float(up)``.\\n\\n    Examples\\n    --------\\n    Note that the end of the resampled data rises to meet the first\\n    sample of the next cycle for the FFT method, and gets closer to zero\\n    for the polyphase method:\\n\\n    >>> import cupy\\n    >>> import cupyx.scipy.signal import resample, resample_poly\\n\\n    >>> x = cupy.linspace(0, 10, 20, endpoint=False)\\n    >>> y = cupy.cos(-x**2/6.0)\\n    >>> f_fft = resample(y, 100)\\n    >>> f_poly = resample_poly(y, 100, 20)\\n    >>> xnew = cupy.linspace(0, 10, 100, endpoint=False)\\n\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(cupy.asnumpy(xnew), cupy.asnumpy(f_fft), 'b.-',                  cupy.asnumpy(xnew), cupy.asnumpy(f_poly), 'r.-')\\n    >>> plt.plot(cupy.asnumpy(x), cupy.asnumpy(y), 'ko-')\\n    >>> plt.plot(10, cupy.asnumpy(y[0]), 'bo', 10, 0., 'ro')  # boundaries\\n    >>> plt.legend(['resample', 'resamp_poly', 'data'], loc='best')\\n    >>> plt.show()\\n    \"\n    if padtype != 'constant' or cval is not None:\n        raise ValueError('padtype and cval arguments are not supported by upfirdn')\n    x = cupy.asarray(x)\n    up = int(up)\n    down = int(down)\n    if up < 1 or down < 1:\n        raise ValueError('up and down must be >= 1')\n    g_ = gcd(up, down)\n    up //= g_\n    down //= g_\n    if up == down == 1:\n        return x.copy()\n    n_out = x.shape[axis] * up\n    n_out = n_out // down + bool(n_out % down)\n    if isinstance(window, (list, cupy.ndarray)):\n        window = cupy.asarray(window)\n        if window.ndim > 1:\n            raise ValueError('window must be 1-D')\n        half_len = (window.size - 1) // 2\n        h = up * window\n    else:\n        half_len = 10 * max(up, down)\n        h = up * _design_resample_poly(up, down, window)\n    n_pre_pad = down - half_len % down\n    n_post_pad = 0\n    n_pre_remove = (half_len + n_pre_pad) // down\n    while _output_len(len(h) + n_pre_pad + n_post_pad, x.shape[axis], up, down) < n_out + n_pre_remove:\n        n_post_pad += 1\n    h = cupy.concatenate((cupy.zeros(n_pre_pad, h.dtype), h, cupy.zeros(n_post_pad, h.dtype)))\n    n_pre_remove_end = n_pre_remove + n_out\n    y = upfirdn(h, x, up, down, axis)\n    keep = [slice(None)] * x.ndim\n    keep[axis] = slice(n_pre_remove, n_pre_remove_end)\n    return y[tuple(keep)]"
        ]
    }
]