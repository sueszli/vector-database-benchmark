[
    {
        "func_name": "_backup_file",
        "original": "def _backup_file(file: Path, copy_file: bool=False) -> None:\n    \"\"\"\n    Backup existing file to avoid deleting the user file\n    :param file: complete path to the file\n    :param copy_file: keep file in place too.\n    :return: None\n    \"\"\"\n    file_swp = str(file) + '.swp'\n    if file.is_file():\n        file.rename(file_swp)\n        if copy_file:\n            copyfile(file_swp, file)",
        "mutated": [
            "def _backup_file(file: Path, copy_file: bool=False) -> None:\n    if False:\n        i = 10\n    '\\n    Backup existing file to avoid deleting the user file\\n    :param file: complete path to the file\\n    :param copy_file: keep file in place too.\\n    :return: None\\n    '\n    file_swp = str(file) + '.swp'\n    if file.is_file():\n        file.rename(file_swp)\n        if copy_file:\n            copyfile(file_swp, file)",
            "def _backup_file(file: Path, copy_file: bool=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Backup existing file to avoid deleting the user file\\n    :param file: complete path to the file\\n    :param copy_file: keep file in place too.\\n    :return: None\\n    '\n    file_swp = str(file) + '.swp'\n    if file.is_file():\n        file.rename(file_swp)\n        if copy_file:\n            copyfile(file_swp, file)",
            "def _backup_file(file: Path, copy_file: bool=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Backup existing file to avoid deleting the user file\\n    :param file: complete path to the file\\n    :param copy_file: keep file in place too.\\n    :return: None\\n    '\n    file_swp = str(file) + '.swp'\n    if file.is_file():\n        file.rename(file_swp)\n        if copy_file:\n            copyfile(file_swp, file)",
            "def _backup_file(file: Path, copy_file: bool=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Backup existing file to avoid deleting the user file\\n    :param file: complete path to the file\\n    :param copy_file: keep file in place too.\\n    :return: None\\n    '\n    file_swp = str(file) + '.swp'\n    if file.is_file():\n        file.rename(file_swp)\n        if copy_file:\n            copyfile(file_swp, file)",
            "def _backup_file(file: Path, copy_file: bool=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Backup existing file to avoid deleting the user file\\n    :param file: complete path to the file\\n    :param copy_file: keep file in place too.\\n    :return: None\\n    '\n    file_swp = str(file) + '.swp'\n    if file.is_file():\n        file.rename(file_swp)\n        if copy_file:\n            copyfile(file_swp, file)"
        ]
    },
    {
        "func_name": "test_text_table_bt_results",
        "original": "def test_text_table_bt_results():\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.05], 'profit_abs': [0.2, 0.4, -0.1], 'trade_duration': [10, 30, 20]})\n    result_str = '|    Pair |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |\\n|---------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------|\\n| ETH/BTC |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |\\n|   TOTAL |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |'\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=4, results=results)\n    assert text_table_bt_results(pair_results, stake_currency='BTC') == result_str",
        "mutated": [
            "def test_text_table_bt_results():\n    if False:\n        i = 10\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.05], 'profit_abs': [0.2, 0.4, -0.1], 'trade_duration': [10, 30, 20]})\n    result_str = '|    Pair |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |\\n|---------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------|\\n| ETH/BTC |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |\\n|   TOTAL |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |'\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=4, results=results)\n    assert text_table_bt_results(pair_results, stake_currency='BTC') == result_str",
            "def test_text_table_bt_results():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.05], 'profit_abs': [0.2, 0.4, -0.1], 'trade_duration': [10, 30, 20]})\n    result_str = '|    Pair |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |\\n|---------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------|\\n| ETH/BTC |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |\\n|   TOTAL |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |'\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=4, results=results)\n    assert text_table_bt_results(pair_results, stake_currency='BTC') == result_str",
            "def test_text_table_bt_results():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.05], 'profit_abs': [0.2, 0.4, -0.1], 'trade_duration': [10, 30, 20]})\n    result_str = '|    Pair |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |\\n|---------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------|\\n| ETH/BTC |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |\\n|   TOTAL |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |'\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=4, results=results)\n    assert text_table_bt_results(pair_results, stake_currency='BTC') == result_str",
            "def test_text_table_bt_results():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.05], 'profit_abs': [0.2, 0.4, -0.1], 'trade_duration': [10, 30, 20]})\n    result_str = '|    Pair |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |\\n|---------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------|\\n| ETH/BTC |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |\\n|   TOTAL |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |'\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=4, results=results)\n    assert text_table_bt_results(pair_results, stake_currency='BTC') == result_str",
            "def test_text_table_bt_results():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.05], 'profit_abs': [0.2, 0.4, -0.1], 'trade_duration': [10, 30, 20]})\n    result_str = '|    Pair |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |\\n|---------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------|\\n| ETH/BTC |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |\\n|   TOTAL |         3 |           8.33 |          25.00 |       0.50000000 |          12.50 |        0:20:00 |     2     0     1  66.7 |'\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=4, results=results)\n    assert text_table_bt_results(pair_results, stake_currency='BTC') == result_str"
        ]
    },
    {
        "func_name": "test_generate_backtest_stats",
        "original": "def test_generate_backtest_stats(default_conf, testdatadir, tmp_path):\n    default_conf.update({'strategy': CURRENT_TEST_STRATEGY})\n    StrategyResolver.load_strategy(default_conf)\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, 0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, 1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.003103, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.STOP_LOSS, ExitType.ROI, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '123'}}\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    min_date = dt_from_ts(1510688220)\n    max_date = dt_from_ts(1510700340)\n    btdata = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert strat_stats['backtest_start'] == min_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['backtest_end'] == max_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['total_trades'] == len(results['DefStrat']['results'])\n    assert strat_stats['max_drawdown_account'] == 0.0\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, -0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, -1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.0032903, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '124'}}\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert pytest.approx(strat_stats['max_drawdown_account']) == 1.399999e-08\n    assert strat_stats['drawdown_start'] == '2017-11-14 22:10:00'\n    assert strat_stats['drawdown_end'] == '2017-11-14 22:43:00'\n    assert strat_stats['drawdown_end_ts'] == 1510699380000\n    assert strat_stats['drawdown_start_ts'] == 1510697400000\n    assert strat_stats['pairlist'] == ['UNITTEST/BTC']\n    filename = tmp_path / 'btresult.json'\n    filename_last = tmp_path / LAST_BT_RESULT_FN\n    _backup_file(filename_last, copy_file=True)\n    assert not filename.is_file()\n    store_backtest_stats(filename, stats, '2022_01_01_15_05_13')\n    last_fn = get_latest_backtest_filename(filename_last.parent)\n    assert re.match('btresult-.*\\\\.json', last_fn)\n    filename1 = tmp_path / last_fn\n    assert filename1.is_file()\n    content = filename1.read_text()\n    assert 'max_drawdown_account' in content\n    assert 'strategy' in content\n    assert 'pairlist' in content\n    assert filename_last.is_file()\n    _clean_test_file(filename_last)\n    filename1.unlink()",
        "mutated": [
            "def test_generate_backtest_stats(default_conf, testdatadir, tmp_path):\n    if False:\n        i = 10\n    default_conf.update({'strategy': CURRENT_TEST_STRATEGY})\n    StrategyResolver.load_strategy(default_conf)\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, 0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, 1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.003103, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.STOP_LOSS, ExitType.ROI, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '123'}}\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    min_date = dt_from_ts(1510688220)\n    max_date = dt_from_ts(1510700340)\n    btdata = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert strat_stats['backtest_start'] == min_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['backtest_end'] == max_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['total_trades'] == len(results['DefStrat']['results'])\n    assert strat_stats['max_drawdown_account'] == 0.0\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, -0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, -1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.0032903, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '124'}}\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert pytest.approx(strat_stats['max_drawdown_account']) == 1.399999e-08\n    assert strat_stats['drawdown_start'] == '2017-11-14 22:10:00'\n    assert strat_stats['drawdown_end'] == '2017-11-14 22:43:00'\n    assert strat_stats['drawdown_end_ts'] == 1510699380000\n    assert strat_stats['drawdown_start_ts'] == 1510697400000\n    assert strat_stats['pairlist'] == ['UNITTEST/BTC']\n    filename = tmp_path / 'btresult.json'\n    filename_last = tmp_path / LAST_BT_RESULT_FN\n    _backup_file(filename_last, copy_file=True)\n    assert not filename.is_file()\n    store_backtest_stats(filename, stats, '2022_01_01_15_05_13')\n    last_fn = get_latest_backtest_filename(filename_last.parent)\n    assert re.match('btresult-.*\\\\.json', last_fn)\n    filename1 = tmp_path / last_fn\n    assert filename1.is_file()\n    content = filename1.read_text()\n    assert 'max_drawdown_account' in content\n    assert 'strategy' in content\n    assert 'pairlist' in content\n    assert filename_last.is_file()\n    _clean_test_file(filename_last)\n    filename1.unlink()",
            "def test_generate_backtest_stats(default_conf, testdatadir, tmp_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    default_conf.update({'strategy': CURRENT_TEST_STRATEGY})\n    StrategyResolver.load_strategy(default_conf)\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, 0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, 1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.003103, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.STOP_LOSS, ExitType.ROI, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '123'}}\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    min_date = dt_from_ts(1510688220)\n    max_date = dt_from_ts(1510700340)\n    btdata = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert strat_stats['backtest_start'] == min_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['backtest_end'] == max_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['total_trades'] == len(results['DefStrat']['results'])\n    assert strat_stats['max_drawdown_account'] == 0.0\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, -0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, -1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.0032903, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '124'}}\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert pytest.approx(strat_stats['max_drawdown_account']) == 1.399999e-08\n    assert strat_stats['drawdown_start'] == '2017-11-14 22:10:00'\n    assert strat_stats['drawdown_end'] == '2017-11-14 22:43:00'\n    assert strat_stats['drawdown_end_ts'] == 1510699380000\n    assert strat_stats['drawdown_start_ts'] == 1510697400000\n    assert strat_stats['pairlist'] == ['UNITTEST/BTC']\n    filename = tmp_path / 'btresult.json'\n    filename_last = tmp_path / LAST_BT_RESULT_FN\n    _backup_file(filename_last, copy_file=True)\n    assert not filename.is_file()\n    store_backtest_stats(filename, stats, '2022_01_01_15_05_13')\n    last_fn = get_latest_backtest_filename(filename_last.parent)\n    assert re.match('btresult-.*\\\\.json', last_fn)\n    filename1 = tmp_path / last_fn\n    assert filename1.is_file()\n    content = filename1.read_text()\n    assert 'max_drawdown_account' in content\n    assert 'strategy' in content\n    assert 'pairlist' in content\n    assert filename_last.is_file()\n    _clean_test_file(filename_last)\n    filename1.unlink()",
            "def test_generate_backtest_stats(default_conf, testdatadir, tmp_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    default_conf.update({'strategy': CURRENT_TEST_STRATEGY})\n    StrategyResolver.load_strategy(default_conf)\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, 0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, 1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.003103, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.STOP_LOSS, ExitType.ROI, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '123'}}\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    min_date = dt_from_ts(1510688220)\n    max_date = dt_from_ts(1510700340)\n    btdata = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert strat_stats['backtest_start'] == min_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['backtest_end'] == max_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['total_trades'] == len(results['DefStrat']['results'])\n    assert strat_stats['max_drawdown_account'] == 0.0\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, -0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, -1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.0032903, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '124'}}\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert pytest.approx(strat_stats['max_drawdown_account']) == 1.399999e-08\n    assert strat_stats['drawdown_start'] == '2017-11-14 22:10:00'\n    assert strat_stats['drawdown_end'] == '2017-11-14 22:43:00'\n    assert strat_stats['drawdown_end_ts'] == 1510699380000\n    assert strat_stats['drawdown_start_ts'] == 1510697400000\n    assert strat_stats['pairlist'] == ['UNITTEST/BTC']\n    filename = tmp_path / 'btresult.json'\n    filename_last = tmp_path / LAST_BT_RESULT_FN\n    _backup_file(filename_last, copy_file=True)\n    assert not filename.is_file()\n    store_backtest_stats(filename, stats, '2022_01_01_15_05_13')\n    last_fn = get_latest_backtest_filename(filename_last.parent)\n    assert re.match('btresult-.*\\\\.json', last_fn)\n    filename1 = tmp_path / last_fn\n    assert filename1.is_file()\n    content = filename1.read_text()\n    assert 'max_drawdown_account' in content\n    assert 'strategy' in content\n    assert 'pairlist' in content\n    assert filename_last.is_file()\n    _clean_test_file(filename_last)\n    filename1.unlink()",
            "def test_generate_backtest_stats(default_conf, testdatadir, tmp_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    default_conf.update({'strategy': CURRENT_TEST_STRATEGY})\n    StrategyResolver.load_strategy(default_conf)\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, 0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, 1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.003103, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.STOP_LOSS, ExitType.ROI, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '123'}}\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    min_date = dt_from_ts(1510688220)\n    max_date = dt_from_ts(1510700340)\n    btdata = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert strat_stats['backtest_start'] == min_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['backtest_end'] == max_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['total_trades'] == len(results['DefStrat']['results'])\n    assert strat_stats['max_drawdown_account'] == 0.0\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, -0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, -1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.0032903, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '124'}}\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert pytest.approx(strat_stats['max_drawdown_account']) == 1.399999e-08\n    assert strat_stats['drawdown_start'] == '2017-11-14 22:10:00'\n    assert strat_stats['drawdown_end'] == '2017-11-14 22:43:00'\n    assert strat_stats['drawdown_end_ts'] == 1510699380000\n    assert strat_stats['drawdown_start_ts'] == 1510697400000\n    assert strat_stats['pairlist'] == ['UNITTEST/BTC']\n    filename = tmp_path / 'btresult.json'\n    filename_last = tmp_path / LAST_BT_RESULT_FN\n    _backup_file(filename_last, copy_file=True)\n    assert not filename.is_file()\n    store_backtest_stats(filename, stats, '2022_01_01_15_05_13')\n    last_fn = get_latest_backtest_filename(filename_last.parent)\n    assert re.match('btresult-.*\\\\.json', last_fn)\n    filename1 = tmp_path / last_fn\n    assert filename1.is_file()\n    content = filename1.read_text()\n    assert 'max_drawdown_account' in content\n    assert 'strategy' in content\n    assert 'pairlist' in content\n    assert filename_last.is_file()\n    _clean_test_file(filename_last)\n    filename1.unlink()",
            "def test_generate_backtest_stats(default_conf, testdatadir, tmp_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    default_conf.update({'strategy': CURRENT_TEST_STRATEGY})\n    StrategyResolver.load_strategy(default_conf)\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, 0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, 1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.003103, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.STOP_LOSS, ExitType.ROI, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '123'}}\n    timerange = TimeRange.parse_timerange('1510688220-1510700340')\n    min_date = dt_from_ts(1510688220)\n    max_date = dt_from_ts(1510700340)\n    btdata = history.load_data(testdatadir, '1m', ['UNITTEST/BTC'], timerange=timerange, fill_up_missing=True)\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert strat_stats['backtest_start'] == min_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['backtest_end'] == max_date.strftime(DATETIME_PRINT_FORMAT)\n    assert strat_stats['total_trades'] == len(results['DefStrat']['results'])\n    assert strat_stats['max_drawdown_account'] == 0.0\n    results = {'DefStrat': {'results': pd.DataFrame({'pair': ['UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC', 'UNITTEST/BTC'], 'profit_ratio': [0.003312, 0.010801, -0.013803, 0.00278], 'profit_abs': [3e-06, 1.1e-05, -1.4e-05, 3e-06], 'open_date': [dt_utc(2017, 11, 14, 19, 32, 0), dt_utc(2017, 11, 14, 21, 36, 0), dt_utc(2017, 11, 14, 22, 12, 0), dt_utc(2017, 11, 14, 22, 44, 0)], 'close_date': [dt_utc(2017, 11, 14, 21, 35, 0), dt_utc(2017, 11, 14, 22, 10, 0), dt_utc(2017, 11, 14, 22, 43, 0), dt_utc(2017, 11, 14, 22, 58, 0)], 'open_rate': [0.002543, 0.003003, 0.003089, 0.003214], 'close_rate': [0.002546, 0.003014, 0.0032903, 0.003217], 'trade_duration': [123, 34, 31, 14], 'is_open': [False, False, False, True], 'is_short': [False, False, False, False], 'stake_amount': [0.01, 0.01, 0.01, 0.01], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS, ExitType.FORCE_EXIT]}), 'config': default_conf, 'locks': [], 'final_balance': 1000.02, 'rejected_signals': 20, 'timedout_entry_orders': 0, 'timedout_exit_orders': 0, 'canceled_trade_entries': 0, 'canceled_entry_orders': 0, 'replaced_entry_orders': 0, 'backtest_start_time': dt_ts() // 1000, 'backtest_end_time': dt_ts() // 1000, 'run_id': '124'}}\n    stats = generate_backtest_stats(btdata, results, min_date, max_date)\n    assert isinstance(stats, dict)\n    assert 'strategy' in stats\n    assert 'DefStrat' in stats['strategy']\n    assert 'strategy_comparison' in stats\n    strat_stats = stats['strategy']['DefStrat']\n    assert pytest.approx(strat_stats['max_drawdown_account']) == 1.399999e-08\n    assert strat_stats['drawdown_start'] == '2017-11-14 22:10:00'\n    assert strat_stats['drawdown_end'] == '2017-11-14 22:43:00'\n    assert strat_stats['drawdown_end_ts'] == 1510699380000\n    assert strat_stats['drawdown_start_ts'] == 1510697400000\n    assert strat_stats['pairlist'] == ['UNITTEST/BTC']\n    filename = tmp_path / 'btresult.json'\n    filename_last = tmp_path / LAST_BT_RESULT_FN\n    _backup_file(filename_last, copy_file=True)\n    assert not filename.is_file()\n    store_backtest_stats(filename, stats, '2022_01_01_15_05_13')\n    last_fn = get_latest_backtest_filename(filename_last.parent)\n    assert re.match('btresult-.*\\\\.json', last_fn)\n    filename1 = tmp_path / last_fn\n    assert filename1.is_file()\n    content = filename1.read_text()\n    assert 'max_drawdown_account' in content\n    assert 'strategy' in content\n    assert 'pairlist' in content\n    assert filename_last.is_file()\n    _clean_test_file(filename_last)\n    filename1.unlink()"
        ]
    },
    {
        "func_name": "test_store_backtest_stats",
        "original": "def test_store_backtest_stats(testdatadir, mocker):\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_json')\n    data = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    store_backtest_stats(testdatadir, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'backtest-result'))\n    dump_mock.reset_mock()\n    filename = testdatadir / 'testresult.json'\n    store_backtest_stats(filename, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'testresult'))",
        "mutated": [
            "def test_store_backtest_stats(testdatadir, mocker):\n    if False:\n        i = 10\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_json')\n    data = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    store_backtest_stats(testdatadir, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'backtest-result'))\n    dump_mock.reset_mock()\n    filename = testdatadir / 'testresult.json'\n    store_backtest_stats(filename, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'testresult'))",
            "def test_store_backtest_stats(testdatadir, mocker):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_json')\n    data = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    store_backtest_stats(testdatadir, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'backtest-result'))\n    dump_mock.reset_mock()\n    filename = testdatadir / 'testresult.json'\n    store_backtest_stats(filename, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'testresult'))",
            "def test_store_backtest_stats(testdatadir, mocker):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_json')\n    data = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    store_backtest_stats(testdatadir, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'backtest-result'))\n    dump_mock.reset_mock()\n    filename = testdatadir / 'testresult.json'\n    store_backtest_stats(filename, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'testresult'))",
            "def test_store_backtest_stats(testdatadir, mocker):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_json')\n    data = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    store_backtest_stats(testdatadir, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'backtest-result'))\n    dump_mock.reset_mock()\n    filename = testdatadir / 'testresult.json'\n    store_backtest_stats(filename, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'testresult'))",
            "def test_store_backtest_stats(testdatadir, mocker):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_json')\n    data = {'metadata': {}, 'strategy': {}, 'strategy_comparison': []}\n    store_backtest_stats(testdatadir, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'backtest-result'))\n    dump_mock.reset_mock()\n    filename = testdatadir / 'testresult.json'\n    store_backtest_stats(filename, data, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 3\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).startswith(str(testdatadir / 'testresult'))"
        ]
    },
    {
        "func_name": "test_store_backtest_candles",
        "original": "def test_store_backtest_candles(testdatadir, mocker):\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_joblib')\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    store_backtest_analysis_results(testdatadir, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()\n    filename = Path(testdatadir / 'testresult')\n    store_backtest_analysis_results(filename, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()",
        "mutated": [
            "def test_store_backtest_candles(testdatadir, mocker):\n    if False:\n        i = 10\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_joblib')\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    store_backtest_analysis_results(testdatadir, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()\n    filename = Path(testdatadir / 'testresult')\n    store_backtest_analysis_results(filename, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()",
            "def test_store_backtest_candles(testdatadir, mocker):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_joblib')\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    store_backtest_analysis_results(testdatadir, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()\n    filename = Path(testdatadir / 'testresult')\n    store_backtest_analysis_results(filename, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()",
            "def test_store_backtest_candles(testdatadir, mocker):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_joblib')\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    store_backtest_analysis_results(testdatadir, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()\n    filename = Path(testdatadir / 'testresult')\n    store_backtest_analysis_results(filename, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()",
            "def test_store_backtest_candles(testdatadir, mocker):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_joblib')\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    store_backtest_analysis_results(testdatadir, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()\n    filename = Path(testdatadir / 'testresult')\n    store_backtest_analysis_results(filename, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()",
            "def test_store_backtest_candles(testdatadir, mocker):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dump_mock = mocker.patch('freqtrade.optimize.optimize_reports.bt_storage.file_dump_joblib')\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    store_backtest_analysis_results(testdatadir, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()\n    filename = Path(testdatadir / 'testresult')\n    store_backtest_analysis_results(filename, candle_dict, {}, '2022_01_01_15_05_13')\n    assert dump_mock.call_count == 2\n    assert isinstance(dump_mock.call_args_list[0][0][0], Path)\n    assert str(dump_mock.call_args_list[0][0][0]).endswith('_signals.pkl')\n    dump_mock.reset_mock()"
        ]
    },
    {
        "func_name": "test_write_read_backtest_candles",
        "original": "def test_write_read_backtest_candles(tmp_path):\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    sample_date = '2022_01_01_15_05_13'\n    store_backtest_analysis_results(tmp_path, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'backtest-result-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)\n    filename = tmp_path / 'testresult'\n    store_backtest_analysis_results(filename, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'testresult-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)",
        "mutated": [
            "def test_write_read_backtest_candles(tmp_path):\n    if False:\n        i = 10\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    sample_date = '2022_01_01_15_05_13'\n    store_backtest_analysis_results(tmp_path, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'backtest-result-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)\n    filename = tmp_path / 'testresult'\n    store_backtest_analysis_results(filename, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'testresult-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)",
            "def test_write_read_backtest_candles(tmp_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    sample_date = '2022_01_01_15_05_13'\n    store_backtest_analysis_results(tmp_path, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'backtest-result-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)\n    filename = tmp_path / 'testresult'\n    store_backtest_analysis_results(filename, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'testresult-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)",
            "def test_write_read_backtest_candles(tmp_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    sample_date = '2022_01_01_15_05_13'\n    store_backtest_analysis_results(tmp_path, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'backtest-result-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)\n    filename = tmp_path / 'testresult'\n    store_backtest_analysis_results(filename, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'testresult-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)",
            "def test_write_read_backtest_candles(tmp_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    sample_date = '2022_01_01_15_05_13'\n    store_backtest_analysis_results(tmp_path, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'backtest-result-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)\n    filename = tmp_path / 'testresult'\n    store_backtest_analysis_results(filename, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'testresult-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)",
            "def test_write_read_backtest_candles(tmp_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    candle_dict = {'DefStrat': {'UNITTEST/BTC': pd.DataFrame()}}\n    sample_date = '2022_01_01_15_05_13'\n    store_backtest_analysis_results(tmp_path, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'backtest-result-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)\n    filename = tmp_path / 'testresult'\n    store_backtest_analysis_results(filename, candle_dict, {}, sample_date)\n    stored_file = tmp_path / f'testresult-{sample_date}_signals.pkl'\n    with stored_file.open('rb') as scp:\n        pickled_signal_candles = joblib.load(scp)\n    assert pickled_signal_candles.keys() == candle_dict.keys()\n    assert pickled_signal_candles['DefStrat'].keys() == pickled_signal_candles['DefStrat'].keys()\n    assert pickled_signal_candles['DefStrat']['UNITTEST/BTC'].equals(pickled_signal_candles['DefStrat']['UNITTEST/BTC'])\n    _clean_test_file(stored_file)"
        ]
    },
    {
        "func_name": "test_generate_pair_metrics",
        "original": "def test_generate_pair_metrics():\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2], 'profit_abs': [0.2, 0.4], 'trade_duration': [10, 30], 'wins': [2, 0], 'draws': [0, 0], 'losses': [0, 0]})\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=2, results=results)\n    assert isinstance(pair_results, list)\n    assert len(pair_results) == 2\n    assert pair_results[-1]['key'] == 'TOTAL'\n    assert pytest.approx(pair_results[-1]['profit_mean_pct']) == pair_results[-1]['profit_mean'] * 100\n    assert pytest.approx(pair_results[-1]['profit_sum_pct']) == pair_results[-1]['profit_sum'] * 100",
        "mutated": [
            "def test_generate_pair_metrics():\n    if False:\n        i = 10\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2], 'profit_abs': [0.2, 0.4], 'trade_duration': [10, 30], 'wins': [2, 0], 'draws': [0, 0], 'losses': [0, 0]})\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=2, results=results)\n    assert isinstance(pair_results, list)\n    assert len(pair_results) == 2\n    assert pair_results[-1]['key'] == 'TOTAL'\n    assert pytest.approx(pair_results[-1]['profit_mean_pct']) == pair_results[-1]['profit_mean'] * 100\n    assert pytest.approx(pair_results[-1]['profit_sum_pct']) == pair_results[-1]['profit_sum'] * 100",
            "def test_generate_pair_metrics():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2], 'profit_abs': [0.2, 0.4], 'trade_duration': [10, 30], 'wins': [2, 0], 'draws': [0, 0], 'losses': [0, 0]})\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=2, results=results)\n    assert isinstance(pair_results, list)\n    assert len(pair_results) == 2\n    assert pair_results[-1]['key'] == 'TOTAL'\n    assert pytest.approx(pair_results[-1]['profit_mean_pct']) == pair_results[-1]['profit_mean'] * 100\n    assert pytest.approx(pair_results[-1]['profit_sum_pct']) == pair_results[-1]['profit_sum'] * 100",
            "def test_generate_pair_metrics():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2], 'profit_abs': [0.2, 0.4], 'trade_duration': [10, 30], 'wins': [2, 0], 'draws': [0, 0], 'losses': [0, 0]})\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=2, results=results)\n    assert isinstance(pair_results, list)\n    assert len(pair_results) == 2\n    assert pair_results[-1]['key'] == 'TOTAL'\n    assert pytest.approx(pair_results[-1]['profit_mean_pct']) == pair_results[-1]['profit_mean'] * 100\n    assert pytest.approx(pair_results[-1]['profit_sum_pct']) == pair_results[-1]['profit_sum'] * 100",
            "def test_generate_pair_metrics():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2], 'profit_abs': [0.2, 0.4], 'trade_duration': [10, 30], 'wins': [2, 0], 'draws': [0, 0], 'losses': [0, 0]})\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=2, results=results)\n    assert isinstance(pair_results, list)\n    assert len(pair_results) == 2\n    assert pair_results[-1]['key'] == 'TOTAL'\n    assert pytest.approx(pair_results[-1]['profit_mean_pct']) == pair_results[-1]['profit_mean'] * 100\n    assert pytest.approx(pair_results[-1]['profit_sum_pct']) == pair_results[-1]['profit_sum'] * 100",
            "def test_generate_pair_metrics():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2], 'profit_abs': [0.2, 0.4], 'trade_duration': [10, 30], 'wins': [2, 0], 'draws': [0, 0], 'losses': [0, 0]})\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC', starting_balance=2, results=results)\n    assert isinstance(pair_results, list)\n    assert len(pair_results) == 2\n    assert pair_results[-1]['key'] == 'TOTAL'\n    assert pytest.approx(pair_results[-1]['profit_mean_pct']) == pair_results[-1]['profit_mean'] * 100\n    assert pytest.approx(pair_results[-1]['profit_sum_pct']) == pair_results[-1]['profit_sum'] * 100"
        ]
    },
    {
        "func_name": "test_generate_daily_stats",
        "original": "def test_generate_daily_stats(testdatadir):\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_daily_stats(bt_data)\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.1796\n    assert round(res['backtest_worst_day'], 4) == -0.1468\n    assert res['winning_days'] == 19\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 2\n    res = generate_daily_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.0\n    assert res['winning_days'] == 0\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 0",
        "mutated": [
            "def test_generate_daily_stats(testdatadir):\n    if False:\n        i = 10\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_daily_stats(bt_data)\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.1796\n    assert round(res['backtest_worst_day'], 4) == -0.1468\n    assert res['winning_days'] == 19\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 2\n    res = generate_daily_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.0\n    assert res['winning_days'] == 0\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 0",
            "def test_generate_daily_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_daily_stats(bt_data)\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.1796\n    assert round(res['backtest_worst_day'], 4) == -0.1468\n    assert res['winning_days'] == 19\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 2\n    res = generate_daily_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.0\n    assert res['winning_days'] == 0\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 0",
            "def test_generate_daily_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_daily_stats(bt_data)\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.1796\n    assert round(res['backtest_worst_day'], 4) == -0.1468\n    assert res['winning_days'] == 19\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 2\n    res = generate_daily_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.0\n    assert res['winning_days'] == 0\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 0",
            "def test_generate_daily_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_daily_stats(bt_data)\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.1796\n    assert round(res['backtest_worst_day'], 4) == -0.1468\n    assert res['winning_days'] == 19\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 2\n    res = generate_daily_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.0\n    assert res['winning_days'] == 0\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 0",
            "def test_generate_daily_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_daily_stats(bt_data)\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.1796\n    assert round(res['backtest_worst_day'], 4) == -0.1468\n    assert res['winning_days'] == 19\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 2\n    res = generate_daily_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert isinstance(res, dict)\n    assert round(res['backtest_best_day'], 4) == 0.0\n    assert res['winning_days'] == 0\n    assert res['draw_days'] == 0\n    assert res['losing_days'] == 0"
        ]
    },
    {
        "func_name": "test_generate_trading_stats",
        "original": "def test_generate_trading_stats(testdatadir):\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_trading_stats(bt_data)\n    assert isinstance(res, dict)\n    assert res['winner_holding_avg'] == timedelta(seconds=1440)\n    assert res['loser_holding_avg'] == timedelta(days=1, seconds=21420)\n    assert 'wins' in res\n    assert 'losses' in res\n    assert 'draws' in res\n    res = generate_trading_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert res['wins'] == 0\n    assert res['losses'] == 0",
        "mutated": [
            "def test_generate_trading_stats(testdatadir):\n    if False:\n        i = 10\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_trading_stats(bt_data)\n    assert isinstance(res, dict)\n    assert res['winner_holding_avg'] == timedelta(seconds=1440)\n    assert res['loser_holding_avg'] == timedelta(days=1, seconds=21420)\n    assert 'wins' in res\n    assert 'losses' in res\n    assert 'draws' in res\n    res = generate_trading_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert res['wins'] == 0\n    assert res['losses'] == 0",
            "def test_generate_trading_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_trading_stats(bt_data)\n    assert isinstance(res, dict)\n    assert res['winner_holding_avg'] == timedelta(seconds=1440)\n    assert res['loser_holding_avg'] == timedelta(days=1, seconds=21420)\n    assert 'wins' in res\n    assert 'losses' in res\n    assert 'draws' in res\n    res = generate_trading_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert res['wins'] == 0\n    assert res['losses'] == 0",
            "def test_generate_trading_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_trading_stats(bt_data)\n    assert isinstance(res, dict)\n    assert res['winner_holding_avg'] == timedelta(seconds=1440)\n    assert res['loser_holding_avg'] == timedelta(days=1, seconds=21420)\n    assert 'wins' in res\n    assert 'losses' in res\n    assert 'draws' in res\n    res = generate_trading_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert res['wins'] == 0\n    assert res['losses'] == 0",
            "def test_generate_trading_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_trading_stats(bt_data)\n    assert isinstance(res, dict)\n    assert res['winner_holding_avg'] == timedelta(seconds=1440)\n    assert res['loser_holding_avg'] == timedelta(days=1, seconds=21420)\n    assert 'wins' in res\n    assert 'losses' in res\n    assert 'draws' in res\n    res = generate_trading_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert res['wins'] == 0\n    assert res['losses'] == 0",
            "def test_generate_trading_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    res = generate_trading_stats(bt_data)\n    assert isinstance(res, dict)\n    assert res['winner_holding_avg'] == timedelta(seconds=1440)\n    assert res['loser_holding_avg'] == timedelta(days=1, seconds=21420)\n    assert 'wins' in res\n    assert 'losses' in res\n    assert 'draws' in res\n    res = generate_trading_stats(bt_data.loc[bt_data['open_date'] == '2000-01-01', :])\n    assert res['wins'] == 0\n    assert res['losses'] == 0"
        ]
    },
    {
        "func_name": "test_calc_streak",
        "original": "def test_calc_streak(testdatadir):\n    df = pd.DataFrame({'profit_ratio': [0.05, -0.02, -0.03, -0.05, 0.01, 0.02, 0.03, 0.04, -0.02, -0.03]})\n    res = calc_streak(df)\n    assert res == (4, 3)\n    assert isinstance(res[0], int)\n    assert isinstance(res[1], int)\n    df1 = df.copy()\n    df1['profit_ratio'] = df1['profit_ratio'] * -1\n    assert calc_streak(df1) == (3, 4)\n    df_empty = pd.DataFrame({'profit_ratio': []})\n    assert df_empty.empty\n    assert calc_streak(df_empty) == (0, 0)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    assert calc_streak(bt_data) == (7, 18)",
        "mutated": [
            "def test_calc_streak(testdatadir):\n    if False:\n        i = 10\n    df = pd.DataFrame({'profit_ratio': [0.05, -0.02, -0.03, -0.05, 0.01, 0.02, 0.03, 0.04, -0.02, -0.03]})\n    res = calc_streak(df)\n    assert res == (4, 3)\n    assert isinstance(res[0], int)\n    assert isinstance(res[1], int)\n    df1 = df.copy()\n    df1['profit_ratio'] = df1['profit_ratio'] * -1\n    assert calc_streak(df1) == (3, 4)\n    df_empty = pd.DataFrame({'profit_ratio': []})\n    assert df_empty.empty\n    assert calc_streak(df_empty) == (0, 0)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    assert calc_streak(bt_data) == (7, 18)",
            "def test_calc_streak(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    df = pd.DataFrame({'profit_ratio': [0.05, -0.02, -0.03, -0.05, 0.01, 0.02, 0.03, 0.04, -0.02, -0.03]})\n    res = calc_streak(df)\n    assert res == (4, 3)\n    assert isinstance(res[0], int)\n    assert isinstance(res[1], int)\n    df1 = df.copy()\n    df1['profit_ratio'] = df1['profit_ratio'] * -1\n    assert calc_streak(df1) == (3, 4)\n    df_empty = pd.DataFrame({'profit_ratio': []})\n    assert df_empty.empty\n    assert calc_streak(df_empty) == (0, 0)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    assert calc_streak(bt_data) == (7, 18)",
            "def test_calc_streak(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    df = pd.DataFrame({'profit_ratio': [0.05, -0.02, -0.03, -0.05, 0.01, 0.02, 0.03, 0.04, -0.02, -0.03]})\n    res = calc_streak(df)\n    assert res == (4, 3)\n    assert isinstance(res[0], int)\n    assert isinstance(res[1], int)\n    df1 = df.copy()\n    df1['profit_ratio'] = df1['profit_ratio'] * -1\n    assert calc_streak(df1) == (3, 4)\n    df_empty = pd.DataFrame({'profit_ratio': []})\n    assert df_empty.empty\n    assert calc_streak(df_empty) == (0, 0)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    assert calc_streak(bt_data) == (7, 18)",
            "def test_calc_streak(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    df = pd.DataFrame({'profit_ratio': [0.05, -0.02, -0.03, -0.05, 0.01, 0.02, 0.03, 0.04, -0.02, -0.03]})\n    res = calc_streak(df)\n    assert res == (4, 3)\n    assert isinstance(res[0], int)\n    assert isinstance(res[1], int)\n    df1 = df.copy()\n    df1['profit_ratio'] = df1['profit_ratio'] * -1\n    assert calc_streak(df1) == (3, 4)\n    df_empty = pd.DataFrame({'profit_ratio': []})\n    assert df_empty.empty\n    assert calc_streak(df_empty) == (0, 0)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    assert calc_streak(bt_data) == (7, 18)",
            "def test_calc_streak(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    df = pd.DataFrame({'profit_ratio': [0.05, -0.02, -0.03, -0.05, 0.01, 0.02, 0.03, 0.04, -0.02, -0.03]})\n    res = calc_streak(df)\n    assert res == (4, 3)\n    assert isinstance(res[0], int)\n    assert isinstance(res[1], int)\n    df1 = df.copy()\n    df1['profit_ratio'] = df1['profit_ratio'] * -1\n    assert calc_streak(df1) == (3, 4)\n    df_empty = pd.DataFrame({'profit_ratio': []})\n    assert df_empty.empty\n    assert calc_streak(df_empty) == (0, 0)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename)\n    assert calc_streak(bt_data) == (7, 18)"
        ]
    },
    {
        "func_name": "test_text_table_exit_reason",
        "original": "def test_text_table_exit_reason():\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    result_str = '|   Exit Reason |   Exits |   Win  Draws  Loss  Win% |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |\\n|---------------+---------+--------------------------+----------------+----------------+------------------+----------------|\\n|           roi |       2 |      2     0     0   100 |             15 |             30 |              0.6 |             15 |\\n|     stop_loss |       1 |      0     0     1     0 |            -10 |            -10 |             -0.2 |             -5 |'\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    assert text_table_exit_reason(exit_reason_stats=exit_reason_stats, stake_currency='BTC') == result_str",
        "mutated": [
            "def test_text_table_exit_reason():\n    if False:\n        i = 10\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    result_str = '|   Exit Reason |   Exits |   Win  Draws  Loss  Win% |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |\\n|---------------+---------+--------------------------+----------------+----------------+------------------+----------------|\\n|           roi |       2 |      2     0     0   100 |             15 |             30 |              0.6 |             15 |\\n|     stop_loss |       1 |      0     0     1     0 |            -10 |            -10 |             -0.2 |             -5 |'\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    assert text_table_exit_reason(exit_reason_stats=exit_reason_stats, stake_currency='BTC') == result_str",
            "def test_text_table_exit_reason():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    result_str = '|   Exit Reason |   Exits |   Win  Draws  Loss  Win% |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |\\n|---------------+---------+--------------------------+----------------+----------------+------------------+----------------|\\n|           roi |       2 |      2     0     0   100 |             15 |             30 |              0.6 |             15 |\\n|     stop_loss |       1 |      0     0     1     0 |            -10 |            -10 |             -0.2 |             -5 |'\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    assert text_table_exit_reason(exit_reason_stats=exit_reason_stats, stake_currency='BTC') == result_str",
            "def test_text_table_exit_reason():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    result_str = '|   Exit Reason |   Exits |   Win  Draws  Loss  Win% |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |\\n|---------------+---------+--------------------------+----------------+----------------+------------------+----------------|\\n|           roi |       2 |      2     0     0   100 |             15 |             30 |              0.6 |             15 |\\n|     stop_loss |       1 |      0     0     1     0 |            -10 |            -10 |             -0.2 |             -5 |'\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    assert text_table_exit_reason(exit_reason_stats=exit_reason_stats, stake_currency='BTC') == result_str",
            "def test_text_table_exit_reason():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    result_str = '|   Exit Reason |   Exits |   Win  Draws  Loss  Win% |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |\\n|---------------+---------+--------------------------+----------------+----------------+------------------+----------------|\\n|           roi |       2 |      2     0     0   100 |             15 |             30 |              0.6 |             15 |\\n|     stop_loss |       1 |      0     0     1     0 |            -10 |            -10 |             -0.2 |             -5 |'\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    assert text_table_exit_reason(exit_reason_stats=exit_reason_stats, stake_currency='BTC') == result_str",
            "def test_text_table_exit_reason():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI, ExitType.ROI, ExitType.STOP_LOSS]})\n    result_str = '|   Exit Reason |   Exits |   Win  Draws  Loss  Win% |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |\\n|---------------+---------+--------------------------+----------------+----------------+------------------+----------------|\\n|           roi |       2 |      2     0     0   100 |             15 |             30 |              0.6 |             15 |\\n|     stop_loss |       1 |      0     0     1     0 |            -10 |            -10 |             -0.2 |             -5 |'\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    assert text_table_exit_reason(exit_reason_stats=exit_reason_stats, stake_currency='BTC') == result_str"
        ]
    },
    {
        "func_name": "test_generate_sell_reason_stats",
        "original": "def test_generate_sell_reason_stats():\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value, ExitType.STOP_LOSS.value]})\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    roi_result = exit_reason_stats[0]\n    assert roi_result['exit_reason'] == 'roi'\n    assert roi_result['trades'] == 2\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    stop_result = exit_reason_stats[1]\n    assert stop_result['exit_reason'] == 'stop_loss'\n    assert stop_result['trades'] == 1\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)",
        "mutated": [
            "def test_generate_sell_reason_stats():\n    if False:\n        i = 10\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value, ExitType.STOP_LOSS.value]})\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    roi_result = exit_reason_stats[0]\n    assert roi_result['exit_reason'] == 'roi'\n    assert roi_result['trades'] == 2\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    stop_result = exit_reason_stats[1]\n    assert stop_result['exit_reason'] == 'stop_loss'\n    assert stop_result['trades'] == 1\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)",
            "def test_generate_sell_reason_stats():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value, ExitType.STOP_LOSS.value]})\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    roi_result = exit_reason_stats[0]\n    assert roi_result['exit_reason'] == 'roi'\n    assert roi_result['trades'] == 2\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    stop_result = exit_reason_stats[1]\n    assert stop_result['exit_reason'] == 'stop_loss'\n    assert stop_result['trades'] == 1\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)",
            "def test_generate_sell_reason_stats():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value, ExitType.STOP_LOSS.value]})\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    roi_result = exit_reason_stats[0]\n    assert roi_result['exit_reason'] == 'roi'\n    assert roi_result['trades'] == 2\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    stop_result = exit_reason_stats[1]\n    assert stop_result['exit_reason'] == 'stop_loss'\n    assert stop_result['trades'] == 1\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)",
            "def test_generate_sell_reason_stats():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value, ExitType.STOP_LOSS.value]})\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    roi_result = exit_reason_stats[0]\n    assert roi_result['exit_reason'] == 'roi'\n    assert roi_result['trades'] == 2\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    stop_result = exit_reason_stats[1]\n    assert stop_result['exit_reason'] == 'stop_loss'\n    assert stop_result['trades'] == 1\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)",
            "def test_generate_sell_reason_stats():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC', 'ETH/BTC'], 'profit_ratio': [0.1, 0.2, -0.1], 'profit_abs': [0.2, 0.4, -0.2], 'trade_duration': [10, 30, 10], 'wins': [2, 0, 0], 'draws': [0, 0, 0], 'losses': [0, 0, 1], 'exit_reason': [ExitType.ROI.value, ExitType.ROI.value, ExitType.STOP_LOSS.value]})\n    exit_reason_stats = generate_exit_reason_stats(max_open_trades=2, results=results)\n    roi_result = exit_reason_stats[0]\n    assert roi_result['exit_reason'] == 'roi'\n    assert roi_result['trades'] == 2\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    assert pytest.approx(roi_result['profit_mean']) == 0.15\n    assert roi_result['profit_mean_pct'] == round(roi_result['profit_mean'] * 100, 2)\n    stop_result = exit_reason_stats[1]\n    assert stop_result['exit_reason'] == 'stop_loss'\n    assert stop_result['trades'] == 1\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)\n    assert pytest.approx(stop_result['profit_mean']) == -0.1\n    assert stop_result['profit_mean_pct'] == round(stop_result['profit_mean'] * 100, 2)"
        ]
    },
    {
        "func_name": "test_text_table_strategy",
        "original": "def test_text_table_strategy(testdatadir):\n    filename = testdatadir / 'backtest_results/backtest-result_multistrat.json'\n    bt_res_data = load_backtest_stats(filename)\n    bt_res_data_comparison = bt_res_data.pop('strategy_comparison')\n    result_str = '|       Strategy |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |              Drawdown |\\n|----------------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------+-----------------------|\\n| StrategyTestV2 |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |\\n|   TestStrategy |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |'\n    strategy_results = generate_strategy_comparison(bt_stats=bt_res_data['strategy'])\n    assert strategy_results == bt_res_data_comparison\n    assert text_table_strategy(strategy_results, 'BTC') == result_str",
        "mutated": [
            "def test_text_table_strategy(testdatadir):\n    if False:\n        i = 10\n    filename = testdatadir / 'backtest_results/backtest-result_multistrat.json'\n    bt_res_data = load_backtest_stats(filename)\n    bt_res_data_comparison = bt_res_data.pop('strategy_comparison')\n    result_str = '|       Strategy |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |              Drawdown |\\n|----------------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------+-----------------------|\\n| StrategyTestV2 |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |\\n|   TestStrategy |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |'\n    strategy_results = generate_strategy_comparison(bt_stats=bt_res_data['strategy'])\n    assert strategy_results == bt_res_data_comparison\n    assert text_table_strategy(strategy_results, 'BTC') == result_str",
            "def test_text_table_strategy(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    filename = testdatadir / 'backtest_results/backtest-result_multistrat.json'\n    bt_res_data = load_backtest_stats(filename)\n    bt_res_data_comparison = bt_res_data.pop('strategy_comparison')\n    result_str = '|       Strategy |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |              Drawdown |\\n|----------------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------+-----------------------|\\n| StrategyTestV2 |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |\\n|   TestStrategy |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |'\n    strategy_results = generate_strategy_comparison(bt_stats=bt_res_data['strategy'])\n    assert strategy_results == bt_res_data_comparison\n    assert text_table_strategy(strategy_results, 'BTC') == result_str",
            "def test_text_table_strategy(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    filename = testdatadir / 'backtest_results/backtest-result_multistrat.json'\n    bt_res_data = load_backtest_stats(filename)\n    bt_res_data_comparison = bt_res_data.pop('strategy_comparison')\n    result_str = '|       Strategy |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |              Drawdown |\\n|----------------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------+-----------------------|\\n| StrategyTestV2 |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |\\n|   TestStrategy |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |'\n    strategy_results = generate_strategy_comparison(bt_stats=bt_res_data['strategy'])\n    assert strategy_results == bt_res_data_comparison\n    assert text_table_strategy(strategy_results, 'BTC') == result_str",
            "def test_text_table_strategy(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    filename = testdatadir / 'backtest_results/backtest-result_multistrat.json'\n    bt_res_data = load_backtest_stats(filename)\n    bt_res_data_comparison = bt_res_data.pop('strategy_comparison')\n    result_str = '|       Strategy |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |              Drawdown |\\n|----------------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------+-----------------------|\\n| StrategyTestV2 |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |\\n|   TestStrategy |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |'\n    strategy_results = generate_strategy_comparison(bt_stats=bt_res_data['strategy'])\n    assert strategy_results == bt_res_data_comparison\n    assert text_table_strategy(strategy_results, 'BTC') == result_str",
            "def test_text_table_strategy(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    filename = testdatadir / 'backtest_results/backtest-result_multistrat.json'\n    bt_res_data = load_backtest_stats(filename)\n    bt_res_data_comparison = bt_res_data.pop('strategy_comparison')\n    result_str = '|       Strategy |   Entries |   Avg Profit % |   Cum Profit % |   Tot Profit BTC |   Tot Profit % |   Avg Duration |   Win  Draw  Loss  Win% |              Drawdown |\\n|----------------+-----------+----------------+----------------+------------------+----------------+----------------+-------------------------+-----------------------|\\n| StrategyTestV2 |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |\\n|   TestStrategy |       179 |           0.08 |          14.39 |       0.02608550 |         260.85 |        3:40:00 |   170     0     9  95.0 | 0.00308222 BTC  8.67% |'\n    strategy_results = generate_strategy_comparison(bt_stats=bt_res_data['strategy'])\n    assert strategy_results == bt_res_data_comparison\n    assert text_table_strategy(strategy_results, 'BTC') == result_str"
        ]
    },
    {
        "func_name": "test_generate_edge_table",
        "original": "def test_generate_edge_table():\n    results = {}\n    results['ETH/BTC'] = PairInfo(-0.01, 0.6, 2, 1, 3, 10, 60)\n    assert generate_edge_table(results).count('+') == 7\n    assert generate_edge_table(results).count('| ETH/BTC |') == 1\n    assert generate_edge_table(results).count('|   Risk Reward Ratio |   Required Risk Reward |   Expectancy |') == 1",
        "mutated": [
            "def test_generate_edge_table():\n    if False:\n        i = 10\n    results = {}\n    results['ETH/BTC'] = PairInfo(-0.01, 0.6, 2, 1, 3, 10, 60)\n    assert generate_edge_table(results).count('+') == 7\n    assert generate_edge_table(results).count('| ETH/BTC |') == 1\n    assert generate_edge_table(results).count('|   Risk Reward Ratio |   Required Risk Reward |   Expectancy |') == 1",
            "def test_generate_edge_table():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    results = {}\n    results['ETH/BTC'] = PairInfo(-0.01, 0.6, 2, 1, 3, 10, 60)\n    assert generate_edge_table(results).count('+') == 7\n    assert generate_edge_table(results).count('| ETH/BTC |') == 1\n    assert generate_edge_table(results).count('|   Risk Reward Ratio |   Required Risk Reward |   Expectancy |') == 1",
            "def test_generate_edge_table():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    results = {}\n    results['ETH/BTC'] = PairInfo(-0.01, 0.6, 2, 1, 3, 10, 60)\n    assert generate_edge_table(results).count('+') == 7\n    assert generate_edge_table(results).count('| ETH/BTC |') == 1\n    assert generate_edge_table(results).count('|   Risk Reward Ratio |   Required Risk Reward |   Expectancy |') == 1",
            "def test_generate_edge_table():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    results = {}\n    results['ETH/BTC'] = PairInfo(-0.01, 0.6, 2, 1, 3, 10, 60)\n    assert generate_edge_table(results).count('+') == 7\n    assert generate_edge_table(results).count('| ETH/BTC |') == 1\n    assert generate_edge_table(results).count('|   Risk Reward Ratio |   Required Risk Reward |   Expectancy |') == 1",
            "def test_generate_edge_table():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    results = {}\n    results['ETH/BTC'] = PairInfo(-0.01, 0.6, 2, 1, 3, 10, 60)\n    assert generate_edge_table(results).count('+') == 7\n    assert generate_edge_table(results).count('| ETH/BTC |') == 1\n    assert generate_edge_table(results).count('|   Risk Reward Ratio |   Required Risk Reward |   Expectancy |') == 1"
        ]
    },
    {
        "func_name": "test_generate_periodic_breakdown_stats",
        "original": "def test_generate_periodic_breakdown_stats(testdatadir):\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename).to_dict(orient='records')\n    res = generate_periodic_breakdown_stats(bt_data, 'day')\n    assert isinstance(res, list)\n    assert len(res) == 21\n    day = res[0]\n    assert 'date' in day\n    assert 'draws' in day\n    assert 'loses' in day\n    assert 'wins' in day\n    assert 'profit_abs' in day\n    res = generate_periodic_breakdown_stats([], 'day')\n    assert res == []",
        "mutated": [
            "def test_generate_periodic_breakdown_stats(testdatadir):\n    if False:\n        i = 10\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename).to_dict(orient='records')\n    res = generate_periodic_breakdown_stats(bt_data, 'day')\n    assert isinstance(res, list)\n    assert len(res) == 21\n    day = res[0]\n    assert 'date' in day\n    assert 'draws' in day\n    assert 'loses' in day\n    assert 'wins' in day\n    assert 'profit_abs' in day\n    res = generate_periodic_breakdown_stats([], 'day')\n    assert res == []",
            "def test_generate_periodic_breakdown_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename).to_dict(orient='records')\n    res = generate_periodic_breakdown_stats(bt_data, 'day')\n    assert isinstance(res, list)\n    assert len(res) == 21\n    day = res[0]\n    assert 'date' in day\n    assert 'draws' in day\n    assert 'loses' in day\n    assert 'wins' in day\n    assert 'profit_abs' in day\n    res = generate_periodic_breakdown_stats([], 'day')\n    assert res == []",
            "def test_generate_periodic_breakdown_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename).to_dict(orient='records')\n    res = generate_periodic_breakdown_stats(bt_data, 'day')\n    assert isinstance(res, list)\n    assert len(res) == 21\n    day = res[0]\n    assert 'date' in day\n    assert 'draws' in day\n    assert 'loses' in day\n    assert 'wins' in day\n    assert 'profit_abs' in day\n    res = generate_periodic_breakdown_stats([], 'day')\n    assert res == []",
            "def test_generate_periodic_breakdown_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename).to_dict(orient='records')\n    res = generate_periodic_breakdown_stats(bt_data, 'day')\n    assert isinstance(res, list)\n    assert len(res) == 21\n    day = res[0]\n    assert 'date' in day\n    assert 'draws' in day\n    assert 'loses' in day\n    assert 'wins' in day\n    assert 'profit_abs' in day\n    res = generate_periodic_breakdown_stats([], 'day')\n    assert res == []",
            "def test_generate_periodic_breakdown_stats(testdatadir):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_data(filename).to_dict(orient='records')\n    res = generate_periodic_breakdown_stats(bt_data, 'day')\n    assert isinstance(res, list)\n    assert len(res) == 21\n    day = res[0]\n    assert 'date' in day\n    assert 'draws' in day\n    assert 'loses' in day\n    assert 'wins' in day\n    assert 'profit_abs' in day\n    res = generate_periodic_breakdown_stats([], 'day')\n    assert res == []"
        ]
    },
    {
        "func_name": "test__get_resample_from_period",
        "original": "def test__get_resample_from_period():\n    assert _get_resample_from_period('day') == '1d'\n    assert _get_resample_from_period('week') == '1W-MON'\n    assert _get_resample_from_period('month') == '1M'\n    with pytest.raises(ValueError, match='Period noooo is not supported.'):\n        _get_resample_from_period('noooo')\n    for period in BACKTEST_BREAKDOWNS:\n        assert isinstance(_get_resample_from_period(period), str)",
        "mutated": [
            "def test__get_resample_from_period():\n    if False:\n        i = 10\n    assert _get_resample_from_period('day') == '1d'\n    assert _get_resample_from_period('week') == '1W-MON'\n    assert _get_resample_from_period('month') == '1M'\n    with pytest.raises(ValueError, match='Period noooo is not supported.'):\n        _get_resample_from_period('noooo')\n    for period in BACKTEST_BREAKDOWNS:\n        assert isinstance(_get_resample_from_period(period), str)",
            "def test__get_resample_from_period():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert _get_resample_from_period('day') == '1d'\n    assert _get_resample_from_period('week') == '1W-MON'\n    assert _get_resample_from_period('month') == '1M'\n    with pytest.raises(ValueError, match='Period noooo is not supported.'):\n        _get_resample_from_period('noooo')\n    for period in BACKTEST_BREAKDOWNS:\n        assert isinstance(_get_resample_from_period(period), str)",
            "def test__get_resample_from_period():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert _get_resample_from_period('day') == '1d'\n    assert _get_resample_from_period('week') == '1W-MON'\n    assert _get_resample_from_period('month') == '1M'\n    with pytest.raises(ValueError, match='Period noooo is not supported.'):\n        _get_resample_from_period('noooo')\n    for period in BACKTEST_BREAKDOWNS:\n        assert isinstance(_get_resample_from_period(period), str)",
            "def test__get_resample_from_period():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert _get_resample_from_period('day') == '1d'\n    assert _get_resample_from_period('week') == '1W-MON'\n    assert _get_resample_from_period('month') == '1M'\n    with pytest.raises(ValueError, match='Period noooo is not supported.'):\n        _get_resample_from_period('noooo')\n    for period in BACKTEST_BREAKDOWNS:\n        assert isinstance(_get_resample_from_period(period), str)",
            "def test__get_resample_from_period():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert _get_resample_from_period('day') == '1d'\n    assert _get_resample_from_period('week') == '1W-MON'\n    assert _get_resample_from_period('month') == '1M'\n    with pytest.raises(ValueError, match='Period noooo is not supported.'):\n        _get_resample_from_period('noooo')\n    for period in BACKTEST_BREAKDOWNS:\n        assert isinstance(_get_resample_from_period(period), str)"
        ]
    },
    {
        "func_name": "test_show_sorted_pairlist",
        "original": "def test_show_sorted_pairlist(testdatadir, default_conf, capsys):\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_stats(filename)\n    default_conf['backtest_show_pair_list'] = True\n    show_sorted_pairlist(default_conf, bt_data)\n    (out, err) = capsys.readouterr()\n    assert 'Pairs for Strategy StrategyTestV3: \\n[' in out\n    assert 'TOTAL' not in out\n    assert '\"ETH/BTC\",  // ' in out",
        "mutated": [
            "def test_show_sorted_pairlist(testdatadir, default_conf, capsys):\n    if False:\n        i = 10\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_stats(filename)\n    default_conf['backtest_show_pair_list'] = True\n    show_sorted_pairlist(default_conf, bt_data)\n    (out, err) = capsys.readouterr()\n    assert 'Pairs for Strategy StrategyTestV3: \\n[' in out\n    assert 'TOTAL' not in out\n    assert '\"ETH/BTC\",  // ' in out",
            "def test_show_sorted_pairlist(testdatadir, default_conf, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_stats(filename)\n    default_conf['backtest_show_pair_list'] = True\n    show_sorted_pairlist(default_conf, bt_data)\n    (out, err) = capsys.readouterr()\n    assert 'Pairs for Strategy StrategyTestV3: \\n[' in out\n    assert 'TOTAL' not in out\n    assert '\"ETH/BTC\",  // ' in out",
            "def test_show_sorted_pairlist(testdatadir, default_conf, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_stats(filename)\n    default_conf['backtest_show_pair_list'] = True\n    show_sorted_pairlist(default_conf, bt_data)\n    (out, err) = capsys.readouterr()\n    assert 'Pairs for Strategy StrategyTestV3: \\n[' in out\n    assert 'TOTAL' not in out\n    assert '\"ETH/BTC\",  // ' in out",
            "def test_show_sorted_pairlist(testdatadir, default_conf, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_stats(filename)\n    default_conf['backtest_show_pair_list'] = True\n    show_sorted_pairlist(default_conf, bt_data)\n    (out, err) = capsys.readouterr()\n    assert 'Pairs for Strategy StrategyTestV3: \\n[' in out\n    assert 'TOTAL' not in out\n    assert '\"ETH/BTC\",  // ' in out",
            "def test_show_sorted_pairlist(testdatadir, default_conf, capsys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    filename = testdatadir / 'backtest_results/backtest-result.json'\n    bt_data = load_backtest_stats(filename)\n    default_conf['backtest_show_pair_list'] = True\n    show_sorted_pairlist(default_conf, bt_data)\n    (out, err) = capsys.readouterr()\n    assert 'Pairs for Strategy StrategyTestV3: \\n[' in out\n    assert 'TOTAL' not in out\n    assert '\"ETH/BTC\",  // ' in out"
        ]
    }
]