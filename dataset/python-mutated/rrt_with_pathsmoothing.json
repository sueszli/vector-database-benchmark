[
    {
        "func_name": "get_path_length",
        "original": "def get_path_length(path):\n    le = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n    return le",
        "mutated": [
            "def get_path_length(path):\n    if False:\n        i = 10\n    le = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n    return le",
            "def get_path_length(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    le = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n    return le",
            "def get_path_length(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    le = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n    return le",
            "def get_path_length(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    le = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n    return le",
            "def get_path_length(path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    le = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n    return le"
        ]
    },
    {
        "func_name": "get_target_point",
        "original": "def get_target_point(path, targetL):\n    le = 0\n    ti = 0\n    lastPairLen = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n        if le >= targetL:\n            ti = i - 1\n            lastPairLen = d\n            break\n    partRatio = (le - targetL) / lastPairLen\n    x = path[ti][0] + (path[ti + 1][0] - path[ti][0]) * partRatio\n    y = path[ti][1] + (path[ti + 1][1] - path[ti][1]) * partRatio\n    return [x, y, ti]",
        "mutated": [
            "def get_target_point(path, targetL):\n    if False:\n        i = 10\n    le = 0\n    ti = 0\n    lastPairLen = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n        if le >= targetL:\n            ti = i - 1\n            lastPairLen = d\n            break\n    partRatio = (le - targetL) / lastPairLen\n    x = path[ti][0] + (path[ti + 1][0] - path[ti][0]) * partRatio\n    y = path[ti][1] + (path[ti + 1][1] - path[ti][1]) * partRatio\n    return [x, y, ti]",
            "def get_target_point(path, targetL):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    le = 0\n    ti = 0\n    lastPairLen = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n        if le >= targetL:\n            ti = i - 1\n            lastPairLen = d\n            break\n    partRatio = (le - targetL) / lastPairLen\n    x = path[ti][0] + (path[ti + 1][0] - path[ti][0]) * partRatio\n    y = path[ti][1] + (path[ti + 1][1] - path[ti][1]) * partRatio\n    return [x, y, ti]",
            "def get_target_point(path, targetL):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    le = 0\n    ti = 0\n    lastPairLen = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n        if le >= targetL:\n            ti = i - 1\n            lastPairLen = d\n            break\n    partRatio = (le - targetL) / lastPairLen\n    x = path[ti][0] + (path[ti + 1][0] - path[ti][0]) * partRatio\n    y = path[ti][1] + (path[ti + 1][1] - path[ti][1]) * partRatio\n    return [x, y, ti]",
            "def get_target_point(path, targetL):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    le = 0\n    ti = 0\n    lastPairLen = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n        if le >= targetL:\n            ti = i - 1\n            lastPairLen = d\n            break\n    partRatio = (le - targetL) / lastPairLen\n    x = path[ti][0] + (path[ti + 1][0] - path[ti][0]) * partRatio\n    y = path[ti][1] + (path[ti + 1][1] - path[ti][1]) * partRatio\n    return [x, y, ti]",
            "def get_target_point(path, targetL):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    le = 0\n    ti = 0\n    lastPairLen = 0\n    for i in range(len(path) - 1):\n        dx = path[i + 1][0] - path[i][0]\n        dy = path[i + 1][1] - path[i][1]\n        d = math.hypot(dx, dy)\n        le += d\n        if le >= targetL:\n            ti = i - 1\n            lastPairLen = d\n            break\n    partRatio = (le - targetL) / lastPairLen\n    x = path[ti][0] + (path[ti + 1][0] - path[ti][0]) * partRatio\n    y = path[ti][1] + (path[ti + 1][1] - path[ti][1]) * partRatio\n    return [x, y, ti]"
        ]
    },
    {
        "func_name": "line_collision_check",
        "original": "def line_collision_check(first, second, obstacleList):\n    x1 = first[0]\n    y1 = first[1]\n    x2 = second[0]\n    y2 = second[1]\n    try:\n        a = y2 - y1\n        b = -(x2 - x1)\n        c = y2 * (x2 - x1) - x2 * (y2 - y1)\n    except ZeroDivisionError:\n        return False\n    for (ox, oy, size) in obstacleList:\n        d = abs(a * ox + b * oy + c) / math.hypot(a, b)\n        if d <= size:\n            return False\n    return True",
        "mutated": [
            "def line_collision_check(first, second, obstacleList):\n    if False:\n        i = 10\n    x1 = first[0]\n    y1 = first[1]\n    x2 = second[0]\n    y2 = second[1]\n    try:\n        a = y2 - y1\n        b = -(x2 - x1)\n        c = y2 * (x2 - x1) - x2 * (y2 - y1)\n    except ZeroDivisionError:\n        return False\n    for (ox, oy, size) in obstacleList:\n        d = abs(a * ox + b * oy + c) / math.hypot(a, b)\n        if d <= size:\n            return False\n    return True",
            "def line_collision_check(first, second, obstacleList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x1 = first[0]\n    y1 = first[1]\n    x2 = second[0]\n    y2 = second[1]\n    try:\n        a = y2 - y1\n        b = -(x2 - x1)\n        c = y2 * (x2 - x1) - x2 * (y2 - y1)\n    except ZeroDivisionError:\n        return False\n    for (ox, oy, size) in obstacleList:\n        d = abs(a * ox + b * oy + c) / math.hypot(a, b)\n        if d <= size:\n            return False\n    return True",
            "def line_collision_check(first, second, obstacleList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x1 = first[0]\n    y1 = first[1]\n    x2 = second[0]\n    y2 = second[1]\n    try:\n        a = y2 - y1\n        b = -(x2 - x1)\n        c = y2 * (x2 - x1) - x2 * (y2 - y1)\n    except ZeroDivisionError:\n        return False\n    for (ox, oy, size) in obstacleList:\n        d = abs(a * ox + b * oy + c) / math.hypot(a, b)\n        if d <= size:\n            return False\n    return True",
            "def line_collision_check(first, second, obstacleList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x1 = first[0]\n    y1 = first[1]\n    x2 = second[0]\n    y2 = second[1]\n    try:\n        a = y2 - y1\n        b = -(x2 - x1)\n        c = y2 * (x2 - x1) - x2 * (y2 - y1)\n    except ZeroDivisionError:\n        return False\n    for (ox, oy, size) in obstacleList:\n        d = abs(a * ox + b * oy + c) / math.hypot(a, b)\n        if d <= size:\n            return False\n    return True",
            "def line_collision_check(first, second, obstacleList):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x1 = first[0]\n    y1 = first[1]\n    x2 = second[0]\n    y2 = second[1]\n    try:\n        a = y2 - y1\n        b = -(x2 - x1)\n        c = y2 * (x2 - x1) - x2 * (y2 - y1)\n    except ZeroDivisionError:\n        return False\n    for (ox, oy, size) in obstacleList:\n        d = abs(a * ox + b * oy + c) / math.hypot(a, b)\n        if d <= size:\n            return False\n    return True"
        ]
    },
    {
        "func_name": "path_smoothing",
        "original": "def path_smoothing(path, max_iter, obstacle_list):\n    le = get_path_length(path)\n    for i in range(max_iter):\n        pickPoints = [random.uniform(0, le), random.uniform(0, le)]\n        pickPoints.sort()\n        first = get_target_point(path, pickPoints[0])\n        second = get_target_point(path, pickPoints[1])\n        if first[2] <= 0 or second[2] <= 0:\n            continue\n        if second[2] + 1 > len(path):\n            continue\n        if second[2] == first[2]:\n            continue\n        if not line_collision_check(first, second, obstacle_list):\n            continue\n        newPath = []\n        newPath.extend(path[:first[2] + 1])\n        newPath.append([first[0], first[1]])\n        newPath.append([second[0], second[1]])\n        newPath.extend(path[second[2] + 1:])\n        path = newPath\n        le = get_path_length(path)\n    return path",
        "mutated": [
            "def path_smoothing(path, max_iter, obstacle_list):\n    if False:\n        i = 10\n    le = get_path_length(path)\n    for i in range(max_iter):\n        pickPoints = [random.uniform(0, le), random.uniform(0, le)]\n        pickPoints.sort()\n        first = get_target_point(path, pickPoints[0])\n        second = get_target_point(path, pickPoints[1])\n        if first[2] <= 0 or second[2] <= 0:\n            continue\n        if second[2] + 1 > len(path):\n            continue\n        if second[2] == first[2]:\n            continue\n        if not line_collision_check(first, second, obstacle_list):\n            continue\n        newPath = []\n        newPath.extend(path[:first[2] + 1])\n        newPath.append([first[0], first[1]])\n        newPath.append([second[0], second[1]])\n        newPath.extend(path[second[2] + 1:])\n        path = newPath\n        le = get_path_length(path)\n    return path",
            "def path_smoothing(path, max_iter, obstacle_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    le = get_path_length(path)\n    for i in range(max_iter):\n        pickPoints = [random.uniform(0, le), random.uniform(0, le)]\n        pickPoints.sort()\n        first = get_target_point(path, pickPoints[0])\n        second = get_target_point(path, pickPoints[1])\n        if first[2] <= 0 or second[2] <= 0:\n            continue\n        if second[2] + 1 > len(path):\n            continue\n        if second[2] == first[2]:\n            continue\n        if not line_collision_check(first, second, obstacle_list):\n            continue\n        newPath = []\n        newPath.extend(path[:first[2] + 1])\n        newPath.append([first[0], first[1]])\n        newPath.append([second[0], second[1]])\n        newPath.extend(path[second[2] + 1:])\n        path = newPath\n        le = get_path_length(path)\n    return path",
            "def path_smoothing(path, max_iter, obstacle_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    le = get_path_length(path)\n    for i in range(max_iter):\n        pickPoints = [random.uniform(0, le), random.uniform(0, le)]\n        pickPoints.sort()\n        first = get_target_point(path, pickPoints[0])\n        second = get_target_point(path, pickPoints[1])\n        if first[2] <= 0 or second[2] <= 0:\n            continue\n        if second[2] + 1 > len(path):\n            continue\n        if second[2] == first[2]:\n            continue\n        if not line_collision_check(first, second, obstacle_list):\n            continue\n        newPath = []\n        newPath.extend(path[:first[2] + 1])\n        newPath.append([first[0], first[1]])\n        newPath.append([second[0], second[1]])\n        newPath.extend(path[second[2] + 1:])\n        path = newPath\n        le = get_path_length(path)\n    return path",
            "def path_smoothing(path, max_iter, obstacle_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    le = get_path_length(path)\n    for i in range(max_iter):\n        pickPoints = [random.uniform(0, le), random.uniform(0, le)]\n        pickPoints.sort()\n        first = get_target_point(path, pickPoints[0])\n        second = get_target_point(path, pickPoints[1])\n        if first[2] <= 0 or second[2] <= 0:\n            continue\n        if second[2] + 1 > len(path):\n            continue\n        if second[2] == first[2]:\n            continue\n        if not line_collision_check(first, second, obstacle_list):\n            continue\n        newPath = []\n        newPath.extend(path[:first[2] + 1])\n        newPath.append([first[0], first[1]])\n        newPath.append([second[0], second[1]])\n        newPath.extend(path[second[2] + 1:])\n        path = newPath\n        le = get_path_length(path)\n    return path",
            "def path_smoothing(path, max_iter, obstacle_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    le = get_path_length(path)\n    for i in range(max_iter):\n        pickPoints = [random.uniform(0, le), random.uniform(0, le)]\n        pickPoints.sort()\n        first = get_target_point(path, pickPoints[0])\n        second = get_target_point(path, pickPoints[1])\n        if first[2] <= 0 or second[2] <= 0:\n            continue\n        if second[2] + 1 > len(path):\n            continue\n        if second[2] == first[2]:\n            continue\n        if not line_collision_check(first, second, obstacle_list):\n            continue\n        newPath = []\n        newPath.extend(path[:first[2] + 1])\n        newPath.append([first[0], first[1]])\n        newPath.append([second[0], second[1]])\n        newPath.extend(path[second[2] + 1:])\n        path = newPath\n        le = get_path_length(path)\n    return path"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    obstacleList = [(5, 5, 1), (3, 6, 2), (3, 8, 2), (3, 10, 2), (7, 5, 2), (9, 5, 2)]\n    rrt = RRT(start=[0, 0], goal=[6, 10], rand_area=[-2, 15], obstacle_list=obstacleList)\n    path = rrt.planning(animation=show_animation)\n    maxIter = 1000\n    smoothedPath = path_smoothing(path, maxIter, obstacleList)\n    if show_animation:\n        rrt.draw_graph()\n        plt.plot([x for (x, y) in path], [y for (x, y) in path], '-r')\n        plt.plot([x for (x, y) in smoothedPath], [y for (x, y) in smoothedPath], '-c')\n        plt.grid(True)\n        plt.pause(0.01)\n        plt.show()",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    obstacleList = [(5, 5, 1), (3, 6, 2), (3, 8, 2), (3, 10, 2), (7, 5, 2), (9, 5, 2)]\n    rrt = RRT(start=[0, 0], goal=[6, 10], rand_area=[-2, 15], obstacle_list=obstacleList)\n    path = rrt.planning(animation=show_animation)\n    maxIter = 1000\n    smoothedPath = path_smoothing(path, maxIter, obstacleList)\n    if show_animation:\n        rrt.draw_graph()\n        plt.plot([x for (x, y) in path], [y for (x, y) in path], '-r')\n        plt.plot([x for (x, y) in smoothedPath], [y for (x, y) in smoothedPath], '-c')\n        plt.grid(True)\n        plt.pause(0.01)\n        plt.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    obstacleList = [(5, 5, 1), (3, 6, 2), (3, 8, 2), (3, 10, 2), (7, 5, 2), (9, 5, 2)]\n    rrt = RRT(start=[0, 0], goal=[6, 10], rand_area=[-2, 15], obstacle_list=obstacleList)\n    path = rrt.planning(animation=show_animation)\n    maxIter = 1000\n    smoothedPath = path_smoothing(path, maxIter, obstacleList)\n    if show_animation:\n        rrt.draw_graph()\n        plt.plot([x for (x, y) in path], [y for (x, y) in path], '-r')\n        plt.plot([x for (x, y) in smoothedPath], [y for (x, y) in smoothedPath], '-c')\n        plt.grid(True)\n        plt.pause(0.01)\n        plt.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    obstacleList = [(5, 5, 1), (3, 6, 2), (3, 8, 2), (3, 10, 2), (7, 5, 2), (9, 5, 2)]\n    rrt = RRT(start=[0, 0], goal=[6, 10], rand_area=[-2, 15], obstacle_list=obstacleList)\n    path = rrt.planning(animation=show_animation)\n    maxIter = 1000\n    smoothedPath = path_smoothing(path, maxIter, obstacleList)\n    if show_animation:\n        rrt.draw_graph()\n        plt.plot([x for (x, y) in path], [y for (x, y) in path], '-r')\n        plt.plot([x for (x, y) in smoothedPath], [y for (x, y) in smoothedPath], '-c')\n        plt.grid(True)\n        plt.pause(0.01)\n        plt.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    obstacleList = [(5, 5, 1), (3, 6, 2), (3, 8, 2), (3, 10, 2), (7, 5, 2), (9, 5, 2)]\n    rrt = RRT(start=[0, 0], goal=[6, 10], rand_area=[-2, 15], obstacle_list=obstacleList)\n    path = rrt.planning(animation=show_animation)\n    maxIter = 1000\n    smoothedPath = path_smoothing(path, maxIter, obstacleList)\n    if show_animation:\n        rrt.draw_graph()\n        plt.plot([x for (x, y) in path], [y for (x, y) in path], '-r')\n        plt.plot([x for (x, y) in smoothedPath], [y for (x, y) in smoothedPath], '-c')\n        plt.grid(True)\n        plt.pause(0.01)\n        plt.show()",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    obstacleList = [(5, 5, 1), (3, 6, 2), (3, 8, 2), (3, 10, 2), (7, 5, 2), (9, 5, 2)]\n    rrt = RRT(start=[0, 0], goal=[6, 10], rand_area=[-2, 15], obstacle_list=obstacleList)\n    path = rrt.planning(animation=show_animation)\n    maxIter = 1000\n    smoothedPath = path_smoothing(path, maxIter, obstacleList)\n    if show_animation:\n        rrt.draw_graph()\n        plt.plot([x for (x, y) in path], [y for (x, y) in path], '-r')\n        plt.plot([x for (x, y) in smoothedPath], [y for (x, y) in smoothedPath], '-c')\n        plt.grid(True)\n        plt.pause(0.01)\n        plt.show()"
        ]
    }
]