[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    Only works on Windows systems.\n    \"\"\"\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_snmp: Requires Windows')\n    if not __utils__['reg.key_exists'](_HKEY, _SNMP_KEY):\n        return (False, 'Module win_snmp: SNMP not installed')\n    return __virtualname__",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    Only works on Windows systems.\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_snmp: Requires Windows')\n    if not __utils__['reg.key_exists'](_HKEY, _SNMP_KEY):\n        return (False, 'Module win_snmp: SNMP not installed')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Only works on Windows systems.\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_snmp: Requires Windows')\n    if not __utils__['reg.key_exists'](_HKEY, _SNMP_KEY):\n        return (False, 'Module win_snmp: SNMP not installed')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Only works on Windows systems.\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_snmp: Requires Windows')\n    if not __utils__['reg.key_exists'](_HKEY, _SNMP_KEY):\n        return (False, 'Module win_snmp: SNMP not installed')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Only works on Windows systems.\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_snmp: Requires Windows')\n    if not __utils__['reg.key_exists'](_HKEY, _SNMP_KEY):\n        return (False, 'Module win_snmp: SNMP not installed')\n    return __virtualname__",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Only works on Windows systems.\\n    '\n    if not salt.utils.platform.is_windows():\n        return (False, 'Module win_snmp: Requires Windows')\n    if not __utils__['reg.key_exists'](_HKEY, _SNMP_KEY):\n        return (False, 'Module win_snmp: SNMP not installed')\n    return __virtualname__"
        ]
    },
    {
        "func_name": "get_agent_service_types",
        "original": "def get_agent_service_types():\n    \"\"\"\n    Get the sysServices types that can be configured.\n\n    Returns:\n        list: A list of service types.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' win_snmp.get_agent_service_types\n    \"\"\"\n    return list(_SERVICE_TYPES)",
        "mutated": [
            "def get_agent_service_types():\n    if False:\n        i = 10\n    \"\\n    Get the sysServices types that can be configured.\\n\\n    Returns:\\n        list: A list of service types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_service_types\\n    \"\n    return list(_SERVICE_TYPES)",
            "def get_agent_service_types():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Get the sysServices types that can be configured.\\n\\n    Returns:\\n        list: A list of service types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_service_types\\n    \"\n    return list(_SERVICE_TYPES)",
            "def get_agent_service_types():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Get the sysServices types that can be configured.\\n\\n    Returns:\\n        list: A list of service types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_service_types\\n    \"\n    return list(_SERVICE_TYPES)",
            "def get_agent_service_types():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Get the sysServices types that can be configured.\\n\\n    Returns:\\n        list: A list of service types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_service_types\\n    \"\n    return list(_SERVICE_TYPES)",
            "def get_agent_service_types():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Get the sysServices types that can be configured.\\n\\n    Returns:\\n        list: A list of service types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_service_types\\n    \"\n    return list(_SERVICE_TYPES)"
        ]
    },
    {
        "func_name": "get_permission_types",
        "original": "def get_permission_types():\n    \"\"\"\n    Get the permission types that can be configured for communities.\n\n    Returns:\n        list: A list of permission types.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' win_snmp.get_permission_types\n    \"\"\"\n    return list(_PERMISSION_TYPES)",
        "mutated": [
            "def get_permission_types():\n    if False:\n        i = 10\n    \"\\n    Get the permission types that can be configured for communities.\\n\\n    Returns:\\n        list: A list of permission types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_permission_types\\n    \"\n    return list(_PERMISSION_TYPES)",
            "def get_permission_types():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Get the permission types that can be configured for communities.\\n\\n    Returns:\\n        list: A list of permission types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_permission_types\\n    \"\n    return list(_PERMISSION_TYPES)",
            "def get_permission_types():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Get the permission types that can be configured for communities.\\n\\n    Returns:\\n        list: A list of permission types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_permission_types\\n    \"\n    return list(_PERMISSION_TYPES)",
            "def get_permission_types():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Get the permission types that can be configured for communities.\\n\\n    Returns:\\n        list: A list of permission types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_permission_types\\n    \"\n    return list(_PERMISSION_TYPES)",
            "def get_permission_types():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Get the permission types that can be configured for communities.\\n\\n    Returns:\\n        list: A list of permission types.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_permission_types\\n    \"\n    return list(_PERMISSION_TYPES)"
        ]
    },
    {
        "func_name": "get_agent_settings",
        "original": "def get_agent_settings():\n    \"\"\"\n    Determine the value of the SNMP sysContact, sysLocation, and sysServices\n    settings.\n\n    Returns:\n        dict: A dictionary of the agent settings.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' win_snmp.get_agent_settings\n    \"\"\"\n    ret = dict()\n    sorted_types = sorted(_SERVICE_TYPES.items(), key=lambda x: (-x[1], x[0]))\n    ret['services'] = list()\n    ret['contact'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysContact')['vdata']\n    ret['location'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysLocation')['vdata']\n    current_bitmask = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysServices')['vdata']\n    if current_bitmask == 0:\n        ret['services'].append(sorted_types[-1][0])\n    else:\n        for (service, bitmask) in sorted_types:\n            if current_bitmask is not None and current_bitmask > 0:\n                remaining_bitmask = current_bitmask - bitmask\n                if remaining_bitmask >= 0:\n                    current_bitmask = remaining_bitmask\n                    ret['services'].append(service)\n            else:\n                break\n    ret['services'] = sorted(ret['services'])\n    return ret",
        "mutated": [
            "def get_agent_settings():\n    if False:\n        i = 10\n    \"\\n    Determine the value of the SNMP sysContact, sysLocation, and sysServices\\n    settings.\\n\\n    Returns:\\n        dict: A dictionary of the agent settings.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_settings\\n    \"\n    ret = dict()\n    sorted_types = sorted(_SERVICE_TYPES.items(), key=lambda x: (-x[1], x[0]))\n    ret['services'] = list()\n    ret['contact'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysContact')['vdata']\n    ret['location'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysLocation')['vdata']\n    current_bitmask = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysServices')['vdata']\n    if current_bitmask == 0:\n        ret['services'].append(sorted_types[-1][0])\n    else:\n        for (service, bitmask) in sorted_types:\n            if current_bitmask is not None and current_bitmask > 0:\n                remaining_bitmask = current_bitmask - bitmask\n                if remaining_bitmask >= 0:\n                    current_bitmask = remaining_bitmask\n                    ret['services'].append(service)\n            else:\n                break\n    ret['services'] = sorted(ret['services'])\n    return ret",
            "def get_agent_settings():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Determine the value of the SNMP sysContact, sysLocation, and sysServices\\n    settings.\\n\\n    Returns:\\n        dict: A dictionary of the agent settings.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_settings\\n    \"\n    ret = dict()\n    sorted_types = sorted(_SERVICE_TYPES.items(), key=lambda x: (-x[1], x[0]))\n    ret['services'] = list()\n    ret['contact'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysContact')['vdata']\n    ret['location'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysLocation')['vdata']\n    current_bitmask = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysServices')['vdata']\n    if current_bitmask == 0:\n        ret['services'].append(sorted_types[-1][0])\n    else:\n        for (service, bitmask) in sorted_types:\n            if current_bitmask is not None and current_bitmask > 0:\n                remaining_bitmask = current_bitmask - bitmask\n                if remaining_bitmask >= 0:\n                    current_bitmask = remaining_bitmask\n                    ret['services'].append(service)\n            else:\n                break\n    ret['services'] = sorted(ret['services'])\n    return ret",
            "def get_agent_settings():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Determine the value of the SNMP sysContact, sysLocation, and sysServices\\n    settings.\\n\\n    Returns:\\n        dict: A dictionary of the agent settings.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_settings\\n    \"\n    ret = dict()\n    sorted_types = sorted(_SERVICE_TYPES.items(), key=lambda x: (-x[1], x[0]))\n    ret['services'] = list()\n    ret['contact'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysContact')['vdata']\n    ret['location'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysLocation')['vdata']\n    current_bitmask = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysServices')['vdata']\n    if current_bitmask == 0:\n        ret['services'].append(sorted_types[-1][0])\n    else:\n        for (service, bitmask) in sorted_types:\n            if current_bitmask is not None and current_bitmask > 0:\n                remaining_bitmask = current_bitmask - bitmask\n                if remaining_bitmask >= 0:\n                    current_bitmask = remaining_bitmask\n                    ret['services'].append(service)\n            else:\n                break\n    ret['services'] = sorted(ret['services'])\n    return ret",
            "def get_agent_settings():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Determine the value of the SNMP sysContact, sysLocation, and sysServices\\n    settings.\\n\\n    Returns:\\n        dict: A dictionary of the agent settings.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_settings\\n    \"\n    ret = dict()\n    sorted_types = sorted(_SERVICE_TYPES.items(), key=lambda x: (-x[1], x[0]))\n    ret['services'] = list()\n    ret['contact'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysContact')['vdata']\n    ret['location'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysLocation')['vdata']\n    current_bitmask = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysServices')['vdata']\n    if current_bitmask == 0:\n        ret['services'].append(sorted_types[-1][0])\n    else:\n        for (service, bitmask) in sorted_types:\n            if current_bitmask is not None and current_bitmask > 0:\n                remaining_bitmask = current_bitmask - bitmask\n                if remaining_bitmask >= 0:\n                    current_bitmask = remaining_bitmask\n                    ret['services'].append(service)\n            else:\n                break\n    ret['services'] = sorted(ret['services'])\n    return ret",
            "def get_agent_settings():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Determine the value of the SNMP sysContact, sysLocation, and sysServices\\n    settings.\\n\\n    Returns:\\n        dict: A dictionary of the agent settings.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_agent_settings\\n    \"\n    ret = dict()\n    sorted_types = sorted(_SERVICE_TYPES.items(), key=lambda x: (-x[1], x[0]))\n    ret['services'] = list()\n    ret['contact'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysContact')['vdata']\n    ret['location'] = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysLocation')['vdata']\n    current_bitmask = __utils__['reg.read_value'](_HKEY, _AGENT_KEY, 'sysServices')['vdata']\n    if current_bitmask == 0:\n        ret['services'].append(sorted_types[-1][0])\n    else:\n        for (service, bitmask) in sorted_types:\n            if current_bitmask is not None and current_bitmask > 0:\n                remaining_bitmask = current_bitmask - bitmask\n                if remaining_bitmask >= 0:\n                    current_bitmask = remaining_bitmask\n                    ret['services'].append(service)\n            else:\n                break\n    ret['services'] = sorted(ret['services'])\n    return ret"
        ]
    },
    {
        "func_name": "set_agent_settings",
        "original": "def set_agent_settings(contact=None, location=None, services=None):\n    \"\"\"\n    Manage the SNMP sysContact, sysLocation, and sysServices settings.\n\n    Args:\n        contact (str, optional): The SNMP contact.\n\n        location (str, optional): The SNMP location.\n\n        services (list, optional): A list of selected services. The possible\n            service names can be found via ``win_snmp.get_agent_service_types``.\n            To disable all services pass a list of None, ie: ['None']\n\n    Returns:\n        bool: True if successful, otherwise False\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' win_snmp.set_agent_settings contact='Contact Name' location='Place' services=\"['Physical']\"\n    \"\"\"\n    if services is not None:\n        services = sorted(set(services))\n        for service in services:\n            if service not in _SERVICE_TYPES:\n                message = \"Invalid service '{}' specified. Valid services: {}\".format(service, get_agent_service_types())\n                raise SaltInvocationError(message)\n    settings = {'contact': contact, 'location': location, 'services': services}\n    current_settings = get_agent_settings()\n    if settings == current_settings:\n        _LOG.debug('Agent settings already contain the provided values.')\n        return True\n    if contact is not None:\n        if contact != current_settings['contact']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysContact', contact, 'REG_SZ')\n    if location is not None:\n        if location != current_settings['location']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysLocation', location, 'REG_SZ')\n    if services is not None:\n        if set(services) != set(current_settings['services']):\n            vdata = sum((_SERVICE_TYPES[service] for service in services))\n            _LOG.debug('Setting sysServices vdata to: %s', vdata)\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysServices', vdata, 'REG_DWORD')\n    new_settings = get_agent_settings()\n    failed_settings = dict()\n    for setting in settings:\n        if settings[setting] is not None and settings[setting] != new_settings[setting]:\n            failed_settings[setting] = settings[setting]\n    if failed_settings:\n        _LOG.error('Unable to configure agent settings: %s', failed_settings)\n        return False\n    _LOG.debug('Agent settings configured successfully: %s', settings.keys())\n    return True",
        "mutated": [
            "def set_agent_settings(contact=None, location=None, services=None):\n    if False:\n        i = 10\n    '\\n    Manage the SNMP sysContact, sysLocation, and sysServices settings.\\n\\n    Args:\\n        contact (str, optional): The SNMP contact.\\n\\n        location (str, optional): The SNMP location.\\n\\n        services (list, optional): A list of selected services. The possible\\n            service names can be found via ``win_snmp.get_agent_service_types``.\\n            To disable all services pass a list of None, ie: [\\'None\\']\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_agent_settings contact=\\'Contact Name\\' location=\\'Place\\' services=\"[\\'Physical\\']\"\\n    '\n    if services is not None:\n        services = sorted(set(services))\n        for service in services:\n            if service not in _SERVICE_TYPES:\n                message = \"Invalid service '{}' specified. Valid services: {}\".format(service, get_agent_service_types())\n                raise SaltInvocationError(message)\n    settings = {'contact': contact, 'location': location, 'services': services}\n    current_settings = get_agent_settings()\n    if settings == current_settings:\n        _LOG.debug('Agent settings already contain the provided values.')\n        return True\n    if contact is not None:\n        if contact != current_settings['contact']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysContact', contact, 'REG_SZ')\n    if location is not None:\n        if location != current_settings['location']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysLocation', location, 'REG_SZ')\n    if services is not None:\n        if set(services) != set(current_settings['services']):\n            vdata = sum((_SERVICE_TYPES[service] for service in services))\n            _LOG.debug('Setting sysServices vdata to: %s', vdata)\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysServices', vdata, 'REG_DWORD')\n    new_settings = get_agent_settings()\n    failed_settings = dict()\n    for setting in settings:\n        if settings[setting] is not None and settings[setting] != new_settings[setting]:\n            failed_settings[setting] = settings[setting]\n    if failed_settings:\n        _LOG.error('Unable to configure agent settings: %s', failed_settings)\n        return False\n    _LOG.debug('Agent settings configured successfully: %s', settings.keys())\n    return True",
            "def set_agent_settings(contact=None, location=None, services=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Manage the SNMP sysContact, sysLocation, and sysServices settings.\\n\\n    Args:\\n        contact (str, optional): The SNMP contact.\\n\\n        location (str, optional): The SNMP location.\\n\\n        services (list, optional): A list of selected services. The possible\\n            service names can be found via ``win_snmp.get_agent_service_types``.\\n            To disable all services pass a list of None, ie: [\\'None\\']\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_agent_settings contact=\\'Contact Name\\' location=\\'Place\\' services=\"[\\'Physical\\']\"\\n    '\n    if services is not None:\n        services = sorted(set(services))\n        for service in services:\n            if service not in _SERVICE_TYPES:\n                message = \"Invalid service '{}' specified. Valid services: {}\".format(service, get_agent_service_types())\n                raise SaltInvocationError(message)\n    settings = {'contact': contact, 'location': location, 'services': services}\n    current_settings = get_agent_settings()\n    if settings == current_settings:\n        _LOG.debug('Agent settings already contain the provided values.')\n        return True\n    if contact is not None:\n        if contact != current_settings['contact']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysContact', contact, 'REG_SZ')\n    if location is not None:\n        if location != current_settings['location']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysLocation', location, 'REG_SZ')\n    if services is not None:\n        if set(services) != set(current_settings['services']):\n            vdata = sum((_SERVICE_TYPES[service] for service in services))\n            _LOG.debug('Setting sysServices vdata to: %s', vdata)\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysServices', vdata, 'REG_DWORD')\n    new_settings = get_agent_settings()\n    failed_settings = dict()\n    for setting in settings:\n        if settings[setting] is not None and settings[setting] != new_settings[setting]:\n            failed_settings[setting] = settings[setting]\n    if failed_settings:\n        _LOG.error('Unable to configure agent settings: %s', failed_settings)\n        return False\n    _LOG.debug('Agent settings configured successfully: %s', settings.keys())\n    return True",
            "def set_agent_settings(contact=None, location=None, services=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Manage the SNMP sysContact, sysLocation, and sysServices settings.\\n\\n    Args:\\n        contact (str, optional): The SNMP contact.\\n\\n        location (str, optional): The SNMP location.\\n\\n        services (list, optional): A list of selected services. The possible\\n            service names can be found via ``win_snmp.get_agent_service_types``.\\n            To disable all services pass a list of None, ie: [\\'None\\']\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_agent_settings contact=\\'Contact Name\\' location=\\'Place\\' services=\"[\\'Physical\\']\"\\n    '\n    if services is not None:\n        services = sorted(set(services))\n        for service in services:\n            if service not in _SERVICE_TYPES:\n                message = \"Invalid service '{}' specified. Valid services: {}\".format(service, get_agent_service_types())\n                raise SaltInvocationError(message)\n    settings = {'contact': contact, 'location': location, 'services': services}\n    current_settings = get_agent_settings()\n    if settings == current_settings:\n        _LOG.debug('Agent settings already contain the provided values.')\n        return True\n    if contact is not None:\n        if contact != current_settings['contact']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysContact', contact, 'REG_SZ')\n    if location is not None:\n        if location != current_settings['location']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysLocation', location, 'REG_SZ')\n    if services is not None:\n        if set(services) != set(current_settings['services']):\n            vdata = sum((_SERVICE_TYPES[service] for service in services))\n            _LOG.debug('Setting sysServices vdata to: %s', vdata)\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysServices', vdata, 'REG_DWORD')\n    new_settings = get_agent_settings()\n    failed_settings = dict()\n    for setting in settings:\n        if settings[setting] is not None and settings[setting] != new_settings[setting]:\n            failed_settings[setting] = settings[setting]\n    if failed_settings:\n        _LOG.error('Unable to configure agent settings: %s', failed_settings)\n        return False\n    _LOG.debug('Agent settings configured successfully: %s', settings.keys())\n    return True",
            "def set_agent_settings(contact=None, location=None, services=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Manage the SNMP sysContact, sysLocation, and sysServices settings.\\n\\n    Args:\\n        contact (str, optional): The SNMP contact.\\n\\n        location (str, optional): The SNMP location.\\n\\n        services (list, optional): A list of selected services. The possible\\n            service names can be found via ``win_snmp.get_agent_service_types``.\\n            To disable all services pass a list of None, ie: [\\'None\\']\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_agent_settings contact=\\'Contact Name\\' location=\\'Place\\' services=\"[\\'Physical\\']\"\\n    '\n    if services is not None:\n        services = sorted(set(services))\n        for service in services:\n            if service not in _SERVICE_TYPES:\n                message = \"Invalid service '{}' specified. Valid services: {}\".format(service, get_agent_service_types())\n                raise SaltInvocationError(message)\n    settings = {'contact': contact, 'location': location, 'services': services}\n    current_settings = get_agent_settings()\n    if settings == current_settings:\n        _LOG.debug('Agent settings already contain the provided values.')\n        return True\n    if contact is not None:\n        if contact != current_settings['contact']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysContact', contact, 'REG_SZ')\n    if location is not None:\n        if location != current_settings['location']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysLocation', location, 'REG_SZ')\n    if services is not None:\n        if set(services) != set(current_settings['services']):\n            vdata = sum((_SERVICE_TYPES[service] for service in services))\n            _LOG.debug('Setting sysServices vdata to: %s', vdata)\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysServices', vdata, 'REG_DWORD')\n    new_settings = get_agent_settings()\n    failed_settings = dict()\n    for setting in settings:\n        if settings[setting] is not None and settings[setting] != new_settings[setting]:\n            failed_settings[setting] = settings[setting]\n    if failed_settings:\n        _LOG.error('Unable to configure agent settings: %s', failed_settings)\n        return False\n    _LOG.debug('Agent settings configured successfully: %s', settings.keys())\n    return True",
            "def set_agent_settings(contact=None, location=None, services=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Manage the SNMP sysContact, sysLocation, and sysServices settings.\\n\\n    Args:\\n        contact (str, optional): The SNMP contact.\\n\\n        location (str, optional): The SNMP location.\\n\\n        services (list, optional): A list of selected services. The possible\\n            service names can be found via ``win_snmp.get_agent_service_types``.\\n            To disable all services pass a list of None, ie: [\\'None\\']\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_agent_settings contact=\\'Contact Name\\' location=\\'Place\\' services=\"[\\'Physical\\']\"\\n    '\n    if services is not None:\n        services = sorted(set(services))\n        for service in services:\n            if service not in _SERVICE_TYPES:\n                message = \"Invalid service '{}' specified. Valid services: {}\".format(service, get_agent_service_types())\n                raise SaltInvocationError(message)\n    settings = {'contact': contact, 'location': location, 'services': services}\n    current_settings = get_agent_settings()\n    if settings == current_settings:\n        _LOG.debug('Agent settings already contain the provided values.')\n        return True\n    if contact is not None:\n        if contact != current_settings['contact']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysContact', contact, 'REG_SZ')\n    if location is not None:\n        if location != current_settings['location']:\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysLocation', location, 'REG_SZ')\n    if services is not None:\n        if set(services) != set(current_settings['services']):\n            vdata = sum((_SERVICE_TYPES[service] for service in services))\n            _LOG.debug('Setting sysServices vdata to: %s', vdata)\n            __utils__['reg.set_value'](_HKEY, _AGENT_KEY, 'sysServices', vdata, 'REG_DWORD')\n    new_settings = get_agent_settings()\n    failed_settings = dict()\n    for setting in settings:\n        if settings[setting] is not None and settings[setting] != new_settings[setting]:\n            failed_settings[setting] = settings[setting]\n    if failed_settings:\n        _LOG.error('Unable to configure agent settings: %s', failed_settings)\n        return False\n    _LOG.debug('Agent settings configured successfully: %s', settings.keys())\n    return True"
        ]
    },
    {
        "func_name": "get_auth_traps_enabled",
        "original": "def get_auth_traps_enabled():\n    \"\"\"\n    Determine whether the host is configured to send authentication traps.\n\n    Returns:\n        bool: True if traps are enabled, otherwise False\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' win_snmp.get_auth_traps_enabled\n    \"\"\"\n    reg_ret = __utils__['reg.read_value'](_HKEY, _SNMP_KEY, 'EnableAuthenticationTraps')\n    if reg_ret['vdata'] == '(value not set)':\n        return False\n    return bool(reg_ret['vdata'] or 0)",
        "mutated": [
            "def get_auth_traps_enabled():\n    if False:\n        i = 10\n    \"\\n    Determine whether the host is configured to send authentication traps.\\n\\n    Returns:\\n        bool: True if traps are enabled, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_auth_traps_enabled\\n    \"\n    reg_ret = __utils__['reg.read_value'](_HKEY, _SNMP_KEY, 'EnableAuthenticationTraps')\n    if reg_ret['vdata'] == '(value not set)':\n        return False\n    return bool(reg_ret['vdata'] or 0)",
            "def get_auth_traps_enabled():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Determine whether the host is configured to send authentication traps.\\n\\n    Returns:\\n        bool: True if traps are enabled, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_auth_traps_enabled\\n    \"\n    reg_ret = __utils__['reg.read_value'](_HKEY, _SNMP_KEY, 'EnableAuthenticationTraps')\n    if reg_ret['vdata'] == '(value not set)':\n        return False\n    return bool(reg_ret['vdata'] or 0)",
            "def get_auth_traps_enabled():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Determine whether the host is configured to send authentication traps.\\n\\n    Returns:\\n        bool: True if traps are enabled, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_auth_traps_enabled\\n    \"\n    reg_ret = __utils__['reg.read_value'](_HKEY, _SNMP_KEY, 'EnableAuthenticationTraps')\n    if reg_ret['vdata'] == '(value not set)':\n        return False\n    return bool(reg_ret['vdata'] or 0)",
            "def get_auth_traps_enabled():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Determine whether the host is configured to send authentication traps.\\n\\n    Returns:\\n        bool: True if traps are enabled, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_auth_traps_enabled\\n    \"\n    reg_ret = __utils__['reg.read_value'](_HKEY, _SNMP_KEY, 'EnableAuthenticationTraps')\n    if reg_ret['vdata'] == '(value not set)':\n        return False\n    return bool(reg_ret['vdata'] or 0)",
            "def get_auth_traps_enabled():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Determine whether the host is configured to send authentication traps.\\n\\n    Returns:\\n        bool: True if traps are enabled, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_auth_traps_enabled\\n    \"\n    reg_ret = __utils__['reg.read_value'](_HKEY, _SNMP_KEY, 'EnableAuthenticationTraps')\n    if reg_ret['vdata'] == '(value not set)':\n        return False\n    return bool(reg_ret['vdata'] or 0)"
        ]
    },
    {
        "func_name": "set_auth_traps_enabled",
        "original": "def set_auth_traps_enabled(status=True):\n    \"\"\"\n    Manage the sending of authentication traps.\n\n    Args:\n        status (bool): True to enable traps. False to disable.\n\n    Returns:\n        bool: True if successful, otherwise False\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' win_snmp.set_auth_traps_enabled status='True'\n    \"\"\"\n    vname = 'EnableAuthenticationTraps'\n    current_status = get_auth_traps_enabled()\n    if bool(status) == current_status:\n        _LOG.debug('%s already contains the provided value.', vname)\n        return True\n    vdata = int(status)\n    __utils__['reg.set_value'](_HKEY, _SNMP_KEY, vname, vdata, 'REG_DWORD')\n    new_status = get_auth_traps_enabled()\n    if status == new_status:\n        _LOG.debug('Setting %s configured successfully: %s', vname, vdata)\n        return True\n    _LOG.error('Unable to configure %s with value: %s', vname, vdata)\n    return False",
        "mutated": [
            "def set_auth_traps_enabled(status=True):\n    if False:\n        i = 10\n    \"\\n    Manage the sending of authentication traps.\\n\\n    Args:\\n        status (bool): True to enable traps. False to disable.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.set_auth_traps_enabled status='True'\\n    \"\n    vname = 'EnableAuthenticationTraps'\n    current_status = get_auth_traps_enabled()\n    if bool(status) == current_status:\n        _LOG.debug('%s already contains the provided value.', vname)\n        return True\n    vdata = int(status)\n    __utils__['reg.set_value'](_HKEY, _SNMP_KEY, vname, vdata, 'REG_DWORD')\n    new_status = get_auth_traps_enabled()\n    if status == new_status:\n        _LOG.debug('Setting %s configured successfully: %s', vname, vdata)\n        return True\n    _LOG.error('Unable to configure %s with value: %s', vname, vdata)\n    return False",
            "def set_auth_traps_enabled(status=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Manage the sending of authentication traps.\\n\\n    Args:\\n        status (bool): True to enable traps. False to disable.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.set_auth_traps_enabled status='True'\\n    \"\n    vname = 'EnableAuthenticationTraps'\n    current_status = get_auth_traps_enabled()\n    if bool(status) == current_status:\n        _LOG.debug('%s already contains the provided value.', vname)\n        return True\n    vdata = int(status)\n    __utils__['reg.set_value'](_HKEY, _SNMP_KEY, vname, vdata, 'REG_DWORD')\n    new_status = get_auth_traps_enabled()\n    if status == new_status:\n        _LOG.debug('Setting %s configured successfully: %s', vname, vdata)\n        return True\n    _LOG.error('Unable to configure %s with value: %s', vname, vdata)\n    return False",
            "def set_auth_traps_enabled(status=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Manage the sending of authentication traps.\\n\\n    Args:\\n        status (bool): True to enable traps. False to disable.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.set_auth_traps_enabled status='True'\\n    \"\n    vname = 'EnableAuthenticationTraps'\n    current_status = get_auth_traps_enabled()\n    if bool(status) == current_status:\n        _LOG.debug('%s already contains the provided value.', vname)\n        return True\n    vdata = int(status)\n    __utils__['reg.set_value'](_HKEY, _SNMP_KEY, vname, vdata, 'REG_DWORD')\n    new_status = get_auth_traps_enabled()\n    if status == new_status:\n        _LOG.debug('Setting %s configured successfully: %s', vname, vdata)\n        return True\n    _LOG.error('Unable to configure %s with value: %s', vname, vdata)\n    return False",
            "def set_auth_traps_enabled(status=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Manage the sending of authentication traps.\\n\\n    Args:\\n        status (bool): True to enable traps. False to disable.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.set_auth_traps_enabled status='True'\\n    \"\n    vname = 'EnableAuthenticationTraps'\n    current_status = get_auth_traps_enabled()\n    if bool(status) == current_status:\n        _LOG.debug('%s already contains the provided value.', vname)\n        return True\n    vdata = int(status)\n    __utils__['reg.set_value'](_HKEY, _SNMP_KEY, vname, vdata, 'REG_DWORD')\n    new_status = get_auth_traps_enabled()\n    if status == new_status:\n        _LOG.debug('Setting %s configured successfully: %s', vname, vdata)\n        return True\n    _LOG.error('Unable to configure %s with value: %s', vname, vdata)\n    return False",
            "def set_auth_traps_enabled(status=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Manage the sending of authentication traps.\\n\\n    Args:\\n        status (bool): True to enable traps. False to disable.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.set_auth_traps_enabled status='True'\\n    \"\n    vname = 'EnableAuthenticationTraps'\n    current_status = get_auth_traps_enabled()\n    if bool(status) == current_status:\n        _LOG.debug('%s already contains the provided value.', vname)\n        return True\n    vdata = int(status)\n    __utils__['reg.set_value'](_HKEY, _SNMP_KEY, vname, vdata, 'REG_DWORD')\n    new_status = get_auth_traps_enabled()\n    if status == new_status:\n        _LOG.debug('Setting %s configured successfully: %s', vname, vdata)\n        return True\n    _LOG.error('Unable to configure %s with value: %s', vname, vdata)\n    return False"
        ]
    },
    {
        "func_name": "get_community_names",
        "original": "def get_community_names():\n    \"\"\"\n    Get the current accepted SNMP community names and their permissions.\n\n    If community names are being managed by Group Policy, those values will be\n    returned instead like this:\n\n    .. code-block:: bash\n\n        TestCommunity:\n            Managed by GPO\n\n    Community names managed normally will denote the permission instead:\n\n    .. code-block:: bash\n\n        TestCommunity:\n            Read Only\n\n    Returns:\n        dict: A dictionary of community names and permissions.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' win_snmp.get_community_names\n    \"\"\"\n    ret = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Loading communities from Group Policy settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_GPO_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                ret[current_value['vdata']] = 'Managed by GPO'\n    if not ret:\n        _LOG.debug('Loading communities from SNMP settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                permissions = ''\n                for permission_name in _PERMISSION_TYPES:\n                    if current_value['vdata'] == _PERMISSION_TYPES[permission_name]:\n                        permissions = permission_name\n                        break\n                ret[current_value['vname']] = permissions\n    if not ret:\n        _LOG.debug('Unable to find existing communities.')\n    return ret",
        "mutated": [
            "def get_community_names():\n    if False:\n        i = 10\n    \"\\n    Get the current accepted SNMP community names and their permissions.\\n\\n    If community names are being managed by Group Policy, those values will be\\n    returned instead like this:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Managed by GPO\\n\\n    Community names managed normally will denote the permission instead:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Read Only\\n\\n    Returns:\\n        dict: A dictionary of community names and permissions.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_community_names\\n    \"\n    ret = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Loading communities from Group Policy settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_GPO_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                ret[current_value['vdata']] = 'Managed by GPO'\n    if not ret:\n        _LOG.debug('Loading communities from SNMP settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                permissions = ''\n                for permission_name in _PERMISSION_TYPES:\n                    if current_value['vdata'] == _PERMISSION_TYPES[permission_name]:\n                        permissions = permission_name\n                        break\n                ret[current_value['vname']] = permissions\n    if not ret:\n        _LOG.debug('Unable to find existing communities.')\n    return ret",
            "def get_community_names():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Get the current accepted SNMP community names and their permissions.\\n\\n    If community names are being managed by Group Policy, those values will be\\n    returned instead like this:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Managed by GPO\\n\\n    Community names managed normally will denote the permission instead:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Read Only\\n\\n    Returns:\\n        dict: A dictionary of community names and permissions.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_community_names\\n    \"\n    ret = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Loading communities from Group Policy settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_GPO_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                ret[current_value['vdata']] = 'Managed by GPO'\n    if not ret:\n        _LOG.debug('Loading communities from SNMP settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                permissions = ''\n                for permission_name in _PERMISSION_TYPES:\n                    if current_value['vdata'] == _PERMISSION_TYPES[permission_name]:\n                        permissions = permission_name\n                        break\n                ret[current_value['vname']] = permissions\n    if not ret:\n        _LOG.debug('Unable to find existing communities.')\n    return ret",
            "def get_community_names():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Get the current accepted SNMP community names and their permissions.\\n\\n    If community names are being managed by Group Policy, those values will be\\n    returned instead like this:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Managed by GPO\\n\\n    Community names managed normally will denote the permission instead:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Read Only\\n\\n    Returns:\\n        dict: A dictionary of community names and permissions.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_community_names\\n    \"\n    ret = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Loading communities from Group Policy settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_GPO_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                ret[current_value['vdata']] = 'Managed by GPO'\n    if not ret:\n        _LOG.debug('Loading communities from SNMP settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                permissions = ''\n                for permission_name in _PERMISSION_TYPES:\n                    if current_value['vdata'] == _PERMISSION_TYPES[permission_name]:\n                        permissions = permission_name\n                        break\n                ret[current_value['vname']] = permissions\n    if not ret:\n        _LOG.debug('Unable to find existing communities.')\n    return ret",
            "def get_community_names():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Get the current accepted SNMP community names and their permissions.\\n\\n    If community names are being managed by Group Policy, those values will be\\n    returned instead like this:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Managed by GPO\\n\\n    Community names managed normally will denote the permission instead:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Read Only\\n\\n    Returns:\\n        dict: A dictionary of community names and permissions.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_community_names\\n    \"\n    ret = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Loading communities from Group Policy settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_GPO_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                ret[current_value['vdata']] = 'Managed by GPO'\n    if not ret:\n        _LOG.debug('Loading communities from SNMP settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                permissions = ''\n                for permission_name in _PERMISSION_TYPES:\n                    if current_value['vdata'] == _PERMISSION_TYPES[permission_name]:\n                        permissions = permission_name\n                        break\n                ret[current_value['vname']] = permissions\n    if not ret:\n        _LOG.debug('Unable to find existing communities.')\n    return ret",
            "def get_community_names():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Get the current accepted SNMP community names and their permissions.\\n\\n    If community names are being managed by Group Policy, those values will be\\n    returned instead like this:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Managed by GPO\\n\\n    Community names managed normally will denote the permission instead:\\n\\n    .. code-block:: bash\\n\\n        TestCommunity:\\n            Read Only\\n\\n    Returns:\\n        dict: A dictionary of community names and permissions.\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' win_snmp.get_community_names\\n    \"\n    ret = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Loading communities from Group Policy settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_GPO_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                ret[current_value['vdata']] = 'Managed by GPO'\n    if not ret:\n        _LOG.debug('Loading communities from SNMP settings')\n        current_values = __utils__['reg.list_values'](_HKEY, _COMMUNITIES_KEY)\n        if isinstance(current_values, list):\n            for current_value in current_values:\n                if not isinstance(current_value, dict):\n                    continue\n                permissions = ''\n                for permission_name in _PERMISSION_TYPES:\n                    if current_value['vdata'] == _PERMISSION_TYPES[permission_name]:\n                        permissions = permission_name\n                        break\n                ret[current_value['vname']] = permissions\n    if not ret:\n        _LOG.debug('Unable to find existing communities.')\n    return ret"
        ]
    },
    {
        "func_name": "set_community_names",
        "original": "def set_community_names(communities):\n    \"\"\"\n    Manage the SNMP accepted community names and their permissions.\n\n    .. note::\n        Settings managed by Group Policy will always take precedence over those\n        set using the SNMP interface. Therefore if this function finds Group\n        Policy settings it will raise a CommandExecutionError\n\n    Args:\n        communities (dict): A dictionary of SNMP community names and\n            permissions. The possible permissions can be found via\n            ``win_snmp.get_permission_types``.\n\n    Returns:\n        bool: True if successful, otherwise False\n\n    Raises:\n        CommandExecutionError:\n            If SNMP settings are being managed by Group Policy\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' win_snmp.set_community_names communities=\"{'TestCommunity': 'Read Only'}'\n    \"\"\"\n    values = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Communities on this system are managed by Group Policy')\n        raise CommandExecutionError('Communities on this system are managed by Group Policy')\n    current_communities = get_community_names()\n    if communities == current_communities:\n        _LOG.debug('Communities already contain the provided values.')\n        return True\n    for vname in communities:\n        if not communities[vname]:\n            communities[vname] = 'None'\n        try:\n            vdata = _PERMISSION_TYPES[communities[vname]]\n        except KeyError:\n            raise SaltInvocationError(\"Invalid permission '{}' specified. Valid permissions: {}\".format(communities[vname], _PERMISSION_TYPES.keys()))\n        values[vname] = vdata\n    for current_vname in current_communities:\n        if current_vname in values:\n            if current_communities[current_vname] != values[current_vname]:\n                __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, current_vname, values[current_vname], 'REG_DWORD')\n        else:\n            __utils__['reg.delete_value'](_HKEY, _COMMUNITIES_KEY, current_vname)\n    for vname in values:\n        if vname not in current_communities:\n            __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, vname, values[vname], 'REG_DWORD')\n    new_communities = get_community_names()\n    failed_communities = dict()\n    for new_vname in new_communities:\n        if new_vname not in communities:\n            failed_communities[new_vname] = None\n    for vname in communities:\n        if communities[vname] != new_communities[vname]:\n            failed_communities[vname] = communities[vname]\n    if failed_communities:\n        _LOG.error('Unable to configure communities: %s', failed_communities)\n        return False\n    _LOG.debug('Communities configured successfully: %s', communities.keys())\n    return True",
        "mutated": [
            "def set_community_names(communities):\n    if False:\n        i = 10\n    '\\n    Manage the SNMP accepted community names and their permissions.\\n\\n    .. note::\\n        Settings managed by Group Policy will always take precedence over those\\n        set using the SNMP interface. Therefore if this function finds Group\\n        Policy settings it will raise a CommandExecutionError\\n\\n    Args:\\n        communities (dict): A dictionary of SNMP community names and\\n            permissions. The possible permissions can be found via\\n            ``win_snmp.get_permission_types``.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    Raises:\\n        CommandExecutionError:\\n            If SNMP settings are being managed by Group Policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_community_names communities=\"{\\'TestCommunity\\': \\'Read Only\\'}\\'\\n    '\n    values = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Communities on this system are managed by Group Policy')\n        raise CommandExecutionError('Communities on this system are managed by Group Policy')\n    current_communities = get_community_names()\n    if communities == current_communities:\n        _LOG.debug('Communities already contain the provided values.')\n        return True\n    for vname in communities:\n        if not communities[vname]:\n            communities[vname] = 'None'\n        try:\n            vdata = _PERMISSION_TYPES[communities[vname]]\n        except KeyError:\n            raise SaltInvocationError(\"Invalid permission '{}' specified. Valid permissions: {}\".format(communities[vname], _PERMISSION_TYPES.keys()))\n        values[vname] = vdata\n    for current_vname in current_communities:\n        if current_vname in values:\n            if current_communities[current_vname] != values[current_vname]:\n                __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, current_vname, values[current_vname], 'REG_DWORD')\n        else:\n            __utils__['reg.delete_value'](_HKEY, _COMMUNITIES_KEY, current_vname)\n    for vname in values:\n        if vname not in current_communities:\n            __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, vname, values[vname], 'REG_DWORD')\n    new_communities = get_community_names()\n    failed_communities = dict()\n    for new_vname in new_communities:\n        if new_vname not in communities:\n            failed_communities[new_vname] = None\n    for vname in communities:\n        if communities[vname] != new_communities[vname]:\n            failed_communities[vname] = communities[vname]\n    if failed_communities:\n        _LOG.error('Unable to configure communities: %s', failed_communities)\n        return False\n    _LOG.debug('Communities configured successfully: %s', communities.keys())\n    return True",
            "def set_community_names(communities):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Manage the SNMP accepted community names and their permissions.\\n\\n    .. note::\\n        Settings managed by Group Policy will always take precedence over those\\n        set using the SNMP interface. Therefore if this function finds Group\\n        Policy settings it will raise a CommandExecutionError\\n\\n    Args:\\n        communities (dict): A dictionary of SNMP community names and\\n            permissions. The possible permissions can be found via\\n            ``win_snmp.get_permission_types``.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    Raises:\\n        CommandExecutionError:\\n            If SNMP settings are being managed by Group Policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_community_names communities=\"{\\'TestCommunity\\': \\'Read Only\\'}\\'\\n    '\n    values = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Communities on this system are managed by Group Policy')\n        raise CommandExecutionError('Communities on this system are managed by Group Policy')\n    current_communities = get_community_names()\n    if communities == current_communities:\n        _LOG.debug('Communities already contain the provided values.')\n        return True\n    for vname in communities:\n        if not communities[vname]:\n            communities[vname] = 'None'\n        try:\n            vdata = _PERMISSION_TYPES[communities[vname]]\n        except KeyError:\n            raise SaltInvocationError(\"Invalid permission '{}' specified. Valid permissions: {}\".format(communities[vname], _PERMISSION_TYPES.keys()))\n        values[vname] = vdata\n    for current_vname in current_communities:\n        if current_vname in values:\n            if current_communities[current_vname] != values[current_vname]:\n                __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, current_vname, values[current_vname], 'REG_DWORD')\n        else:\n            __utils__['reg.delete_value'](_HKEY, _COMMUNITIES_KEY, current_vname)\n    for vname in values:\n        if vname not in current_communities:\n            __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, vname, values[vname], 'REG_DWORD')\n    new_communities = get_community_names()\n    failed_communities = dict()\n    for new_vname in new_communities:\n        if new_vname not in communities:\n            failed_communities[new_vname] = None\n    for vname in communities:\n        if communities[vname] != new_communities[vname]:\n            failed_communities[vname] = communities[vname]\n    if failed_communities:\n        _LOG.error('Unable to configure communities: %s', failed_communities)\n        return False\n    _LOG.debug('Communities configured successfully: %s', communities.keys())\n    return True",
            "def set_community_names(communities):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Manage the SNMP accepted community names and their permissions.\\n\\n    .. note::\\n        Settings managed by Group Policy will always take precedence over those\\n        set using the SNMP interface. Therefore if this function finds Group\\n        Policy settings it will raise a CommandExecutionError\\n\\n    Args:\\n        communities (dict): A dictionary of SNMP community names and\\n            permissions. The possible permissions can be found via\\n            ``win_snmp.get_permission_types``.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    Raises:\\n        CommandExecutionError:\\n            If SNMP settings are being managed by Group Policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_community_names communities=\"{\\'TestCommunity\\': \\'Read Only\\'}\\'\\n    '\n    values = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Communities on this system are managed by Group Policy')\n        raise CommandExecutionError('Communities on this system are managed by Group Policy')\n    current_communities = get_community_names()\n    if communities == current_communities:\n        _LOG.debug('Communities already contain the provided values.')\n        return True\n    for vname in communities:\n        if not communities[vname]:\n            communities[vname] = 'None'\n        try:\n            vdata = _PERMISSION_TYPES[communities[vname]]\n        except KeyError:\n            raise SaltInvocationError(\"Invalid permission '{}' specified. Valid permissions: {}\".format(communities[vname], _PERMISSION_TYPES.keys()))\n        values[vname] = vdata\n    for current_vname in current_communities:\n        if current_vname in values:\n            if current_communities[current_vname] != values[current_vname]:\n                __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, current_vname, values[current_vname], 'REG_DWORD')\n        else:\n            __utils__['reg.delete_value'](_HKEY, _COMMUNITIES_KEY, current_vname)\n    for vname in values:\n        if vname not in current_communities:\n            __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, vname, values[vname], 'REG_DWORD')\n    new_communities = get_community_names()\n    failed_communities = dict()\n    for new_vname in new_communities:\n        if new_vname not in communities:\n            failed_communities[new_vname] = None\n    for vname in communities:\n        if communities[vname] != new_communities[vname]:\n            failed_communities[vname] = communities[vname]\n    if failed_communities:\n        _LOG.error('Unable to configure communities: %s', failed_communities)\n        return False\n    _LOG.debug('Communities configured successfully: %s', communities.keys())\n    return True",
            "def set_community_names(communities):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Manage the SNMP accepted community names and their permissions.\\n\\n    .. note::\\n        Settings managed by Group Policy will always take precedence over those\\n        set using the SNMP interface. Therefore if this function finds Group\\n        Policy settings it will raise a CommandExecutionError\\n\\n    Args:\\n        communities (dict): A dictionary of SNMP community names and\\n            permissions. The possible permissions can be found via\\n            ``win_snmp.get_permission_types``.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    Raises:\\n        CommandExecutionError:\\n            If SNMP settings are being managed by Group Policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_community_names communities=\"{\\'TestCommunity\\': \\'Read Only\\'}\\'\\n    '\n    values = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Communities on this system are managed by Group Policy')\n        raise CommandExecutionError('Communities on this system are managed by Group Policy')\n    current_communities = get_community_names()\n    if communities == current_communities:\n        _LOG.debug('Communities already contain the provided values.')\n        return True\n    for vname in communities:\n        if not communities[vname]:\n            communities[vname] = 'None'\n        try:\n            vdata = _PERMISSION_TYPES[communities[vname]]\n        except KeyError:\n            raise SaltInvocationError(\"Invalid permission '{}' specified. Valid permissions: {}\".format(communities[vname], _PERMISSION_TYPES.keys()))\n        values[vname] = vdata\n    for current_vname in current_communities:\n        if current_vname in values:\n            if current_communities[current_vname] != values[current_vname]:\n                __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, current_vname, values[current_vname], 'REG_DWORD')\n        else:\n            __utils__['reg.delete_value'](_HKEY, _COMMUNITIES_KEY, current_vname)\n    for vname in values:\n        if vname not in current_communities:\n            __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, vname, values[vname], 'REG_DWORD')\n    new_communities = get_community_names()\n    failed_communities = dict()\n    for new_vname in new_communities:\n        if new_vname not in communities:\n            failed_communities[new_vname] = None\n    for vname in communities:\n        if communities[vname] != new_communities[vname]:\n            failed_communities[vname] = communities[vname]\n    if failed_communities:\n        _LOG.error('Unable to configure communities: %s', failed_communities)\n        return False\n    _LOG.debug('Communities configured successfully: %s', communities.keys())\n    return True",
            "def set_community_names(communities):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Manage the SNMP accepted community names and their permissions.\\n\\n    .. note::\\n        Settings managed by Group Policy will always take precedence over those\\n        set using the SNMP interface. Therefore if this function finds Group\\n        Policy settings it will raise a CommandExecutionError\\n\\n    Args:\\n        communities (dict): A dictionary of SNMP community names and\\n            permissions. The possible permissions can be found via\\n            ``win_snmp.get_permission_types``.\\n\\n    Returns:\\n        bool: True if successful, otherwise False\\n\\n    Raises:\\n        CommandExecutionError:\\n            If SNMP settings are being managed by Group Policy\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt \\'*\\' win_snmp.set_community_names communities=\"{\\'TestCommunity\\': \\'Read Only\\'}\\'\\n    '\n    values = dict()\n    if __utils__['reg.key_exists'](_HKEY, _COMMUNITIES_GPO_KEY):\n        _LOG.debug('Communities on this system are managed by Group Policy')\n        raise CommandExecutionError('Communities on this system are managed by Group Policy')\n    current_communities = get_community_names()\n    if communities == current_communities:\n        _LOG.debug('Communities already contain the provided values.')\n        return True\n    for vname in communities:\n        if not communities[vname]:\n            communities[vname] = 'None'\n        try:\n            vdata = _PERMISSION_TYPES[communities[vname]]\n        except KeyError:\n            raise SaltInvocationError(\"Invalid permission '{}' specified. Valid permissions: {}\".format(communities[vname], _PERMISSION_TYPES.keys()))\n        values[vname] = vdata\n    for current_vname in current_communities:\n        if current_vname in values:\n            if current_communities[current_vname] != values[current_vname]:\n                __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, current_vname, values[current_vname], 'REG_DWORD')\n        else:\n            __utils__['reg.delete_value'](_HKEY, _COMMUNITIES_KEY, current_vname)\n    for vname in values:\n        if vname not in current_communities:\n            __utils__['reg.set_value'](_HKEY, _COMMUNITIES_KEY, vname, values[vname], 'REG_DWORD')\n    new_communities = get_community_names()\n    failed_communities = dict()\n    for new_vname in new_communities:\n        if new_vname not in communities:\n            failed_communities[new_vname] = None\n    for vname in communities:\n        if communities[vname] != new_communities[vname]:\n            failed_communities[vname] = communities[vname]\n    if failed_communities:\n        _LOG.error('Unable to configure communities: %s', failed_communities)\n        return False\n    _LOG.debug('Communities configured successfully: %s', communities.keys())\n    return True"
        ]
    }
]