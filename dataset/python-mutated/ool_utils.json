[
    {
        "func_name": "pool2d",
        "original": "def pool2d(np_data, attrs, dtype='float32'):\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCHW':\n        (in_n, in_c, in_h, in_w) = in_shape = np_data.shape\n        height_axis = 2\n        width_axis = 3\n    elif data_format == 'NHWC':\n        (in_n, in_h, in_w, in_c) = in_shape = np_data.shape\n        height_axis = 1\n        width_axis = 2\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_h = k_w = kernel_size\n    else:\n        (k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_h = s_w = stride_size\n    else:\n        (s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pt = pl = pb = pr = padding_size\n    else:\n        (pt, pl, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCHW':\n        pad_np = np.full(shape=(in_n, in_c, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if exclusive:\n                    pad_exclusive = pad_np.copy()\n                    pad_exclusive[np.ix_(*no_zero)] = 1\n                    if data_format == 'NCHW':\n                        pad_count = np.sum(pad_exclusive[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, :, i, j] = np.sum(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    else:\n                        pad_count = np.sum(pad_exclusive[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, i, j, :] = np.sum(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                elif data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.mean(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.mean(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.max(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.max(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
        "mutated": [
            "def pool2d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCHW':\n        (in_n, in_c, in_h, in_w) = in_shape = np_data.shape\n        height_axis = 2\n        width_axis = 3\n    elif data_format == 'NHWC':\n        (in_n, in_h, in_w, in_c) = in_shape = np_data.shape\n        height_axis = 1\n        width_axis = 2\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_h = k_w = kernel_size\n    else:\n        (k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_h = s_w = stride_size\n    else:\n        (s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pt = pl = pb = pr = padding_size\n    else:\n        (pt, pl, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCHW':\n        pad_np = np.full(shape=(in_n, in_c, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if exclusive:\n                    pad_exclusive = pad_np.copy()\n                    pad_exclusive[np.ix_(*no_zero)] = 1\n                    if data_format == 'NCHW':\n                        pad_count = np.sum(pad_exclusive[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, :, i, j] = np.sum(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    else:\n                        pad_count = np.sum(pad_exclusive[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, i, j, :] = np.sum(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                elif data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.mean(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.mean(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.max(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.max(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool2d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCHW':\n        (in_n, in_c, in_h, in_w) = in_shape = np_data.shape\n        height_axis = 2\n        width_axis = 3\n    elif data_format == 'NHWC':\n        (in_n, in_h, in_w, in_c) = in_shape = np_data.shape\n        height_axis = 1\n        width_axis = 2\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_h = k_w = kernel_size\n    else:\n        (k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_h = s_w = stride_size\n    else:\n        (s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pt = pl = pb = pr = padding_size\n    else:\n        (pt, pl, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCHW':\n        pad_np = np.full(shape=(in_n, in_c, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if exclusive:\n                    pad_exclusive = pad_np.copy()\n                    pad_exclusive[np.ix_(*no_zero)] = 1\n                    if data_format == 'NCHW':\n                        pad_count = np.sum(pad_exclusive[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, :, i, j] = np.sum(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    else:\n                        pad_count = np.sum(pad_exclusive[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, i, j, :] = np.sum(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                elif data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.mean(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.mean(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.max(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.max(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool2d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCHW':\n        (in_n, in_c, in_h, in_w) = in_shape = np_data.shape\n        height_axis = 2\n        width_axis = 3\n    elif data_format == 'NHWC':\n        (in_n, in_h, in_w, in_c) = in_shape = np_data.shape\n        height_axis = 1\n        width_axis = 2\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_h = k_w = kernel_size\n    else:\n        (k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_h = s_w = stride_size\n    else:\n        (s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pt = pl = pb = pr = padding_size\n    else:\n        (pt, pl, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCHW':\n        pad_np = np.full(shape=(in_n, in_c, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if exclusive:\n                    pad_exclusive = pad_np.copy()\n                    pad_exclusive[np.ix_(*no_zero)] = 1\n                    if data_format == 'NCHW':\n                        pad_count = np.sum(pad_exclusive[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, :, i, j] = np.sum(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    else:\n                        pad_count = np.sum(pad_exclusive[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, i, j, :] = np.sum(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                elif data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.mean(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.mean(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.max(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.max(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool2d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCHW':\n        (in_n, in_c, in_h, in_w) = in_shape = np_data.shape\n        height_axis = 2\n        width_axis = 3\n    elif data_format == 'NHWC':\n        (in_n, in_h, in_w, in_c) = in_shape = np_data.shape\n        height_axis = 1\n        width_axis = 2\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_h = k_w = kernel_size\n    else:\n        (k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_h = s_w = stride_size\n    else:\n        (s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pt = pl = pb = pr = padding_size\n    else:\n        (pt, pl, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCHW':\n        pad_np = np.full(shape=(in_n, in_c, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if exclusive:\n                    pad_exclusive = pad_np.copy()\n                    pad_exclusive[np.ix_(*no_zero)] = 1\n                    if data_format == 'NCHW':\n                        pad_count = np.sum(pad_exclusive[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, :, i, j] = np.sum(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    else:\n                        pad_count = np.sum(pad_exclusive[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, i, j, :] = np.sum(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                elif data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.mean(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.mean(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.max(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.max(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool2d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCHW':\n        (in_n, in_c, in_h, in_w) = in_shape = np_data.shape\n        height_axis = 2\n        width_axis = 3\n    elif data_format == 'NHWC':\n        (in_n, in_h, in_w, in_c) = in_shape = np_data.shape\n        height_axis = 1\n        width_axis = 2\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_h = k_w = kernel_size\n    else:\n        (k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_h = s_w = stride_size\n    else:\n        (s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pt = pl = pb = pr = padding_size\n    else:\n        (pt, pl, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCHW':\n        pad_np = np.full(shape=(in_n, in_c, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if exclusive:\n                    pad_exclusive = pad_np.copy()\n                    pad_exclusive[np.ix_(*no_zero)] = 1\n                    if data_format == 'NCHW':\n                        pad_count = np.sum(pad_exclusive[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, :, i, j] = np.sum(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    else:\n                        pad_count = np.sum(pad_exclusive[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :] == 1, axis=(height_axis, width_axis))\n                        ret_np[:, i, j, :] = np.sum(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis)) / np.maximum(pad_count, 1)\n                elif data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.mean(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.mean(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[height_axis]):\n            for j in range(out_shape[width_axis]):\n                if data_format == 'NCHW':\n                    ret_np[:, :, i, j] = np.max(pad_np[:, :, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w], axis=(height_axis, width_axis))\n                else:\n                    ret_np[:, i, j, :] = np.max(pad_np[:, i * s_h:i * s_h + k_h, j * s_w:j * s_w + k_w, :], axis=(height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])"
        ]
    },
    {
        "func_name": "pool3d",
        "original": "def pool3d(np_data, attrs, dtype='float32'):\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCDHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCDHW':\n        (in_n, in_c, in_d, in_h, in_w) = in_shape = np_data.shape\n        depth_axis = 2\n        height_axis = 3\n        width_axis = 4\n    elif data_format == 'NDHWC':\n        (in_n, in_d, in_h, in_w, in_c) = in_shape = np_data.shape\n        depth_axis = 1\n        height_axis = 2\n        width_axis = 3\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_d = k_h = k_w = kernel_size\n    else:\n        (k_d, k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_d = s_h = s_w = stride_size\n    else:\n        (s_d, s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pf = pt = pl = pk = pb = pr = padding_size\n    else:\n        (pf, pt, pl, pk, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[depth_axis] = int(math.ceil(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[depth_axis] = int(math.floor(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCDHW':\n        pad_np = np.full(shape=(in_n, in_c, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if exclusive:\n                        pad_exclusive = pad_np.copy()\n                        pad_exclusive[np.ix_(*no_zero)] = 1\n                        if data_format == 'NCDHW':\n                            pad_count = np.sum(pad_exclusive[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, :, i, j, k] = np.sum(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                        else:\n                            pad_count = np.sum(pad_exclusive[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, i, j, k, :] = np.sum(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    elif data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.mean(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.mean(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.max(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.max(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
        "mutated": [
            "def pool3d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCDHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCDHW':\n        (in_n, in_c, in_d, in_h, in_w) = in_shape = np_data.shape\n        depth_axis = 2\n        height_axis = 3\n        width_axis = 4\n    elif data_format == 'NDHWC':\n        (in_n, in_d, in_h, in_w, in_c) = in_shape = np_data.shape\n        depth_axis = 1\n        height_axis = 2\n        width_axis = 3\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_d = k_h = k_w = kernel_size\n    else:\n        (k_d, k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_d = s_h = s_w = stride_size\n    else:\n        (s_d, s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pf = pt = pl = pk = pb = pr = padding_size\n    else:\n        (pf, pt, pl, pk, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[depth_axis] = int(math.ceil(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[depth_axis] = int(math.floor(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCDHW':\n        pad_np = np.full(shape=(in_n, in_c, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if exclusive:\n                        pad_exclusive = pad_np.copy()\n                        pad_exclusive[np.ix_(*no_zero)] = 1\n                        if data_format == 'NCDHW':\n                            pad_count = np.sum(pad_exclusive[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, :, i, j, k] = np.sum(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                        else:\n                            pad_count = np.sum(pad_exclusive[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, i, j, k, :] = np.sum(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    elif data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.mean(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.mean(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.max(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.max(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool3d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCDHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCDHW':\n        (in_n, in_c, in_d, in_h, in_w) = in_shape = np_data.shape\n        depth_axis = 2\n        height_axis = 3\n        width_axis = 4\n    elif data_format == 'NDHWC':\n        (in_n, in_d, in_h, in_w, in_c) = in_shape = np_data.shape\n        depth_axis = 1\n        height_axis = 2\n        width_axis = 3\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_d = k_h = k_w = kernel_size\n    else:\n        (k_d, k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_d = s_h = s_w = stride_size\n    else:\n        (s_d, s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pf = pt = pl = pk = pb = pr = padding_size\n    else:\n        (pf, pt, pl, pk, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[depth_axis] = int(math.ceil(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[depth_axis] = int(math.floor(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCDHW':\n        pad_np = np.full(shape=(in_n, in_c, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if exclusive:\n                        pad_exclusive = pad_np.copy()\n                        pad_exclusive[np.ix_(*no_zero)] = 1\n                        if data_format == 'NCDHW':\n                            pad_count = np.sum(pad_exclusive[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, :, i, j, k] = np.sum(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                        else:\n                            pad_count = np.sum(pad_exclusive[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, i, j, k, :] = np.sum(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    elif data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.mean(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.mean(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.max(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.max(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool3d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCDHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCDHW':\n        (in_n, in_c, in_d, in_h, in_w) = in_shape = np_data.shape\n        depth_axis = 2\n        height_axis = 3\n        width_axis = 4\n    elif data_format == 'NDHWC':\n        (in_n, in_d, in_h, in_w, in_c) = in_shape = np_data.shape\n        depth_axis = 1\n        height_axis = 2\n        width_axis = 3\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_d = k_h = k_w = kernel_size\n    else:\n        (k_d, k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_d = s_h = s_w = stride_size\n    else:\n        (s_d, s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pf = pt = pl = pk = pb = pr = padding_size\n    else:\n        (pf, pt, pl, pk, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[depth_axis] = int(math.ceil(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[depth_axis] = int(math.floor(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCDHW':\n        pad_np = np.full(shape=(in_n, in_c, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if exclusive:\n                        pad_exclusive = pad_np.copy()\n                        pad_exclusive[np.ix_(*no_zero)] = 1\n                        if data_format == 'NCDHW':\n                            pad_count = np.sum(pad_exclusive[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, :, i, j, k] = np.sum(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                        else:\n                            pad_count = np.sum(pad_exclusive[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, i, j, k, :] = np.sum(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    elif data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.mean(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.mean(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.max(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.max(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool3d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCDHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCDHW':\n        (in_n, in_c, in_d, in_h, in_w) = in_shape = np_data.shape\n        depth_axis = 2\n        height_axis = 3\n        width_axis = 4\n    elif data_format == 'NDHWC':\n        (in_n, in_d, in_h, in_w, in_c) = in_shape = np_data.shape\n        depth_axis = 1\n        height_axis = 2\n        width_axis = 3\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_d = k_h = k_w = kernel_size\n    else:\n        (k_d, k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_d = s_h = s_w = stride_size\n    else:\n        (s_d, s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pf = pt = pl = pk = pb = pr = padding_size\n    else:\n        (pf, pt, pl, pk, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[depth_axis] = int(math.ceil(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[depth_axis] = int(math.floor(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCDHW':\n        pad_np = np.full(shape=(in_n, in_c, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if exclusive:\n                        pad_exclusive = pad_np.copy()\n                        pad_exclusive[np.ix_(*no_zero)] = 1\n                        if data_format == 'NCDHW':\n                            pad_count = np.sum(pad_exclusive[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, :, i, j, k] = np.sum(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                        else:\n                            pad_count = np.sum(pad_exclusive[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, i, j, k, :] = np.sum(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    elif data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.mean(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.mean(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.max(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.max(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool3d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCDHW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCDHW':\n        (in_n, in_c, in_d, in_h, in_w) = in_shape = np_data.shape\n        depth_axis = 2\n        height_axis = 3\n        width_axis = 4\n    elif data_format == 'NDHWC':\n        (in_n, in_d, in_h, in_w, in_c) = in_shape = np_data.shape\n        depth_axis = 1\n        height_axis = 2\n        width_axis = 3\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_d = k_h = k_w = kernel_size\n    else:\n        (k_d, k_h, k_w) = kernel_size\n    if isinstance(stride_size, int):\n        s_d = s_h = s_w = stride_size\n    else:\n        (s_d, s_h, s_w) = stride_size\n    if isinstance(padding_size, int):\n        pf = pt = pl = pk = pb = pr = padding_size\n    else:\n        (pf, pt, pl, pk, pb, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[depth_axis] = int(math.ceil(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.ceil(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[depth_axis] = int(math.floor(float(in_shape[depth_axis] - k_d + pf + pk) / s_d) + 1)\n        out_shape[height_axis] = int(math.floor(float(in_shape[height_axis] - k_h + pt + pb) / s_h) + 1)\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCDHW':\n        pad_np = np.full(shape=(in_n, in_c, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_d + pf + pk, in_h + pt + pb, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pf, in_d + pf), range(pt, in_h + pt), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if exclusive:\n                        pad_exclusive = pad_np.copy()\n                        pad_exclusive[np.ix_(*no_zero)] = 1\n                        if data_format == 'NCDHW':\n                            pad_count = np.sum(pad_exclusive[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, :, i, j, k] = np.sum(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                        else:\n                            pad_count = np.sum(pad_exclusive[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :] == 1, axis=(depth_axis, height_axis, width_axis))\n                            ret_np[:, i, j, k, :] = np.sum(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis)) / np.maximum(pad_count, 1)\n                    elif data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.mean(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.mean(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    elif pool_type == 'max':\n        for i in range(out_shape[depth_axis]):\n            for j in range(out_shape[height_axis]):\n                for k in range(out_shape[width_axis]):\n                    if data_format == 'NCDHW':\n                        ret_np[:, :, i, j, k] = np.max(pad_np[:, :, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w], axis=(depth_axis, height_axis, width_axis))\n                    else:\n                        ret_np[:, i, j, k, :] = np.max(pad_np[:, i * s_d:i * s_d + k_d, j * s_h:j * s_h + k_h, k * s_w:k * s_w + k_w, :], axis=(depth_axis, height_axis, width_axis))\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])"
        ]
    },
    {
        "func_name": "pool1d",
        "original": "def pool1d(np_data, attrs, dtype='float32'):\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCW':\n        (in_n, in_c, in_w) = in_shape = np_data.shape\n        width_axis = 2\n    elif data_format == 'NWC':\n        (in_n, in_w, in_c) = in_shape = np_data.shape\n        width_axis = 1\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_w = kernel_size\n    else:\n        (k_w,) = kernel_size\n    if isinstance(stride_size, int):\n        s_w = stride_size\n    else:\n        (s_w,) = stride_size\n    if isinstance(padding_size, int):\n        pl = pr = padding_size\n    else:\n        (pl, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCW':\n        pad_np = np.full(shape=(in_n, in_c, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[width_axis]):\n            if exclusive:\n                pad_exclusive = pad_np.copy()\n                pad_exclusive[np.ix_(*no_zero)] = 1\n                if data_format == 'NCW':\n                    pad_count = np.sum(pad_exclusive[:, :, i * s_w:i * s_w + k_w] == 1, axis=width_axis)\n                    ret_np[:, :, i] = np.sum(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis) / np.maximum(pad_count, 1)\n                else:\n                    pad_count = np.sum(pad_exclusive[:, i * s_w:i * s_w + k_w, :] == 1, axis=width_axis)\n                    ret_np[:, i, :] = np.sum(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis) / np.maximum(pad_count, 1)\n            elif data_format == 'NCW':\n                ret_np[:, :, i] = np.mean(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, i, :] = np.mean(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis)\n    elif pool_type == 'max':\n        for k in range(out_shape[width_axis]):\n            if data_format == 'NCW':\n                ret_np[:, :, k] = np.max(pad_np[:, :, k * s_w:k * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, k, :] = np.max(pad_np[:, k * s_w:k * s_w + k_w, :], axis=width_axis)\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
        "mutated": [
            "def pool1d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCW':\n        (in_n, in_c, in_w) = in_shape = np_data.shape\n        width_axis = 2\n    elif data_format == 'NWC':\n        (in_n, in_w, in_c) = in_shape = np_data.shape\n        width_axis = 1\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_w = kernel_size\n    else:\n        (k_w,) = kernel_size\n    if isinstance(stride_size, int):\n        s_w = stride_size\n    else:\n        (s_w,) = stride_size\n    if isinstance(padding_size, int):\n        pl = pr = padding_size\n    else:\n        (pl, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCW':\n        pad_np = np.full(shape=(in_n, in_c, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[width_axis]):\n            if exclusive:\n                pad_exclusive = pad_np.copy()\n                pad_exclusive[np.ix_(*no_zero)] = 1\n                if data_format == 'NCW':\n                    pad_count = np.sum(pad_exclusive[:, :, i * s_w:i * s_w + k_w] == 1, axis=width_axis)\n                    ret_np[:, :, i] = np.sum(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis) / np.maximum(pad_count, 1)\n                else:\n                    pad_count = np.sum(pad_exclusive[:, i * s_w:i * s_w + k_w, :] == 1, axis=width_axis)\n                    ret_np[:, i, :] = np.sum(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis) / np.maximum(pad_count, 1)\n            elif data_format == 'NCW':\n                ret_np[:, :, i] = np.mean(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, i, :] = np.mean(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis)\n    elif pool_type == 'max':\n        for k in range(out_shape[width_axis]):\n            if data_format == 'NCW':\n                ret_np[:, :, k] = np.max(pad_np[:, :, k * s_w:k * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, k, :] = np.max(pad_np[:, k * s_w:k * s_w + k_w, :], axis=width_axis)\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool1d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCW':\n        (in_n, in_c, in_w) = in_shape = np_data.shape\n        width_axis = 2\n    elif data_format == 'NWC':\n        (in_n, in_w, in_c) = in_shape = np_data.shape\n        width_axis = 1\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_w = kernel_size\n    else:\n        (k_w,) = kernel_size\n    if isinstance(stride_size, int):\n        s_w = stride_size\n    else:\n        (s_w,) = stride_size\n    if isinstance(padding_size, int):\n        pl = pr = padding_size\n    else:\n        (pl, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCW':\n        pad_np = np.full(shape=(in_n, in_c, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[width_axis]):\n            if exclusive:\n                pad_exclusive = pad_np.copy()\n                pad_exclusive[np.ix_(*no_zero)] = 1\n                if data_format == 'NCW':\n                    pad_count = np.sum(pad_exclusive[:, :, i * s_w:i * s_w + k_w] == 1, axis=width_axis)\n                    ret_np[:, :, i] = np.sum(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis) / np.maximum(pad_count, 1)\n                else:\n                    pad_count = np.sum(pad_exclusive[:, i * s_w:i * s_w + k_w, :] == 1, axis=width_axis)\n                    ret_np[:, i, :] = np.sum(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis) / np.maximum(pad_count, 1)\n            elif data_format == 'NCW':\n                ret_np[:, :, i] = np.mean(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, i, :] = np.mean(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis)\n    elif pool_type == 'max':\n        for k in range(out_shape[width_axis]):\n            if data_format == 'NCW':\n                ret_np[:, :, k] = np.max(pad_np[:, :, k * s_w:k * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, k, :] = np.max(pad_np[:, k * s_w:k * s_w + k_w, :], axis=width_axis)\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool1d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCW':\n        (in_n, in_c, in_w) = in_shape = np_data.shape\n        width_axis = 2\n    elif data_format == 'NWC':\n        (in_n, in_w, in_c) = in_shape = np_data.shape\n        width_axis = 1\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_w = kernel_size\n    else:\n        (k_w,) = kernel_size\n    if isinstance(stride_size, int):\n        s_w = stride_size\n    else:\n        (s_w,) = stride_size\n    if isinstance(padding_size, int):\n        pl = pr = padding_size\n    else:\n        (pl, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCW':\n        pad_np = np.full(shape=(in_n, in_c, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[width_axis]):\n            if exclusive:\n                pad_exclusive = pad_np.copy()\n                pad_exclusive[np.ix_(*no_zero)] = 1\n                if data_format == 'NCW':\n                    pad_count = np.sum(pad_exclusive[:, :, i * s_w:i * s_w + k_w] == 1, axis=width_axis)\n                    ret_np[:, :, i] = np.sum(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis) / np.maximum(pad_count, 1)\n                else:\n                    pad_count = np.sum(pad_exclusive[:, i * s_w:i * s_w + k_w, :] == 1, axis=width_axis)\n                    ret_np[:, i, :] = np.sum(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis) / np.maximum(pad_count, 1)\n            elif data_format == 'NCW':\n                ret_np[:, :, i] = np.mean(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, i, :] = np.mean(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis)\n    elif pool_type == 'max':\n        for k in range(out_shape[width_axis]):\n            if data_format == 'NCW':\n                ret_np[:, :, k] = np.max(pad_np[:, :, k * s_w:k * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, k, :] = np.max(pad_np[:, k * s_w:k * s_w + k_w, :], axis=width_axis)\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool1d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCW':\n        (in_n, in_c, in_w) = in_shape = np_data.shape\n        width_axis = 2\n    elif data_format == 'NWC':\n        (in_n, in_w, in_c) = in_shape = np_data.shape\n        width_axis = 1\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_w = kernel_size\n    else:\n        (k_w,) = kernel_size\n    if isinstance(stride_size, int):\n        s_w = stride_size\n    else:\n        (s_w,) = stride_size\n    if isinstance(padding_size, int):\n        pl = pr = padding_size\n    else:\n        (pl, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCW':\n        pad_np = np.full(shape=(in_n, in_c, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[width_axis]):\n            if exclusive:\n                pad_exclusive = pad_np.copy()\n                pad_exclusive[np.ix_(*no_zero)] = 1\n                if data_format == 'NCW':\n                    pad_count = np.sum(pad_exclusive[:, :, i * s_w:i * s_w + k_w] == 1, axis=width_axis)\n                    ret_np[:, :, i] = np.sum(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis) / np.maximum(pad_count, 1)\n                else:\n                    pad_count = np.sum(pad_exclusive[:, i * s_w:i * s_w + k_w, :] == 1, axis=width_axis)\n                    ret_np[:, i, :] = np.sum(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis) / np.maximum(pad_count, 1)\n            elif data_format == 'NCW':\n                ret_np[:, :, i] = np.mean(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, i, :] = np.mean(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis)\n    elif pool_type == 'max':\n        for k in range(out_shape[width_axis]):\n            if data_format == 'NCW':\n                ret_np[:, :, k] = np.max(pad_np[:, :, k * s_w:k * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, k, :] = np.max(pad_np[:, k * s_w:k * s_w + k_w, :], axis=width_axis)\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])",
            "def pool1d(np_data, attrs, dtype='float32'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pool_type = 'max'\n    ceil_mode = False\n    exclusive = True\n    data_format = 'NCW'\n    for key in attrs.attr_store:\n        if key == 'kernel_size':\n            kernel_size = attrs.get_attr('kernel_size')\n        elif key == 'stride_size':\n            stride_size = attrs.get_attr('stride_size')\n        elif key == 'padding_size':\n            padding_size = attrs.get_attr('padding_size')\n        elif key == 'pool_type':\n            pool_type = attrs.get_attr('pool_type')\n        elif key == 'ceil_mode':\n            ceil_mode = attrs.get_attr('ceil_mode')\n        elif key == 'exclusive':\n            exclusive = attrs.get_attr('exclusive')\n        elif key == 'data_format':\n            data_format = attrs.get_attr('data_format')\n        else:\n            raise ValueError(f'attr_store {key} is not supported')\n    if data_format == 'NCW':\n        (in_n, in_c, in_w) = in_shape = np_data.shape\n        width_axis = 2\n    elif data_format == 'NWC':\n        (in_n, in_w, in_c) = in_shape = np_data.shape\n        width_axis = 1\n    else:\n        raise ValueError(f'data_format {data_format} is not supported')\n    if isinstance(kernel_size, int):\n        k_w = kernel_size\n    else:\n        (k_w,) = kernel_size\n    if isinstance(stride_size, int):\n        s_w = stride_size\n    else:\n        (s_w,) = stride_size\n    if isinstance(padding_size, int):\n        pl = pr = padding_size\n    else:\n        (pl, pr) = padding_size\n    out_shape = list(in_shape)\n    if ceil_mode:\n        out_shape[width_axis] = int(math.ceil(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    else:\n        out_shape[width_axis] = int(math.floor(float(in_shape[width_axis] - k_w + pl + pr) / s_w) + 1)\n    fill_value = 0\n    if exclusive and pool_type == 'max':\n        fill_value = sys.float_info.min\n    if data_format == 'NCW':\n        pad_np = np.full(shape=(in_n, in_c, in_w + pl + pr), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(in_c), range(pl, in_w + pl))\n    else:\n        pad_np = np.full(shape=(in_n, in_w + pl + pr, in_c), fill_value=fill_value, dtype=dtype)\n        no_zero = (range(in_n), range(pl, in_w + pl), range(in_c))\n    pad_np[np.ix_(*no_zero)] = np_data\n    ret_np = np.zeros(shape=out_shape).astype(dtype)\n    if pool_type == 'avg':\n        for i in range(out_shape[width_axis]):\n            if exclusive:\n                pad_exclusive = pad_np.copy()\n                pad_exclusive[np.ix_(*no_zero)] = 1\n                if data_format == 'NCW':\n                    pad_count = np.sum(pad_exclusive[:, :, i * s_w:i * s_w + k_w] == 1, axis=width_axis)\n                    ret_np[:, :, i] = np.sum(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis) / np.maximum(pad_count, 1)\n                else:\n                    pad_count = np.sum(pad_exclusive[:, i * s_w:i * s_w + k_w, :] == 1, axis=width_axis)\n                    ret_np[:, i, :] = np.sum(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis) / np.maximum(pad_count, 1)\n            elif data_format == 'NCW':\n                ret_np[:, :, i] = np.mean(pad_np[:, :, i * s_w:i * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, i, :] = np.mean(pad_np[:, i * s_w:i * s_w + k_w, :], axis=width_axis)\n    elif pool_type == 'max':\n        for k in range(out_shape[width_axis]):\n            if data_format == 'NCW':\n                ret_np[:, :, k] = np.max(pad_np[:, :, k * s_w:k * s_w + k_w], axis=width_axis)\n            else:\n                ret_np[:, k, :] = np.max(pad_np[:, k * s_w:k * s_w + k_w, :], axis=width_axis)\n    else:\n        raise ValueError(f'pool type {pool_type} is not supported')\n    ret_np = np.maximum(ret_np, fill_value)\n    return (ret_np, [out_shape])"
        ]
    }
]