[
    {
        "func_name": "cathetus",
        "original": "def cathetus(h, a):\n    \"\"\"Given the lengths of the hypotenuse and a side of a right triangle,\n    return the length of the other side.\n\n    A companion to the C99 hypot() function.  Some care is needed to avoid\n    underflow in the case of small arguments, and overflow in the case of\n    large arguments as would occur for the naive implementation as\n    sqrt(h*h - a*a).  The behaviour with respect the non-finite arguments\n    (NaNs and infinities) is designed to be as consistent as possible with\n    the C99 hypot() specifications.\n\n    This function relies on the system ``sqrt`` function and so, like it,\n    may be inaccurate up to a relative error of (around) floating-point\n    epsilon.\n\n    Based on the C99 implementation https://github.com/jjgreen/cathetus\n    \"\"\"\n    if isnan(h):\n        return nan\n    if isinf(h):\n        if isinf(a):\n            return nan\n        else:\n            return inf\n    h = fabs(h)\n    a = fabs(a)\n    if h < a:\n        return nan\n    if h > sqrt(float_info.max):\n        if h > float_info.max / 2:\n            b = sqrt(h - a) * sqrt(h / 2 + a / 2) * sqrt(2)\n        else:\n            b = sqrt(h - a) * sqrt(h + a)\n    elif h < sqrt(float_info.min):\n        b = sqrt(h - a) * sqrt(h + a)\n    else:\n        b = sqrt((h - a) * (h + a))\n    return min(b, h)",
        "mutated": [
            "def cathetus(h, a):\n    if False:\n        i = 10\n    'Given the lengths of the hypotenuse and a side of a right triangle,\\n    return the length of the other side.\\n\\n    A companion to the C99 hypot() function.  Some care is needed to avoid\\n    underflow in the case of small arguments, and overflow in the case of\\n    large arguments as would occur for the naive implementation as\\n    sqrt(h*h - a*a).  The behaviour with respect the non-finite arguments\\n    (NaNs and infinities) is designed to be as consistent as possible with\\n    the C99 hypot() specifications.\\n\\n    This function relies on the system ``sqrt`` function and so, like it,\\n    may be inaccurate up to a relative error of (around) floating-point\\n    epsilon.\\n\\n    Based on the C99 implementation https://github.com/jjgreen/cathetus\\n    '\n    if isnan(h):\n        return nan\n    if isinf(h):\n        if isinf(a):\n            return nan\n        else:\n            return inf\n    h = fabs(h)\n    a = fabs(a)\n    if h < a:\n        return nan\n    if h > sqrt(float_info.max):\n        if h > float_info.max / 2:\n            b = sqrt(h - a) * sqrt(h / 2 + a / 2) * sqrt(2)\n        else:\n            b = sqrt(h - a) * sqrt(h + a)\n    elif h < sqrt(float_info.min):\n        b = sqrt(h - a) * sqrt(h + a)\n    else:\n        b = sqrt((h - a) * (h + a))\n    return min(b, h)",
            "def cathetus(h, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Given the lengths of the hypotenuse and a side of a right triangle,\\n    return the length of the other side.\\n\\n    A companion to the C99 hypot() function.  Some care is needed to avoid\\n    underflow in the case of small arguments, and overflow in the case of\\n    large arguments as would occur for the naive implementation as\\n    sqrt(h*h - a*a).  The behaviour with respect the non-finite arguments\\n    (NaNs and infinities) is designed to be as consistent as possible with\\n    the C99 hypot() specifications.\\n\\n    This function relies on the system ``sqrt`` function and so, like it,\\n    may be inaccurate up to a relative error of (around) floating-point\\n    epsilon.\\n\\n    Based on the C99 implementation https://github.com/jjgreen/cathetus\\n    '\n    if isnan(h):\n        return nan\n    if isinf(h):\n        if isinf(a):\n            return nan\n        else:\n            return inf\n    h = fabs(h)\n    a = fabs(a)\n    if h < a:\n        return nan\n    if h > sqrt(float_info.max):\n        if h > float_info.max / 2:\n            b = sqrt(h - a) * sqrt(h / 2 + a / 2) * sqrt(2)\n        else:\n            b = sqrt(h - a) * sqrt(h + a)\n    elif h < sqrt(float_info.min):\n        b = sqrt(h - a) * sqrt(h + a)\n    else:\n        b = sqrt((h - a) * (h + a))\n    return min(b, h)",
            "def cathetus(h, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Given the lengths of the hypotenuse and a side of a right triangle,\\n    return the length of the other side.\\n\\n    A companion to the C99 hypot() function.  Some care is needed to avoid\\n    underflow in the case of small arguments, and overflow in the case of\\n    large arguments as would occur for the naive implementation as\\n    sqrt(h*h - a*a).  The behaviour with respect the non-finite arguments\\n    (NaNs and infinities) is designed to be as consistent as possible with\\n    the C99 hypot() specifications.\\n\\n    This function relies on the system ``sqrt`` function and so, like it,\\n    may be inaccurate up to a relative error of (around) floating-point\\n    epsilon.\\n\\n    Based on the C99 implementation https://github.com/jjgreen/cathetus\\n    '\n    if isnan(h):\n        return nan\n    if isinf(h):\n        if isinf(a):\n            return nan\n        else:\n            return inf\n    h = fabs(h)\n    a = fabs(a)\n    if h < a:\n        return nan\n    if h > sqrt(float_info.max):\n        if h > float_info.max / 2:\n            b = sqrt(h - a) * sqrt(h / 2 + a / 2) * sqrt(2)\n        else:\n            b = sqrt(h - a) * sqrt(h + a)\n    elif h < sqrt(float_info.min):\n        b = sqrt(h - a) * sqrt(h + a)\n    else:\n        b = sqrt((h - a) * (h + a))\n    return min(b, h)",
            "def cathetus(h, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Given the lengths of the hypotenuse and a side of a right triangle,\\n    return the length of the other side.\\n\\n    A companion to the C99 hypot() function.  Some care is needed to avoid\\n    underflow in the case of small arguments, and overflow in the case of\\n    large arguments as would occur for the naive implementation as\\n    sqrt(h*h - a*a).  The behaviour with respect the non-finite arguments\\n    (NaNs and infinities) is designed to be as consistent as possible with\\n    the C99 hypot() specifications.\\n\\n    This function relies on the system ``sqrt`` function and so, like it,\\n    may be inaccurate up to a relative error of (around) floating-point\\n    epsilon.\\n\\n    Based on the C99 implementation https://github.com/jjgreen/cathetus\\n    '\n    if isnan(h):\n        return nan\n    if isinf(h):\n        if isinf(a):\n            return nan\n        else:\n            return inf\n    h = fabs(h)\n    a = fabs(a)\n    if h < a:\n        return nan\n    if h > sqrt(float_info.max):\n        if h > float_info.max / 2:\n            b = sqrt(h - a) * sqrt(h / 2 + a / 2) * sqrt(2)\n        else:\n            b = sqrt(h - a) * sqrt(h + a)\n    elif h < sqrt(float_info.min):\n        b = sqrt(h - a) * sqrt(h + a)\n    else:\n        b = sqrt((h - a) * (h + a))\n    return min(b, h)",
            "def cathetus(h, a):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Given the lengths of the hypotenuse and a side of a right triangle,\\n    return the length of the other side.\\n\\n    A companion to the C99 hypot() function.  Some care is needed to avoid\\n    underflow in the case of small arguments, and overflow in the case of\\n    large arguments as would occur for the naive implementation as\\n    sqrt(h*h - a*a).  The behaviour with respect the non-finite arguments\\n    (NaNs and infinities) is designed to be as consistent as possible with\\n    the C99 hypot() specifications.\\n\\n    This function relies on the system ``sqrt`` function and so, like it,\\n    may be inaccurate up to a relative error of (around) floating-point\\n    epsilon.\\n\\n    Based on the C99 implementation https://github.com/jjgreen/cathetus\\n    '\n    if isnan(h):\n        return nan\n    if isinf(h):\n        if isinf(a):\n            return nan\n        else:\n            return inf\n    h = fabs(h)\n    a = fabs(a)\n    if h < a:\n        return nan\n    if h > sqrt(float_info.max):\n        if h > float_info.max / 2:\n            b = sqrt(h - a) * sqrt(h / 2 + a / 2) * sqrt(2)\n        else:\n            b = sqrt(h - a) * sqrt(h + a)\n    elif h < sqrt(float_info.min):\n        b = sqrt(h - a) * sqrt(h + a)\n    else:\n        b = sqrt((h - a) * (h + a))\n    return min(b, h)"
        ]
    }
]