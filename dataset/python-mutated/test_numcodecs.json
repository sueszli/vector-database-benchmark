[
    {
        "func_name": "compare_arrays",
        "original": "def compare_arrays(arr, res, precision=None):\n    res = ensure_ndarray(res).view(arr.dtype)\n    if arr.flags.f_contiguous:\n        order = 'F'\n    else:\n        order = 'C'\n    res = res.reshape(arr.shape, order=order)\n    if precision is None:\n        assert_array_equal(arr, res)\n    else:\n        assert_array_almost_equal(arr, res, decimal=precision)",
        "mutated": [
            "def compare_arrays(arr, res, precision=None):\n    if False:\n        i = 10\n    res = ensure_ndarray(res).view(arr.dtype)\n    if arr.flags.f_contiguous:\n        order = 'F'\n    else:\n        order = 'C'\n    res = res.reshape(arr.shape, order=order)\n    if precision is None:\n        assert_array_equal(arr, res)\n    else:\n        assert_array_almost_equal(arr, res, decimal=precision)",
            "def compare_arrays(arr, res, precision=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    res = ensure_ndarray(res).view(arr.dtype)\n    if arr.flags.f_contiguous:\n        order = 'F'\n    else:\n        order = 'C'\n    res = res.reshape(arr.shape, order=order)\n    if precision is None:\n        assert_array_equal(arr, res)\n    else:\n        assert_array_almost_equal(arr, res, decimal=precision)",
            "def compare_arrays(arr, res, precision=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    res = ensure_ndarray(res).view(arr.dtype)\n    if arr.flags.f_contiguous:\n        order = 'F'\n    else:\n        order = 'C'\n    res = res.reshape(arr.shape, order=order)\n    if precision is None:\n        assert_array_equal(arr, res)\n    else:\n        assert_array_almost_equal(arr, res, decimal=precision)",
            "def compare_arrays(arr, res, precision=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    res = ensure_ndarray(res).view(arr.dtype)\n    if arr.flags.f_contiguous:\n        order = 'F'\n    else:\n        order = 'C'\n    res = res.reshape(arr.shape, order=order)\n    if precision is None:\n        assert_array_equal(arr, res)\n    else:\n        assert_array_almost_equal(arr, res, decimal=precision)",
            "def compare_arrays(arr, res, precision=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    res = ensure_ndarray(res).view(arr.dtype)\n    if arr.flags.f_contiguous:\n        order = 'F'\n    else:\n        order = 'C'\n    res = res.reshape(arr.shape, order=order)\n    if precision is None:\n        assert_array_equal(arr, res)\n    else:\n        assert_array_almost_equal(arr, res, decimal=precision)"
        ]
    },
    {
        "func_name": "check_encode_decode",
        "original": "def check_encode_decode(arr, codec, precision=None):\n    enc = codec.encode(arr)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = arr.tobytes(order='A')\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = bytearray(arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    enc_bytes = ensure_bytes(enc)\n    dec = codec.decode(enc_bytes)\n    compare_arrays(arr, dec, precision=precision)\n    dec = codec.decode(bytearray(enc_bytes))\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', enc_bytes)\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    buf = np.frombuffer(enc_bytes, dtype='u1')\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    out = np.empty_like(arr)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)\n    out = bytearray(arr.nbytes)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)",
        "mutated": [
            "def check_encode_decode(arr, codec, precision=None):\n    if False:\n        i = 10\n    enc = codec.encode(arr)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = arr.tobytes(order='A')\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = bytearray(arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    enc_bytes = ensure_bytes(enc)\n    dec = codec.decode(enc_bytes)\n    compare_arrays(arr, dec, precision=precision)\n    dec = codec.decode(bytearray(enc_bytes))\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', enc_bytes)\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    buf = np.frombuffer(enc_bytes, dtype='u1')\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    out = np.empty_like(arr)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)\n    out = bytearray(arr.nbytes)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)",
            "def check_encode_decode(arr, codec, precision=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    enc = codec.encode(arr)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = arr.tobytes(order='A')\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = bytearray(arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    enc_bytes = ensure_bytes(enc)\n    dec = codec.decode(enc_bytes)\n    compare_arrays(arr, dec, precision=precision)\n    dec = codec.decode(bytearray(enc_bytes))\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', enc_bytes)\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    buf = np.frombuffer(enc_bytes, dtype='u1')\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    out = np.empty_like(arr)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)\n    out = bytearray(arr.nbytes)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)",
            "def check_encode_decode(arr, codec, precision=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    enc = codec.encode(arr)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = arr.tobytes(order='A')\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = bytearray(arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    enc_bytes = ensure_bytes(enc)\n    dec = codec.decode(enc_bytes)\n    compare_arrays(arr, dec, precision=precision)\n    dec = codec.decode(bytearray(enc_bytes))\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', enc_bytes)\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    buf = np.frombuffer(enc_bytes, dtype='u1')\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    out = np.empty_like(arr)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)\n    out = bytearray(arr.nbytes)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)",
            "def check_encode_decode(arr, codec, precision=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    enc = codec.encode(arr)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = arr.tobytes(order='A')\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = bytearray(arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    enc_bytes = ensure_bytes(enc)\n    dec = codec.decode(enc_bytes)\n    compare_arrays(arr, dec, precision=precision)\n    dec = codec.decode(bytearray(enc_bytes))\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', enc_bytes)\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    buf = np.frombuffer(enc_bytes, dtype='u1')\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    out = np.empty_like(arr)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)\n    out = bytearray(arr.nbytes)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)",
            "def check_encode_decode(arr, codec, precision=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    enc = codec.encode(arr)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = arr.tobytes(order='A')\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = bytearray(arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', arr.tobytes(order='A'))\n    enc = codec.encode(buf)\n    dec = codec.decode(enc)\n    compare_arrays(arr, dec, precision=precision)\n    enc_bytes = ensure_bytes(enc)\n    dec = codec.decode(enc_bytes)\n    compare_arrays(arr, dec, precision=precision)\n    dec = codec.decode(bytearray(enc_bytes))\n    compare_arrays(arr, dec, precision=precision)\n    buf = array.array('b', enc_bytes)\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    buf = np.frombuffer(enc_bytes, dtype='u1')\n    dec = codec.decode(buf)\n    compare_arrays(arr, dec, precision=precision)\n    out = np.empty_like(arr)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)\n    out = bytearray(arr.nbytes)\n    codec.decode(enc_bytes, out=out)\n    compare_arrays(arr, out, precision=precision)"
        ]
    },
    {
        "func_name": "test_blosc",
        "original": "@pytest.mark.xfail_browsers(chrome='test_numcodecs triggers a recursion error in chrome')\n@run_in_pyodide(packages=['numcodecs', 'numpy'])\ndef test_blosc(selenium_standalone):\n    import array\n    import numpy as np\n    from numcodecs.blosc import Blosc\n    from numcodecs.compat import ensure_bytes, ensure_ndarray\n    from numcodecs.lz4 import LZ4\n    from numcodecs.zstd import Zstd\n    from numpy.testing import assert_array_almost_equal, assert_array_equal\n\n    def compare_arrays(arr, res, precision=None):\n        res = ensure_ndarray(res).view(arr.dtype)\n        if arr.flags.f_contiguous:\n            order = 'F'\n        else:\n            order = 'C'\n        res = res.reshape(arr.shape, order=order)\n        if precision is None:\n            assert_array_equal(arr, res)\n        else:\n            assert_array_almost_equal(arr, res, decimal=precision)\n\n    def check_encode_decode(arr, codec, precision=None):\n        enc = codec.encode(arr)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = arr.tobytes(order='A')\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = bytearray(arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        enc_bytes = ensure_bytes(enc)\n        dec = codec.decode(enc_bytes)\n        compare_arrays(arr, dec, precision=precision)\n        dec = codec.decode(bytearray(enc_bytes))\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', enc_bytes)\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        buf = np.frombuffer(enc_bytes, dtype='u1')\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        out = np.empty_like(arr)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n        out = bytearray(arr.nbytes)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n    arrays = [np.arange(1000, dtype='i4'), np.linspace(1000, 1001, 1000, dtype='f8'), np.random.normal(loc=1000, scale=1, size=(100, 10)), np.random.randint(0, 2, size=1000, dtype=bool).reshape(100, 10, order='F'), np.random.choice([b'a', b'bb', b'ccc'], size=1000).reshape(10, 10, 10), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('M8[ns]'), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('m8[ns]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('M8[m]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('m8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[m]')]\n    codecs = [LZ4(), LZ4(acceleration=-1), LZ4(acceleration=10), Zstd(), Zstd(level=-1), Zstd(level=10), Blosc(shuffle=Blosc.SHUFFLE), Blosc(clevel=0, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE), Blosc(cname='lz4', clevel=5, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=9, shuffle=Blosc.BITSHUFFLE), Blosc(cname='zlib', clevel=1, shuffle=0), Blosc(cname='zstd', clevel=1, shuffle=1), Blosc(cname='blosclz', clevel=1, shuffle=2), Blosc(shuffle=Blosc.SHUFFLE, blocksize=0), Blosc(shuffle=Blosc.SHUFFLE, blocksize=2 ** 8), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE, blocksize=2 ** 8)]\n    for codec in codecs:\n        for arr in arrays:\n            check_encode_decode(arr, codec)",
        "mutated": [
            "@pytest.mark.xfail_browsers(chrome='test_numcodecs triggers a recursion error in chrome')\n@run_in_pyodide(packages=['numcodecs', 'numpy'])\ndef test_blosc(selenium_standalone):\n    if False:\n        i = 10\n    import array\n    import numpy as np\n    from numcodecs.blosc import Blosc\n    from numcodecs.compat import ensure_bytes, ensure_ndarray\n    from numcodecs.lz4 import LZ4\n    from numcodecs.zstd import Zstd\n    from numpy.testing import assert_array_almost_equal, assert_array_equal\n\n    def compare_arrays(arr, res, precision=None):\n        res = ensure_ndarray(res).view(arr.dtype)\n        if arr.flags.f_contiguous:\n            order = 'F'\n        else:\n            order = 'C'\n        res = res.reshape(arr.shape, order=order)\n        if precision is None:\n            assert_array_equal(arr, res)\n        else:\n            assert_array_almost_equal(arr, res, decimal=precision)\n\n    def check_encode_decode(arr, codec, precision=None):\n        enc = codec.encode(arr)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = arr.tobytes(order='A')\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = bytearray(arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        enc_bytes = ensure_bytes(enc)\n        dec = codec.decode(enc_bytes)\n        compare_arrays(arr, dec, precision=precision)\n        dec = codec.decode(bytearray(enc_bytes))\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', enc_bytes)\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        buf = np.frombuffer(enc_bytes, dtype='u1')\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        out = np.empty_like(arr)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n        out = bytearray(arr.nbytes)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n    arrays = [np.arange(1000, dtype='i4'), np.linspace(1000, 1001, 1000, dtype='f8'), np.random.normal(loc=1000, scale=1, size=(100, 10)), np.random.randint(0, 2, size=1000, dtype=bool).reshape(100, 10, order='F'), np.random.choice([b'a', b'bb', b'ccc'], size=1000).reshape(10, 10, 10), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('M8[ns]'), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('m8[ns]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('M8[m]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('m8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[m]')]\n    codecs = [LZ4(), LZ4(acceleration=-1), LZ4(acceleration=10), Zstd(), Zstd(level=-1), Zstd(level=10), Blosc(shuffle=Blosc.SHUFFLE), Blosc(clevel=0, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE), Blosc(cname='lz4', clevel=5, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=9, shuffle=Blosc.BITSHUFFLE), Blosc(cname='zlib', clevel=1, shuffle=0), Blosc(cname='zstd', clevel=1, shuffle=1), Blosc(cname='blosclz', clevel=1, shuffle=2), Blosc(shuffle=Blosc.SHUFFLE, blocksize=0), Blosc(shuffle=Blosc.SHUFFLE, blocksize=2 ** 8), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE, blocksize=2 ** 8)]\n    for codec in codecs:\n        for arr in arrays:\n            check_encode_decode(arr, codec)",
            "@pytest.mark.xfail_browsers(chrome='test_numcodecs triggers a recursion error in chrome')\n@run_in_pyodide(packages=['numcodecs', 'numpy'])\ndef test_blosc(selenium_standalone):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    import array\n    import numpy as np\n    from numcodecs.blosc import Blosc\n    from numcodecs.compat import ensure_bytes, ensure_ndarray\n    from numcodecs.lz4 import LZ4\n    from numcodecs.zstd import Zstd\n    from numpy.testing import assert_array_almost_equal, assert_array_equal\n\n    def compare_arrays(arr, res, precision=None):\n        res = ensure_ndarray(res).view(arr.dtype)\n        if arr.flags.f_contiguous:\n            order = 'F'\n        else:\n            order = 'C'\n        res = res.reshape(arr.shape, order=order)\n        if precision is None:\n            assert_array_equal(arr, res)\n        else:\n            assert_array_almost_equal(arr, res, decimal=precision)\n\n    def check_encode_decode(arr, codec, precision=None):\n        enc = codec.encode(arr)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = arr.tobytes(order='A')\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = bytearray(arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        enc_bytes = ensure_bytes(enc)\n        dec = codec.decode(enc_bytes)\n        compare_arrays(arr, dec, precision=precision)\n        dec = codec.decode(bytearray(enc_bytes))\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', enc_bytes)\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        buf = np.frombuffer(enc_bytes, dtype='u1')\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        out = np.empty_like(arr)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n        out = bytearray(arr.nbytes)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n    arrays = [np.arange(1000, dtype='i4'), np.linspace(1000, 1001, 1000, dtype='f8'), np.random.normal(loc=1000, scale=1, size=(100, 10)), np.random.randint(0, 2, size=1000, dtype=bool).reshape(100, 10, order='F'), np.random.choice([b'a', b'bb', b'ccc'], size=1000).reshape(10, 10, 10), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('M8[ns]'), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('m8[ns]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('M8[m]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('m8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[m]')]\n    codecs = [LZ4(), LZ4(acceleration=-1), LZ4(acceleration=10), Zstd(), Zstd(level=-1), Zstd(level=10), Blosc(shuffle=Blosc.SHUFFLE), Blosc(clevel=0, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE), Blosc(cname='lz4', clevel=5, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=9, shuffle=Blosc.BITSHUFFLE), Blosc(cname='zlib', clevel=1, shuffle=0), Blosc(cname='zstd', clevel=1, shuffle=1), Blosc(cname='blosclz', clevel=1, shuffle=2), Blosc(shuffle=Blosc.SHUFFLE, blocksize=0), Blosc(shuffle=Blosc.SHUFFLE, blocksize=2 ** 8), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE, blocksize=2 ** 8)]\n    for codec in codecs:\n        for arr in arrays:\n            check_encode_decode(arr, codec)",
            "@pytest.mark.xfail_browsers(chrome='test_numcodecs triggers a recursion error in chrome')\n@run_in_pyodide(packages=['numcodecs', 'numpy'])\ndef test_blosc(selenium_standalone):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    import array\n    import numpy as np\n    from numcodecs.blosc import Blosc\n    from numcodecs.compat import ensure_bytes, ensure_ndarray\n    from numcodecs.lz4 import LZ4\n    from numcodecs.zstd import Zstd\n    from numpy.testing import assert_array_almost_equal, assert_array_equal\n\n    def compare_arrays(arr, res, precision=None):\n        res = ensure_ndarray(res).view(arr.dtype)\n        if arr.flags.f_contiguous:\n            order = 'F'\n        else:\n            order = 'C'\n        res = res.reshape(arr.shape, order=order)\n        if precision is None:\n            assert_array_equal(arr, res)\n        else:\n            assert_array_almost_equal(arr, res, decimal=precision)\n\n    def check_encode_decode(arr, codec, precision=None):\n        enc = codec.encode(arr)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = arr.tobytes(order='A')\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = bytearray(arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        enc_bytes = ensure_bytes(enc)\n        dec = codec.decode(enc_bytes)\n        compare_arrays(arr, dec, precision=precision)\n        dec = codec.decode(bytearray(enc_bytes))\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', enc_bytes)\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        buf = np.frombuffer(enc_bytes, dtype='u1')\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        out = np.empty_like(arr)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n        out = bytearray(arr.nbytes)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n    arrays = [np.arange(1000, dtype='i4'), np.linspace(1000, 1001, 1000, dtype='f8'), np.random.normal(loc=1000, scale=1, size=(100, 10)), np.random.randint(0, 2, size=1000, dtype=bool).reshape(100, 10, order='F'), np.random.choice([b'a', b'bb', b'ccc'], size=1000).reshape(10, 10, 10), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('M8[ns]'), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('m8[ns]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('M8[m]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('m8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[m]')]\n    codecs = [LZ4(), LZ4(acceleration=-1), LZ4(acceleration=10), Zstd(), Zstd(level=-1), Zstd(level=10), Blosc(shuffle=Blosc.SHUFFLE), Blosc(clevel=0, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE), Blosc(cname='lz4', clevel=5, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=9, shuffle=Blosc.BITSHUFFLE), Blosc(cname='zlib', clevel=1, shuffle=0), Blosc(cname='zstd', clevel=1, shuffle=1), Blosc(cname='blosclz', clevel=1, shuffle=2), Blosc(shuffle=Blosc.SHUFFLE, blocksize=0), Blosc(shuffle=Blosc.SHUFFLE, blocksize=2 ** 8), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE, blocksize=2 ** 8)]\n    for codec in codecs:\n        for arr in arrays:\n            check_encode_decode(arr, codec)",
            "@pytest.mark.xfail_browsers(chrome='test_numcodecs triggers a recursion error in chrome')\n@run_in_pyodide(packages=['numcodecs', 'numpy'])\ndef test_blosc(selenium_standalone):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    import array\n    import numpy as np\n    from numcodecs.blosc import Blosc\n    from numcodecs.compat import ensure_bytes, ensure_ndarray\n    from numcodecs.lz4 import LZ4\n    from numcodecs.zstd import Zstd\n    from numpy.testing import assert_array_almost_equal, assert_array_equal\n\n    def compare_arrays(arr, res, precision=None):\n        res = ensure_ndarray(res).view(arr.dtype)\n        if arr.flags.f_contiguous:\n            order = 'F'\n        else:\n            order = 'C'\n        res = res.reshape(arr.shape, order=order)\n        if precision is None:\n            assert_array_equal(arr, res)\n        else:\n            assert_array_almost_equal(arr, res, decimal=precision)\n\n    def check_encode_decode(arr, codec, precision=None):\n        enc = codec.encode(arr)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = arr.tobytes(order='A')\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = bytearray(arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        enc_bytes = ensure_bytes(enc)\n        dec = codec.decode(enc_bytes)\n        compare_arrays(arr, dec, precision=precision)\n        dec = codec.decode(bytearray(enc_bytes))\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', enc_bytes)\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        buf = np.frombuffer(enc_bytes, dtype='u1')\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        out = np.empty_like(arr)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n        out = bytearray(arr.nbytes)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n    arrays = [np.arange(1000, dtype='i4'), np.linspace(1000, 1001, 1000, dtype='f8'), np.random.normal(loc=1000, scale=1, size=(100, 10)), np.random.randint(0, 2, size=1000, dtype=bool).reshape(100, 10, order='F'), np.random.choice([b'a', b'bb', b'ccc'], size=1000).reshape(10, 10, 10), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('M8[ns]'), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('m8[ns]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('M8[m]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('m8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[m]')]\n    codecs = [LZ4(), LZ4(acceleration=-1), LZ4(acceleration=10), Zstd(), Zstd(level=-1), Zstd(level=10), Blosc(shuffle=Blosc.SHUFFLE), Blosc(clevel=0, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE), Blosc(cname='lz4', clevel=5, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=9, shuffle=Blosc.BITSHUFFLE), Blosc(cname='zlib', clevel=1, shuffle=0), Blosc(cname='zstd', clevel=1, shuffle=1), Blosc(cname='blosclz', clevel=1, shuffle=2), Blosc(shuffle=Blosc.SHUFFLE, blocksize=0), Blosc(shuffle=Blosc.SHUFFLE, blocksize=2 ** 8), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE, blocksize=2 ** 8)]\n    for codec in codecs:\n        for arr in arrays:\n            check_encode_decode(arr, codec)",
            "@pytest.mark.xfail_browsers(chrome='test_numcodecs triggers a recursion error in chrome')\n@run_in_pyodide(packages=['numcodecs', 'numpy'])\ndef test_blosc(selenium_standalone):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    import array\n    import numpy as np\n    from numcodecs.blosc import Blosc\n    from numcodecs.compat import ensure_bytes, ensure_ndarray\n    from numcodecs.lz4 import LZ4\n    from numcodecs.zstd import Zstd\n    from numpy.testing import assert_array_almost_equal, assert_array_equal\n\n    def compare_arrays(arr, res, precision=None):\n        res = ensure_ndarray(res).view(arr.dtype)\n        if arr.flags.f_contiguous:\n            order = 'F'\n        else:\n            order = 'C'\n        res = res.reshape(arr.shape, order=order)\n        if precision is None:\n            assert_array_equal(arr, res)\n        else:\n            assert_array_almost_equal(arr, res, decimal=precision)\n\n    def check_encode_decode(arr, codec, precision=None):\n        enc = codec.encode(arr)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = arr.tobytes(order='A')\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = bytearray(arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', arr.tobytes(order='A'))\n        enc = codec.encode(buf)\n        dec = codec.decode(enc)\n        compare_arrays(arr, dec, precision=precision)\n        enc_bytes = ensure_bytes(enc)\n        dec = codec.decode(enc_bytes)\n        compare_arrays(arr, dec, precision=precision)\n        dec = codec.decode(bytearray(enc_bytes))\n        compare_arrays(arr, dec, precision=precision)\n        buf = array.array('b', enc_bytes)\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        buf = np.frombuffer(enc_bytes, dtype='u1')\n        dec = codec.decode(buf)\n        compare_arrays(arr, dec, precision=precision)\n        out = np.empty_like(arr)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n        out = bytearray(arr.nbytes)\n        codec.decode(enc_bytes, out=out)\n        compare_arrays(arr, out, precision=precision)\n    arrays = [np.arange(1000, dtype='i4'), np.linspace(1000, 1001, 1000, dtype='f8'), np.random.normal(loc=1000, scale=1, size=(100, 10)), np.random.randint(0, 2, size=1000, dtype=bool).reshape(100, 10, order='F'), np.random.choice([b'a', b'bb', b'ccc'], size=1000).reshape(10, 10, 10), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('M8[ns]'), np.random.randint(0, 2 ** 60, size=1000, dtype='u8').view('m8[ns]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('M8[m]'), np.random.randint(0, 2 ** 25, size=1000, dtype='u8').view('m8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[ns]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('M8[m]'), np.random.randint(-2 ** 63, -2 ** 63 + 20, size=1000, dtype='i8').view('m8[m]')]\n    codecs = [LZ4(), LZ4(acceleration=-1), LZ4(acceleration=10), Zstd(), Zstd(level=-1), Zstd(level=10), Blosc(shuffle=Blosc.SHUFFLE), Blosc(clevel=0, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE), Blosc(cname='lz4', clevel=5, shuffle=Blosc.SHUFFLE), Blosc(cname='lz4', clevel=9, shuffle=Blosc.BITSHUFFLE), Blosc(cname='zlib', clevel=1, shuffle=0), Blosc(cname='zstd', clevel=1, shuffle=1), Blosc(cname='blosclz', clevel=1, shuffle=2), Blosc(shuffle=Blosc.SHUFFLE, blocksize=0), Blosc(shuffle=Blosc.SHUFFLE, blocksize=2 ** 8), Blosc(cname='lz4', clevel=1, shuffle=Blosc.NOSHUFFLE, blocksize=2 ** 8)]\n    for codec in codecs:\n        for arr in arrays:\n            check_encode_decode(arr, codec)"
        ]
    }
]