[
    {
        "func_name": "setUp",
        "original": "def setUp(self):\n    super().setUp()\n    np.random.seed(6908265)",
        "mutated": [
            "def setUp(self):\n    if False:\n        i = 10\n    super().setUp()\n    np.random.seed(6908265)",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().setUp()\n    np.random.seed(6908265)",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().setUp()\n    np.random.seed(6908265)",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().setUp()\n    np.random.seed(6908265)",
            "def setUp(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().setUp()\n    np.random.seed(6908265)"
        ]
    },
    {
        "func_name": "test_layer2q_matrix",
        "original": "def test_layer2q_matrix(self):\n    \"\"\"\n        Tests: (1) the correctness of Layer2Q matrix construction;\n        (2) matrix multiplication interleaved with permutations.\n        \"\"\"\n    mat_kind = 'complex'\n    _eps = 100.0 * np.finfo(float).eps\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        iden = tut.eye_int(n)\n        for j in range(n):\n            for k in range(n):\n                if j == k:\n                    continue\n                m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n                (t_mat, g_mat) = tut.make_test_matrices4x4(n=n, j=j, k=k, kind=mat_kind)\n                lmat = lr.Layer2Q(num_qubits=n, j=j, k=k, g4x4=g_mat)\n                (g2, perm, inv_perm) = lmat.get_attr()\n                self.assertTrue(m_mat.dtype == t_mat.dtype == g_mat.dtype == g2.dtype)\n                self.assertTrue(np.all(g_mat == g2))\n                self.assertTrue(np.all(iden[perm].T == iden[inv_perm]))\n                g_mat = np.kron(tut.eye_int(n - 2), g_mat)\n                err = tut.relative_error(t_mat, iden[perm].T @ g_mat @ iden[perm])\n                self.assertLess(err, _eps, 'err = {:0.16f}'.format(err))\n                max_rel_err = max(max_rel_err, err)\n                tm = t_mat @ m_mat\n                err1 = tut.relative_error(iden[perm].T @ g_mat @ m_mat[perm], tm)\n                err2 = tut.relative_error((g_mat @ m_mat[perm])[inv_perm], tm)\n                mt = m_mat @ t_mat\n                err3 = tut.relative_error(m_mat @ iden[perm].T @ g_mat @ iden[perm], mt)\n                err4 = tut.relative_error((m_mat[:, perm] @ g_mat)[:, inv_perm], mt)\n                self.assertTrue(err1 < _eps and err2 < _eps and (err3 < _eps) and (err4 < _eps), 'err1 = {:f},  err2 = {:f},  err3 = {:f},  err4 = {:f}'.format(err1, err2, err3, err4))\n                max_rel_err = max(max_rel_err, err1, err2, err3, err4)",
        "mutated": [
            "def test_layer2q_matrix(self):\n    if False:\n        i = 10\n    '\\n        Tests: (1) the correctness of Layer2Q matrix construction;\\n        (2) matrix multiplication interleaved with permutations.\\n        '\n    mat_kind = 'complex'\n    _eps = 100.0 * np.finfo(float).eps\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        iden = tut.eye_int(n)\n        for j in range(n):\n            for k in range(n):\n                if j == k:\n                    continue\n                m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n                (t_mat, g_mat) = tut.make_test_matrices4x4(n=n, j=j, k=k, kind=mat_kind)\n                lmat = lr.Layer2Q(num_qubits=n, j=j, k=k, g4x4=g_mat)\n                (g2, perm, inv_perm) = lmat.get_attr()\n                self.assertTrue(m_mat.dtype == t_mat.dtype == g_mat.dtype == g2.dtype)\n                self.assertTrue(np.all(g_mat == g2))\n                self.assertTrue(np.all(iden[perm].T == iden[inv_perm]))\n                g_mat = np.kron(tut.eye_int(n - 2), g_mat)\n                err = tut.relative_error(t_mat, iden[perm].T @ g_mat @ iden[perm])\n                self.assertLess(err, _eps, 'err = {:0.16f}'.format(err))\n                max_rel_err = max(max_rel_err, err)\n                tm = t_mat @ m_mat\n                err1 = tut.relative_error(iden[perm].T @ g_mat @ m_mat[perm], tm)\n                err2 = tut.relative_error((g_mat @ m_mat[perm])[inv_perm], tm)\n                mt = m_mat @ t_mat\n                err3 = tut.relative_error(m_mat @ iden[perm].T @ g_mat @ iden[perm], mt)\n                err4 = tut.relative_error((m_mat[:, perm] @ g_mat)[:, inv_perm], mt)\n                self.assertTrue(err1 < _eps and err2 < _eps and (err3 < _eps) and (err4 < _eps), 'err1 = {:f},  err2 = {:f},  err3 = {:f},  err4 = {:f}'.format(err1, err2, err3, err4))\n                max_rel_err = max(max_rel_err, err1, err2, err3, err4)",
            "def test_layer2q_matrix(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Tests: (1) the correctness of Layer2Q matrix construction;\\n        (2) matrix multiplication interleaved with permutations.\\n        '\n    mat_kind = 'complex'\n    _eps = 100.0 * np.finfo(float).eps\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        iden = tut.eye_int(n)\n        for j in range(n):\n            for k in range(n):\n                if j == k:\n                    continue\n                m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n                (t_mat, g_mat) = tut.make_test_matrices4x4(n=n, j=j, k=k, kind=mat_kind)\n                lmat = lr.Layer2Q(num_qubits=n, j=j, k=k, g4x4=g_mat)\n                (g2, perm, inv_perm) = lmat.get_attr()\n                self.assertTrue(m_mat.dtype == t_mat.dtype == g_mat.dtype == g2.dtype)\n                self.assertTrue(np.all(g_mat == g2))\n                self.assertTrue(np.all(iden[perm].T == iden[inv_perm]))\n                g_mat = np.kron(tut.eye_int(n - 2), g_mat)\n                err = tut.relative_error(t_mat, iden[perm].T @ g_mat @ iden[perm])\n                self.assertLess(err, _eps, 'err = {:0.16f}'.format(err))\n                max_rel_err = max(max_rel_err, err)\n                tm = t_mat @ m_mat\n                err1 = tut.relative_error(iden[perm].T @ g_mat @ m_mat[perm], tm)\n                err2 = tut.relative_error((g_mat @ m_mat[perm])[inv_perm], tm)\n                mt = m_mat @ t_mat\n                err3 = tut.relative_error(m_mat @ iden[perm].T @ g_mat @ iden[perm], mt)\n                err4 = tut.relative_error((m_mat[:, perm] @ g_mat)[:, inv_perm], mt)\n                self.assertTrue(err1 < _eps and err2 < _eps and (err3 < _eps) and (err4 < _eps), 'err1 = {:f},  err2 = {:f},  err3 = {:f},  err4 = {:f}'.format(err1, err2, err3, err4))\n                max_rel_err = max(max_rel_err, err1, err2, err3, err4)",
            "def test_layer2q_matrix(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Tests: (1) the correctness of Layer2Q matrix construction;\\n        (2) matrix multiplication interleaved with permutations.\\n        '\n    mat_kind = 'complex'\n    _eps = 100.0 * np.finfo(float).eps\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        iden = tut.eye_int(n)\n        for j in range(n):\n            for k in range(n):\n                if j == k:\n                    continue\n                m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n                (t_mat, g_mat) = tut.make_test_matrices4x4(n=n, j=j, k=k, kind=mat_kind)\n                lmat = lr.Layer2Q(num_qubits=n, j=j, k=k, g4x4=g_mat)\n                (g2, perm, inv_perm) = lmat.get_attr()\n                self.assertTrue(m_mat.dtype == t_mat.dtype == g_mat.dtype == g2.dtype)\n                self.assertTrue(np.all(g_mat == g2))\n                self.assertTrue(np.all(iden[perm].T == iden[inv_perm]))\n                g_mat = np.kron(tut.eye_int(n - 2), g_mat)\n                err = tut.relative_error(t_mat, iden[perm].T @ g_mat @ iden[perm])\n                self.assertLess(err, _eps, 'err = {:0.16f}'.format(err))\n                max_rel_err = max(max_rel_err, err)\n                tm = t_mat @ m_mat\n                err1 = tut.relative_error(iden[perm].T @ g_mat @ m_mat[perm], tm)\n                err2 = tut.relative_error((g_mat @ m_mat[perm])[inv_perm], tm)\n                mt = m_mat @ t_mat\n                err3 = tut.relative_error(m_mat @ iden[perm].T @ g_mat @ iden[perm], mt)\n                err4 = tut.relative_error((m_mat[:, perm] @ g_mat)[:, inv_perm], mt)\n                self.assertTrue(err1 < _eps and err2 < _eps and (err3 < _eps) and (err4 < _eps), 'err1 = {:f},  err2 = {:f},  err3 = {:f},  err4 = {:f}'.format(err1, err2, err3, err4))\n                max_rel_err = max(max_rel_err, err1, err2, err3, err4)",
            "def test_layer2q_matrix(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Tests: (1) the correctness of Layer2Q matrix construction;\\n        (2) matrix multiplication interleaved with permutations.\\n        '\n    mat_kind = 'complex'\n    _eps = 100.0 * np.finfo(float).eps\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        iden = tut.eye_int(n)\n        for j in range(n):\n            for k in range(n):\n                if j == k:\n                    continue\n                m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n                (t_mat, g_mat) = tut.make_test_matrices4x4(n=n, j=j, k=k, kind=mat_kind)\n                lmat = lr.Layer2Q(num_qubits=n, j=j, k=k, g4x4=g_mat)\n                (g2, perm, inv_perm) = lmat.get_attr()\n                self.assertTrue(m_mat.dtype == t_mat.dtype == g_mat.dtype == g2.dtype)\n                self.assertTrue(np.all(g_mat == g2))\n                self.assertTrue(np.all(iden[perm].T == iden[inv_perm]))\n                g_mat = np.kron(tut.eye_int(n - 2), g_mat)\n                err = tut.relative_error(t_mat, iden[perm].T @ g_mat @ iden[perm])\n                self.assertLess(err, _eps, 'err = {:0.16f}'.format(err))\n                max_rel_err = max(max_rel_err, err)\n                tm = t_mat @ m_mat\n                err1 = tut.relative_error(iden[perm].T @ g_mat @ m_mat[perm], tm)\n                err2 = tut.relative_error((g_mat @ m_mat[perm])[inv_perm], tm)\n                mt = m_mat @ t_mat\n                err3 = tut.relative_error(m_mat @ iden[perm].T @ g_mat @ iden[perm], mt)\n                err4 = tut.relative_error((m_mat[:, perm] @ g_mat)[:, inv_perm], mt)\n                self.assertTrue(err1 < _eps and err2 < _eps and (err3 < _eps) and (err4 < _eps), 'err1 = {:f},  err2 = {:f},  err3 = {:f},  err4 = {:f}'.format(err1, err2, err3, err4))\n                max_rel_err = max(max_rel_err, err1, err2, err3, err4)",
            "def test_layer2q_matrix(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Tests: (1) the correctness of Layer2Q matrix construction;\\n        (2) matrix multiplication interleaved with permutations.\\n        '\n    mat_kind = 'complex'\n    _eps = 100.0 * np.finfo(float).eps\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        iden = tut.eye_int(n)\n        for j in range(n):\n            for k in range(n):\n                if j == k:\n                    continue\n                m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n                (t_mat, g_mat) = tut.make_test_matrices4x4(n=n, j=j, k=k, kind=mat_kind)\n                lmat = lr.Layer2Q(num_qubits=n, j=j, k=k, g4x4=g_mat)\n                (g2, perm, inv_perm) = lmat.get_attr()\n                self.assertTrue(m_mat.dtype == t_mat.dtype == g_mat.dtype == g2.dtype)\n                self.assertTrue(np.all(g_mat == g2))\n                self.assertTrue(np.all(iden[perm].T == iden[inv_perm]))\n                g_mat = np.kron(tut.eye_int(n - 2), g_mat)\n                err = tut.relative_error(t_mat, iden[perm].T @ g_mat @ iden[perm])\n                self.assertLess(err, _eps, 'err = {:0.16f}'.format(err))\n                max_rel_err = max(max_rel_err, err)\n                tm = t_mat @ m_mat\n                err1 = tut.relative_error(iden[perm].T @ g_mat @ m_mat[perm], tm)\n                err2 = tut.relative_error((g_mat @ m_mat[perm])[inv_perm], tm)\n                mt = m_mat @ t_mat\n                err3 = tut.relative_error(m_mat @ iden[perm].T @ g_mat @ iden[perm], mt)\n                err4 = tut.relative_error((m_mat[:, perm] @ g_mat)[:, inv_perm], mt)\n                self.assertTrue(err1 < _eps and err2 < _eps and (err3 < _eps) and (err4 < _eps), 'err1 = {:f},  err2 = {:f},  err3 = {:f},  err4 = {:f}'.format(err1, err2, err3, err4))\n                max_rel_err = max(max_rel_err, err1, err2, err3, err4)"
        ]
    },
    {
        "func_name": "test_pmatrix_class",
        "original": "def test_pmatrix_class(self):\n    \"\"\"\n        Test the class PMatrix.\n        \"\"\"\n    _eps = 100.0 * np.finfo(float).eps\n    mat_kind = 'complex'\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        tmp1 = np.ndarray((dim, dim), dtype=np.complex128)\n        tmp2 = tmp1.copy()\n        for _ in range(self.num_repeats):\n            j0 = randint(0, n - 1)\n            k0 = (j0 + randint(1, n - 1)) % n\n            j1 = randint(0, n - 1)\n            k1 = (j1 + randint(1, n - 1)) % n\n            j2 = randint(0, n - 1)\n            k2 = (j2 + randint(1, n - 1)) % n\n            j3 = randint(0, n - 1)\n            k3 = (j3 + randint(1, n - 1)) % n\n            j4 = randint(0, n - 1)\n            k4 = (j4 + randint(1, n - 1)) % n\n            (t0, g0) = tut.make_test_matrices4x4(n=n, j=j0, k=k0, kind=mat_kind)\n            (t1, g1) = tut.make_test_matrices4x4(n=n, j=j1, k=k1, kind=mat_kind)\n            (t2, g2) = tut.make_test_matrices4x4(n=n, j=j2, k=k2, kind=mat_kind)\n            (t3, g3) = tut.make_test_matrices4x4(n=n, j=j3, k=k3, kind=mat_kind)\n            (t4, g4) = tut.make_test_matrices4x4(n=n, j=j4, k=k4, kind=mat_kind)\n            c0 = lr.Layer2Q(num_qubits=n, j=j0, k=k0, g4x4=g0)\n            c1 = lr.Layer2Q(num_qubits=n, j=j1, k=k1, g4x4=g1)\n            c2 = lr.Layer2Q(num_qubits=n, j=j2, k=k2, g4x4=g2)\n            c3 = lr.Layer2Q(num_qubits=n, j=j3, k=k3, g4x4=g3)\n            c4 = lr.Layer2Q(num_qubits=n, j=j4, k=k4, g4x4=g4)\n            m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n            ttmtt = t0 @ t1 @ m_mat @ np.conj(t2).T @ np.conj(t3).T\n            pmat = PMatrix(n)\n            pmat.set_matrix(m_mat)\n            pmat.mul_left_q2(layer=c1, temp_mat=tmp1)\n            pmat.mul_left_q2(layer=c0, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c2, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c3, temp_mat=tmp1)\n            alt_ttmtt = pmat.finalize(temp_mat=tmp1)\n            err1 = tut.relative_error(alt_ttmtt, ttmtt)\n            self.assertLess(err1, _eps, 'relative error: {:f}'.format(err1))\n            prod = np.complex128(np.trace(ttmtt @ t4))\n            alt_prod = pmat.product_q2(layer=c4, tmp1=tmp1, tmp2=tmp2)\n            err2 = abs(alt_prod - prod) / abs(prod)\n            self.assertLess(err2, _eps, 'relative error: {:f}'.format(err2))\n            max_rel_err = max(max_rel_err, err1, err2)",
        "mutated": [
            "def test_pmatrix_class(self):\n    if False:\n        i = 10\n    '\\n        Test the class PMatrix.\\n        '\n    _eps = 100.0 * np.finfo(float).eps\n    mat_kind = 'complex'\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        tmp1 = np.ndarray((dim, dim), dtype=np.complex128)\n        tmp2 = tmp1.copy()\n        for _ in range(self.num_repeats):\n            j0 = randint(0, n - 1)\n            k0 = (j0 + randint(1, n - 1)) % n\n            j1 = randint(0, n - 1)\n            k1 = (j1 + randint(1, n - 1)) % n\n            j2 = randint(0, n - 1)\n            k2 = (j2 + randint(1, n - 1)) % n\n            j3 = randint(0, n - 1)\n            k3 = (j3 + randint(1, n - 1)) % n\n            j4 = randint(0, n - 1)\n            k4 = (j4 + randint(1, n - 1)) % n\n            (t0, g0) = tut.make_test_matrices4x4(n=n, j=j0, k=k0, kind=mat_kind)\n            (t1, g1) = tut.make_test_matrices4x4(n=n, j=j1, k=k1, kind=mat_kind)\n            (t2, g2) = tut.make_test_matrices4x4(n=n, j=j2, k=k2, kind=mat_kind)\n            (t3, g3) = tut.make_test_matrices4x4(n=n, j=j3, k=k3, kind=mat_kind)\n            (t4, g4) = tut.make_test_matrices4x4(n=n, j=j4, k=k4, kind=mat_kind)\n            c0 = lr.Layer2Q(num_qubits=n, j=j0, k=k0, g4x4=g0)\n            c1 = lr.Layer2Q(num_qubits=n, j=j1, k=k1, g4x4=g1)\n            c2 = lr.Layer2Q(num_qubits=n, j=j2, k=k2, g4x4=g2)\n            c3 = lr.Layer2Q(num_qubits=n, j=j3, k=k3, g4x4=g3)\n            c4 = lr.Layer2Q(num_qubits=n, j=j4, k=k4, g4x4=g4)\n            m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n            ttmtt = t0 @ t1 @ m_mat @ np.conj(t2).T @ np.conj(t3).T\n            pmat = PMatrix(n)\n            pmat.set_matrix(m_mat)\n            pmat.mul_left_q2(layer=c1, temp_mat=tmp1)\n            pmat.mul_left_q2(layer=c0, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c2, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c3, temp_mat=tmp1)\n            alt_ttmtt = pmat.finalize(temp_mat=tmp1)\n            err1 = tut.relative_error(alt_ttmtt, ttmtt)\n            self.assertLess(err1, _eps, 'relative error: {:f}'.format(err1))\n            prod = np.complex128(np.trace(ttmtt @ t4))\n            alt_prod = pmat.product_q2(layer=c4, tmp1=tmp1, tmp2=tmp2)\n            err2 = abs(alt_prod - prod) / abs(prod)\n            self.assertLess(err2, _eps, 'relative error: {:f}'.format(err2))\n            max_rel_err = max(max_rel_err, err1, err2)",
            "def test_pmatrix_class(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Test the class PMatrix.\\n        '\n    _eps = 100.0 * np.finfo(float).eps\n    mat_kind = 'complex'\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        tmp1 = np.ndarray((dim, dim), dtype=np.complex128)\n        tmp2 = tmp1.copy()\n        for _ in range(self.num_repeats):\n            j0 = randint(0, n - 1)\n            k0 = (j0 + randint(1, n - 1)) % n\n            j1 = randint(0, n - 1)\n            k1 = (j1 + randint(1, n - 1)) % n\n            j2 = randint(0, n - 1)\n            k2 = (j2 + randint(1, n - 1)) % n\n            j3 = randint(0, n - 1)\n            k3 = (j3 + randint(1, n - 1)) % n\n            j4 = randint(0, n - 1)\n            k4 = (j4 + randint(1, n - 1)) % n\n            (t0, g0) = tut.make_test_matrices4x4(n=n, j=j0, k=k0, kind=mat_kind)\n            (t1, g1) = tut.make_test_matrices4x4(n=n, j=j1, k=k1, kind=mat_kind)\n            (t2, g2) = tut.make_test_matrices4x4(n=n, j=j2, k=k2, kind=mat_kind)\n            (t3, g3) = tut.make_test_matrices4x4(n=n, j=j3, k=k3, kind=mat_kind)\n            (t4, g4) = tut.make_test_matrices4x4(n=n, j=j4, k=k4, kind=mat_kind)\n            c0 = lr.Layer2Q(num_qubits=n, j=j0, k=k0, g4x4=g0)\n            c1 = lr.Layer2Q(num_qubits=n, j=j1, k=k1, g4x4=g1)\n            c2 = lr.Layer2Q(num_qubits=n, j=j2, k=k2, g4x4=g2)\n            c3 = lr.Layer2Q(num_qubits=n, j=j3, k=k3, g4x4=g3)\n            c4 = lr.Layer2Q(num_qubits=n, j=j4, k=k4, g4x4=g4)\n            m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n            ttmtt = t0 @ t1 @ m_mat @ np.conj(t2).T @ np.conj(t3).T\n            pmat = PMatrix(n)\n            pmat.set_matrix(m_mat)\n            pmat.mul_left_q2(layer=c1, temp_mat=tmp1)\n            pmat.mul_left_q2(layer=c0, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c2, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c3, temp_mat=tmp1)\n            alt_ttmtt = pmat.finalize(temp_mat=tmp1)\n            err1 = tut.relative_error(alt_ttmtt, ttmtt)\n            self.assertLess(err1, _eps, 'relative error: {:f}'.format(err1))\n            prod = np.complex128(np.trace(ttmtt @ t4))\n            alt_prod = pmat.product_q2(layer=c4, tmp1=tmp1, tmp2=tmp2)\n            err2 = abs(alt_prod - prod) / abs(prod)\n            self.assertLess(err2, _eps, 'relative error: {:f}'.format(err2))\n            max_rel_err = max(max_rel_err, err1, err2)",
            "def test_pmatrix_class(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Test the class PMatrix.\\n        '\n    _eps = 100.0 * np.finfo(float).eps\n    mat_kind = 'complex'\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        tmp1 = np.ndarray((dim, dim), dtype=np.complex128)\n        tmp2 = tmp1.copy()\n        for _ in range(self.num_repeats):\n            j0 = randint(0, n - 1)\n            k0 = (j0 + randint(1, n - 1)) % n\n            j1 = randint(0, n - 1)\n            k1 = (j1 + randint(1, n - 1)) % n\n            j2 = randint(0, n - 1)\n            k2 = (j2 + randint(1, n - 1)) % n\n            j3 = randint(0, n - 1)\n            k3 = (j3 + randint(1, n - 1)) % n\n            j4 = randint(0, n - 1)\n            k4 = (j4 + randint(1, n - 1)) % n\n            (t0, g0) = tut.make_test_matrices4x4(n=n, j=j0, k=k0, kind=mat_kind)\n            (t1, g1) = tut.make_test_matrices4x4(n=n, j=j1, k=k1, kind=mat_kind)\n            (t2, g2) = tut.make_test_matrices4x4(n=n, j=j2, k=k2, kind=mat_kind)\n            (t3, g3) = tut.make_test_matrices4x4(n=n, j=j3, k=k3, kind=mat_kind)\n            (t4, g4) = tut.make_test_matrices4x4(n=n, j=j4, k=k4, kind=mat_kind)\n            c0 = lr.Layer2Q(num_qubits=n, j=j0, k=k0, g4x4=g0)\n            c1 = lr.Layer2Q(num_qubits=n, j=j1, k=k1, g4x4=g1)\n            c2 = lr.Layer2Q(num_qubits=n, j=j2, k=k2, g4x4=g2)\n            c3 = lr.Layer2Q(num_qubits=n, j=j3, k=k3, g4x4=g3)\n            c4 = lr.Layer2Q(num_qubits=n, j=j4, k=k4, g4x4=g4)\n            m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n            ttmtt = t0 @ t1 @ m_mat @ np.conj(t2).T @ np.conj(t3).T\n            pmat = PMatrix(n)\n            pmat.set_matrix(m_mat)\n            pmat.mul_left_q2(layer=c1, temp_mat=tmp1)\n            pmat.mul_left_q2(layer=c0, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c2, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c3, temp_mat=tmp1)\n            alt_ttmtt = pmat.finalize(temp_mat=tmp1)\n            err1 = tut.relative_error(alt_ttmtt, ttmtt)\n            self.assertLess(err1, _eps, 'relative error: {:f}'.format(err1))\n            prod = np.complex128(np.trace(ttmtt @ t4))\n            alt_prod = pmat.product_q2(layer=c4, tmp1=tmp1, tmp2=tmp2)\n            err2 = abs(alt_prod - prod) / abs(prod)\n            self.assertLess(err2, _eps, 'relative error: {:f}'.format(err2))\n            max_rel_err = max(max_rel_err, err1, err2)",
            "def test_pmatrix_class(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Test the class PMatrix.\\n        '\n    _eps = 100.0 * np.finfo(float).eps\n    mat_kind = 'complex'\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        tmp1 = np.ndarray((dim, dim), dtype=np.complex128)\n        tmp2 = tmp1.copy()\n        for _ in range(self.num_repeats):\n            j0 = randint(0, n - 1)\n            k0 = (j0 + randint(1, n - 1)) % n\n            j1 = randint(0, n - 1)\n            k1 = (j1 + randint(1, n - 1)) % n\n            j2 = randint(0, n - 1)\n            k2 = (j2 + randint(1, n - 1)) % n\n            j3 = randint(0, n - 1)\n            k3 = (j3 + randint(1, n - 1)) % n\n            j4 = randint(0, n - 1)\n            k4 = (j4 + randint(1, n - 1)) % n\n            (t0, g0) = tut.make_test_matrices4x4(n=n, j=j0, k=k0, kind=mat_kind)\n            (t1, g1) = tut.make_test_matrices4x4(n=n, j=j1, k=k1, kind=mat_kind)\n            (t2, g2) = tut.make_test_matrices4x4(n=n, j=j2, k=k2, kind=mat_kind)\n            (t3, g3) = tut.make_test_matrices4x4(n=n, j=j3, k=k3, kind=mat_kind)\n            (t4, g4) = tut.make_test_matrices4x4(n=n, j=j4, k=k4, kind=mat_kind)\n            c0 = lr.Layer2Q(num_qubits=n, j=j0, k=k0, g4x4=g0)\n            c1 = lr.Layer2Q(num_qubits=n, j=j1, k=k1, g4x4=g1)\n            c2 = lr.Layer2Q(num_qubits=n, j=j2, k=k2, g4x4=g2)\n            c3 = lr.Layer2Q(num_qubits=n, j=j3, k=k3, g4x4=g3)\n            c4 = lr.Layer2Q(num_qubits=n, j=j4, k=k4, g4x4=g4)\n            m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n            ttmtt = t0 @ t1 @ m_mat @ np.conj(t2).T @ np.conj(t3).T\n            pmat = PMatrix(n)\n            pmat.set_matrix(m_mat)\n            pmat.mul_left_q2(layer=c1, temp_mat=tmp1)\n            pmat.mul_left_q2(layer=c0, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c2, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c3, temp_mat=tmp1)\n            alt_ttmtt = pmat.finalize(temp_mat=tmp1)\n            err1 = tut.relative_error(alt_ttmtt, ttmtt)\n            self.assertLess(err1, _eps, 'relative error: {:f}'.format(err1))\n            prod = np.complex128(np.trace(ttmtt @ t4))\n            alt_prod = pmat.product_q2(layer=c4, tmp1=tmp1, tmp2=tmp2)\n            err2 = abs(alt_prod - prod) / abs(prod)\n            self.assertLess(err2, _eps, 'relative error: {:f}'.format(err2))\n            max_rel_err = max(max_rel_err, err1, err2)",
            "def test_pmatrix_class(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Test the class PMatrix.\\n        '\n    _eps = 100.0 * np.finfo(float).eps\n    mat_kind = 'complex'\n    max_rel_err = 0.0\n    for n in range(2, self.max_num_qubits + 1):\n        dim = 2 ** n\n        tmp1 = np.ndarray((dim, dim), dtype=np.complex128)\n        tmp2 = tmp1.copy()\n        for _ in range(self.num_repeats):\n            j0 = randint(0, n - 1)\n            k0 = (j0 + randint(1, n - 1)) % n\n            j1 = randint(0, n - 1)\n            k1 = (j1 + randint(1, n - 1)) % n\n            j2 = randint(0, n - 1)\n            k2 = (j2 + randint(1, n - 1)) % n\n            j3 = randint(0, n - 1)\n            k3 = (j3 + randint(1, n - 1)) % n\n            j4 = randint(0, n - 1)\n            k4 = (j4 + randint(1, n - 1)) % n\n            (t0, g0) = tut.make_test_matrices4x4(n=n, j=j0, k=k0, kind=mat_kind)\n            (t1, g1) = tut.make_test_matrices4x4(n=n, j=j1, k=k1, kind=mat_kind)\n            (t2, g2) = tut.make_test_matrices4x4(n=n, j=j2, k=k2, kind=mat_kind)\n            (t3, g3) = tut.make_test_matrices4x4(n=n, j=j3, k=k3, kind=mat_kind)\n            (t4, g4) = tut.make_test_matrices4x4(n=n, j=j4, k=k4, kind=mat_kind)\n            c0 = lr.Layer2Q(num_qubits=n, j=j0, k=k0, g4x4=g0)\n            c1 = lr.Layer2Q(num_qubits=n, j=j1, k=k1, g4x4=g1)\n            c2 = lr.Layer2Q(num_qubits=n, j=j2, k=k2, g4x4=g2)\n            c3 = lr.Layer2Q(num_qubits=n, j=j3, k=k3, g4x4=g3)\n            c4 = lr.Layer2Q(num_qubits=n, j=j4, k=k4, g4x4=g4)\n            m_mat = tut.rand_matrix(dim=dim, kind=mat_kind)\n            ttmtt = t0 @ t1 @ m_mat @ np.conj(t2).T @ np.conj(t3).T\n            pmat = PMatrix(n)\n            pmat.set_matrix(m_mat)\n            pmat.mul_left_q2(layer=c1, temp_mat=tmp1)\n            pmat.mul_left_q2(layer=c0, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c2, temp_mat=tmp1)\n            pmat.mul_right_q2(layer=c3, temp_mat=tmp1)\n            alt_ttmtt = pmat.finalize(temp_mat=tmp1)\n            err1 = tut.relative_error(alt_ttmtt, ttmtt)\n            self.assertLess(err1, _eps, 'relative error: {:f}'.format(err1))\n            prod = np.complex128(np.trace(ttmtt @ t4))\n            alt_prod = pmat.product_q2(layer=c4, tmp1=tmp1, tmp2=tmp2)\n            err2 = abs(alt_prod - prod) / abs(prod)\n            self.assertLess(err2, _eps, 'relative error: {:f}'.format(err2))\n            max_rel_err = max(max_rel_err, err1, err2)"
        ]
    }
]