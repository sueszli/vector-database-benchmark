[
    {
        "func_name": "setup_ldl_factor",
        "original": "def setup_ldl_factor(c, G, h, dims, A, b):\n    \"\"\"\n    The meanings of arguments in this function are identical to those of the\n    function cvxopt.solvers.conelp. Refer to CVXOPT documentation\n\n        https://cvxopt.org/userguide/coneprog.html#linear-cone-programs\n\n    for more information.\n\n    Note: CVXOPT allows G and A to be passed as dense matrix objects. However,\n    this function will only ever be called with spmatrix objects. If creating\n    a custom kktsolver of your own, you need to conform to this sparse matrix\n    assumption.\n    \"\"\"\n    factor = kkt_ldl(G, dims, A)\n    return factor",
        "mutated": [
            "def setup_ldl_factor(c, G, h, dims, A, b):\n    if False:\n        i = 10\n    '\\n    The meanings of arguments in this function are identical to those of the\\n    function cvxopt.solvers.conelp. Refer to CVXOPT documentation\\n\\n        https://cvxopt.org/userguide/coneprog.html#linear-cone-programs\\n\\n    for more information.\\n\\n    Note: CVXOPT allows G and A to be passed as dense matrix objects. However,\\n    this function will only ever be called with spmatrix objects. If creating\\n    a custom kktsolver of your own, you need to conform to this sparse matrix\\n    assumption.\\n    '\n    factor = kkt_ldl(G, dims, A)\n    return factor",
            "def setup_ldl_factor(c, G, h, dims, A, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The meanings of arguments in this function are identical to those of the\\n    function cvxopt.solvers.conelp. Refer to CVXOPT documentation\\n\\n        https://cvxopt.org/userguide/coneprog.html#linear-cone-programs\\n\\n    for more information.\\n\\n    Note: CVXOPT allows G and A to be passed as dense matrix objects. However,\\n    this function will only ever be called with spmatrix objects. If creating\\n    a custom kktsolver of your own, you need to conform to this sparse matrix\\n    assumption.\\n    '\n    factor = kkt_ldl(G, dims, A)\n    return factor",
            "def setup_ldl_factor(c, G, h, dims, A, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The meanings of arguments in this function are identical to those of the\\n    function cvxopt.solvers.conelp. Refer to CVXOPT documentation\\n\\n        https://cvxopt.org/userguide/coneprog.html#linear-cone-programs\\n\\n    for more information.\\n\\n    Note: CVXOPT allows G and A to be passed as dense matrix objects. However,\\n    this function will only ever be called with spmatrix objects. If creating\\n    a custom kktsolver of your own, you need to conform to this sparse matrix\\n    assumption.\\n    '\n    factor = kkt_ldl(G, dims, A)\n    return factor",
            "def setup_ldl_factor(c, G, h, dims, A, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The meanings of arguments in this function are identical to those of the\\n    function cvxopt.solvers.conelp. Refer to CVXOPT documentation\\n\\n        https://cvxopt.org/userguide/coneprog.html#linear-cone-programs\\n\\n    for more information.\\n\\n    Note: CVXOPT allows G and A to be passed as dense matrix objects. However,\\n    this function will only ever be called with spmatrix objects. If creating\\n    a custom kktsolver of your own, you need to conform to this sparse matrix\\n    assumption.\\n    '\n    factor = kkt_ldl(G, dims, A)\n    return factor",
            "def setup_ldl_factor(c, G, h, dims, A, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The meanings of arguments in this function are identical to those of the\\n    function cvxopt.solvers.conelp. Refer to CVXOPT documentation\\n\\n        https://cvxopt.org/userguide/coneprog.html#linear-cone-programs\\n\\n    for more information.\\n\\n    Note: CVXOPT allows G and A to be passed as dense matrix objects. However,\\n    this function will only ever be called with spmatrix objects. If creating\\n    a custom kktsolver of your own, you need to conform to this sparse matrix\\n    assumption.\\n    '\n    factor = kkt_ldl(G, dims, A)\n    return factor"
        ]
    },
    {
        "func_name": "solve",
        "original": "def solve(x, y, z):\n    blas.copy(x, u)\n    blas.copy(y, u, offsety=n)\n    scale(z, W, trans='T', inverse='I')\n    pack(z, u, dims, 0, offsety=n + p)\n    lapack.sytrs(K, ipiv, u)\n    blas.copy(u, x, n=n)\n    blas.copy(u, y, offsetx=n, n=p)\n    unpack(u, z, dims, 0, offsetx=n + p)",
        "mutated": [
            "def solve(x, y, z):\n    if False:\n        i = 10\n    blas.copy(x, u)\n    blas.copy(y, u, offsety=n)\n    scale(z, W, trans='T', inverse='I')\n    pack(z, u, dims, 0, offsety=n + p)\n    lapack.sytrs(K, ipiv, u)\n    blas.copy(u, x, n=n)\n    blas.copy(u, y, offsetx=n, n=p)\n    unpack(u, z, dims, 0, offsetx=n + p)",
            "def solve(x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    blas.copy(x, u)\n    blas.copy(y, u, offsety=n)\n    scale(z, W, trans='T', inverse='I')\n    pack(z, u, dims, 0, offsety=n + p)\n    lapack.sytrs(K, ipiv, u)\n    blas.copy(u, x, n=n)\n    blas.copy(u, y, offsetx=n, n=p)\n    unpack(u, z, dims, 0, offsetx=n + p)",
            "def solve(x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    blas.copy(x, u)\n    blas.copy(y, u, offsety=n)\n    scale(z, W, trans='T', inverse='I')\n    pack(z, u, dims, 0, offsety=n + p)\n    lapack.sytrs(K, ipiv, u)\n    blas.copy(u, x, n=n)\n    blas.copy(u, y, offsetx=n, n=p)\n    unpack(u, z, dims, 0, offsetx=n + p)",
            "def solve(x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    blas.copy(x, u)\n    blas.copy(y, u, offsety=n)\n    scale(z, W, trans='T', inverse='I')\n    pack(z, u, dims, 0, offsety=n + p)\n    lapack.sytrs(K, ipiv, u)\n    blas.copy(u, x, n=n)\n    blas.copy(u, y, offsetx=n, n=p)\n    unpack(u, z, dims, 0, offsetx=n + p)",
            "def solve(x, y, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    blas.copy(x, u)\n    blas.copy(y, u, offsety=n)\n    scale(z, W, trans='T', inverse='I')\n    pack(z, u, dims, 0, offsety=n + p)\n    lapack.sytrs(K, ipiv, u)\n    blas.copy(u, x, n=n)\n    blas.copy(u, y, offsetx=n, n=p)\n    unpack(u, z, dims, 0, offsetx=n + p)"
        ]
    },
    {
        "func_name": "factor",
        "original": "def factor(W, H=None):\n    blas.scal(0.0, K)\n    if H is not None:\n        K[:n, :n] = H\n    K[n:n + p, :n] = A\n    for k in range(n):\n        g[:] = G[:, k]\n        scale(g, W, trans='T', inverse='I')\n        pack(g, K, dims, 0, offsety=k * ldK + n + p)\n    K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n    K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n    K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n    lapack.sytrf(K, ipiv)\n\n    def solve(x, y, z):\n        blas.copy(x, u)\n        blas.copy(y, u, offsety=n)\n        scale(z, W, trans='T', inverse='I')\n        pack(z, u, dims, 0, offsety=n + p)\n        lapack.sytrs(K, ipiv, u)\n        blas.copy(u, x, n=n)\n        blas.copy(u, y, offsetx=n, n=p)\n        unpack(u, z, dims, 0, offsetx=n + p)\n    return solve",
        "mutated": [
            "def factor(W, H=None):\n    if False:\n        i = 10\n    blas.scal(0.0, K)\n    if H is not None:\n        K[:n, :n] = H\n    K[n:n + p, :n] = A\n    for k in range(n):\n        g[:] = G[:, k]\n        scale(g, W, trans='T', inverse='I')\n        pack(g, K, dims, 0, offsety=k * ldK + n + p)\n    K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n    K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n    K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n    lapack.sytrf(K, ipiv)\n\n    def solve(x, y, z):\n        blas.copy(x, u)\n        blas.copy(y, u, offsety=n)\n        scale(z, W, trans='T', inverse='I')\n        pack(z, u, dims, 0, offsety=n + p)\n        lapack.sytrs(K, ipiv, u)\n        blas.copy(u, x, n=n)\n        blas.copy(u, y, offsetx=n, n=p)\n        unpack(u, z, dims, 0, offsetx=n + p)\n    return solve",
            "def factor(W, H=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    blas.scal(0.0, K)\n    if H is not None:\n        K[:n, :n] = H\n    K[n:n + p, :n] = A\n    for k in range(n):\n        g[:] = G[:, k]\n        scale(g, W, trans='T', inverse='I')\n        pack(g, K, dims, 0, offsety=k * ldK + n + p)\n    K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n    K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n    K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n    lapack.sytrf(K, ipiv)\n\n    def solve(x, y, z):\n        blas.copy(x, u)\n        blas.copy(y, u, offsety=n)\n        scale(z, W, trans='T', inverse='I')\n        pack(z, u, dims, 0, offsety=n + p)\n        lapack.sytrs(K, ipiv, u)\n        blas.copy(u, x, n=n)\n        blas.copy(u, y, offsetx=n, n=p)\n        unpack(u, z, dims, 0, offsetx=n + p)\n    return solve",
            "def factor(W, H=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    blas.scal(0.0, K)\n    if H is not None:\n        K[:n, :n] = H\n    K[n:n + p, :n] = A\n    for k in range(n):\n        g[:] = G[:, k]\n        scale(g, W, trans='T', inverse='I')\n        pack(g, K, dims, 0, offsety=k * ldK + n + p)\n    K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n    K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n    K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n    lapack.sytrf(K, ipiv)\n\n    def solve(x, y, z):\n        blas.copy(x, u)\n        blas.copy(y, u, offsety=n)\n        scale(z, W, trans='T', inverse='I')\n        pack(z, u, dims, 0, offsety=n + p)\n        lapack.sytrs(K, ipiv, u)\n        blas.copy(u, x, n=n)\n        blas.copy(u, y, offsetx=n, n=p)\n        unpack(u, z, dims, 0, offsetx=n + p)\n    return solve",
            "def factor(W, H=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    blas.scal(0.0, K)\n    if H is not None:\n        K[:n, :n] = H\n    K[n:n + p, :n] = A\n    for k in range(n):\n        g[:] = G[:, k]\n        scale(g, W, trans='T', inverse='I')\n        pack(g, K, dims, 0, offsety=k * ldK + n + p)\n    K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n    K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n    K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n    lapack.sytrf(K, ipiv)\n\n    def solve(x, y, z):\n        blas.copy(x, u)\n        blas.copy(y, u, offsety=n)\n        scale(z, W, trans='T', inverse='I')\n        pack(z, u, dims, 0, offsety=n + p)\n        lapack.sytrs(K, ipiv, u)\n        blas.copy(u, x, n=n)\n        blas.copy(u, y, offsetx=n, n=p)\n        unpack(u, z, dims, 0, offsetx=n + p)\n    return solve",
            "def factor(W, H=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    blas.scal(0.0, K)\n    if H is not None:\n        K[:n, :n] = H\n    K[n:n + p, :n] = A\n    for k in range(n):\n        g[:] = G[:, k]\n        scale(g, W, trans='T', inverse='I')\n        pack(g, K, dims, 0, offsety=k * ldK + n + p)\n    K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n    K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n    K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n    lapack.sytrf(K, ipiv)\n\n    def solve(x, y, z):\n        blas.copy(x, u)\n        blas.copy(y, u, offsety=n)\n        scale(z, W, trans='T', inverse='I')\n        pack(z, u, dims, 0, offsety=n + p)\n        lapack.sytrs(K, ipiv, u)\n        blas.copy(u, x, n=n)\n        blas.copy(u, y, offsetx=n, n=p)\n        unpack(u, z, dims, 0, offsetx=n + p)\n    return solve"
        ]
    },
    {
        "func_name": "kkt_ldl",
        "original": "def kkt_ldl(G, dims, A):\n    \"\"\"\n    Returns a function handle \"factor\", which conforms to the CVXOPT\n    custom KKT solver specifications:\n\n        https://cvxopt.org/userguide/coneprog.html#exploiting-structure.\n\n    For convenience, we provide a short outline for how this function works.\n\n    First, we allocate workspace for use in \"factor\". The factor function is\n    called with data (H, W). Once called, the factor function computes an LDL\n    factorization of the 3 x 3 system:\n\n        [ H           A'   G'*W^{-1}  ]\n        [ A           0    0          ].\n        [ W^{-T}*G    0   -I          ]\n\n    Once that LDL factorization is computed, \"factor\" constructs another\n    inner function, called \"solve\". The solve function uses the newly\n    constructed LDL factorization to compute solutions to linear systems of\n    the form\n\n        [ H     A'   G'    ]   [ ux ]   [ bx ]\n        [ A     0    0     ] * [ uy ] = [ by ].\n        [ G     0   -W'*W  ]   [ uz ]   [ bz ]\n\n    The factor function concludes by returning a reference to the solve function.\n\n    Notes: In the 3 x 3 system, H is n x n, A is p x n, and G is N x n, where\n    N = dims['l'] + sum(dims['q']) + sum( k**2 for k in dims['s'] ). For cone\n    programs, H is the zero matrix.\n    \"\"\"\n    from cvxopt import blas, lapack\n    from cvxopt.base import matrix\n    from cvxopt.misc import pack, scale, unpack\n    (p, n) = A.size\n    ldK = n + p + dims['l'] + sum(dims['q']) + sum([int(k * (k + 1) / 2) for k in dims['s']])\n    K = matrix(0.0, (ldK, ldK))\n    ipiv = matrix(0, (ldK, 1))\n    u = matrix(0.0, (ldK, 1))\n    g = matrix(0.0, (G.size[0], 1))\n\n    def factor(W, H=None):\n        blas.scal(0.0, K)\n        if H is not None:\n            K[:n, :n] = H\n        K[n:n + p, :n] = A\n        for k in range(n):\n            g[:] = G[:, k]\n            scale(g, W, trans='T', inverse='I')\n            pack(g, K, dims, 0, offsety=k * ldK + n + p)\n        K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n        K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n        K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n        lapack.sytrf(K, ipiv)\n\n        def solve(x, y, z):\n            blas.copy(x, u)\n            blas.copy(y, u, offsety=n)\n            scale(z, W, trans='T', inverse='I')\n            pack(z, u, dims, 0, offsety=n + p)\n            lapack.sytrs(K, ipiv, u)\n            blas.copy(u, x, n=n)\n            blas.copy(u, y, offsetx=n, n=p)\n            unpack(u, z, dims, 0, offsetx=n + p)\n        return solve\n    return factor",
        "mutated": [
            "def kkt_ldl(G, dims, A):\n    if False:\n        i = 10\n    '\\n    Returns a function handle \"factor\", which conforms to the CVXOPT\\n    custom KKT solver specifications:\\n\\n        https://cvxopt.org/userguide/coneprog.html#exploiting-structure.\\n\\n    For convenience, we provide a short outline for how this function works.\\n\\n    First, we allocate workspace for use in \"factor\". The factor function is\\n    called with data (H, W). Once called, the factor function computes an LDL\\n    factorization of the 3 x 3 system:\\n\\n        [ H           A\\'   G\\'*W^{-1}  ]\\n        [ A           0    0          ].\\n        [ W^{-T}*G    0   -I          ]\\n\\n    Once that LDL factorization is computed, \"factor\" constructs another\\n    inner function, called \"solve\". The solve function uses the newly\\n    constructed LDL factorization to compute solutions to linear systems of\\n    the form\\n\\n        [ H     A\\'   G\\'    ]   [ ux ]   [ bx ]\\n        [ A     0    0     ] * [ uy ] = [ by ].\\n        [ G     0   -W\\'*W  ]   [ uz ]   [ bz ]\\n\\n    The factor function concludes by returning a reference to the solve function.\\n\\n    Notes: In the 3 x 3 system, H is n x n, A is p x n, and G is N x n, where\\n    N = dims[\\'l\\'] + sum(dims[\\'q\\']) + sum( k**2 for k in dims[\\'s\\'] ). For cone\\n    programs, H is the zero matrix.\\n    '\n    from cvxopt import blas, lapack\n    from cvxopt.base import matrix\n    from cvxopt.misc import pack, scale, unpack\n    (p, n) = A.size\n    ldK = n + p + dims['l'] + sum(dims['q']) + sum([int(k * (k + 1) / 2) for k in dims['s']])\n    K = matrix(0.0, (ldK, ldK))\n    ipiv = matrix(0, (ldK, 1))\n    u = matrix(0.0, (ldK, 1))\n    g = matrix(0.0, (G.size[0], 1))\n\n    def factor(W, H=None):\n        blas.scal(0.0, K)\n        if H is not None:\n            K[:n, :n] = H\n        K[n:n + p, :n] = A\n        for k in range(n):\n            g[:] = G[:, k]\n            scale(g, W, trans='T', inverse='I')\n            pack(g, K, dims, 0, offsety=k * ldK + n + p)\n        K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n        K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n        K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n        lapack.sytrf(K, ipiv)\n\n        def solve(x, y, z):\n            blas.copy(x, u)\n            blas.copy(y, u, offsety=n)\n            scale(z, W, trans='T', inverse='I')\n            pack(z, u, dims, 0, offsety=n + p)\n            lapack.sytrs(K, ipiv, u)\n            blas.copy(u, x, n=n)\n            blas.copy(u, y, offsetx=n, n=p)\n            unpack(u, z, dims, 0, offsetx=n + p)\n        return solve\n    return factor",
            "def kkt_ldl(G, dims, A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a function handle \"factor\", which conforms to the CVXOPT\\n    custom KKT solver specifications:\\n\\n        https://cvxopt.org/userguide/coneprog.html#exploiting-structure.\\n\\n    For convenience, we provide a short outline for how this function works.\\n\\n    First, we allocate workspace for use in \"factor\". The factor function is\\n    called with data (H, W). Once called, the factor function computes an LDL\\n    factorization of the 3 x 3 system:\\n\\n        [ H           A\\'   G\\'*W^{-1}  ]\\n        [ A           0    0          ].\\n        [ W^{-T}*G    0   -I          ]\\n\\n    Once that LDL factorization is computed, \"factor\" constructs another\\n    inner function, called \"solve\". The solve function uses the newly\\n    constructed LDL factorization to compute solutions to linear systems of\\n    the form\\n\\n        [ H     A\\'   G\\'    ]   [ ux ]   [ bx ]\\n        [ A     0    0     ] * [ uy ] = [ by ].\\n        [ G     0   -W\\'*W  ]   [ uz ]   [ bz ]\\n\\n    The factor function concludes by returning a reference to the solve function.\\n\\n    Notes: In the 3 x 3 system, H is n x n, A is p x n, and G is N x n, where\\n    N = dims[\\'l\\'] + sum(dims[\\'q\\']) + sum( k**2 for k in dims[\\'s\\'] ). For cone\\n    programs, H is the zero matrix.\\n    '\n    from cvxopt import blas, lapack\n    from cvxopt.base import matrix\n    from cvxopt.misc import pack, scale, unpack\n    (p, n) = A.size\n    ldK = n + p + dims['l'] + sum(dims['q']) + sum([int(k * (k + 1) / 2) for k in dims['s']])\n    K = matrix(0.0, (ldK, ldK))\n    ipiv = matrix(0, (ldK, 1))\n    u = matrix(0.0, (ldK, 1))\n    g = matrix(0.0, (G.size[0], 1))\n\n    def factor(W, H=None):\n        blas.scal(0.0, K)\n        if H is not None:\n            K[:n, :n] = H\n        K[n:n + p, :n] = A\n        for k in range(n):\n            g[:] = G[:, k]\n            scale(g, W, trans='T', inverse='I')\n            pack(g, K, dims, 0, offsety=k * ldK + n + p)\n        K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n        K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n        K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n        lapack.sytrf(K, ipiv)\n\n        def solve(x, y, z):\n            blas.copy(x, u)\n            blas.copy(y, u, offsety=n)\n            scale(z, W, trans='T', inverse='I')\n            pack(z, u, dims, 0, offsety=n + p)\n            lapack.sytrs(K, ipiv, u)\n            blas.copy(u, x, n=n)\n            blas.copy(u, y, offsetx=n, n=p)\n            unpack(u, z, dims, 0, offsetx=n + p)\n        return solve\n    return factor",
            "def kkt_ldl(G, dims, A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a function handle \"factor\", which conforms to the CVXOPT\\n    custom KKT solver specifications:\\n\\n        https://cvxopt.org/userguide/coneprog.html#exploiting-structure.\\n\\n    For convenience, we provide a short outline for how this function works.\\n\\n    First, we allocate workspace for use in \"factor\". The factor function is\\n    called with data (H, W). Once called, the factor function computes an LDL\\n    factorization of the 3 x 3 system:\\n\\n        [ H           A\\'   G\\'*W^{-1}  ]\\n        [ A           0    0          ].\\n        [ W^{-T}*G    0   -I          ]\\n\\n    Once that LDL factorization is computed, \"factor\" constructs another\\n    inner function, called \"solve\". The solve function uses the newly\\n    constructed LDL factorization to compute solutions to linear systems of\\n    the form\\n\\n        [ H     A\\'   G\\'    ]   [ ux ]   [ bx ]\\n        [ A     0    0     ] * [ uy ] = [ by ].\\n        [ G     0   -W\\'*W  ]   [ uz ]   [ bz ]\\n\\n    The factor function concludes by returning a reference to the solve function.\\n\\n    Notes: In the 3 x 3 system, H is n x n, A is p x n, and G is N x n, where\\n    N = dims[\\'l\\'] + sum(dims[\\'q\\']) + sum( k**2 for k in dims[\\'s\\'] ). For cone\\n    programs, H is the zero matrix.\\n    '\n    from cvxopt import blas, lapack\n    from cvxopt.base import matrix\n    from cvxopt.misc import pack, scale, unpack\n    (p, n) = A.size\n    ldK = n + p + dims['l'] + sum(dims['q']) + sum([int(k * (k + 1) / 2) for k in dims['s']])\n    K = matrix(0.0, (ldK, ldK))\n    ipiv = matrix(0, (ldK, 1))\n    u = matrix(0.0, (ldK, 1))\n    g = matrix(0.0, (G.size[0], 1))\n\n    def factor(W, H=None):\n        blas.scal(0.0, K)\n        if H is not None:\n            K[:n, :n] = H\n        K[n:n + p, :n] = A\n        for k in range(n):\n            g[:] = G[:, k]\n            scale(g, W, trans='T', inverse='I')\n            pack(g, K, dims, 0, offsety=k * ldK + n + p)\n        K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n        K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n        K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n        lapack.sytrf(K, ipiv)\n\n        def solve(x, y, z):\n            blas.copy(x, u)\n            blas.copy(y, u, offsety=n)\n            scale(z, W, trans='T', inverse='I')\n            pack(z, u, dims, 0, offsety=n + p)\n            lapack.sytrs(K, ipiv, u)\n            blas.copy(u, x, n=n)\n            blas.copy(u, y, offsetx=n, n=p)\n            unpack(u, z, dims, 0, offsetx=n + p)\n        return solve\n    return factor",
            "def kkt_ldl(G, dims, A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a function handle \"factor\", which conforms to the CVXOPT\\n    custom KKT solver specifications:\\n\\n        https://cvxopt.org/userguide/coneprog.html#exploiting-structure.\\n\\n    For convenience, we provide a short outline for how this function works.\\n\\n    First, we allocate workspace for use in \"factor\". The factor function is\\n    called with data (H, W). Once called, the factor function computes an LDL\\n    factorization of the 3 x 3 system:\\n\\n        [ H           A\\'   G\\'*W^{-1}  ]\\n        [ A           0    0          ].\\n        [ W^{-T}*G    0   -I          ]\\n\\n    Once that LDL factorization is computed, \"factor\" constructs another\\n    inner function, called \"solve\". The solve function uses the newly\\n    constructed LDL factorization to compute solutions to linear systems of\\n    the form\\n\\n        [ H     A\\'   G\\'    ]   [ ux ]   [ bx ]\\n        [ A     0    0     ] * [ uy ] = [ by ].\\n        [ G     0   -W\\'*W  ]   [ uz ]   [ bz ]\\n\\n    The factor function concludes by returning a reference to the solve function.\\n\\n    Notes: In the 3 x 3 system, H is n x n, A is p x n, and G is N x n, where\\n    N = dims[\\'l\\'] + sum(dims[\\'q\\']) + sum( k**2 for k in dims[\\'s\\'] ). For cone\\n    programs, H is the zero matrix.\\n    '\n    from cvxopt import blas, lapack\n    from cvxopt.base import matrix\n    from cvxopt.misc import pack, scale, unpack\n    (p, n) = A.size\n    ldK = n + p + dims['l'] + sum(dims['q']) + sum([int(k * (k + 1) / 2) for k in dims['s']])\n    K = matrix(0.0, (ldK, ldK))\n    ipiv = matrix(0, (ldK, 1))\n    u = matrix(0.0, (ldK, 1))\n    g = matrix(0.0, (G.size[0], 1))\n\n    def factor(W, H=None):\n        blas.scal(0.0, K)\n        if H is not None:\n            K[:n, :n] = H\n        K[n:n + p, :n] = A\n        for k in range(n):\n            g[:] = G[:, k]\n            scale(g, W, trans='T', inverse='I')\n            pack(g, K, dims, 0, offsety=k * ldK + n + p)\n        K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n        K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n        K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n        lapack.sytrf(K, ipiv)\n\n        def solve(x, y, z):\n            blas.copy(x, u)\n            blas.copy(y, u, offsety=n)\n            scale(z, W, trans='T', inverse='I')\n            pack(z, u, dims, 0, offsety=n + p)\n            lapack.sytrs(K, ipiv, u)\n            blas.copy(u, x, n=n)\n            blas.copy(u, y, offsetx=n, n=p)\n            unpack(u, z, dims, 0, offsetx=n + p)\n        return solve\n    return factor",
            "def kkt_ldl(G, dims, A):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a function handle \"factor\", which conforms to the CVXOPT\\n    custom KKT solver specifications:\\n\\n        https://cvxopt.org/userguide/coneprog.html#exploiting-structure.\\n\\n    For convenience, we provide a short outline for how this function works.\\n\\n    First, we allocate workspace for use in \"factor\". The factor function is\\n    called with data (H, W). Once called, the factor function computes an LDL\\n    factorization of the 3 x 3 system:\\n\\n        [ H           A\\'   G\\'*W^{-1}  ]\\n        [ A           0    0          ].\\n        [ W^{-T}*G    0   -I          ]\\n\\n    Once that LDL factorization is computed, \"factor\" constructs another\\n    inner function, called \"solve\". The solve function uses the newly\\n    constructed LDL factorization to compute solutions to linear systems of\\n    the form\\n\\n        [ H     A\\'   G\\'    ]   [ ux ]   [ bx ]\\n        [ A     0    0     ] * [ uy ] = [ by ].\\n        [ G     0   -W\\'*W  ]   [ uz ]   [ bz ]\\n\\n    The factor function concludes by returning a reference to the solve function.\\n\\n    Notes: In the 3 x 3 system, H is n x n, A is p x n, and G is N x n, where\\n    N = dims[\\'l\\'] + sum(dims[\\'q\\']) + sum( k**2 for k in dims[\\'s\\'] ). For cone\\n    programs, H is the zero matrix.\\n    '\n    from cvxopt import blas, lapack\n    from cvxopt.base import matrix\n    from cvxopt.misc import pack, scale, unpack\n    (p, n) = A.size\n    ldK = n + p + dims['l'] + sum(dims['q']) + sum([int(k * (k + 1) / 2) for k in dims['s']])\n    K = matrix(0.0, (ldK, ldK))\n    ipiv = matrix(0, (ldK, 1))\n    u = matrix(0.0, (ldK, 1))\n    g = matrix(0.0, (G.size[0], 1))\n\n    def factor(W, H=None):\n        blas.scal(0.0, K)\n        if H is not None:\n            K[:n, :n] = H\n        K[n:n + p, :n] = A\n        for k in range(n):\n            g[:] = G[:, k]\n            scale(g, W, trans='T', inverse='I')\n            pack(g, K, dims, 0, offsety=k * ldK + n + p)\n        K[(ldK + 1) * (p + n)::ldK + 1] = -1.0\n        K[0:(ldK + 1) * n:ldK + 1] += REG_EPS\n        K[(ldK + 1) * n::ldK + 1] += -REG_EPS\n        lapack.sytrf(K, ipiv)\n\n        def solve(x, y, z):\n            blas.copy(x, u)\n            blas.copy(y, u, offsety=n)\n            scale(z, W, trans='T', inverse='I')\n            pack(z, u, dims, 0, offsety=n + p)\n            lapack.sytrs(K, ipiv, u)\n            blas.copy(u, x, n=n)\n            blas.copy(u, y, offsetx=n, n=p)\n            unpack(u, z, dims, 0, offsetx=n + p)\n        return solve\n    return factor"
        ]
    }
]