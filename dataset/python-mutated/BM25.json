[
    {
        "func_name": "DocLength",
        "original": "def DocLength(Doc):\n    \"\"\"\n    Calculates length of a document\n    \"\"\"\n    return sum(Doc.values())",
        "mutated": [
            "def DocLength(Doc):\n    if False:\n        i = 10\n    '\\n    Calculates length of a document\\n    '\n    return sum(Doc.values())",
            "def DocLength(Doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Calculates length of a document\\n    '\n    return sum(Doc.values())",
            "def DocLength(Doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Calculates length of a document\\n    '\n    return sum(Doc.values())",
            "def DocLength(Doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Calculates length of a document\\n    '\n    return sum(Doc.values())",
            "def DocLength(Doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Calculates length of a document\\n    '\n    return sum(Doc.values())"
        ]
    },
    {
        "func_name": "AvgDocLength",
        "original": "def AvgDocLength(Docs):\n    \"\"\"\n   Calculates average length of all documents within a set\n    \"\"\"\n    count = 0\n    total = 0\n    for Doc in Docs:\n        total += DocLength(Doc)\n        count += 1\n    try:\n        avg = total / count\n    except:\n        raise ZeroDivisionError('Query not in corpus')\n    return avg",
        "mutated": [
            "def AvgDocLength(Docs):\n    if False:\n        i = 10\n    '\\n   Calculates average length of all documents within a set\\n    '\n    count = 0\n    total = 0\n    for Doc in Docs:\n        total += DocLength(Doc)\n        count += 1\n    try:\n        avg = total / count\n    except:\n        raise ZeroDivisionError('Query not in corpus')\n    return avg",
            "def AvgDocLength(Docs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n   Calculates average length of all documents within a set\\n    '\n    count = 0\n    total = 0\n    for Doc in Docs:\n        total += DocLength(Doc)\n        count += 1\n    try:\n        avg = total / count\n    except:\n        raise ZeroDivisionError('Query not in corpus')\n    return avg",
            "def AvgDocLength(Docs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n   Calculates average length of all documents within a set\\n    '\n    count = 0\n    total = 0\n    for Doc in Docs:\n        total += DocLength(Doc)\n        count += 1\n    try:\n        avg = total / count\n    except:\n        raise ZeroDivisionError('Query not in corpus')\n    return avg",
            "def AvgDocLength(Docs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n   Calculates average length of all documents within a set\\n    '\n    count = 0\n    total = 0\n    for Doc in Docs:\n        total += DocLength(Doc)\n        count += 1\n    try:\n        avg = total / count\n    except:\n        raise ZeroDivisionError('Query not in corpus')\n    return avg",
            "def AvgDocLength(Docs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n   Calculates average length of all documents within a set\\n    '\n    count = 0\n    total = 0\n    for Doc in Docs:\n        total += DocLength(Doc)\n        count += 1\n    try:\n        avg = total / count\n    except:\n        raise ZeroDivisionError('Query not in corpus')\n    return avg"
        ]
    },
    {
        "func_name": "MakeIDF",
        "original": "def MakeIDF(query, docs):\n    \"\"\"\n    Cacuates the IDF portion of the code in which the inverse distribution function is calculated for each query\n    \"\"\"\n    IDF = {}\n    N = len(docs.keys())\n    for term in query.keys():\n        if term not in IDF:\n            n = 0\n            for key in docs:\n                if str(term) in docs[key].keys():\n                    n += 1\n            idf = math.log((N - n + 0.5) / (n + 0.5), 2)\n            IDF[term] = idf\n    return IDF",
        "mutated": [
            "def MakeIDF(query, docs):\n    if False:\n        i = 10\n    '\\n    Cacuates the IDF portion of the code in which the inverse distribution function is calculated for each query\\n    '\n    IDF = {}\n    N = len(docs.keys())\n    for term in query.keys():\n        if term not in IDF:\n            n = 0\n            for key in docs:\n                if str(term) in docs[key].keys():\n                    n += 1\n            idf = math.log((N - n + 0.5) / (n + 0.5), 2)\n            IDF[term] = idf\n    return IDF",
            "def MakeIDF(query, docs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Cacuates the IDF portion of the code in which the inverse distribution function is calculated for each query\\n    '\n    IDF = {}\n    N = len(docs.keys())\n    for term in query.keys():\n        if term not in IDF:\n            n = 0\n            for key in docs:\n                if str(term) in docs[key].keys():\n                    n += 1\n            idf = math.log((N - n + 0.5) / (n + 0.5), 2)\n            IDF[term] = idf\n    return IDF",
            "def MakeIDF(query, docs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Cacuates the IDF portion of the code in which the inverse distribution function is calculated for each query\\n    '\n    IDF = {}\n    N = len(docs.keys())\n    for term in query.keys():\n        if term not in IDF:\n            n = 0\n            for key in docs:\n                if str(term) in docs[key].keys():\n                    n += 1\n            idf = math.log((N - n + 0.5) / (n + 0.5), 2)\n            IDF[term] = idf\n    return IDF",
            "def MakeIDF(query, docs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Cacuates the IDF portion of the code in which the inverse distribution function is calculated for each query\\n    '\n    IDF = {}\n    N = len(docs.keys())\n    for term in query.keys():\n        if term not in IDF:\n            n = 0\n            for key in docs:\n                if str(term) in docs[key].keys():\n                    n += 1\n            idf = math.log((N - n + 0.5) / (n + 0.5), 2)\n            IDF[term] = idf\n    return IDF",
            "def MakeIDF(query, docs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Cacuates the IDF portion of the code in which the inverse distribution function is calculated for each query\\n    '\n    IDF = {}\n    N = len(docs.keys())\n    for term in query.keys():\n        if term not in IDF:\n            n = 0\n            for key in docs:\n                if str(term) in docs[key].keys():\n                    n += 1\n            idf = math.log((N - n + 0.5) / (n + 0.5), 2)\n            IDF[term] = idf\n    return IDF"
        ]
    },
    {
        "func_name": "termFreq",
        "original": "def termFreq(term, doc):\n    \"\"\"\n    Checks for a given term within the document and if it is present returns its frequency\n    \"\"\"\n    if str(term) in doc.keys():\n        return doc[str(term)]\n    else:\n        return 0.0",
        "mutated": [
            "def termFreq(term, doc):\n    if False:\n        i = 10\n    '\\n    Checks for a given term within the document and if it is present returns its frequency\\n    '\n    if str(term) in doc.keys():\n        return doc[str(term)]\n    else:\n        return 0.0",
            "def termFreq(term, doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Checks for a given term within the document and if it is present returns its frequency\\n    '\n    if str(term) in doc.keys():\n        return doc[str(term)]\n    else:\n        return 0.0",
            "def termFreq(term, doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Checks for a given term within the document and if it is present returns its frequency\\n    '\n    if str(term) in doc.keys():\n        return doc[str(term)]\n    else:\n        return 0.0",
            "def termFreq(term, doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Checks for a given term within the document and if it is present returns its frequency\\n    '\n    if str(term) in doc.keys():\n        return doc[str(term)]\n    else:\n        return 0.0",
            "def termFreq(term, doc):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Checks for a given term within the document and if it is present returns its frequency\\n    '\n    if str(term) in doc.keys():\n        return doc[str(term)]\n    else:\n        return 0.0"
        ]
    },
    {
        "func_name": "calcBM25",
        "original": "def calcBM25(query, doc, IDF, k, b, avgdl):\n    \"\"\"\n    Iterates through the keys of the query scoring each individually before returning the sum of these scores\n    \"\"\"\n    score = 0.0\n    for key in query.keys():\n        numer = termFreq(str(key), doc) * (k + 1.0)\n        denom = termFreq(str(key), doc) + (k * (1.0 - b) + b * DocLength(doc) / avgdl)\n        score += IDF[str(key)] * (numer / denom)\n    return score",
        "mutated": [
            "def calcBM25(query, doc, IDF, k, b, avgdl):\n    if False:\n        i = 10\n    '\\n    Iterates through the keys of the query scoring each individually before returning the sum of these scores\\n    '\n    score = 0.0\n    for key in query.keys():\n        numer = termFreq(str(key), doc) * (k + 1.0)\n        denom = termFreq(str(key), doc) + (k * (1.0 - b) + b * DocLength(doc) / avgdl)\n        score += IDF[str(key)] * (numer / denom)\n    return score",
            "def calcBM25(query, doc, IDF, k, b, avgdl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Iterates through the keys of the query scoring each individually before returning the sum of these scores\\n    '\n    score = 0.0\n    for key in query.keys():\n        numer = termFreq(str(key), doc) * (k + 1.0)\n        denom = termFreq(str(key), doc) + (k * (1.0 - b) + b * DocLength(doc) / avgdl)\n        score += IDF[str(key)] * (numer / denom)\n    return score",
            "def calcBM25(query, doc, IDF, k, b, avgdl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Iterates through the keys of the query scoring each individually before returning the sum of these scores\\n    '\n    score = 0.0\n    for key in query.keys():\n        numer = termFreq(str(key), doc) * (k + 1.0)\n        denom = termFreq(str(key), doc) + (k * (1.0 - b) + b * DocLength(doc) / avgdl)\n        score += IDF[str(key)] * (numer / denom)\n    return score",
            "def calcBM25(query, doc, IDF, k, b, avgdl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Iterates through the keys of the query scoring each individually before returning the sum of these scores\\n    '\n    score = 0.0\n    for key in query.keys():\n        numer = termFreq(str(key), doc) * (k + 1.0)\n        denom = termFreq(str(key), doc) + (k * (1.0 - b) + b * DocLength(doc) / avgdl)\n        score += IDF[str(key)] * (numer / denom)\n    return score",
            "def calcBM25(query, doc, IDF, k, b, avgdl):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Iterates through the keys of the query scoring each individually before returning the sum of these scores\\n    '\n    score = 0.0\n    for key in query.keys():\n        numer = termFreq(str(key), doc) * (k + 1.0)\n        denom = termFreq(str(key), doc) + (k * (1.0 - b) + b * DocLength(doc) / avgdl)\n        score += IDF[str(key)] * (numer / denom)\n    return score"
        ]
    },
    {
        "func_name": "NDCG",
        "original": "def NDCG(df, K):\n    rels = df['Score']\n    ideal_rels = np.sort(rels)[::-1]\n    dcg = rels[0]\n    for i in range(1, K):\n        try:\n            dcg += rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    idcg = ideal_rels[0]\n    for i in range(1, K):\n        try:\n            idcg += ideal_rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    ndcg = dcg / idcg\n    print('Search Results in an NDCG accuracy of: ', ndcg)",
        "mutated": [
            "def NDCG(df, K):\n    if False:\n        i = 10\n    rels = df['Score']\n    ideal_rels = np.sort(rels)[::-1]\n    dcg = rels[0]\n    for i in range(1, K):\n        try:\n            dcg += rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    idcg = ideal_rels[0]\n    for i in range(1, K):\n        try:\n            idcg += ideal_rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    ndcg = dcg / idcg\n    print('Search Results in an NDCG accuracy of: ', ndcg)",
            "def NDCG(df, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rels = df['Score']\n    ideal_rels = np.sort(rels)[::-1]\n    dcg = rels[0]\n    for i in range(1, K):\n        try:\n            dcg += rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    idcg = ideal_rels[0]\n    for i in range(1, K):\n        try:\n            idcg += ideal_rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    ndcg = dcg / idcg\n    print('Search Results in an NDCG accuracy of: ', ndcg)",
            "def NDCG(df, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rels = df['Score']\n    ideal_rels = np.sort(rels)[::-1]\n    dcg = rels[0]\n    for i in range(1, K):\n        try:\n            dcg += rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    idcg = ideal_rels[0]\n    for i in range(1, K):\n        try:\n            idcg += ideal_rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    ndcg = dcg / idcg\n    print('Search Results in an NDCG accuracy of: ', ndcg)",
            "def NDCG(df, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rels = df['Score']\n    ideal_rels = np.sort(rels)[::-1]\n    dcg = rels[0]\n    for i in range(1, K):\n        try:\n            dcg += rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    idcg = ideal_rels[0]\n    for i in range(1, K):\n        try:\n            idcg += ideal_rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    ndcg = dcg / idcg\n    print('Search Results in an NDCG accuracy of: ', ndcg)",
            "def NDCG(df, K):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rels = df['Score']\n    ideal_rels = np.sort(rels)[::-1]\n    dcg = rels[0]\n    for i in range(1, K):\n        try:\n            dcg += rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    idcg = ideal_rels[0]\n    for i in range(1, K):\n        try:\n            idcg += ideal_rels[i] / math.log(i + 1, 2)\n        except:\n            pass\n    ndcg = dcg / idcg\n    print('Search Results in an NDCG accuracy of: ', ndcg)"
        ]
    },
    {
        "func_name": "BM25",
        "original": "def BM25(data, keywords, k, b, max_tweets, eval=None, K=1000):\n    \"\"\"\n    Iterates through all docs calculating the BM25 scores for each query, saving these, having been\n    ordered in the set file path.\n    \"\"\"\n    matrix = []\n    query_v = vectorise(keywords)\n    with open('./dictionaries/idf_reference.json') as fp:\n        IDF = json.load(fp)\n    avgD = AvgDocLength(data.vector)\n    data['BM25'] = data.vector.apply(lambda x: calcBM25(query_v, x, IDF, k, b, avgD))\n    data = data.sort_values('BM25', ascending=False)\n    data = data.reset_index()\n    if eval != None:\n        if eval == 'rugby':\n            df = pd.read_csv('./BM25_samples/rugby world cup_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        elif eval == 'fireworks':\n            df = pd.read_csv('./BM25_samples/fireworks night_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        else:\n            print('No prepared data for evaluation')\n    try:\n        matrix += data['vector'][0:max_tweets].tolist()\n        data = data.reset_index()\n        data = data.ix[:max_tweets - 1, :]\n        return (data, matrix)\n    except:\n        matrix += data['vector'].tolist()\n        return (data, matrix)",
        "mutated": [
            "def BM25(data, keywords, k, b, max_tweets, eval=None, K=1000):\n    if False:\n        i = 10\n    '\\n    Iterates through all docs calculating the BM25 scores for each query, saving these, having been\\n    ordered in the set file path.\\n    '\n    matrix = []\n    query_v = vectorise(keywords)\n    with open('./dictionaries/idf_reference.json') as fp:\n        IDF = json.load(fp)\n    avgD = AvgDocLength(data.vector)\n    data['BM25'] = data.vector.apply(lambda x: calcBM25(query_v, x, IDF, k, b, avgD))\n    data = data.sort_values('BM25', ascending=False)\n    data = data.reset_index()\n    if eval != None:\n        if eval == 'rugby':\n            df = pd.read_csv('./BM25_samples/rugby world cup_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        elif eval == 'fireworks':\n            df = pd.read_csv('./BM25_samples/fireworks night_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        else:\n            print('No prepared data for evaluation')\n    try:\n        matrix += data['vector'][0:max_tweets].tolist()\n        data = data.reset_index()\n        data = data.ix[:max_tweets - 1, :]\n        return (data, matrix)\n    except:\n        matrix += data['vector'].tolist()\n        return (data, matrix)",
            "def BM25(data, keywords, k, b, max_tweets, eval=None, K=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Iterates through all docs calculating the BM25 scores for each query, saving these, having been\\n    ordered in the set file path.\\n    '\n    matrix = []\n    query_v = vectorise(keywords)\n    with open('./dictionaries/idf_reference.json') as fp:\n        IDF = json.load(fp)\n    avgD = AvgDocLength(data.vector)\n    data['BM25'] = data.vector.apply(lambda x: calcBM25(query_v, x, IDF, k, b, avgD))\n    data = data.sort_values('BM25', ascending=False)\n    data = data.reset_index()\n    if eval != None:\n        if eval == 'rugby':\n            df = pd.read_csv('./BM25_samples/rugby world cup_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        elif eval == 'fireworks':\n            df = pd.read_csv('./BM25_samples/fireworks night_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        else:\n            print('No prepared data for evaluation')\n    try:\n        matrix += data['vector'][0:max_tweets].tolist()\n        data = data.reset_index()\n        data = data.ix[:max_tweets - 1, :]\n        return (data, matrix)\n    except:\n        matrix += data['vector'].tolist()\n        return (data, matrix)",
            "def BM25(data, keywords, k, b, max_tweets, eval=None, K=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Iterates through all docs calculating the BM25 scores for each query, saving these, having been\\n    ordered in the set file path.\\n    '\n    matrix = []\n    query_v = vectorise(keywords)\n    with open('./dictionaries/idf_reference.json') as fp:\n        IDF = json.load(fp)\n    avgD = AvgDocLength(data.vector)\n    data['BM25'] = data.vector.apply(lambda x: calcBM25(query_v, x, IDF, k, b, avgD))\n    data = data.sort_values('BM25', ascending=False)\n    data = data.reset_index()\n    if eval != None:\n        if eval == 'rugby':\n            df = pd.read_csv('./BM25_samples/rugby world cup_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        elif eval == 'fireworks':\n            df = pd.read_csv('./BM25_samples/fireworks night_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        else:\n            print('No prepared data for evaluation')\n    try:\n        matrix += data['vector'][0:max_tweets].tolist()\n        data = data.reset_index()\n        data = data.ix[:max_tweets - 1, :]\n        return (data, matrix)\n    except:\n        matrix += data['vector'].tolist()\n        return (data, matrix)",
            "def BM25(data, keywords, k, b, max_tweets, eval=None, K=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Iterates through all docs calculating the BM25 scores for each query, saving these, having been\\n    ordered in the set file path.\\n    '\n    matrix = []\n    query_v = vectorise(keywords)\n    with open('./dictionaries/idf_reference.json') as fp:\n        IDF = json.load(fp)\n    avgD = AvgDocLength(data.vector)\n    data['BM25'] = data.vector.apply(lambda x: calcBM25(query_v, x, IDF, k, b, avgD))\n    data = data.sort_values('BM25', ascending=False)\n    data = data.reset_index()\n    if eval != None:\n        if eval == 'rugby':\n            df = pd.read_csv('./BM25_samples/rugby world cup_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        elif eval == 'fireworks':\n            df = pd.read_csv('./BM25_samples/fireworks night_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        else:\n            print('No prepared data for evaluation')\n    try:\n        matrix += data['vector'][0:max_tweets].tolist()\n        data = data.reset_index()\n        data = data.ix[:max_tweets - 1, :]\n        return (data, matrix)\n    except:\n        matrix += data['vector'].tolist()\n        return (data, matrix)",
            "def BM25(data, keywords, k, b, max_tweets, eval=None, K=1000):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Iterates through all docs calculating the BM25 scores for each query, saving these, having been\\n    ordered in the set file path.\\n    '\n    matrix = []\n    query_v = vectorise(keywords)\n    with open('./dictionaries/idf_reference.json') as fp:\n        IDF = json.load(fp)\n    avgD = AvgDocLength(data.vector)\n    data['BM25'] = data.vector.apply(lambda x: calcBM25(query_v, x, IDF, k, b, avgD))\n    data = data.sort_values('BM25', ascending=False)\n    data = data.reset_index()\n    if eval != None:\n        if eval == 'rugby':\n            df = pd.read_csv('./BM25_samples/rugby world cup_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        elif eval == 'fireworks':\n            df = pd.read_csv('./BM25_samples/fireworks night_output.csv', usecols=[0, 1])\n            NDCG(df, K)\n        else:\n            print('No prepared data for evaluation')\n    try:\n        matrix += data['vector'][0:max_tweets].tolist()\n        data = data.reset_index()\n        data = data.ix[:max_tweets - 1, :]\n        return (data, matrix)\n    except:\n        matrix += data['vector'].tolist()\n        return (data, matrix)"
        ]
    }
]