[
    {
        "func_name": "symmetrize",
        "original": "@public\ndef symmetrize(F, *gens, **args):\n    \"\"\"\n    Rewrite a polynomial in terms of elementary symmetric polynomials.\n\n    A symmetric polynomial is a multivariate polynomial that remains invariant\n    under any variable permutation, i.e., if `f = f(x_1, x_2, \\\\dots, x_n)`,\n    then `f = f(x_{i_1}, x_{i_2}, \\\\dots, x_{i_n})`, where\n    `(i_1, i_2, \\\\dots, i_n)` is a permutation of `(1, 2, \\\\dots, n)` (an\n    element of the group `S_n`).\n\n    Returns a tuple of symmetric polynomials ``(f1, f2, ..., fn)`` such that\n    ``f = f1 + f2 + ... + fn``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polyfuncs import symmetrize\n    >>> from sympy.abc import x, y\n\n    >>> symmetrize(x**2 + y**2)\n    (-2*x*y + (x + y)**2, 0)\n\n    >>> symmetrize(x**2 + y**2, formal=True)\n    (s1**2 - 2*s2, 0, [(s1, x + y), (s2, x*y)])\n\n    >>> symmetrize(x**2 - y**2)\n    (-2*x*y + (x + y)**2, -2*y**2)\n\n    >>> symmetrize(x**2 - y**2, formal=True)\n    (s1**2 - 2*s2, -2*y**2, [(s1, x + y), (s2, x*y)])\n\n    \"\"\"\n    allowed_flags(args, ['formal', 'symbols'])\n    iterable = True\n    if not hasattr(F, '__iter__'):\n        iterable = False\n        F = [F]\n    (R, F) = sring(F, *gens, **args)\n    gens = R.symbols\n    opt = build_options(gens, args)\n    symbols = opt.symbols\n    symbols = [next(symbols) for i in range(len(gens))]\n    result = []\n    for f in F:\n        (p, r, m) = f.symmetrize()\n        result.append((p.as_expr(*symbols), r.as_expr(*gens)))\n    polys = [(s, g.as_expr()) for (s, (_, g)) in zip(symbols, m)]\n    if not opt.formal:\n        for (i, (sym, non_sym)) in enumerate(result):\n            result[i] = (sym.subs(polys), non_sym)\n    if not iterable:\n        (result,) = result\n    if not opt.formal:\n        return result\n    elif iterable:\n        return (result, polys)\n    else:\n        return result + (polys,)",
        "mutated": [
            "@public\ndef symmetrize(F, *gens, **args):\n    if False:\n        i = 10\n    '\\n    Rewrite a polynomial in terms of elementary symmetric polynomials.\\n\\n    A symmetric polynomial is a multivariate polynomial that remains invariant\\n    under any variable permutation, i.e., if `f = f(x_1, x_2, \\\\dots, x_n)`,\\n    then `f = f(x_{i_1}, x_{i_2}, \\\\dots, x_{i_n})`, where\\n    `(i_1, i_2, \\\\dots, i_n)` is a permutation of `(1, 2, \\\\dots, n)` (an\\n    element of the group `S_n`).\\n\\n    Returns a tuple of symmetric polynomials ``(f1, f2, ..., fn)`` such that\\n    ``f = f1 + f2 + ... + fn``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import symmetrize\\n    >>> from sympy.abc import x, y\\n\\n    >>> symmetrize(x**2 + y**2)\\n    (-2*x*y + (x + y)**2, 0)\\n\\n    >>> symmetrize(x**2 + y**2, formal=True)\\n    (s1**2 - 2*s2, 0, [(s1, x + y), (s2, x*y)])\\n\\n    >>> symmetrize(x**2 - y**2)\\n    (-2*x*y + (x + y)**2, -2*y**2)\\n\\n    >>> symmetrize(x**2 - y**2, formal=True)\\n    (s1**2 - 2*s2, -2*y**2, [(s1, x + y), (s2, x*y)])\\n\\n    '\n    allowed_flags(args, ['formal', 'symbols'])\n    iterable = True\n    if not hasattr(F, '__iter__'):\n        iterable = False\n        F = [F]\n    (R, F) = sring(F, *gens, **args)\n    gens = R.symbols\n    opt = build_options(gens, args)\n    symbols = opt.symbols\n    symbols = [next(symbols) for i in range(len(gens))]\n    result = []\n    for f in F:\n        (p, r, m) = f.symmetrize()\n        result.append((p.as_expr(*symbols), r.as_expr(*gens)))\n    polys = [(s, g.as_expr()) for (s, (_, g)) in zip(symbols, m)]\n    if not opt.formal:\n        for (i, (sym, non_sym)) in enumerate(result):\n            result[i] = (sym.subs(polys), non_sym)\n    if not iterable:\n        (result,) = result\n    if not opt.formal:\n        return result\n    elif iterable:\n        return (result, polys)\n    else:\n        return result + (polys,)",
            "@public\ndef symmetrize(F, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Rewrite a polynomial in terms of elementary symmetric polynomials.\\n\\n    A symmetric polynomial is a multivariate polynomial that remains invariant\\n    under any variable permutation, i.e., if `f = f(x_1, x_2, \\\\dots, x_n)`,\\n    then `f = f(x_{i_1}, x_{i_2}, \\\\dots, x_{i_n})`, where\\n    `(i_1, i_2, \\\\dots, i_n)` is a permutation of `(1, 2, \\\\dots, n)` (an\\n    element of the group `S_n`).\\n\\n    Returns a tuple of symmetric polynomials ``(f1, f2, ..., fn)`` such that\\n    ``f = f1 + f2 + ... + fn``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import symmetrize\\n    >>> from sympy.abc import x, y\\n\\n    >>> symmetrize(x**2 + y**2)\\n    (-2*x*y + (x + y)**2, 0)\\n\\n    >>> symmetrize(x**2 + y**2, formal=True)\\n    (s1**2 - 2*s2, 0, [(s1, x + y), (s2, x*y)])\\n\\n    >>> symmetrize(x**2 - y**2)\\n    (-2*x*y + (x + y)**2, -2*y**2)\\n\\n    >>> symmetrize(x**2 - y**2, formal=True)\\n    (s1**2 - 2*s2, -2*y**2, [(s1, x + y), (s2, x*y)])\\n\\n    '\n    allowed_flags(args, ['formal', 'symbols'])\n    iterable = True\n    if not hasattr(F, '__iter__'):\n        iterable = False\n        F = [F]\n    (R, F) = sring(F, *gens, **args)\n    gens = R.symbols\n    opt = build_options(gens, args)\n    symbols = opt.symbols\n    symbols = [next(symbols) for i in range(len(gens))]\n    result = []\n    for f in F:\n        (p, r, m) = f.symmetrize()\n        result.append((p.as_expr(*symbols), r.as_expr(*gens)))\n    polys = [(s, g.as_expr()) for (s, (_, g)) in zip(symbols, m)]\n    if not opt.formal:\n        for (i, (sym, non_sym)) in enumerate(result):\n            result[i] = (sym.subs(polys), non_sym)\n    if not iterable:\n        (result,) = result\n    if not opt.formal:\n        return result\n    elif iterable:\n        return (result, polys)\n    else:\n        return result + (polys,)",
            "@public\ndef symmetrize(F, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Rewrite a polynomial in terms of elementary symmetric polynomials.\\n\\n    A symmetric polynomial is a multivariate polynomial that remains invariant\\n    under any variable permutation, i.e., if `f = f(x_1, x_2, \\\\dots, x_n)`,\\n    then `f = f(x_{i_1}, x_{i_2}, \\\\dots, x_{i_n})`, where\\n    `(i_1, i_2, \\\\dots, i_n)` is a permutation of `(1, 2, \\\\dots, n)` (an\\n    element of the group `S_n`).\\n\\n    Returns a tuple of symmetric polynomials ``(f1, f2, ..., fn)`` such that\\n    ``f = f1 + f2 + ... + fn``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import symmetrize\\n    >>> from sympy.abc import x, y\\n\\n    >>> symmetrize(x**2 + y**2)\\n    (-2*x*y + (x + y)**2, 0)\\n\\n    >>> symmetrize(x**2 + y**2, formal=True)\\n    (s1**2 - 2*s2, 0, [(s1, x + y), (s2, x*y)])\\n\\n    >>> symmetrize(x**2 - y**2)\\n    (-2*x*y + (x + y)**2, -2*y**2)\\n\\n    >>> symmetrize(x**2 - y**2, formal=True)\\n    (s1**2 - 2*s2, -2*y**2, [(s1, x + y), (s2, x*y)])\\n\\n    '\n    allowed_flags(args, ['formal', 'symbols'])\n    iterable = True\n    if not hasattr(F, '__iter__'):\n        iterable = False\n        F = [F]\n    (R, F) = sring(F, *gens, **args)\n    gens = R.symbols\n    opt = build_options(gens, args)\n    symbols = opt.symbols\n    symbols = [next(symbols) for i in range(len(gens))]\n    result = []\n    for f in F:\n        (p, r, m) = f.symmetrize()\n        result.append((p.as_expr(*symbols), r.as_expr(*gens)))\n    polys = [(s, g.as_expr()) for (s, (_, g)) in zip(symbols, m)]\n    if not opt.formal:\n        for (i, (sym, non_sym)) in enumerate(result):\n            result[i] = (sym.subs(polys), non_sym)\n    if not iterable:\n        (result,) = result\n    if not opt.formal:\n        return result\n    elif iterable:\n        return (result, polys)\n    else:\n        return result + (polys,)",
            "@public\ndef symmetrize(F, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Rewrite a polynomial in terms of elementary symmetric polynomials.\\n\\n    A symmetric polynomial is a multivariate polynomial that remains invariant\\n    under any variable permutation, i.e., if `f = f(x_1, x_2, \\\\dots, x_n)`,\\n    then `f = f(x_{i_1}, x_{i_2}, \\\\dots, x_{i_n})`, where\\n    `(i_1, i_2, \\\\dots, i_n)` is a permutation of `(1, 2, \\\\dots, n)` (an\\n    element of the group `S_n`).\\n\\n    Returns a tuple of symmetric polynomials ``(f1, f2, ..., fn)`` such that\\n    ``f = f1 + f2 + ... + fn``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import symmetrize\\n    >>> from sympy.abc import x, y\\n\\n    >>> symmetrize(x**2 + y**2)\\n    (-2*x*y + (x + y)**2, 0)\\n\\n    >>> symmetrize(x**2 + y**2, formal=True)\\n    (s1**2 - 2*s2, 0, [(s1, x + y), (s2, x*y)])\\n\\n    >>> symmetrize(x**2 - y**2)\\n    (-2*x*y + (x + y)**2, -2*y**2)\\n\\n    >>> symmetrize(x**2 - y**2, formal=True)\\n    (s1**2 - 2*s2, -2*y**2, [(s1, x + y), (s2, x*y)])\\n\\n    '\n    allowed_flags(args, ['formal', 'symbols'])\n    iterable = True\n    if not hasattr(F, '__iter__'):\n        iterable = False\n        F = [F]\n    (R, F) = sring(F, *gens, **args)\n    gens = R.symbols\n    opt = build_options(gens, args)\n    symbols = opt.symbols\n    symbols = [next(symbols) for i in range(len(gens))]\n    result = []\n    for f in F:\n        (p, r, m) = f.symmetrize()\n        result.append((p.as_expr(*symbols), r.as_expr(*gens)))\n    polys = [(s, g.as_expr()) for (s, (_, g)) in zip(symbols, m)]\n    if not opt.formal:\n        for (i, (sym, non_sym)) in enumerate(result):\n            result[i] = (sym.subs(polys), non_sym)\n    if not iterable:\n        (result,) = result\n    if not opt.formal:\n        return result\n    elif iterable:\n        return (result, polys)\n    else:\n        return result + (polys,)",
            "@public\ndef symmetrize(F, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Rewrite a polynomial in terms of elementary symmetric polynomials.\\n\\n    A symmetric polynomial is a multivariate polynomial that remains invariant\\n    under any variable permutation, i.e., if `f = f(x_1, x_2, \\\\dots, x_n)`,\\n    then `f = f(x_{i_1}, x_{i_2}, \\\\dots, x_{i_n})`, where\\n    `(i_1, i_2, \\\\dots, i_n)` is a permutation of `(1, 2, \\\\dots, n)` (an\\n    element of the group `S_n`).\\n\\n    Returns a tuple of symmetric polynomials ``(f1, f2, ..., fn)`` such that\\n    ``f = f1 + f2 + ... + fn``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import symmetrize\\n    >>> from sympy.abc import x, y\\n\\n    >>> symmetrize(x**2 + y**2)\\n    (-2*x*y + (x + y)**2, 0)\\n\\n    >>> symmetrize(x**2 + y**2, formal=True)\\n    (s1**2 - 2*s2, 0, [(s1, x + y), (s2, x*y)])\\n\\n    >>> symmetrize(x**2 - y**2)\\n    (-2*x*y + (x + y)**2, -2*y**2)\\n\\n    >>> symmetrize(x**2 - y**2, formal=True)\\n    (s1**2 - 2*s2, -2*y**2, [(s1, x + y), (s2, x*y)])\\n\\n    '\n    allowed_flags(args, ['formal', 'symbols'])\n    iterable = True\n    if not hasattr(F, '__iter__'):\n        iterable = False\n        F = [F]\n    (R, F) = sring(F, *gens, **args)\n    gens = R.symbols\n    opt = build_options(gens, args)\n    symbols = opt.symbols\n    symbols = [next(symbols) for i in range(len(gens))]\n    result = []\n    for f in F:\n        (p, r, m) = f.symmetrize()\n        result.append((p.as_expr(*symbols), r.as_expr(*gens)))\n    polys = [(s, g.as_expr()) for (s, (_, g)) in zip(symbols, m)]\n    if not opt.formal:\n        for (i, (sym, non_sym)) in enumerate(result):\n            result[i] = (sym.subs(polys), non_sym)\n    if not iterable:\n        (result,) = result\n    if not opt.formal:\n        return result\n    elif iterable:\n        return (result, polys)\n    else:\n        return result + (polys,)"
        ]
    },
    {
        "func_name": "horner",
        "original": "@public\ndef horner(f, *gens, **args):\n    \"\"\"\n    Rewrite a polynomial in Horner form.\n\n    Among other applications, evaluation of a polynomial at a point is optimal\n    when it is applied using the Horner scheme ([1]).\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polyfuncs import horner\n    >>> from sympy.abc import x, y, a, b, c, d, e\n\n    >>> horner(9*x**4 + 8*x**3 + 7*x**2 + 6*x + 5)\n    x*(x*(x*(9*x + 8) + 7) + 6) + 5\n\n    >>> horner(a*x**4 + b*x**3 + c*x**2 + d*x + e)\n    e + x*(d + x*(c + x*(a*x + b)))\n\n    >>> f = 4*x**2*y**2 + 2*x**2*y + 2*x*y**2 + x*y\n\n    >>> horner(f, wrt=x)\n    x*(x*y*(4*y + 2) + y*(2*y + 1))\n\n    >>> horner(f, wrt=y)\n    y*(x*y*(4*x + 2) + x*(2*x + 1))\n\n    References\n    ==========\n    [1] - https://en.wikipedia.org/wiki/Horner_scheme\n\n    \"\"\"\n    allowed_flags(args, [])\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        return exc.expr\n    (form, gen) = (S.Zero, F.gen)\n    if F.is_univariate:\n        for coeff in F.all_coeffs():\n            form = form * gen + coeff\n    else:\n        (F, gens) = (Poly(F, gen), gens[1:])\n        for coeff in F.all_coeffs():\n            form = form * gen + horner(coeff, *gens, **args)\n    return form",
        "mutated": [
            "@public\ndef horner(f, *gens, **args):\n    if False:\n        i = 10\n    '\\n    Rewrite a polynomial in Horner form.\\n\\n    Among other applications, evaluation of a polynomial at a point is optimal\\n    when it is applied using the Horner scheme ([1]).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import horner\\n    >>> from sympy.abc import x, y, a, b, c, d, e\\n\\n    >>> horner(9*x**4 + 8*x**3 + 7*x**2 + 6*x + 5)\\n    x*(x*(x*(9*x + 8) + 7) + 6) + 5\\n\\n    >>> horner(a*x**4 + b*x**3 + c*x**2 + d*x + e)\\n    e + x*(d + x*(c + x*(a*x + b)))\\n\\n    >>> f = 4*x**2*y**2 + 2*x**2*y + 2*x*y**2 + x*y\\n\\n    >>> horner(f, wrt=x)\\n    x*(x*y*(4*y + 2) + y*(2*y + 1))\\n\\n    >>> horner(f, wrt=y)\\n    y*(x*y*(4*x + 2) + x*(2*x + 1))\\n\\n    References\\n    ==========\\n    [1] - https://en.wikipedia.org/wiki/Horner_scheme\\n\\n    '\n    allowed_flags(args, [])\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        return exc.expr\n    (form, gen) = (S.Zero, F.gen)\n    if F.is_univariate:\n        for coeff in F.all_coeffs():\n            form = form * gen + coeff\n    else:\n        (F, gens) = (Poly(F, gen), gens[1:])\n        for coeff in F.all_coeffs():\n            form = form * gen + horner(coeff, *gens, **args)\n    return form",
            "@public\ndef horner(f, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Rewrite a polynomial in Horner form.\\n\\n    Among other applications, evaluation of a polynomial at a point is optimal\\n    when it is applied using the Horner scheme ([1]).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import horner\\n    >>> from sympy.abc import x, y, a, b, c, d, e\\n\\n    >>> horner(9*x**4 + 8*x**3 + 7*x**2 + 6*x + 5)\\n    x*(x*(x*(9*x + 8) + 7) + 6) + 5\\n\\n    >>> horner(a*x**4 + b*x**3 + c*x**2 + d*x + e)\\n    e + x*(d + x*(c + x*(a*x + b)))\\n\\n    >>> f = 4*x**2*y**2 + 2*x**2*y + 2*x*y**2 + x*y\\n\\n    >>> horner(f, wrt=x)\\n    x*(x*y*(4*y + 2) + y*(2*y + 1))\\n\\n    >>> horner(f, wrt=y)\\n    y*(x*y*(4*x + 2) + x*(2*x + 1))\\n\\n    References\\n    ==========\\n    [1] - https://en.wikipedia.org/wiki/Horner_scheme\\n\\n    '\n    allowed_flags(args, [])\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        return exc.expr\n    (form, gen) = (S.Zero, F.gen)\n    if F.is_univariate:\n        for coeff in F.all_coeffs():\n            form = form * gen + coeff\n    else:\n        (F, gens) = (Poly(F, gen), gens[1:])\n        for coeff in F.all_coeffs():\n            form = form * gen + horner(coeff, *gens, **args)\n    return form",
            "@public\ndef horner(f, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Rewrite a polynomial in Horner form.\\n\\n    Among other applications, evaluation of a polynomial at a point is optimal\\n    when it is applied using the Horner scheme ([1]).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import horner\\n    >>> from sympy.abc import x, y, a, b, c, d, e\\n\\n    >>> horner(9*x**4 + 8*x**3 + 7*x**2 + 6*x + 5)\\n    x*(x*(x*(9*x + 8) + 7) + 6) + 5\\n\\n    >>> horner(a*x**4 + b*x**3 + c*x**2 + d*x + e)\\n    e + x*(d + x*(c + x*(a*x + b)))\\n\\n    >>> f = 4*x**2*y**2 + 2*x**2*y + 2*x*y**2 + x*y\\n\\n    >>> horner(f, wrt=x)\\n    x*(x*y*(4*y + 2) + y*(2*y + 1))\\n\\n    >>> horner(f, wrt=y)\\n    y*(x*y*(4*x + 2) + x*(2*x + 1))\\n\\n    References\\n    ==========\\n    [1] - https://en.wikipedia.org/wiki/Horner_scheme\\n\\n    '\n    allowed_flags(args, [])\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        return exc.expr\n    (form, gen) = (S.Zero, F.gen)\n    if F.is_univariate:\n        for coeff in F.all_coeffs():\n            form = form * gen + coeff\n    else:\n        (F, gens) = (Poly(F, gen), gens[1:])\n        for coeff in F.all_coeffs():\n            form = form * gen + horner(coeff, *gens, **args)\n    return form",
            "@public\ndef horner(f, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Rewrite a polynomial in Horner form.\\n\\n    Among other applications, evaluation of a polynomial at a point is optimal\\n    when it is applied using the Horner scheme ([1]).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import horner\\n    >>> from sympy.abc import x, y, a, b, c, d, e\\n\\n    >>> horner(9*x**4 + 8*x**3 + 7*x**2 + 6*x + 5)\\n    x*(x*(x*(9*x + 8) + 7) + 6) + 5\\n\\n    >>> horner(a*x**4 + b*x**3 + c*x**2 + d*x + e)\\n    e + x*(d + x*(c + x*(a*x + b)))\\n\\n    >>> f = 4*x**2*y**2 + 2*x**2*y + 2*x*y**2 + x*y\\n\\n    >>> horner(f, wrt=x)\\n    x*(x*y*(4*y + 2) + y*(2*y + 1))\\n\\n    >>> horner(f, wrt=y)\\n    y*(x*y*(4*x + 2) + x*(2*x + 1))\\n\\n    References\\n    ==========\\n    [1] - https://en.wikipedia.org/wiki/Horner_scheme\\n\\n    '\n    allowed_flags(args, [])\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        return exc.expr\n    (form, gen) = (S.Zero, F.gen)\n    if F.is_univariate:\n        for coeff in F.all_coeffs():\n            form = form * gen + coeff\n    else:\n        (F, gens) = (Poly(F, gen), gens[1:])\n        for coeff in F.all_coeffs():\n            form = form * gen + horner(coeff, *gens, **args)\n    return form",
            "@public\ndef horner(f, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Rewrite a polynomial in Horner form.\\n\\n    Among other applications, evaluation of a polynomial at a point is optimal\\n    when it is applied using the Horner scheme ([1]).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import horner\\n    >>> from sympy.abc import x, y, a, b, c, d, e\\n\\n    >>> horner(9*x**4 + 8*x**3 + 7*x**2 + 6*x + 5)\\n    x*(x*(x*(9*x + 8) + 7) + 6) + 5\\n\\n    >>> horner(a*x**4 + b*x**3 + c*x**2 + d*x + e)\\n    e + x*(d + x*(c + x*(a*x + b)))\\n\\n    >>> f = 4*x**2*y**2 + 2*x**2*y + 2*x*y**2 + x*y\\n\\n    >>> horner(f, wrt=x)\\n    x*(x*y*(4*y + 2) + y*(2*y + 1))\\n\\n    >>> horner(f, wrt=y)\\n    y*(x*y*(4*x + 2) + x*(2*x + 1))\\n\\n    References\\n    ==========\\n    [1] - https://en.wikipedia.org/wiki/Horner_scheme\\n\\n    '\n    allowed_flags(args, [])\n    try:\n        (F, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        return exc.expr\n    (form, gen) = (S.Zero, F.gen)\n    if F.is_univariate:\n        for coeff in F.all_coeffs():\n            form = form * gen + coeff\n    else:\n        (F, gens) = (Poly(F, gen), gens[1:])\n        for coeff in F.all_coeffs():\n            form = form * gen + horner(coeff, *gens, **args)\n    return form"
        ]
    },
    {
        "func_name": "interpolate",
        "original": "@public\ndef interpolate(data, x):\n    \"\"\"\n    Construct an interpolating polynomial for the data points\n    evaluated at point x (which can be symbolic or numeric).\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polyfuncs import interpolate\n    >>> from sympy.abc import a, b, x\n\n    A list is interpreted as though it were paired with a range starting\n    from 1:\n\n    >>> interpolate([1, 4, 9, 16], x)\n    x**2\n\n    This can be made explicit by giving a list of coordinates:\n\n    >>> interpolate([(1, 1), (2, 4), (3, 9)], x)\n    x**2\n\n    The (x, y) coordinates can also be given as keys and values of a\n    dictionary (and the points need not be equispaced):\n\n    >>> interpolate([(-1, 2), (1, 2), (2, 5)], x)\n    x**2 + 1\n    >>> interpolate({-1: 2, 1: 2, 2: 5}, x)\n    x**2 + 1\n\n    If the interpolation is going to be used only once then the\n    value of interest can be passed instead of passing a symbol:\n\n    >>> interpolate([1, 4, 9], 5)\n    25\n\n    Symbolic coordinates are also supported:\n\n    >>> [(i,interpolate((a, b), i)) for i in range(1, 4)]\n    [(1, a), (2, b), (3, -a + 2*b)]\n    \"\"\"\n    n = len(data)\n    if isinstance(data, dict):\n        if x in data:\n            return S(data[x])\n        (X, Y) = list(zip(*data.items()))\n    elif isinstance(data[0], tuple):\n        (X, Y) = list(zip(*data))\n        if x in X:\n            return S(Y[X.index(x)])\n    else:\n        if x in range(1, n + 1):\n            return S(data[x - 1])\n        Y = list(data)\n        X = list(range(1, n + 1))\n    try:\n        return interpolating_poly(n, x, X, Y).expand()\n    except ValueError:\n        d = Dummy()\n        return interpolating_poly(n, d, X, Y).expand().subs(d, x)",
        "mutated": [
            "@public\ndef interpolate(data, x):\n    if False:\n        i = 10\n    '\\n    Construct an interpolating polynomial for the data points\\n    evaluated at point x (which can be symbolic or numeric).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import interpolate\\n    >>> from sympy.abc import a, b, x\\n\\n    A list is interpreted as though it were paired with a range starting\\n    from 1:\\n\\n    >>> interpolate([1, 4, 9, 16], x)\\n    x**2\\n\\n    This can be made explicit by giving a list of coordinates:\\n\\n    >>> interpolate([(1, 1), (2, 4), (3, 9)], x)\\n    x**2\\n\\n    The (x, y) coordinates can also be given as keys and values of a\\n    dictionary (and the points need not be equispaced):\\n\\n    >>> interpolate([(-1, 2), (1, 2), (2, 5)], x)\\n    x**2 + 1\\n    >>> interpolate({-1: 2, 1: 2, 2: 5}, x)\\n    x**2 + 1\\n\\n    If the interpolation is going to be used only once then the\\n    value of interest can be passed instead of passing a symbol:\\n\\n    >>> interpolate([1, 4, 9], 5)\\n    25\\n\\n    Symbolic coordinates are also supported:\\n\\n    >>> [(i,interpolate((a, b), i)) for i in range(1, 4)]\\n    [(1, a), (2, b), (3, -a + 2*b)]\\n    '\n    n = len(data)\n    if isinstance(data, dict):\n        if x in data:\n            return S(data[x])\n        (X, Y) = list(zip(*data.items()))\n    elif isinstance(data[0], tuple):\n        (X, Y) = list(zip(*data))\n        if x in X:\n            return S(Y[X.index(x)])\n    else:\n        if x in range(1, n + 1):\n            return S(data[x - 1])\n        Y = list(data)\n        X = list(range(1, n + 1))\n    try:\n        return interpolating_poly(n, x, X, Y).expand()\n    except ValueError:\n        d = Dummy()\n        return interpolating_poly(n, d, X, Y).expand().subs(d, x)",
            "@public\ndef interpolate(data, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Construct an interpolating polynomial for the data points\\n    evaluated at point x (which can be symbolic or numeric).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import interpolate\\n    >>> from sympy.abc import a, b, x\\n\\n    A list is interpreted as though it were paired with a range starting\\n    from 1:\\n\\n    >>> interpolate([1, 4, 9, 16], x)\\n    x**2\\n\\n    This can be made explicit by giving a list of coordinates:\\n\\n    >>> interpolate([(1, 1), (2, 4), (3, 9)], x)\\n    x**2\\n\\n    The (x, y) coordinates can also be given as keys and values of a\\n    dictionary (and the points need not be equispaced):\\n\\n    >>> interpolate([(-1, 2), (1, 2), (2, 5)], x)\\n    x**2 + 1\\n    >>> interpolate({-1: 2, 1: 2, 2: 5}, x)\\n    x**2 + 1\\n\\n    If the interpolation is going to be used only once then the\\n    value of interest can be passed instead of passing a symbol:\\n\\n    >>> interpolate([1, 4, 9], 5)\\n    25\\n\\n    Symbolic coordinates are also supported:\\n\\n    >>> [(i,interpolate((a, b), i)) for i in range(1, 4)]\\n    [(1, a), (2, b), (3, -a + 2*b)]\\n    '\n    n = len(data)\n    if isinstance(data, dict):\n        if x in data:\n            return S(data[x])\n        (X, Y) = list(zip(*data.items()))\n    elif isinstance(data[0], tuple):\n        (X, Y) = list(zip(*data))\n        if x in X:\n            return S(Y[X.index(x)])\n    else:\n        if x in range(1, n + 1):\n            return S(data[x - 1])\n        Y = list(data)\n        X = list(range(1, n + 1))\n    try:\n        return interpolating_poly(n, x, X, Y).expand()\n    except ValueError:\n        d = Dummy()\n        return interpolating_poly(n, d, X, Y).expand().subs(d, x)",
            "@public\ndef interpolate(data, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Construct an interpolating polynomial for the data points\\n    evaluated at point x (which can be symbolic or numeric).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import interpolate\\n    >>> from sympy.abc import a, b, x\\n\\n    A list is interpreted as though it were paired with a range starting\\n    from 1:\\n\\n    >>> interpolate([1, 4, 9, 16], x)\\n    x**2\\n\\n    This can be made explicit by giving a list of coordinates:\\n\\n    >>> interpolate([(1, 1), (2, 4), (3, 9)], x)\\n    x**2\\n\\n    The (x, y) coordinates can also be given as keys and values of a\\n    dictionary (and the points need not be equispaced):\\n\\n    >>> interpolate([(-1, 2), (1, 2), (2, 5)], x)\\n    x**2 + 1\\n    >>> interpolate({-1: 2, 1: 2, 2: 5}, x)\\n    x**2 + 1\\n\\n    If the interpolation is going to be used only once then the\\n    value of interest can be passed instead of passing a symbol:\\n\\n    >>> interpolate([1, 4, 9], 5)\\n    25\\n\\n    Symbolic coordinates are also supported:\\n\\n    >>> [(i,interpolate((a, b), i)) for i in range(1, 4)]\\n    [(1, a), (2, b), (3, -a + 2*b)]\\n    '\n    n = len(data)\n    if isinstance(data, dict):\n        if x in data:\n            return S(data[x])\n        (X, Y) = list(zip(*data.items()))\n    elif isinstance(data[0], tuple):\n        (X, Y) = list(zip(*data))\n        if x in X:\n            return S(Y[X.index(x)])\n    else:\n        if x in range(1, n + 1):\n            return S(data[x - 1])\n        Y = list(data)\n        X = list(range(1, n + 1))\n    try:\n        return interpolating_poly(n, x, X, Y).expand()\n    except ValueError:\n        d = Dummy()\n        return interpolating_poly(n, d, X, Y).expand().subs(d, x)",
            "@public\ndef interpolate(data, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Construct an interpolating polynomial for the data points\\n    evaluated at point x (which can be symbolic or numeric).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import interpolate\\n    >>> from sympy.abc import a, b, x\\n\\n    A list is interpreted as though it were paired with a range starting\\n    from 1:\\n\\n    >>> interpolate([1, 4, 9, 16], x)\\n    x**2\\n\\n    This can be made explicit by giving a list of coordinates:\\n\\n    >>> interpolate([(1, 1), (2, 4), (3, 9)], x)\\n    x**2\\n\\n    The (x, y) coordinates can also be given as keys and values of a\\n    dictionary (and the points need not be equispaced):\\n\\n    >>> interpolate([(-1, 2), (1, 2), (2, 5)], x)\\n    x**2 + 1\\n    >>> interpolate({-1: 2, 1: 2, 2: 5}, x)\\n    x**2 + 1\\n\\n    If the interpolation is going to be used only once then the\\n    value of interest can be passed instead of passing a symbol:\\n\\n    >>> interpolate([1, 4, 9], 5)\\n    25\\n\\n    Symbolic coordinates are also supported:\\n\\n    >>> [(i,interpolate((a, b), i)) for i in range(1, 4)]\\n    [(1, a), (2, b), (3, -a + 2*b)]\\n    '\n    n = len(data)\n    if isinstance(data, dict):\n        if x in data:\n            return S(data[x])\n        (X, Y) = list(zip(*data.items()))\n    elif isinstance(data[0], tuple):\n        (X, Y) = list(zip(*data))\n        if x in X:\n            return S(Y[X.index(x)])\n    else:\n        if x in range(1, n + 1):\n            return S(data[x - 1])\n        Y = list(data)\n        X = list(range(1, n + 1))\n    try:\n        return interpolating_poly(n, x, X, Y).expand()\n    except ValueError:\n        d = Dummy()\n        return interpolating_poly(n, d, X, Y).expand().subs(d, x)",
            "@public\ndef interpolate(data, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Construct an interpolating polynomial for the data points\\n    evaluated at point x (which can be symbolic or numeric).\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import interpolate\\n    >>> from sympy.abc import a, b, x\\n\\n    A list is interpreted as though it were paired with a range starting\\n    from 1:\\n\\n    >>> interpolate([1, 4, 9, 16], x)\\n    x**2\\n\\n    This can be made explicit by giving a list of coordinates:\\n\\n    >>> interpolate([(1, 1), (2, 4), (3, 9)], x)\\n    x**2\\n\\n    The (x, y) coordinates can also be given as keys and values of a\\n    dictionary (and the points need not be equispaced):\\n\\n    >>> interpolate([(-1, 2), (1, 2), (2, 5)], x)\\n    x**2 + 1\\n    >>> interpolate({-1: 2, 1: 2, 2: 5}, x)\\n    x**2 + 1\\n\\n    If the interpolation is going to be used only once then the\\n    value of interest can be passed instead of passing a symbol:\\n\\n    >>> interpolate([1, 4, 9], 5)\\n    25\\n\\n    Symbolic coordinates are also supported:\\n\\n    >>> [(i,interpolate((a, b), i)) for i in range(1, 4)]\\n    [(1, a), (2, b), (3, -a + 2*b)]\\n    '\n    n = len(data)\n    if isinstance(data, dict):\n        if x in data:\n            return S(data[x])\n        (X, Y) = list(zip(*data.items()))\n    elif isinstance(data[0], tuple):\n        (X, Y) = list(zip(*data))\n        if x in X:\n            return S(Y[X.index(x)])\n    else:\n        if x in range(1, n + 1):\n            return S(data[x - 1])\n        Y = list(data)\n        X = list(range(1, n + 1))\n    try:\n        return interpolating_poly(n, x, X, Y).expand()\n    except ValueError:\n        d = Dummy()\n        return interpolating_poly(n, d, X, Y).expand().subs(d, x)"
        ]
    },
    {
        "func_name": "rational_interpolate",
        "original": "@public\ndef rational_interpolate(data, degnum, X=symbols('x')):\n    \"\"\"\n    Returns a rational interpolation, where the data points are element of\n    any integral domain.\n\n    The first argument  contains the data (as a list of coordinates). The\n    ``degnum`` argument is the degree in the numerator of the rational\n    function. Setting it too high will decrease the maximal degree in the\n    denominator for the same amount of data.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polyfuncs import rational_interpolate\n\n    >>> data = [(1, -210), (2, -35), (3, 105), (4, 231), (5, 350), (6, 465)]\n    >>> rational_interpolate(data, 2)\n    (105*x**2 - 525)/(x + 1)\n\n    Values do not need to be integers:\n\n    >>> from sympy import sympify\n    >>> x = [1, 2, 3, 4, 5, 6]\n    >>> y = sympify(\"[-1, 0, 2, 22/5, 7, 68/7]\")\n    >>> rational_interpolate(zip(x, y), 2)\n    (3*x**2 - 7*x + 2)/(x + 1)\n\n    The symbol for the variable can be changed if needed:\n    >>> from sympy import symbols\n    >>> z = symbols('z')\n    >>> rational_interpolate(data, 2, X=z)\n    (105*z**2 - 525)/(z + 1)\n\n    References\n    ==========\n\n    .. [1] Algorithm is adapted from:\n           http://axiom-wiki.newsynthesis.org/RationalInterpolation\n\n    \"\"\"\n    from sympy.matrices.dense import ones\n    (xdata, ydata) = list(zip(*data))\n    k = len(xdata) - degnum - 1\n    if k < 0:\n        raise OptionError('Too few values for the required degree.')\n    c = ones(degnum + k + 1, degnum + k + 2)\n    for j in range(max(degnum, k)):\n        for i in range(degnum + k + 1):\n            c[i, j + 1] = c[i, j] * xdata[i]\n    for j in range(k + 1):\n        for i in range(degnum + k + 1):\n            c[i, degnum + k + 1 - j] = -c[i, k - j] * ydata[i]\n    r = c.nullspace()[0]\n    return sum((r[i] * X ** i for i in range(degnum + 1))) / sum((r[i + degnum + 1] * X ** i for i in range(k + 1)))",
        "mutated": [
            "@public\ndef rational_interpolate(data, degnum, X=symbols('x')):\n    if False:\n        i = 10\n    '\\n    Returns a rational interpolation, where the data points are element of\\n    any integral domain.\\n\\n    The first argument  contains the data (as a list of coordinates). The\\n    ``degnum`` argument is the degree in the numerator of the rational\\n    function. Setting it too high will decrease the maximal degree in the\\n    denominator for the same amount of data.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import rational_interpolate\\n\\n    >>> data = [(1, -210), (2, -35), (3, 105), (4, 231), (5, 350), (6, 465)]\\n    >>> rational_interpolate(data, 2)\\n    (105*x**2 - 525)/(x + 1)\\n\\n    Values do not need to be integers:\\n\\n    >>> from sympy import sympify\\n    >>> x = [1, 2, 3, 4, 5, 6]\\n    >>> y = sympify(\"[-1, 0, 2, 22/5, 7, 68/7]\")\\n    >>> rational_interpolate(zip(x, y), 2)\\n    (3*x**2 - 7*x + 2)/(x + 1)\\n\\n    The symbol for the variable can be changed if needed:\\n    >>> from sympy import symbols\\n    >>> z = symbols(\\'z\\')\\n    >>> rational_interpolate(data, 2, X=z)\\n    (105*z**2 - 525)/(z + 1)\\n\\n    References\\n    ==========\\n\\n    .. [1] Algorithm is adapted from:\\n           http://axiom-wiki.newsynthesis.org/RationalInterpolation\\n\\n    '\n    from sympy.matrices.dense import ones\n    (xdata, ydata) = list(zip(*data))\n    k = len(xdata) - degnum - 1\n    if k < 0:\n        raise OptionError('Too few values for the required degree.')\n    c = ones(degnum + k + 1, degnum + k + 2)\n    for j in range(max(degnum, k)):\n        for i in range(degnum + k + 1):\n            c[i, j + 1] = c[i, j] * xdata[i]\n    for j in range(k + 1):\n        for i in range(degnum + k + 1):\n            c[i, degnum + k + 1 - j] = -c[i, k - j] * ydata[i]\n    r = c.nullspace()[0]\n    return sum((r[i] * X ** i for i in range(degnum + 1))) / sum((r[i + degnum + 1] * X ** i for i in range(k + 1)))",
            "@public\ndef rational_interpolate(data, degnum, X=symbols('x')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a rational interpolation, where the data points are element of\\n    any integral domain.\\n\\n    The first argument  contains the data (as a list of coordinates). The\\n    ``degnum`` argument is the degree in the numerator of the rational\\n    function. Setting it too high will decrease the maximal degree in the\\n    denominator for the same amount of data.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import rational_interpolate\\n\\n    >>> data = [(1, -210), (2, -35), (3, 105), (4, 231), (5, 350), (6, 465)]\\n    >>> rational_interpolate(data, 2)\\n    (105*x**2 - 525)/(x + 1)\\n\\n    Values do not need to be integers:\\n\\n    >>> from sympy import sympify\\n    >>> x = [1, 2, 3, 4, 5, 6]\\n    >>> y = sympify(\"[-1, 0, 2, 22/5, 7, 68/7]\")\\n    >>> rational_interpolate(zip(x, y), 2)\\n    (3*x**2 - 7*x + 2)/(x + 1)\\n\\n    The symbol for the variable can be changed if needed:\\n    >>> from sympy import symbols\\n    >>> z = symbols(\\'z\\')\\n    >>> rational_interpolate(data, 2, X=z)\\n    (105*z**2 - 525)/(z + 1)\\n\\n    References\\n    ==========\\n\\n    .. [1] Algorithm is adapted from:\\n           http://axiom-wiki.newsynthesis.org/RationalInterpolation\\n\\n    '\n    from sympy.matrices.dense import ones\n    (xdata, ydata) = list(zip(*data))\n    k = len(xdata) - degnum - 1\n    if k < 0:\n        raise OptionError('Too few values for the required degree.')\n    c = ones(degnum + k + 1, degnum + k + 2)\n    for j in range(max(degnum, k)):\n        for i in range(degnum + k + 1):\n            c[i, j + 1] = c[i, j] * xdata[i]\n    for j in range(k + 1):\n        for i in range(degnum + k + 1):\n            c[i, degnum + k + 1 - j] = -c[i, k - j] * ydata[i]\n    r = c.nullspace()[0]\n    return sum((r[i] * X ** i for i in range(degnum + 1))) / sum((r[i + degnum + 1] * X ** i for i in range(k + 1)))",
            "@public\ndef rational_interpolate(data, degnum, X=symbols('x')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a rational interpolation, where the data points are element of\\n    any integral domain.\\n\\n    The first argument  contains the data (as a list of coordinates). The\\n    ``degnum`` argument is the degree in the numerator of the rational\\n    function. Setting it too high will decrease the maximal degree in the\\n    denominator for the same amount of data.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import rational_interpolate\\n\\n    >>> data = [(1, -210), (2, -35), (3, 105), (4, 231), (5, 350), (6, 465)]\\n    >>> rational_interpolate(data, 2)\\n    (105*x**2 - 525)/(x + 1)\\n\\n    Values do not need to be integers:\\n\\n    >>> from sympy import sympify\\n    >>> x = [1, 2, 3, 4, 5, 6]\\n    >>> y = sympify(\"[-1, 0, 2, 22/5, 7, 68/7]\")\\n    >>> rational_interpolate(zip(x, y), 2)\\n    (3*x**2 - 7*x + 2)/(x + 1)\\n\\n    The symbol for the variable can be changed if needed:\\n    >>> from sympy import symbols\\n    >>> z = symbols(\\'z\\')\\n    >>> rational_interpolate(data, 2, X=z)\\n    (105*z**2 - 525)/(z + 1)\\n\\n    References\\n    ==========\\n\\n    .. [1] Algorithm is adapted from:\\n           http://axiom-wiki.newsynthesis.org/RationalInterpolation\\n\\n    '\n    from sympy.matrices.dense import ones\n    (xdata, ydata) = list(zip(*data))\n    k = len(xdata) - degnum - 1\n    if k < 0:\n        raise OptionError('Too few values for the required degree.')\n    c = ones(degnum + k + 1, degnum + k + 2)\n    for j in range(max(degnum, k)):\n        for i in range(degnum + k + 1):\n            c[i, j + 1] = c[i, j] * xdata[i]\n    for j in range(k + 1):\n        for i in range(degnum + k + 1):\n            c[i, degnum + k + 1 - j] = -c[i, k - j] * ydata[i]\n    r = c.nullspace()[0]\n    return sum((r[i] * X ** i for i in range(degnum + 1))) / sum((r[i + degnum + 1] * X ** i for i in range(k + 1)))",
            "@public\ndef rational_interpolate(data, degnum, X=symbols('x')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a rational interpolation, where the data points are element of\\n    any integral domain.\\n\\n    The first argument  contains the data (as a list of coordinates). The\\n    ``degnum`` argument is the degree in the numerator of the rational\\n    function. Setting it too high will decrease the maximal degree in the\\n    denominator for the same amount of data.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import rational_interpolate\\n\\n    >>> data = [(1, -210), (2, -35), (3, 105), (4, 231), (5, 350), (6, 465)]\\n    >>> rational_interpolate(data, 2)\\n    (105*x**2 - 525)/(x + 1)\\n\\n    Values do not need to be integers:\\n\\n    >>> from sympy import sympify\\n    >>> x = [1, 2, 3, 4, 5, 6]\\n    >>> y = sympify(\"[-1, 0, 2, 22/5, 7, 68/7]\")\\n    >>> rational_interpolate(zip(x, y), 2)\\n    (3*x**2 - 7*x + 2)/(x + 1)\\n\\n    The symbol for the variable can be changed if needed:\\n    >>> from sympy import symbols\\n    >>> z = symbols(\\'z\\')\\n    >>> rational_interpolate(data, 2, X=z)\\n    (105*z**2 - 525)/(z + 1)\\n\\n    References\\n    ==========\\n\\n    .. [1] Algorithm is adapted from:\\n           http://axiom-wiki.newsynthesis.org/RationalInterpolation\\n\\n    '\n    from sympy.matrices.dense import ones\n    (xdata, ydata) = list(zip(*data))\n    k = len(xdata) - degnum - 1\n    if k < 0:\n        raise OptionError('Too few values for the required degree.')\n    c = ones(degnum + k + 1, degnum + k + 2)\n    for j in range(max(degnum, k)):\n        for i in range(degnum + k + 1):\n            c[i, j + 1] = c[i, j] * xdata[i]\n    for j in range(k + 1):\n        for i in range(degnum + k + 1):\n            c[i, degnum + k + 1 - j] = -c[i, k - j] * ydata[i]\n    r = c.nullspace()[0]\n    return sum((r[i] * X ** i for i in range(degnum + 1))) / sum((r[i + degnum + 1] * X ** i for i in range(k + 1)))",
            "@public\ndef rational_interpolate(data, degnum, X=symbols('x')):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a rational interpolation, where the data points are element of\\n    any integral domain.\\n\\n    The first argument  contains the data (as a list of coordinates). The\\n    ``degnum`` argument is the degree in the numerator of the rational\\n    function. Setting it too high will decrease the maximal degree in the\\n    denominator for the same amount of data.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import rational_interpolate\\n\\n    >>> data = [(1, -210), (2, -35), (3, 105), (4, 231), (5, 350), (6, 465)]\\n    >>> rational_interpolate(data, 2)\\n    (105*x**2 - 525)/(x + 1)\\n\\n    Values do not need to be integers:\\n\\n    >>> from sympy import sympify\\n    >>> x = [1, 2, 3, 4, 5, 6]\\n    >>> y = sympify(\"[-1, 0, 2, 22/5, 7, 68/7]\")\\n    >>> rational_interpolate(zip(x, y), 2)\\n    (3*x**2 - 7*x + 2)/(x + 1)\\n\\n    The symbol for the variable can be changed if needed:\\n    >>> from sympy import symbols\\n    >>> z = symbols(\\'z\\')\\n    >>> rational_interpolate(data, 2, X=z)\\n    (105*z**2 - 525)/(z + 1)\\n\\n    References\\n    ==========\\n\\n    .. [1] Algorithm is adapted from:\\n           http://axiom-wiki.newsynthesis.org/RationalInterpolation\\n\\n    '\n    from sympy.matrices.dense import ones\n    (xdata, ydata) = list(zip(*data))\n    k = len(xdata) - degnum - 1\n    if k < 0:\n        raise OptionError('Too few values for the required degree.')\n    c = ones(degnum + k + 1, degnum + k + 2)\n    for j in range(max(degnum, k)):\n        for i in range(degnum + k + 1):\n            c[i, j + 1] = c[i, j] * xdata[i]\n    for j in range(k + 1):\n        for i in range(degnum + k + 1):\n            c[i, degnum + k + 1 - j] = -c[i, k - j] * ydata[i]\n    r = c.nullspace()[0]\n    return sum((r[i] * X ** i for i in range(degnum + 1))) / sum((r[i + degnum + 1] * X ** i for i in range(k + 1)))"
        ]
    },
    {
        "func_name": "viete",
        "original": "@public\ndef viete(f, roots=None, *gens, **args):\n    \"\"\"\n    Generate Viete's formulas for ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polyfuncs import viete\n    >>> from sympy import symbols\n\n    >>> x, a, b, c, r1, r2 = symbols('x,a:c,r1:3')\n\n    >>> viete(a*x**2 + b*x + c, [r1, r2], x)\n    [(r1 + r2, -b/a), (r1*r2, c/a)]\n\n    \"\"\"\n    allowed_flags(args, [])\n    if isinstance(roots, Basic):\n        (gens, roots) = ((roots,) + gens, None)\n    try:\n        (f, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('viete', 1, exc)\n    if f.is_multivariate:\n        raise MultivariatePolynomialError('multivariate polynomials are not allowed')\n    n = f.degree()\n    if n < 1:\n        raise ValueError(\"Cannot derive Viete's formulas for a constant polynomial\")\n    if roots is None:\n        roots = numbered_symbols('r', start=1)\n    roots = take(roots, n)\n    if n != len(roots):\n        raise ValueError('required %s roots, got %s' % (n, len(roots)))\n    (lc, coeffs) = (f.LC(), f.all_coeffs())\n    (result, sign) = ([], -1)\n    for (i, coeff) in enumerate(coeffs[1:]):\n        poly = symmetric_poly(i + 1, roots)\n        coeff = sign * (coeff / lc)\n        result.append((poly, coeff))\n        sign = -sign\n    return result",
        "mutated": [
            "@public\ndef viete(f, roots=None, *gens, **args):\n    if False:\n        i = 10\n    \"\\n    Generate Viete's formulas for ``f``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import viete\\n    >>> from sympy import symbols\\n\\n    >>> x, a, b, c, r1, r2 = symbols('x,a:c,r1:3')\\n\\n    >>> viete(a*x**2 + b*x + c, [r1, r2], x)\\n    [(r1 + r2, -b/a), (r1*r2, c/a)]\\n\\n    \"\n    allowed_flags(args, [])\n    if isinstance(roots, Basic):\n        (gens, roots) = ((roots,) + gens, None)\n    try:\n        (f, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('viete', 1, exc)\n    if f.is_multivariate:\n        raise MultivariatePolynomialError('multivariate polynomials are not allowed')\n    n = f.degree()\n    if n < 1:\n        raise ValueError(\"Cannot derive Viete's formulas for a constant polynomial\")\n    if roots is None:\n        roots = numbered_symbols('r', start=1)\n    roots = take(roots, n)\n    if n != len(roots):\n        raise ValueError('required %s roots, got %s' % (n, len(roots)))\n    (lc, coeffs) = (f.LC(), f.all_coeffs())\n    (result, sign) = ([], -1)\n    for (i, coeff) in enumerate(coeffs[1:]):\n        poly = symmetric_poly(i + 1, roots)\n        coeff = sign * (coeff / lc)\n        result.append((poly, coeff))\n        sign = -sign\n    return result",
            "@public\ndef viete(f, roots=None, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Generate Viete's formulas for ``f``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import viete\\n    >>> from sympy import symbols\\n\\n    >>> x, a, b, c, r1, r2 = symbols('x,a:c,r1:3')\\n\\n    >>> viete(a*x**2 + b*x + c, [r1, r2], x)\\n    [(r1 + r2, -b/a), (r1*r2, c/a)]\\n\\n    \"\n    allowed_flags(args, [])\n    if isinstance(roots, Basic):\n        (gens, roots) = ((roots,) + gens, None)\n    try:\n        (f, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('viete', 1, exc)\n    if f.is_multivariate:\n        raise MultivariatePolynomialError('multivariate polynomials are not allowed')\n    n = f.degree()\n    if n < 1:\n        raise ValueError(\"Cannot derive Viete's formulas for a constant polynomial\")\n    if roots is None:\n        roots = numbered_symbols('r', start=1)\n    roots = take(roots, n)\n    if n != len(roots):\n        raise ValueError('required %s roots, got %s' % (n, len(roots)))\n    (lc, coeffs) = (f.LC(), f.all_coeffs())\n    (result, sign) = ([], -1)\n    for (i, coeff) in enumerate(coeffs[1:]):\n        poly = symmetric_poly(i + 1, roots)\n        coeff = sign * (coeff / lc)\n        result.append((poly, coeff))\n        sign = -sign\n    return result",
            "@public\ndef viete(f, roots=None, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Generate Viete's formulas for ``f``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import viete\\n    >>> from sympy import symbols\\n\\n    >>> x, a, b, c, r1, r2 = symbols('x,a:c,r1:3')\\n\\n    >>> viete(a*x**2 + b*x + c, [r1, r2], x)\\n    [(r1 + r2, -b/a), (r1*r2, c/a)]\\n\\n    \"\n    allowed_flags(args, [])\n    if isinstance(roots, Basic):\n        (gens, roots) = ((roots,) + gens, None)\n    try:\n        (f, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('viete', 1, exc)\n    if f.is_multivariate:\n        raise MultivariatePolynomialError('multivariate polynomials are not allowed')\n    n = f.degree()\n    if n < 1:\n        raise ValueError(\"Cannot derive Viete's formulas for a constant polynomial\")\n    if roots is None:\n        roots = numbered_symbols('r', start=1)\n    roots = take(roots, n)\n    if n != len(roots):\n        raise ValueError('required %s roots, got %s' % (n, len(roots)))\n    (lc, coeffs) = (f.LC(), f.all_coeffs())\n    (result, sign) = ([], -1)\n    for (i, coeff) in enumerate(coeffs[1:]):\n        poly = symmetric_poly(i + 1, roots)\n        coeff = sign * (coeff / lc)\n        result.append((poly, coeff))\n        sign = -sign\n    return result",
            "@public\ndef viete(f, roots=None, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Generate Viete's formulas for ``f``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import viete\\n    >>> from sympy import symbols\\n\\n    >>> x, a, b, c, r1, r2 = symbols('x,a:c,r1:3')\\n\\n    >>> viete(a*x**2 + b*x + c, [r1, r2], x)\\n    [(r1 + r2, -b/a), (r1*r2, c/a)]\\n\\n    \"\n    allowed_flags(args, [])\n    if isinstance(roots, Basic):\n        (gens, roots) = ((roots,) + gens, None)\n    try:\n        (f, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('viete', 1, exc)\n    if f.is_multivariate:\n        raise MultivariatePolynomialError('multivariate polynomials are not allowed')\n    n = f.degree()\n    if n < 1:\n        raise ValueError(\"Cannot derive Viete's formulas for a constant polynomial\")\n    if roots is None:\n        roots = numbered_symbols('r', start=1)\n    roots = take(roots, n)\n    if n != len(roots):\n        raise ValueError('required %s roots, got %s' % (n, len(roots)))\n    (lc, coeffs) = (f.LC(), f.all_coeffs())\n    (result, sign) = ([], -1)\n    for (i, coeff) in enumerate(coeffs[1:]):\n        poly = symmetric_poly(i + 1, roots)\n        coeff = sign * (coeff / lc)\n        result.append((poly, coeff))\n        sign = -sign\n    return result",
            "@public\ndef viete(f, roots=None, *gens, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Generate Viete's formulas for ``f``.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.polys.polyfuncs import viete\\n    >>> from sympy import symbols\\n\\n    >>> x, a, b, c, r1, r2 = symbols('x,a:c,r1:3')\\n\\n    >>> viete(a*x**2 + b*x + c, [r1, r2], x)\\n    [(r1 + r2, -b/a), (r1*r2, c/a)]\\n\\n    \"\n    allowed_flags(args, [])\n    if isinstance(roots, Basic):\n        (gens, roots) = ((roots,) + gens, None)\n    try:\n        (f, opt) = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('viete', 1, exc)\n    if f.is_multivariate:\n        raise MultivariatePolynomialError('multivariate polynomials are not allowed')\n    n = f.degree()\n    if n < 1:\n        raise ValueError(\"Cannot derive Viete's formulas for a constant polynomial\")\n    if roots is None:\n        roots = numbered_symbols('r', start=1)\n    roots = take(roots, n)\n    if n != len(roots):\n        raise ValueError('required %s roots, got %s' % (n, len(roots)))\n    (lc, coeffs) = (f.LC(), f.all_coeffs())\n    (result, sign) = ([], -1)\n    for (i, coeff) in enumerate(coeffs[1:]):\n        poly = symmetric_poly(i + 1, roots)\n        coeff = sign * (coeff / lc)\n        result.append((poly, coeff))\n        sign = -sign\n    return result"
        ]
    }
]