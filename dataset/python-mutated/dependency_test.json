[
    {
        "func_name": "test_basic",
        "original": "def test_basic():\n    t = BoostBuild.Tester(['-d3', '-d+12'], use_test_config=False)\n    t.write('a.cpp', '\\n#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\nint main() {}\\n')\n    t.write('a.h', '\\n')\n    t.write('a_c.c', '#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\n')\n    t.write('b.cpp', '#include \"a.h\"\\nint main() {}\\n')\n    t.write('b.h', '\\n')\n    t.write('c.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('e.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('x.foo', '')\n    t.write('y.foo', '')\n    t.write('src1/a.h', '#include \"b.h\"\\n')\n    t.write('src1/b.h', '#include \"c.h\"\\n')\n    t.write('src1/c.h', '\\n')\n    t.write('src1/z.h', 'extern int dummy_variable_suppressing_empty_file_warning_on_hp_cxx_compiler;\\n')\n    t.write('src2/b.h', '\\n')\n    t.write('jamroot.jam', 'import foo ;\\nimport types/cpp ;\\nimport types/exe ;\\n\\nproject test : requirements <include>src1 ;\\n\\nexe a : x.foo a.cpp a_c.c ;\\nexe b : b.cpp ;\\n\\n# Because of <define>FOO, c.cpp will be compiled to a different directory than\\n# everything for main target \"a\". Therefore, without <implicit-dependency>, C\\n# preprocessor processing that module will not find \"x.h\", which is part of\\n# \"a\"\\'s dependency graph.\\n#\\n# --------------------------\\n# More detailed explanation:\\n# --------------------------\\n#   c.cpp includes x.h which does not exist on the current include path so Boost\\n# Jam will try to match it to existing Jam targets to cover cases as this one\\n# where the file is generated by the same build.\\n#\\n#   However, as x.h is not part of \"c\" metatarget\\'s dependency graph, Boost\\n# Build will not actualize its target by default, i.e. create its Jam target.\\n#\\n#   To get the Jam target created in time, we use the <implicit-dependency>\\n# feature. This tells Boost Build that it needs to actualize the dependency\\n# graph for metatarget \"a\", even though that metatarget has not been directly\\n# mentioned and is not a dependency for any of the metatargets mentioned in the\\n# current build request.\\n#\\n#   Note that Boost Build does not automatically add a dependency between the\\n# Jam targets in question so, if Boost Jam does not add a dependency on a target\\n# from that other dependency graph (x.h in our case), i.e. if c.cpp does not\\n# actually include x.h, us actualizing it will have no effect in the end as\\n# Boost Jam will not have a reason to actually build those targets in spite of\\n# knowing about them.\\nexe c : c.cpp : <define>FOO <implicit-dependency>a ;\\n')\n    t.write('foo.jam', 'import generators ;\\nimport modules ;\\nimport os ;\\nimport print ;\\nimport type ;\\nimport types/cpp ;\\n\\ntype.register FOO : foo ;\\n\\ngenerators.register-standard foo.foo : FOO : CPP H ;\\n\\nnl = \"\\n\" ;\\n\\nrule foo ( targets * : sources * : properties * )\\n{\\n    # On NT, you need an exported symbol in order to have an import library\\n    # generated. We will not really use the symbol defined here, just force the\\n    # import library creation.\\n    if ( [ os.name ] = NT || [ modules.peek : OS ] in CYGWIN ) &&\\n        <main-target-type>LIB in $(properties)\\n    {\\n        .decl = \"void __declspec(dllexport) foo() {}\" ;\\n    }\\n    print.output $(<[1]) ;\\n    print.text $(.decl:E=\"//\")$(nl) ;\\n    print.output $(<[2]) ;\\n    print.text \"#include <z.h>\"$(nl) ;\\n}\\n')\n    t.write('foo.py', 'import bjam\\nimport b2.build.type as type\\nimport b2.build.generators as generators\\n\\nfrom b2.manager import get_manager\\n\\ntype.register(\"FOO\", [\"foo\"])\\ngenerators.register_standard(\"foo.foo\", [\"FOO\"], [\"CPP\", \"H\"])\\n\\ndef prepare_foo(targets, sources, properties):\\n    if properties.get(\\'os\\') in [\\'windows\\', \\'cygwin\\']:\\n        bjam.call(\\'set-target-variable\\', targets, \"DECL\",\\n            \"void __declspec(dllexport) foo() {}\")\\n\\nget_manager().engine().register_action(\"foo.foo\",\\n    \"echo -e $(DECL:E=//)\\\\\\\\n > $(<[1])\\\\n\"\\n    \"echo -e \"#include <z.h>\\\\\\\\n\" > $(<[2])\\\\n\", function=prepare_foo)\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/c.exe')\n    t.touch('a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_touch('bin/$toolset/debug*/b.exe')\n    t.expect_touch('bin/$toolset/debug*/b.obj')\n    t.expect_nothing_more()\n    t.touch('src1/a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/b.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/c.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.touch('b.h')\n    t.run_build_system()\n    t.expect_nothing_more()\n    t.touch('x.foo')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.touch('src1/z.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.cleanup()",
        "mutated": [
            "def test_basic():\n    if False:\n        i = 10\n    t = BoostBuild.Tester(['-d3', '-d+12'], use_test_config=False)\n    t.write('a.cpp', '\\n#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\nint main() {}\\n')\n    t.write('a.h', '\\n')\n    t.write('a_c.c', '#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\n')\n    t.write('b.cpp', '#include \"a.h\"\\nint main() {}\\n')\n    t.write('b.h', '\\n')\n    t.write('c.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('e.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('x.foo', '')\n    t.write('y.foo', '')\n    t.write('src1/a.h', '#include \"b.h\"\\n')\n    t.write('src1/b.h', '#include \"c.h\"\\n')\n    t.write('src1/c.h', '\\n')\n    t.write('src1/z.h', 'extern int dummy_variable_suppressing_empty_file_warning_on_hp_cxx_compiler;\\n')\n    t.write('src2/b.h', '\\n')\n    t.write('jamroot.jam', 'import foo ;\\nimport types/cpp ;\\nimport types/exe ;\\n\\nproject test : requirements <include>src1 ;\\n\\nexe a : x.foo a.cpp a_c.c ;\\nexe b : b.cpp ;\\n\\n# Because of <define>FOO, c.cpp will be compiled to a different directory than\\n# everything for main target \"a\". Therefore, without <implicit-dependency>, C\\n# preprocessor processing that module will not find \"x.h\", which is part of\\n# \"a\"\\'s dependency graph.\\n#\\n# --------------------------\\n# More detailed explanation:\\n# --------------------------\\n#   c.cpp includes x.h which does not exist on the current include path so Boost\\n# Jam will try to match it to existing Jam targets to cover cases as this one\\n# where the file is generated by the same build.\\n#\\n#   However, as x.h is not part of \"c\" metatarget\\'s dependency graph, Boost\\n# Build will not actualize its target by default, i.e. create its Jam target.\\n#\\n#   To get the Jam target created in time, we use the <implicit-dependency>\\n# feature. This tells Boost Build that it needs to actualize the dependency\\n# graph for metatarget \"a\", even though that metatarget has not been directly\\n# mentioned and is not a dependency for any of the metatargets mentioned in the\\n# current build request.\\n#\\n#   Note that Boost Build does not automatically add a dependency between the\\n# Jam targets in question so, if Boost Jam does not add a dependency on a target\\n# from that other dependency graph (x.h in our case), i.e. if c.cpp does not\\n# actually include x.h, us actualizing it will have no effect in the end as\\n# Boost Jam will not have a reason to actually build those targets in spite of\\n# knowing about them.\\nexe c : c.cpp : <define>FOO <implicit-dependency>a ;\\n')\n    t.write('foo.jam', 'import generators ;\\nimport modules ;\\nimport os ;\\nimport print ;\\nimport type ;\\nimport types/cpp ;\\n\\ntype.register FOO : foo ;\\n\\ngenerators.register-standard foo.foo : FOO : CPP H ;\\n\\nnl = \"\\n\" ;\\n\\nrule foo ( targets * : sources * : properties * )\\n{\\n    # On NT, you need an exported symbol in order to have an import library\\n    # generated. We will not really use the symbol defined here, just force the\\n    # import library creation.\\n    if ( [ os.name ] = NT || [ modules.peek : OS ] in CYGWIN ) &&\\n        <main-target-type>LIB in $(properties)\\n    {\\n        .decl = \"void __declspec(dllexport) foo() {}\" ;\\n    }\\n    print.output $(<[1]) ;\\n    print.text $(.decl:E=\"//\")$(nl) ;\\n    print.output $(<[2]) ;\\n    print.text \"#include <z.h>\"$(nl) ;\\n}\\n')\n    t.write('foo.py', 'import bjam\\nimport b2.build.type as type\\nimport b2.build.generators as generators\\n\\nfrom b2.manager import get_manager\\n\\ntype.register(\"FOO\", [\"foo\"])\\ngenerators.register_standard(\"foo.foo\", [\"FOO\"], [\"CPP\", \"H\"])\\n\\ndef prepare_foo(targets, sources, properties):\\n    if properties.get(\\'os\\') in [\\'windows\\', \\'cygwin\\']:\\n        bjam.call(\\'set-target-variable\\', targets, \"DECL\",\\n            \"void __declspec(dllexport) foo() {}\")\\n\\nget_manager().engine().register_action(\"foo.foo\",\\n    \"echo -e $(DECL:E=//)\\\\\\\\n > $(<[1])\\\\n\"\\n    \"echo -e \"#include <z.h>\\\\\\\\n\" > $(<[2])\\\\n\", function=prepare_foo)\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/c.exe')\n    t.touch('a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_touch('bin/$toolset/debug*/b.exe')\n    t.expect_touch('bin/$toolset/debug*/b.obj')\n    t.expect_nothing_more()\n    t.touch('src1/a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/b.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/c.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.touch('b.h')\n    t.run_build_system()\n    t.expect_nothing_more()\n    t.touch('x.foo')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.touch('src1/z.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    t = BoostBuild.Tester(['-d3', '-d+12'], use_test_config=False)\n    t.write('a.cpp', '\\n#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\nint main() {}\\n')\n    t.write('a.h', '\\n')\n    t.write('a_c.c', '#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\n')\n    t.write('b.cpp', '#include \"a.h\"\\nint main() {}\\n')\n    t.write('b.h', '\\n')\n    t.write('c.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('e.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('x.foo', '')\n    t.write('y.foo', '')\n    t.write('src1/a.h', '#include \"b.h\"\\n')\n    t.write('src1/b.h', '#include \"c.h\"\\n')\n    t.write('src1/c.h', '\\n')\n    t.write('src1/z.h', 'extern int dummy_variable_suppressing_empty_file_warning_on_hp_cxx_compiler;\\n')\n    t.write('src2/b.h', '\\n')\n    t.write('jamroot.jam', 'import foo ;\\nimport types/cpp ;\\nimport types/exe ;\\n\\nproject test : requirements <include>src1 ;\\n\\nexe a : x.foo a.cpp a_c.c ;\\nexe b : b.cpp ;\\n\\n# Because of <define>FOO, c.cpp will be compiled to a different directory than\\n# everything for main target \"a\". Therefore, without <implicit-dependency>, C\\n# preprocessor processing that module will not find \"x.h\", which is part of\\n# \"a\"\\'s dependency graph.\\n#\\n# --------------------------\\n# More detailed explanation:\\n# --------------------------\\n#   c.cpp includes x.h which does not exist on the current include path so Boost\\n# Jam will try to match it to existing Jam targets to cover cases as this one\\n# where the file is generated by the same build.\\n#\\n#   However, as x.h is not part of \"c\" metatarget\\'s dependency graph, Boost\\n# Build will not actualize its target by default, i.e. create its Jam target.\\n#\\n#   To get the Jam target created in time, we use the <implicit-dependency>\\n# feature. This tells Boost Build that it needs to actualize the dependency\\n# graph for metatarget \"a\", even though that metatarget has not been directly\\n# mentioned and is not a dependency for any of the metatargets mentioned in the\\n# current build request.\\n#\\n#   Note that Boost Build does not automatically add a dependency between the\\n# Jam targets in question so, if Boost Jam does not add a dependency on a target\\n# from that other dependency graph (x.h in our case), i.e. if c.cpp does not\\n# actually include x.h, us actualizing it will have no effect in the end as\\n# Boost Jam will not have a reason to actually build those targets in spite of\\n# knowing about them.\\nexe c : c.cpp : <define>FOO <implicit-dependency>a ;\\n')\n    t.write('foo.jam', 'import generators ;\\nimport modules ;\\nimport os ;\\nimport print ;\\nimport type ;\\nimport types/cpp ;\\n\\ntype.register FOO : foo ;\\n\\ngenerators.register-standard foo.foo : FOO : CPP H ;\\n\\nnl = \"\\n\" ;\\n\\nrule foo ( targets * : sources * : properties * )\\n{\\n    # On NT, you need an exported symbol in order to have an import library\\n    # generated. We will not really use the symbol defined here, just force the\\n    # import library creation.\\n    if ( [ os.name ] = NT || [ modules.peek : OS ] in CYGWIN ) &&\\n        <main-target-type>LIB in $(properties)\\n    {\\n        .decl = \"void __declspec(dllexport) foo() {}\" ;\\n    }\\n    print.output $(<[1]) ;\\n    print.text $(.decl:E=\"//\")$(nl) ;\\n    print.output $(<[2]) ;\\n    print.text \"#include <z.h>\"$(nl) ;\\n}\\n')\n    t.write('foo.py', 'import bjam\\nimport b2.build.type as type\\nimport b2.build.generators as generators\\n\\nfrom b2.manager import get_manager\\n\\ntype.register(\"FOO\", [\"foo\"])\\ngenerators.register_standard(\"foo.foo\", [\"FOO\"], [\"CPP\", \"H\"])\\n\\ndef prepare_foo(targets, sources, properties):\\n    if properties.get(\\'os\\') in [\\'windows\\', \\'cygwin\\']:\\n        bjam.call(\\'set-target-variable\\', targets, \"DECL\",\\n            \"void __declspec(dllexport) foo() {}\")\\n\\nget_manager().engine().register_action(\"foo.foo\",\\n    \"echo -e $(DECL:E=//)\\\\\\\\n > $(<[1])\\\\n\"\\n    \"echo -e \"#include <z.h>\\\\\\\\n\" > $(<[2])\\\\n\", function=prepare_foo)\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/c.exe')\n    t.touch('a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_touch('bin/$toolset/debug*/b.exe')\n    t.expect_touch('bin/$toolset/debug*/b.obj')\n    t.expect_nothing_more()\n    t.touch('src1/a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/b.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/c.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.touch('b.h')\n    t.run_build_system()\n    t.expect_nothing_more()\n    t.touch('x.foo')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.touch('src1/z.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    t = BoostBuild.Tester(['-d3', '-d+12'], use_test_config=False)\n    t.write('a.cpp', '\\n#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\nint main() {}\\n')\n    t.write('a.h', '\\n')\n    t.write('a_c.c', '#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\n')\n    t.write('b.cpp', '#include \"a.h\"\\nint main() {}\\n')\n    t.write('b.h', '\\n')\n    t.write('c.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('e.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('x.foo', '')\n    t.write('y.foo', '')\n    t.write('src1/a.h', '#include \"b.h\"\\n')\n    t.write('src1/b.h', '#include \"c.h\"\\n')\n    t.write('src1/c.h', '\\n')\n    t.write('src1/z.h', 'extern int dummy_variable_suppressing_empty_file_warning_on_hp_cxx_compiler;\\n')\n    t.write('src2/b.h', '\\n')\n    t.write('jamroot.jam', 'import foo ;\\nimport types/cpp ;\\nimport types/exe ;\\n\\nproject test : requirements <include>src1 ;\\n\\nexe a : x.foo a.cpp a_c.c ;\\nexe b : b.cpp ;\\n\\n# Because of <define>FOO, c.cpp will be compiled to a different directory than\\n# everything for main target \"a\". Therefore, without <implicit-dependency>, C\\n# preprocessor processing that module will not find \"x.h\", which is part of\\n# \"a\"\\'s dependency graph.\\n#\\n# --------------------------\\n# More detailed explanation:\\n# --------------------------\\n#   c.cpp includes x.h which does not exist on the current include path so Boost\\n# Jam will try to match it to existing Jam targets to cover cases as this one\\n# where the file is generated by the same build.\\n#\\n#   However, as x.h is not part of \"c\" metatarget\\'s dependency graph, Boost\\n# Build will not actualize its target by default, i.e. create its Jam target.\\n#\\n#   To get the Jam target created in time, we use the <implicit-dependency>\\n# feature. This tells Boost Build that it needs to actualize the dependency\\n# graph for metatarget \"a\", even though that metatarget has not been directly\\n# mentioned and is not a dependency for any of the metatargets mentioned in the\\n# current build request.\\n#\\n#   Note that Boost Build does not automatically add a dependency between the\\n# Jam targets in question so, if Boost Jam does not add a dependency on a target\\n# from that other dependency graph (x.h in our case), i.e. if c.cpp does not\\n# actually include x.h, us actualizing it will have no effect in the end as\\n# Boost Jam will not have a reason to actually build those targets in spite of\\n# knowing about them.\\nexe c : c.cpp : <define>FOO <implicit-dependency>a ;\\n')\n    t.write('foo.jam', 'import generators ;\\nimport modules ;\\nimport os ;\\nimport print ;\\nimport type ;\\nimport types/cpp ;\\n\\ntype.register FOO : foo ;\\n\\ngenerators.register-standard foo.foo : FOO : CPP H ;\\n\\nnl = \"\\n\" ;\\n\\nrule foo ( targets * : sources * : properties * )\\n{\\n    # On NT, you need an exported symbol in order to have an import library\\n    # generated. We will not really use the symbol defined here, just force the\\n    # import library creation.\\n    if ( [ os.name ] = NT || [ modules.peek : OS ] in CYGWIN ) &&\\n        <main-target-type>LIB in $(properties)\\n    {\\n        .decl = \"void __declspec(dllexport) foo() {}\" ;\\n    }\\n    print.output $(<[1]) ;\\n    print.text $(.decl:E=\"//\")$(nl) ;\\n    print.output $(<[2]) ;\\n    print.text \"#include <z.h>\"$(nl) ;\\n}\\n')\n    t.write('foo.py', 'import bjam\\nimport b2.build.type as type\\nimport b2.build.generators as generators\\n\\nfrom b2.manager import get_manager\\n\\ntype.register(\"FOO\", [\"foo\"])\\ngenerators.register_standard(\"foo.foo\", [\"FOO\"], [\"CPP\", \"H\"])\\n\\ndef prepare_foo(targets, sources, properties):\\n    if properties.get(\\'os\\') in [\\'windows\\', \\'cygwin\\']:\\n        bjam.call(\\'set-target-variable\\', targets, \"DECL\",\\n            \"void __declspec(dllexport) foo() {}\")\\n\\nget_manager().engine().register_action(\"foo.foo\",\\n    \"echo -e $(DECL:E=//)\\\\\\\\n > $(<[1])\\\\n\"\\n    \"echo -e \"#include <z.h>\\\\\\\\n\" > $(<[2])\\\\n\", function=prepare_foo)\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/c.exe')\n    t.touch('a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_touch('bin/$toolset/debug*/b.exe')\n    t.expect_touch('bin/$toolset/debug*/b.obj')\n    t.expect_nothing_more()\n    t.touch('src1/a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/b.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/c.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.touch('b.h')\n    t.run_build_system()\n    t.expect_nothing_more()\n    t.touch('x.foo')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.touch('src1/z.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    t = BoostBuild.Tester(['-d3', '-d+12'], use_test_config=False)\n    t.write('a.cpp', '\\n#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\nint main() {}\\n')\n    t.write('a.h', '\\n')\n    t.write('a_c.c', '#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\n')\n    t.write('b.cpp', '#include \"a.h\"\\nint main() {}\\n')\n    t.write('b.h', '\\n')\n    t.write('c.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('e.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('x.foo', '')\n    t.write('y.foo', '')\n    t.write('src1/a.h', '#include \"b.h\"\\n')\n    t.write('src1/b.h', '#include \"c.h\"\\n')\n    t.write('src1/c.h', '\\n')\n    t.write('src1/z.h', 'extern int dummy_variable_suppressing_empty_file_warning_on_hp_cxx_compiler;\\n')\n    t.write('src2/b.h', '\\n')\n    t.write('jamroot.jam', 'import foo ;\\nimport types/cpp ;\\nimport types/exe ;\\n\\nproject test : requirements <include>src1 ;\\n\\nexe a : x.foo a.cpp a_c.c ;\\nexe b : b.cpp ;\\n\\n# Because of <define>FOO, c.cpp will be compiled to a different directory than\\n# everything for main target \"a\". Therefore, without <implicit-dependency>, C\\n# preprocessor processing that module will not find \"x.h\", which is part of\\n# \"a\"\\'s dependency graph.\\n#\\n# --------------------------\\n# More detailed explanation:\\n# --------------------------\\n#   c.cpp includes x.h which does not exist on the current include path so Boost\\n# Jam will try to match it to existing Jam targets to cover cases as this one\\n# where the file is generated by the same build.\\n#\\n#   However, as x.h is not part of \"c\" metatarget\\'s dependency graph, Boost\\n# Build will not actualize its target by default, i.e. create its Jam target.\\n#\\n#   To get the Jam target created in time, we use the <implicit-dependency>\\n# feature. This tells Boost Build that it needs to actualize the dependency\\n# graph for metatarget \"a\", even though that metatarget has not been directly\\n# mentioned and is not a dependency for any of the metatargets mentioned in the\\n# current build request.\\n#\\n#   Note that Boost Build does not automatically add a dependency between the\\n# Jam targets in question so, if Boost Jam does not add a dependency on a target\\n# from that other dependency graph (x.h in our case), i.e. if c.cpp does not\\n# actually include x.h, us actualizing it will have no effect in the end as\\n# Boost Jam will not have a reason to actually build those targets in spite of\\n# knowing about them.\\nexe c : c.cpp : <define>FOO <implicit-dependency>a ;\\n')\n    t.write('foo.jam', 'import generators ;\\nimport modules ;\\nimport os ;\\nimport print ;\\nimport type ;\\nimport types/cpp ;\\n\\ntype.register FOO : foo ;\\n\\ngenerators.register-standard foo.foo : FOO : CPP H ;\\n\\nnl = \"\\n\" ;\\n\\nrule foo ( targets * : sources * : properties * )\\n{\\n    # On NT, you need an exported symbol in order to have an import library\\n    # generated. We will not really use the symbol defined here, just force the\\n    # import library creation.\\n    if ( [ os.name ] = NT || [ modules.peek : OS ] in CYGWIN ) &&\\n        <main-target-type>LIB in $(properties)\\n    {\\n        .decl = \"void __declspec(dllexport) foo() {}\" ;\\n    }\\n    print.output $(<[1]) ;\\n    print.text $(.decl:E=\"//\")$(nl) ;\\n    print.output $(<[2]) ;\\n    print.text \"#include <z.h>\"$(nl) ;\\n}\\n')\n    t.write('foo.py', 'import bjam\\nimport b2.build.type as type\\nimport b2.build.generators as generators\\n\\nfrom b2.manager import get_manager\\n\\ntype.register(\"FOO\", [\"foo\"])\\ngenerators.register_standard(\"foo.foo\", [\"FOO\"], [\"CPP\", \"H\"])\\n\\ndef prepare_foo(targets, sources, properties):\\n    if properties.get(\\'os\\') in [\\'windows\\', \\'cygwin\\']:\\n        bjam.call(\\'set-target-variable\\', targets, \"DECL\",\\n            \"void __declspec(dllexport) foo() {}\")\\n\\nget_manager().engine().register_action(\"foo.foo\",\\n    \"echo -e $(DECL:E=//)\\\\\\\\n > $(<[1])\\\\n\"\\n    \"echo -e \"#include <z.h>\\\\\\\\n\" > $(<[2])\\\\n\", function=prepare_foo)\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/c.exe')\n    t.touch('a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_touch('bin/$toolset/debug*/b.exe')\n    t.expect_touch('bin/$toolset/debug*/b.obj')\n    t.expect_nothing_more()\n    t.touch('src1/a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/b.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/c.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.touch('b.h')\n    t.run_build_system()\n    t.expect_nothing_more()\n    t.touch('x.foo')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.touch('src1/z.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.cleanup()",
            "def test_basic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    t = BoostBuild.Tester(['-d3', '-d+12'], use_test_config=False)\n    t.write('a.cpp', '\\n#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\nint main() {}\\n')\n    t.write('a.h', '\\n')\n    t.write('a_c.c', '#include <a.h>\\n# include \"a.h\"\\n#include <x.h>\\n')\n    t.write('b.cpp', '#include \"a.h\"\\nint main() {}\\n')\n    t.write('b.h', '\\n')\n    t.write('c.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('e.cpp', '#include \"x.h\"\\nint main() {}\\n')\n    t.write('x.foo', '')\n    t.write('y.foo', '')\n    t.write('src1/a.h', '#include \"b.h\"\\n')\n    t.write('src1/b.h', '#include \"c.h\"\\n')\n    t.write('src1/c.h', '\\n')\n    t.write('src1/z.h', 'extern int dummy_variable_suppressing_empty_file_warning_on_hp_cxx_compiler;\\n')\n    t.write('src2/b.h', '\\n')\n    t.write('jamroot.jam', 'import foo ;\\nimport types/cpp ;\\nimport types/exe ;\\n\\nproject test : requirements <include>src1 ;\\n\\nexe a : x.foo a.cpp a_c.c ;\\nexe b : b.cpp ;\\n\\n# Because of <define>FOO, c.cpp will be compiled to a different directory than\\n# everything for main target \"a\". Therefore, without <implicit-dependency>, C\\n# preprocessor processing that module will not find \"x.h\", which is part of\\n# \"a\"\\'s dependency graph.\\n#\\n# --------------------------\\n# More detailed explanation:\\n# --------------------------\\n#   c.cpp includes x.h which does not exist on the current include path so Boost\\n# Jam will try to match it to existing Jam targets to cover cases as this one\\n# where the file is generated by the same build.\\n#\\n#   However, as x.h is not part of \"c\" metatarget\\'s dependency graph, Boost\\n# Build will not actualize its target by default, i.e. create its Jam target.\\n#\\n#   To get the Jam target created in time, we use the <implicit-dependency>\\n# feature. This tells Boost Build that it needs to actualize the dependency\\n# graph for metatarget \"a\", even though that metatarget has not been directly\\n# mentioned and is not a dependency for any of the metatargets mentioned in the\\n# current build request.\\n#\\n#   Note that Boost Build does not automatically add a dependency between the\\n# Jam targets in question so, if Boost Jam does not add a dependency on a target\\n# from that other dependency graph (x.h in our case), i.e. if c.cpp does not\\n# actually include x.h, us actualizing it will have no effect in the end as\\n# Boost Jam will not have a reason to actually build those targets in spite of\\n# knowing about them.\\nexe c : c.cpp : <define>FOO <implicit-dependency>a ;\\n')\n    t.write('foo.jam', 'import generators ;\\nimport modules ;\\nimport os ;\\nimport print ;\\nimport type ;\\nimport types/cpp ;\\n\\ntype.register FOO : foo ;\\n\\ngenerators.register-standard foo.foo : FOO : CPP H ;\\n\\nnl = \"\\n\" ;\\n\\nrule foo ( targets * : sources * : properties * )\\n{\\n    # On NT, you need an exported symbol in order to have an import library\\n    # generated. We will not really use the symbol defined here, just force the\\n    # import library creation.\\n    if ( [ os.name ] = NT || [ modules.peek : OS ] in CYGWIN ) &&\\n        <main-target-type>LIB in $(properties)\\n    {\\n        .decl = \"void __declspec(dllexport) foo() {}\" ;\\n    }\\n    print.output $(<[1]) ;\\n    print.text $(.decl:E=\"//\")$(nl) ;\\n    print.output $(<[2]) ;\\n    print.text \"#include <z.h>\"$(nl) ;\\n}\\n')\n    t.write('foo.py', 'import bjam\\nimport b2.build.type as type\\nimport b2.build.generators as generators\\n\\nfrom b2.manager import get_manager\\n\\ntype.register(\"FOO\", [\"foo\"])\\ngenerators.register_standard(\"foo.foo\", [\"FOO\"], [\"CPP\", \"H\"])\\n\\ndef prepare_foo(targets, sources, properties):\\n    if properties.get(\\'os\\') in [\\'windows\\', \\'cygwin\\']:\\n        bjam.call(\\'set-target-variable\\', targets, \"DECL\",\\n            \"void __declspec(dllexport) foo() {}\")\\n\\nget_manager().engine().register_action(\"foo.foo\",\\n    \"echo -e $(DECL:E=//)\\\\\\\\n > $(<[1])\\\\n\"\\n    \"echo -e \"#include <z.h>\\\\\\\\n\" > $(<[2])\\\\n\", function=prepare_foo)\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/c.exe')\n    t.touch('a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_touch('bin/$toolset/debug*/b.exe')\n    t.expect_touch('bin/$toolset/debug*/b.obj')\n    t.expect_nothing_more()\n    t.touch('src1/a.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/b.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.expect_nothing_more()\n    t.touch('src1/c.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.exe')\n    t.touch('b.h')\n    t.run_build_system()\n    t.expect_nothing_more()\n    t.touch('x.foo')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.touch('src1/z.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/a.obj')\n    t.expect_touch('bin/$toolset/debug*/a_c.obj')\n    t.cleanup()"
        ]
    },
    {
        "func_name": "test_scanned_includes_with_absolute_paths",
        "original": "def test_scanned_includes_with_absolute_paths():\n    \"\"\"\n      Regression test: on Windows, <includes> with absolute paths were not\n    considered when scanning dependencies.\n\n    \"\"\"\n    t = BoostBuild.Tester(['-d3', '-d+12'])\n    t.write('jamroot.jam', 'path-constant TOP : . ;\\nexe app : main.cpp : <include>$(TOP)/include ;\\n')\n    t.write('main.cpp', '#include <dir/header.h>\\nint main() {}\\n')\n    t.write('include/dir/header.h', '\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/main.obj')\n    t.touch('include/dir/header.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/main.obj')\n    t.cleanup()",
        "mutated": [
            "def test_scanned_includes_with_absolute_paths():\n    if False:\n        i = 10\n    '\\n      Regression test: on Windows, <includes> with absolute paths were not\\n    considered when scanning dependencies.\\n\\n    '\n    t = BoostBuild.Tester(['-d3', '-d+12'])\n    t.write('jamroot.jam', 'path-constant TOP : . ;\\nexe app : main.cpp : <include>$(TOP)/include ;\\n')\n    t.write('main.cpp', '#include <dir/header.h>\\nint main() {}\\n')\n    t.write('include/dir/header.h', '\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/main.obj')\n    t.touch('include/dir/header.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/main.obj')\n    t.cleanup()",
            "def test_scanned_includes_with_absolute_paths():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n      Regression test: on Windows, <includes> with absolute paths were not\\n    considered when scanning dependencies.\\n\\n    '\n    t = BoostBuild.Tester(['-d3', '-d+12'])\n    t.write('jamroot.jam', 'path-constant TOP : . ;\\nexe app : main.cpp : <include>$(TOP)/include ;\\n')\n    t.write('main.cpp', '#include <dir/header.h>\\nint main() {}\\n')\n    t.write('include/dir/header.h', '\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/main.obj')\n    t.touch('include/dir/header.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/main.obj')\n    t.cleanup()",
            "def test_scanned_includes_with_absolute_paths():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n      Regression test: on Windows, <includes> with absolute paths were not\\n    considered when scanning dependencies.\\n\\n    '\n    t = BoostBuild.Tester(['-d3', '-d+12'])\n    t.write('jamroot.jam', 'path-constant TOP : . ;\\nexe app : main.cpp : <include>$(TOP)/include ;\\n')\n    t.write('main.cpp', '#include <dir/header.h>\\nint main() {}\\n')\n    t.write('include/dir/header.h', '\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/main.obj')\n    t.touch('include/dir/header.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/main.obj')\n    t.cleanup()",
            "def test_scanned_includes_with_absolute_paths():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n      Regression test: on Windows, <includes> with absolute paths were not\\n    considered when scanning dependencies.\\n\\n    '\n    t = BoostBuild.Tester(['-d3', '-d+12'])\n    t.write('jamroot.jam', 'path-constant TOP : . ;\\nexe app : main.cpp : <include>$(TOP)/include ;\\n')\n    t.write('main.cpp', '#include <dir/header.h>\\nint main() {}\\n')\n    t.write('include/dir/header.h', '\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/main.obj')\n    t.touch('include/dir/header.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/main.obj')\n    t.cleanup()",
            "def test_scanned_includes_with_absolute_paths():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n      Regression test: on Windows, <includes> with absolute paths were not\\n    considered when scanning dependencies.\\n\\n    '\n    t = BoostBuild.Tester(['-d3', '-d+12'])\n    t.write('jamroot.jam', 'path-constant TOP : . ;\\nexe app : main.cpp : <include>$(TOP)/include ;\\n')\n    t.write('main.cpp', '#include <dir/header.h>\\nint main() {}\\n')\n    t.write('include/dir/header.h', '\\n')\n    t.run_build_system()\n    t.expect_addition('bin/$toolset/debug*/main.obj')\n    t.touch('include/dir/header.h')\n    t.run_build_system()\n    t.expect_touch('bin/$toolset/debug*/main.obj')\n    t.cleanup()"
        ]
    }
]