from __future__ import annotations
from typing import TYPE_CHECKING, Any, Union
from typing_extensions import TypedDict
import github.RepositoryAdvisoryVulnerabilityPackage
from github.GithubObject import Attribute, NonCompletableGithubObject, NotSet
if TYPE_CHECKING:
    from github.RepositoryAdvisoryVulnerabilityPackage import RepositoryAdvisoryVulnerabilityPackage

class SimpleAdvisoryVulnerabilityPackage(TypedDict):
    """
    A simple package in an advisory.
    """
    ecosystem: str
    name: str | None

class SimpleAdvisoryVulnerability(TypedDict):
    """
    A simple vulnerability in a security advisory.
    """
    package: SimpleAdvisoryVulnerabilityPackage
    patched_versions: str | None
    vulnerable_functions: list[str] | None
    vulnerable_version_range: str | None
AdvisoryVulnerability = Union[SimpleAdvisoryVulnerability, 'RepositoryAdvisoryVulnerability']

class RepositoryAdvisoryVulnerability(NonCompletableGithubObject):
    """
    This class represents a package that is vulnerable to a parent SecurityAdvisory.
    The reference can be found here https://docs.github.com/en/rest/security-advisories/repository-advisories
    """

    @property
    def package(self) -> RepositoryAdvisoryVulnerabilityPackage:
        if False:
            while True:
                i = 10
        '\n        :type: :class:`github.RepositoryAdvisoryVulnerability.RepositoryAdvisoryVulnerability`\n        '
        return self._package.value

    @property
    def patched_versions(self) -> str:
        if False:
            while True:
                i = 10
        '\n        :type: string\n        '
        return self._patched_versions.value

    @property
    def vulnerable_functions(self) -> list[str] | None:
        if False:
            while True:
                i = 10
        '\n        :type: list of string\n        '
        return self._vulnerable_functions.value

    @property
    def vulnerable_version_range(self) -> str | None:
        if False:
            return 10
        '\n        :type: string\n        '
        return self._vulnerable_version_range.value

    def _initAttributes(self) -> None:
        if False:
            return 10
        self._package: Attribute[RepositoryAdvisoryVulnerabilityPackage] = NotSet
        self._patched_versions: Attribute[str] = NotSet
        self._vulnerable_functions: Attribute[list[str]] = NotSet
        self._vulnerable_version_range: Attribute[str] = NotSet

    def _useAttributes(self, attributes: dict[str, Any]) -> None:
        if False:
            for i in range(10):
                print('nop')
        if 'package' in attributes:
            self._package = self._makeClassAttribute(github.RepositoryAdvisoryVulnerabilityPackage.RepositoryAdvisoryVulnerabilityPackage, attributes['package'])
        if 'patched_versions' in attributes:
            self._patched_versions = self._makeStringAttribute(attributes['patched_versions'])
        if 'vulnerable_functions' in attributes:
            self._vulnerable_functions = self._makeListOfStringsAttribute(attributes['vulnerable_functions'])
        if 'vulnerable_version_range' in attributes:
            self._vulnerable_version_range = self._makeStringAttribute(attributes['vulnerable_version_range'])

    @classmethod
    def _validate_vulnerability(cls, vulnerability: AdvisoryVulnerability) -> None:
        if False:
            i = 10
            return i + 15
        assert isinstance(vulnerability, (dict, cls)), vulnerability
        if isinstance(vulnerability, dict):
            assert 'package' in vulnerability, vulnerability
            package: SimpleAdvisoryVulnerabilityPackage = vulnerability['package']
            assert isinstance(package, dict), package
            assert 'ecosystem' in package, package
            assert isinstance(package['ecosystem'], str), package
            assert 'name' in package, package
            assert isinstance(package['name'], (str, type(None))), package
            assert 'patched_versions' in vulnerability, vulnerability
            assert isinstance(vulnerability['patched_versions'], (str, type(None))), vulnerability
            assert 'vulnerable_functions' in vulnerability, vulnerability
            assert isinstance(vulnerability['vulnerable_functions'], (list, type(None))), vulnerability
            assert 'vulnerable_functions' in vulnerability, vulnerability
            assert all((isinstance(vf, str) for vf in vulnerability['vulnerable_functions'])) if vulnerability['vulnerable_functions'] is not None else True, vulnerability
            assert 'vulnerable_version_range' in vulnerability, vulnerability
            assert isinstance(vulnerability['vulnerable_version_range'], (str, type(None))), vulnerability
        else:
            assert vulnerability.package is github.RepositoryAdvisoryVulnerabilityPackage.RepositoryAdvisoryVulnerabilityPackage, vulnerability

    @staticmethod
    def _to_github_dict(vulnerability: AdvisoryVulnerability) -> SimpleAdvisoryVulnerability:
        if False:
            while True:
                i = 10
        if isinstance(vulnerability, dict):
            vulnerability_package: SimpleAdvisoryVulnerabilityPackage = vulnerability['package']
            return {'package': {'ecosystem': vulnerability_package['ecosystem'], 'name': vulnerability_package['name']}, 'patched_versions': vulnerability['patched_versions'], 'vulnerable_functions': vulnerability['vulnerable_functions'], 'vulnerable_version_range': vulnerability['vulnerable_version_range']}
        return {'package': {'ecosystem': vulnerability.package.ecosystem, 'name': vulnerability.package.name}, 'patched_versions': vulnerability.patched_versions, 'vulnerable_functions': vulnerability.vulnerable_functions, 'vulnerable_version_range': vulnerability.vulnerable_version_range}