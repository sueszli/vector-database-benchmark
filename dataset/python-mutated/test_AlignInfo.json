[
    {
        "func_name": "assertAlmostEqualList",
        "original": "def assertAlmostEqualList(self, list1, list2, **kwargs):\n    self.assertEqual(len(list1), len(list2))\n    for (v1, v2) in zip(list1, list2):\n        self.assertAlmostEqual(v1, v2, **kwargs)",
        "mutated": [
            "def assertAlmostEqualList(self, list1, list2, **kwargs):\n    if False:\n        i = 10\n    self.assertEqual(len(list1), len(list2))\n    for (v1, v2) in zip(list1, list2):\n        self.assertAlmostEqual(v1, v2, **kwargs)",
            "def assertAlmostEqualList(self, list1, list2, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.assertEqual(len(list1), len(list2))\n    for (v1, v2) in zip(list1, list2):\n        self.assertAlmostEqual(v1, v2, **kwargs)",
            "def assertAlmostEqualList(self, list1, list2, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.assertEqual(len(list1), len(list2))\n    for (v1, v2) in zip(list1, list2):\n        self.assertAlmostEqual(v1, v2, **kwargs)",
            "def assertAlmostEqualList(self, list1, list2, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.assertEqual(len(list1), len(list2))\n    for (v1, v2) in zip(list1, list2):\n        self.assertAlmostEqual(v1, v2, **kwargs)",
            "def assertAlmostEqualList(self, list1, list2, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.assertEqual(len(list1), len(list2))\n    for (v1, v2) in zip(list1, list2):\n        self.assertAlmostEqual(v1, v2, **kwargs)"
        ]
    },
    {
        "func_name": "test_nucleotides",
        "original": "def test_nucleotides(self):\n    filename = 'GFF/multi.fna'\n    fmt = 'fasta'\n    alignment = AlignIO.read(filename, fmt)\n    summary = SummaryInfo(alignment)\n    c = summary.dumb_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    c = summary.gap_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    expected = {'A': 0.25, 'G': 0.25, 'T': 0.25, 'C': 0.25}\n    m = summary.pos_specific_score_matrix(chars_to_ignore=['-'], axis_seq=c)\n    self.assertEqual(str(m), '    A   C   G   T\\nN  2.0 0.0 1.0 0.0\\nN  1.0 1.0 1.0 0.0\\nN  1.0 0.0 2.0 0.0\\nN  0.0 1.0 1.0 1.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\n')\n    ic = summary.information_content(e_freq_table=expected, chars_to_ignore=['-'])\n    self.assertAlmostEqual(ic, 7.32029999423075, places=6)",
        "mutated": [
            "def test_nucleotides(self):\n    if False:\n        i = 10\n    filename = 'GFF/multi.fna'\n    fmt = 'fasta'\n    alignment = AlignIO.read(filename, fmt)\n    summary = SummaryInfo(alignment)\n    c = summary.dumb_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    c = summary.gap_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    expected = {'A': 0.25, 'G': 0.25, 'T': 0.25, 'C': 0.25}\n    m = summary.pos_specific_score_matrix(chars_to_ignore=['-'], axis_seq=c)\n    self.assertEqual(str(m), '    A   C   G   T\\nN  2.0 0.0 1.0 0.0\\nN  1.0 1.0 1.0 0.0\\nN  1.0 0.0 2.0 0.0\\nN  0.0 1.0 1.0 1.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\n')\n    ic = summary.information_content(e_freq_table=expected, chars_to_ignore=['-'])\n    self.assertAlmostEqual(ic, 7.32029999423075, places=6)",
            "def test_nucleotides(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    filename = 'GFF/multi.fna'\n    fmt = 'fasta'\n    alignment = AlignIO.read(filename, fmt)\n    summary = SummaryInfo(alignment)\n    c = summary.dumb_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    c = summary.gap_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    expected = {'A': 0.25, 'G': 0.25, 'T': 0.25, 'C': 0.25}\n    m = summary.pos_specific_score_matrix(chars_to_ignore=['-'], axis_seq=c)\n    self.assertEqual(str(m), '    A   C   G   T\\nN  2.0 0.0 1.0 0.0\\nN  1.0 1.0 1.0 0.0\\nN  1.0 0.0 2.0 0.0\\nN  0.0 1.0 1.0 1.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\n')\n    ic = summary.information_content(e_freq_table=expected, chars_to_ignore=['-'])\n    self.assertAlmostEqual(ic, 7.32029999423075, places=6)",
            "def test_nucleotides(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    filename = 'GFF/multi.fna'\n    fmt = 'fasta'\n    alignment = AlignIO.read(filename, fmt)\n    summary = SummaryInfo(alignment)\n    c = summary.dumb_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    c = summary.gap_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    expected = {'A': 0.25, 'G': 0.25, 'T': 0.25, 'C': 0.25}\n    m = summary.pos_specific_score_matrix(chars_to_ignore=['-'], axis_seq=c)\n    self.assertEqual(str(m), '    A   C   G   T\\nN  2.0 0.0 1.0 0.0\\nN  1.0 1.0 1.0 0.0\\nN  1.0 0.0 2.0 0.0\\nN  0.0 1.0 1.0 1.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\n')\n    ic = summary.information_content(e_freq_table=expected, chars_to_ignore=['-'])\n    self.assertAlmostEqual(ic, 7.32029999423075, places=6)",
            "def test_nucleotides(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    filename = 'GFF/multi.fna'\n    fmt = 'fasta'\n    alignment = AlignIO.read(filename, fmt)\n    summary = SummaryInfo(alignment)\n    c = summary.dumb_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    c = summary.gap_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    expected = {'A': 0.25, 'G': 0.25, 'T': 0.25, 'C': 0.25}\n    m = summary.pos_specific_score_matrix(chars_to_ignore=['-'], axis_seq=c)\n    self.assertEqual(str(m), '    A   C   G   T\\nN  2.0 0.0 1.0 0.0\\nN  1.0 1.0 1.0 0.0\\nN  1.0 0.0 2.0 0.0\\nN  0.0 1.0 1.0 1.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\n')\n    ic = summary.information_content(e_freq_table=expected, chars_to_ignore=['-'])\n    self.assertAlmostEqual(ic, 7.32029999423075, places=6)",
            "def test_nucleotides(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    filename = 'GFF/multi.fna'\n    fmt = 'fasta'\n    alignment = AlignIO.read(filename, fmt)\n    summary = SummaryInfo(alignment)\n    c = summary.dumb_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    c = summary.gap_consensus(ambiguous='N')\n    self.assertEqual(c, 'NNNNNNNN')\n    expected = {'A': 0.25, 'G': 0.25, 'T': 0.25, 'C': 0.25}\n    m = summary.pos_specific_score_matrix(chars_to_ignore=['-'], axis_seq=c)\n    self.assertEqual(str(m), '    A   C   G   T\\nN  2.0 0.0 1.0 0.0\\nN  1.0 1.0 1.0 0.0\\nN  1.0 0.0 2.0 0.0\\nN  0.0 1.0 1.0 1.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\nN  1.0 2.0 0.0 0.0\\nN  0.0 2.0 1.0 0.0\\n')\n    ic = summary.information_content(e_freq_table=expected, chars_to_ignore=['-'])\n    self.assertAlmostEqual(ic, 7.32029999423075, places=6)"
        ]
    },
    {
        "func_name": "test_proteins",
        "original": "def test_proteins(self):\n    a = MultipleSeqAlignment([SeqRecord(Seq('MHQAIFIYQIGYP*LKSGYIQSIRSPEYDNW-'), id='ID001'), SeqRecord(Seq('MH--IFIYQIGYAYLKSGYIQSIRSPEY-NW*'), id='ID002'), SeqRecord(Seq('MHQAIFIYQIGYPYLKSGYIQSIRSPEYDNW*'), id='ID003')])\n    self.assertEqual(32, a.get_alignment_length())\n    s = SummaryInfo(a)\n    c = s.dumb_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHQAIFIYQIGYXXLKSGYIQSIRSPEYDNW*')\n    c = s.gap_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHXXIFIYQIGYXXLKSGYIQSIRSPEYXNWX')\n    m = s.pos_specific_score_matrix(chars_to_ignore=['-', '*'], axis_seq=c)\n    self.assertEqual(str(m), '    A   D   E   F   G   H   I   K   L   M   N   P   Q   R   S   W   Y\\nM  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nH  0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0\\nX  2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nF  0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0\\nL  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nK  0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nR  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nP  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0\\nE  0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  0.0 2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nN  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0\\nW  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\n')\n    letters = IUPACData.protein_letters\n    base_freq = 1.0 / len(letters)\n    e_freq_table = {letter: base_freq for letter in letters}\n    ic = s.information_content(e_freq_table=e_freq_table, chars_to_ignore=['-', '*'])\n    self.assertAlmostEqual(ic, 133.061475107, places=6)",
        "mutated": [
            "def test_proteins(self):\n    if False:\n        i = 10\n    a = MultipleSeqAlignment([SeqRecord(Seq('MHQAIFIYQIGYP*LKSGYIQSIRSPEYDNW-'), id='ID001'), SeqRecord(Seq('MH--IFIYQIGYAYLKSGYIQSIRSPEY-NW*'), id='ID002'), SeqRecord(Seq('MHQAIFIYQIGYPYLKSGYIQSIRSPEYDNW*'), id='ID003')])\n    self.assertEqual(32, a.get_alignment_length())\n    s = SummaryInfo(a)\n    c = s.dumb_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHQAIFIYQIGYXXLKSGYIQSIRSPEYDNW*')\n    c = s.gap_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHXXIFIYQIGYXXLKSGYIQSIRSPEYXNWX')\n    m = s.pos_specific_score_matrix(chars_to_ignore=['-', '*'], axis_seq=c)\n    self.assertEqual(str(m), '    A   D   E   F   G   H   I   K   L   M   N   P   Q   R   S   W   Y\\nM  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nH  0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0\\nX  2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nF  0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0\\nL  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nK  0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nR  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nP  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0\\nE  0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  0.0 2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nN  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0\\nW  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\n')\n    letters = IUPACData.protein_letters\n    base_freq = 1.0 / len(letters)\n    e_freq_table = {letter: base_freq for letter in letters}\n    ic = s.information_content(e_freq_table=e_freq_table, chars_to_ignore=['-', '*'])\n    self.assertAlmostEqual(ic, 133.061475107, places=6)",
            "def test_proteins(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = MultipleSeqAlignment([SeqRecord(Seq('MHQAIFIYQIGYP*LKSGYIQSIRSPEYDNW-'), id='ID001'), SeqRecord(Seq('MH--IFIYQIGYAYLKSGYIQSIRSPEY-NW*'), id='ID002'), SeqRecord(Seq('MHQAIFIYQIGYPYLKSGYIQSIRSPEYDNW*'), id='ID003')])\n    self.assertEqual(32, a.get_alignment_length())\n    s = SummaryInfo(a)\n    c = s.dumb_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHQAIFIYQIGYXXLKSGYIQSIRSPEYDNW*')\n    c = s.gap_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHXXIFIYQIGYXXLKSGYIQSIRSPEYXNWX')\n    m = s.pos_specific_score_matrix(chars_to_ignore=['-', '*'], axis_seq=c)\n    self.assertEqual(str(m), '    A   D   E   F   G   H   I   K   L   M   N   P   Q   R   S   W   Y\\nM  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nH  0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0\\nX  2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nF  0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0\\nL  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nK  0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nR  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nP  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0\\nE  0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  0.0 2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nN  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0\\nW  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\n')\n    letters = IUPACData.protein_letters\n    base_freq = 1.0 / len(letters)\n    e_freq_table = {letter: base_freq for letter in letters}\n    ic = s.information_content(e_freq_table=e_freq_table, chars_to_ignore=['-', '*'])\n    self.assertAlmostEqual(ic, 133.061475107, places=6)",
            "def test_proteins(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = MultipleSeqAlignment([SeqRecord(Seq('MHQAIFIYQIGYP*LKSGYIQSIRSPEYDNW-'), id='ID001'), SeqRecord(Seq('MH--IFIYQIGYAYLKSGYIQSIRSPEY-NW*'), id='ID002'), SeqRecord(Seq('MHQAIFIYQIGYPYLKSGYIQSIRSPEYDNW*'), id='ID003')])\n    self.assertEqual(32, a.get_alignment_length())\n    s = SummaryInfo(a)\n    c = s.dumb_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHQAIFIYQIGYXXLKSGYIQSIRSPEYDNW*')\n    c = s.gap_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHXXIFIYQIGYXXLKSGYIQSIRSPEYXNWX')\n    m = s.pos_specific_score_matrix(chars_to_ignore=['-', '*'], axis_seq=c)\n    self.assertEqual(str(m), '    A   D   E   F   G   H   I   K   L   M   N   P   Q   R   S   W   Y\\nM  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nH  0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0\\nX  2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nF  0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0\\nL  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nK  0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nR  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nP  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0\\nE  0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  0.0 2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nN  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0\\nW  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\n')\n    letters = IUPACData.protein_letters\n    base_freq = 1.0 / len(letters)\n    e_freq_table = {letter: base_freq for letter in letters}\n    ic = s.information_content(e_freq_table=e_freq_table, chars_to_ignore=['-', '*'])\n    self.assertAlmostEqual(ic, 133.061475107, places=6)",
            "def test_proteins(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = MultipleSeqAlignment([SeqRecord(Seq('MHQAIFIYQIGYP*LKSGYIQSIRSPEYDNW-'), id='ID001'), SeqRecord(Seq('MH--IFIYQIGYAYLKSGYIQSIRSPEY-NW*'), id='ID002'), SeqRecord(Seq('MHQAIFIYQIGYPYLKSGYIQSIRSPEYDNW*'), id='ID003')])\n    self.assertEqual(32, a.get_alignment_length())\n    s = SummaryInfo(a)\n    c = s.dumb_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHQAIFIYQIGYXXLKSGYIQSIRSPEYDNW*')\n    c = s.gap_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHXXIFIYQIGYXXLKSGYIQSIRSPEYXNWX')\n    m = s.pos_specific_score_matrix(chars_to_ignore=['-', '*'], axis_seq=c)\n    self.assertEqual(str(m), '    A   D   E   F   G   H   I   K   L   M   N   P   Q   R   S   W   Y\\nM  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nH  0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0\\nX  2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nF  0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0\\nL  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nK  0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nR  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nP  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0\\nE  0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  0.0 2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nN  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0\\nW  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\n')\n    letters = IUPACData.protein_letters\n    base_freq = 1.0 / len(letters)\n    e_freq_table = {letter: base_freq for letter in letters}\n    ic = s.information_content(e_freq_table=e_freq_table, chars_to_ignore=['-', '*'])\n    self.assertAlmostEqual(ic, 133.061475107, places=6)",
            "def test_proteins(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = MultipleSeqAlignment([SeqRecord(Seq('MHQAIFIYQIGYP*LKSGYIQSIRSPEYDNW-'), id='ID001'), SeqRecord(Seq('MH--IFIYQIGYAYLKSGYIQSIRSPEY-NW*'), id='ID002'), SeqRecord(Seq('MHQAIFIYQIGYPYLKSGYIQSIRSPEYDNW*'), id='ID003')])\n    self.assertEqual(32, a.get_alignment_length())\n    s = SummaryInfo(a)\n    c = s.dumb_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHQAIFIYQIGYXXLKSGYIQSIRSPEYDNW*')\n    c = s.gap_consensus(ambiguous='X')\n    self.assertEqual(c, 'MHXXIFIYQIGYXXLKSGYIQSIRSPEYXNWX')\n    m = s.pos_specific_score_matrix(chars_to_ignore=['-', '*'], axis_seq=c)\n    self.assertEqual(str(m), '    A   D   E   F   G   H   I   K   L   M   N   P   Q   R   S   W   Y\\nM  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nH  0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0\\nX  2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nF  0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 0.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0\\nL  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nK  0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nG  0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nQ  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nI  0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nR  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0\\nS  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0\\nP  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0\\nE  0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nY  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0\\nX  0.0 2.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\nN  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0\\nW  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 3.0 0.0\\nX  0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\\n')\n    letters = IUPACData.protein_letters\n    base_freq = 1.0 / len(letters)\n    e_freq_table = {letter: base_freq for letter in letters}\n    ic = s.information_content(e_freq_table=e_freq_table, chars_to_ignore=['-', '*'])\n    self.assertAlmostEqual(ic, 133.061475107, places=6)"
        ]
    },
    {
        "func_name": "test_pseudo_count",
        "original": "def test_pseudo_count(self):\n    dna_align = MultipleSeqAlignment([SeqRecord(Seq('AACCACGTTTAA'), id='ID001'), SeqRecord(Seq('CACCACGTGGGT'), id='ID002'), SeqRecord(Seq('CACCACGTTCGC'), id='ID003'), SeqRecord(Seq('GCGCACGTGGGG'), id='ID004'), SeqRecord(Seq('TCGCACGTTGTG'), id='ID005'), SeqRecord(Seq('TGGCACGTGTTT'), id='ID006'), SeqRecord(Seq('TGACACGTGGGA'), id='ID007'), SeqRecord(Seq('TTACACGTGCGC'), id='ID008')])\n    summary = SummaryInfo(dna_align)\n    expected = {'A': 0.325, 'G': 0.175, 'T': 0.325, 'C': 0.175}\n    ic = summary.information_content(e_freq_table=expected, log_base=math.exp(1), pseudo_count=1)\n    self.assertAlmostEqualList(summary.ic_vector, [0.11, 0.09, 0.36, 1.29, 0.8, 1.29, 1.29, 0.8, 0.61, 0.39, 0.47, 0.04], places=2)\n    self.assertAlmostEqual(ic, 7.546, places=3)",
        "mutated": [
            "def test_pseudo_count(self):\n    if False:\n        i = 10\n    dna_align = MultipleSeqAlignment([SeqRecord(Seq('AACCACGTTTAA'), id='ID001'), SeqRecord(Seq('CACCACGTGGGT'), id='ID002'), SeqRecord(Seq('CACCACGTTCGC'), id='ID003'), SeqRecord(Seq('GCGCACGTGGGG'), id='ID004'), SeqRecord(Seq('TCGCACGTTGTG'), id='ID005'), SeqRecord(Seq('TGGCACGTGTTT'), id='ID006'), SeqRecord(Seq('TGACACGTGGGA'), id='ID007'), SeqRecord(Seq('TTACACGTGCGC'), id='ID008')])\n    summary = SummaryInfo(dna_align)\n    expected = {'A': 0.325, 'G': 0.175, 'T': 0.325, 'C': 0.175}\n    ic = summary.information_content(e_freq_table=expected, log_base=math.exp(1), pseudo_count=1)\n    self.assertAlmostEqualList(summary.ic_vector, [0.11, 0.09, 0.36, 1.29, 0.8, 1.29, 1.29, 0.8, 0.61, 0.39, 0.47, 0.04], places=2)\n    self.assertAlmostEqual(ic, 7.546, places=3)",
            "def test_pseudo_count(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    dna_align = MultipleSeqAlignment([SeqRecord(Seq('AACCACGTTTAA'), id='ID001'), SeqRecord(Seq('CACCACGTGGGT'), id='ID002'), SeqRecord(Seq('CACCACGTTCGC'), id='ID003'), SeqRecord(Seq('GCGCACGTGGGG'), id='ID004'), SeqRecord(Seq('TCGCACGTTGTG'), id='ID005'), SeqRecord(Seq('TGGCACGTGTTT'), id='ID006'), SeqRecord(Seq('TGACACGTGGGA'), id='ID007'), SeqRecord(Seq('TTACACGTGCGC'), id='ID008')])\n    summary = SummaryInfo(dna_align)\n    expected = {'A': 0.325, 'G': 0.175, 'T': 0.325, 'C': 0.175}\n    ic = summary.information_content(e_freq_table=expected, log_base=math.exp(1), pseudo_count=1)\n    self.assertAlmostEqualList(summary.ic_vector, [0.11, 0.09, 0.36, 1.29, 0.8, 1.29, 1.29, 0.8, 0.61, 0.39, 0.47, 0.04], places=2)\n    self.assertAlmostEqual(ic, 7.546, places=3)",
            "def test_pseudo_count(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    dna_align = MultipleSeqAlignment([SeqRecord(Seq('AACCACGTTTAA'), id='ID001'), SeqRecord(Seq('CACCACGTGGGT'), id='ID002'), SeqRecord(Seq('CACCACGTTCGC'), id='ID003'), SeqRecord(Seq('GCGCACGTGGGG'), id='ID004'), SeqRecord(Seq('TCGCACGTTGTG'), id='ID005'), SeqRecord(Seq('TGGCACGTGTTT'), id='ID006'), SeqRecord(Seq('TGACACGTGGGA'), id='ID007'), SeqRecord(Seq('TTACACGTGCGC'), id='ID008')])\n    summary = SummaryInfo(dna_align)\n    expected = {'A': 0.325, 'G': 0.175, 'T': 0.325, 'C': 0.175}\n    ic = summary.information_content(e_freq_table=expected, log_base=math.exp(1), pseudo_count=1)\n    self.assertAlmostEqualList(summary.ic_vector, [0.11, 0.09, 0.36, 1.29, 0.8, 1.29, 1.29, 0.8, 0.61, 0.39, 0.47, 0.04], places=2)\n    self.assertAlmostEqual(ic, 7.546, places=3)",
            "def test_pseudo_count(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    dna_align = MultipleSeqAlignment([SeqRecord(Seq('AACCACGTTTAA'), id='ID001'), SeqRecord(Seq('CACCACGTGGGT'), id='ID002'), SeqRecord(Seq('CACCACGTTCGC'), id='ID003'), SeqRecord(Seq('GCGCACGTGGGG'), id='ID004'), SeqRecord(Seq('TCGCACGTTGTG'), id='ID005'), SeqRecord(Seq('TGGCACGTGTTT'), id='ID006'), SeqRecord(Seq('TGACACGTGGGA'), id='ID007'), SeqRecord(Seq('TTACACGTGCGC'), id='ID008')])\n    summary = SummaryInfo(dna_align)\n    expected = {'A': 0.325, 'G': 0.175, 'T': 0.325, 'C': 0.175}\n    ic = summary.information_content(e_freq_table=expected, log_base=math.exp(1), pseudo_count=1)\n    self.assertAlmostEqualList(summary.ic_vector, [0.11, 0.09, 0.36, 1.29, 0.8, 1.29, 1.29, 0.8, 0.61, 0.39, 0.47, 0.04], places=2)\n    self.assertAlmostEqual(ic, 7.546, places=3)",
            "def test_pseudo_count(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    dna_align = MultipleSeqAlignment([SeqRecord(Seq('AACCACGTTTAA'), id='ID001'), SeqRecord(Seq('CACCACGTGGGT'), id='ID002'), SeqRecord(Seq('CACCACGTTCGC'), id='ID003'), SeqRecord(Seq('GCGCACGTGGGG'), id='ID004'), SeqRecord(Seq('TCGCACGTTGTG'), id='ID005'), SeqRecord(Seq('TGGCACGTGTTT'), id='ID006'), SeqRecord(Seq('TGACACGTGGGA'), id='ID007'), SeqRecord(Seq('TTACACGTGCGC'), id='ID008')])\n    summary = SummaryInfo(dna_align)\n    expected = {'A': 0.325, 'G': 0.175, 'T': 0.325, 'C': 0.175}\n    ic = summary.information_content(e_freq_table=expected, log_base=math.exp(1), pseudo_count=1)\n    self.assertAlmostEqualList(summary.ic_vector, [0.11, 0.09, 0.36, 1.29, 0.8, 1.29, 1.29, 0.8, 0.61, 0.39, 0.47, 0.04], places=2)\n    self.assertAlmostEqual(ic, 7.546, places=3)"
        ]
    }
]