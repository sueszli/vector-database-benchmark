[
    {
        "func_name": "backtrack",
        "original": "def backtrack(board, i, j, trie, pre, used, result):\n    \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n    if '#' in trie:\n        result.add(pre)\n    if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n        return\n    if not used[i][j] and board[i][j] in trie:\n        used[i][j] = True\n        backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n        used[i][j] = False",
        "mutated": [
            "def backtrack(board, i, j, trie, pre, used, result):\n    if False:\n        i = 10\n    '\\n        backtrack tries to build each words from\\n        the board and return all words found\\n\\n        @param: board, the passed in board of characters\\n        @param: i, the row index\\n        @param: j, the column index\\n        @param: trie, a trie of the passed in words\\n        @param: pre, a buffer of currently build string that differs\\n                by recursion stack\\n        @param: used, a replica of the board except in booleans\\n                to state whether a character has been used\\n        @param: result, the resulting set that contains all words found\\n\\n        @return: list of words found\\n        '\n    if '#' in trie:\n        result.add(pre)\n    if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n        return\n    if not used[i][j] and board[i][j] in trie:\n        used[i][j] = True\n        backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n        used[i][j] = False",
            "def backtrack(board, i, j, trie, pre, used, result):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        backtrack tries to build each words from\\n        the board and return all words found\\n\\n        @param: board, the passed in board of characters\\n        @param: i, the row index\\n        @param: j, the column index\\n        @param: trie, a trie of the passed in words\\n        @param: pre, a buffer of currently build string that differs\\n                by recursion stack\\n        @param: used, a replica of the board except in booleans\\n                to state whether a character has been used\\n        @param: result, the resulting set that contains all words found\\n\\n        @return: list of words found\\n        '\n    if '#' in trie:\n        result.add(pre)\n    if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n        return\n    if not used[i][j] and board[i][j] in trie:\n        used[i][j] = True\n        backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n        used[i][j] = False",
            "def backtrack(board, i, j, trie, pre, used, result):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        backtrack tries to build each words from\\n        the board and return all words found\\n\\n        @param: board, the passed in board of characters\\n        @param: i, the row index\\n        @param: j, the column index\\n        @param: trie, a trie of the passed in words\\n        @param: pre, a buffer of currently build string that differs\\n                by recursion stack\\n        @param: used, a replica of the board except in booleans\\n                to state whether a character has been used\\n        @param: result, the resulting set that contains all words found\\n\\n        @return: list of words found\\n        '\n    if '#' in trie:\n        result.add(pre)\n    if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n        return\n    if not used[i][j] and board[i][j] in trie:\n        used[i][j] = True\n        backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n        used[i][j] = False",
            "def backtrack(board, i, j, trie, pre, used, result):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        backtrack tries to build each words from\\n        the board and return all words found\\n\\n        @param: board, the passed in board of characters\\n        @param: i, the row index\\n        @param: j, the column index\\n        @param: trie, a trie of the passed in words\\n        @param: pre, a buffer of currently build string that differs\\n                by recursion stack\\n        @param: used, a replica of the board except in booleans\\n                to state whether a character has been used\\n        @param: result, the resulting set that contains all words found\\n\\n        @return: list of words found\\n        '\n    if '#' in trie:\n        result.add(pre)\n    if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n        return\n    if not used[i][j] and board[i][j] in trie:\n        used[i][j] = True\n        backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n        used[i][j] = False",
            "def backtrack(board, i, j, trie, pre, used, result):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        backtrack tries to build each words from\\n        the board and return all words found\\n\\n        @param: board, the passed in board of characters\\n        @param: i, the row index\\n        @param: j, the column index\\n        @param: trie, a trie of the passed in words\\n        @param: pre, a buffer of currently build string that differs\\n                by recursion stack\\n        @param: used, a replica of the board except in booleans\\n                to state whether a character has been used\\n        @param: result, the resulting set that contains all words found\\n\\n        @return: list of words found\\n        '\n    if '#' in trie:\n        result.add(pre)\n    if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n        return\n    if not used[i][j] and board[i][j] in trie:\n        used[i][j] = True\n        backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n        used[i][j] = False"
        ]
    },
    {
        "func_name": "find_words",
        "original": "def find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)",
        "mutated": [
            "def find_words(board, words):\n    if False:\n        i = 10\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)",
            "def find_words(board, words):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)",
            "def find_words(board, words):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)",
            "def find_words(board, words):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)",
            "def find_words(board, words):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        \"\"\"\n        backtrack tries to build each words from\n        the board and return all words found\n\n        @param: board, the passed in board of characters\n        @param: i, the row index\n        @param: j, the column index\n        @param: trie, a trie of the passed in words\n        @param: pre, a buffer of currently build string that differs\n                by recursion stack\n        @param: used, a replica of the board except in booleans\n                to state whether a character has been used\n        @param: result, the resulting set that contains all words found\n\n        @return: list of words found\n        \"\"\"\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)"
        ]
    }
]