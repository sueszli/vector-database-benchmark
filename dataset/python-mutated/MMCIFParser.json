[
    {
        "func_name": "__init__",
        "original": "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    \"\"\"Create a PDBParser object.\n\n        The mmCIF parser calls a number of standard methods in an aggregated\n        StructureBuilder object. Normally this object is instantiated by the\n        MMCIParser object itself, but if the user provides his/her own\n        StructureBuilder object, the latter is used instead.\n\n        Arguments:\n         - structure_builder - an optional user implemented StructureBuilder class.\n         - auth_chains - True by default. If true, use the author chain IDs.\n           If false, use the re-assigned mmCIF chain IDs.\n         - auth_residues - True by default. If true, use the author residue numbering.\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\n           codes, and strictly increments residue numbers.\n           NOTE: Non-polymers such as water don't have a \"label\" residue number,\n           and will be skipped.\n\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\n           These warnings might be indicative of problems in the mmCIF file!\n\n        \"\"\"\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.header = None\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
        "mutated": [
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n    'Create a PDBParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        MMCIParser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.header = None\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create a PDBParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        MMCIParser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.header = None\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create a PDBParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        MMCIParser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.header = None\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create a PDBParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        MMCIParser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.header = None\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create a PDBParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        MMCIParser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.header = None\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)"
        ]
    },
    {
        "func_name": "get_structure",
        "original": "def get_structure(self, structure_id, filename):\n    \"\"\"Return the structure.\n\n        Arguments:\n         - structure_id - string, the id that will be used for the structure\n         - filename - name of mmCIF file, OR an open text mode file handle\n\n        \"\"\"\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        self._mmcif_dict = MMCIF2Dict(filename)\n        self._build_structure(structure_id)\n        self._structure_builder.set_header(self._get_header())\n    return self._structure_builder.get_structure()",
        "mutated": [
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of mmCIF file, OR an open text mode file handle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        self._mmcif_dict = MMCIF2Dict(filename)\n        self._build_structure(structure_id)\n        self._structure_builder.set_header(self._get_header())\n    return self._structure_builder.get_structure()",
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of mmCIF file, OR an open text mode file handle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        self._mmcif_dict = MMCIF2Dict(filename)\n        self._build_structure(structure_id)\n        self._structure_builder.set_header(self._get_header())\n    return self._structure_builder.get_structure()",
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of mmCIF file, OR an open text mode file handle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        self._mmcif_dict = MMCIF2Dict(filename)\n        self._build_structure(structure_id)\n        self._structure_builder.set_header(self._get_header())\n    return self._structure_builder.get_structure()",
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of mmCIF file, OR an open text mode file handle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        self._mmcif_dict = MMCIF2Dict(filename)\n        self._build_structure(structure_id)\n        self._structure_builder.set_header(self._get_header())\n    return self._structure_builder.get_structure()",
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of mmCIF file, OR an open text mode file handle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        self._mmcif_dict = MMCIF2Dict(filename)\n        self._build_structure(structure_id)\n        self._structure_builder.set_header(self._get_header())\n    return self._structure_builder.get_structure()"
        ]
    },
    {
        "func_name": "_mmcif_get",
        "original": "def _mmcif_get(self, key, dict, deflt):\n    if key in dict:\n        rslt = dict[key][0]\n        if '?' != rslt:\n            return rslt\n    return deflt",
        "mutated": [
            "def _mmcif_get(self, key, dict, deflt):\n    if False:\n        i = 10\n    if key in dict:\n        rslt = dict[key][0]\n        if '?' != rslt:\n            return rslt\n    return deflt",
            "def _mmcif_get(self, key, dict, deflt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if key in dict:\n        rslt = dict[key][0]\n        if '?' != rslt:\n            return rslt\n    return deflt",
            "def _mmcif_get(self, key, dict, deflt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if key in dict:\n        rslt = dict[key][0]\n        if '?' != rslt:\n            return rslt\n    return deflt",
            "def _mmcif_get(self, key, dict, deflt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if key in dict:\n        rslt = dict[key][0]\n        if '?' != rslt:\n            return rslt\n    return deflt",
            "def _mmcif_get(self, key, dict, deflt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if key in dict:\n        rslt = dict[key][0]\n        if '?' != rslt:\n            return rslt\n    return deflt"
        ]
    },
    {
        "func_name": "_update_header_entry",
        "original": "def _update_header_entry(self, target_key, keys):\n    md = self._mmcif_dict\n    for key in keys:\n        val = md.get(key)\n        try:\n            item = val[0]\n        except (TypeError, IndexError):\n            continue\n        if item != '?' and item != '.':\n            self.header[target_key] = item\n            break",
        "mutated": [
            "def _update_header_entry(self, target_key, keys):\n    if False:\n        i = 10\n    md = self._mmcif_dict\n    for key in keys:\n        val = md.get(key)\n        try:\n            item = val[0]\n        except (TypeError, IndexError):\n            continue\n        if item != '?' and item != '.':\n            self.header[target_key] = item\n            break",
            "def _update_header_entry(self, target_key, keys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    md = self._mmcif_dict\n    for key in keys:\n        val = md.get(key)\n        try:\n            item = val[0]\n        except (TypeError, IndexError):\n            continue\n        if item != '?' and item != '.':\n            self.header[target_key] = item\n            break",
            "def _update_header_entry(self, target_key, keys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    md = self._mmcif_dict\n    for key in keys:\n        val = md.get(key)\n        try:\n            item = val[0]\n        except (TypeError, IndexError):\n            continue\n        if item != '?' and item != '.':\n            self.header[target_key] = item\n            break",
            "def _update_header_entry(self, target_key, keys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    md = self._mmcif_dict\n    for key in keys:\n        val = md.get(key)\n        try:\n            item = val[0]\n        except (TypeError, IndexError):\n            continue\n        if item != '?' and item != '.':\n            self.header[target_key] = item\n            break",
            "def _update_header_entry(self, target_key, keys):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    md = self._mmcif_dict\n    for key in keys:\n        val = md.get(key)\n        try:\n            item = val[0]\n        except (TypeError, IndexError):\n            continue\n        if item != '?' and item != '.':\n            self.header[target_key] = item\n            break"
        ]
    },
    {
        "func_name": "_get_header",
        "original": "def _get_header(self):\n    self.header = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '', 'structure_method': '', 'resolution': None}\n    self._update_header_entry('idcode', ['_entry_id', '_exptl.entry_id', '_struct.entry_id'])\n    self._update_header_entry('name', ['_struct.title'])\n    self._update_header_entry('head', ['_struct_keywords.pdbx_keywords', '_struct_keywords.text'])\n    self._update_header_entry('deposition_date', ['_pdbx_database_status.recvd_initial_deposition_date'])\n    self._update_header_entry('structure_method', ['_exptl.method'])\n    self._update_header_entry('resolution', ['_refine.ls_d_res_high', '_refine_hist.d_res_high', '_em_3d_reconstruction.resolution'])\n    if self.header['resolution'] is not None:\n        try:\n            self.header['resolution'] = float(self.header['resolution'])\n        except ValueError:\n            self.header['resolution'] = None\n    return self.header",
        "mutated": [
            "def _get_header(self):\n    if False:\n        i = 10\n    self.header = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '', 'structure_method': '', 'resolution': None}\n    self._update_header_entry('idcode', ['_entry_id', '_exptl.entry_id', '_struct.entry_id'])\n    self._update_header_entry('name', ['_struct.title'])\n    self._update_header_entry('head', ['_struct_keywords.pdbx_keywords', '_struct_keywords.text'])\n    self._update_header_entry('deposition_date', ['_pdbx_database_status.recvd_initial_deposition_date'])\n    self._update_header_entry('structure_method', ['_exptl.method'])\n    self._update_header_entry('resolution', ['_refine.ls_d_res_high', '_refine_hist.d_res_high', '_em_3d_reconstruction.resolution'])\n    if self.header['resolution'] is not None:\n        try:\n            self.header['resolution'] = float(self.header['resolution'])\n        except ValueError:\n            self.header['resolution'] = None\n    return self.header",
            "def _get_header(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.header = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '', 'structure_method': '', 'resolution': None}\n    self._update_header_entry('idcode', ['_entry_id', '_exptl.entry_id', '_struct.entry_id'])\n    self._update_header_entry('name', ['_struct.title'])\n    self._update_header_entry('head', ['_struct_keywords.pdbx_keywords', '_struct_keywords.text'])\n    self._update_header_entry('deposition_date', ['_pdbx_database_status.recvd_initial_deposition_date'])\n    self._update_header_entry('structure_method', ['_exptl.method'])\n    self._update_header_entry('resolution', ['_refine.ls_d_res_high', '_refine_hist.d_res_high', '_em_3d_reconstruction.resolution'])\n    if self.header['resolution'] is not None:\n        try:\n            self.header['resolution'] = float(self.header['resolution'])\n        except ValueError:\n            self.header['resolution'] = None\n    return self.header",
            "def _get_header(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.header = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '', 'structure_method': '', 'resolution': None}\n    self._update_header_entry('idcode', ['_entry_id', '_exptl.entry_id', '_struct.entry_id'])\n    self._update_header_entry('name', ['_struct.title'])\n    self._update_header_entry('head', ['_struct_keywords.pdbx_keywords', '_struct_keywords.text'])\n    self._update_header_entry('deposition_date', ['_pdbx_database_status.recvd_initial_deposition_date'])\n    self._update_header_entry('structure_method', ['_exptl.method'])\n    self._update_header_entry('resolution', ['_refine.ls_d_res_high', '_refine_hist.d_res_high', '_em_3d_reconstruction.resolution'])\n    if self.header['resolution'] is not None:\n        try:\n            self.header['resolution'] = float(self.header['resolution'])\n        except ValueError:\n            self.header['resolution'] = None\n    return self.header",
            "def _get_header(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.header = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '', 'structure_method': '', 'resolution': None}\n    self._update_header_entry('idcode', ['_entry_id', '_exptl.entry_id', '_struct.entry_id'])\n    self._update_header_entry('name', ['_struct.title'])\n    self._update_header_entry('head', ['_struct_keywords.pdbx_keywords', '_struct_keywords.text'])\n    self._update_header_entry('deposition_date', ['_pdbx_database_status.recvd_initial_deposition_date'])\n    self._update_header_entry('structure_method', ['_exptl.method'])\n    self._update_header_entry('resolution', ['_refine.ls_d_res_high', '_refine_hist.d_res_high', '_em_3d_reconstruction.resolution'])\n    if self.header['resolution'] is not None:\n        try:\n            self.header['resolution'] = float(self.header['resolution'])\n        except ValueError:\n            self.header['resolution'] = None\n    return self.header",
            "def _get_header(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.header = {'name': '', 'head': '', 'idcode': '', 'deposition_date': '', 'structure_method': '', 'resolution': None}\n    self._update_header_entry('idcode', ['_entry_id', '_exptl.entry_id', '_struct.entry_id'])\n    self._update_header_entry('name', ['_struct.title'])\n    self._update_header_entry('head', ['_struct_keywords.pdbx_keywords', '_struct_keywords.text'])\n    self._update_header_entry('deposition_date', ['_pdbx_database_status.recvd_initial_deposition_date'])\n    self._update_header_entry('structure_method', ['_exptl.method'])\n    self._update_header_entry('resolution', ['_refine.ls_d_res_high', '_refine_hist.d_res_high', '_em_3d_reconstruction.resolution'])\n    if self.header['resolution'] is not None:\n        try:\n            self.header['resolution'] = float(self.header['resolution'])\n        except ValueError:\n            self.header['resolution'] = None\n    return self.header"
        ]
    },
    {
        "func_name": "_build_structure",
        "original": "def _build_structure(self, structure_id):\n    _unassigned = {'.', '?'}\n    mmcif_dict = self._mmcif_dict\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        try:\n            serial = int(atom_serial_list[i])\n        except ValueError:\n            serial = atom_serial_list[i]\n            warnings.warn('PDBConstructionWarning: Some atom serial numbers are not numerical', PDBConstructionWarning)\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i]\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            if resname == 'HOH' or resname == 'WAT':\n                hetatm_flag = 'W'\n            else:\n                hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i].upper() if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)\n    try:\n        a = float(mmcif_dict['_cell.length_a'][0])\n        b = float(mmcif_dict['_cell.length_b'][0])\n        c = float(mmcif_dict['_cell.length_c'][0])\n        alpha = float(mmcif_dict['_cell.angle_alpha'][0])\n        beta = float(mmcif_dict['_cell.angle_beta'][0])\n        gamma = float(mmcif_dict['_cell.angle_gamma'][0])\n        cell = np.array((a, b, c, alpha, beta, gamma), 'f')\n        spacegroup = mmcif_dict['_symmetry.space_group_name_H-M'][0]\n        spacegroup = spacegroup[1:-1]\n        if spacegroup is None:\n            raise Exception\n        structure_builder.set_symmetry(spacegroup, cell)\n    except Exception:\n        pass",
        "mutated": [
            "def _build_structure(self, structure_id):\n    if False:\n        i = 10\n    _unassigned = {'.', '?'}\n    mmcif_dict = self._mmcif_dict\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        try:\n            serial = int(atom_serial_list[i])\n        except ValueError:\n            serial = atom_serial_list[i]\n            warnings.warn('PDBConstructionWarning: Some atom serial numbers are not numerical', PDBConstructionWarning)\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i]\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            if resname == 'HOH' or resname == 'WAT':\n                hetatm_flag = 'W'\n            else:\n                hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i].upper() if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)\n    try:\n        a = float(mmcif_dict['_cell.length_a'][0])\n        b = float(mmcif_dict['_cell.length_b'][0])\n        c = float(mmcif_dict['_cell.length_c'][0])\n        alpha = float(mmcif_dict['_cell.angle_alpha'][0])\n        beta = float(mmcif_dict['_cell.angle_beta'][0])\n        gamma = float(mmcif_dict['_cell.angle_gamma'][0])\n        cell = np.array((a, b, c, alpha, beta, gamma), 'f')\n        spacegroup = mmcif_dict['_symmetry.space_group_name_H-M'][0]\n        spacegroup = spacegroup[1:-1]\n        if spacegroup is None:\n            raise Exception\n        structure_builder.set_symmetry(spacegroup, cell)\n    except Exception:\n        pass",
            "def _build_structure(self, structure_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    _unassigned = {'.', '?'}\n    mmcif_dict = self._mmcif_dict\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        try:\n            serial = int(atom_serial_list[i])\n        except ValueError:\n            serial = atom_serial_list[i]\n            warnings.warn('PDBConstructionWarning: Some atom serial numbers are not numerical', PDBConstructionWarning)\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i]\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            if resname == 'HOH' or resname == 'WAT':\n                hetatm_flag = 'W'\n            else:\n                hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i].upper() if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)\n    try:\n        a = float(mmcif_dict['_cell.length_a'][0])\n        b = float(mmcif_dict['_cell.length_b'][0])\n        c = float(mmcif_dict['_cell.length_c'][0])\n        alpha = float(mmcif_dict['_cell.angle_alpha'][0])\n        beta = float(mmcif_dict['_cell.angle_beta'][0])\n        gamma = float(mmcif_dict['_cell.angle_gamma'][0])\n        cell = np.array((a, b, c, alpha, beta, gamma), 'f')\n        spacegroup = mmcif_dict['_symmetry.space_group_name_H-M'][0]\n        spacegroup = spacegroup[1:-1]\n        if spacegroup is None:\n            raise Exception\n        structure_builder.set_symmetry(spacegroup, cell)\n    except Exception:\n        pass",
            "def _build_structure(self, structure_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    _unassigned = {'.', '?'}\n    mmcif_dict = self._mmcif_dict\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        try:\n            serial = int(atom_serial_list[i])\n        except ValueError:\n            serial = atom_serial_list[i]\n            warnings.warn('PDBConstructionWarning: Some atom serial numbers are not numerical', PDBConstructionWarning)\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i]\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            if resname == 'HOH' or resname == 'WAT':\n                hetatm_flag = 'W'\n            else:\n                hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i].upper() if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)\n    try:\n        a = float(mmcif_dict['_cell.length_a'][0])\n        b = float(mmcif_dict['_cell.length_b'][0])\n        c = float(mmcif_dict['_cell.length_c'][0])\n        alpha = float(mmcif_dict['_cell.angle_alpha'][0])\n        beta = float(mmcif_dict['_cell.angle_beta'][0])\n        gamma = float(mmcif_dict['_cell.angle_gamma'][0])\n        cell = np.array((a, b, c, alpha, beta, gamma), 'f')\n        spacegroup = mmcif_dict['_symmetry.space_group_name_H-M'][0]\n        spacegroup = spacegroup[1:-1]\n        if spacegroup is None:\n            raise Exception\n        structure_builder.set_symmetry(spacegroup, cell)\n    except Exception:\n        pass",
            "def _build_structure(self, structure_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    _unassigned = {'.', '?'}\n    mmcif_dict = self._mmcif_dict\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        try:\n            serial = int(atom_serial_list[i])\n        except ValueError:\n            serial = atom_serial_list[i]\n            warnings.warn('PDBConstructionWarning: Some atom serial numbers are not numerical', PDBConstructionWarning)\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i]\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            if resname == 'HOH' or resname == 'WAT':\n                hetatm_flag = 'W'\n            else:\n                hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i].upper() if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)\n    try:\n        a = float(mmcif_dict['_cell.length_a'][0])\n        b = float(mmcif_dict['_cell.length_b'][0])\n        c = float(mmcif_dict['_cell.length_c'][0])\n        alpha = float(mmcif_dict['_cell.angle_alpha'][0])\n        beta = float(mmcif_dict['_cell.angle_beta'][0])\n        gamma = float(mmcif_dict['_cell.angle_gamma'][0])\n        cell = np.array((a, b, c, alpha, beta, gamma), 'f')\n        spacegroup = mmcif_dict['_symmetry.space_group_name_H-M'][0]\n        spacegroup = spacegroup[1:-1]\n        if spacegroup is None:\n            raise Exception\n        structure_builder.set_symmetry(spacegroup, cell)\n    except Exception:\n        pass",
            "def _build_structure(self, structure_id):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    _unassigned = {'.', '?'}\n    mmcif_dict = self._mmcif_dict\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        try:\n            serial = int(atom_serial_list[i])\n        except ValueError:\n            serial = atom_serial_list[i]\n            warnings.warn('PDBConstructionWarning: Some atom serial numbers are not numerical', PDBConstructionWarning)\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i]\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            if resname == 'HOH' or resname == 'WAT':\n                hetatm_flag = 'W'\n            else:\n                hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i].upper() if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)\n    try:\n        a = float(mmcif_dict['_cell.length_a'][0])\n        b = float(mmcif_dict['_cell.length_b'][0])\n        c = float(mmcif_dict['_cell.length_c'][0])\n        alpha = float(mmcif_dict['_cell.angle_alpha'][0])\n        beta = float(mmcif_dict['_cell.angle_beta'][0])\n        gamma = float(mmcif_dict['_cell.angle_gamma'][0])\n        cell = np.array((a, b, c, alpha, beta, gamma), 'f')\n        spacegroup = mmcif_dict['_symmetry.space_group_name_H-M'][0]\n        spacegroup = spacegroup[1:-1]\n        if spacegroup is None:\n            raise Exception\n        structure_builder.set_symmetry(spacegroup, cell)\n    except Exception:\n        pass"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    \"\"\"Create a FastMMCIFParser object.\n\n        The mmCIF parser calls a number of standard methods in an aggregated\n        StructureBuilder object. Normally this object is instantiated by the\n        parser object itself, but if the user provides his/her own\n        StructureBuilder object, the latter is used instead.\n\n        The main difference between this class and the regular MMCIFParser is\n        that only 'ATOM' and 'HETATM' lines are parsed here. Use if you are\n        interested only in coordinate information.\n\n        Arguments:\n         - structure_builder - an optional user implemented StructureBuilder class.\n         - auth_chains - True by default. If true, use the author chain IDs.\n           If false, use the re-assigned mmCIF chain IDs.\n         - auth_residues - True by default. If true, use the author residue numbering.\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\n           codes, and strictly increments residue numbers.\n           NOTE: Non-polymers such as water don't have a \"label\" residue number,\n           and will be skipped.\n\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\n           These warnings might be indicative of problems in the mmCIF file!\n\n        \"\"\"\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
        "mutated": [
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n    'Create a FastMMCIFParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        parser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        The main difference between this class and the regular MMCIFParser is\\n        that only \\'ATOM\\' and \\'HETATM\\' lines are parsed here. Use if you are\\n        interested only in coordinate information.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Create a FastMMCIFParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        parser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        The main difference between this class and the regular MMCIFParser is\\n        that only \\'ATOM\\' and \\'HETATM\\' lines are parsed here. Use if you are\\n        interested only in coordinate information.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Create a FastMMCIFParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        parser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        The main difference between this class and the regular MMCIFParser is\\n        that only \\'ATOM\\' and \\'HETATM\\' lines are parsed here. Use if you are\\n        interested only in coordinate information.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Create a FastMMCIFParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        parser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        The main difference between this class and the regular MMCIFParser is\\n        that only \\'ATOM\\' and \\'HETATM\\' lines are parsed here. Use if you are\\n        interested only in coordinate information.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)",
            "def __init__(self, structure_builder=None, auth_chains=True, auth_residues=True, QUIET=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Create a FastMMCIFParser object.\\n\\n        The mmCIF parser calls a number of standard methods in an aggregated\\n        StructureBuilder object. Normally this object is instantiated by the\\n        parser object itself, but if the user provides his/her own\\n        StructureBuilder object, the latter is used instead.\\n\\n        The main difference between this class and the regular MMCIFParser is\\n        that only \\'ATOM\\' and \\'HETATM\\' lines are parsed here. Use if you are\\n        interested only in coordinate information.\\n\\n        Arguments:\\n         - structure_builder - an optional user implemented StructureBuilder class.\\n         - auth_chains - True by default. If true, use the author chain IDs.\\n           If false, use the re-assigned mmCIF chain IDs.\\n         - auth_residues - True by default. If true, use the author residue numbering.\\n           If false, use the mmCIF \"label\" residue numbering, which has no insertion\\n           codes, and strictly increments residue numbers.\\n           NOTE: Non-polymers such as water don\\'t have a \"label\" residue number,\\n           and will be skipped.\\n\\n         - QUIET - Evaluated as a Boolean. If true, warnings issued in constructing\\n           the SMCRA data will be suppressed. If false (DEFAULT), they will be shown.\\n           These warnings might be indicative of problems in the mmCIF file!\\n\\n        '\n    if structure_builder is not None:\n        self._structure_builder = structure_builder\n    else:\n        self._structure_builder = StructureBuilder()\n    self.line_counter = 0\n    self.build_structure = None\n    self.auth_chains = bool(auth_chains)\n    self.auth_residues = bool(auth_residues)\n    self.QUIET = bool(QUIET)"
        ]
    },
    {
        "func_name": "get_structure",
        "original": "def get_structure(self, structure_id, filename):\n    \"\"\"Return the structure.\n\n        Arguments:\n         - structure_id - string, the id that will be used for the structure\n         - filename - name of the mmCIF file OR an open filehandle\n\n        \"\"\"\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        with as_handle(filename) as handle:\n            self._build_structure(structure_id, handle)\n    return self._structure_builder.get_structure()",
        "mutated": [
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of the mmCIF file OR an open filehandle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        with as_handle(filename) as handle:\n            self._build_structure(structure_id, handle)\n    return self._structure_builder.get_structure()",
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of the mmCIF file OR an open filehandle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        with as_handle(filename) as handle:\n            self._build_structure(structure_id, handle)\n    return self._structure_builder.get_structure()",
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of the mmCIF file OR an open filehandle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        with as_handle(filename) as handle:\n            self._build_structure(structure_id, handle)\n    return self._structure_builder.get_structure()",
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of the mmCIF file OR an open filehandle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        with as_handle(filename) as handle:\n            self._build_structure(structure_id, handle)\n    return self._structure_builder.get_structure()",
            "def get_structure(self, structure_id, filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Return the structure.\\n\\n        Arguments:\\n         - structure_id - string, the id that will be used for the structure\\n         - filename - name of the mmCIF file OR an open filehandle\\n\\n        '\n    with warnings.catch_warnings():\n        if self.QUIET:\n            warnings.filterwarnings('ignore', category=PDBConstructionWarning)\n        with as_handle(filename) as handle:\n            self._build_structure(structure_id, handle)\n    return self._structure_builder.get_structure()"
        ]
    },
    {
        "func_name": "_build_structure",
        "original": "def _build_structure(self, structure_id, filehandle):\n    _unassigned = {'.', '?'}\n    (read_atom, read_aniso) = (False, False)\n    (_fields, _records) = ([], [])\n    (_anisof, _anisors) = ([], [])\n    for line in filehandle:\n        if line.startswith('_atom_site.'):\n            read_atom = True\n            _fields.append(line.strip())\n        elif line.startswith('_atom_site_anisotrop.'):\n            read_aniso = True\n            _anisof.append(line.strip())\n        elif read_atom and line.startswith('#'):\n            read_atom = False\n        elif read_aniso and line.startswith('#'):\n            read_aniso = False\n        elif read_atom:\n            _records.append(line.strip())\n        elif read_aniso:\n            _anisors.append(line.strip())\n    _record_tbl = zip(*map(str.split, _records))\n    _anisob_tbl = zip(*map(str.split, _anisors))\n    mmcif_dict = dict(zip(_fields, _record_tbl))\n    mmcif_dict.update(dict(zip(_anisof, _anisob_tbl)))\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        serial = atom_serial_list[i]\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i].strip('\"')\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i] if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)",
        "mutated": [
            "def _build_structure(self, structure_id, filehandle):\n    if False:\n        i = 10\n    _unassigned = {'.', '?'}\n    (read_atom, read_aniso) = (False, False)\n    (_fields, _records) = ([], [])\n    (_anisof, _anisors) = ([], [])\n    for line in filehandle:\n        if line.startswith('_atom_site.'):\n            read_atom = True\n            _fields.append(line.strip())\n        elif line.startswith('_atom_site_anisotrop.'):\n            read_aniso = True\n            _anisof.append(line.strip())\n        elif read_atom and line.startswith('#'):\n            read_atom = False\n        elif read_aniso and line.startswith('#'):\n            read_aniso = False\n        elif read_atom:\n            _records.append(line.strip())\n        elif read_aniso:\n            _anisors.append(line.strip())\n    _record_tbl = zip(*map(str.split, _records))\n    _anisob_tbl = zip(*map(str.split, _anisors))\n    mmcif_dict = dict(zip(_fields, _record_tbl))\n    mmcif_dict.update(dict(zip(_anisof, _anisob_tbl)))\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        serial = atom_serial_list[i]\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i].strip('\"')\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i] if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)",
            "def _build_structure(self, structure_id, filehandle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    _unassigned = {'.', '?'}\n    (read_atom, read_aniso) = (False, False)\n    (_fields, _records) = ([], [])\n    (_anisof, _anisors) = ([], [])\n    for line in filehandle:\n        if line.startswith('_atom_site.'):\n            read_atom = True\n            _fields.append(line.strip())\n        elif line.startswith('_atom_site_anisotrop.'):\n            read_aniso = True\n            _anisof.append(line.strip())\n        elif read_atom and line.startswith('#'):\n            read_atom = False\n        elif read_aniso and line.startswith('#'):\n            read_aniso = False\n        elif read_atom:\n            _records.append(line.strip())\n        elif read_aniso:\n            _anisors.append(line.strip())\n    _record_tbl = zip(*map(str.split, _records))\n    _anisob_tbl = zip(*map(str.split, _anisors))\n    mmcif_dict = dict(zip(_fields, _record_tbl))\n    mmcif_dict.update(dict(zip(_anisof, _anisob_tbl)))\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        serial = atom_serial_list[i]\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i].strip('\"')\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i] if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)",
            "def _build_structure(self, structure_id, filehandle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    _unassigned = {'.', '?'}\n    (read_atom, read_aniso) = (False, False)\n    (_fields, _records) = ([], [])\n    (_anisof, _anisors) = ([], [])\n    for line in filehandle:\n        if line.startswith('_atom_site.'):\n            read_atom = True\n            _fields.append(line.strip())\n        elif line.startswith('_atom_site_anisotrop.'):\n            read_aniso = True\n            _anisof.append(line.strip())\n        elif read_atom and line.startswith('#'):\n            read_atom = False\n        elif read_aniso and line.startswith('#'):\n            read_aniso = False\n        elif read_atom:\n            _records.append(line.strip())\n        elif read_aniso:\n            _anisors.append(line.strip())\n    _record_tbl = zip(*map(str.split, _records))\n    _anisob_tbl = zip(*map(str.split, _anisors))\n    mmcif_dict = dict(zip(_fields, _record_tbl))\n    mmcif_dict.update(dict(zip(_anisof, _anisob_tbl)))\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        serial = atom_serial_list[i]\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i].strip('\"')\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i] if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)",
            "def _build_structure(self, structure_id, filehandle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    _unassigned = {'.', '?'}\n    (read_atom, read_aniso) = (False, False)\n    (_fields, _records) = ([], [])\n    (_anisof, _anisors) = ([], [])\n    for line in filehandle:\n        if line.startswith('_atom_site.'):\n            read_atom = True\n            _fields.append(line.strip())\n        elif line.startswith('_atom_site_anisotrop.'):\n            read_aniso = True\n            _anisof.append(line.strip())\n        elif read_atom and line.startswith('#'):\n            read_atom = False\n        elif read_aniso and line.startswith('#'):\n            read_aniso = False\n        elif read_atom:\n            _records.append(line.strip())\n        elif read_aniso:\n            _anisors.append(line.strip())\n    _record_tbl = zip(*map(str.split, _records))\n    _anisob_tbl = zip(*map(str.split, _anisors))\n    mmcif_dict = dict(zip(_fields, _record_tbl))\n    mmcif_dict.update(dict(zip(_anisof, _anisob_tbl)))\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        serial = atom_serial_list[i]\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i].strip('\"')\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i] if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)",
            "def _build_structure(self, structure_id, filehandle):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    _unassigned = {'.', '?'}\n    (read_atom, read_aniso) = (False, False)\n    (_fields, _records) = ([], [])\n    (_anisof, _anisors) = ([], [])\n    for line in filehandle:\n        if line.startswith('_atom_site.'):\n            read_atom = True\n            _fields.append(line.strip())\n        elif line.startswith('_atom_site_anisotrop.'):\n            read_aniso = True\n            _anisof.append(line.strip())\n        elif read_atom and line.startswith('#'):\n            read_atom = False\n        elif read_aniso and line.startswith('#'):\n            read_aniso = False\n        elif read_atom:\n            _records.append(line.strip())\n        elif read_aniso:\n            _anisors.append(line.strip())\n    _record_tbl = zip(*map(str.split, _records))\n    _anisob_tbl = zip(*map(str.split, _anisors))\n    mmcif_dict = dict(zip(_fields, _record_tbl))\n    mmcif_dict.update(dict(zip(_anisof, _anisob_tbl)))\n    atom_serial_list = mmcif_dict['_atom_site.id']\n    atom_id_list = mmcif_dict['_atom_site.label_atom_id']\n    residue_id_list = mmcif_dict['_atom_site.label_comp_id']\n    try:\n        element_list = mmcif_dict['_atom_site.type_symbol']\n    except KeyError:\n        element_list = None\n    if self.auth_chains:\n        chain_id_list = mmcif_dict['_atom_site.auth_asym_id']\n    else:\n        chain_id_list = mmcif_dict['_atom_site.label_asym_id']\n    x_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_x']]\n    y_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_y']]\n    z_list = [float(x) for x in mmcif_dict['_atom_site.Cartn_z']]\n    alt_list = mmcif_dict['_atom_site.label_alt_id']\n    icode_list = mmcif_dict['_atom_site.pdbx_PDB_ins_code']\n    b_factor_list = mmcif_dict['_atom_site.B_iso_or_equiv']\n    occupancy_list = mmcif_dict['_atom_site.occupancy']\n    fieldname_list = mmcif_dict['_atom_site.group_PDB']\n    try:\n        serial_list = [int(n) for n in mmcif_dict['_atom_site.pdbx_PDB_model_num']]\n    except KeyError:\n        serial_list = None\n    except ValueError:\n        raise PDBConstructionException('Invalid model number') from None\n    try:\n        aniso_u11 = mmcif_dict['_atom_site_anisotrop.U[1][1]']\n        aniso_u12 = mmcif_dict['_atom_site_anisotrop.U[1][2]']\n        aniso_u13 = mmcif_dict['_atom_site_anisotrop.U[1][3]']\n        aniso_u22 = mmcif_dict['_atom_site_anisotrop.U[2][2]']\n        aniso_u23 = mmcif_dict['_atom_site_anisotrop.U[2][3]']\n        aniso_u33 = mmcif_dict['_atom_site_anisotrop.U[3][3]']\n        aniso_flag = 1\n    except KeyError:\n        aniso_flag = 0\n    if self.auth_residues:\n        if '_atom_site.auth_seq_id' in mmcif_dict:\n            seq_id_list = mmcif_dict['_atom_site.auth_seq_id']\n        else:\n            seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    else:\n        seq_id_list = mmcif_dict['_atom_site.label_seq_id']\n    current_chain_id = None\n    current_residue_id = None\n    current_resname = None\n    structure_builder = self._structure_builder\n    structure_builder.init_structure(structure_id)\n    structure_builder.init_seg(' ')\n    current_model_id = -1\n    current_serial_id = -1\n    for i in range(len(atom_id_list)):\n        structure_builder.set_line_counter(i)\n        serial = atom_serial_list[i]\n        x = x_list[i]\n        y = y_list[i]\n        z = z_list[i]\n        resname = residue_id_list[i]\n        chainid = chain_id_list[i]\n        altloc = alt_list[i]\n        if altloc in _unassigned:\n            altloc = ' '\n        resseq = seq_id_list[i]\n        if resseq == '.':\n            try:\n                msg_resseq = mmcif_dict['_atom_site.auth_seq_id'][i]\n                msg = \"Non-existing residue ID in chain '{}', residue '{}'\".format(chainid, msg_resseq)\n            except (KeyError, IndexError):\n                msg = f\"Non-existing residue ID in chain '{chainid}'\"\n            warnings.warn('PDBConstructionWarning: ' + msg, PDBConstructionWarning)\n            continue\n        int_resseq = int(resseq)\n        icode = icode_list[i]\n        if icode in _unassigned:\n            icode = ' '\n        name = atom_id_list[i].strip('\"')\n        try:\n            tempfactor = float(b_factor_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing B factor') from None\n        try:\n            occupancy = float(occupancy_list[i])\n        except ValueError:\n            raise PDBConstructionException('Invalid or missing occupancy') from None\n        fieldname = fieldname_list[i]\n        if fieldname == 'HETATM':\n            hetatm_flag = 'H'\n        else:\n            hetatm_flag = ' '\n        resseq = (hetatm_flag, int_resseq, icode)\n        if serial_list is not None:\n            serial_id = serial_list[i]\n            if current_serial_id != serial_id:\n                current_serial_id = serial_id\n                current_model_id += 1\n                structure_builder.init_model(current_model_id, current_serial_id)\n                current_chain_id = None\n                current_residue_id = None\n                current_resname = None\n        else:\n            structure_builder.init_model(current_model_id)\n        if current_chain_id != chainid:\n            current_chain_id = chainid\n            structure_builder.init_chain(current_chain_id)\n            current_residue_id = None\n            current_resname = None\n        if current_residue_id != resseq or current_resname != resname:\n            current_residue_id = resseq\n            current_resname = resname\n            structure_builder.init_residue(resname, hetatm_flag, int_resseq, icode)\n        coord = np.array((x, y, z), 'f')\n        element = element_list[i] if element_list else None\n        structure_builder.init_atom(name, coord, tempfactor, occupancy, altloc, name, serial_number=serial, element=element)\n        if aniso_flag == 1 and i < len(aniso_u11):\n            u = (aniso_u11[i], aniso_u12[i], aniso_u13[i], aniso_u22[i], aniso_u23[i], aniso_u33[i])\n            mapped_anisou = [float(_) for _ in u]\n            anisou_array = np.array(mapped_anisou, 'f')\n            structure_builder.set_anisou(anisou_array)"
        ]
    }
]