[
    {
        "func_name": "__virtual__",
        "original": "def __virtual__():\n    \"\"\"\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\n    \"\"\"\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
        "mutated": [
            "def __virtual__():\n    if False:\n        i = 10\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)",
            "def __virtual__():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    NAPALM library must be installed for this module to work and run in a (proxy) minion.\\n    '\n    return salt.utils.napalm.virtual(__opts__, __virtualname__, __file__)"
        ]
    },
    {
        "func_name": "_update_config",
        "original": "def _update_config(template_name, template_source=None, template_hash=None, template_hash_name=None, template_user='root', template_group='root', template_mode='755', template_attrs='--------------e----', saltenv=None, template_engine='jinja', skip_verify=False, defaults=None, test=False, commit=True, debug=False, replace=False, **template_vars):\n    \"\"\"\n    Call the necessary functions in order to execute the state.\n    For the moment this only calls the ``net.load_template`` function from the\n    :mod:`Network-related basic features execution module <salt.modules.napalm_network>`, but this may change in time.\n    \"\"\"\n    return __salt__['net.load_template'](template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, template_user=template_user, template_group=template_group, template_mode=template_mode, template_attrs=template_attrs, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, defaults=defaults, test=test, commit=commit, debug=debug, replace=replace, **template_vars)",
        "mutated": [
            "def _update_config(template_name, template_source=None, template_hash=None, template_hash_name=None, template_user='root', template_group='root', template_mode='755', template_attrs='--------------e----', saltenv=None, template_engine='jinja', skip_verify=False, defaults=None, test=False, commit=True, debug=False, replace=False, **template_vars):\n    if False:\n        i = 10\n    '\\n    Call the necessary functions in order to execute the state.\\n    For the moment this only calls the ``net.load_template`` function from the\\n    :mod:`Network-related basic features execution module <salt.modules.napalm_network>`, but this may change in time.\\n    '\n    return __salt__['net.load_template'](template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, template_user=template_user, template_group=template_group, template_mode=template_mode, template_attrs=template_attrs, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, defaults=defaults, test=test, commit=commit, debug=debug, replace=replace, **template_vars)",
            "def _update_config(template_name, template_source=None, template_hash=None, template_hash_name=None, template_user='root', template_group='root', template_mode='755', template_attrs='--------------e----', saltenv=None, template_engine='jinja', skip_verify=False, defaults=None, test=False, commit=True, debug=False, replace=False, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Call the necessary functions in order to execute the state.\\n    For the moment this only calls the ``net.load_template`` function from the\\n    :mod:`Network-related basic features execution module <salt.modules.napalm_network>`, but this may change in time.\\n    '\n    return __salt__['net.load_template'](template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, template_user=template_user, template_group=template_group, template_mode=template_mode, template_attrs=template_attrs, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, defaults=defaults, test=test, commit=commit, debug=debug, replace=replace, **template_vars)",
            "def _update_config(template_name, template_source=None, template_hash=None, template_hash_name=None, template_user='root', template_group='root', template_mode='755', template_attrs='--------------e----', saltenv=None, template_engine='jinja', skip_verify=False, defaults=None, test=False, commit=True, debug=False, replace=False, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Call the necessary functions in order to execute the state.\\n    For the moment this only calls the ``net.load_template`` function from the\\n    :mod:`Network-related basic features execution module <salt.modules.napalm_network>`, but this may change in time.\\n    '\n    return __salt__['net.load_template'](template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, template_user=template_user, template_group=template_group, template_mode=template_mode, template_attrs=template_attrs, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, defaults=defaults, test=test, commit=commit, debug=debug, replace=replace, **template_vars)",
            "def _update_config(template_name, template_source=None, template_hash=None, template_hash_name=None, template_user='root', template_group='root', template_mode='755', template_attrs='--------------e----', saltenv=None, template_engine='jinja', skip_verify=False, defaults=None, test=False, commit=True, debug=False, replace=False, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Call the necessary functions in order to execute the state.\\n    For the moment this only calls the ``net.load_template`` function from the\\n    :mod:`Network-related basic features execution module <salt.modules.napalm_network>`, but this may change in time.\\n    '\n    return __salt__['net.load_template'](template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, template_user=template_user, template_group=template_group, template_mode=template_mode, template_attrs=template_attrs, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, defaults=defaults, test=test, commit=commit, debug=debug, replace=replace, **template_vars)",
            "def _update_config(template_name, template_source=None, template_hash=None, template_hash_name=None, template_user='root', template_group='root', template_mode='755', template_attrs='--------------e----', saltenv=None, template_engine='jinja', skip_verify=False, defaults=None, test=False, commit=True, debug=False, replace=False, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Call the necessary functions in order to execute the state.\\n    For the moment this only calls the ``net.load_template`` function from the\\n    :mod:`Network-related basic features execution module <salt.modules.napalm_network>`, but this may change in time.\\n    '\n    return __salt__['net.load_template'](template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, template_user=template_user, template_group=template_group, template_mode=template_mode, template_attrs=template_attrs, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, defaults=defaults, test=test, commit=commit, debug=debug, replace=replace, **template_vars)"
        ]
    },
    {
        "func_name": "replace_pattern",
        "original": "def replace_pattern(name, pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source='running', path=None, test=False, replace=True, debug=False, commit=True):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Replace occurrences of a pattern in the configuration source. If\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\n    otherwise a ``True`` will be returned when changes are made, and ``False``\n    when no changes are made.\n    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.\n\n    pattern\n        A regular expression, to be matched using Python's\n        :py:func:`~re.search`.\n\n    repl\n        The replacement text.\n\n    count: ``0``\n        Maximum number of pattern occurrences to be replaced. If count is a\n        positive integer ``n``, only ``n`` occurrences will be replaced,\n        otherwise all occurrences will be replaced.\n\n    flags (list or int): ``8``\n        A list of flags defined in the ``re`` module documentation from the\n        Python standard library. Each list item should be a string that will\n        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',\n        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\n        8 (which supports 'MULTILINE').\n\n    bufsize (int or str): ``1``\n        How much of the configuration to buffer into memory at once. The\n        default value ``1`` processes one line at a time. The special value\n        ``file`` may be specified which will read the entire file into memory\n        before processing.\n\n    append_if_not_found: ``False``\n        If set to ``True``, and pattern is not found, then the content will be\n        appended to the file.\n\n    prepend_if_not_found: ``False``\n        If set to ``True`` and pattern is not found, then the content will be\n        prepended to the file.\n\n    not_found_content\n        Content to use for append/prepend if not found. If None (default), uses\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\n\n    search_only: ``False``\n        If set to true, this no changes will be performed on the file, and this\n        function will simply return ``True`` if the pattern was matched, and\n        ``False`` if not.\n\n    show_changes: ``True``\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\n        if changes were made, and ``False`` if not.\n\n    backslash_literal: ``False``\n        Interpret backslashes as literal backslashes for the repl and not\n        escape characters.  This will help when using append/prepend so that\n        the backslashes are not interpreted for the repl on the second run of\n        the state.\n\n    source: ``running``\n        The configuration source. Choose from: ``running``, ``candidate``, or\n        ``startup``. Default: ``running``.\n\n    path\n        Save the temporary configuration to a specific path, then read from\n        there.\n\n    test: ``False``\n        Dry run? If set as ``True``, will apply the config, discard and return\n        the changes. Default: ``False`` and will commit the changes on the\n        device.\n\n    commit: ``True``\n        Commit the configuration changes? Default: ``True``.\n\n    debug: ``False``\n        Debug mode. Will insert a new key in the output dictionary, as\n        ``loaded_config`` containing the raw configuration loaded on the device.\n\n    replace: ``True``\n        Load and replace the configuration. Default: ``True``.\n\n    If an equal sign (``=``) appears in an argument to a Salt command it is\n    interpreted as a keyword argument in the format ``key=val``. That\n    processing can be bypassed in order to pass an equal sign through to the\n    remote shell command by manually specifying the kwarg:\n\n    State SLS Example:\n\n    .. code-block:: yaml\n\n        update_policy_name:\n          netconfig.replace_pattern:\n            - pattern: OLD-POLICY-NAME\n            - repl: new-policy-name\n            - debug: true\n    \"\"\"\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    replace_ret = __salt__['net.replace_pattern'](pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal, source=source, path=path, test=test, replace=replace, debug=debug, commit=commit)\n    return salt.utils.napalm.loaded_ret(ret, replace_ret, test, debug)",
        "mutated": [
            "def replace_pattern(name, pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source='running', path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python's\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',\\n        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports 'MULTILINE').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        update_policy_name:\\n          netconfig.replace_pattern:\\n            - pattern: OLD-POLICY-NAME\\n            - repl: new-policy-name\\n            - debug: true\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    replace_ret = __salt__['net.replace_pattern'](pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal, source=source, path=path, test=test, replace=replace, debug=debug, commit=commit)\n    return salt.utils.napalm.loaded_ret(ret, replace_ret, test, debug)",
            "def replace_pattern(name, pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source='running', path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python's\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',\\n        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports 'MULTILINE').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        update_policy_name:\\n          netconfig.replace_pattern:\\n            - pattern: OLD-POLICY-NAME\\n            - repl: new-policy-name\\n            - debug: true\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    replace_ret = __salt__['net.replace_pattern'](pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal, source=source, path=path, test=test, replace=replace, debug=debug, commit=commit)\n    return salt.utils.napalm.loaded_ret(ret, replace_ret, test, debug)",
            "def replace_pattern(name, pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source='running', path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python's\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',\\n        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports 'MULTILINE').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        update_policy_name:\\n          netconfig.replace_pattern:\\n            - pattern: OLD-POLICY-NAME\\n            - repl: new-policy-name\\n            - debug: true\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    replace_ret = __salt__['net.replace_pattern'](pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal, source=source, path=path, test=test, replace=replace, debug=debug, commit=commit)\n    return salt.utils.napalm.loaded_ret(ret, replace_ret, test, debug)",
            "def replace_pattern(name, pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source='running', path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python's\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',\\n        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports 'MULTILINE').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        update_policy_name:\\n          netconfig.replace_pattern:\\n            - pattern: OLD-POLICY-NAME\\n            - repl: new-policy-name\\n            - debug: true\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    replace_ret = __salt__['net.replace_pattern'](pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal, source=source, path=path, test=test, replace=replace, debug=debug, commit=commit)\n    return salt.utils.napalm.loaded_ret(ret, replace_ret, test, debug)",
            "def replace_pattern(name, pattern, repl, count=0, flags=8, bufsize=1, append_if_not_found=False, prepend_if_not_found=False, not_found_content=None, search_only=False, show_changes=True, backslash_literal=False, source='running', path=None, test=False, replace=True, debug=False, commit=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Replace occurrences of a pattern in the configuration source. If\\n    ``show_changes`` is ``True``, then a diff of what changed will be returned,\\n    otherwise a ``True`` will be returned when changes are made, and ``False``\\n    when no changes are made.\\n    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.\\n\\n    pattern\\n        A regular expression, to be matched using Python's\\n        :py:func:`~re.search`.\\n\\n    repl\\n        The replacement text.\\n\\n    count: ``0``\\n        Maximum number of pattern occurrences to be replaced. If count is a\\n        positive integer ``n``, only ``n`` occurrences will be replaced,\\n        otherwise all occurrences will be replaced.\\n\\n    flags (list or int): ``8``\\n        A list of flags defined in the ``re`` module documentation from the\\n        Python standard library. Each list item should be a string that will\\n        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',\\n        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value\\n        corresponding to the XOR (``|``) of all the desired flags. Defaults to\\n        8 (which supports 'MULTILINE').\\n\\n    bufsize (int or str): ``1``\\n        How much of the configuration to buffer into memory at once. The\\n        default value ``1`` processes one line at a time. The special value\\n        ``file`` may be specified which will read the entire file into memory\\n        before processing.\\n\\n    append_if_not_found: ``False``\\n        If set to ``True``, and pattern is not found, then the content will be\\n        appended to the file.\\n\\n    prepend_if_not_found: ``False``\\n        If set to ``True`` and pattern is not found, then the content will be\\n        prepended to the file.\\n\\n    not_found_content\\n        Content to use for append/prepend if not found. If None (default), uses\\n        ``repl``. Useful when ``repl`` uses references to group in pattern.\\n\\n    search_only: ``False``\\n        If set to true, this no changes will be performed on the file, and this\\n        function will simply return ``True`` if the pattern was matched, and\\n        ``False`` if not.\\n\\n    show_changes: ``True``\\n        If ``True``, return a diff of changes made. Otherwise, return ``True``\\n        if changes were made, and ``False`` if not.\\n\\n    backslash_literal: ``False``\\n        Interpret backslashes as literal backslashes for the repl and not\\n        escape characters.  This will help when using append/prepend so that\\n        the backslashes are not interpreted for the repl on the second run of\\n        the state.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``, or\\n        ``startup``. Default: ``running``.\\n\\n    path\\n        Save the temporary configuration to a specific path, then read from\\n        there.\\n\\n    test: ``False``\\n        Dry run? If set as ``True``, will apply the config, discard and return\\n        the changes. Default: ``False`` and will commit the changes on the\\n        device.\\n\\n    commit: ``True``\\n        Commit the configuration changes? Default: ``True``.\\n\\n    debug: ``False``\\n        Debug mode. Will insert a new key in the output dictionary, as\\n        ``loaded_config`` containing the raw configuration loaded on the device.\\n\\n    replace: ``True``\\n        Load and replace the configuration. Default: ``True``.\\n\\n    If an equal sign (``=``) appears in an argument to a Salt command it is\\n    interpreted as a keyword argument in the format ``key=val``. That\\n    processing can be bypassed in order to pass an equal sign through to the\\n    remote shell command by manually specifying the kwarg:\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        update_policy_name:\\n          netconfig.replace_pattern:\\n            - pattern: OLD-POLICY-NAME\\n            - repl: new-policy-name\\n            - debug: true\\n    \"\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    replace_ret = __salt__['net.replace_pattern'](pattern, repl, count=count, flags=flags, bufsize=bufsize, append_if_not_found=append_if_not_found, prepend_if_not_found=prepend_if_not_found, not_found_content=not_found_content, search_only=search_only, show_changes=show_changes, backslash_literal=backslash_literal, source=source, path=path, test=test, replace=replace, debug=debug, commit=commit)\n    return salt.utils.napalm.loaded_ret(ret, replace_ret, test, debug)"
        ]
    },
    {
        "func_name": "saved",
        "original": "def saved(name, source='running', user=None, group=None, mode=None, attrs=None, makedirs=False, dir_mode=None, replace=True, backup='', show_changes=True, create=True, tmp_dir='', tmp_ext='', encoding=None, encoding_errors='strict', allow_empty=False, follow_symlinks=True, check_cmd=None, win_owner=None, win_perms=None, win_deny_perms=None, win_inheritance=True, win_perms_reset=False, **kwargs):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Save the configuration to a file on the local file system.\n\n    name\n        Absolute path to file where to save the configuration.\n        To push the files to the Master, use\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\n\n    source: ``running``\n        The configuration source. Choose from: ``running``, ``candidate``,\n        ``startup``. Default: ``running``.\n\n    user\n        The user to own the file, this defaults to the user salt is running as\n        on the minion\n\n    group\n        The group ownership set for the file, this defaults to the group salt\n        is running as on the minion. On Windows, this is ignored\n\n    mode\n        The permissions to set on this file, e.g. ``644``, ``0775``, or\n        ``4664``.\n        The default mode for new files and directories corresponds to the\n        umask of the salt process. The mode of existing files and directories\n        will only be changed if ``mode`` is specified.\n\n        .. note::\n            This option is **not** supported on Windows.\n    attrs\n        The attributes to have on this file, e.g. ``a``, ``i``. The attributes\n        can be any or a combination of the following characters:\n        ``aAcCdDeijPsStTu``.\n\n        .. note::\n            This option is **not** supported on Windows.\n\n    makedirs: ``False``\n        If set to ``True``, then the parent directories will be created to\n        facilitate the creation of the named file. If ``False``, and the parent\n        directory of the destination file doesn't exist, the state will fail.\n\n    dir_mode\n        If directories are to be created, passing this option specifies the\n        permissions for those directories. If this is not set, directories\n        will be assigned permissions by adding the execute bit to the mode of\n        the files.\n\n        The default mode for new files and directories corresponds umask of salt\n        process. For existing files and directories it's not enforced.\n\n    replace: ``True``\n        If set to ``False`` and the file already exists, the file will not be\n        modified even if changes would otherwise be made. Permissions and\n        ownership will still be enforced, however.\n\n    backup\n        Overrides the default backup mode for this specific file. See\n        :ref:`backup_mode documentation <file-state-backups>` for more details.\n\n    show_changes: ``True``\n        Output a unified diff of the old file and the new file. If ``False``\n        return a boolean if any changes were made.\n\n    create: ``True``\n        If set to ``False``, then the file will only be managed if the file\n        already exists on the system.\n\n    encoding\n        If specified, then the specified encoding will be used. Otherwise, the\n        file will be encoded using the system locale (usually UTF-8). See\n        https://docs.python.org/3/library/codecs.html#standard-encodings for\n        the list of available encodings.\n\n    encoding_errors: ``'strict'``\n        Error encoding scheme. Default is ```'strict'```.\n        See https://docs.python.org/2/library/codecs.html#codec-base-classes\n        for the list of available schemes.\n\n    allow_empty: ``True``\n        If set to ``False``, then the state will fail if the contents specified\n        by ``contents_pillar`` or ``contents_grains`` are empty.\n\n    follow_symlinks: ``True``\n        If the desired path is a symlink follow it and make changes to the\n        file to which the symlink points.\n\n    check_cmd\n        The specified command will be run with an appended argument of a\n        *temporary* file containing the new managed contents.  If the command\n        exits with a zero status the new managed contents will be written to\n        the managed destination. If the command exits with a nonzero exit\n        code, the state will fail and no changes will be made to the file.\n\n    tmp_dir\n        Directory for temp file created by ``check_cmd``. Useful for checkers\n        dependent on config file location (e.g. daemons restricted to their\n        own config directories by an apparmor profile).\n\n    tmp_ext\n        Suffix for temp file created by ``check_cmd``. Useful for checkers\n        dependent on config file extension (e.g. the init-checkconf upstart\n        config checker).\n\n    win_owner: ``None``\n        The owner of the directory. If this is not passed, user will be used. If\n        user is not passed, the account under which Salt is running will be\n        used.\n\n    win_perms: ``None``\n        A dictionary containing permissions to grant and their propagation. For\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\n        single basic perm or a list of advanced perms. ``perms`` must be\n        specified. ``applies_to`` does not apply to file objects.\n\n    win_deny_perms: ``None``\n        A dictionary containing permissions to deny and their propagation. For\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\n        single basic perm or a list of advanced perms. ``perms`` must be\n        specified. ``applies_to`` does not apply to file objects.\n\n    win_inheritance: ``True``\n        True to inherit permissions from the parent directory, False not to\n        inherit permission.\n\n    win_perms_reset: ``False``\n        If ``True`` the existing DACL will be cleared and replaced with the\n        settings defined in this function. If ``False``, new entries will be\n        appended to the existing DACL. Default is ``False``.\n\n    State SLS Example:\n\n    .. code-block:: yaml\n\n        /var/backups/{{ opts.id }}/{{ salt.status.time('%s') }}.cfg:\n          netconfig.saved:\n            - source: running\n            - makedirs: true\n\n    The state SLS  above would create a backup config grouping the files by the\n    Minion ID, in chronological files. For example, if the state is executed at\n    on the 3rd of August 2018, at 5:15PM, on the Minion ``core1.lon01``, the\n    configuration would saved in the file:\n    ``/var/backups/core01.lon01/1533316558.cfg``\n    \"\"\"\n    ret = __salt__['net.config'](source=source)\n    if not ret['result']:\n        return {'name': name, 'changes': {}, 'result': False, 'comment': ret['comment']}\n    return __states__['file.managed'](name, user=user, group=group, mode=mode, attrs=attrs, makedirs=makedirs, dir_mode=dir_mode, replace=replace, backup=backup, show_changes=show_changes, create=create, contents=ret['out'][source], tmp_dir=tmp_dir, tmp_ext=tmp_ext, encoding=encoding, encoding_errors=encoding_errors, allow_empty=allow_empty, follow_symlinks=follow_symlinks, check_cmd=check_cmd, win_owner=win_owner, win_perms=win_perms, win_deny_perms=win_deny_perms, win_inheritance=win_inheritance, win_perms_reset=win_perms_reset, **kwargs)",
        "mutated": [
            "def saved(name, source='running', user=None, group=None, mode=None, attrs=None, makedirs=False, dir_mode=None, replace=True, backup='', show_changes=True, create=True, tmp_dir='', tmp_ext='', encoding=None, encoding_errors='strict', allow_empty=False, follow_symlinks=True, check_cmd=None, win_owner=None, win_perms=None, win_deny_perms=None, win_inheritance=True, win_perms_reset=False, **kwargs):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    name\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    user\\n        The user to own the file, this defaults to the user salt is running as\\n        on the minion\\n\\n    group\\n        The group ownership set for the file, this defaults to the group salt\\n        is running as on the minion. On Windows, this is ignored\\n\\n    mode\\n        The permissions to set on this file, e.g. ``644``, ``0775``, or\\n        ``4664``.\\n        The default mode for new files and directories corresponds to the\\n        umask of the salt process. The mode of existing files and directories\\n        will only be changed if ``mode`` is specified.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n    attrs\\n        The attributes to have on this file, e.g. ``a``, ``i``. The attributes\\n        can be any or a combination of the following characters:\\n        ``aAcCdDeijPsStTu``.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n\\n    makedirs: ``False``\\n        If set to ``True``, then the parent directories will be created to\\n        facilitate the creation of the named file. If ``False``, and the parent\\n        directory of the destination file doesn't exist, the state will fail.\\n\\n    dir_mode\\n        If directories are to be created, passing this option specifies the\\n        permissions for those directories. If this is not set, directories\\n        will be assigned permissions by adding the execute bit to the mode of\\n        the files.\\n\\n        The default mode for new files and directories corresponds umask of salt\\n        process. For existing files and directories it's not enforced.\\n\\n    replace: ``True``\\n        If set to ``False`` and the file already exists, the file will not be\\n        modified even if changes would otherwise be made. Permissions and\\n        ownership will still be enforced, however.\\n\\n    backup\\n        Overrides the default backup mode for this specific file. See\\n        :ref:`backup_mode documentation <file-state-backups>` for more details.\\n\\n    show_changes: ``True``\\n        Output a unified diff of the old file and the new file. If ``False``\\n        return a boolean if any changes were made.\\n\\n    create: ``True``\\n        If set to ``False``, then the file will only be managed if the file\\n        already exists on the system.\\n\\n    encoding\\n        If specified, then the specified encoding will be used. Otherwise, the\\n        file will be encoded using the system locale (usually UTF-8). See\\n        https://docs.python.org/3/library/codecs.html#standard-encodings for\\n        the list of available encodings.\\n\\n    encoding_errors: ``'strict'``\\n        Error encoding scheme. Default is ```'strict'```.\\n        See https://docs.python.org/2/library/codecs.html#codec-base-classes\\n        for the list of available schemes.\\n\\n    allow_empty: ``True``\\n        If set to ``False``, then the state will fail if the contents specified\\n        by ``contents_pillar`` or ``contents_grains`` are empty.\\n\\n    follow_symlinks: ``True``\\n        If the desired path is a symlink follow it and make changes to the\\n        file to which the symlink points.\\n\\n    check_cmd\\n        The specified command will be run with an appended argument of a\\n        *temporary* file containing the new managed contents.  If the command\\n        exits with a zero status the new managed contents will be written to\\n        the managed destination. If the command exits with a nonzero exit\\n        code, the state will fail and no changes will be made to the file.\\n\\n    tmp_dir\\n        Directory for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file location (e.g. daemons restricted to their\\n        own config directories by an apparmor profile).\\n\\n    tmp_ext\\n        Suffix for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file extension (e.g. the init-checkconf upstart\\n        config checker).\\n\\n    win_owner: ``None``\\n        The owner of the directory. If this is not passed, user will be used. If\\n        user is not passed, the account under which Salt is running will be\\n        used.\\n\\n    win_perms: ``None``\\n        A dictionary containing permissions to grant and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_deny_perms: ``None``\\n        A dictionary containing permissions to deny and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_inheritance: ``True``\\n        True to inherit permissions from the parent directory, False not to\\n        inherit permission.\\n\\n    win_perms_reset: ``False``\\n        If ``True`` the existing DACL will be cleared and replaced with the\\n        settings defined in this function. If ``False``, new entries will be\\n        appended to the existing DACL. Default is ``False``.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        /var/backups/{{ opts.id }}/{{ salt.status.time('%s') }}.cfg:\\n          netconfig.saved:\\n            - source: running\\n            - makedirs: true\\n\\n    The state SLS  above would create a backup config grouping the files by the\\n    Minion ID, in chronological files. For example, if the state is executed at\\n    on the 3rd of August 2018, at 5:15PM, on the Minion ``core1.lon01``, the\\n    configuration would saved in the file:\\n    ``/var/backups/core01.lon01/1533316558.cfg``\\n    \"\n    ret = __salt__['net.config'](source=source)\n    if not ret['result']:\n        return {'name': name, 'changes': {}, 'result': False, 'comment': ret['comment']}\n    return __states__['file.managed'](name, user=user, group=group, mode=mode, attrs=attrs, makedirs=makedirs, dir_mode=dir_mode, replace=replace, backup=backup, show_changes=show_changes, create=create, contents=ret['out'][source], tmp_dir=tmp_dir, tmp_ext=tmp_ext, encoding=encoding, encoding_errors=encoding_errors, allow_empty=allow_empty, follow_symlinks=follow_symlinks, check_cmd=check_cmd, win_owner=win_owner, win_perms=win_perms, win_deny_perms=win_deny_perms, win_inheritance=win_inheritance, win_perms_reset=win_perms_reset, **kwargs)",
            "def saved(name, source='running', user=None, group=None, mode=None, attrs=None, makedirs=False, dir_mode=None, replace=True, backup='', show_changes=True, create=True, tmp_dir='', tmp_ext='', encoding=None, encoding_errors='strict', allow_empty=False, follow_symlinks=True, check_cmd=None, win_owner=None, win_perms=None, win_deny_perms=None, win_inheritance=True, win_perms_reset=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    name\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    user\\n        The user to own the file, this defaults to the user salt is running as\\n        on the minion\\n\\n    group\\n        The group ownership set for the file, this defaults to the group salt\\n        is running as on the minion. On Windows, this is ignored\\n\\n    mode\\n        The permissions to set on this file, e.g. ``644``, ``0775``, or\\n        ``4664``.\\n        The default mode for new files and directories corresponds to the\\n        umask of the salt process. The mode of existing files and directories\\n        will only be changed if ``mode`` is specified.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n    attrs\\n        The attributes to have on this file, e.g. ``a``, ``i``. The attributes\\n        can be any or a combination of the following characters:\\n        ``aAcCdDeijPsStTu``.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n\\n    makedirs: ``False``\\n        If set to ``True``, then the parent directories will be created to\\n        facilitate the creation of the named file. If ``False``, and the parent\\n        directory of the destination file doesn't exist, the state will fail.\\n\\n    dir_mode\\n        If directories are to be created, passing this option specifies the\\n        permissions for those directories. If this is not set, directories\\n        will be assigned permissions by adding the execute bit to the mode of\\n        the files.\\n\\n        The default mode for new files and directories corresponds umask of salt\\n        process. For existing files and directories it's not enforced.\\n\\n    replace: ``True``\\n        If set to ``False`` and the file already exists, the file will not be\\n        modified even if changes would otherwise be made. Permissions and\\n        ownership will still be enforced, however.\\n\\n    backup\\n        Overrides the default backup mode for this specific file. See\\n        :ref:`backup_mode documentation <file-state-backups>` for more details.\\n\\n    show_changes: ``True``\\n        Output a unified diff of the old file and the new file. If ``False``\\n        return a boolean if any changes were made.\\n\\n    create: ``True``\\n        If set to ``False``, then the file will only be managed if the file\\n        already exists on the system.\\n\\n    encoding\\n        If specified, then the specified encoding will be used. Otherwise, the\\n        file will be encoded using the system locale (usually UTF-8). See\\n        https://docs.python.org/3/library/codecs.html#standard-encodings for\\n        the list of available encodings.\\n\\n    encoding_errors: ``'strict'``\\n        Error encoding scheme. Default is ```'strict'```.\\n        See https://docs.python.org/2/library/codecs.html#codec-base-classes\\n        for the list of available schemes.\\n\\n    allow_empty: ``True``\\n        If set to ``False``, then the state will fail if the contents specified\\n        by ``contents_pillar`` or ``contents_grains`` are empty.\\n\\n    follow_symlinks: ``True``\\n        If the desired path is a symlink follow it and make changes to the\\n        file to which the symlink points.\\n\\n    check_cmd\\n        The specified command will be run with an appended argument of a\\n        *temporary* file containing the new managed contents.  If the command\\n        exits with a zero status the new managed contents will be written to\\n        the managed destination. If the command exits with a nonzero exit\\n        code, the state will fail and no changes will be made to the file.\\n\\n    tmp_dir\\n        Directory for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file location (e.g. daemons restricted to their\\n        own config directories by an apparmor profile).\\n\\n    tmp_ext\\n        Suffix for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file extension (e.g. the init-checkconf upstart\\n        config checker).\\n\\n    win_owner: ``None``\\n        The owner of the directory. If this is not passed, user will be used. If\\n        user is not passed, the account under which Salt is running will be\\n        used.\\n\\n    win_perms: ``None``\\n        A dictionary containing permissions to grant and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_deny_perms: ``None``\\n        A dictionary containing permissions to deny and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_inheritance: ``True``\\n        True to inherit permissions from the parent directory, False not to\\n        inherit permission.\\n\\n    win_perms_reset: ``False``\\n        If ``True`` the existing DACL will be cleared and replaced with the\\n        settings defined in this function. If ``False``, new entries will be\\n        appended to the existing DACL. Default is ``False``.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        /var/backups/{{ opts.id }}/{{ salt.status.time('%s') }}.cfg:\\n          netconfig.saved:\\n            - source: running\\n            - makedirs: true\\n\\n    The state SLS  above would create a backup config grouping the files by the\\n    Minion ID, in chronological files. For example, if the state is executed at\\n    on the 3rd of August 2018, at 5:15PM, on the Minion ``core1.lon01``, the\\n    configuration would saved in the file:\\n    ``/var/backups/core01.lon01/1533316558.cfg``\\n    \"\n    ret = __salt__['net.config'](source=source)\n    if not ret['result']:\n        return {'name': name, 'changes': {}, 'result': False, 'comment': ret['comment']}\n    return __states__['file.managed'](name, user=user, group=group, mode=mode, attrs=attrs, makedirs=makedirs, dir_mode=dir_mode, replace=replace, backup=backup, show_changes=show_changes, create=create, contents=ret['out'][source], tmp_dir=tmp_dir, tmp_ext=tmp_ext, encoding=encoding, encoding_errors=encoding_errors, allow_empty=allow_empty, follow_symlinks=follow_symlinks, check_cmd=check_cmd, win_owner=win_owner, win_perms=win_perms, win_deny_perms=win_deny_perms, win_inheritance=win_inheritance, win_perms_reset=win_perms_reset, **kwargs)",
            "def saved(name, source='running', user=None, group=None, mode=None, attrs=None, makedirs=False, dir_mode=None, replace=True, backup='', show_changes=True, create=True, tmp_dir='', tmp_ext='', encoding=None, encoding_errors='strict', allow_empty=False, follow_symlinks=True, check_cmd=None, win_owner=None, win_perms=None, win_deny_perms=None, win_inheritance=True, win_perms_reset=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    name\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    user\\n        The user to own the file, this defaults to the user salt is running as\\n        on the minion\\n\\n    group\\n        The group ownership set for the file, this defaults to the group salt\\n        is running as on the minion. On Windows, this is ignored\\n\\n    mode\\n        The permissions to set on this file, e.g. ``644``, ``0775``, or\\n        ``4664``.\\n        The default mode for new files and directories corresponds to the\\n        umask of the salt process. The mode of existing files and directories\\n        will only be changed if ``mode`` is specified.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n    attrs\\n        The attributes to have on this file, e.g. ``a``, ``i``. The attributes\\n        can be any or a combination of the following characters:\\n        ``aAcCdDeijPsStTu``.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n\\n    makedirs: ``False``\\n        If set to ``True``, then the parent directories will be created to\\n        facilitate the creation of the named file. If ``False``, and the parent\\n        directory of the destination file doesn't exist, the state will fail.\\n\\n    dir_mode\\n        If directories are to be created, passing this option specifies the\\n        permissions for those directories. If this is not set, directories\\n        will be assigned permissions by adding the execute bit to the mode of\\n        the files.\\n\\n        The default mode for new files and directories corresponds umask of salt\\n        process. For existing files and directories it's not enforced.\\n\\n    replace: ``True``\\n        If set to ``False`` and the file already exists, the file will not be\\n        modified even if changes would otherwise be made. Permissions and\\n        ownership will still be enforced, however.\\n\\n    backup\\n        Overrides the default backup mode for this specific file. See\\n        :ref:`backup_mode documentation <file-state-backups>` for more details.\\n\\n    show_changes: ``True``\\n        Output a unified diff of the old file and the new file. If ``False``\\n        return a boolean if any changes were made.\\n\\n    create: ``True``\\n        If set to ``False``, then the file will only be managed if the file\\n        already exists on the system.\\n\\n    encoding\\n        If specified, then the specified encoding will be used. Otherwise, the\\n        file will be encoded using the system locale (usually UTF-8). See\\n        https://docs.python.org/3/library/codecs.html#standard-encodings for\\n        the list of available encodings.\\n\\n    encoding_errors: ``'strict'``\\n        Error encoding scheme. Default is ```'strict'```.\\n        See https://docs.python.org/2/library/codecs.html#codec-base-classes\\n        for the list of available schemes.\\n\\n    allow_empty: ``True``\\n        If set to ``False``, then the state will fail if the contents specified\\n        by ``contents_pillar`` or ``contents_grains`` are empty.\\n\\n    follow_symlinks: ``True``\\n        If the desired path is a symlink follow it and make changes to the\\n        file to which the symlink points.\\n\\n    check_cmd\\n        The specified command will be run with an appended argument of a\\n        *temporary* file containing the new managed contents.  If the command\\n        exits with a zero status the new managed contents will be written to\\n        the managed destination. If the command exits with a nonzero exit\\n        code, the state will fail and no changes will be made to the file.\\n\\n    tmp_dir\\n        Directory for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file location (e.g. daemons restricted to their\\n        own config directories by an apparmor profile).\\n\\n    tmp_ext\\n        Suffix for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file extension (e.g. the init-checkconf upstart\\n        config checker).\\n\\n    win_owner: ``None``\\n        The owner of the directory. If this is not passed, user will be used. If\\n        user is not passed, the account under which Salt is running will be\\n        used.\\n\\n    win_perms: ``None``\\n        A dictionary containing permissions to grant and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_deny_perms: ``None``\\n        A dictionary containing permissions to deny and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_inheritance: ``True``\\n        True to inherit permissions from the parent directory, False not to\\n        inherit permission.\\n\\n    win_perms_reset: ``False``\\n        If ``True`` the existing DACL will be cleared and replaced with the\\n        settings defined in this function. If ``False``, new entries will be\\n        appended to the existing DACL. Default is ``False``.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        /var/backups/{{ opts.id }}/{{ salt.status.time('%s') }}.cfg:\\n          netconfig.saved:\\n            - source: running\\n            - makedirs: true\\n\\n    The state SLS  above would create a backup config grouping the files by the\\n    Minion ID, in chronological files. For example, if the state is executed at\\n    on the 3rd of August 2018, at 5:15PM, on the Minion ``core1.lon01``, the\\n    configuration would saved in the file:\\n    ``/var/backups/core01.lon01/1533316558.cfg``\\n    \"\n    ret = __salt__['net.config'](source=source)\n    if not ret['result']:\n        return {'name': name, 'changes': {}, 'result': False, 'comment': ret['comment']}\n    return __states__['file.managed'](name, user=user, group=group, mode=mode, attrs=attrs, makedirs=makedirs, dir_mode=dir_mode, replace=replace, backup=backup, show_changes=show_changes, create=create, contents=ret['out'][source], tmp_dir=tmp_dir, tmp_ext=tmp_ext, encoding=encoding, encoding_errors=encoding_errors, allow_empty=allow_empty, follow_symlinks=follow_symlinks, check_cmd=check_cmd, win_owner=win_owner, win_perms=win_perms, win_deny_perms=win_deny_perms, win_inheritance=win_inheritance, win_perms_reset=win_perms_reset, **kwargs)",
            "def saved(name, source='running', user=None, group=None, mode=None, attrs=None, makedirs=False, dir_mode=None, replace=True, backup='', show_changes=True, create=True, tmp_dir='', tmp_ext='', encoding=None, encoding_errors='strict', allow_empty=False, follow_symlinks=True, check_cmd=None, win_owner=None, win_perms=None, win_deny_perms=None, win_inheritance=True, win_perms_reset=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    name\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    user\\n        The user to own the file, this defaults to the user salt is running as\\n        on the minion\\n\\n    group\\n        The group ownership set for the file, this defaults to the group salt\\n        is running as on the minion. On Windows, this is ignored\\n\\n    mode\\n        The permissions to set on this file, e.g. ``644``, ``0775``, or\\n        ``4664``.\\n        The default mode for new files and directories corresponds to the\\n        umask of the salt process. The mode of existing files and directories\\n        will only be changed if ``mode`` is specified.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n    attrs\\n        The attributes to have on this file, e.g. ``a``, ``i``. The attributes\\n        can be any or a combination of the following characters:\\n        ``aAcCdDeijPsStTu``.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n\\n    makedirs: ``False``\\n        If set to ``True``, then the parent directories will be created to\\n        facilitate the creation of the named file. If ``False``, and the parent\\n        directory of the destination file doesn't exist, the state will fail.\\n\\n    dir_mode\\n        If directories are to be created, passing this option specifies the\\n        permissions for those directories. If this is not set, directories\\n        will be assigned permissions by adding the execute bit to the mode of\\n        the files.\\n\\n        The default mode for new files and directories corresponds umask of salt\\n        process. For existing files and directories it's not enforced.\\n\\n    replace: ``True``\\n        If set to ``False`` and the file already exists, the file will not be\\n        modified even if changes would otherwise be made. Permissions and\\n        ownership will still be enforced, however.\\n\\n    backup\\n        Overrides the default backup mode for this specific file. See\\n        :ref:`backup_mode documentation <file-state-backups>` for more details.\\n\\n    show_changes: ``True``\\n        Output a unified diff of the old file and the new file. If ``False``\\n        return a boolean if any changes were made.\\n\\n    create: ``True``\\n        If set to ``False``, then the file will only be managed if the file\\n        already exists on the system.\\n\\n    encoding\\n        If specified, then the specified encoding will be used. Otherwise, the\\n        file will be encoded using the system locale (usually UTF-8). See\\n        https://docs.python.org/3/library/codecs.html#standard-encodings for\\n        the list of available encodings.\\n\\n    encoding_errors: ``'strict'``\\n        Error encoding scheme. Default is ```'strict'```.\\n        See https://docs.python.org/2/library/codecs.html#codec-base-classes\\n        for the list of available schemes.\\n\\n    allow_empty: ``True``\\n        If set to ``False``, then the state will fail if the contents specified\\n        by ``contents_pillar`` or ``contents_grains`` are empty.\\n\\n    follow_symlinks: ``True``\\n        If the desired path is a symlink follow it and make changes to the\\n        file to which the symlink points.\\n\\n    check_cmd\\n        The specified command will be run with an appended argument of a\\n        *temporary* file containing the new managed contents.  If the command\\n        exits with a zero status the new managed contents will be written to\\n        the managed destination. If the command exits with a nonzero exit\\n        code, the state will fail and no changes will be made to the file.\\n\\n    tmp_dir\\n        Directory for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file location (e.g. daemons restricted to their\\n        own config directories by an apparmor profile).\\n\\n    tmp_ext\\n        Suffix for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file extension (e.g. the init-checkconf upstart\\n        config checker).\\n\\n    win_owner: ``None``\\n        The owner of the directory. If this is not passed, user will be used. If\\n        user is not passed, the account under which Salt is running will be\\n        used.\\n\\n    win_perms: ``None``\\n        A dictionary containing permissions to grant and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_deny_perms: ``None``\\n        A dictionary containing permissions to deny and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_inheritance: ``True``\\n        True to inherit permissions from the parent directory, False not to\\n        inherit permission.\\n\\n    win_perms_reset: ``False``\\n        If ``True`` the existing DACL will be cleared and replaced with the\\n        settings defined in this function. If ``False``, new entries will be\\n        appended to the existing DACL. Default is ``False``.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        /var/backups/{{ opts.id }}/{{ salt.status.time('%s') }}.cfg:\\n          netconfig.saved:\\n            - source: running\\n            - makedirs: true\\n\\n    The state SLS  above would create a backup config grouping the files by the\\n    Minion ID, in chronological files. For example, if the state is executed at\\n    on the 3rd of August 2018, at 5:15PM, on the Minion ``core1.lon01``, the\\n    configuration would saved in the file:\\n    ``/var/backups/core01.lon01/1533316558.cfg``\\n    \"\n    ret = __salt__['net.config'](source=source)\n    if not ret['result']:\n        return {'name': name, 'changes': {}, 'result': False, 'comment': ret['comment']}\n    return __states__['file.managed'](name, user=user, group=group, mode=mode, attrs=attrs, makedirs=makedirs, dir_mode=dir_mode, replace=replace, backup=backup, show_changes=show_changes, create=create, contents=ret['out'][source], tmp_dir=tmp_dir, tmp_ext=tmp_ext, encoding=encoding, encoding_errors=encoding_errors, allow_empty=allow_empty, follow_symlinks=follow_symlinks, check_cmd=check_cmd, win_owner=win_owner, win_perms=win_perms, win_deny_perms=win_deny_perms, win_inheritance=win_inheritance, win_perms_reset=win_perms_reset, **kwargs)",
            "def saved(name, source='running', user=None, group=None, mode=None, attrs=None, makedirs=False, dir_mode=None, replace=True, backup='', show_changes=True, create=True, tmp_dir='', tmp_ext='', encoding=None, encoding_errors='strict', allow_empty=False, follow_symlinks=True, check_cmd=None, win_owner=None, win_perms=None, win_deny_perms=None, win_inheritance=True, win_perms_reset=False, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Save the configuration to a file on the local file system.\\n\\n    name\\n        Absolute path to file where to save the configuration.\\n        To push the files to the Master, use\\n        :mod:`cp.push <salt.modules.cp.push>` Execution function.\\n\\n    source: ``running``\\n        The configuration source. Choose from: ``running``, ``candidate``,\\n        ``startup``. Default: ``running``.\\n\\n    user\\n        The user to own the file, this defaults to the user salt is running as\\n        on the minion\\n\\n    group\\n        The group ownership set for the file, this defaults to the group salt\\n        is running as on the minion. On Windows, this is ignored\\n\\n    mode\\n        The permissions to set on this file, e.g. ``644``, ``0775``, or\\n        ``4664``.\\n        The default mode for new files and directories corresponds to the\\n        umask of the salt process. The mode of existing files and directories\\n        will only be changed if ``mode`` is specified.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n    attrs\\n        The attributes to have on this file, e.g. ``a``, ``i``. The attributes\\n        can be any or a combination of the following characters:\\n        ``aAcCdDeijPsStTu``.\\n\\n        .. note::\\n            This option is **not** supported on Windows.\\n\\n    makedirs: ``False``\\n        If set to ``True``, then the parent directories will be created to\\n        facilitate the creation of the named file. If ``False``, and the parent\\n        directory of the destination file doesn't exist, the state will fail.\\n\\n    dir_mode\\n        If directories are to be created, passing this option specifies the\\n        permissions for those directories. If this is not set, directories\\n        will be assigned permissions by adding the execute bit to the mode of\\n        the files.\\n\\n        The default mode for new files and directories corresponds umask of salt\\n        process. For existing files and directories it's not enforced.\\n\\n    replace: ``True``\\n        If set to ``False`` and the file already exists, the file will not be\\n        modified even if changes would otherwise be made. Permissions and\\n        ownership will still be enforced, however.\\n\\n    backup\\n        Overrides the default backup mode for this specific file. See\\n        :ref:`backup_mode documentation <file-state-backups>` for more details.\\n\\n    show_changes: ``True``\\n        Output a unified diff of the old file and the new file. If ``False``\\n        return a boolean if any changes were made.\\n\\n    create: ``True``\\n        If set to ``False``, then the file will only be managed if the file\\n        already exists on the system.\\n\\n    encoding\\n        If specified, then the specified encoding will be used. Otherwise, the\\n        file will be encoded using the system locale (usually UTF-8). See\\n        https://docs.python.org/3/library/codecs.html#standard-encodings for\\n        the list of available encodings.\\n\\n    encoding_errors: ``'strict'``\\n        Error encoding scheme. Default is ```'strict'```.\\n        See https://docs.python.org/2/library/codecs.html#codec-base-classes\\n        for the list of available schemes.\\n\\n    allow_empty: ``True``\\n        If set to ``False``, then the state will fail if the contents specified\\n        by ``contents_pillar`` or ``contents_grains`` are empty.\\n\\n    follow_symlinks: ``True``\\n        If the desired path is a symlink follow it and make changes to the\\n        file to which the symlink points.\\n\\n    check_cmd\\n        The specified command will be run with an appended argument of a\\n        *temporary* file containing the new managed contents.  If the command\\n        exits with a zero status the new managed contents will be written to\\n        the managed destination. If the command exits with a nonzero exit\\n        code, the state will fail and no changes will be made to the file.\\n\\n    tmp_dir\\n        Directory for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file location (e.g. daemons restricted to their\\n        own config directories by an apparmor profile).\\n\\n    tmp_ext\\n        Suffix for temp file created by ``check_cmd``. Useful for checkers\\n        dependent on config file extension (e.g. the init-checkconf upstart\\n        config checker).\\n\\n    win_owner: ``None``\\n        The owner of the directory. If this is not passed, user will be used. If\\n        user is not passed, the account under which Salt is running will be\\n        used.\\n\\n    win_perms: ``None``\\n        A dictionary containing permissions to grant and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_deny_perms: ``None``\\n        A dictionary containing permissions to deny and their propagation. For\\n        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a\\n        single basic perm or a list of advanced perms. ``perms`` must be\\n        specified. ``applies_to`` does not apply to file objects.\\n\\n    win_inheritance: ``True``\\n        True to inherit permissions from the parent directory, False not to\\n        inherit permission.\\n\\n    win_perms_reset: ``False``\\n        If ``True`` the existing DACL will be cleared and replaced with the\\n        settings defined in this function. If ``False``, new entries will be\\n        appended to the existing DACL. Default is ``False``.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        /var/backups/{{ opts.id }}/{{ salt.status.time('%s') }}.cfg:\\n          netconfig.saved:\\n            - source: running\\n            - makedirs: true\\n\\n    The state SLS  above would create a backup config grouping the files by the\\n    Minion ID, in chronological files. For example, if the state is executed at\\n    on the 3rd of August 2018, at 5:15PM, on the Minion ``core1.lon01``, the\\n    configuration would saved in the file:\\n    ``/var/backups/core01.lon01/1533316558.cfg``\\n    \"\n    ret = __salt__['net.config'](source=source)\n    if not ret['result']:\n        return {'name': name, 'changes': {}, 'result': False, 'comment': ret['comment']}\n    return __states__['file.managed'](name, user=user, group=group, mode=mode, attrs=attrs, makedirs=makedirs, dir_mode=dir_mode, replace=replace, backup=backup, show_changes=show_changes, create=create, contents=ret['out'][source], tmp_dir=tmp_dir, tmp_ext=tmp_ext, encoding=encoding, encoding_errors=encoding_errors, allow_empty=allow_empty, follow_symlinks=follow_symlinks, check_cmd=check_cmd, win_owner=win_owner, win_perms=win_perms, win_deny_perms=win_deny_perms, win_inheritance=win_inheritance, win_perms_reset=win_perms_reset, **kwargs)"
        ]
    },
    {
        "func_name": "managed",
        "original": "def managed(name, template_name=None, template_source=None, template_hash=None, template_hash_name=None, saltenv='base', template_engine='jinja', skip_verify=False, context=None, defaults=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, **template_vars):\n    \"\"\"\n    Manages the configuration on network devices.\n\n    By default this state will commit the changes on the device. If there are no changes required, it does not commit\n    and the field ``already_configured`` from the output dictionary will be set as ``True`` to notify that.\n\n    To avoid committing the configuration, set the argument ``test`` to ``True`` (or via the CLI argument ``test=True``)\n    and will discard (dry run).\n\n    To preserve the changes, set ``commit`` to ``False`` (either as CLI argument, either as state parameter).\n    However, this is recommended to be used only in exceptional cases when there are applied few consecutive states\n    and/or configuration changes. Otherwise the user might forget that the config DB is locked and the candidate config\n    buffer is not cleared/merged in the running config.\n\n    To replace the config, set ``replace`` to ``True``. This option is recommended to be used with caution!\n\n    template_name\n        Identifies path to the template source. The template can be either stored on the local machine,\n        either remotely.\n        The recommended location is under the ``file_roots`` as specified in the master config file.\n        For example, let's suppose the ``file_roots`` is configured as:\n\n        .. code-block:: yaml\n\n            file_roots:\n              base:\n                 - /etc/salt/states\n\n        Placing the template under ``/etc/salt/states/templates/example.jinja``, it can be used as\n        ``salt://templates/example.jinja``.\n        Alternatively, for local files, the user can specify the absolute path.\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\n\n        Examples:\n\n        - ``salt://my_template.jinja``\n        - ``/absolute/path/to/my_template.jinja``\n        - ``http://example.com/template.cheetah``\n        - ``https:/example.com/template.mako``\n        - ``ftp://example.com/template.py``\n\n        .. versionchanged:: 2019.2.0\n            This argument can now support a list of templates to be rendered.\n            The resulting configuration text is loaded at once, as a single\n            configuration chunk.\n\n    template_source: None\n        Inline config template to be rendered and loaded on the device.\n\n    template_hash: None\n        Hash of the template file. Format: ``{hash_type: 'md5', 'hsum': <md5sum>}``\n\n    template_hash_name: None\n        When ``template_hash`` refers to a remote file, this specifies the filename to look for in that file.\n\n    saltenv: base\n        Specifies the template environment. This will influence the relative imports inside the templates.\n\n    template_engine: jinja\n        The following templates engines are supported:\n\n        - :mod:`cheetah<salt.renderers.cheetah>`\n        - :mod:`genshi<salt.renderers.genshi>`\n        - :mod:`jinja<salt.renderers.jinja>`\n        - :mod:`mako<salt.renderers.mako>`\n        - :mod:`py<salt.renderers.py>`\n        - :mod:`wempy<salt.renderers.wempy>`\n\n    skip_verify: False\n        If ``True``, hash verification of remote file sources (``http://``, ``https://``, ``ftp://``) will be skipped,\n        and the ``source_hash`` argument will be ignored.\n\n        .. versionchanged:: 2017.7.1\n\n    test: False\n        Dry run? If set to ``True``, will apply the config, discard and return the changes. Default: ``False``\n        (will commit the changes on the device).\n\n    commit: True\n        Commit? Default: ``True``.\n\n    debug: False\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\n        result after the template was rendered.\n\n        .. note::\n            This argument cannot be used directly on the command line. Instead,\n            it can be passed through the ``pillar`` variable when executing\n            either of the :py:func:`state.sls <salt.modules.state.sls>` or\n            :py:func:`state.apply <salt.modules.state.apply>` (see below for an\n            example).\n\n    commit_in: ``None``\n        Commit the changes in a specific number of minutes / hours. Example of\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\n        the changes in 5 hours and 30 minutes).\n\n        .. note::\n            This feature works on any platforms, as it does not rely on the\n            native features of the network operating system.\n\n        .. note::\n            After the command is executed and the ``diff`` is not satisfactory,\n            or for any other reasons you have to discard the commit, you are\n            able to do so using the\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\n            execution function, using the commit ID returned by this function.\n\n        .. warning::\n            Using this feature, Salt will load the exact configuration you\n            expect, however the diff may change in time (i.e., if an user\n            applies a manual configuration change, or a different process or\n            command changes the configuration in the meanwhile).\n\n        .. versionadded:: 2019.2.0\n\n    commit_at: ``None``\n        Commit the changes at a specific time. Example of accepted formats:\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\n        commit at 13:20), ``1:20am``, etc.\n\n        .. note::\n            This feature works on any platforms, as it does not rely on the\n            native features of the network operating system.\n\n        .. note::\n            After the command is executed and the ``diff`` is not satisfactory,\n            or for any other reasons you have to discard the commit, you are\n            able to do so using the\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\n            execution function, using the commit ID returned by this function.\n\n        .. warning::\n            Using this feature, Salt will load the exact configuration you\n            expect, however the diff may change in time (i.e., if an user\n            applies a manual configuration change, or a different process or\n            command changes the configuration in the meanwhile).\n\n        .. versionadded:: 2019.2.0\n\n    revert_in: ``None``\n        Commit and revert the changes in a specific number of minutes / hours.\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\n        the changes in 5 hours and 30 minutes).\n\n        .. note::\n            To confirm the commit, and prevent reverting the changes, you will\n            have to execute the\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\n            function, using the commit ID returned by this function.\n\n        .. warning::\n            This works on any platform, regardless if they have or don't have\n            native capabilities to confirming a commit. However, please be\n            *very* cautious when using this feature: on Junos (as it is the only\n            NAPALM core platform supporting this natively) it executes a commit\n            confirmed as you would do from the command line.\n            All the other platforms don't have this capability natively,\n            therefore the revert is done via Salt. That means, your device needs\n            to be reachable at the moment when Salt will attempt to revert your\n            changes. Be cautious when pushing configuration changes that would\n            prevent you reach the device.\n\n            Similarly, if an user or a different process apply other\n            configuration changes in the meanwhile (between the moment you\n            commit and till the changes are reverted), these changes would be\n            equally reverted, as Salt cannot be aware of them.\n\n        .. versionadded:: 2019.2.0\n\n    revert_at: ``None``\n        Commit and revert the changes at a specific time. Example of accepted\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\n\n        .. note::\n            To confirm the commit, and prevent reverting the changes, you will\n            have to execute the\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\n            function, using the commit ID returned by this function.\n\n        .. warning::\n            This works on any platform, regardless if they have or don't have\n            native capabilities to confirming a commit. However, please be\n            *very* cautious when using this feature: on Junos (as it is the only\n            NAPALM core platform supporting this natively) it executes a commit\n            confirmed as you would do from the command line.\n            All the other platforms don't have this capability natively,\n            therefore the revert is done via Salt. That means, your device needs\n            to be reachable at the moment when Salt will attempt to revert your\n            changes. Be cautious when pushing configuration changes that would\n            prevent you reach the device.\n\n            Similarly, if an user or a different process apply other\n            configuration changes in the meanwhile (between the moment you\n            commit and till the changes are reverted), these changes would be\n            equally reverted, as Salt cannot be aware of them.\n\n        .. versionadded:: 2019.2.0\n\n    replace: False\n        Load and replace the configuration. Default: ``False`` (will apply load merge).\n\n    context: None\n        Overrides default context variables passed to the template.\n\n        .. versionadded:: 2019.2.0\n\n    defaults: None\n        Default variables/context passed to the template.\n\n    template_vars\n        Dictionary with the arguments/context to be used when the template is rendered. Do not explicitly specify this\n        argument. This represents any other variable that will be sent to the template rendering system. Please\n        see an example below! In both ``ntp_peers_example_using_pillar`` and ``ntp_peers_example``, ``peers`` is sent as\n        template variable.\n\n        .. note::\n            It is more recommended to use the ``context`` argument instead, to\n            avoid any conflicts with other arguments.\n\n    SLS Example (e.g.: under salt://router/config.sls) :\n\n    .. code-block:: yaml\n\n        whole_config_example:\n            netconfig.managed:\n                - template_name: salt://path/to/complete_config.jinja\n                - debug: True\n                - replace: True\n        bgp_config_example:\n            netconfig.managed:\n                - template_name: /absolute/path/to/bgp_neighbors.mako\n                - template_engine: mako\n        prefix_lists_example:\n            netconfig.managed:\n                - template_name: prefix_lists.cheetah\n                - debug: True\n                - template_engine: cheetah\n        ntp_peers_example:\n            netconfig.managed:\n                - template_name: http://bit.ly/2gKOj20\n                - skip_verify: False\n                - debug: True\n                - peers:\n                    - 192.168.0.1\n                    - 192.168.0.1\n        ntp_peers_example_using_pillar:\n            netconfig.managed:\n                - template_name: http://bit.ly/2gKOj20\n                - peers: {{ pillar.get('ntp.peers', []) }}\n\n    Multi template example:\n\n    .. code-block:: yaml\n\n        hostname_and_ntp:\n          netconfig.managed:\n            - template_name:\n                - https://bit.ly/2OhSgqP\n                - https://bit.ly/2M6C4Lx\n                - https://bit.ly/2OIWVTs\n            - debug: true\n            - context:\n                hostname: {{ opts.id }}\n                servers:\n                  - 172.17.17.1\n                  - 172.17.17.2\n                peers:\n                  - 192.168.0.1\n                  - 192.168.0.2\n\n    Usage examples:\n\n    .. code-block:: bash\n\n        $ sudo salt 'juniper.device' state.sls router.config test=True\n\n        $ sudo salt -N all-routers state.sls router.config pillar=\"{'debug': True}\"\n\n    ``router.config`` depends on the location of the SLS file (see above). Running this command, will be executed all\n    five steps from above. These examples above are not meant to be used in a production environment, their sole purpose\n    is to provide usage examples.\n\n    Output example:\n\n    .. code-block:: bash\n\n        $ sudo salt 'juniper.device' state.sls router.config test=True\n        juniper.device:\n        ----------\n                  ID: ntp_peers_example_using_pillar\n            Function: netconfig.managed\n              Result: None\n             Comment: Testing mode: Configuration discarded.\n             Started: 12:01:40.744535\n            Duration: 8755.788 ms\n             Changes:\n                      ----------\n                      diff:\n                          [edit system ntp]\n                               peer 192.168.0.1 { ... }\n                          +    peer 172.17.17.1;\n                          +    peer 172.17.17.3;\n\n        Summary for juniper.device\n        ------------\n        Succeeded: 1 (unchanged=1, changed=1)\n        Failed:    0\n        ------------\n        Total states run:     1\n        Total run time:   8.756 s\n\n    Raw output example (useful when the output is reused in other states/execution modules):\n\n    .. code-block:: bash\n\n        $ sudo salt --out=pprint 'juniper.device' state.sls router.config test=True debug=True\n\n    .. code-block:: python\n\n        {\n            'juniper.device': {\n                'netconfig_|-ntp_peers_example_using_pillar_|-ntp_peers_example_using_pillar_|-managed': {\n                    '__id__': 'ntp_peers_example_using_pillar',\n                    '__run_num__': 0,\n                    'already_configured': False,\n                    'changes': {\n                        'diff': '[edit system ntp]   peer 192.168.0.1 { ... }+   peer 172.17.17.1;+   peer 172.17.17.3;'\n                    },\n                    'comment': 'Testing mode: Configuration discarded.',\n                    'duration': 7400.759,\n                    'loaded_config': 'system {  ntp {  peer 172.17.17.1;  peer 172.17.17.3; } }',\n                    'name': 'ntp_peers_example_using_pillar',\n                    'result': None,\n                    'start_time': '12:09:09.811445'\n                }\n            }\n        }\n    \"\"\"\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    skip_verify = __salt__['config.merge']('skip_verify', skip_verify)\n    commit_in = __salt__['config.merge']('commit_in', commit_in)\n    commit_at = __salt__['config.merge']('commit_at', commit_at)\n    revert_in = __salt__['config.merge']('revert_in', revert_in)\n    revert_at = __salt__['config.merge']('revert_at', revert_at)\n    config_update_ret = _update_config(template_name=template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, context=context, defaults=defaults, test=test, commit=commit, commit_in=commit_in, commit_at=commit_at, revert_in=revert_in, revert_at=revert_at, debug=debug, replace=replace, **template_vars)\n    return salt.utils.napalm.loaded_ret(ret, config_update_ret, test, debug)",
        "mutated": [
            "def managed(name, template_name=None, template_source=None, template_hash=None, template_hash_name=None, saltenv='base', template_engine='jinja', skip_verify=False, context=None, defaults=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, **template_vars):\n    if False:\n        i = 10\n    '\\n    Manages the configuration on network devices.\\n\\n    By default this state will commit the changes on the device. If there are no changes required, it does not commit\\n    and the field ``already_configured`` from the output dictionary will be set as ``True`` to notify that.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` (or via the CLI argument ``test=True``)\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False`` (either as CLI argument, either as state parameter).\\n    However, this is recommended to be used only in exceptional cases when there are applied few consecutive states\\n    and/or configuration changes. Otherwise the user might forget that the config DB is locked and the candidate config\\n    buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``. This option is recommended to be used with caution!\\n\\n    template_name\\n        Identifies path to the template source. The template can be either stored on the local machine,\\n        either remotely.\\n        The recommended location is under the ``file_roots`` as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                 - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``, it can be used as\\n        ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file, this specifies the filename to look for in that file.\\n\\n    saltenv: base\\n        Specifies the template environment. This will influence the relative imports inside the templates.\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n    skip_verify: False\\n        If ``True``, hash verification of remote file sources (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionchanged:: 2017.7.1\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        (will commit the changes on the device).\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        result after the template was rendered.\\n\\n        .. note::\\n            This argument cannot be used directly on the command line. Instead,\\n            it can be passed through the ``pillar`` variable when executing\\n            either of the :py:func:`state.sls <salt.modules.state.sls>` or\\n            :py:func:`state.apply <salt.modules.state.apply>` (see below for an\\n            example).\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False`` (will apply load merge).\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered. Do not explicitly specify this\\n        argument. This represents any other variable that will be sent to the template rendering system. Please\\n        see an example below! In both ``ntp_peers_example_using_pillar`` and ``ntp_peers_example``, ``peers`` is sent as\\n        template variable.\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument instead, to\\n            avoid any conflicts with other arguments.\\n\\n    SLS Example (e.g.: under salt://router/config.sls) :\\n\\n    .. code-block:: yaml\\n\\n        whole_config_example:\\n            netconfig.managed:\\n                - template_name: salt://path/to/complete_config.jinja\\n                - debug: True\\n                - replace: True\\n        bgp_config_example:\\n            netconfig.managed:\\n                - template_name: /absolute/path/to/bgp_neighbors.mako\\n                - template_engine: mako\\n        prefix_lists_example:\\n            netconfig.managed:\\n                - template_name: prefix_lists.cheetah\\n                - debug: True\\n                - template_engine: cheetah\\n        ntp_peers_example:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - skip_verify: False\\n                - debug: True\\n                - peers:\\n                    - 192.168.0.1\\n                    - 192.168.0.1\\n        ntp_peers_example_using_pillar:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - peers: {{ pillar.get(\\'ntp.peers\\', []) }}\\n\\n    Multi template example:\\n\\n    .. code-block:: yaml\\n\\n        hostname_and_ntp:\\n          netconfig.managed:\\n            - template_name:\\n                - https://bit.ly/2OhSgqP\\n                - https://bit.ly/2M6C4Lx\\n                - https://bit.ly/2OIWVTs\\n            - debug: true\\n            - context:\\n                hostname: {{ opts.id }}\\n                servers:\\n                  - 172.17.17.1\\n                  - 172.17.17.2\\n                peers:\\n                  - 192.168.0.1\\n                  - 192.168.0.2\\n\\n    Usage examples:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n\\n        $ sudo salt -N all-routers state.sls router.config pillar=\"{\\'debug\\': True}\"\\n\\n    ``router.config`` depends on the location of the SLS file (see above). Running this command, will be executed all\\n    five steps from above. These examples above are not meant to be used in a production environment, their sole purpose\\n    is to provide usage examples.\\n\\n    Output example:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n        juniper.device:\\n        ----------\\n                  ID: ntp_peers_example_using_pillar\\n            Function: netconfig.managed\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:01:40.744535\\n            Duration: 8755.788 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit system ntp]\\n                               peer 192.168.0.1 { ... }\\n                          +    peer 172.17.17.1;\\n                          +    peer 172.17.17.3;\\n\\n        Summary for juniper.device\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   8.756 s\\n\\n    Raw output example (useful when the output is reused in other states/execution modules):\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt --out=pprint \\'juniper.device\\' state.sls router.config test=True debug=True\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'juniper.device\\': {\\n                \\'netconfig_|-ntp_peers_example_using_pillar_|-ntp_peers_example_using_pillar_|-managed\\': {\\n                    \\'__id__\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'__run_num__\\': 0,\\n                    \\'already_configured\\': False,\\n                    \\'changes\\': {\\n                        \\'diff\\': \\'[edit system ntp]   peer 192.168.0.1 { ... }+   peer 172.17.17.1;+   peer 172.17.17.3;\\'\\n                    },\\n                    \\'comment\\': \\'Testing mode: Configuration discarded.\\',\\n                    \\'duration\\': 7400.759,\\n                    \\'loaded_config\\': \\'system {  ntp {  peer 172.17.17.1;  peer 172.17.17.3; } }\\',\\n                    \\'name\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'result\\': None,\\n                    \\'start_time\\': \\'12:09:09.811445\\'\\n                }\\n            }\\n        }\\n    '\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    skip_verify = __salt__['config.merge']('skip_verify', skip_verify)\n    commit_in = __salt__['config.merge']('commit_in', commit_in)\n    commit_at = __salt__['config.merge']('commit_at', commit_at)\n    revert_in = __salt__['config.merge']('revert_in', revert_in)\n    revert_at = __salt__['config.merge']('revert_at', revert_at)\n    config_update_ret = _update_config(template_name=template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, context=context, defaults=defaults, test=test, commit=commit, commit_in=commit_in, commit_at=commit_at, revert_in=revert_in, revert_at=revert_at, debug=debug, replace=replace, **template_vars)\n    return salt.utils.napalm.loaded_ret(ret, config_update_ret, test, debug)",
            "def managed(name, template_name=None, template_source=None, template_hash=None, template_hash_name=None, saltenv='base', template_engine='jinja', skip_verify=False, context=None, defaults=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Manages the configuration on network devices.\\n\\n    By default this state will commit the changes on the device. If there are no changes required, it does not commit\\n    and the field ``already_configured`` from the output dictionary will be set as ``True`` to notify that.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` (or via the CLI argument ``test=True``)\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False`` (either as CLI argument, either as state parameter).\\n    However, this is recommended to be used only in exceptional cases when there are applied few consecutive states\\n    and/or configuration changes. Otherwise the user might forget that the config DB is locked and the candidate config\\n    buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``. This option is recommended to be used with caution!\\n\\n    template_name\\n        Identifies path to the template source. The template can be either stored on the local machine,\\n        either remotely.\\n        The recommended location is under the ``file_roots`` as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                 - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``, it can be used as\\n        ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file, this specifies the filename to look for in that file.\\n\\n    saltenv: base\\n        Specifies the template environment. This will influence the relative imports inside the templates.\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n    skip_verify: False\\n        If ``True``, hash verification of remote file sources (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionchanged:: 2017.7.1\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        (will commit the changes on the device).\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        result after the template was rendered.\\n\\n        .. note::\\n            This argument cannot be used directly on the command line. Instead,\\n            it can be passed through the ``pillar`` variable when executing\\n            either of the :py:func:`state.sls <salt.modules.state.sls>` or\\n            :py:func:`state.apply <salt.modules.state.apply>` (see below for an\\n            example).\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False`` (will apply load merge).\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered. Do not explicitly specify this\\n        argument. This represents any other variable that will be sent to the template rendering system. Please\\n        see an example below! In both ``ntp_peers_example_using_pillar`` and ``ntp_peers_example``, ``peers`` is sent as\\n        template variable.\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument instead, to\\n            avoid any conflicts with other arguments.\\n\\n    SLS Example (e.g.: under salt://router/config.sls) :\\n\\n    .. code-block:: yaml\\n\\n        whole_config_example:\\n            netconfig.managed:\\n                - template_name: salt://path/to/complete_config.jinja\\n                - debug: True\\n                - replace: True\\n        bgp_config_example:\\n            netconfig.managed:\\n                - template_name: /absolute/path/to/bgp_neighbors.mako\\n                - template_engine: mako\\n        prefix_lists_example:\\n            netconfig.managed:\\n                - template_name: prefix_lists.cheetah\\n                - debug: True\\n                - template_engine: cheetah\\n        ntp_peers_example:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - skip_verify: False\\n                - debug: True\\n                - peers:\\n                    - 192.168.0.1\\n                    - 192.168.0.1\\n        ntp_peers_example_using_pillar:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - peers: {{ pillar.get(\\'ntp.peers\\', []) }}\\n\\n    Multi template example:\\n\\n    .. code-block:: yaml\\n\\n        hostname_and_ntp:\\n          netconfig.managed:\\n            - template_name:\\n                - https://bit.ly/2OhSgqP\\n                - https://bit.ly/2M6C4Lx\\n                - https://bit.ly/2OIWVTs\\n            - debug: true\\n            - context:\\n                hostname: {{ opts.id }}\\n                servers:\\n                  - 172.17.17.1\\n                  - 172.17.17.2\\n                peers:\\n                  - 192.168.0.1\\n                  - 192.168.0.2\\n\\n    Usage examples:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n\\n        $ sudo salt -N all-routers state.sls router.config pillar=\"{\\'debug\\': True}\"\\n\\n    ``router.config`` depends on the location of the SLS file (see above). Running this command, will be executed all\\n    five steps from above. These examples above are not meant to be used in a production environment, their sole purpose\\n    is to provide usage examples.\\n\\n    Output example:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n        juniper.device:\\n        ----------\\n                  ID: ntp_peers_example_using_pillar\\n            Function: netconfig.managed\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:01:40.744535\\n            Duration: 8755.788 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit system ntp]\\n                               peer 192.168.0.1 { ... }\\n                          +    peer 172.17.17.1;\\n                          +    peer 172.17.17.3;\\n\\n        Summary for juniper.device\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   8.756 s\\n\\n    Raw output example (useful when the output is reused in other states/execution modules):\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt --out=pprint \\'juniper.device\\' state.sls router.config test=True debug=True\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'juniper.device\\': {\\n                \\'netconfig_|-ntp_peers_example_using_pillar_|-ntp_peers_example_using_pillar_|-managed\\': {\\n                    \\'__id__\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'__run_num__\\': 0,\\n                    \\'already_configured\\': False,\\n                    \\'changes\\': {\\n                        \\'diff\\': \\'[edit system ntp]   peer 192.168.0.1 { ... }+   peer 172.17.17.1;+   peer 172.17.17.3;\\'\\n                    },\\n                    \\'comment\\': \\'Testing mode: Configuration discarded.\\',\\n                    \\'duration\\': 7400.759,\\n                    \\'loaded_config\\': \\'system {  ntp {  peer 172.17.17.1;  peer 172.17.17.3; } }\\',\\n                    \\'name\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'result\\': None,\\n                    \\'start_time\\': \\'12:09:09.811445\\'\\n                }\\n            }\\n        }\\n    '\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    skip_verify = __salt__['config.merge']('skip_verify', skip_verify)\n    commit_in = __salt__['config.merge']('commit_in', commit_in)\n    commit_at = __salt__['config.merge']('commit_at', commit_at)\n    revert_in = __salt__['config.merge']('revert_in', revert_in)\n    revert_at = __salt__['config.merge']('revert_at', revert_at)\n    config_update_ret = _update_config(template_name=template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, context=context, defaults=defaults, test=test, commit=commit, commit_in=commit_in, commit_at=commit_at, revert_in=revert_in, revert_at=revert_at, debug=debug, replace=replace, **template_vars)\n    return salt.utils.napalm.loaded_ret(ret, config_update_ret, test, debug)",
            "def managed(name, template_name=None, template_source=None, template_hash=None, template_hash_name=None, saltenv='base', template_engine='jinja', skip_verify=False, context=None, defaults=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Manages the configuration on network devices.\\n\\n    By default this state will commit the changes on the device. If there are no changes required, it does not commit\\n    and the field ``already_configured`` from the output dictionary will be set as ``True`` to notify that.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` (or via the CLI argument ``test=True``)\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False`` (either as CLI argument, either as state parameter).\\n    However, this is recommended to be used only in exceptional cases when there are applied few consecutive states\\n    and/or configuration changes. Otherwise the user might forget that the config DB is locked and the candidate config\\n    buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``. This option is recommended to be used with caution!\\n\\n    template_name\\n        Identifies path to the template source. The template can be either stored on the local machine,\\n        either remotely.\\n        The recommended location is under the ``file_roots`` as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                 - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``, it can be used as\\n        ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file, this specifies the filename to look for in that file.\\n\\n    saltenv: base\\n        Specifies the template environment. This will influence the relative imports inside the templates.\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n    skip_verify: False\\n        If ``True``, hash verification of remote file sources (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionchanged:: 2017.7.1\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        (will commit the changes on the device).\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        result after the template was rendered.\\n\\n        .. note::\\n            This argument cannot be used directly on the command line. Instead,\\n            it can be passed through the ``pillar`` variable when executing\\n            either of the :py:func:`state.sls <salt.modules.state.sls>` or\\n            :py:func:`state.apply <salt.modules.state.apply>` (see below for an\\n            example).\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False`` (will apply load merge).\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered. Do not explicitly specify this\\n        argument. This represents any other variable that will be sent to the template rendering system. Please\\n        see an example below! In both ``ntp_peers_example_using_pillar`` and ``ntp_peers_example``, ``peers`` is sent as\\n        template variable.\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument instead, to\\n            avoid any conflicts with other arguments.\\n\\n    SLS Example (e.g.: under salt://router/config.sls) :\\n\\n    .. code-block:: yaml\\n\\n        whole_config_example:\\n            netconfig.managed:\\n                - template_name: salt://path/to/complete_config.jinja\\n                - debug: True\\n                - replace: True\\n        bgp_config_example:\\n            netconfig.managed:\\n                - template_name: /absolute/path/to/bgp_neighbors.mako\\n                - template_engine: mako\\n        prefix_lists_example:\\n            netconfig.managed:\\n                - template_name: prefix_lists.cheetah\\n                - debug: True\\n                - template_engine: cheetah\\n        ntp_peers_example:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - skip_verify: False\\n                - debug: True\\n                - peers:\\n                    - 192.168.0.1\\n                    - 192.168.0.1\\n        ntp_peers_example_using_pillar:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - peers: {{ pillar.get(\\'ntp.peers\\', []) }}\\n\\n    Multi template example:\\n\\n    .. code-block:: yaml\\n\\n        hostname_and_ntp:\\n          netconfig.managed:\\n            - template_name:\\n                - https://bit.ly/2OhSgqP\\n                - https://bit.ly/2M6C4Lx\\n                - https://bit.ly/2OIWVTs\\n            - debug: true\\n            - context:\\n                hostname: {{ opts.id }}\\n                servers:\\n                  - 172.17.17.1\\n                  - 172.17.17.2\\n                peers:\\n                  - 192.168.0.1\\n                  - 192.168.0.2\\n\\n    Usage examples:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n\\n        $ sudo salt -N all-routers state.sls router.config pillar=\"{\\'debug\\': True}\"\\n\\n    ``router.config`` depends on the location of the SLS file (see above). Running this command, will be executed all\\n    five steps from above. These examples above are not meant to be used in a production environment, their sole purpose\\n    is to provide usage examples.\\n\\n    Output example:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n        juniper.device:\\n        ----------\\n                  ID: ntp_peers_example_using_pillar\\n            Function: netconfig.managed\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:01:40.744535\\n            Duration: 8755.788 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit system ntp]\\n                               peer 192.168.0.1 { ... }\\n                          +    peer 172.17.17.1;\\n                          +    peer 172.17.17.3;\\n\\n        Summary for juniper.device\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   8.756 s\\n\\n    Raw output example (useful when the output is reused in other states/execution modules):\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt --out=pprint \\'juniper.device\\' state.sls router.config test=True debug=True\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'juniper.device\\': {\\n                \\'netconfig_|-ntp_peers_example_using_pillar_|-ntp_peers_example_using_pillar_|-managed\\': {\\n                    \\'__id__\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'__run_num__\\': 0,\\n                    \\'already_configured\\': False,\\n                    \\'changes\\': {\\n                        \\'diff\\': \\'[edit system ntp]   peer 192.168.0.1 { ... }+   peer 172.17.17.1;+   peer 172.17.17.3;\\'\\n                    },\\n                    \\'comment\\': \\'Testing mode: Configuration discarded.\\',\\n                    \\'duration\\': 7400.759,\\n                    \\'loaded_config\\': \\'system {  ntp {  peer 172.17.17.1;  peer 172.17.17.3; } }\\',\\n                    \\'name\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'result\\': None,\\n                    \\'start_time\\': \\'12:09:09.811445\\'\\n                }\\n            }\\n        }\\n    '\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    skip_verify = __salt__['config.merge']('skip_verify', skip_verify)\n    commit_in = __salt__['config.merge']('commit_in', commit_in)\n    commit_at = __salt__['config.merge']('commit_at', commit_at)\n    revert_in = __salt__['config.merge']('revert_in', revert_in)\n    revert_at = __salt__['config.merge']('revert_at', revert_at)\n    config_update_ret = _update_config(template_name=template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, context=context, defaults=defaults, test=test, commit=commit, commit_in=commit_in, commit_at=commit_at, revert_in=revert_in, revert_at=revert_at, debug=debug, replace=replace, **template_vars)\n    return salt.utils.napalm.loaded_ret(ret, config_update_ret, test, debug)",
            "def managed(name, template_name=None, template_source=None, template_hash=None, template_hash_name=None, saltenv='base', template_engine='jinja', skip_verify=False, context=None, defaults=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Manages the configuration on network devices.\\n\\n    By default this state will commit the changes on the device. If there are no changes required, it does not commit\\n    and the field ``already_configured`` from the output dictionary will be set as ``True`` to notify that.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` (or via the CLI argument ``test=True``)\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False`` (either as CLI argument, either as state parameter).\\n    However, this is recommended to be used only in exceptional cases when there are applied few consecutive states\\n    and/or configuration changes. Otherwise the user might forget that the config DB is locked and the candidate config\\n    buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``. This option is recommended to be used with caution!\\n\\n    template_name\\n        Identifies path to the template source. The template can be either stored on the local machine,\\n        either remotely.\\n        The recommended location is under the ``file_roots`` as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                 - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``, it can be used as\\n        ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file, this specifies the filename to look for in that file.\\n\\n    saltenv: base\\n        Specifies the template environment. This will influence the relative imports inside the templates.\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n    skip_verify: False\\n        If ``True``, hash verification of remote file sources (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionchanged:: 2017.7.1\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        (will commit the changes on the device).\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        result after the template was rendered.\\n\\n        .. note::\\n            This argument cannot be used directly on the command line. Instead,\\n            it can be passed through the ``pillar`` variable when executing\\n            either of the :py:func:`state.sls <salt.modules.state.sls>` or\\n            :py:func:`state.apply <salt.modules.state.apply>` (see below for an\\n            example).\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False`` (will apply load merge).\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered. Do not explicitly specify this\\n        argument. This represents any other variable that will be sent to the template rendering system. Please\\n        see an example below! In both ``ntp_peers_example_using_pillar`` and ``ntp_peers_example``, ``peers`` is sent as\\n        template variable.\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument instead, to\\n            avoid any conflicts with other arguments.\\n\\n    SLS Example (e.g.: under salt://router/config.sls) :\\n\\n    .. code-block:: yaml\\n\\n        whole_config_example:\\n            netconfig.managed:\\n                - template_name: salt://path/to/complete_config.jinja\\n                - debug: True\\n                - replace: True\\n        bgp_config_example:\\n            netconfig.managed:\\n                - template_name: /absolute/path/to/bgp_neighbors.mako\\n                - template_engine: mako\\n        prefix_lists_example:\\n            netconfig.managed:\\n                - template_name: prefix_lists.cheetah\\n                - debug: True\\n                - template_engine: cheetah\\n        ntp_peers_example:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - skip_verify: False\\n                - debug: True\\n                - peers:\\n                    - 192.168.0.1\\n                    - 192.168.0.1\\n        ntp_peers_example_using_pillar:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - peers: {{ pillar.get(\\'ntp.peers\\', []) }}\\n\\n    Multi template example:\\n\\n    .. code-block:: yaml\\n\\n        hostname_and_ntp:\\n          netconfig.managed:\\n            - template_name:\\n                - https://bit.ly/2OhSgqP\\n                - https://bit.ly/2M6C4Lx\\n                - https://bit.ly/2OIWVTs\\n            - debug: true\\n            - context:\\n                hostname: {{ opts.id }}\\n                servers:\\n                  - 172.17.17.1\\n                  - 172.17.17.2\\n                peers:\\n                  - 192.168.0.1\\n                  - 192.168.0.2\\n\\n    Usage examples:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n\\n        $ sudo salt -N all-routers state.sls router.config pillar=\"{\\'debug\\': True}\"\\n\\n    ``router.config`` depends on the location of the SLS file (see above). Running this command, will be executed all\\n    five steps from above. These examples above are not meant to be used in a production environment, their sole purpose\\n    is to provide usage examples.\\n\\n    Output example:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n        juniper.device:\\n        ----------\\n                  ID: ntp_peers_example_using_pillar\\n            Function: netconfig.managed\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:01:40.744535\\n            Duration: 8755.788 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit system ntp]\\n                               peer 192.168.0.1 { ... }\\n                          +    peer 172.17.17.1;\\n                          +    peer 172.17.17.3;\\n\\n        Summary for juniper.device\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   8.756 s\\n\\n    Raw output example (useful when the output is reused in other states/execution modules):\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt --out=pprint \\'juniper.device\\' state.sls router.config test=True debug=True\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'juniper.device\\': {\\n                \\'netconfig_|-ntp_peers_example_using_pillar_|-ntp_peers_example_using_pillar_|-managed\\': {\\n                    \\'__id__\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'__run_num__\\': 0,\\n                    \\'already_configured\\': False,\\n                    \\'changes\\': {\\n                        \\'diff\\': \\'[edit system ntp]   peer 192.168.0.1 { ... }+   peer 172.17.17.1;+   peer 172.17.17.3;\\'\\n                    },\\n                    \\'comment\\': \\'Testing mode: Configuration discarded.\\',\\n                    \\'duration\\': 7400.759,\\n                    \\'loaded_config\\': \\'system {  ntp {  peer 172.17.17.1;  peer 172.17.17.3; } }\\',\\n                    \\'name\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'result\\': None,\\n                    \\'start_time\\': \\'12:09:09.811445\\'\\n                }\\n            }\\n        }\\n    '\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    skip_verify = __salt__['config.merge']('skip_verify', skip_verify)\n    commit_in = __salt__['config.merge']('commit_in', commit_in)\n    commit_at = __salt__['config.merge']('commit_at', commit_at)\n    revert_in = __salt__['config.merge']('revert_in', revert_in)\n    revert_at = __salt__['config.merge']('revert_at', revert_at)\n    config_update_ret = _update_config(template_name=template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, context=context, defaults=defaults, test=test, commit=commit, commit_in=commit_in, commit_at=commit_at, revert_in=revert_in, revert_at=revert_at, debug=debug, replace=replace, **template_vars)\n    return salt.utils.napalm.loaded_ret(ret, config_update_ret, test, debug)",
            "def managed(name, template_name=None, template_source=None, template_hash=None, template_hash_name=None, saltenv='base', template_engine='jinja', skip_verify=False, context=None, defaults=None, test=False, commit=True, debug=False, replace=False, commit_in=None, commit_at=None, revert_in=None, revert_at=None, **template_vars):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Manages the configuration on network devices.\\n\\n    By default this state will commit the changes on the device. If there are no changes required, it does not commit\\n    and the field ``already_configured`` from the output dictionary will be set as ``True`` to notify that.\\n\\n    To avoid committing the configuration, set the argument ``test`` to ``True`` (or via the CLI argument ``test=True``)\\n    and will discard (dry run).\\n\\n    To preserve the changes, set ``commit`` to ``False`` (either as CLI argument, either as state parameter).\\n    However, this is recommended to be used only in exceptional cases when there are applied few consecutive states\\n    and/or configuration changes. Otherwise the user might forget that the config DB is locked and the candidate config\\n    buffer is not cleared/merged in the running config.\\n\\n    To replace the config, set ``replace`` to ``True``. This option is recommended to be used with caution!\\n\\n    template_name\\n        Identifies path to the template source. The template can be either stored on the local machine,\\n        either remotely.\\n        The recommended location is under the ``file_roots`` as specified in the master config file.\\n        For example, let\\'s suppose the ``file_roots`` is configured as:\\n\\n        .. code-block:: yaml\\n\\n            file_roots:\\n              base:\\n                 - /etc/salt/states\\n\\n        Placing the template under ``/etc/salt/states/templates/example.jinja``, it can be used as\\n        ``salt://templates/example.jinja``.\\n        Alternatively, for local files, the user can specify the absolute path.\\n        If remotely, the source can be retrieved via ``http``, ``https`` or ``ftp``.\\n\\n        Examples:\\n\\n        - ``salt://my_template.jinja``\\n        - ``/absolute/path/to/my_template.jinja``\\n        - ``http://example.com/template.cheetah``\\n        - ``https:/example.com/template.mako``\\n        - ``ftp://example.com/template.py``\\n\\n        .. versionchanged:: 2019.2.0\\n            This argument can now support a list of templates to be rendered.\\n            The resulting configuration text is loaded at once, as a single\\n            configuration chunk.\\n\\n    template_source: None\\n        Inline config template to be rendered and loaded on the device.\\n\\n    template_hash: None\\n        Hash of the template file. Format: ``{hash_type: \\'md5\\', \\'hsum\\': <md5sum>}``\\n\\n    template_hash_name: None\\n        When ``template_hash`` refers to a remote file, this specifies the filename to look for in that file.\\n\\n    saltenv: base\\n        Specifies the template environment. This will influence the relative imports inside the templates.\\n\\n    template_engine: jinja\\n        The following templates engines are supported:\\n\\n        - :mod:`cheetah<salt.renderers.cheetah>`\\n        - :mod:`genshi<salt.renderers.genshi>`\\n        - :mod:`jinja<salt.renderers.jinja>`\\n        - :mod:`mako<salt.renderers.mako>`\\n        - :mod:`py<salt.renderers.py>`\\n        - :mod:`wempy<salt.renderers.wempy>`\\n\\n    skip_verify: False\\n        If ``True``, hash verification of remote file sources (``http://``, ``https://``, ``ftp://``) will be skipped,\\n        and the ``source_hash`` argument will be ignored.\\n\\n        .. versionchanged:: 2017.7.1\\n\\n    test: False\\n        Dry run? If set to ``True``, will apply the config, discard and return the changes. Default: ``False``\\n        (will commit the changes on the device).\\n\\n    commit: True\\n        Commit? Default: ``True``.\\n\\n    debug: False\\n        Debug mode. Will insert a new key under the output dictionary, as ``loaded_config`` containing the raw\\n        result after the template was rendered.\\n\\n        .. note::\\n            This argument cannot be used directly on the command line. Instead,\\n            it can be passed through the ``pillar`` variable when executing\\n            either of the :py:func:`state.sls <salt.modules.state.sls>` or\\n            :py:func:`state.apply <salt.modules.state.apply>` (see below for an\\n            example).\\n\\n    commit_in: ``None``\\n        Commit the changes in a specific number of minutes / hours. Example of\\n        accepted formats: ``5`` (commit in 5 minutes), ``2m`` (commit in 2\\n        minutes), ``1h`` (commit the changes in 1 hour)`, ``5h30m`` (commit\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    commit_at: ``None``\\n        Commit the changes at a specific time. Example of accepted formats:\\n        ``1am`` (will commit the changes at the next 1AM), ``13:20`` (will\\n        commit at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            This feature works on any platforms, as it does not rely on the\\n            native features of the network operating system.\\n\\n        .. note::\\n            After the command is executed and the ``diff`` is not satisfactory,\\n            or for any other reasons you have to discard the commit, you are\\n            able to do so using the\\n            :py:func:`net.cancel_commit <salt.modules.napalm_network.cancel_commit>`\\n            execution function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            Using this feature, Salt will load the exact configuration you\\n            expect, however the diff may change in time (i.e., if an user\\n            applies a manual configuration change, or a different process or\\n            command changes the configuration in the meanwhile).\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_in: ``None``\\n        Commit and revert the changes in a specific number of minutes / hours.\\n        Example of accepted formats: ``5`` (revert in 5 minutes), ``2m`` (revert\\n        in 2 minutes), ``1h`` (revert the changes in 1 hour)`, ``5h30m`` (revert\\n        the changes in 5 hours and 30 minutes).\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    revert_at: ``None``\\n        Commit and revert the changes at a specific time. Example of accepted\\n        formats: ``1am`` (will commit and revert the changes at the next 1AM),\\n        ``13:20`` (will commit and revert at 13:20), ``1:20am``, etc.\\n\\n        .. note::\\n            To confirm the commit, and prevent reverting the changes, you will\\n            have to execute the\\n            :mod:`net.confirm_commit <salt.modules.napalm_network.confirm_commit>`\\n            function, using the commit ID returned by this function.\\n\\n        .. warning::\\n            This works on any platform, regardless if they have or don\\'t have\\n            native capabilities to confirming a commit. However, please be\\n            *very* cautious when using this feature: on Junos (as it is the only\\n            NAPALM core platform supporting this natively) it executes a commit\\n            confirmed as you would do from the command line.\\n            All the other platforms don\\'t have this capability natively,\\n            therefore the revert is done via Salt. That means, your device needs\\n            to be reachable at the moment when Salt will attempt to revert your\\n            changes. Be cautious when pushing configuration changes that would\\n            prevent you reach the device.\\n\\n            Similarly, if an user or a different process apply other\\n            configuration changes in the meanwhile (between the moment you\\n            commit and till the changes are reverted), these changes would be\\n            equally reverted, as Salt cannot be aware of them.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    replace: False\\n        Load and replace the configuration. Default: ``False`` (will apply load merge).\\n\\n    context: None\\n        Overrides default context variables passed to the template.\\n\\n        .. versionadded:: 2019.2.0\\n\\n    defaults: None\\n        Default variables/context passed to the template.\\n\\n    template_vars\\n        Dictionary with the arguments/context to be used when the template is rendered. Do not explicitly specify this\\n        argument. This represents any other variable that will be sent to the template rendering system. Please\\n        see an example below! In both ``ntp_peers_example_using_pillar`` and ``ntp_peers_example``, ``peers`` is sent as\\n        template variable.\\n\\n        .. note::\\n            It is more recommended to use the ``context`` argument instead, to\\n            avoid any conflicts with other arguments.\\n\\n    SLS Example (e.g.: under salt://router/config.sls) :\\n\\n    .. code-block:: yaml\\n\\n        whole_config_example:\\n            netconfig.managed:\\n                - template_name: salt://path/to/complete_config.jinja\\n                - debug: True\\n                - replace: True\\n        bgp_config_example:\\n            netconfig.managed:\\n                - template_name: /absolute/path/to/bgp_neighbors.mako\\n                - template_engine: mako\\n        prefix_lists_example:\\n            netconfig.managed:\\n                - template_name: prefix_lists.cheetah\\n                - debug: True\\n                - template_engine: cheetah\\n        ntp_peers_example:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - skip_verify: False\\n                - debug: True\\n                - peers:\\n                    - 192.168.0.1\\n                    - 192.168.0.1\\n        ntp_peers_example_using_pillar:\\n            netconfig.managed:\\n                - template_name: http://bit.ly/2gKOj20\\n                - peers: {{ pillar.get(\\'ntp.peers\\', []) }}\\n\\n    Multi template example:\\n\\n    .. code-block:: yaml\\n\\n        hostname_and_ntp:\\n          netconfig.managed:\\n            - template_name:\\n                - https://bit.ly/2OhSgqP\\n                - https://bit.ly/2M6C4Lx\\n                - https://bit.ly/2OIWVTs\\n            - debug: true\\n            - context:\\n                hostname: {{ opts.id }}\\n                servers:\\n                  - 172.17.17.1\\n                  - 172.17.17.2\\n                peers:\\n                  - 192.168.0.1\\n                  - 192.168.0.2\\n\\n    Usage examples:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n\\n        $ sudo salt -N all-routers state.sls router.config pillar=\"{\\'debug\\': True}\"\\n\\n    ``router.config`` depends on the location of the SLS file (see above). Running this command, will be executed all\\n    five steps from above. These examples above are not meant to be used in a production environment, their sole purpose\\n    is to provide usage examples.\\n\\n    Output example:\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt \\'juniper.device\\' state.sls router.config test=True\\n        juniper.device:\\n        ----------\\n                  ID: ntp_peers_example_using_pillar\\n            Function: netconfig.managed\\n              Result: None\\n             Comment: Testing mode: Configuration discarded.\\n             Started: 12:01:40.744535\\n            Duration: 8755.788 ms\\n             Changes:\\n                      ----------\\n                      diff:\\n                          [edit system ntp]\\n                               peer 192.168.0.1 { ... }\\n                          +    peer 172.17.17.1;\\n                          +    peer 172.17.17.3;\\n\\n        Summary for juniper.device\\n        ------------\\n        Succeeded: 1 (unchanged=1, changed=1)\\n        Failed:    0\\n        ------------\\n        Total states run:     1\\n        Total run time:   8.756 s\\n\\n    Raw output example (useful when the output is reused in other states/execution modules):\\n\\n    .. code-block:: bash\\n\\n        $ sudo salt --out=pprint \\'juniper.device\\' state.sls router.config test=True debug=True\\n\\n    .. code-block:: python\\n\\n        {\\n            \\'juniper.device\\': {\\n                \\'netconfig_|-ntp_peers_example_using_pillar_|-ntp_peers_example_using_pillar_|-managed\\': {\\n                    \\'__id__\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'__run_num__\\': 0,\\n                    \\'already_configured\\': False,\\n                    \\'changes\\': {\\n                        \\'diff\\': \\'[edit system ntp]   peer 192.168.0.1 { ... }+   peer 172.17.17.1;+   peer 172.17.17.3;\\'\\n                    },\\n                    \\'comment\\': \\'Testing mode: Configuration discarded.\\',\\n                    \\'duration\\': 7400.759,\\n                    \\'loaded_config\\': \\'system {  ntp {  peer 172.17.17.1;  peer 172.17.17.3; } }\\',\\n                    \\'name\\': \\'ntp_peers_example_using_pillar\\',\\n                    \\'result\\': None,\\n                    \\'start_time\\': \\'12:09:09.811445\\'\\n                }\\n            }\\n        }\\n    '\n    ret = salt.utils.napalm.default_ret(name)\n    test = test or __opts__['test']\n    debug = __salt__['config.merge']('debug', debug)\n    commit = __salt__['config.merge']('commit', commit)\n    replace = __salt__['config.merge']('replace', replace)\n    skip_verify = __salt__['config.merge']('skip_verify', skip_verify)\n    commit_in = __salt__['config.merge']('commit_in', commit_in)\n    commit_at = __salt__['config.merge']('commit_at', commit_at)\n    revert_in = __salt__['config.merge']('revert_in', revert_in)\n    revert_at = __salt__['config.merge']('revert_at', revert_at)\n    config_update_ret = _update_config(template_name=template_name, template_source=template_source, template_hash=template_hash, template_hash_name=template_hash_name, saltenv=saltenv, template_engine=template_engine, skip_verify=skip_verify, context=context, defaults=defaults, test=test, commit=commit, commit_in=commit_in, commit_at=commit_at, revert_in=revert_in, revert_at=revert_at, debug=debug, replace=replace, **template_vars)\n    return salt.utils.napalm.loaded_ret(ret, config_update_ret, test, debug)"
        ]
    },
    {
        "func_name": "commit_cancelled",
        "original": "def commit_cancelled(name):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\n    ``commit_at`` arguments from the\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\n    execution functions. The commit ID is displayed when the commit is scheduled\n    via the functions named above.\n\n    State SLS Example:\n\n    .. code-block:: yaml\n\n        '20180726083540640360':\n          netconfig.commit_cancelled\n    \"\"\"\n    cancelled = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        cancelled['comment'] = 'It would cancel commit #{}'.format(name)\n        return cancelled\n    ret = __salt__['net.cancel_commit'](name)\n    cancelled.update(ret)\n    return cancelled",
        "mutated": [
            "def commit_cancelled(name):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_cancelled\\n    \"\n    cancelled = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        cancelled['comment'] = 'It would cancel commit #{}'.format(name)\n        return cancelled\n    ret = __salt__['net.cancel_commit'](name)\n    cancelled.update(ret)\n    return cancelled",
            "def commit_cancelled(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_cancelled\\n    \"\n    cancelled = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        cancelled['comment'] = 'It would cancel commit #{}'.format(name)\n        return cancelled\n    ret = __salt__['net.cancel_commit'](name)\n    cancelled.update(ret)\n    return cancelled",
            "def commit_cancelled(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_cancelled\\n    \"\n    cancelled = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        cancelled['comment'] = 'It would cancel commit #{}'.format(name)\n        return cancelled\n    ret = __salt__['net.cancel_commit'](name)\n    cancelled.update(ret)\n    return cancelled",
            "def commit_cancelled(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_cancelled\\n    \"\n    cancelled = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        cancelled['comment'] = 'It would cancel commit #{}'.format(name)\n        return cancelled\n    ret = __salt__['net.cancel_commit'](name)\n    cancelled.update(ret)\n    return cancelled",
            "def commit_cancelled(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Cancel a commit scheduled to be executed via the ``commit_in`` and\\n    ``commit_at`` arguments from the\\n    :py:func:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :py:func:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit is scheduled\\n    via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_cancelled\\n    \"\n    cancelled = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        cancelled['comment'] = 'It would cancel commit #{}'.format(name)\n        return cancelled\n    ret = __salt__['net.cancel_commit'](name)\n    cancelled.update(ret)\n    return cancelled"
        ]
    },
    {
        "func_name": "commit_confirmed",
        "original": "def commit_confirmed(name):\n    \"\"\"\n    .. versionadded:: 2019.2.0\n\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\n    ``revert_at`` arguments from the\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\n    execution functions. The commit ID is displayed when the commit confirmed\n    is scheduled via the functions named above.\n\n    State SLS Example:\n\n    .. code-block:: yaml\n\n        '20180726083540640360':\n          netconfig.commit_confirmed\n    \"\"\"\n    confirmed = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        confirmed['comment'] = 'It would confirm commit #{}'.format(name)\n        return confirmed\n    ret = __salt__['net.confirm_commit'](name)\n    confirmed.update(ret)\n    return confirmed",
        "mutated": [
            "def commit_confirmed(name):\n    if False:\n        i = 10\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at`` arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_confirmed\\n    \"\n    confirmed = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        confirmed['comment'] = 'It would confirm commit #{}'.format(name)\n        return confirmed\n    ret = __salt__['net.confirm_commit'](name)\n    confirmed.update(ret)\n    return confirmed",
            "def commit_confirmed(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at`` arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_confirmed\\n    \"\n    confirmed = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        confirmed['comment'] = 'It would confirm commit #{}'.format(name)\n        return confirmed\n    ret = __salt__['net.confirm_commit'](name)\n    confirmed.update(ret)\n    return confirmed",
            "def commit_confirmed(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at`` arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_confirmed\\n    \"\n    confirmed = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        confirmed['comment'] = 'It would confirm commit #{}'.format(name)\n        return confirmed\n    ret = __salt__['net.confirm_commit'](name)\n    confirmed.update(ret)\n    return confirmed",
            "def commit_confirmed(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at`` arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_confirmed\\n    \"\n    confirmed = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        confirmed['comment'] = 'It would confirm commit #{}'.format(name)\n        return confirmed\n    ret = __salt__['net.confirm_commit'](name)\n    confirmed.update(ret)\n    return confirmed",
            "def commit_confirmed(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    .. versionadded:: 2019.2.0\\n\\n    Confirm a commit scheduled to be reverted via the ``revert_in`` and\\n    ``revert_at`` arguments from the\\n    :mod:`net.load_template <salt.modules.napalm_network.load_template>` or\\n    :mod:`net.load_config <salt.modules.napalm_network.load_config>`\\n    execution functions. The commit ID is displayed when the commit confirmed\\n    is scheduled via the functions named above.\\n\\n    State SLS Example:\\n\\n    .. code-block:: yaml\\n\\n        '20180726083540640360':\\n          netconfig.commit_confirmed\\n    \"\n    confirmed = {'name': name, 'result': None, 'changes': {}, 'comment': ''}\n    if __opts__['test']:\n        confirmed['comment'] = 'It would confirm commit #{}'.format(name)\n        return confirmed\n    ret = __salt__['net.confirm_commit'](name)\n    confirmed.update(ret)\n    return confirmed"
        ]
    }
]