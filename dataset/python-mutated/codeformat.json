[
    {
        "func_name": "list_files",
        "original": "def list_files(paths, exclusions=None, prefix=''):\n    files = set()\n    for pattern in paths:\n        files.update(glob.glob(os.path.join(prefix, pattern), recursive=True))\n    for pattern in exclusions or []:\n        files.difference_update(glob.fnmatch.filter(files, os.path.join(prefix, pattern)))\n    return sorted(files)",
        "mutated": [
            "def list_files(paths, exclusions=None, prefix=''):\n    if False:\n        i = 10\n    files = set()\n    for pattern in paths:\n        files.update(glob.glob(os.path.join(prefix, pattern), recursive=True))\n    for pattern in exclusions or []:\n        files.difference_update(glob.fnmatch.filter(files, os.path.join(prefix, pattern)))\n    return sorted(files)",
            "def list_files(paths, exclusions=None, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    files = set()\n    for pattern in paths:\n        files.update(glob.glob(os.path.join(prefix, pattern), recursive=True))\n    for pattern in exclusions or []:\n        files.difference_update(glob.fnmatch.filter(files, os.path.join(prefix, pattern)))\n    return sorted(files)",
            "def list_files(paths, exclusions=None, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    files = set()\n    for pattern in paths:\n        files.update(glob.glob(os.path.join(prefix, pattern), recursive=True))\n    for pattern in exclusions or []:\n        files.difference_update(glob.fnmatch.filter(files, os.path.join(prefix, pattern)))\n    return sorted(files)",
            "def list_files(paths, exclusions=None, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    files = set()\n    for pattern in paths:\n        files.update(glob.glob(os.path.join(prefix, pattern), recursive=True))\n    for pattern in exclusions or []:\n        files.difference_update(glob.fnmatch.filter(files, os.path.join(prefix, pattern)))\n    return sorted(files)",
            "def list_files(paths, exclusions=None, prefix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    files = set()\n    for pattern in paths:\n        files.update(glob.glob(os.path.join(prefix, pattern), recursive=True))\n    for pattern in exclusions or []:\n        files.difference_update(glob.fnmatch.filter(files, os.path.join(prefix, pattern)))\n    return sorted(files)"
        ]
    },
    {
        "func_name": "fixup_c",
        "original": "def fixup_c(filename):\n    with open(filename) as f:\n        lines = f.readlines()\n    with open(filename, 'w', newline='') as f:\n        dedent_stack = []\n        while lines:\n            l = lines.pop(0)\n            m = re.match('( +)#(if |ifdef |ifndef |elif |else|endif)', l)\n            if m:\n                indent = len(m.group(1))\n                directive = m.group(2)\n                if directive in ('if ', 'ifdef ', 'ifndef '):\n                    l_next = lines[0]\n                    indent_next = len(re.match('( *)', l_next).group(1))\n                    if indent - 4 == indent_next and re.match(' +(} else |case )', l_next):\n                        l = l[4:]\n                        dedent_stack.append(indent - 4)\n                    else:\n                        dedent_stack.append(-1)\n                else:\n                    if dedent_stack[-1] >= 0:\n                        indent_diff = indent - dedent_stack[-1]\n                        assert indent_diff >= 0\n                        l = l[indent_diff:]\n                    if directive == 'endif':\n                        dedent_stack.pop()\n            f.write(l)\n        assert not dedent_stack, filename",
        "mutated": [
            "def fixup_c(filename):\n    if False:\n        i = 10\n    with open(filename) as f:\n        lines = f.readlines()\n    with open(filename, 'w', newline='') as f:\n        dedent_stack = []\n        while lines:\n            l = lines.pop(0)\n            m = re.match('( +)#(if |ifdef |ifndef |elif |else|endif)', l)\n            if m:\n                indent = len(m.group(1))\n                directive = m.group(2)\n                if directive in ('if ', 'ifdef ', 'ifndef '):\n                    l_next = lines[0]\n                    indent_next = len(re.match('( *)', l_next).group(1))\n                    if indent - 4 == indent_next and re.match(' +(} else |case )', l_next):\n                        l = l[4:]\n                        dedent_stack.append(indent - 4)\n                    else:\n                        dedent_stack.append(-1)\n                else:\n                    if dedent_stack[-1] >= 0:\n                        indent_diff = indent - dedent_stack[-1]\n                        assert indent_diff >= 0\n                        l = l[indent_diff:]\n                    if directive == 'endif':\n                        dedent_stack.pop()\n            f.write(l)\n        assert not dedent_stack, filename",
            "def fixup_c(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(filename) as f:\n        lines = f.readlines()\n    with open(filename, 'w', newline='') as f:\n        dedent_stack = []\n        while lines:\n            l = lines.pop(0)\n            m = re.match('( +)#(if |ifdef |ifndef |elif |else|endif)', l)\n            if m:\n                indent = len(m.group(1))\n                directive = m.group(2)\n                if directive in ('if ', 'ifdef ', 'ifndef '):\n                    l_next = lines[0]\n                    indent_next = len(re.match('( *)', l_next).group(1))\n                    if indent - 4 == indent_next and re.match(' +(} else |case )', l_next):\n                        l = l[4:]\n                        dedent_stack.append(indent - 4)\n                    else:\n                        dedent_stack.append(-1)\n                else:\n                    if dedent_stack[-1] >= 0:\n                        indent_diff = indent - dedent_stack[-1]\n                        assert indent_diff >= 0\n                        l = l[indent_diff:]\n                    if directive == 'endif':\n                        dedent_stack.pop()\n            f.write(l)\n        assert not dedent_stack, filename",
            "def fixup_c(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(filename) as f:\n        lines = f.readlines()\n    with open(filename, 'w', newline='') as f:\n        dedent_stack = []\n        while lines:\n            l = lines.pop(0)\n            m = re.match('( +)#(if |ifdef |ifndef |elif |else|endif)', l)\n            if m:\n                indent = len(m.group(1))\n                directive = m.group(2)\n                if directive in ('if ', 'ifdef ', 'ifndef '):\n                    l_next = lines[0]\n                    indent_next = len(re.match('( *)', l_next).group(1))\n                    if indent - 4 == indent_next and re.match(' +(} else |case )', l_next):\n                        l = l[4:]\n                        dedent_stack.append(indent - 4)\n                    else:\n                        dedent_stack.append(-1)\n                else:\n                    if dedent_stack[-1] >= 0:\n                        indent_diff = indent - dedent_stack[-1]\n                        assert indent_diff >= 0\n                        l = l[indent_diff:]\n                    if directive == 'endif':\n                        dedent_stack.pop()\n            f.write(l)\n        assert not dedent_stack, filename",
            "def fixup_c(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(filename) as f:\n        lines = f.readlines()\n    with open(filename, 'w', newline='') as f:\n        dedent_stack = []\n        while lines:\n            l = lines.pop(0)\n            m = re.match('( +)#(if |ifdef |ifndef |elif |else|endif)', l)\n            if m:\n                indent = len(m.group(1))\n                directive = m.group(2)\n                if directive in ('if ', 'ifdef ', 'ifndef '):\n                    l_next = lines[0]\n                    indent_next = len(re.match('( *)', l_next).group(1))\n                    if indent - 4 == indent_next and re.match(' +(} else |case )', l_next):\n                        l = l[4:]\n                        dedent_stack.append(indent - 4)\n                    else:\n                        dedent_stack.append(-1)\n                else:\n                    if dedent_stack[-1] >= 0:\n                        indent_diff = indent - dedent_stack[-1]\n                        assert indent_diff >= 0\n                        l = l[indent_diff:]\n                    if directive == 'endif':\n                        dedent_stack.pop()\n            f.write(l)\n        assert not dedent_stack, filename",
            "def fixup_c(filename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(filename) as f:\n        lines = f.readlines()\n    with open(filename, 'w', newline='') as f:\n        dedent_stack = []\n        while lines:\n            l = lines.pop(0)\n            m = re.match('( +)#(if |ifdef |ifndef |elif |else|endif)', l)\n            if m:\n                indent = len(m.group(1))\n                directive = m.group(2)\n                if directive in ('if ', 'ifdef ', 'ifndef '):\n                    l_next = lines[0]\n                    indent_next = len(re.match('( *)', l_next).group(1))\n                    if indent - 4 == indent_next and re.match(' +(} else |case )', l_next):\n                        l = l[4:]\n                        dedent_stack.append(indent - 4)\n                    else:\n                        dedent_stack.append(-1)\n                else:\n                    if dedent_stack[-1] >= 0:\n                        indent_diff = indent - dedent_stack[-1]\n                        assert indent_diff >= 0\n                        l = l[indent_diff:]\n                    if directive == 'endif':\n                        dedent_stack.pop()\n            f.write(l)\n        assert not dedent_stack, filename"
        ]
    },
    {
        "func_name": "batch",
        "original": "def batch(cmd, N=200):\n    files_iter = iter(files)\n    while True:\n        file_args = list(itertools.islice(files_iter, N))\n        if not file_args:\n            break\n        subprocess.check_call(cmd + file_args)",
        "mutated": [
            "def batch(cmd, N=200):\n    if False:\n        i = 10\n    files_iter = iter(files)\n    while True:\n        file_args = list(itertools.islice(files_iter, N))\n        if not file_args:\n            break\n        subprocess.check_call(cmd + file_args)",
            "def batch(cmd, N=200):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    files_iter = iter(files)\n    while True:\n        file_args = list(itertools.islice(files_iter, N))\n        if not file_args:\n            break\n        subprocess.check_call(cmd + file_args)",
            "def batch(cmd, N=200):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    files_iter = iter(files)\n    while True:\n        file_args = list(itertools.islice(files_iter, N))\n        if not file_args:\n            break\n        subprocess.check_call(cmd + file_args)",
            "def batch(cmd, N=200):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    files_iter = iter(files)\n    while True:\n        file_args = list(itertools.islice(files_iter, N))\n        if not file_args:\n            break\n        subprocess.check_call(cmd + file_args)",
            "def batch(cmd, N=200):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    files_iter = iter(files)\n    while True:\n        file_args = list(itertools.islice(files_iter, N))\n        if not file_args:\n            break\n        subprocess.check_call(cmd + file_args)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main():\n    cmd_parser = argparse.ArgumentParser(description='Auto-format C and Python files.')\n    cmd_parser.add_argument('-c', action='store_true', help='Format C code only')\n    cmd_parser.add_argument('-p', action='store_true', help='Format Python code only')\n    cmd_parser.add_argument('-v', action='store_true', help='Enable verbose output')\n    cmd_parser.add_argument('-f', action='store_true', help='Filter files provided on the command line against the default list of files to check.')\n    cmd_parser.add_argument('files', nargs='*', help='Run on specific globs')\n    args = cmd_parser.parse_args()\n    format_c = args.c or not args.p\n    format_py = args.p or not args.c\n    files = []\n    if args.files:\n        files = list_files(args.files)\n        if args.f:\n            files = set((os.path.abspath(f) for f in files))\n            all_files = set(list_files(PATHS, EXCLUSIONS, TOP))\n            if args.v:\n                for f in files - all_files:\n                    print('Not checking: {}'.format(f))\n            files = list(files & all_files)\n    else:\n        files = list_files(PATHS, EXCLUSIONS, TOP)\n\n    def batch(cmd, N=200):\n        files_iter = iter(files)\n        while True:\n            file_args = list(itertools.islice(files_iter, N))\n            if not file_args:\n                break\n            subprocess.check_call(cmd + file_args)\n    if format_c:\n        command = ['uncrustify', '-c', UNCRUSTIFY_CFG, '-lC', '--no-backup']\n        if not args.v:\n            command.append('-q')\n        batch(command)\n        for file in files:\n            fixup_c(file)\n    if format_py:\n        command = ['ruff', 'format']\n        if args.v:\n            command.append('-v')\n        else:\n            command.append('-q')\n        command.append('.')\n        subprocess.check_call(command, cwd=TOP)",
        "mutated": [
            "def main():\n    if False:\n        i = 10\n    cmd_parser = argparse.ArgumentParser(description='Auto-format C and Python files.')\n    cmd_parser.add_argument('-c', action='store_true', help='Format C code only')\n    cmd_parser.add_argument('-p', action='store_true', help='Format Python code only')\n    cmd_parser.add_argument('-v', action='store_true', help='Enable verbose output')\n    cmd_parser.add_argument('-f', action='store_true', help='Filter files provided on the command line against the default list of files to check.')\n    cmd_parser.add_argument('files', nargs='*', help='Run on specific globs')\n    args = cmd_parser.parse_args()\n    format_c = args.c or not args.p\n    format_py = args.p or not args.c\n    files = []\n    if args.files:\n        files = list_files(args.files)\n        if args.f:\n            files = set((os.path.abspath(f) for f in files))\n            all_files = set(list_files(PATHS, EXCLUSIONS, TOP))\n            if args.v:\n                for f in files - all_files:\n                    print('Not checking: {}'.format(f))\n            files = list(files & all_files)\n    else:\n        files = list_files(PATHS, EXCLUSIONS, TOP)\n\n    def batch(cmd, N=200):\n        files_iter = iter(files)\n        while True:\n            file_args = list(itertools.islice(files_iter, N))\n            if not file_args:\n                break\n            subprocess.check_call(cmd + file_args)\n    if format_c:\n        command = ['uncrustify', '-c', UNCRUSTIFY_CFG, '-lC', '--no-backup']\n        if not args.v:\n            command.append('-q')\n        batch(command)\n        for file in files:\n            fixup_c(file)\n    if format_py:\n        command = ['ruff', 'format']\n        if args.v:\n            command.append('-v')\n        else:\n            command.append('-q')\n        command.append('.')\n        subprocess.check_call(command, cwd=TOP)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cmd_parser = argparse.ArgumentParser(description='Auto-format C and Python files.')\n    cmd_parser.add_argument('-c', action='store_true', help='Format C code only')\n    cmd_parser.add_argument('-p', action='store_true', help='Format Python code only')\n    cmd_parser.add_argument('-v', action='store_true', help='Enable verbose output')\n    cmd_parser.add_argument('-f', action='store_true', help='Filter files provided on the command line against the default list of files to check.')\n    cmd_parser.add_argument('files', nargs='*', help='Run on specific globs')\n    args = cmd_parser.parse_args()\n    format_c = args.c or not args.p\n    format_py = args.p or not args.c\n    files = []\n    if args.files:\n        files = list_files(args.files)\n        if args.f:\n            files = set((os.path.abspath(f) for f in files))\n            all_files = set(list_files(PATHS, EXCLUSIONS, TOP))\n            if args.v:\n                for f in files - all_files:\n                    print('Not checking: {}'.format(f))\n            files = list(files & all_files)\n    else:\n        files = list_files(PATHS, EXCLUSIONS, TOP)\n\n    def batch(cmd, N=200):\n        files_iter = iter(files)\n        while True:\n            file_args = list(itertools.islice(files_iter, N))\n            if not file_args:\n                break\n            subprocess.check_call(cmd + file_args)\n    if format_c:\n        command = ['uncrustify', '-c', UNCRUSTIFY_CFG, '-lC', '--no-backup']\n        if not args.v:\n            command.append('-q')\n        batch(command)\n        for file in files:\n            fixup_c(file)\n    if format_py:\n        command = ['ruff', 'format']\n        if args.v:\n            command.append('-v')\n        else:\n            command.append('-q')\n        command.append('.')\n        subprocess.check_call(command, cwd=TOP)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cmd_parser = argparse.ArgumentParser(description='Auto-format C and Python files.')\n    cmd_parser.add_argument('-c', action='store_true', help='Format C code only')\n    cmd_parser.add_argument('-p', action='store_true', help='Format Python code only')\n    cmd_parser.add_argument('-v', action='store_true', help='Enable verbose output')\n    cmd_parser.add_argument('-f', action='store_true', help='Filter files provided on the command line against the default list of files to check.')\n    cmd_parser.add_argument('files', nargs='*', help='Run on specific globs')\n    args = cmd_parser.parse_args()\n    format_c = args.c or not args.p\n    format_py = args.p or not args.c\n    files = []\n    if args.files:\n        files = list_files(args.files)\n        if args.f:\n            files = set((os.path.abspath(f) for f in files))\n            all_files = set(list_files(PATHS, EXCLUSIONS, TOP))\n            if args.v:\n                for f in files - all_files:\n                    print('Not checking: {}'.format(f))\n            files = list(files & all_files)\n    else:\n        files = list_files(PATHS, EXCLUSIONS, TOP)\n\n    def batch(cmd, N=200):\n        files_iter = iter(files)\n        while True:\n            file_args = list(itertools.islice(files_iter, N))\n            if not file_args:\n                break\n            subprocess.check_call(cmd + file_args)\n    if format_c:\n        command = ['uncrustify', '-c', UNCRUSTIFY_CFG, '-lC', '--no-backup']\n        if not args.v:\n            command.append('-q')\n        batch(command)\n        for file in files:\n            fixup_c(file)\n    if format_py:\n        command = ['ruff', 'format']\n        if args.v:\n            command.append('-v')\n        else:\n            command.append('-q')\n        command.append('.')\n        subprocess.check_call(command, cwd=TOP)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cmd_parser = argparse.ArgumentParser(description='Auto-format C and Python files.')\n    cmd_parser.add_argument('-c', action='store_true', help='Format C code only')\n    cmd_parser.add_argument('-p', action='store_true', help='Format Python code only')\n    cmd_parser.add_argument('-v', action='store_true', help='Enable verbose output')\n    cmd_parser.add_argument('-f', action='store_true', help='Filter files provided on the command line against the default list of files to check.')\n    cmd_parser.add_argument('files', nargs='*', help='Run on specific globs')\n    args = cmd_parser.parse_args()\n    format_c = args.c or not args.p\n    format_py = args.p or not args.c\n    files = []\n    if args.files:\n        files = list_files(args.files)\n        if args.f:\n            files = set((os.path.abspath(f) for f in files))\n            all_files = set(list_files(PATHS, EXCLUSIONS, TOP))\n            if args.v:\n                for f in files - all_files:\n                    print('Not checking: {}'.format(f))\n            files = list(files & all_files)\n    else:\n        files = list_files(PATHS, EXCLUSIONS, TOP)\n\n    def batch(cmd, N=200):\n        files_iter = iter(files)\n        while True:\n            file_args = list(itertools.islice(files_iter, N))\n            if not file_args:\n                break\n            subprocess.check_call(cmd + file_args)\n    if format_c:\n        command = ['uncrustify', '-c', UNCRUSTIFY_CFG, '-lC', '--no-backup']\n        if not args.v:\n            command.append('-q')\n        batch(command)\n        for file in files:\n            fixup_c(file)\n    if format_py:\n        command = ['ruff', 'format']\n        if args.v:\n            command.append('-v')\n        else:\n            command.append('-q')\n        command.append('.')\n        subprocess.check_call(command, cwd=TOP)",
            "def main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cmd_parser = argparse.ArgumentParser(description='Auto-format C and Python files.')\n    cmd_parser.add_argument('-c', action='store_true', help='Format C code only')\n    cmd_parser.add_argument('-p', action='store_true', help='Format Python code only')\n    cmd_parser.add_argument('-v', action='store_true', help='Enable verbose output')\n    cmd_parser.add_argument('-f', action='store_true', help='Filter files provided on the command line against the default list of files to check.')\n    cmd_parser.add_argument('files', nargs='*', help='Run on specific globs')\n    args = cmd_parser.parse_args()\n    format_c = args.c or not args.p\n    format_py = args.p or not args.c\n    files = []\n    if args.files:\n        files = list_files(args.files)\n        if args.f:\n            files = set((os.path.abspath(f) for f in files))\n            all_files = set(list_files(PATHS, EXCLUSIONS, TOP))\n            if args.v:\n                for f in files - all_files:\n                    print('Not checking: {}'.format(f))\n            files = list(files & all_files)\n    else:\n        files = list_files(PATHS, EXCLUSIONS, TOP)\n\n    def batch(cmd, N=200):\n        files_iter = iter(files)\n        while True:\n            file_args = list(itertools.islice(files_iter, N))\n            if not file_args:\n                break\n            subprocess.check_call(cmd + file_args)\n    if format_c:\n        command = ['uncrustify', '-c', UNCRUSTIFY_CFG, '-lC', '--no-backup']\n        if not args.v:\n            command.append('-q')\n        batch(command)\n        for file in files:\n            fixup_c(file)\n    if format_py:\n        command = ['ruff', 'format']\n        if args.v:\n            command.append('-v')\n        else:\n            command.append('-q')\n        command.append('.')\n        subprocess.check_call(command, cwd=TOP)"
        ]
    }
]