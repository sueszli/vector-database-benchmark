[
    {
        "func_name": "execute",
        "original": "def execute(self, context):\n    scn = context.scene\n    scn.render.engine = 'CYCLES'\n    obj = context.view_layer.objects.active\n    if obj is None:\n        self.report({'ERROR'}, 'No active object')\n        return {'CANCELLED'}\n    heightMatName = 'Height_' + obj.name\n    if heightMatName not in [m.name for m in bpy.data.materials]:\n        heightMat = bpy.data.materials.new(heightMatName)\n    else:\n        heightMat = bpy.data.materials[heightMatName]\n    heightMat.use_nodes = True\n    heightMat.use_fake_user = True\n    node_tree = heightMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    groupsTree = bpy.data.node_groups\n    \"\\n\\t\\t#make a purge (for testing)\\n\\t\\tfor nodeTree in groupsTree:\\n\\t\\t\\tname = nodeTree.name\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tgroupsTree.remove(nodeTree)\\n\\t\\t\\t\\tprint(name+' has been deleted')\\n\\t\\t\\texcept:\\n\\t\\t\\t\\tprint('cannot delete '+name)\\n\\t\\t\"\n    if 'Normalize' in [nodeTree.name for nodeTree in groupsTree]:\n        scaleNodesGroupTree = groupsTree['Normalize']\n        scaleNodesGroupTree.nodes.clear()\n        scaleNodesGroupTree.inputs.clear()\n        scaleNodesGroupTree.outputs.clear()\n    else:\n        scaleNodesGroupTree = groupsTree.new('Normalize', 'ShaderNodeTree')\n    scaleNodesGroupName = scaleNodesGroupTree.name\n    scaleInputsNode = scaleNodesGroupTree.nodes.new('NodeGroupInput')\n    scaleInputsNode.location = (-350, 0)\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'val')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'min')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'max')\n    scaleOutputsNode = scaleNodesGroupTree.nodes.new('NodeGroupOutput')\n    scaleOutputsNode.location = (300, 0)\n    scaleNodesGroupTree.outputs.new('NodeSocketFloat', 'val')\n    subtractNode1 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode1.operation = 'SUBTRACT'\n    subtractNode1.location = (-100, 100)\n    subtractNode2 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode2.operation = 'SUBTRACT'\n    subtractNode2.location = (-100, -100)\n    divideNode = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    divideNode.operation = 'DIVIDE'\n    divideNode.location = (100, 0)\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['val'], subtractNode1.inputs[0])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode1.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode2.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['max'], subtractNode2.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode1.outputs[0], divideNode.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode2.outputs[0], divideNode.inputs[1])\n    scaleNodesGroupTree.links.new(divideNode.outputs[0], scaleOutputsNode.inputs['val'])\n    scaleNodeGroup = node_tree.nodes.new('ShaderNodeGroup')\n    scaleNodeGroup.node_tree = bpy.data.node_groups[scaleNodesGroupName]\n    scaleNodeGroup.location = (-200, 200)\n    bbox = getBBOX.fromObj(obj)\n    zmin = node_tree.nodes.new('ShaderNodeValue')\n    zmin.label = 'zmin ' + obj.name\n    zmin.outputs[0].default_value = bbox['zmin']\n    zmin.location = (-400, 0)\n    zmax = node_tree.nodes.new('ShaderNodeValue')\n    zmax.label = 'zmax ' + obj.name\n    zmax.outputs[0].default_value = bbox['zmax']\n    zmax.location = (-400, -100)\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (0, 200)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (300, 200)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (500, 200)\n    node_tree.links.new(geomNode.outputs['Position'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], scaleNodeGroup.inputs['val'])\n    node_tree.links.new(zmin.outputs[0], scaleNodeGroup.inputs['min'])\n    node_tree.links.new(zmax.outputs[0], scaleNodeGroup.inputs['max'])\n    node_tree.links.new(scaleNodeGroup.outputs['val'], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    slopeMatName = 'Slope'\n    if slopeMatName not in [m.name for m in bpy.data.materials]:\n        slopeMat = bpy.data.materials.new(slopeMatName)\n    else:\n        slopeMat = bpy.data.materials[slopeMatName]\n    slopeMat.use_nodes = True\n    slopeMat.use_fake_user = True\n    node_tree = slopeMat.node_tree\n    node_tree.nodes.clear()\n    \"\\n\\t\\t# create texture coordinate node (local coordinates)\\n\\t\\ttexCoordNode = node_tree.nodes.new('ShaderNodeTexCoord')\\n\\t\\ttexCoordNode.location = (-600, 0)\\n\\t\\t\"\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 0)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 0)\n    arcCosNode = node_tree.nodes.new('ShaderNodeMath')\n    arcCosNode.operation = 'ARCCOSINE'\n    arcCosNode.location = (-200, 0)\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (0, 0)\n    rad2dg.label = 'Radians to degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (200, 0)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 100\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (400, 0)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].position = 0.5\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (800, 0)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1000, 0)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], arcCosNode.inputs[0])\n    node_tree.links.new(arcCosNode.outputs[0], rad2dg.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], normalize.inputs[0])\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    aspectMatName = 'Aspect'\n    if aspectMatName not in [m.name for m in bpy.data.materials]:\n        aspectMat = bpy.data.materials.new(aspectMatName)\n    else:\n        aspectMat = bpy.data.materials[aspectMatName]\n    aspectMat.use_nodes = True\n    aspectMat.use_fake_user = True\n    node_tree = aspectMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    xyDiv = node_tree.nodes.new('ShaderNodeMath')\n    xyDiv.operation = 'DIVIDE'\n    xyDiv.location = (-200, 0)\n    node_tree.links.new(xyzSplitNode.outputs['X'], xyDiv.inputs[0])\n    node_tree.links.new(xyzSplitNode.outputs['Y'], xyDiv.inputs[1])\n    atanNode = node_tree.nodes.new('ShaderNodeMath')\n    atanNode.operation = 'ARCTANGENT'\n    atanNode.label = 'Aspect radians'\n    atanNode.location = (0, 0)\n    node_tree.links.new(xyDiv.outputs[0], atanNode.inputs[0])\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (200, 0)\n    rad2dg.label = 'Aspect degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    node_tree.links.new(atanNode.outputs[0], rad2dg.inputs[0])\n    yNegMask = node_tree.nodes.new('ShaderNodeMath')\n    yNegMask.operation = 'LESS_THAN'\n    yNegMask.location = (0, 200)\n    yNegMask.label = 'y negative ?'\n    yNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yNegMask.inputs[0])\n    yNegMutiply = node_tree.nodes.new('ShaderNodeMath')\n    yNegMutiply.operation = 'MULTIPLY'\n    yNegMutiply.location = (200, 200)\n    node_tree.links.new(yNegMask.outputs[0], yNegMutiply.inputs[0])\n    yNegMutiply.inputs[1].default_value = 180\n    yNegAdd = node_tree.nodes.new('ShaderNodeMath')\n    yNegAdd.operation = 'ADD'\n    yNegAdd.location = (400, 200)\n    node_tree.links.new(yNegMutiply.outputs[0], yNegAdd.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], yNegAdd.inputs[1])\n    xNegMask = node_tree.nodes.new('ShaderNodeMath')\n    xNegMask.operation = 'LESS_THAN'\n    xNegMask.location = (0, 600)\n    xNegMask.label = 'x negative ?'\n    xNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['X'], xNegMask.inputs[0])\n    yPosMask = node_tree.nodes.new('ShaderNodeMath')\n    yPosMask.operation = 'GREATER_THAN'\n    yPosMask.location = (0, 400)\n    yPosMask.label = 'y positive ?'\n    yPosMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yPosMask.inputs[0])\n    mask = node_tree.nodes.new('ShaderNodeMath')\n    mask.operation = 'MULTIPLY'\n    mask.location = (200, 500)\n    node_tree.links.new(xNegMask.outputs[0], mask.inputs[0])\n    node_tree.links.new(yPosMask.outputs[0], mask.inputs[1])\n    maskMultiply = node_tree.nodes.new('ShaderNodeMath')\n    maskMultiply.operation = 'MULTIPLY'\n    maskMultiply.location = (400, 500)\n    node_tree.links.new(mask.outputs[0], maskMultiply.inputs[0])\n    maskMultiply.inputs[1].default_value = 360\n    maskAdd = node_tree.nodes.new('ShaderNodeMath')\n    maskAdd.operation = 'ADD'\n    maskAdd.location = (600, 300)\n    node_tree.links.new(maskMultiply.outputs[0], maskAdd.inputs[0])\n    node_tree.links.new(yNegAdd.outputs[0], maskAdd.inputs[1])\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (800, 300)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 360\n    node_tree.links.new(maskAdd.outputs[0], normalize.inputs[0])\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (1000, 300)\n    cr = colorRampNode.color_ramp\n    stops = cr.elements\n    cr.elements[0].color = (1, 0, 0, 1)\n    stops.remove(stops[1])\n    colors = [(1, 0.5, 0, 1), (1, 1, 0, 1), (0, 1, 0, 1), (0, 1, 1, 1), (0, 0.5, 1, 1), (0, 0, 1, 1), (1, 0, 1, 1), (1, 0, 0, 1)]\n    for (i, angle) in enumerate([22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5]):\n        pos = scale(angle, 0, 360, 0, 1)\n        stop = stops.new(pos)\n        stop.color = colors[i]\n    cr.interpolation = 'CONSTANT'\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (1300, 300)\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    diffuseFlat = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseFlat.location = (1300, 0)\n    diffuseFlat.inputs[0].default_value = (1, 1, 1, 1)\n    flatMask = node_tree.nodes.new('ShaderNodeMath')\n    flatMask.operation = 'LESS_THAN'\n    flatMask.location = (800, -100)\n    flatMask.label = 'is flat?'\n    flatMask.inputs[1].default_value = 0.999\n    node_tree.links.new(xyzSplitNode.outputs['Z'], flatMask.inputs[0])\n    mixNode = node_tree.nodes.new('ShaderNodeMixShader')\n    mixNode.location = (1500, 200)\n    node_tree.links.new(diffuseNode.outputs['BSDF'], mixNode.inputs[2])\n    node_tree.links.new(diffuseFlat.outputs['BSDF'], mixNode.inputs[1])\n    node_tree.links.new(flatMask.outputs[0], mixNode.inputs['Fac'])\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1700, 200)\n    node_tree.links.new(mixNode.outputs[0], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    '\\n\\t\\tif heightMat.name not in [m.name for m in obj.data.materials]:\\n\\t\\t\\t#add slot & move ui list index\\n\\t\\telse:#this name already exist, just move ui list index to select it\\n\\t\\t\\tobj.active_material_index = obj.material_slots.find(heightMat.name)\\n\\t\\t'\n    obj.data.materials.append(heightMat)\n    obj.active_material_index = len(obj.material_slots) - 1\n    for faces in obj.data.polygons:\n        faces.material_index = obj.active_material_index\n    return {'FINISHED'}",
        "mutated": [
            "def execute(self, context):\n    if False:\n        i = 10\n    scn = context.scene\n    scn.render.engine = 'CYCLES'\n    obj = context.view_layer.objects.active\n    if obj is None:\n        self.report({'ERROR'}, 'No active object')\n        return {'CANCELLED'}\n    heightMatName = 'Height_' + obj.name\n    if heightMatName not in [m.name for m in bpy.data.materials]:\n        heightMat = bpy.data.materials.new(heightMatName)\n    else:\n        heightMat = bpy.data.materials[heightMatName]\n    heightMat.use_nodes = True\n    heightMat.use_fake_user = True\n    node_tree = heightMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    groupsTree = bpy.data.node_groups\n    \"\\n\\t\\t#make a purge (for testing)\\n\\t\\tfor nodeTree in groupsTree:\\n\\t\\t\\tname = nodeTree.name\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tgroupsTree.remove(nodeTree)\\n\\t\\t\\t\\tprint(name+' has been deleted')\\n\\t\\t\\texcept:\\n\\t\\t\\t\\tprint('cannot delete '+name)\\n\\t\\t\"\n    if 'Normalize' in [nodeTree.name for nodeTree in groupsTree]:\n        scaleNodesGroupTree = groupsTree['Normalize']\n        scaleNodesGroupTree.nodes.clear()\n        scaleNodesGroupTree.inputs.clear()\n        scaleNodesGroupTree.outputs.clear()\n    else:\n        scaleNodesGroupTree = groupsTree.new('Normalize', 'ShaderNodeTree')\n    scaleNodesGroupName = scaleNodesGroupTree.name\n    scaleInputsNode = scaleNodesGroupTree.nodes.new('NodeGroupInput')\n    scaleInputsNode.location = (-350, 0)\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'val')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'min')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'max')\n    scaleOutputsNode = scaleNodesGroupTree.nodes.new('NodeGroupOutput')\n    scaleOutputsNode.location = (300, 0)\n    scaleNodesGroupTree.outputs.new('NodeSocketFloat', 'val')\n    subtractNode1 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode1.operation = 'SUBTRACT'\n    subtractNode1.location = (-100, 100)\n    subtractNode2 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode2.operation = 'SUBTRACT'\n    subtractNode2.location = (-100, -100)\n    divideNode = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    divideNode.operation = 'DIVIDE'\n    divideNode.location = (100, 0)\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['val'], subtractNode1.inputs[0])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode1.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode2.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['max'], subtractNode2.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode1.outputs[0], divideNode.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode2.outputs[0], divideNode.inputs[1])\n    scaleNodesGroupTree.links.new(divideNode.outputs[0], scaleOutputsNode.inputs['val'])\n    scaleNodeGroup = node_tree.nodes.new('ShaderNodeGroup')\n    scaleNodeGroup.node_tree = bpy.data.node_groups[scaleNodesGroupName]\n    scaleNodeGroup.location = (-200, 200)\n    bbox = getBBOX.fromObj(obj)\n    zmin = node_tree.nodes.new('ShaderNodeValue')\n    zmin.label = 'zmin ' + obj.name\n    zmin.outputs[0].default_value = bbox['zmin']\n    zmin.location = (-400, 0)\n    zmax = node_tree.nodes.new('ShaderNodeValue')\n    zmax.label = 'zmax ' + obj.name\n    zmax.outputs[0].default_value = bbox['zmax']\n    zmax.location = (-400, -100)\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (0, 200)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (300, 200)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (500, 200)\n    node_tree.links.new(geomNode.outputs['Position'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], scaleNodeGroup.inputs['val'])\n    node_tree.links.new(zmin.outputs[0], scaleNodeGroup.inputs['min'])\n    node_tree.links.new(zmax.outputs[0], scaleNodeGroup.inputs['max'])\n    node_tree.links.new(scaleNodeGroup.outputs['val'], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    slopeMatName = 'Slope'\n    if slopeMatName not in [m.name for m in bpy.data.materials]:\n        slopeMat = bpy.data.materials.new(slopeMatName)\n    else:\n        slopeMat = bpy.data.materials[slopeMatName]\n    slopeMat.use_nodes = True\n    slopeMat.use_fake_user = True\n    node_tree = slopeMat.node_tree\n    node_tree.nodes.clear()\n    \"\\n\\t\\t# create texture coordinate node (local coordinates)\\n\\t\\ttexCoordNode = node_tree.nodes.new('ShaderNodeTexCoord')\\n\\t\\ttexCoordNode.location = (-600, 0)\\n\\t\\t\"\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 0)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 0)\n    arcCosNode = node_tree.nodes.new('ShaderNodeMath')\n    arcCosNode.operation = 'ARCCOSINE'\n    arcCosNode.location = (-200, 0)\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (0, 0)\n    rad2dg.label = 'Radians to degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (200, 0)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 100\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (400, 0)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].position = 0.5\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (800, 0)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1000, 0)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], arcCosNode.inputs[0])\n    node_tree.links.new(arcCosNode.outputs[0], rad2dg.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], normalize.inputs[0])\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    aspectMatName = 'Aspect'\n    if aspectMatName not in [m.name for m in bpy.data.materials]:\n        aspectMat = bpy.data.materials.new(aspectMatName)\n    else:\n        aspectMat = bpy.data.materials[aspectMatName]\n    aspectMat.use_nodes = True\n    aspectMat.use_fake_user = True\n    node_tree = aspectMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    xyDiv = node_tree.nodes.new('ShaderNodeMath')\n    xyDiv.operation = 'DIVIDE'\n    xyDiv.location = (-200, 0)\n    node_tree.links.new(xyzSplitNode.outputs['X'], xyDiv.inputs[0])\n    node_tree.links.new(xyzSplitNode.outputs['Y'], xyDiv.inputs[1])\n    atanNode = node_tree.nodes.new('ShaderNodeMath')\n    atanNode.operation = 'ARCTANGENT'\n    atanNode.label = 'Aspect radians'\n    atanNode.location = (0, 0)\n    node_tree.links.new(xyDiv.outputs[0], atanNode.inputs[0])\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (200, 0)\n    rad2dg.label = 'Aspect degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    node_tree.links.new(atanNode.outputs[0], rad2dg.inputs[0])\n    yNegMask = node_tree.nodes.new('ShaderNodeMath')\n    yNegMask.operation = 'LESS_THAN'\n    yNegMask.location = (0, 200)\n    yNegMask.label = 'y negative ?'\n    yNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yNegMask.inputs[0])\n    yNegMutiply = node_tree.nodes.new('ShaderNodeMath')\n    yNegMutiply.operation = 'MULTIPLY'\n    yNegMutiply.location = (200, 200)\n    node_tree.links.new(yNegMask.outputs[0], yNegMutiply.inputs[0])\n    yNegMutiply.inputs[1].default_value = 180\n    yNegAdd = node_tree.nodes.new('ShaderNodeMath')\n    yNegAdd.operation = 'ADD'\n    yNegAdd.location = (400, 200)\n    node_tree.links.new(yNegMutiply.outputs[0], yNegAdd.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], yNegAdd.inputs[1])\n    xNegMask = node_tree.nodes.new('ShaderNodeMath')\n    xNegMask.operation = 'LESS_THAN'\n    xNegMask.location = (0, 600)\n    xNegMask.label = 'x negative ?'\n    xNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['X'], xNegMask.inputs[0])\n    yPosMask = node_tree.nodes.new('ShaderNodeMath')\n    yPosMask.operation = 'GREATER_THAN'\n    yPosMask.location = (0, 400)\n    yPosMask.label = 'y positive ?'\n    yPosMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yPosMask.inputs[0])\n    mask = node_tree.nodes.new('ShaderNodeMath')\n    mask.operation = 'MULTIPLY'\n    mask.location = (200, 500)\n    node_tree.links.new(xNegMask.outputs[0], mask.inputs[0])\n    node_tree.links.new(yPosMask.outputs[0], mask.inputs[1])\n    maskMultiply = node_tree.nodes.new('ShaderNodeMath')\n    maskMultiply.operation = 'MULTIPLY'\n    maskMultiply.location = (400, 500)\n    node_tree.links.new(mask.outputs[0], maskMultiply.inputs[0])\n    maskMultiply.inputs[1].default_value = 360\n    maskAdd = node_tree.nodes.new('ShaderNodeMath')\n    maskAdd.operation = 'ADD'\n    maskAdd.location = (600, 300)\n    node_tree.links.new(maskMultiply.outputs[0], maskAdd.inputs[0])\n    node_tree.links.new(yNegAdd.outputs[0], maskAdd.inputs[1])\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (800, 300)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 360\n    node_tree.links.new(maskAdd.outputs[0], normalize.inputs[0])\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (1000, 300)\n    cr = colorRampNode.color_ramp\n    stops = cr.elements\n    cr.elements[0].color = (1, 0, 0, 1)\n    stops.remove(stops[1])\n    colors = [(1, 0.5, 0, 1), (1, 1, 0, 1), (0, 1, 0, 1), (0, 1, 1, 1), (0, 0.5, 1, 1), (0, 0, 1, 1), (1, 0, 1, 1), (1, 0, 0, 1)]\n    for (i, angle) in enumerate([22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5]):\n        pos = scale(angle, 0, 360, 0, 1)\n        stop = stops.new(pos)\n        stop.color = colors[i]\n    cr.interpolation = 'CONSTANT'\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (1300, 300)\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    diffuseFlat = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseFlat.location = (1300, 0)\n    diffuseFlat.inputs[0].default_value = (1, 1, 1, 1)\n    flatMask = node_tree.nodes.new('ShaderNodeMath')\n    flatMask.operation = 'LESS_THAN'\n    flatMask.location = (800, -100)\n    flatMask.label = 'is flat?'\n    flatMask.inputs[1].default_value = 0.999\n    node_tree.links.new(xyzSplitNode.outputs['Z'], flatMask.inputs[0])\n    mixNode = node_tree.nodes.new('ShaderNodeMixShader')\n    mixNode.location = (1500, 200)\n    node_tree.links.new(diffuseNode.outputs['BSDF'], mixNode.inputs[2])\n    node_tree.links.new(diffuseFlat.outputs['BSDF'], mixNode.inputs[1])\n    node_tree.links.new(flatMask.outputs[0], mixNode.inputs['Fac'])\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1700, 200)\n    node_tree.links.new(mixNode.outputs[0], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    '\\n\\t\\tif heightMat.name not in [m.name for m in obj.data.materials]:\\n\\t\\t\\t#add slot & move ui list index\\n\\t\\telse:#this name already exist, just move ui list index to select it\\n\\t\\t\\tobj.active_material_index = obj.material_slots.find(heightMat.name)\\n\\t\\t'\n    obj.data.materials.append(heightMat)\n    obj.active_material_index = len(obj.material_slots) - 1\n    for faces in obj.data.polygons:\n        faces.material_index = obj.active_material_index\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    scn = context.scene\n    scn.render.engine = 'CYCLES'\n    obj = context.view_layer.objects.active\n    if obj is None:\n        self.report({'ERROR'}, 'No active object')\n        return {'CANCELLED'}\n    heightMatName = 'Height_' + obj.name\n    if heightMatName not in [m.name for m in bpy.data.materials]:\n        heightMat = bpy.data.materials.new(heightMatName)\n    else:\n        heightMat = bpy.data.materials[heightMatName]\n    heightMat.use_nodes = True\n    heightMat.use_fake_user = True\n    node_tree = heightMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    groupsTree = bpy.data.node_groups\n    \"\\n\\t\\t#make a purge (for testing)\\n\\t\\tfor nodeTree in groupsTree:\\n\\t\\t\\tname = nodeTree.name\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tgroupsTree.remove(nodeTree)\\n\\t\\t\\t\\tprint(name+' has been deleted')\\n\\t\\t\\texcept:\\n\\t\\t\\t\\tprint('cannot delete '+name)\\n\\t\\t\"\n    if 'Normalize' in [nodeTree.name for nodeTree in groupsTree]:\n        scaleNodesGroupTree = groupsTree['Normalize']\n        scaleNodesGroupTree.nodes.clear()\n        scaleNodesGroupTree.inputs.clear()\n        scaleNodesGroupTree.outputs.clear()\n    else:\n        scaleNodesGroupTree = groupsTree.new('Normalize', 'ShaderNodeTree')\n    scaleNodesGroupName = scaleNodesGroupTree.name\n    scaleInputsNode = scaleNodesGroupTree.nodes.new('NodeGroupInput')\n    scaleInputsNode.location = (-350, 0)\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'val')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'min')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'max')\n    scaleOutputsNode = scaleNodesGroupTree.nodes.new('NodeGroupOutput')\n    scaleOutputsNode.location = (300, 0)\n    scaleNodesGroupTree.outputs.new('NodeSocketFloat', 'val')\n    subtractNode1 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode1.operation = 'SUBTRACT'\n    subtractNode1.location = (-100, 100)\n    subtractNode2 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode2.operation = 'SUBTRACT'\n    subtractNode2.location = (-100, -100)\n    divideNode = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    divideNode.operation = 'DIVIDE'\n    divideNode.location = (100, 0)\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['val'], subtractNode1.inputs[0])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode1.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode2.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['max'], subtractNode2.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode1.outputs[0], divideNode.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode2.outputs[0], divideNode.inputs[1])\n    scaleNodesGroupTree.links.new(divideNode.outputs[0], scaleOutputsNode.inputs['val'])\n    scaleNodeGroup = node_tree.nodes.new('ShaderNodeGroup')\n    scaleNodeGroup.node_tree = bpy.data.node_groups[scaleNodesGroupName]\n    scaleNodeGroup.location = (-200, 200)\n    bbox = getBBOX.fromObj(obj)\n    zmin = node_tree.nodes.new('ShaderNodeValue')\n    zmin.label = 'zmin ' + obj.name\n    zmin.outputs[0].default_value = bbox['zmin']\n    zmin.location = (-400, 0)\n    zmax = node_tree.nodes.new('ShaderNodeValue')\n    zmax.label = 'zmax ' + obj.name\n    zmax.outputs[0].default_value = bbox['zmax']\n    zmax.location = (-400, -100)\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (0, 200)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (300, 200)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (500, 200)\n    node_tree.links.new(geomNode.outputs['Position'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], scaleNodeGroup.inputs['val'])\n    node_tree.links.new(zmin.outputs[0], scaleNodeGroup.inputs['min'])\n    node_tree.links.new(zmax.outputs[0], scaleNodeGroup.inputs['max'])\n    node_tree.links.new(scaleNodeGroup.outputs['val'], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    slopeMatName = 'Slope'\n    if slopeMatName not in [m.name for m in bpy.data.materials]:\n        slopeMat = bpy.data.materials.new(slopeMatName)\n    else:\n        slopeMat = bpy.data.materials[slopeMatName]\n    slopeMat.use_nodes = True\n    slopeMat.use_fake_user = True\n    node_tree = slopeMat.node_tree\n    node_tree.nodes.clear()\n    \"\\n\\t\\t# create texture coordinate node (local coordinates)\\n\\t\\ttexCoordNode = node_tree.nodes.new('ShaderNodeTexCoord')\\n\\t\\ttexCoordNode.location = (-600, 0)\\n\\t\\t\"\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 0)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 0)\n    arcCosNode = node_tree.nodes.new('ShaderNodeMath')\n    arcCosNode.operation = 'ARCCOSINE'\n    arcCosNode.location = (-200, 0)\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (0, 0)\n    rad2dg.label = 'Radians to degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (200, 0)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 100\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (400, 0)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].position = 0.5\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (800, 0)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1000, 0)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], arcCosNode.inputs[0])\n    node_tree.links.new(arcCosNode.outputs[0], rad2dg.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], normalize.inputs[0])\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    aspectMatName = 'Aspect'\n    if aspectMatName not in [m.name for m in bpy.data.materials]:\n        aspectMat = bpy.data.materials.new(aspectMatName)\n    else:\n        aspectMat = bpy.data.materials[aspectMatName]\n    aspectMat.use_nodes = True\n    aspectMat.use_fake_user = True\n    node_tree = aspectMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    xyDiv = node_tree.nodes.new('ShaderNodeMath')\n    xyDiv.operation = 'DIVIDE'\n    xyDiv.location = (-200, 0)\n    node_tree.links.new(xyzSplitNode.outputs['X'], xyDiv.inputs[0])\n    node_tree.links.new(xyzSplitNode.outputs['Y'], xyDiv.inputs[1])\n    atanNode = node_tree.nodes.new('ShaderNodeMath')\n    atanNode.operation = 'ARCTANGENT'\n    atanNode.label = 'Aspect radians'\n    atanNode.location = (0, 0)\n    node_tree.links.new(xyDiv.outputs[0], atanNode.inputs[0])\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (200, 0)\n    rad2dg.label = 'Aspect degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    node_tree.links.new(atanNode.outputs[0], rad2dg.inputs[0])\n    yNegMask = node_tree.nodes.new('ShaderNodeMath')\n    yNegMask.operation = 'LESS_THAN'\n    yNegMask.location = (0, 200)\n    yNegMask.label = 'y negative ?'\n    yNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yNegMask.inputs[0])\n    yNegMutiply = node_tree.nodes.new('ShaderNodeMath')\n    yNegMutiply.operation = 'MULTIPLY'\n    yNegMutiply.location = (200, 200)\n    node_tree.links.new(yNegMask.outputs[0], yNegMutiply.inputs[0])\n    yNegMutiply.inputs[1].default_value = 180\n    yNegAdd = node_tree.nodes.new('ShaderNodeMath')\n    yNegAdd.operation = 'ADD'\n    yNegAdd.location = (400, 200)\n    node_tree.links.new(yNegMutiply.outputs[0], yNegAdd.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], yNegAdd.inputs[1])\n    xNegMask = node_tree.nodes.new('ShaderNodeMath')\n    xNegMask.operation = 'LESS_THAN'\n    xNegMask.location = (0, 600)\n    xNegMask.label = 'x negative ?'\n    xNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['X'], xNegMask.inputs[0])\n    yPosMask = node_tree.nodes.new('ShaderNodeMath')\n    yPosMask.operation = 'GREATER_THAN'\n    yPosMask.location = (0, 400)\n    yPosMask.label = 'y positive ?'\n    yPosMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yPosMask.inputs[0])\n    mask = node_tree.nodes.new('ShaderNodeMath')\n    mask.operation = 'MULTIPLY'\n    mask.location = (200, 500)\n    node_tree.links.new(xNegMask.outputs[0], mask.inputs[0])\n    node_tree.links.new(yPosMask.outputs[0], mask.inputs[1])\n    maskMultiply = node_tree.nodes.new('ShaderNodeMath')\n    maskMultiply.operation = 'MULTIPLY'\n    maskMultiply.location = (400, 500)\n    node_tree.links.new(mask.outputs[0], maskMultiply.inputs[0])\n    maskMultiply.inputs[1].default_value = 360\n    maskAdd = node_tree.nodes.new('ShaderNodeMath')\n    maskAdd.operation = 'ADD'\n    maskAdd.location = (600, 300)\n    node_tree.links.new(maskMultiply.outputs[0], maskAdd.inputs[0])\n    node_tree.links.new(yNegAdd.outputs[0], maskAdd.inputs[1])\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (800, 300)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 360\n    node_tree.links.new(maskAdd.outputs[0], normalize.inputs[0])\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (1000, 300)\n    cr = colorRampNode.color_ramp\n    stops = cr.elements\n    cr.elements[0].color = (1, 0, 0, 1)\n    stops.remove(stops[1])\n    colors = [(1, 0.5, 0, 1), (1, 1, 0, 1), (0, 1, 0, 1), (0, 1, 1, 1), (0, 0.5, 1, 1), (0, 0, 1, 1), (1, 0, 1, 1), (1, 0, 0, 1)]\n    for (i, angle) in enumerate([22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5]):\n        pos = scale(angle, 0, 360, 0, 1)\n        stop = stops.new(pos)\n        stop.color = colors[i]\n    cr.interpolation = 'CONSTANT'\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (1300, 300)\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    diffuseFlat = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseFlat.location = (1300, 0)\n    diffuseFlat.inputs[0].default_value = (1, 1, 1, 1)\n    flatMask = node_tree.nodes.new('ShaderNodeMath')\n    flatMask.operation = 'LESS_THAN'\n    flatMask.location = (800, -100)\n    flatMask.label = 'is flat?'\n    flatMask.inputs[1].default_value = 0.999\n    node_tree.links.new(xyzSplitNode.outputs['Z'], flatMask.inputs[0])\n    mixNode = node_tree.nodes.new('ShaderNodeMixShader')\n    mixNode.location = (1500, 200)\n    node_tree.links.new(diffuseNode.outputs['BSDF'], mixNode.inputs[2])\n    node_tree.links.new(diffuseFlat.outputs['BSDF'], mixNode.inputs[1])\n    node_tree.links.new(flatMask.outputs[0], mixNode.inputs['Fac'])\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1700, 200)\n    node_tree.links.new(mixNode.outputs[0], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    '\\n\\t\\tif heightMat.name not in [m.name for m in obj.data.materials]:\\n\\t\\t\\t#add slot & move ui list index\\n\\t\\telse:#this name already exist, just move ui list index to select it\\n\\t\\t\\tobj.active_material_index = obj.material_slots.find(heightMat.name)\\n\\t\\t'\n    obj.data.materials.append(heightMat)\n    obj.active_material_index = len(obj.material_slots) - 1\n    for faces in obj.data.polygons:\n        faces.material_index = obj.active_material_index\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    scn = context.scene\n    scn.render.engine = 'CYCLES'\n    obj = context.view_layer.objects.active\n    if obj is None:\n        self.report({'ERROR'}, 'No active object')\n        return {'CANCELLED'}\n    heightMatName = 'Height_' + obj.name\n    if heightMatName not in [m.name for m in bpy.data.materials]:\n        heightMat = bpy.data.materials.new(heightMatName)\n    else:\n        heightMat = bpy.data.materials[heightMatName]\n    heightMat.use_nodes = True\n    heightMat.use_fake_user = True\n    node_tree = heightMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    groupsTree = bpy.data.node_groups\n    \"\\n\\t\\t#make a purge (for testing)\\n\\t\\tfor nodeTree in groupsTree:\\n\\t\\t\\tname = nodeTree.name\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tgroupsTree.remove(nodeTree)\\n\\t\\t\\t\\tprint(name+' has been deleted')\\n\\t\\t\\texcept:\\n\\t\\t\\t\\tprint('cannot delete '+name)\\n\\t\\t\"\n    if 'Normalize' in [nodeTree.name for nodeTree in groupsTree]:\n        scaleNodesGroupTree = groupsTree['Normalize']\n        scaleNodesGroupTree.nodes.clear()\n        scaleNodesGroupTree.inputs.clear()\n        scaleNodesGroupTree.outputs.clear()\n    else:\n        scaleNodesGroupTree = groupsTree.new('Normalize', 'ShaderNodeTree')\n    scaleNodesGroupName = scaleNodesGroupTree.name\n    scaleInputsNode = scaleNodesGroupTree.nodes.new('NodeGroupInput')\n    scaleInputsNode.location = (-350, 0)\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'val')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'min')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'max')\n    scaleOutputsNode = scaleNodesGroupTree.nodes.new('NodeGroupOutput')\n    scaleOutputsNode.location = (300, 0)\n    scaleNodesGroupTree.outputs.new('NodeSocketFloat', 'val')\n    subtractNode1 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode1.operation = 'SUBTRACT'\n    subtractNode1.location = (-100, 100)\n    subtractNode2 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode2.operation = 'SUBTRACT'\n    subtractNode2.location = (-100, -100)\n    divideNode = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    divideNode.operation = 'DIVIDE'\n    divideNode.location = (100, 0)\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['val'], subtractNode1.inputs[0])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode1.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode2.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['max'], subtractNode2.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode1.outputs[0], divideNode.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode2.outputs[0], divideNode.inputs[1])\n    scaleNodesGroupTree.links.new(divideNode.outputs[0], scaleOutputsNode.inputs['val'])\n    scaleNodeGroup = node_tree.nodes.new('ShaderNodeGroup')\n    scaleNodeGroup.node_tree = bpy.data.node_groups[scaleNodesGroupName]\n    scaleNodeGroup.location = (-200, 200)\n    bbox = getBBOX.fromObj(obj)\n    zmin = node_tree.nodes.new('ShaderNodeValue')\n    zmin.label = 'zmin ' + obj.name\n    zmin.outputs[0].default_value = bbox['zmin']\n    zmin.location = (-400, 0)\n    zmax = node_tree.nodes.new('ShaderNodeValue')\n    zmax.label = 'zmax ' + obj.name\n    zmax.outputs[0].default_value = bbox['zmax']\n    zmax.location = (-400, -100)\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (0, 200)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (300, 200)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (500, 200)\n    node_tree.links.new(geomNode.outputs['Position'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], scaleNodeGroup.inputs['val'])\n    node_tree.links.new(zmin.outputs[0], scaleNodeGroup.inputs['min'])\n    node_tree.links.new(zmax.outputs[0], scaleNodeGroup.inputs['max'])\n    node_tree.links.new(scaleNodeGroup.outputs['val'], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    slopeMatName = 'Slope'\n    if slopeMatName not in [m.name for m in bpy.data.materials]:\n        slopeMat = bpy.data.materials.new(slopeMatName)\n    else:\n        slopeMat = bpy.data.materials[slopeMatName]\n    slopeMat.use_nodes = True\n    slopeMat.use_fake_user = True\n    node_tree = slopeMat.node_tree\n    node_tree.nodes.clear()\n    \"\\n\\t\\t# create texture coordinate node (local coordinates)\\n\\t\\ttexCoordNode = node_tree.nodes.new('ShaderNodeTexCoord')\\n\\t\\ttexCoordNode.location = (-600, 0)\\n\\t\\t\"\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 0)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 0)\n    arcCosNode = node_tree.nodes.new('ShaderNodeMath')\n    arcCosNode.operation = 'ARCCOSINE'\n    arcCosNode.location = (-200, 0)\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (0, 0)\n    rad2dg.label = 'Radians to degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (200, 0)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 100\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (400, 0)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].position = 0.5\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (800, 0)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1000, 0)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], arcCosNode.inputs[0])\n    node_tree.links.new(arcCosNode.outputs[0], rad2dg.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], normalize.inputs[0])\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    aspectMatName = 'Aspect'\n    if aspectMatName not in [m.name for m in bpy.data.materials]:\n        aspectMat = bpy.data.materials.new(aspectMatName)\n    else:\n        aspectMat = bpy.data.materials[aspectMatName]\n    aspectMat.use_nodes = True\n    aspectMat.use_fake_user = True\n    node_tree = aspectMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    xyDiv = node_tree.nodes.new('ShaderNodeMath')\n    xyDiv.operation = 'DIVIDE'\n    xyDiv.location = (-200, 0)\n    node_tree.links.new(xyzSplitNode.outputs['X'], xyDiv.inputs[0])\n    node_tree.links.new(xyzSplitNode.outputs['Y'], xyDiv.inputs[1])\n    atanNode = node_tree.nodes.new('ShaderNodeMath')\n    atanNode.operation = 'ARCTANGENT'\n    atanNode.label = 'Aspect radians'\n    atanNode.location = (0, 0)\n    node_tree.links.new(xyDiv.outputs[0], atanNode.inputs[0])\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (200, 0)\n    rad2dg.label = 'Aspect degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    node_tree.links.new(atanNode.outputs[0], rad2dg.inputs[0])\n    yNegMask = node_tree.nodes.new('ShaderNodeMath')\n    yNegMask.operation = 'LESS_THAN'\n    yNegMask.location = (0, 200)\n    yNegMask.label = 'y negative ?'\n    yNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yNegMask.inputs[0])\n    yNegMutiply = node_tree.nodes.new('ShaderNodeMath')\n    yNegMutiply.operation = 'MULTIPLY'\n    yNegMutiply.location = (200, 200)\n    node_tree.links.new(yNegMask.outputs[0], yNegMutiply.inputs[0])\n    yNegMutiply.inputs[1].default_value = 180\n    yNegAdd = node_tree.nodes.new('ShaderNodeMath')\n    yNegAdd.operation = 'ADD'\n    yNegAdd.location = (400, 200)\n    node_tree.links.new(yNegMutiply.outputs[0], yNegAdd.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], yNegAdd.inputs[1])\n    xNegMask = node_tree.nodes.new('ShaderNodeMath')\n    xNegMask.operation = 'LESS_THAN'\n    xNegMask.location = (0, 600)\n    xNegMask.label = 'x negative ?'\n    xNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['X'], xNegMask.inputs[0])\n    yPosMask = node_tree.nodes.new('ShaderNodeMath')\n    yPosMask.operation = 'GREATER_THAN'\n    yPosMask.location = (0, 400)\n    yPosMask.label = 'y positive ?'\n    yPosMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yPosMask.inputs[0])\n    mask = node_tree.nodes.new('ShaderNodeMath')\n    mask.operation = 'MULTIPLY'\n    mask.location = (200, 500)\n    node_tree.links.new(xNegMask.outputs[0], mask.inputs[0])\n    node_tree.links.new(yPosMask.outputs[0], mask.inputs[1])\n    maskMultiply = node_tree.nodes.new('ShaderNodeMath')\n    maskMultiply.operation = 'MULTIPLY'\n    maskMultiply.location = (400, 500)\n    node_tree.links.new(mask.outputs[0], maskMultiply.inputs[0])\n    maskMultiply.inputs[1].default_value = 360\n    maskAdd = node_tree.nodes.new('ShaderNodeMath')\n    maskAdd.operation = 'ADD'\n    maskAdd.location = (600, 300)\n    node_tree.links.new(maskMultiply.outputs[0], maskAdd.inputs[0])\n    node_tree.links.new(yNegAdd.outputs[0], maskAdd.inputs[1])\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (800, 300)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 360\n    node_tree.links.new(maskAdd.outputs[0], normalize.inputs[0])\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (1000, 300)\n    cr = colorRampNode.color_ramp\n    stops = cr.elements\n    cr.elements[0].color = (1, 0, 0, 1)\n    stops.remove(stops[1])\n    colors = [(1, 0.5, 0, 1), (1, 1, 0, 1), (0, 1, 0, 1), (0, 1, 1, 1), (0, 0.5, 1, 1), (0, 0, 1, 1), (1, 0, 1, 1), (1, 0, 0, 1)]\n    for (i, angle) in enumerate([22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5]):\n        pos = scale(angle, 0, 360, 0, 1)\n        stop = stops.new(pos)\n        stop.color = colors[i]\n    cr.interpolation = 'CONSTANT'\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (1300, 300)\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    diffuseFlat = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseFlat.location = (1300, 0)\n    diffuseFlat.inputs[0].default_value = (1, 1, 1, 1)\n    flatMask = node_tree.nodes.new('ShaderNodeMath')\n    flatMask.operation = 'LESS_THAN'\n    flatMask.location = (800, -100)\n    flatMask.label = 'is flat?'\n    flatMask.inputs[1].default_value = 0.999\n    node_tree.links.new(xyzSplitNode.outputs['Z'], flatMask.inputs[0])\n    mixNode = node_tree.nodes.new('ShaderNodeMixShader')\n    mixNode.location = (1500, 200)\n    node_tree.links.new(diffuseNode.outputs['BSDF'], mixNode.inputs[2])\n    node_tree.links.new(diffuseFlat.outputs['BSDF'], mixNode.inputs[1])\n    node_tree.links.new(flatMask.outputs[0], mixNode.inputs['Fac'])\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1700, 200)\n    node_tree.links.new(mixNode.outputs[0], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    '\\n\\t\\tif heightMat.name not in [m.name for m in obj.data.materials]:\\n\\t\\t\\t#add slot & move ui list index\\n\\t\\telse:#this name already exist, just move ui list index to select it\\n\\t\\t\\tobj.active_material_index = obj.material_slots.find(heightMat.name)\\n\\t\\t'\n    obj.data.materials.append(heightMat)\n    obj.active_material_index = len(obj.material_slots) - 1\n    for faces in obj.data.polygons:\n        faces.material_index = obj.active_material_index\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    scn = context.scene\n    scn.render.engine = 'CYCLES'\n    obj = context.view_layer.objects.active\n    if obj is None:\n        self.report({'ERROR'}, 'No active object')\n        return {'CANCELLED'}\n    heightMatName = 'Height_' + obj.name\n    if heightMatName not in [m.name for m in bpy.data.materials]:\n        heightMat = bpy.data.materials.new(heightMatName)\n    else:\n        heightMat = bpy.data.materials[heightMatName]\n    heightMat.use_nodes = True\n    heightMat.use_fake_user = True\n    node_tree = heightMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    groupsTree = bpy.data.node_groups\n    \"\\n\\t\\t#make a purge (for testing)\\n\\t\\tfor nodeTree in groupsTree:\\n\\t\\t\\tname = nodeTree.name\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tgroupsTree.remove(nodeTree)\\n\\t\\t\\t\\tprint(name+' has been deleted')\\n\\t\\t\\texcept:\\n\\t\\t\\t\\tprint('cannot delete '+name)\\n\\t\\t\"\n    if 'Normalize' in [nodeTree.name for nodeTree in groupsTree]:\n        scaleNodesGroupTree = groupsTree['Normalize']\n        scaleNodesGroupTree.nodes.clear()\n        scaleNodesGroupTree.inputs.clear()\n        scaleNodesGroupTree.outputs.clear()\n    else:\n        scaleNodesGroupTree = groupsTree.new('Normalize', 'ShaderNodeTree')\n    scaleNodesGroupName = scaleNodesGroupTree.name\n    scaleInputsNode = scaleNodesGroupTree.nodes.new('NodeGroupInput')\n    scaleInputsNode.location = (-350, 0)\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'val')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'min')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'max')\n    scaleOutputsNode = scaleNodesGroupTree.nodes.new('NodeGroupOutput')\n    scaleOutputsNode.location = (300, 0)\n    scaleNodesGroupTree.outputs.new('NodeSocketFloat', 'val')\n    subtractNode1 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode1.operation = 'SUBTRACT'\n    subtractNode1.location = (-100, 100)\n    subtractNode2 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode2.operation = 'SUBTRACT'\n    subtractNode2.location = (-100, -100)\n    divideNode = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    divideNode.operation = 'DIVIDE'\n    divideNode.location = (100, 0)\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['val'], subtractNode1.inputs[0])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode1.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode2.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['max'], subtractNode2.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode1.outputs[0], divideNode.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode2.outputs[0], divideNode.inputs[1])\n    scaleNodesGroupTree.links.new(divideNode.outputs[0], scaleOutputsNode.inputs['val'])\n    scaleNodeGroup = node_tree.nodes.new('ShaderNodeGroup')\n    scaleNodeGroup.node_tree = bpy.data.node_groups[scaleNodesGroupName]\n    scaleNodeGroup.location = (-200, 200)\n    bbox = getBBOX.fromObj(obj)\n    zmin = node_tree.nodes.new('ShaderNodeValue')\n    zmin.label = 'zmin ' + obj.name\n    zmin.outputs[0].default_value = bbox['zmin']\n    zmin.location = (-400, 0)\n    zmax = node_tree.nodes.new('ShaderNodeValue')\n    zmax.label = 'zmax ' + obj.name\n    zmax.outputs[0].default_value = bbox['zmax']\n    zmax.location = (-400, -100)\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (0, 200)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (300, 200)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (500, 200)\n    node_tree.links.new(geomNode.outputs['Position'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], scaleNodeGroup.inputs['val'])\n    node_tree.links.new(zmin.outputs[0], scaleNodeGroup.inputs['min'])\n    node_tree.links.new(zmax.outputs[0], scaleNodeGroup.inputs['max'])\n    node_tree.links.new(scaleNodeGroup.outputs['val'], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    slopeMatName = 'Slope'\n    if slopeMatName not in [m.name for m in bpy.data.materials]:\n        slopeMat = bpy.data.materials.new(slopeMatName)\n    else:\n        slopeMat = bpy.data.materials[slopeMatName]\n    slopeMat.use_nodes = True\n    slopeMat.use_fake_user = True\n    node_tree = slopeMat.node_tree\n    node_tree.nodes.clear()\n    \"\\n\\t\\t# create texture coordinate node (local coordinates)\\n\\t\\ttexCoordNode = node_tree.nodes.new('ShaderNodeTexCoord')\\n\\t\\ttexCoordNode.location = (-600, 0)\\n\\t\\t\"\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 0)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 0)\n    arcCosNode = node_tree.nodes.new('ShaderNodeMath')\n    arcCosNode.operation = 'ARCCOSINE'\n    arcCosNode.location = (-200, 0)\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (0, 0)\n    rad2dg.label = 'Radians to degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (200, 0)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 100\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (400, 0)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].position = 0.5\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (800, 0)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1000, 0)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], arcCosNode.inputs[0])\n    node_tree.links.new(arcCosNode.outputs[0], rad2dg.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], normalize.inputs[0])\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    aspectMatName = 'Aspect'\n    if aspectMatName not in [m.name for m in bpy.data.materials]:\n        aspectMat = bpy.data.materials.new(aspectMatName)\n    else:\n        aspectMat = bpy.data.materials[aspectMatName]\n    aspectMat.use_nodes = True\n    aspectMat.use_fake_user = True\n    node_tree = aspectMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    xyDiv = node_tree.nodes.new('ShaderNodeMath')\n    xyDiv.operation = 'DIVIDE'\n    xyDiv.location = (-200, 0)\n    node_tree.links.new(xyzSplitNode.outputs['X'], xyDiv.inputs[0])\n    node_tree.links.new(xyzSplitNode.outputs['Y'], xyDiv.inputs[1])\n    atanNode = node_tree.nodes.new('ShaderNodeMath')\n    atanNode.operation = 'ARCTANGENT'\n    atanNode.label = 'Aspect radians'\n    atanNode.location = (0, 0)\n    node_tree.links.new(xyDiv.outputs[0], atanNode.inputs[0])\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (200, 0)\n    rad2dg.label = 'Aspect degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    node_tree.links.new(atanNode.outputs[0], rad2dg.inputs[0])\n    yNegMask = node_tree.nodes.new('ShaderNodeMath')\n    yNegMask.operation = 'LESS_THAN'\n    yNegMask.location = (0, 200)\n    yNegMask.label = 'y negative ?'\n    yNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yNegMask.inputs[0])\n    yNegMutiply = node_tree.nodes.new('ShaderNodeMath')\n    yNegMutiply.operation = 'MULTIPLY'\n    yNegMutiply.location = (200, 200)\n    node_tree.links.new(yNegMask.outputs[0], yNegMutiply.inputs[0])\n    yNegMutiply.inputs[1].default_value = 180\n    yNegAdd = node_tree.nodes.new('ShaderNodeMath')\n    yNegAdd.operation = 'ADD'\n    yNegAdd.location = (400, 200)\n    node_tree.links.new(yNegMutiply.outputs[0], yNegAdd.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], yNegAdd.inputs[1])\n    xNegMask = node_tree.nodes.new('ShaderNodeMath')\n    xNegMask.operation = 'LESS_THAN'\n    xNegMask.location = (0, 600)\n    xNegMask.label = 'x negative ?'\n    xNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['X'], xNegMask.inputs[0])\n    yPosMask = node_tree.nodes.new('ShaderNodeMath')\n    yPosMask.operation = 'GREATER_THAN'\n    yPosMask.location = (0, 400)\n    yPosMask.label = 'y positive ?'\n    yPosMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yPosMask.inputs[0])\n    mask = node_tree.nodes.new('ShaderNodeMath')\n    mask.operation = 'MULTIPLY'\n    mask.location = (200, 500)\n    node_tree.links.new(xNegMask.outputs[0], mask.inputs[0])\n    node_tree.links.new(yPosMask.outputs[0], mask.inputs[1])\n    maskMultiply = node_tree.nodes.new('ShaderNodeMath')\n    maskMultiply.operation = 'MULTIPLY'\n    maskMultiply.location = (400, 500)\n    node_tree.links.new(mask.outputs[0], maskMultiply.inputs[0])\n    maskMultiply.inputs[1].default_value = 360\n    maskAdd = node_tree.nodes.new('ShaderNodeMath')\n    maskAdd.operation = 'ADD'\n    maskAdd.location = (600, 300)\n    node_tree.links.new(maskMultiply.outputs[0], maskAdd.inputs[0])\n    node_tree.links.new(yNegAdd.outputs[0], maskAdd.inputs[1])\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (800, 300)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 360\n    node_tree.links.new(maskAdd.outputs[0], normalize.inputs[0])\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (1000, 300)\n    cr = colorRampNode.color_ramp\n    stops = cr.elements\n    cr.elements[0].color = (1, 0, 0, 1)\n    stops.remove(stops[1])\n    colors = [(1, 0.5, 0, 1), (1, 1, 0, 1), (0, 1, 0, 1), (0, 1, 1, 1), (0, 0.5, 1, 1), (0, 0, 1, 1), (1, 0, 1, 1), (1, 0, 0, 1)]\n    for (i, angle) in enumerate([22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5]):\n        pos = scale(angle, 0, 360, 0, 1)\n        stop = stops.new(pos)\n        stop.color = colors[i]\n    cr.interpolation = 'CONSTANT'\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (1300, 300)\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    diffuseFlat = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseFlat.location = (1300, 0)\n    diffuseFlat.inputs[0].default_value = (1, 1, 1, 1)\n    flatMask = node_tree.nodes.new('ShaderNodeMath')\n    flatMask.operation = 'LESS_THAN'\n    flatMask.location = (800, -100)\n    flatMask.label = 'is flat?'\n    flatMask.inputs[1].default_value = 0.999\n    node_tree.links.new(xyzSplitNode.outputs['Z'], flatMask.inputs[0])\n    mixNode = node_tree.nodes.new('ShaderNodeMixShader')\n    mixNode.location = (1500, 200)\n    node_tree.links.new(diffuseNode.outputs['BSDF'], mixNode.inputs[2])\n    node_tree.links.new(diffuseFlat.outputs['BSDF'], mixNode.inputs[1])\n    node_tree.links.new(flatMask.outputs[0], mixNode.inputs['Fac'])\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1700, 200)\n    node_tree.links.new(mixNode.outputs[0], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    '\\n\\t\\tif heightMat.name not in [m.name for m in obj.data.materials]:\\n\\t\\t\\t#add slot & move ui list index\\n\\t\\telse:#this name already exist, just move ui list index to select it\\n\\t\\t\\tobj.active_material_index = obj.material_slots.find(heightMat.name)\\n\\t\\t'\n    obj.data.materials.append(heightMat)\n    obj.active_material_index = len(obj.material_slots) - 1\n    for faces in obj.data.polygons:\n        faces.material_index = obj.active_material_index\n    return {'FINISHED'}",
            "def execute(self, context):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    scn = context.scene\n    scn.render.engine = 'CYCLES'\n    obj = context.view_layer.objects.active\n    if obj is None:\n        self.report({'ERROR'}, 'No active object')\n        return {'CANCELLED'}\n    heightMatName = 'Height_' + obj.name\n    if heightMatName not in [m.name for m in bpy.data.materials]:\n        heightMat = bpy.data.materials.new(heightMatName)\n    else:\n        heightMat = bpy.data.materials[heightMatName]\n    heightMat.use_nodes = True\n    heightMat.use_fake_user = True\n    node_tree = heightMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    groupsTree = bpy.data.node_groups\n    \"\\n\\t\\t#make a purge (for testing)\\n\\t\\tfor nodeTree in groupsTree:\\n\\t\\t\\tname = nodeTree.name\\n\\t\\t\\ttry:\\n\\t\\t\\t\\tgroupsTree.remove(nodeTree)\\n\\t\\t\\t\\tprint(name+' has been deleted')\\n\\t\\t\\texcept:\\n\\t\\t\\t\\tprint('cannot delete '+name)\\n\\t\\t\"\n    if 'Normalize' in [nodeTree.name for nodeTree in groupsTree]:\n        scaleNodesGroupTree = groupsTree['Normalize']\n        scaleNodesGroupTree.nodes.clear()\n        scaleNodesGroupTree.inputs.clear()\n        scaleNodesGroupTree.outputs.clear()\n    else:\n        scaleNodesGroupTree = groupsTree.new('Normalize', 'ShaderNodeTree')\n    scaleNodesGroupName = scaleNodesGroupTree.name\n    scaleInputsNode = scaleNodesGroupTree.nodes.new('NodeGroupInput')\n    scaleInputsNode.location = (-350, 0)\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'val')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'min')\n    scaleNodesGroupTree.inputs.new('NodeSocketFloat', 'max')\n    scaleOutputsNode = scaleNodesGroupTree.nodes.new('NodeGroupOutput')\n    scaleOutputsNode.location = (300, 0)\n    scaleNodesGroupTree.outputs.new('NodeSocketFloat', 'val')\n    subtractNode1 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode1.operation = 'SUBTRACT'\n    subtractNode1.location = (-100, 100)\n    subtractNode2 = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    subtractNode2.operation = 'SUBTRACT'\n    subtractNode2.location = (-100, -100)\n    divideNode = scaleNodesGroupTree.nodes.new('ShaderNodeMath')\n    divideNode.operation = 'DIVIDE'\n    divideNode.location = (100, 0)\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['val'], subtractNode1.inputs[0])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode1.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['min'], subtractNode2.inputs[1])\n    scaleNodesGroupTree.links.new(scaleInputsNode.outputs['max'], subtractNode2.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode1.outputs[0], divideNode.inputs[0])\n    scaleNodesGroupTree.links.new(subtractNode2.outputs[0], divideNode.inputs[1])\n    scaleNodesGroupTree.links.new(divideNode.outputs[0], scaleOutputsNode.inputs['val'])\n    scaleNodeGroup = node_tree.nodes.new('ShaderNodeGroup')\n    scaleNodeGroup.node_tree = bpy.data.node_groups[scaleNodesGroupName]\n    scaleNodeGroup.location = (-200, 200)\n    bbox = getBBOX.fromObj(obj)\n    zmin = node_tree.nodes.new('ShaderNodeValue')\n    zmin.label = 'zmin ' + obj.name\n    zmin.outputs[0].default_value = bbox['zmin']\n    zmin.location = (-400, 0)\n    zmax = node_tree.nodes.new('ShaderNodeValue')\n    zmax.label = 'zmax ' + obj.name\n    zmax.outputs[0].default_value = bbox['zmax']\n    zmax.location = (-400, -100)\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (0, 200)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (300, 200)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (500, 200)\n    node_tree.links.new(geomNode.outputs['Position'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], scaleNodeGroup.inputs['val'])\n    node_tree.links.new(zmin.outputs[0], scaleNodeGroup.inputs['min'])\n    node_tree.links.new(zmax.outputs[0], scaleNodeGroup.inputs['max'])\n    node_tree.links.new(scaleNodeGroup.outputs['val'], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    slopeMatName = 'Slope'\n    if slopeMatName not in [m.name for m in bpy.data.materials]:\n        slopeMat = bpy.data.materials.new(slopeMatName)\n    else:\n        slopeMat = bpy.data.materials[slopeMatName]\n    slopeMat.use_nodes = True\n    slopeMat.use_fake_user = True\n    node_tree = slopeMat.node_tree\n    node_tree.nodes.clear()\n    \"\\n\\t\\t# create texture coordinate node (local coordinates)\\n\\t\\ttexCoordNode = node_tree.nodes.new('ShaderNodeTexCoord')\\n\\t\\ttexCoordNode.location = (-600, 0)\\n\\t\\t\"\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 0)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 0)\n    arcCosNode = node_tree.nodes.new('ShaderNodeMath')\n    arcCosNode.operation = 'ARCCOSINE'\n    arcCosNode.location = (-200, 0)\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (0, 0)\n    rad2dg.label = 'Radians to degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (200, 0)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 100\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (400, 0)\n    cr = colorRampNode.color_ramp\n    cr.elements[0].color = (0, 1, 0, 1)\n    cr.elements[1].position = 0.5\n    cr.elements[1].color = (1, 0, 0, 1)\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (800, 0)\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1000, 0)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    node_tree.links.new(xyzSplitNode.outputs['Z'], arcCosNode.inputs[0])\n    node_tree.links.new(arcCosNode.outputs[0], rad2dg.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], normalize.inputs[0])\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    node_tree.links.new(diffuseNode.outputs['BSDF'], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    aspectMatName = 'Aspect'\n    if aspectMatName not in [m.name for m in bpy.data.materials]:\n        aspectMat = bpy.data.materials.new(aspectMatName)\n    else:\n        aspectMat = bpy.data.materials[aspectMatName]\n    aspectMat.use_nodes = True\n    aspectMat.use_fake_user = True\n    node_tree = aspectMat.node_tree\n    node_tree.nodes.clear()\n    geomNode = node_tree.nodes.new('ShaderNodeNewGeometry')\n    geomNode.location = (-600, 200)\n    xyzSplitNode = node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    xyzSplitNode.location = (-400, 200)\n    node_tree.links.new(geomNode.outputs['True Normal'], xyzSplitNode.inputs['Vector'])\n    xyDiv = node_tree.nodes.new('ShaderNodeMath')\n    xyDiv.operation = 'DIVIDE'\n    xyDiv.location = (-200, 0)\n    node_tree.links.new(xyzSplitNode.outputs['X'], xyDiv.inputs[0])\n    node_tree.links.new(xyzSplitNode.outputs['Y'], xyDiv.inputs[1])\n    atanNode = node_tree.nodes.new('ShaderNodeMath')\n    atanNode.operation = 'ARCTANGENT'\n    atanNode.label = 'Aspect radians'\n    atanNode.location = (0, 0)\n    node_tree.links.new(xyDiv.outputs[0], atanNode.inputs[0])\n    rad2dg = node_tree.nodes.new('ShaderNodeMath')\n    rad2dg.operation = 'MULTIPLY'\n    rad2dg.location = (200, 0)\n    rad2dg.label = 'Aspect degrees'\n    rad2dg.inputs[1].default_value = 180 / math.pi\n    node_tree.links.new(atanNode.outputs[0], rad2dg.inputs[0])\n    yNegMask = node_tree.nodes.new('ShaderNodeMath')\n    yNegMask.operation = 'LESS_THAN'\n    yNegMask.location = (0, 200)\n    yNegMask.label = 'y negative ?'\n    yNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yNegMask.inputs[0])\n    yNegMutiply = node_tree.nodes.new('ShaderNodeMath')\n    yNegMutiply.operation = 'MULTIPLY'\n    yNegMutiply.location = (200, 200)\n    node_tree.links.new(yNegMask.outputs[0], yNegMutiply.inputs[0])\n    yNegMutiply.inputs[1].default_value = 180\n    yNegAdd = node_tree.nodes.new('ShaderNodeMath')\n    yNegAdd.operation = 'ADD'\n    yNegAdd.location = (400, 200)\n    node_tree.links.new(yNegMutiply.outputs[0], yNegAdd.inputs[0])\n    node_tree.links.new(rad2dg.outputs[0], yNegAdd.inputs[1])\n    xNegMask = node_tree.nodes.new('ShaderNodeMath')\n    xNegMask.operation = 'LESS_THAN'\n    xNegMask.location = (0, 600)\n    xNegMask.label = 'x negative ?'\n    xNegMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['X'], xNegMask.inputs[0])\n    yPosMask = node_tree.nodes.new('ShaderNodeMath')\n    yPosMask.operation = 'GREATER_THAN'\n    yPosMask.location = (0, 400)\n    yPosMask.label = 'y positive ?'\n    yPosMask.inputs[1].default_value = 0\n    node_tree.links.new(xyzSplitNode.outputs['Y'], yPosMask.inputs[0])\n    mask = node_tree.nodes.new('ShaderNodeMath')\n    mask.operation = 'MULTIPLY'\n    mask.location = (200, 500)\n    node_tree.links.new(xNegMask.outputs[0], mask.inputs[0])\n    node_tree.links.new(yPosMask.outputs[0], mask.inputs[1])\n    maskMultiply = node_tree.nodes.new('ShaderNodeMath')\n    maskMultiply.operation = 'MULTIPLY'\n    maskMultiply.location = (400, 500)\n    node_tree.links.new(mask.outputs[0], maskMultiply.inputs[0])\n    maskMultiply.inputs[1].default_value = 360\n    maskAdd = node_tree.nodes.new('ShaderNodeMath')\n    maskAdd.operation = 'ADD'\n    maskAdd.location = (600, 300)\n    node_tree.links.new(maskMultiply.outputs[0], maskAdd.inputs[0])\n    node_tree.links.new(yNegAdd.outputs[0], maskAdd.inputs[1])\n    normalize = node_tree.nodes.new('ShaderNodeMath')\n    normalize.operation = 'DIVIDE'\n    normalize.location = (800, 300)\n    normalize.label = 'Normalize'\n    normalize.inputs[1].default_value = 360\n    node_tree.links.new(maskAdd.outputs[0], normalize.inputs[0])\n    colorRampNode = node_tree.nodes.new('ShaderNodeValToRGB')\n    colorRampNode.location = (1000, 300)\n    cr = colorRampNode.color_ramp\n    stops = cr.elements\n    cr.elements[0].color = (1, 0, 0, 1)\n    stops.remove(stops[1])\n    colors = [(1, 0.5, 0, 1), (1, 1, 0, 1), (0, 1, 0, 1), (0, 1, 1, 1), (0, 0.5, 1, 1), (0, 0, 1, 1), (1, 0, 1, 1), (1, 0, 0, 1)]\n    for (i, angle) in enumerate([22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5]):\n        pos = scale(angle, 0, 360, 0, 1)\n        stop = stops.new(pos)\n        stop.color = colors[i]\n    cr.interpolation = 'CONSTANT'\n    node_tree.links.new(normalize.outputs[0], colorRampNode.inputs['Fac'])\n    diffuseNode = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseNode.location = (1300, 300)\n    node_tree.links.new(colorRampNode.outputs['Color'], diffuseNode.inputs['Color'])\n    diffuseFlat = node_tree.nodes.new('ShaderNodeBsdfDiffuse')\n    diffuseFlat.location = (1300, 0)\n    diffuseFlat.inputs[0].default_value = (1, 1, 1, 1)\n    flatMask = node_tree.nodes.new('ShaderNodeMath')\n    flatMask.operation = 'LESS_THAN'\n    flatMask.location = (800, -100)\n    flatMask.label = 'is flat?'\n    flatMask.inputs[1].default_value = 0.999\n    node_tree.links.new(xyzSplitNode.outputs['Z'], flatMask.inputs[0])\n    mixNode = node_tree.nodes.new('ShaderNodeMixShader')\n    mixNode.location = (1500, 200)\n    node_tree.links.new(diffuseNode.outputs['BSDF'], mixNode.inputs[2])\n    node_tree.links.new(diffuseFlat.outputs['BSDF'], mixNode.inputs[1])\n    node_tree.links.new(flatMask.outputs[0], mixNode.inputs['Fac'])\n    outputNode = node_tree.nodes.new('ShaderNodeOutputMaterial')\n    outputNode.location = (1700, 200)\n    node_tree.links.new(mixNode.outputs[0], outputNode.inputs['Surface'])\n    for node in node_tree.nodes:\n        node.select = False\n    colorRampNode.select = True\n    node_tree.nodes.active = colorRampNode\n    '\\n\\t\\tif heightMat.name not in [m.name for m in obj.data.materials]:\\n\\t\\t\\t#add slot & move ui list index\\n\\t\\telse:#this name already exist, just move ui list index to select it\\n\\t\\t\\tobj.active_material_index = obj.material_slots.find(heightMat.name)\\n\\t\\t'\n    obj.data.materials.append(heightMat)\n    obj.active_material_index = len(obj.material_slots) - 1\n    for faces in obj.data.polygons:\n        faces.material_index = obj.active_material_index\n    return {'FINISHED'}"
        ]
    },
    {
        "func_name": "register",
        "original": "def register():\n    try:\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(TERRAIN_ANALYSIS_OT_build_nodes))\n        unregister()\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)",
        "mutated": [
            "def register():\n    if False:\n        i = 10\n    try:\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(TERRAIN_ANALYSIS_OT_build_nodes))\n        unregister()\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(TERRAIN_ANALYSIS_OT_build_nodes))\n        unregister()\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(TERRAIN_ANALYSIS_OT_build_nodes))\n        unregister()\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(TERRAIN_ANALYSIS_OT_build_nodes))\n        unregister()\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)",
            "def register():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)\n    except ValueError as e:\n        log.warning('{} is already registered, now unregister and retry... '.format(TERRAIN_ANALYSIS_OT_build_nodes))\n        unregister()\n        bpy.utils.register_class(TERRAIN_ANALYSIS_OT_build_nodes)"
        ]
    },
    {
        "func_name": "unregister",
        "original": "def unregister():\n    bpy.utils.unregister_class(TERRAIN_ANALYSIS_OT_build_nodes)",
        "mutated": [
            "def unregister():\n    if False:\n        i = 10\n    bpy.utils.unregister_class(TERRAIN_ANALYSIS_OT_build_nodes)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    bpy.utils.unregister_class(TERRAIN_ANALYSIS_OT_build_nodes)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    bpy.utils.unregister_class(TERRAIN_ANALYSIS_OT_build_nodes)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    bpy.utils.unregister_class(TERRAIN_ANALYSIS_OT_build_nodes)",
            "def unregister():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    bpy.utils.unregister_class(TERRAIN_ANALYSIS_OT_build_nodes)"
        ]
    }
]