from __future__ import annotations
import asyncio
from collections.abc import Sequence
from typing import Any, Callable, Literal, overload
from anyio import create_task_group
from reactpy.core.types import EventHandlerFunc, EventHandlerType

@overload
def event(function: Callable[..., Any], *, stop_propagation: bool=..., prevent_default: bool=...) -> EventHandler:
    if False:
        i = 10
        return i + 15
    ...

@overload
def event(function: Literal[None]=..., *, stop_propagation: bool=..., prevent_default: bool=...) -> Callable[[Callable[..., Any]], EventHandler]:
    if False:
        for i in range(10):
            print('nop')
    ...

def event(function: Callable[..., Any] | None=None, *, stop_propagation: bool=False, prevent_default: bool=False) -> EventHandler | Callable[[Callable[..., Any]], EventHandler]:
    if False:
        for i in range(10):
            print('nop')
    'A decorator for constructing an :class:`EventHandler`.\n\n    While you\'re always free to add callbacks by assigning them to an element\'s attributes\n\n    .. code-block:: python\n\n        element = reactpy.html.button({"onClick": my_callback})\n\n    You may want the ability to prevent the default action associated with the event\n    from taking place, or stopping the event from propagating up the DOM. This decorator\n    allows you to add that functionality to your callbacks.\n\n    .. code-block:: python\n\n        @event(stop_propagation=True, prevent_default=True)\n        def my_callback(*data):\n            ...\n\n        element = reactpy.html.button({"onClick": my_callback})\n\n    Parameters:\n        function:\n            A function or coroutine responsible for handling the event.\n        stop_propagation:\n            Block the event from propagating further up the DOM.\n        prevent_default:\n            Stops the default actional associate with the event from taking place.\n    '

    def setup(function: Callable[..., Any]) -> EventHandler:
        if False:
            for i in range(10):
                print('nop')
        return EventHandler(to_event_handler_function(function, positional_args=True), stop_propagation, prevent_default)
    if function is not None:
        return setup(function)
    else:
        return setup

class EventHandler:
    """Turn a function or coroutine into an event handler

    Parameters:
        function:
            The function or coroutine which handles the event.
        stop_propagation:
            Block the event from propagating further up the DOM.
        prevent_default:
            Stops the default action associate with the event from taking place.
        target:
            A unique identifier for this event handler (auto-generated by default)
    """
    __slots__ = ('__weakref__', 'function', 'prevent_default', 'stop_propagation', 'target')

    def __init__(self, function: EventHandlerFunc, stop_propagation: bool=False, prevent_default: bool=False, target: str | None=None) -> None:
        if False:
            for i in range(10):
                print('nop')
        self.function = to_event_handler_function(function, positional_args=False)
        self.prevent_default = prevent_default
        self.stop_propagation = stop_propagation
        self.target = target

    def __eq__(self, other: Any) -> bool:
        if False:
            while True:
                i = 10
        undefined = object()
        for attr in ('function', 'prevent_default', 'stop_propagation', 'target'):
            if not attr.startswith('_'):
                if not getattr(other, attr, undefined) == getattr(self, attr):
                    return False
        return True

    def __repr__(self) -> str:
        if False:
            print('Hello World!')
        public_names = [name for name in self.__slots__ if not name.startswith('_')]
        items = ', '.join([f'{n}={getattr(self, n)!r}' for n in public_names])
        return f'{type(self).__name__}({items})'

def to_event_handler_function(function: Callable[..., Any], positional_args: bool=True) -> EventHandlerFunc:
    if False:
        for i in range(10):
            print('nop')
    'Make a :data:`~reactpy.core.proto.EventHandlerFunc` from a function or coroutine\n\n    Parameters:\n        function:\n            A function or coroutine accepting a number of positional arguments.\n        positional_args:\n            Whether to pass the event parameters a positional args or as a list.\n    '
    if positional_args:
        if asyncio.iscoroutinefunction(function):

            async def wrapper(data: Sequence[Any]) -> None:
                await function(*data)
        else:

            async def wrapper(data: Sequence[Any]) -> None:
                function(*data)
        return wrapper
    elif not asyncio.iscoroutinefunction(function):

        async def wrapper(data: Sequence[Any]) -> None:
            function(data)
        return wrapper
    else:
        return function

def merge_event_handlers(event_handlers: Sequence[EventHandlerType]) -> EventHandlerType:
    if False:
        return 10
    'Merge multiple event handlers into one\n\n    Raises a ValueError if any handlers have conflicting\n    :attr:`~reactpy.core.proto.EventHandlerType.stop_propagation` or\n    :attr:`~reactpy.core.proto.EventHandlerType.prevent_default` attributes.\n    '
    if not event_handlers:
        msg = 'No event handlers to merge'
        raise ValueError(msg)
    elif len(event_handlers) == 1:
        return event_handlers[0]
    first_handler = event_handlers[0]
    stop_propagation = first_handler.stop_propagation
    prevent_default = first_handler.prevent_default
    target = first_handler.target
    for handler in event_handlers:
        if handler.stop_propagation != stop_propagation or handler.prevent_default != prevent_default or handler.target != target:
            msg = "Cannot merge handlers - 'stop_propagation', 'prevent_default' or 'target' mismatch."
            raise ValueError(msg)
    return EventHandler(merge_event_handler_funcs([h.function for h in event_handlers]), stop_propagation, prevent_default, target)

def merge_event_handler_funcs(functions: Sequence[EventHandlerFunc]) -> EventHandlerFunc:
    if False:
        for i in range(10):
            print('nop')
    'Make one event handler function from many'
    if not functions:
        msg = 'No event handler functions to merge'
        raise ValueError(msg)
    elif len(functions) == 1:
        return functions[0]

    async def await_all_event_handlers(data: Sequence[Any]) -> None:
        async with create_task_group() as group:
            for func in functions:
                group.start_soon(func, data)
    return await_all_event_handlers