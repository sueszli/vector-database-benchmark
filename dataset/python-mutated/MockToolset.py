import sys

def create(t):
    if False:
        print('Hello World!')
    t.write('mockinfo.py', '\nimport re\nimport optparse\nimport os\n\nparser = optparse.OptionParser()\nparser.add_option(\'-o\', dest="output_file")\nparser.add_option(\'-x\', dest="language")\nparser.add_option(\'-c\', dest="compile", action="store_true")\nparser.add_option(\'-I\', dest="includes", action="append")\nparser.add_option(\'-D\', dest="defines", action="append")\nparser.add_option(\'-L\', dest="library_path", action="append")\nparser.add_option(\'--dll\', dest="dll", action="store_true")\nparser.add_option(\'--archive\', dest="archive", action="store_true")\nparser.add_option(\'--static-lib\', dest="static_libraries", action="append")\nparser.add_option(\'--shared-lib\', dest="shared_libraries", action="append")\n\ncwd = os.environ["JAM_CWD"]\n\nclass MockInfo(object):\n  def __init__(self, verbose=False):\n    self.files = dict()\n    self.commands = list()\n    self.verbose = verbose\n  def source_file(self, name, pattern):\n    self.files[name] = pattern\n  def action(self, command, status=0):\n    if isinstance(command, str):\n      command = command.split()\n    self.commands.append((command, status))\n  def check(self, command):\n    print "Testing command", command\n    for (raw, status) in self.commands:\n      if self.matches(raw, command):\n        return status\n  def matches(self, raw, command):\n    (expected_options, expected_args) = parser.parse_args(raw)\n    options = command[0]\n    input_files = list(command[1])\n    if self.verbose:\n      print "  - matching against", (expected_options, expected_args)\n    if len(expected_args) != len(input_files):\n      if self.verbose:\n        print "  argument list sizes differ"\n      return False\n    for arg in expected_args:\n      if arg.startswith(\'$\'):\n        fileid = arg[1:]\n        pattern = self.files[fileid] if fileid in self.files else fileid\n        matching_file = None\n        for input_file in input_files:\n          with open(input_file, \'r\') as f:\n            contents = f.read()\n          if pattern == contents:\n            matching_file = input_file\n            break\n        if matching_file is not None:\n          input_files.remove(matching_file)\n        else:\n          if self.verbose:\n            print "    Failed to match input file contents: %s" % arg\n          return False\n      else:\n        if arg in input_files:\n          input_files.remove(arg)\n        else:\n          if self.verbose:\n            print "    Failed to match input file: %s" % arg\n          return False\n\n    if options.language != expected_options.language:\n      if self.verbose:\n        print "    Failed to match -c"\n      return False\n\n    if options.compile != expected_options.compile:\n      if self.verbose:\n        print "    Failed to match -x"\n      return False\n\n    # Normalize a path for comparison purposes\n    def adjust_path(p):\n      return os.path.normcase(os.path.normpath(os.path.join(cwd, p)))\n\n    # order matters\n    if options.includes is None:\n      options.includes = []\n    if expected_options.includes is None:\n      expected_options.includes = []\n    if map(adjust_path, options.includes) !=         map(adjust_path, expected_options.includes):\n      if self.verbose:\n        print "    Failed to match -I ",  map(adjust_path, options.includes),           " != ", map(adjust_path, expected_options.includes)\n      return False\n\n    if options.defines is None:\n      options.defines = []\n    if expected_options.defines is None:\n      expected_options.defines = []\n    if options.defines != expected_options.defines:\n      if self.verbose:\n        print "    Failed to match -I ",  options.defines,           " != ", expected_options.defines\n      return False\n\n    if options.library_path is None:\n      options.library_path = []\n    if expected_options.library_path is None:\n      expected_options.library_path = []\n    if map(adjust_path, options.library_path) !=         map(adjust_path, expected_options.library_path):\n      if self.verbose:\n        print "    Failed to match -L ",  map(adjust_path, options.library_path),           " != ", map(adjust_path, expected_options.library_path)\n      return False\n\n    if options.static_libraries != expected_options.static_libraries:\n      if self.verbose:\n        print "    Failed to match --static-lib"\n      return False\n\n    if options.shared_libraries != expected_options.shared_libraries:\n      if self.verbose:\n        print "    Failed to match --shared-lib"\n      return False\n\n    if options.dll != expected_options.dll:\n      if self.verbose:\n        print "    Failed to match --dll"\n      return False\n\n    if options.archive != expected_options.archive:\n      if self.verbose:\n        print "    Failed to match --archive"\n      return False\n\n    # The output must be handled after everything else\n    # is validated\n    if expected_options.output_file is not None:\n      if options.output_file is not None:\n        if expected_options.output_file.startswith(\'$\'):\n          fileid = expected_options.output_file[1:]\n          if fileid not in self.files:\n            self.files[fileid] = fileid\n          else:\n            assert(self.files[fileid] == fileid)\n          with open(options.output_file, \'w\') as output:\n            output.write(fileid)\n      else:\n        if self.verbose:\n          print "Failed to match -o"\n        return False\n    elif options.output_file is not None:\n      if self.verbose:\n        print "Failed to match -o"\n      return False\n\n    # if we\'ve gotten here, then everything matched\n    if self.verbose:\n      print "    Matched"\n    return True\n')
    t.write('mock.py', '\nimport mockinfo\nimport markup\nimport sys\n\nstatus = markup.info.check(mockinfo.parser.parse_args())\nif status is not None:\n  exit(status)\nelse:\n  print("Unrecognized command: " + \' \'.join(sys.argv))\n  exit(1)\n')
    t.write('mock.jam', '\nimport feature ;\nimport toolset ;\nimport path ;\nimport modules ;\nimport common ;\nimport type ;\n\n.python-cmd = ""%s"" ;\n\n# Behave the same as gcc on Windows, because that\'s what\n# the test system expects\ntype.set-generated-target-prefix SHARED_LIB : <toolset>mock <target-os>windows : lib ;\ntype.set-generated-target-suffix STATIC_LIB : <toolset>mock <target-os>windows : a ;\n\nrule init ( )\n{\n    local here = [ path.make [ modules.binding $(__name__) ] ] ;\n    here = [ path.native [ path.root [ path.parent $(here) ] [ path.pwd ] ] ] ;\n    .config-cmd = [ common.variable-setting-command JAM_CWD : $(here) ] $(.python-cmd) -B ;\n}\n\nfeature.extend toolset : mock ;\n\ngenerators.register-c-compiler mock.compile.c++ : CPP : OBJ : <toolset>mock ;\ngenerators.register-c-compiler mock.compile.c : C : OBJ : <toolset>mock ;\n\ngenerators.register-linker mock.link : LIB OBJ : EXE : <toolset>mock ;\ngenerators.register-linker mock.link.dll : LIB OBJ : SHARED_LIB : <toolset>mock ;\ngenerators.register-archiver mock.archive : OBJ : STATIC_LIB : <toolset>mock ;\n\ntoolset.flags mock.compile OPTIONS <link>shared : -fPIC ;\ntoolset.flags mock.compile INCLUDES : <include> ;\ntoolset.flags mock.compile DEFINES : <define> ;\n\nactions compile.c\n{\n   $(.config-cmd) mock.py -c -x c -I"$(INCLUDES)" -D"$(DEFINES)" "$(>)" -o "$(<)"\n}\n\nactions compile.c++\n{\n    $(.config-cmd) mock.py -c -x c++ -I"$(INCLUDES)" -D"$(DEFINES)" "$(>)" -o "$(<)"\n}\n\ntoolset.flags mock.link USER_OPTIONS <linkflags> ;\ntoolset.flags mock.link FINDLIBS-STATIC <find-static-library> ;\ntoolset.flags mock.link FINDLIBS-SHARED <find-shared-library> ;\ntoolset.flags mock.link LINK_PATH <library-path> ;\ntoolset.flags mock.link LIBRARIES <library-file> ;\n\nactions link\n{\n    $(.config-cmd) mock.py "$(>)" -o "$(<)" $(USER_OPTIONS) -L"$(LINK_PATH)" --static-lib=$(FINDLIBS-STATIC) --shared-lib=$(FINDLIBS-SHARED)\n}\n\nactions archive\n{\n    $(.config-cmd) mock.py --archive "$(>)" -o "$(<)" $(USER_OPTIONS)\n}\n\nactions link.dll\n{\n    $(.config-cmd) mock.py --dll "$(>)" -o "$(<)" $(USER_OPTIONS) -L"$(LINK_PATH)" --static-lib=$(FINDLIBS-STATIC) --shared-lib=$(FINDLIBS-SHARED)\n}\n\n' % sys.executable.replace('\\', '\\\\'))

def set_expected(t, markup):
    if False:
        while True:
            i = 10
    verbose = 'True' if t.verbose else 'False'
    t.write('markup.py', '\nimport mockinfo\ninfo = mockinfo.MockInfo(%s)\ndef source_file(name, contents):\n  info.source_file(name, contents)\ndef action(command, status=0):\n  info.action(command, status)\n' % verbose + markup)