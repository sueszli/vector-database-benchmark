def scatter_add(a, slices, value):
    if False:
        for i in range(10):
            print('nop')
    "Adds given values to specified elements of an array.\n\n    It adds ``value`` to the specified elements of ``a``.\n    If all of the indices target different locations, the operation of\n    :func:`scatter_add` is equivalent to ``a[slices] = a[slices] + value``.\n    If there are multiple elements targeting the same location,\n    :func:`scatter_add` uses all of these values for addition. On the other\n    hand, ``a[slices] = a[slices] + value`` only adds the contribution from one\n    of the indices targeting the same location.\n\n    Note that just like an array indexing, negative indices are interpreted as\n    counting from the end of an array.\n\n    Also note that :func:`scatter_add` behaves identically\n    to :func:`numpy.add.at`.\n\n    Example\n    -------\n    >>> import cupy\n    >>> import cupyx\n    >>> a = cupy.zeros((6,), dtype=cupy.float32)\n    >>> i = cupy.array([1, 0, 1])\n    >>> v = cupy.array([1., 1., 1.])\n    >>> cupyx.scatter_add(a, i, v);\n    >>> a\n    array([1., 2., 0., 0., 0., 0.], dtype=float32)\n\n    Args:\n        a (ndarray): An array that gets added.\n        slices: It is integer, slices, ellipsis, numpy.newaxis,\n            integer array-like, boolean array-like or tuple of them.\n            It works for slices used for\n            :func:`cupy.ndarray.__getitem__` and\n            :func:`cupy.ndarray.__setitem__`.\n        v (array-like): Values to increment ``a`` at referenced locations.\n\n    .. note::\n        It only supports types that are supported by CUDA's atomicAdd when\n        an integer array is included in ``slices``.\n        The supported types are ``numpy.float32``, ``numpy.int32``,\n        ``numpy.uint32``, ``numpy.uint64`` and ``numpy.ulonglong``.\n\n    .. note::\n        :func:`scatter_add` does not raise an error when indices exceed size of\n        axes. Instead, it wraps indices.\n\n    .. seealso:: :meth:`numpy.ufunc.at`.\n\n    "
    a.scatter_add(slices, value)

def scatter_max(a, slices, value):
    if False:
        while True:
            i = 10
    'Stores a maximum value of elements specified by indices to an array.\n\n    It stores the maximum value of elements in ``value`` array indexed by\n    ``slices`` to ``a``. If all of the indices target different locations,\n    the operation of :func:`scatter_max` is equivalent to\n    ``a[slices] = cupy.maximum(a[slices], value)``.\n    If there are multiple elements targeting the same location,\n    :func:`scatter_max` stores the maximum of all of these values to the given\n    index of ``a``, the initial element of ``a`` is also taken in account.\n\n    Note that just like an array indexing, negative indices are interpreted as\n    counting from the end of an array.\n\n    Also note that :func:`scatter_max` behaves identically\n    to :func:`numpy.maximum.at`.\n\n    Example\n    -------\n    >>> import numpy\n    >>> import cupy\n    >>> a = cupy.zeros((6,), dtype=numpy.float32)\n    >>> i = cupy.array([1, 0, 1, 2])\n    >>> v = cupy.array([1., 2., 3., -1.])\n    >>> cupyx.scatter_max(a, i, v);\n    >>> a\n    array([2., 3., 0., 0., 0., 0.], dtype=float32)\n\n    Args:\n        a (ndarray): An array to store the results.\n        slices: It is integer, slices, ellipsis, numpy.newaxis,\n            integer array-like, boolean array-like or tuple of them.\n            It works for slices used for\n            :func:`cupy.ndarray.__getitem__` and\n            :func:`cupy.ndarray.__setitem__`.\n        v (array-like): An array used for reference.\n    '
    a.scatter_max(slices, value)

def scatter_min(a, slices, value):
    if False:
        print('Hello World!')
    'Stores a minimum value of elements specified by indices to an array.\n\n    It stores the minimum value of elements in ``value`` array indexed by\n    ``slices`` to ``a``. If all of the indices target different locations,\n    the operation of :func:`scatter_min` is equivalent to\n    ``a[slices] = cupy.minimum(a[slices], value)``.\n    If there are multiple elements targeting the same location,\n    :func:`scatter_min` stores the minimum of all of these values to the given\n    index of ``a``, the initial element of ``a`` is also taken in account.\n\n    Note that just like an array indexing, negative indices are interpreted as\n    counting from the end of an array.\n\n    Also note that :func:`scatter_min` behaves identically\n    to :func:`numpy.minimum.at`.\n\n    Example\n    -------\n    >>> import numpy\n    >>> import cupy\n    >>> a = cupy.zeros((6,), dtype=numpy.float32)\n    >>> i = cupy.array([1, 0, 1, 2])\n    >>> v = cupy.array([1., 2., 3., -1.])\n    >>> cupyx.scatter_min(a, i, v);\n    >>> a\n    array([ 0.,  0., -1.,  0.,  0.,  0.], dtype=float32)\n\n    Args:\n        a (ndarray): An array to store the results.\n        slices: It is integer, slices, ellipsis, numpy.newaxis,\n            integer array-like, boolean array-like or tuple of them.\n            It works for slices used for\n            :func:`cupy.ndarray.__getitem__` and\n            :func:`cupy.ndarray.__setitem__`.\n        v (array-like): An array used for reference.\n    '
    a.scatter_min(slices, value)