[
    {
        "func_name": "cvx_relax",
        "original": "def cvx_relax(prob):\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [0 <= var, var <= 1]\n    return Problem(prob.objective, prob.constraints + new_constr)",
        "mutated": [
            "def cvx_relax(prob):\n    if False:\n        i = 10\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [0 <= var, var <= 1]\n    return Problem(prob.objective, prob.constraints + new_constr)",
            "def cvx_relax(prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [0 <= var, var <= 1]\n    return Problem(prob.objective, prob.constraints + new_constr)",
            "def cvx_relax(prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [0 <= var, var <= 1]\n    return Problem(prob.objective, prob.constraints + new_constr)",
            "def cvx_relax(prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [0 <= var, var <= 1]\n    return Problem(prob.objective, prob.constraints + new_constr)",
            "def cvx_relax(prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [0 <= var, var <= 1]\n    return Problem(prob.objective, prob.constraints + new_constr)"
        ]
    },
    {
        "func_name": "round_and_fix",
        "original": "def round_and_fix(prob):\n    prob.solve()\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [var == numpy.round(var.value)]\n    return Problem(prob.objective, prob.constraints + new_constr)",
        "mutated": [
            "def round_and_fix(prob):\n    if False:\n        i = 10\n    prob.solve()\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [var == numpy.round(var.value)]\n    return Problem(prob.objective, prob.constraints + new_constr)",
            "def round_and_fix(prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    prob.solve()\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [var == numpy.round(var.value)]\n    return Problem(prob.objective, prob.constraints + new_constr)",
            "def round_and_fix(prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    prob.solve()\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [var == numpy.round(var.value)]\n    return Problem(prob.objective, prob.constraints + new_constr)",
            "def round_and_fix(prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    prob.solve()\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [var == numpy.round(var.value)]\n    return Problem(prob.objective, prob.constraints + new_constr)",
            "def round_and_fix(prob):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    prob.solve()\n    new_constr = []\n    for var in prob.variables():\n        if getattr(var, 'boolean', False):\n            new_constr += [var == numpy.round(var.value)]\n    return Problem(prob.objective, prob.constraints + new_constr)"
        ]
    },
    {
        "func_name": "branch_and_bound",
        "original": "def branch_and_bound(n, A, B, c):\n    from queue import PriorityQueue\n    x = Variable(n)\n    z = Variable(n)\n    L = Parameter(n)\n    U = Parameter(n)\n    prob = Problem(Minimize(sum_squares(A * x + B * z - c)), [L <= z, z <= U])\n    visited = 0\n    best_z = None\n    f_best = numpy.inf\n    nodes = PriorityQueue()\n    nodes.put((numpy.inf, 0, numpy.zeros(n), numpy.ones(n), 0))\n    while not nodes.empty():\n        visited += 1\n        (_, _, L_val, U_val, idx) = nodes.get()\n        L.value = L_val\n        U.value = U_val\n        lower_bound = prob.solve()\n        z_star = numpy.round(z.value)\n        upper_bound = Problem(prob.objective, [z == z_star]).solve()\n        f_best = min(f_best, upper_bound)\n        if upper_bound == f_best:\n            best_z = z_star\n        if idx < n and lower_bound < f_best:\n            for i in [0, 1]:\n                L_val[idx] = U_val[idx] = i\n                nodes.put((lower_bound, i, L_val.copy(), U_val.copy(), idx + 1))\n    return (f_best, best_z)",
        "mutated": [
            "def branch_and_bound(n, A, B, c):\n    if False:\n        i = 10\n    from queue import PriorityQueue\n    x = Variable(n)\n    z = Variable(n)\n    L = Parameter(n)\n    U = Parameter(n)\n    prob = Problem(Minimize(sum_squares(A * x + B * z - c)), [L <= z, z <= U])\n    visited = 0\n    best_z = None\n    f_best = numpy.inf\n    nodes = PriorityQueue()\n    nodes.put((numpy.inf, 0, numpy.zeros(n), numpy.ones(n), 0))\n    while not nodes.empty():\n        visited += 1\n        (_, _, L_val, U_val, idx) = nodes.get()\n        L.value = L_val\n        U.value = U_val\n        lower_bound = prob.solve()\n        z_star = numpy.round(z.value)\n        upper_bound = Problem(prob.objective, [z == z_star]).solve()\n        f_best = min(f_best, upper_bound)\n        if upper_bound == f_best:\n            best_z = z_star\n        if idx < n and lower_bound < f_best:\n            for i in [0, 1]:\n                L_val[idx] = U_val[idx] = i\n                nodes.put((lower_bound, i, L_val.copy(), U_val.copy(), idx + 1))\n    return (f_best, best_z)",
            "def branch_and_bound(n, A, B, c):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from queue import PriorityQueue\n    x = Variable(n)\n    z = Variable(n)\n    L = Parameter(n)\n    U = Parameter(n)\n    prob = Problem(Minimize(sum_squares(A * x + B * z - c)), [L <= z, z <= U])\n    visited = 0\n    best_z = None\n    f_best = numpy.inf\n    nodes = PriorityQueue()\n    nodes.put((numpy.inf, 0, numpy.zeros(n), numpy.ones(n), 0))\n    while not nodes.empty():\n        visited += 1\n        (_, _, L_val, U_val, idx) = nodes.get()\n        L.value = L_val\n        U.value = U_val\n        lower_bound = prob.solve()\n        z_star = numpy.round(z.value)\n        upper_bound = Problem(prob.objective, [z == z_star]).solve()\n        f_best = min(f_best, upper_bound)\n        if upper_bound == f_best:\n            best_z = z_star\n        if idx < n and lower_bound < f_best:\n            for i in [0, 1]:\n                L_val[idx] = U_val[idx] = i\n                nodes.put((lower_bound, i, L_val.copy(), U_val.copy(), idx + 1))\n    return (f_best, best_z)",
            "def branch_and_bound(n, A, B, c):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from queue import PriorityQueue\n    x = Variable(n)\n    z = Variable(n)\n    L = Parameter(n)\n    U = Parameter(n)\n    prob = Problem(Minimize(sum_squares(A * x + B * z - c)), [L <= z, z <= U])\n    visited = 0\n    best_z = None\n    f_best = numpy.inf\n    nodes = PriorityQueue()\n    nodes.put((numpy.inf, 0, numpy.zeros(n), numpy.ones(n), 0))\n    while not nodes.empty():\n        visited += 1\n        (_, _, L_val, U_val, idx) = nodes.get()\n        L.value = L_val\n        U.value = U_val\n        lower_bound = prob.solve()\n        z_star = numpy.round(z.value)\n        upper_bound = Problem(prob.objective, [z == z_star]).solve()\n        f_best = min(f_best, upper_bound)\n        if upper_bound == f_best:\n            best_z = z_star\n        if idx < n and lower_bound < f_best:\n            for i in [0, 1]:\n                L_val[idx] = U_val[idx] = i\n                nodes.put((lower_bound, i, L_val.copy(), U_val.copy(), idx + 1))\n    return (f_best, best_z)",
            "def branch_and_bound(n, A, B, c):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from queue import PriorityQueue\n    x = Variable(n)\n    z = Variable(n)\n    L = Parameter(n)\n    U = Parameter(n)\n    prob = Problem(Minimize(sum_squares(A * x + B * z - c)), [L <= z, z <= U])\n    visited = 0\n    best_z = None\n    f_best = numpy.inf\n    nodes = PriorityQueue()\n    nodes.put((numpy.inf, 0, numpy.zeros(n), numpy.ones(n), 0))\n    while not nodes.empty():\n        visited += 1\n        (_, _, L_val, U_val, idx) = nodes.get()\n        L.value = L_val\n        U.value = U_val\n        lower_bound = prob.solve()\n        z_star = numpy.round(z.value)\n        upper_bound = Problem(prob.objective, [z == z_star]).solve()\n        f_best = min(f_best, upper_bound)\n        if upper_bound == f_best:\n            best_z = z_star\n        if idx < n and lower_bound < f_best:\n            for i in [0, 1]:\n                L_val[idx] = U_val[idx] = i\n                nodes.put((lower_bound, i, L_val.copy(), U_val.copy(), idx + 1))\n    return (f_best, best_z)",
            "def branch_and_bound(n, A, B, c):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from queue import PriorityQueue\n    x = Variable(n)\n    z = Variable(n)\n    L = Parameter(n)\n    U = Parameter(n)\n    prob = Problem(Minimize(sum_squares(A * x + B * z - c)), [L <= z, z <= U])\n    visited = 0\n    best_z = None\n    f_best = numpy.inf\n    nodes = PriorityQueue()\n    nodes.put((numpy.inf, 0, numpy.zeros(n), numpy.ones(n), 0))\n    while not nodes.empty():\n        visited += 1\n        (_, _, L_val, U_val, idx) = nodes.get()\n        L.value = L_val\n        U.value = U_val\n        lower_bound = prob.solve()\n        z_star = numpy.round(z.value)\n        upper_bound = Problem(prob.objective, [z == z_star]).solve()\n        f_best = min(f_best, upper_bound)\n        if upper_bound == f_best:\n            best_z = z_star\n        if idx < n and lower_bound < f_best:\n            for i in [0, 1]:\n                L_val[idx] = U_val[idx] = i\n                nodes.put((lower_bound, i, L_val.copy(), U_val.copy(), idx + 1))\n    return (f_best, best_z)"
        ]
    },
    {
        "func_name": "example",
        "original": "def example(n, get_vals: bool=False):\n    print('n = %d #################' % n)\n    m = 2 * n\n    A = numpy.matrix(numpy.random.randn(m, n))\n    B = numpy.matrix(numpy.random.randn(m, n))\n    sltn = (numpy.random.randn(n, 1), numpy.random.randint(2, size=(n, 1)))\n    noise = numpy.random.normal(size=(m, 1))\n    c = A.dot(sltn[0]) + B.dot(sltn[1]) + noise\n    x = Variable(n)\n    z = Variable(n)\n    z.boolean = True\n    obj = sum_squares(A * x + B * z - c)\n    prob = Problem(Minimize(obj))\n    relaxation = cvx_relax(prob)\n    print('relaxation', relaxation.solve())\n    rel_z = z.value\n    rounded = round_and_fix(relaxation)\n    rounded.solve()\n    print('relax and round', rounded.value)\n    (truth, true_z) = branch_and_bound(n, A, B, c)\n    print('true optimum', truth)\n    if get_vals:\n        return (rel_z, z.value, true_z)\n    return (relaxation.value, rounded.value, truth)",
        "mutated": [
            "def example(n, get_vals: bool=False):\n    if False:\n        i = 10\n    print('n = %d #################' % n)\n    m = 2 * n\n    A = numpy.matrix(numpy.random.randn(m, n))\n    B = numpy.matrix(numpy.random.randn(m, n))\n    sltn = (numpy.random.randn(n, 1), numpy.random.randint(2, size=(n, 1)))\n    noise = numpy.random.normal(size=(m, 1))\n    c = A.dot(sltn[0]) + B.dot(sltn[1]) + noise\n    x = Variable(n)\n    z = Variable(n)\n    z.boolean = True\n    obj = sum_squares(A * x + B * z - c)\n    prob = Problem(Minimize(obj))\n    relaxation = cvx_relax(prob)\n    print('relaxation', relaxation.solve())\n    rel_z = z.value\n    rounded = round_and_fix(relaxation)\n    rounded.solve()\n    print('relax and round', rounded.value)\n    (truth, true_z) = branch_and_bound(n, A, B, c)\n    print('true optimum', truth)\n    if get_vals:\n        return (rel_z, z.value, true_z)\n    return (relaxation.value, rounded.value, truth)",
            "def example(n, get_vals: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('n = %d #################' % n)\n    m = 2 * n\n    A = numpy.matrix(numpy.random.randn(m, n))\n    B = numpy.matrix(numpy.random.randn(m, n))\n    sltn = (numpy.random.randn(n, 1), numpy.random.randint(2, size=(n, 1)))\n    noise = numpy.random.normal(size=(m, 1))\n    c = A.dot(sltn[0]) + B.dot(sltn[1]) + noise\n    x = Variable(n)\n    z = Variable(n)\n    z.boolean = True\n    obj = sum_squares(A * x + B * z - c)\n    prob = Problem(Minimize(obj))\n    relaxation = cvx_relax(prob)\n    print('relaxation', relaxation.solve())\n    rel_z = z.value\n    rounded = round_and_fix(relaxation)\n    rounded.solve()\n    print('relax and round', rounded.value)\n    (truth, true_z) = branch_and_bound(n, A, B, c)\n    print('true optimum', truth)\n    if get_vals:\n        return (rel_z, z.value, true_z)\n    return (relaxation.value, rounded.value, truth)",
            "def example(n, get_vals: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('n = %d #################' % n)\n    m = 2 * n\n    A = numpy.matrix(numpy.random.randn(m, n))\n    B = numpy.matrix(numpy.random.randn(m, n))\n    sltn = (numpy.random.randn(n, 1), numpy.random.randint(2, size=(n, 1)))\n    noise = numpy.random.normal(size=(m, 1))\n    c = A.dot(sltn[0]) + B.dot(sltn[1]) + noise\n    x = Variable(n)\n    z = Variable(n)\n    z.boolean = True\n    obj = sum_squares(A * x + B * z - c)\n    prob = Problem(Minimize(obj))\n    relaxation = cvx_relax(prob)\n    print('relaxation', relaxation.solve())\n    rel_z = z.value\n    rounded = round_and_fix(relaxation)\n    rounded.solve()\n    print('relax and round', rounded.value)\n    (truth, true_z) = branch_and_bound(n, A, B, c)\n    print('true optimum', truth)\n    if get_vals:\n        return (rel_z, z.value, true_z)\n    return (relaxation.value, rounded.value, truth)",
            "def example(n, get_vals: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('n = %d #################' % n)\n    m = 2 * n\n    A = numpy.matrix(numpy.random.randn(m, n))\n    B = numpy.matrix(numpy.random.randn(m, n))\n    sltn = (numpy.random.randn(n, 1), numpy.random.randint(2, size=(n, 1)))\n    noise = numpy.random.normal(size=(m, 1))\n    c = A.dot(sltn[0]) + B.dot(sltn[1]) + noise\n    x = Variable(n)\n    z = Variable(n)\n    z.boolean = True\n    obj = sum_squares(A * x + B * z - c)\n    prob = Problem(Minimize(obj))\n    relaxation = cvx_relax(prob)\n    print('relaxation', relaxation.solve())\n    rel_z = z.value\n    rounded = round_and_fix(relaxation)\n    rounded.solve()\n    print('relax and round', rounded.value)\n    (truth, true_z) = branch_and_bound(n, A, B, c)\n    print('true optimum', truth)\n    if get_vals:\n        return (rel_z, z.value, true_z)\n    return (relaxation.value, rounded.value, truth)",
            "def example(n, get_vals: bool=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('n = %d #################' % n)\n    m = 2 * n\n    A = numpy.matrix(numpy.random.randn(m, n))\n    B = numpy.matrix(numpy.random.randn(m, n))\n    sltn = (numpy.random.randn(n, 1), numpy.random.randint(2, size=(n, 1)))\n    noise = numpy.random.normal(size=(m, 1))\n    c = A.dot(sltn[0]) + B.dot(sltn[1]) + noise\n    x = Variable(n)\n    z = Variable(n)\n    z.boolean = True\n    obj = sum_squares(A * x + B * z - c)\n    prob = Problem(Minimize(obj))\n    relaxation = cvx_relax(prob)\n    print('relaxation', relaxation.solve())\n    rel_z = z.value\n    rounded = round_and_fix(relaxation)\n    rounded.solve()\n    print('relax and round', rounded.value)\n    (truth, true_z) = branch_and_bound(n, A, B, c)\n    print('true optimum', truth)\n    if get_vals:\n        return (rel_z, z.value, true_z)\n    return (relaxation.value, rounded.value, truth)"
        ]
    }
]