[
    {
        "func_name": "test_discriminated_union_type",
        "original": "def test_discriminated_union_type():\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: str = Field(..., discriminator='qwe')",
        "mutated": [
            "def test_discriminated_union_type():\n    if False:\n        i = 10\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: str = Field(..., discriminator='qwe')",
            "def test_discriminated_union_type():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: str = Field(..., discriminator='qwe')",
            "def test_discriminated_union_type():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: str = Field(..., discriminator='qwe')",
            "def test_discriminated_union_type():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: str = Field(..., discriminator='qwe')",
            "def test_discriminated_union_type():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: str = Field(..., discriminator='qwe')"
        ]
    },
    {
        "func_name": "test_discriminated_single_variant",
        "original": "@pytest.mark.parametrize('union', [True, False])\ndef test_discriminated_single_variant(union):\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n        y: int\n\n    class Model(BaseModel):\n        if union:\n            x: Union[InnerModel] = Field(..., discriminator='qwe')\n        else:\n            x: InnerModel = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe', 'y': 1}).x.qwe == 'qwe'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'qwe': 'asd', 'y': 'a'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'qwe'\", 'expected_tags': \"'qwe'\", 'tag': 'asd'}, 'input': {'qwe': 'asd', 'y': 'a'}, 'loc': ('x',), 'msg': \"Input tag 'asd' found using 'qwe' does not match any of the expected tags: 'qwe'\", 'type': 'union_tag_invalid'}]",
        "mutated": [
            "@pytest.mark.parametrize('union', [True, False])\ndef test_discriminated_single_variant(union):\n    if False:\n        i = 10\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n        y: int\n\n    class Model(BaseModel):\n        if union:\n            x: Union[InnerModel] = Field(..., discriminator='qwe')\n        else:\n            x: InnerModel = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe', 'y': 1}).x.qwe == 'qwe'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'qwe': 'asd', 'y': 'a'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'qwe'\", 'expected_tags': \"'qwe'\", 'tag': 'asd'}, 'input': {'qwe': 'asd', 'y': 'a'}, 'loc': ('x',), 'msg': \"Input tag 'asd' found using 'qwe' does not match any of the expected tags: 'qwe'\", 'type': 'union_tag_invalid'}]",
            "@pytest.mark.parametrize('union', [True, False])\ndef test_discriminated_single_variant(union):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n        y: int\n\n    class Model(BaseModel):\n        if union:\n            x: Union[InnerModel] = Field(..., discriminator='qwe')\n        else:\n            x: InnerModel = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe', 'y': 1}).x.qwe == 'qwe'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'qwe': 'asd', 'y': 'a'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'qwe'\", 'expected_tags': \"'qwe'\", 'tag': 'asd'}, 'input': {'qwe': 'asd', 'y': 'a'}, 'loc': ('x',), 'msg': \"Input tag 'asd' found using 'qwe' does not match any of the expected tags: 'qwe'\", 'type': 'union_tag_invalid'}]",
            "@pytest.mark.parametrize('union', [True, False])\ndef test_discriminated_single_variant(union):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n        y: int\n\n    class Model(BaseModel):\n        if union:\n            x: Union[InnerModel] = Field(..., discriminator='qwe')\n        else:\n            x: InnerModel = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe', 'y': 1}).x.qwe == 'qwe'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'qwe': 'asd', 'y': 'a'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'qwe'\", 'expected_tags': \"'qwe'\", 'tag': 'asd'}, 'input': {'qwe': 'asd', 'y': 'a'}, 'loc': ('x',), 'msg': \"Input tag 'asd' found using 'qwe' does not match any of the expected tags: 'qwe'\", 'type': 'union_tag_invalid'}]",
            "@pytest.mark.parametrize('union', [True, False])\ndef test_discriminated_single_variant(union):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n        y: int\n\n    class Model(BaseModel):\n        if union:\n            x: Union[InnerModel] = Field(..., discriminator='qwe')\n        else:\n            x: InnerModel = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe', 'y': 1}).x.qwe == 'qwe'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'qwe': 'asd', 'y': 'a'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'qwe'\", 'expected_tags': \"'qwe'\", 'tag': 'asd'}, 'input': {'qwe': 'asd', 'y': 'a'}, 'loc': ('x',), 'msg': \"Input tag 'asd' found using 'qwe' does not match any of the expected tags: 'qwe'\", 'type': 'union_tag_invalid'}]",
            "@pytest.mark.parametrize('union', [True, False])\ndef test_discriminated_single_variant(union):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n        y: int\n\n    class Model(BaseModel):\n        if union:\n            x: Union[InnerModel] = Field(..., discriminator='qwe')\n        else:\n            x: InnerModel = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe', 'y': 1}).x.qwe == 'qwe'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'qwe': 'asd', 'y': 'a'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'qwe'\", 'expected_tags': \"'qwe'\", 'tag': 'asd'}, 'input': {'qwe': 'asd', 'y': 'a'}, 'loc': ('x',), 'msg': \"Input tag 'asd' found using 'qwe' does not match any of the expected tags: 'qwe'\", 'type': 'union_tag_invalid'}]"
        ]
    },
    {
        "func_name": "test_discriminated_union_single_variant",
        "original": "def test_discriminated_union_single_variant():\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n\n    class Model(BaseModel):\n        x: Union[InnerModel] = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe'}).x.qwe == 'qwe'",
        "mutated": [
            "def test_discriminated_union_single_variant():\n    if False:\n        i = 10\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n\n    class Model(BaseModel):\n        x: Union[InnerModel] = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe'}).x.qwe == 'qwe'",
            "def test_discriminated_union_single_variant():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n\n    class Model(BaseModel):\n        x: Union[InnerModel] = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe'}).x.qwe == 'qwe'",
            "def test_discriminated_union_single_variant():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n\n    class Model(BaseModel):\n        x: Union[InnerModel] = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe'}).x.qwe == 'qwe'",
            "def test_discriminated_union_single_variant():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n\n    class Model(BaseModel):\n        x: Union[InnerModel] = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe'}).x.qwe == 'qwe'",
            "def test_discriminated_union_single_variant():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class InnerModel(BaseModel):\n        qwe: Literal['qwe']\n\n    class Model(BaseModel):\n        x: Union[InnerModel] = Field(..., discriminator='qwe')\n    assert Model(x={'qwe': 'qwe'}).x.qwe == 'qwe'"
        ]
    },
    {
        "func_name": "test_discriminated_union_invalid_type",
        "original": "def test_discriminated_union_invalid_type():\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: Union[str, int] = Field(..., discriminator='qwe')",
        "mutated": [
            "def test_discriminated_union_invalid_type():\n    if False:\n        i = 10\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: Union[str, int] = Field(..., discriminator='qwe')",
            "def test_discriminated_union_invalid_type():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: Union[str, int] = Field(..., discriminator='qwe')",
            "def test_discriminated_union_invalid_type():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: Union[str, int] = Field(..., discriminator='qwe')",
            "def test_discriminated_union_invalid_type():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: Union[str, int] = Field(..., discriminator='qwe')",
            "def test_discriminated_union_invalid_type():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            x: Union[str, int] = Field(..., discriminator='qwe')"
        ]
    },
    {
        "func_name": "test_discriminated_union_defined_discriminator",
        "original": "def test_discriminated_union_defined_discriminator():\n\n    class Cat(BaseModel):\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs a discriminator field for key 'pet_type'\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
        "mutated": [
            "def test_discriminated_union_defined_discriminator():\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs a discriminator field for key 'pet_type'\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
            "def test_discriminated_union_defined_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs a discriminator field for key 'pet_type'\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
            "def test_discriminated_union_defined_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs a discriminator field for key 'pet_type'\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
            "def test_discriminated_union_defined_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs a discriminator field for key 'pet_type'\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
            "def test_discriminated_union_defined_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs a discriminator field for key 'pet_type'\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int"
        ]
    },
    {
        "func_name": "test_discriminated_union_literal_discriminator",
        "original": "def test_discriminated_union_literal_discriminator():\n\n    class Cat(BaseModel):\n        pet_type: int\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs field 'pet_type' to be of type `Literal`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
        "mutated": [
            "def test_discriminated_union_literal_discriminator():\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: int\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs field 'pet_type' to be of type `Literal`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
            "def test_discriminated_union_literal_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: int\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs field 'pet_type' to be of type `Literal`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
            "def test_discriminated_union_literal_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: int\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs field 'pet_type' to be of type `Literal`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
            "def test_discriminated_union_literal_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: int\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs field 'pet_type' to be of type `Literal`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int",
            "def test_discriminated_union_literal_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: int\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n    with pytest.raises(PydanticUserError, match=\"Model 'Cat' needs field 'pet_type' to be of type `Literal`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(..., discriminator='pet_type')\n            number: int"
        ]
    },
    {
        "func_name": "test_discriminated_union_root_same_discriminator",
        "original": "def test_discriminated_union_root_same_discriminator():\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['blackcat']\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['whitecat']\n    Cat = Union[BlackCat, WhiteCat]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n    CatDog = TypeAdapter(Annotated[Union[Cat, Dog], Field(..., discriminator='pet_type')]).validate_python\n    CatDog({'pet_type': 'blackcat'})\n    CatDog({'pet_type': 'whitecat'})\n    CatDog({'pet_type': 'dog'})\n    with pytest.raises(ValidationError) as exc_info:\n        CatDog({'pet_type': 'llama'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'blackcat', 'whitecat', 'dog'\", 'tag': 'llama'}, 'input': {'pet_type': 'llama'}, 'loc': (), 'msg': \"Input tag 'llama' found using 'pet_type' does not match any of the expected tags: 'blackcat', 'whitecat', 'dog'\", 'type': 'union_tag_invalid'}]",
        "mutated": [
            "def test_discriminated_union_root_same_discriminator():\n    if False:\n        i = 10\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['blackcat']\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['whitecat']\n    Cat = Union[BlackCat, WhiteCat]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n    CatDog = TypeAdapter(Annotated[Union[Cat, Dog], Field(..., discriminator='pet_type')]).validate_python\n    CatDog({'pet_type': 'blackcat'})\n    CatDog({'pet_type': 'whitecat'})\n    CatDog({'pet_type': 'dog'})\n    with pytest.raises(ValidationError) as exc_info:\n        CatDog({'pet_type': 'llama'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'blackcat', 'whitecat', 'dog'\", 'tag': 'llama'}, 'input': {'pet_type': 'llama'}, 'loc': (), 'msg': \"Input tag 'llama' found using 'pet_type' does not match any of the expected tags: 'blackcat', 'whitecat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_discriminated_union_root_same_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['blackcat']\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['whitecat']\n    Cat = Union[BlackCat, WhiteCat]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n    CatDog = TypeAdapter(Annotated[Union[Cat, Dog], Field(..., discriminator='pet_type')]).validate_python\n    CatDog({'pet_type': 'blackcat'})\n    CatDog({'pet_type': 'whitecat'})\n    CatDog({'pet_type': 'dog'})\n    with pytest.raises(ValidationError) as exc_info:\n        CatDog({'pet_type': 'llama'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'blackcat', 'whitecat', 'dog'\", 'tag': 'llama'}, 'input': {'pet_type': 'llama'}, 'loc': (), 'msg': \"Input tag 'llama' found using 'pet_type' does not match any of the expected tags: 'blackcat', 'whitecat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_discriminated_union_root_same_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['blackcat']\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['whitecat']\n    Cat = Union[BlackCat, WhiteCat]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n    CatDog = TypeAdapter(Annotated[Union[Cat, Dog], Field(..., discriminator='pet_type')]).validate_python\n    CatDog({'pet_type': 'blackcat'})\n    CatDog({'pet_type': 'whitecat'})\n    CatDog({'pet_type': 'dog'})\n    with pytest.raises(ValidationError) as exc_info:\n        CatDog({'pet_type': 'llama'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'blackcat', 'whitecat', 'dog'\", 'tag': 'llama'}, 'input': {'pet_type': 'llama'}, 'loc': (), 'msg': \"Input tag 'llama' found using 'pet_type' does not match any of the expected tags: 'blackcat', 'whitecat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_discriminated_union_root_same_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['blackcat']\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['whitecat']\n    Cat = Union[BlackCat, WhiteCat]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n    CatDog = TypeAdapter(Annotated[Union[Cat, Dog], Field(..., discriminator='pet_type')]).validate_python\n    CatDog({'pet_type': 'blackcat'})\n    CatDog({'pet_type': 'whitecat'})\n    CatDog({'pet_type': 'dog'})\n    with pytest.raises(ValidationError) as exc_info:\n        CatDog({'pet_type': 'llama'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'blackcat', 'whitecat', 'dog'\", 'tag': 'llama'}, 'input': {'pet_type': 'llama'}, 'loc': (), 'msg': \"Input tag 'llama' found using 'pet_type' does not match any of the expected tags: 'blackcat', 'whitecat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_discriminated_union_root_same_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['blackcat']\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['whitecat']\n    Cat = Union[BlackCat, WhiteCat]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n    CatDog = TypeAdapter(Annotated[Union[Cat, Dog], Field(..., discriminator='pet_type')]).validate_python\n    CatDog({'pet_type': 'blackcat'})\n    CatDog({'pet_type': 'whitecat'})\n    CatDog({'pet_type': 'dog'})\n    with pytest.raises(ValidationError) as exc_info:\n        CatDog({'pet_type': 'llama'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'blackcat', 'whitecat', 'dog'\", 'tag': 'llama'}, 'input': {'pet_type': 'llama'}, 'loc': (), 'msg': \"Input tag 'llama' found using 'pet_type' does not match any of the expected tags: 'blackcat', 'whitecat', 'dog'\", 'type': 'union_tag_invalid'}]"
        ]
    },
    {
        "func_name": "_get_str_discriminator",
        "original": "def _get_str_discriminator(discriminator: str, kind: str):\n    if kind == 'discriminator':\n        return Discriminator(discriminator)\n    elif kind == 'field_str':\n        return Field(discriminator=discriminator)\n    elif kind == 'field_discriminator':\n        return Field(discriminator=Discriminator(discriminator))\n    raise ValueError(f'Invalid kind: {kind}')",
        "mutated": [
            "def _get_str_discriminator(discriminator: str, kind: str):\n    if False:\n        i = 10\n    if kind == 'discriminator':\n        return Discriminator(discriminator)\n    elif kind == 'field_str':\n        return Field(discriminator=discriminator)\n    elif kind == 'field_discriminator':\n        return Field(discriminator=Discriminator(discriminator))\n    raise ValueError(f'Invalid kind: {kind}')",
            "def _get_str_discriminator(discriminator: str, kind: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if kind == 'discriminator':\n        return Discriminator(discriminator)\n    elif kind == 'field_str':\n        return Field(discriminator=discriminator)\n    elif kind == 'field_discriminator':\n        return Field(discriminator=Discriminator(discriminator))\n    raise ValueError(f'Invalid kind: {kind}')",
            "def _get_str_discriminator(discriminator: str, kind: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if kind == 'discriminator':\n        return Discriminator(discriminator)\n    elif kind == 'field_str':\n        return Field(discriminator=discriminator)\n    elif kind == 'field_discriminator':\n        return Field(discriminator=Discriminator(discriminator))\n    raise ValueError(f'Invalid kind: {kind}')",
            "def _get_str_discriminator(discriminator: str, kind: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if kind == 'discriminator':\n        return Discriminator(discriminator)\n    elif kind == 'field_str':\n        return Field(discriminator=discriminator)\n    elif kind == 'field_discriminator':\n        return Field(discriminator=Discriminator(discriminator))\n    raise ValueError(f'Invalid kind: {kind}')",
            "def _get_str_discriminator(discriminator: str, kind: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if kind == 'discriminator':\n        return Discriminator(discriminator)\n    elif kind == 'field_str':\n        return Field(discriminator=discriminator)\n    elif kind == 'field_discriminator':\n        return Field(discriminator=Discriminator(discriminator))\n    raise ValueError(f'Invalid kind: {kind}')"
        ]
    },
    {
        "func_name": "test_discriminated_union_validation",
        "original": "@pytest.mark.parametrize('color_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\n@pytest.mark.parametrize('pet_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\ndef test_discriminated_union_validation(color_discriminator_kind, pet_discriminator_kind):\n\n    def _get_str_discriminator(discriminator: str, kind: str):\n        if kind == 'discriminator':\n            return Discriminator(discriminator)\n        elif kind == 'field_str':\n            return Field(discriminator=discriminator)\n        elif kind == 'field_discriminator':\n            return Field(discriminator=Discriminator(discriminator))\n        raise ValueError(f'Invalid kind: {kind}')\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    color_discriminator = _get_str_discriminator('color', color_discriminator_kind)\n    Cat = Annotated[Union[BlackCat, WhiteCat], color_discriminator]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        m: str\n    pet_discriminator = _get_str_discriminator('pet_type', pet_discriminator_kind)\n\n    class Model(BaseModel):\n        pet: Annotated[Union[Cat, Dog, Lizard], pet_discriminator]\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': 'fish', 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'model_attributes_type', 'loc': ('pet',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': 'fish'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog', 'reptile', 'lizard'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'reptile', 'lizard'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'lizard'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'lizard'}, 'loc': ('pet', 'lizard', 'm'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, Lizard)\n    assert m.model_dump() == {'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2}\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
        "mutated": [
            "@pytest.mark.parametrize('color_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\n@pytest.mark.parametrize('pet_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\ndef test_discriminated_union_validation(color_discriminator_kind, pet_discriminator_kind):\n    if False:\n        i = 10\n\n    def _get_str_discriminator(discriminator: str, kind: str):\n        if kind == 'discriminator':\n            return Discriminator(discriminator)\n        elif kind == 'field_str':\n            return Field(discriminator=discriminator)\n        elif kind == 'field_discriminator':\n            return Field(discriminator=Discriminator(discriminator))\n        raise ValueError(f'Invalid kind: {kind}')\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    color_discriminator = _get_str_discriminator('color', color_discriminator_kind)\n    Cat = Annotated[Union[BlackCat, WhiteCat], color_discriminator]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        m: str\n    pet_discriminator = _get_str_discriminator('pet_type', pet_discriminator_kind)\n\n    class Model(BaseModel):\n        pet: Annotated[Union[Cat, Dog, Lizard], pet_discriminator]\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': 'fish', 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'model_attributes_type', 'loc': ('pet',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': 'fish'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog', 'reptile', 'lizard'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'reptile', 'lizard'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'lizard'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'lizard'}, 'loc': ('pet', 'lizard', 'm'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, Lizard)\n    assert m.model_dump() == {'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2}\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
            "@pytest.mark.parametrize('color_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\n@pytest.mark.parametrize('pet_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\ndef test_discriminated_union_validation(color_discriminator_kind, pet_discriminator_kind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def _get_str_discriminator(discriminator: str, kind: str):\n        if kind == 'discriminator':\n            return Discriminator(discriminator)\n        elif kind == 'field_str':\n            return Field(discriminator=discriminator)\n        elif kind == 'field_discriminator':\n            return Field(discriminator=Discriminator(discriminator))\n        raise ValueError(f'Invalid kind: {kind}')\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    color_discriminator = _get_str_discriminator('color', color_discriminator_kind)\n    Cat = Annotated[Union[BlackCat, WhiteCat], color_discriminator]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        m: str\n    pet_discriminator = _get_str_discriminator('pet_type', pet_discriminator_kind)\n\n    class Model(BaseModel):\n        pet: Annotated[Union[Cat, Dog, Lizard], pet_discriminator]\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': 'fish', 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'model_attributes_type', 'loc': ('pet',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': 'fish'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog', 'reptile', 'lizard'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'reptile', 'lizard'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'lizard'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'lizard'}, 'loc': ('pet', 'lizard', 'm'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, Lizard)\n    assert m.model_dump() == {'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2}\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
            "@pytest.mark.parametrize('color_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\n@pytest.mark.parametrize('pet_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\ndef test_discriminated_union_validation(color_discriminator_kind, pet_discriminator_kind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def _get_str_discriminator(discriminator: str, kind: str):\n        if kind == 'discriminator':\n            return Discriminator(discriminator)\n        elif kind == 'field_str':\n            return Field(discriminator=discriminator)\n        elif kind == 'field_discriminator':\n            return Field(discriminator=Discriminator(discriminator))\n        raise ValueError(f'Invalid kind: {kind}')\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    color_discriminator = _get_str_discriminator('color', color_discriminator_kind)\n    Cat = Annotated[Union[BlackCat, WhiteCat], color_discriminator]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        m: str\n    pet_discriminator = _get_str_discriminator('pet_type', pet_discriminator_kind)\n\n    class Model(BaseModel):\n        pet: Annotated[Union[Cat, Dog, Lizard], pet_discriminator]\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': 'fish', 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'model_attributes_type', 'loc': ('pet',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': 'fish'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog', 'reptile', 'lizard'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'reptile', 'lizard'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'lizard'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'lizard'}, 'loc': ('pet', 'lizard', 'm'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, Lizard)\n    assert m.model_dump() == {'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2}\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
            "@pytest.mark.parametrize('color_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\n@pytest.mark.parametrize('pet_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\ndef test_discriminated_union_validation(color_discriminator_kind, pet_discriminator_kind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def _get_str_discriminator(discriminator: str, kind: str):\n        if kind == 'discriminator':\n            return Discriminator(discriminator)\n        elif kind == 'field_str':\n            return Field(discriminator=discriminator)\n        elif kind == 'field_discriminator':\n            return Field(discriminator=Discriminator(discriminator))\n        raise ValueError(f'Invalid kind: {kind}')\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    color_discriminator = _get_str_discriminator('color', color_discriminator_kind)\n    Cat = Annotated[Union[BlackCat, WhiteCat], color_discriminator]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        m: str\n    pet_discriminator = _get_str_discriminator('pet_type', pet_discriminator_kind)\n\n    class Model(BaseModel):\n        pet: Annotated[Union[Cat, Dog, Lizard], pet_discriminator]\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': 'fish', 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'model_attributes_type', 'loc': ('pet',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': 'fish'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog', 'reptile', 'lizard'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'reptile', 'lizard'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'lizard'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'lizard'}, 'loc': ('pet', 'lizard', 'm'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, Lizard)\n    assert m.model_dump() == {'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2}\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
            "@pytest.mark.parametrize('color_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\n@pytest.mark.parametrize('pet_discriminator_kind', ['discriminator', 'field_str', 'field_discriminator'])\ndef test_discriminated_union_validation(color_discriminator_kind, pet_discriminator_kind):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def _get_str_discriminator(discriminator: str, kind: str):\n        if kind == 'discriminator':\n            return Discriminator(discriminator)\n        elif kind == 'field_str':\n            return Field(discriminator=discriminator)\n        elif kind == 'field_discriminator':\n            return Field(discriminator=Discriminator(discriminator))\n        raise ValueError(f'Invalid kind: {kind}')\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    color_discriminator = _get_str_discriminator('color', color_discriminator_kind)\n    Cat = Annotated[Union[BlackCat, WhiteCat], color_discriminator]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        m: str\n    pet_discriminator = _get_str_discriminator('pet_type', pet_discriminator_kind)\n\n    class Model(BaseModel):\n        pet: Annotated[Union[Cat, Dog, Lizard], pet_discriminator]\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': 'fish', 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'model_attributes_type', 'loc': ('pet',), 'msg': 'Input should be a valid dictionary or object to extract fields from', 'input': 'fish'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog', 'reptile', 'lizard'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'reptile', 'lizard'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'lizard'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'lizard'}, 'loc': ('pet', 'lizard', 'm'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, Lizard)\n    assert m.model_dump() == {'pet': {'pet_type': 'lizard', 'm': 'pika'}, 'number': 2}\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)"
        ]
    },
    {
        "func_name": "test_discriminated_annotated_union",
        "original": "def test_discriminated_annotated_union():\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        dog_name: str\n    Pet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Pet\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'dog'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'dog'}, 'loc': ('pet', 'dog', 'dog_name'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'dog', 'dog_name': 'milou'}, 'number': 2})\n    assert isinstance(m.pet, Dog)\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'red'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'color'\", 'expected_tags': \"'black', 'white'\", 'tag': 'red'}, 'input': {'color': 'red', 'pet_type': 'cat'}, 'loc': ('pet', 'cat'), 'msg': \"Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
        "mutated": [
            "def test_discriminated_annotated_union():\n    if False:\n        i = 10\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        dog_name: str\n    Pet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Pet\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'dog'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'dog'}, 'loc': ('pet', 'dog', 'dog_name'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'dog', 'dog_name': 'milou'}, 'number': 2})\n    assert isinstance(m.pet, Dog)\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'red'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'color'\", 'expected_tags': \"'black', 'white'\", 'tag': 'red'}, 'input': {'color': 'red', 'pet_type': 'cat'}, 'loc': ('pet', 'cat'), 'msg': \"Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
            "def test_discriminated_annotated_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        dog_name: str\n    Pet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Pet\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'dog'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'dog'}, 'loc': ('pet', 'dog', 'dog_name'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'dog', 'dog_name': 'milou'}, 'number': 2})\n    assert isinstance(m.pet, Dog)\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'red'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'color'\", 'expected_tags': \"'black', 'white'\", 'tag': 'red'}, 'input': {'color': 'red', 'pet_type': 'cat'}, 'loc': ('pet', 'cat'), 'msg': \"Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
            "def test_discriminated_annotated_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        dog_name: str\n    Pet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Pet\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'dog'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'dog'}, 'loc': ('pet', 'dog', 'dog_name'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'dog', 'dog_name': 'milou'}, 'number': 2})\n    assert isinstance(m.pet, Dog)\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'red'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'color'\", 'expected_tags': \"'black', 'white'\", 'tag': 'red'}, 'input': {'color': 'red', 'pet_type': 'cat'}, 'loc': ('pet', 'cat'), 'msg': \"Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
            "def test_discriminated_annotated_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        dog_name: str\n    Pet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Pet\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'dog'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'dog'}, 'loc': ('pet', 'dog', 'dog_name'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'dog', 'dog_name': 'milou'}, 'number': 2})\n    assert isinstance(m.pet, Dog)\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'red'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'color'\", 'expected_tags': \"'black', 'white'\", 'tag': 'red'}, 'input': {'color': 'red', 'pet_type': 'cat'}, 'loc': ('pet', 'cat'), 'msg': \"Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)",
            "def test_discriminated_annotated_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class BlackCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['black']\n        black_infos: str\n\n    class WhiteCat(BaseModel):\n        pet_type: Literal['cat']\n        color: Literal['white']\n        white_infos: str\n    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        dog_name: str\n    Pet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Pet\n        number: int\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_typ': 'cat'}, 'number': 'x'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'pet_typ': 'cat'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}, {'input': 'x', 'loc': ('number',), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'type': 'int_parsing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'fish'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_type': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'dog'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'pet_type': 'dog'}, 'loc': ('pet', 'dog', 'dog_name'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'dog', 'dog_name': 'milou'}, 'number': 2})\n    assert isinstance(m.pet, Dog)\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'red'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'color'\", 'expected_tags': \"'black', 'white'\", 'tag': 'red'}, 'input': {'color': 'red', 'pet_type': 'cat'}, 'loc': ('pet', 'cat'), 'msg': \"Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white'}, 'number': 2})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'color': 'white', 'pet_type': 'cat'}, 'loc': ('pet', 'cat', 'white', 'white_infos'), 'msg': 'Field required', 'type': 'missing'}]\n    m = Model.model_validate({'pet': {'pet_type': 'cat', 'color': 'white', 'white_infos': 'pika'}, 'number': 2})\n    assert isinstance(m.pet, WhiteCat)"
        ]
    },
    {
        "func_name": "test_discriminated_union_basemodel_instance_value",
        "original": "def test_discriminated_union_basemodel_instance_value():\n\n    class A(BaseModel):\n        foo: Literal['a']\n\n    class B(BaseModel):\n        foo: Literal['b']\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='foo')\n    t = Top(sub=A(foo='a'))\n    assert isinstance(t, Top)",
        "mutated": [
            "def test_discriminated_union_basemodel_instance_value():\n    if False:\n        i = 10\n\n    class A(BaseModel):\n        foo: Literal['a']\n\n    class B(BaseModel):\n        foo: Literal['b']\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='foo')\n    t = Top(sub=A(foo='a'))\n    assert isinstance(t, Top)",
            "def test_discriminated_union_basemodel_instance_value():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class A(BaseModel):\n        foo: Literal['a']\n\n    class B(BaseModel):\n        foo: Literal['b']\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='foo')\n    t = Top(sub=A(foo='a'))\n    assert isinstance(t, Top)",
            "def test_discriminated_union_basemodel_instance_value():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class A(BaseModel):\n        foo: Literal['a']\n\n    class B(BaseModel):\n        foo: Literal['b']\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='foo')\n    t = Top(sub=A(foo='a'))\n    assert isinstance(t, Top)",
            "def test_discriminated_union_basemodel_instance_value():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class A(BaseModel):\n        foo: Literal['a']\n\n    class B(BaseModel):\n        foo: Literal['b']\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='foo')\n    t = Top(sub=A(foo='a'))\n    assert isinstance(t, Top)",
            "def test_discriminated_union_basemodel_instance_value():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class A(BaseModel):\n        foo: Literal['a']\n\n    class B(BaseModel):\n        foo: Literal['b']\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='foo')\n    t = Top(sub=A(foo='a'))\n    assert isinstance(t, Top)"
        ]
    },
    {
        "func_name": "test_discriminated_union_basemodel_instance_value_with_alias",
        "original": "def test_discriminated_union_basemodel_instance_value_with_alias():\n\n    class A(BaseModel):\n        literal: Literal['a'] = Field(alias='lit')\n\n    class B(BaseModel):\n        model_config = ConfigDict(populate_by_name=True)\n        literal: Literal['b'] = Field(alias='lit')\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='literal')\n    with pytest.raises(ValidationError) as exc_info:\n        Top(sub=A(literal='a'))\n    assert exc_info.value.errors(include_url=False) == [{'input': {'literal': 'a'}, 'loc': ('lit',), 'msg': 'Field required', 'type': 'missing'}]\n    assert Top(sub=A(lit='a')).sub.literal == 'a'\n    assert Top(sub=B(lit='b')).sub.literal == 'b'\n    assert Top(sub=B(literal='b')).sub.literal == 'b'",
        "mutated": [
            "def test_discriminated_union_basemodel_instance_value_with_alias():\n    if False:\n        i = 10\n\n    class A(BaseModel):\n        literal: Literal['a'] = Field(alias='lit')\n\n    class B(BaseModel):\n        model_config = ConfigDict(populate_by_name=True)\n        literal: Literal['b'] = Field(alias='lit')\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='literal')\n    with pytest.raises(ValidationError) as exc_info:\n        Top(sub=A(literal='a'))\n    assert exc_info.value.errors(include_url=False) == [{'input': {'literal': 'a'}, 'loc': ('lit',), 'msg': 'Field required', 'type': 'missing'}]\n    assert Top(sub=A(lit='a')).sub.literal == 'a'\n    assert Top(sub=B(lit='b')).sub.literal == 'b'\n    assert Top(sub=B(literal='b')).sub.literal == 'b'",
            "def test_discriminated_union_basemodel_instance_value_with_alias():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class A(BaseModel):\n        literal: Literal['a'] = Field(alias='lit')\n\n    class B(BaseModel):\n        model_config = ConfigDict(populate_by_name=True)\n        literal: Literal['b'] = Field(alias='lit')\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='literal')\n    with pytest.raises(ValidationError) as exc_info:\n        Top(sub=A(literal='a'))\n    assert exc_info.value.errors(include_url=False) == [{'input': {'literal': 'a'}, 'loc': ('lit',), 'msg': 'Field required', 'type': 'missing'}]\n    assert Top(sub=A(lit='a')).sub.literal == 'a'\n    assert Top(sub=B(lit='b')).sub.literal == 'b'\n    assert Top(sub=B(literal='b')).sub.literal == 'b'",
            "def test_discriminated_union_basemodel_instance_value_with_alias():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class A(BaseModel):\n        literal: Literal['a'] = Field(alias='lit')\n\n    class B(BaseModel):\n        model_config = ConfigDict(populate_by_name=True)\n        literal: Literal['b'] = Field(alias='lit')\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='literal')\n    with pytest.raises(ValidationError) as exc_info:\n        Top(sub=A(literal='a'))\n    assert exc_info.value.errors(include_url=False) == [{'input': {'literal': 'a'}, 'loc': ('lit',), 'msg': 'Field required', 'type': 'missing'}]\n    assert Top(sub=A(lit='a')).sub.literal == 'a'\n    assert Top(sub=B(lit='b')).sub.literal == 'b'\n    assert Top(sub=B(literal='b')).sub.literal == 'b'",
            "def test_discriminated_union_basemodel_instance_value_with_alias():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class A(BaseModel):\n        literal: Literal['a'] = Field(alias='lit')\n\n    class B(BaseModel):\n        model_config = ConfigDict(populate_by_name=True)\n        literal: Literal['b'] = Field(alias='lit')\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='literal')\n    with pytest.raises(ValidationError) as exc_info:\n        Top(sub=A(literal='a'))\n    assert exc_info.value.errors(include_url=False) == [{'input': {'literal': 'a'}, 'loc': ('lit',), 'msg': 'Field required', 'type': 'missing'}]\n    assert Top(sub=A(lit='a')).sub.literal == 'a'\n    assert Top(sub=B(lit='b')).sub.literal == 'b'\n    assert Top(sub=B(literal='b')).sub.literal == 'b'",
            "def test_discriminated_union_basemodel_instance_value_with_alias():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class A(BaseModel):\n        literal: Literal['a'] = Field(alias='lit')\n\n    class B(BaseModel):\n        model_config = ConfigDict(populate_by_name=True)\n        literal: Literal['b'] = Field(alias='lit')\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='literal')\n    with pytest.raises(ValidationError) as exc_info:\n        Top(sub=A(literal='a'))\n    assert exc_info.value.errors(include_url=False) == [{'input': {'literal': 'a'}, 'loc': ('lit',), 'msg': 'Field required', 'type': 'missing'}]\n    assert Top(sub=A(lit='a')).sub.literal == 'a'\n    assert Top(sub=B(lit='b')).sub.literal == 'b'\n    assert Top(sub=B(literal='b')).sub.literal == 'b'"
        ]
    },
    {
        "func_name": "test_discriminated_union_int",
        "original": "def test_discriminated_union_int():\n\n    class A(BaseModel):\n        m: Literal[1]\n\n    class B(BaseModel):\n        m: Literal[2]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': 2}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'m'\", 'expected_tags': '1, 2', 'tag': '3'}, 'input': {'m': 3}, 'loc': ('sub',), 'msg': \"Input tag '3' found using 'm' does not match any of the expected tags: 1, 2\", 'type': 'union_tag_invalid'}]",
        "mutated": [
            "def test_discriminated_union_int():\n    if False:\n        i = 10\n\n    class A(BaseModel):\n        m: Literal[1]\n\n    class B(BaseModel):\n        m: Literal[2]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': 2}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'m'\", 'expected_tags': '1, 2', 'tag': '3'}, 'input': {'m': 3}, 'loc': ('sub',), 'msg': \"Input tag '3' found using 'm' does not match any of the expected tags: 1, 2\", 'type': 'union_tag_invalid'}]",
            "def test_discriminated_union_int():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class A(BaseModel):\n        m: Literal[1]\n\n    class B(BaseModel):\n        m: Literal[2]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': 2}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'m'\", 'expected_tags': '1, 2', 'tag': '3'}, 'input': {'m': 3}, 'loc': ('sub',), 'msg': \"Input tag '3' found using 'm' does not match any of the expected tags: 1, 2\", 'type': 'union_tag_invalid'}]",
            "def test_discriminated_union_int():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class A(BaseModel):\n        m: Literal[1]\n\n    class B(BaseModel):\n        m: Literal[2]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': 2}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'m'\", 'expected_tags': '1, 2', 'tag': '3'}, 'input': {'m': 3}, 'loc': ('sub',), 'msg': \"Input tag '3' found using 'm' does not match any of the expected tags: 1, 2\", 'type': 'union_tag_invalid'}]",
            "def test_discriminated_union_int():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class A(BaseModel):\n        m: Literal[1]\n\n    class B(BaseModel):\n        m: Literal[2]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': 2}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'m'\", 'expected_tags': '1, 2', 'tag': '3'}, 'input': {'m': 3}, 'loc': ('sub',), 'msg': \"Input tag '3' found using 'm' does not match any of the expected tags: 1, 2\", 'type': 'union_tag_invalid'}]",
            "def test_discriminated_union_int():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class A(BaseModel):\n        m: Literal[1]\n\n    class B(BaseModel):\n        m: Literal[2]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': 2}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'m'\", 'expected_tags': '1, 2', 'tag': '3'}, 'input': {'m': 3}, 'loc': ('sub',), 'msg': \"Input tag '3' found using 'm' does not match any of the expected tags: 1, 2\", 'type': 'union_tag_invalid'}]"
        ]
    },
    {
        "func_name": "test_discriminated_union_enum",
        "original": "@pytest.mark.skipif(sys.version_info[:2] == (3, 8), reason='https://github.com/python/cpython/issues/103592')\n@pytest.mark.parametrize('base_class,choices', ENUM_TEST_CASES)\ndef test_discriminated_union_enum(base_class, choices):\n    EnumValue = base_class('EnumValue', choices)\n\n    class A(BaseModel):\n        m: Literal[EnumValue.a]\n\n    class B(BaseModel):\n        m: Literal[EnumValue.b]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b}}).sub, B)\n    if isinstance(EnumValue.b, (int, str)):\n        assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b.value}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    expected_tags = f'{EnumValue.a!r}, {EnumValue.b!r}'\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('sub',), 'msg': f\"Input tag '3' found using 'm' does not match any of the expected tags: {expected_tags}\", 'input': {'m': 3}, 'ctx': {'discriminator': \"'m'\", 'tag': '3', 'expected_tags': expected_tags}}]",
        "mutated": [
            "@pytest.mark.skipif(sys.version_info[:2] == (3, 8), reason='https://github.com/python/cpython/issues/103592')\n@pytest.mark.parametrize('base_class,choices', ENUM_TEST_CASES)\ndef test_discriminated_union_enum(base_class, choices):\n    if False:\n        i = 10\n    EnumValue = base_class('EnumValue', choices)\n\n    class A(BaseModel):\n        m: Literal[EnumValue.a]\n\n    class B(BaseModel):\n        m: Literal[EnumValue.b]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b}}).sub, B)\n    if isinstance(EnumValue.b, (int, str)):\n        assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b.value}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    expected_tags = f'{EnumValue.a!r}, {EnumValue.b!r}'\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('sub',), 'msg': f\"Input tag '3' found using 'm' does not match any of the expected tags: {expected_tags}\", 'input': {'m': 3}, 'ctx': {'discriminator': \"'m'\", 'tag': '3', 'expected_tags': expected_tags}}]",
            "@pytest.mark.skipif(sys.version_info[:2] == (3, 8), reason='https://github.com/python/cpython/issues/103592')\n@pytest.mark.parametrize('base_class,choices', ENUM_TEST_CASES)\ndef test_discriminated_union_enum(base_class, choices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    EnumValue = base_class('EnumValue', choices)\n\n    class A(BaseModel):\n        m: Literal[EnumValue.a]\n\n    class B(BaseModel):\n        m: Literal[EnumValue.b]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b}}).sub, B)\n    if isinstance(EnumValue.b, (int, str)):\n        assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b.value}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    expected_tags = f'{EnumValue.a!r}, {EnumValue.b!r}'\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('sub',), 'msg': f\"Input tag '3' found using 'm' does not match any of the expected tags: {expected_tags}\", 'input': {'m': 3}, 'ctx': {'discriminator': \"'m'\", 'tag': '3', 'expected_tags': expected_tags}}]",
            "@pytest.mark.skipif(sys.version_info[:2] == (3, 8), reason='https://github.com/python/cpython/issues/103592')\n@pytest.mark.parametrize('base_class,choices', ENUM_TEST_CASES)\ndef test_discriminated_union_enum(base_class, choices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    EnumValue = base_class('EnumValue', choices)\n\n    class A(BaseModel):\n        m: Literal[EnumValue.a]\n\n    class B(BaseModel):\n        m: Literal[EnumValue.b]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b}}).sub, B)\n    if isinstance(EnumValue.b, (int, str)):\n        assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b.value}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    expected_tags = f'{EnumValue.a!r}, {EnumValue.b!r}'\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('sub',), 'msg': f\"Input tag '3' found using 'm' does not match any of the expected tags: {expected_tags}\", 'input': {'m': 3}, 'ctx': {'discriminator': \"'m'\", 'tag': '3', 'expected_tags': expected_tags}}]",
            "@pytest.mark.skipif(sys.version_info[:2] == (3, 8), reason='https://github.com/python/cpython/issues/103592')\n@pytest.mark.parametrize('base_class,choices', ENUM_TEST_CASES)\ndef test_discriminated_union_enum(base_class, choices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    EnumValue = base_class('EnumValue', choices)\n\n    class A(BaseModel):\n        m: Literal[EnumValue.a]\n\n    class B(BaseModel):\n        m: Literal[EnumValue.b]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b}}).sub, B)\n    if isinstance(EnumValue.b, (int, str)):\n        assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b.value}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    expected_tags = f'{EnumValue.a!r}, {EnumValue.b!r}'\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('sub',), 'msg': f\"Input tag '3' found using 'm' does not match any of the expected tags: {expected_tags}\", 'input': {'m': 3}, 'ctx': {'discriminator': \"'m'\", 'tag': '3', 'expected_tags': expected_tags}}]",
            "@pytest.mark.skipif(sys.version_info[:2] == (3, 8), reason='https://github.com/python/cpython/issues/103592')\n@pytest.mark.parametrize('base_class,choices', ENUM_TEST_CASES)\ndef test_discriminated_union_enum(base_class, choices):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    EnumValue = base_class('EnumValue', choices)\n\n    class A(BaseModel):\n        m: Literal[EnumValue.a]\n\n    class B(BaseModel):\n        m: Literal[EnumValue.b]\n\n    class Top(BaseModel):\n        sub: Union[A, B] = Field(..., discriminator='m')\n    assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b}}).sub, B)\n    if isinstance(EnumValue.b, (int, str)):\n        assert isinstance(Top.model_validate({'sub': {'m': EnumValue.b.value}}).sub, B)\n    with pytest.raises(ValidationError) as exc_info:\n        Top.model_validate({'sub': {'m': 3}})\n    expected_tags = f'{EnumValue.a!r}, {EnumValue.b!r}'\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('sub',), 'msg': f\"Input tag '3' found using 'm' does not match any of the expected tags: {expected_tags}\", 'input': {'m': 3}, 'ctx': {'discriminator': \"'m'\", 'tag': '3', 'expected_tags': expected_tags}}]"
        ]
    },
    {
        "func_name": "test_alias_different",
        "original": "def test_alias_different():\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='U')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='T')\n        d: str\n    with pytest.raises(TypeError, match=re.escape(\"Aliases for discriminator 'pet_type' must be the same (got T, U)\")):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
        "mutated": [
            "def test_alias_different():\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='U')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='T')\n        d: str\n    with pytest.raises(TypeError, match=re.escape(\"Aliases for discriminator 'pet_type' must be the same (got T, U)\")):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
            "def test_alias_different():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='U')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='T')\n        d: str\n    with pytest.raises(TypeError, match=re.escape(\"Aliases for discriminator 'pet_type' must be the same (got T, U)\")):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
            "def test_alias_different():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='U')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='T')\n        d: str\n    with pytest.raises(TypeError, match=re.escape(\"Aliases for discriminator 'pet_type' must be the same (got T, U)\")):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
            "def test_alias_different():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='U')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='T')\n        d: str\n    with pytest.raises(TypeError, match=re.escape(\"Aliases for discriminator 'pet_type' must be the same (got T, U)\")):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
            "def test_alias_different():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='U')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='T')\n        d: str\n    with pytest.raises(TypeError, match=re.escape(\"Aliases for discriminator 'pet_type' must be the same (got T, U)\")):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')"
        ]
    },
    {
        "func_name": "test_alias_same",
        "original": "def test_alias_same():\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog', 'd': 'milou'}}).pet.pet_type == 'dog'",
        "mutated": [
            "def test_alias_same():\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog', 'd': 'milou'}}).pet.pet_type == 'dog'",
            "def test_alias_same():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog', 'd': 'milou'}}).pet.pet_type == 'dog'",
            "def test_alias_same():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog', 'd': 'milou'}}).pet.pet_type == 'dog'",
            "def test_alias_same():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog', 'd': 'milou'}}).pet.pet_type == 'dog'",
            "def test_alias_same():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog', 'd': 'milou'}}).pet.pet_type == 'dog'"
        ]
    },
    {
        "func_name": "test_nested",
        "original": "def test_nested():\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n    CommonPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        name: str\n\n    class Model(BaseModel):\n        pet: Union[CommonPet, Lizard] = Field(..., discriminator='pet_type')\n        n: int\n    assert isinstance(Model(**{'pet': {'pet_type': 'dog', 'name': 'Milou'}, 'n': 5}).pet, Dog)",
        "mutated": [
            "def test_nested():\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n    CommonPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        name: str\n\n    class Model(BaseModel):\n        pet: Union[CommonPet, Lizard] = Field(..., discriminator='pet_type')\n        n: int\n    assert isinstance(Model(**{'pet': {'pet_type': 'dog', 'name': 'Milou'}, 'n': 5}).pet, Dog)",
            "def test_nested():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n    CommonPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        name: str\n\n    class Model(BaseModel):\n        pet: Union[CommonPet, Lizard] = Field(..., discriminator='pet_type')\n        n: int\n    assert isinstance(Model(**{'pet': {'pet_type': 'dog', 'name': 'Milou'}, 'n': 5}).pet, Dog)",
            "def test_nested():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n    CommonPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        name: str\n\n    class Model(BaseModel):\n        pet: Union[CommonPet, Lizard] = Field(..., discriminator='pet_type')\n        n: int\n    assert isinstance(Model(**{'pet': {'pet_type': 'dog', 'name': 'Milou'}, 'n': 5}).pet, Dog)",
            "def test_nested():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n    CommonPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        name: str\n\n    class Model(BaseModel):\n        pet: Union[CommonPet, Lizard] = Field(..., discriminator='pet_type')\n        n: int\n    assert isinstance(Model(**{'pet': {'pet_type': 'dog', 'name': 'Milou'}, 'n': 5}).pet, Dog)",
            "def test_nested():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n    CommonPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        name: str\n\n    class Model(BaseModel):\n        pet: Union[CommonPet, Lizard] = Field(..., discriminator='pet_type')\n        n: int\n    assert isinstance(Model(**{'pet': {'pet_type': 'dog', 'name': 'Milou'}, 'n': 5}).pet, Dog)"
        ]
    },
    {
        "func_name": "test_generic",
        "original": "def test_generic():\n    T = TypeVar('T')\n\n    class Success(BaseModel, Generic[T]):\n        type: Literal['Success'] = 'Success'\n        data: T\n\n    class Failure(BaseModel):\n        type: Literal['Failure'] = 'Failure'\n        error_message: str\n\n    class Container(BaseModel, Generic[T]):\n        result: Union[Success[T], Failure] = Field(discriminator='type')\n    with pytest.raises(ValidationError, match=\"Unable to extract tag using discriminator 'type'\"):\n        Container[str].model_validate({'result': {}})\n    with pytest.raises(ValidationError, match=re.escape(\"Input tag 'Other' found using 'type' does not match any of the expected tags: 'Success', 'Failure'\")):\n        Container[str].model_validate({'result': {'type': 'Other'}})\n    with pytest.raises(ValidationError, match='Container\\\\[str\\\\]\\\\nresult\\\\.Success\\\\.data') as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success'}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'type': 'Success'}, 'loc': ('result', 'Success', 'data'), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success', 'data': 1}})\n    assert exc_info.value.errors(include_url=False) == [{'input': 1, 'loc': ('result', 'Success', 'data'), 'msg': 'Input should be a valid string', 'type': 'string_type'}]\n    assert Container[str].model_validate({'result': {'type': 'Success', 'data': '1'}}).result.data == '1'",
        "mutated": [
            "def test_generic():\n    if False:\n        i = 10\n    T = TypeVar('T')\n\n    class Success(BaseModel, Generic[T]):\n        type: Literal['Success'] = 'Success'\n        data: T\n\n    class Failure(BaseModel):\n        type: Literal['Failure'] = 'Failure'\n        error_message: str\n\n    class Container(BaseModel, Generic[T]):\n        result: Union[Success[T], Failure] = Field(discriminator='type')\n    with pytest.raises(ValidationError, match=\"Unable to extract tag using discriminator 'type'\"):\n        Container[str].model_validate({'result': {}})\n    with pytest.raises(ValidationError, match=re.escape(\"Input tag 'Other' found using 'type' does not match any of the expected tags: 'Success', 'Failure'\")):\n        Container[str].model_validate({'result': {'type': 'Other'}})\n    with pytest.raises(ValidationError, match='Container\\\\[str\\\\]\\\\nresult\\\\.Success\\\\.data') as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success'}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'type': 'Success'}, 'loc': ('result', 'Success', 'data'), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success', 'data': 1}})\n    assert exc_info.value.errors(include_url=False) == [{'input': 1, 'loc': ('result', 'Success', 'data'), 'msg': 'Input should be a valid string', 'type': 'string_type'}]\n    assert Container[str].model_validate({'result': {'type': 'Success', 'data': '1'}}).result.data == '1'",
            "def test_generic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    T = TypeVar('T')\n\n    class Success(BaseModel, Generic[T]):\n        type: Literal['Success'] = 'Success'\n        data: T\n\n    class Failure(BaseModel):\n        type: Literal['Failure'] = 'Failure'\n        error_message: str\n\n    class Container(BaseModel, Generic[T]):\n        result: Union[Success[T], Failure] = Field(discriminator='type')\n    with pytest.raises(ValidationError, match=\"Unable to extract tag using discriminator 'type'\"):\n        Container[str].model_validate({'result': {}})\n    with pytest.raises(ValidationError, match=re.escape(\"Input tag 'Other' found using 'type' does not match any of the expected tags: 'Success', 'Failure'\")):\n        Container[str].model_validate({'result': {'type': 'Other'}})\n    with pytest.raises(ValidationError, match='Container\\\\[str\\\\]\\\\nresult\\\\.Success\\\\.data') as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success'}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'type': 'Success'}, 'loc': ('result', 'Success', 'data'), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success', 'data': 1}})\n    assert exc_info.value.errors(include_url=False) == [{'input': 1, 'loc': ('result', 'Success', 'data'), 'msg': 'Input should be a valid string', 'type': 'string_type'}]\n    assert Container[str].model_validate({'result': {'type': 'Success', 'data': '1'}}).result.data == '1'",
            "def test_generic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    T = TypeVar('T')\n\n    class Success(BaseModel, Generic[T]):\n        type: Literal['Success'] = 'Success'\n        data: T\n\n    class Failure(BaseModel):\n        type: Literal['Failure'] = 'Failure'\n        error_message: str\n\n    class Container(BaseModel, Generic[T]):\n        result: Union[Success[T], Failure] = Field(discriminator='type')\n    with pytest.raises(ValidationError, match=\"Unable to extract tag using discriminator 'type'\"):\n        Container[str].model_validate({'result': {}})\n    with pytest.raises(ValidationError, match=re.escape(\"Input tag 'Other' found using 'type' does not match any of the expected tags: 'Success', 'Failure'\")):\n        Container[str].model_validate({'result': {'type': 'Other'}})\n    with pytest.raises(ValidationError, match='Container\\\\[str\\\\]\\\\nresult\\\\.Success\\\\.data') as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success'}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'type': 'Success'}, 'loc': ('result', 'Success', 'data'), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success', 'data': 1}})\n    assert exc_info.value.errors(include_url=False) == [{'input': 1, 'loc': ('result', 'Success', 'data'), 'msg': 'Input should be a valid string', 'type': 'string_type'}]\n    assert Container[str].model_validate({'result': {'type': 'Success', 'data': '1'}}).result.data == '1'",
            "def test_generic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    T = TypeVar('T')\n\n    class Success(BaseModel, Generic[T]):\n        type: Literal['Success'] = 'Success'\n        data: T\n\n    class Failure(BaseModel):\n        type: Literal['Failure'] = 'Failure'\n        error_message: str\n\n    class Container(BaseModel, Generic[T]):\n        result: Union[Success[T], Failure] = Field(discriminator='type')\n    with pytest.raises(ValidationError, match=\"Unable to extract tag using discriminator 'type'\"):\n        Container[str].model_validate({'result': {}})\n    with pytest.raises(ValidationError, match=re.escape(\"Input tag 'Other' found using 'type' does not match any of the expected tags: 'Success', 'Failure'\")):\n        Container[str].model_validate({'result': {'type': 'Other'}})\n    with pytest.raises(ValidationError, match='Container\\\\[str\\\\]\\\\nresult\\\\.Success\\\\.data') as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success'}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'type': 'Success'}, 'loc': ('result', 'Success', 'data'), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success', 'data': 1}})\n    assert exc_info.value.errors(include_url=False) == [{'input': 1, 'loc': ('result', 'Success', 'data'), 'msg': 'Input should be a valid string', 'type': 'string_type'}]\n    assert Container[str].model_validate({'result': {'type': 'Success', 'data': '1'}}).result.data == '1'",
            "def test_generic():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    T = TypeVar('T')\n\n    class Success(BaseModel, Generic[T]):\n        type: Literal['Success'] = 'Success'\n        data: T\n\n    class Failure(BaseModel):\n        type: Literal['Failure'] = 'Failure'\n        error_message: str\n\n    class Container(BaseModel, Generic[T]):\n        result: Union[Success[T], Failure] = Field(discriminator='type')\n    with pytest.raises(ValidationError, match=\"Unable to extract tag using discriminator 'type'\"):\n        Container[str].model_validate({'result': {}})\n    with pytest.raises(ValidationError, match=re.escape(\"Input tag 'Other' found using 'type' does not match any of the expected tags: 'Success', 'Failure'\")):\n        Container[str].model_validate({'result': {'type': 'Other'}})\n    with pytest.raises(ValidationError, match='Container\\\\[str\\\\]\\\\nresult\\\\.Success\\\\.data') as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success'}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'type': 'Success'}, 'loc': ('result', 'Success', 'data'), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Container[str].model_validate({'result': {'type': 'Success', 'data': 1}})\n    assert exc_info.value.errors(include_url=False) == [{'input': 1, 'loc': ('result', 'Success', 'data'), 'msg': 'Input should be a valid string', 'type': 'string_type'}]\n    assert Container[str].model_validate({'result': {'type': 'Success', 'data': '1'}}).result.data == '1'"
        ]
    },
    {
        "func_name": "test_optional_union",
        "original": "def test_optional_union():\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet()\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('pet',), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
        "mutated": [
            "def test_optional_union():\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet()\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('pet',), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_optional_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet()\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('pet',), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_optional_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet()\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('pet',), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_optional_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet()\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('pet',), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_optional_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet()\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('pet',), 'msg': 'Field required', 'type': 'missing'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]"
        ]
    },
    {
        "func_name": "test_optional_union_with_defaults",
        "original": "def test_optional_union_with_defaults():\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(default=None, discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    assert Pet().model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
        "mutated": [
            "def test_optional_union_with_defaults():\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(default=None, discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    assert Pet().model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_optional_union_with_defaults():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(default=None, discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    assert Pet().model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_optional_union_with_defaults():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(default=None, discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    assert Pet().model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_optional_union_with_defaults():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(default=None, discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    assert Pet().model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_optional_union_with_defaults():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n        name: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n        name: str\n\n    class Pet(BaseModel):\n        pet: Optional[Union[Cat, Dog]] = Field(default=None, discriminator='pet_type')\n    assert Pet(pet={'pet_type': 'cat', 'name': 'Milo'}).model_dump() == {'pet': {'name': 'Milo', 'pet_type': 'cat'}}\n    assert Pet(pet={'pet_type': 'dog', 'name': 'Otis'}).model_dump() == {'pet': {'name': 'Otis', 'pet_type': 'dog'}}\n    assert Pet(pet=None).model_dump() == {'pet': None}\n    assert Pet().model_dump() == {'pet': None}\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'name': 'Benji'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\"}, 'input': {'name': 'Benji'}, 'loc': ('pet',), 'msg': \"Unable to extract tag using discriminator 'pet_type'\", 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet(pet={'pet_type': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'pet_type'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'pet_type': 'lizard'}, 'loc': ('pet',), 'msg': \"Input tag 'lizard' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]"
        ]
    },
    {
        "func_name": "test_aliases_matching_is_not_sufficient",
        "original": "def test_aliases_matching_is_not_sufficient() -> None:\n\n    class Case1(BaseModel):\n        kind_one: Literal['1'] = Field(alias='kind')\n\n    class Case2(BaseModel):\n        kind_two: Literal['2'] = Field(alias='kind')\n    with pytest.raises(PydanticUserError, match=\"Model 'Case1' needs a discriminator field for key 'kind'\"):\n\n        class TaggedParent(BaseModel):\n            tagged: Union[Case1, Case2] = Field(discriminator='kind')",
        "mutated": [
            "def test_aliases_matching_is_not_sufficient() -> None:\n    if False:\n        i = 10\n\n    class Case1(BaseModel):\n        kind_one: Literal['1'] = Field(alias='kind')\n\n    class Case2(BaseModel):\n        kind_two: Literal['2'] = Field(alias='kind')\n    with pytest.raises(PydanticUserError, match=\"Model 'Case1' needs a discriminator field for key 'kind'\"):\n\n        class TaggedParent(BaseModel):\n            tagged: Union[Case1, Case2] = Field(discriminator='kind')",
            "def test_aliases_matching_is_not_sufficient() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Case1(BaseModel):\n        kind_one: Literal['1'] = Field(alias='kind')\n\n    class Case2(BaseModel):\n        kind_two: Literal['2'] = Field(alias='kind')\n    with pytest.raises(PydanticUserError, match=\"Model 'Case1' needs a discriminator field for key 'kind'\"):\n\n        class TaggedParent(BaseModel):\n            tagged: Union[Case1, Case2] = Field(discriminator='kind')",
            "def test_aliases_matching_is_not_sufficient() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Case1(BaseModel):\n        kind_one: Literal['1'] = Field(alias='kind')\n\n    class Case2(BaseModel):\n        kind_two: Literal['2'] = Field(alias='kind')\n    with pytest.raises(PydanticUserError, match=\"Model 'Case1' needs a discriminator field for key 'kind'\"):\n\n        class TaggedParent(BaseModel):\n            tagged: Union[Case1, Case2] = Field(discriminator='kind')",
            "def test_aliases_matching_is_not_sufficient() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Case1(BaseModel):\n        kind_one: Literal['1'] = Field(alias='kind')\n\n    class Case2(BaseModel):\n        kind_two: Literal['2'] = Field(alias='kind')\n    with pytest.raises(PydanticUserError, match=\"Model 'Case1' needs a discriminator field for key 'kind'\"):\n\n        class TaggedParent(BaseModel):\n            tagged: Union[Case1, Case2] = Field(discriminator='kind')",
            "def test_aliases_matching_is_not_sufficient() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Case1(BaseModel):\n        kind_one: Literal['1'] = Field(alias='kind')\n\n    class Case2(BaseModel):\n        kind_two: Literal['2'] = Field(alias='kind')\n    with pytest.raises(PydanticUserError, match=\"Model 'Case1' needs a discriminator field for key 'kind'\"):\n\n        class TaggedParent(BaseModel):\n            tagged: Union[Case1, Case2] = Field(discriminator='kind')"
        ]
    },
    {
        "func_name": "test_nested_optional_unions",
        "original": "def test_nested_optional_unions() -> None:\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'reptile'] = 'lizard'\n    MaybeCatDog = Annotated[Optional[Union[Cat, Dog]], Field(discriminator='pet_type')]\n    MaybeDogLizard = Annotated[Union[Dog, Lizard, None], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: Union[MaybeCatDog, MaybeDogLizard] = Field(discriminator='pet_type')\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    Pet.model_validate({'pet': None})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': None}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'None' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': None}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'None', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'fox'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'fox' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': 'fox'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'fox', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]",
        "mutated": [
            "def test_nested_optional_unions() -> None:\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'reptile'] = 'lizard'\n    MaybeCatDog = Annotated[Optional[Union[Cat, Dog]], Field(discriminator='pet_type')]\n    MaybeDogLizard = Annotated[Union[Dog, Lizard, None], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: Union[MaybeCatDog, MaybeDogLizard] = Field(discriminator='pet_type')\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    Pet.model_validate({'pet': None})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': None}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'None' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': None}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'None', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'fox'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'fox' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': 'fox'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'fox', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]",
            "def test_nested_optional_unions() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'reptile'] = 'lizard'\n    MaybeCatDog = Annotated[Optional[Union[Cat, Dog]], Field(discriminator='pet_type')]\n    MaybeDogLizard = Annotated[Union[Dog, Lizard, None], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: Union[MaybeCatDog, MaybeDogLizard] = Field(discriminator='pet_type')\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    Pet.model_validate({'pet': None})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': None}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'None' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': None}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'None', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'fox'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'fox' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': 'fox'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'fox', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]",
            "def test_nested_optional_unions() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'reptile'] = 'lizard'\n    MaybeCatDog = Annotated[Optional[Union[Cat, Dog]], Field(discriminator='pet_type')]\n    MaybeDogLizard = Annotated[Union[Dog, Lizard, None], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: Union[MaybeCatDog, MaybeDogLizard] = Field(discriminator='pet_type')\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    Pet.model_validate({'pet': None})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': None}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'None' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': None}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'None', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'fox'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'fox' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': 'fox'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'fox', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]",
            "def test_nested_optional_unions() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'reptile'] = 'lizard'\n    MaybeCatDog = Annotated[Optional[Union[Cat, Dog]], Field(discriminator='pet_type')]\n    MaybeDogLizard = Annotated[Union[Dog, Lizard, None], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: Union[MaybeCatDog, MaybeDogLizard] = Field(discriminator='pet_type')\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    Pet.model_validate({'pet': None})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': None}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'None' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': None}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'None', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'fox'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'fox' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': 'fox'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'fox', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]",
            "def test_nested_optional_unions() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = 'dog'\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'reptile'] = 'lizard'\n    MaybeCatDog = Annotated[Optional[Union[Cat, Dog]], Field(discriminator='pet_type')]\n    MaybeDogLizard = Annotated[Union[Dog, Lizard, None], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: Union[MaybeCatDog, MaybeDogLizard] = Field(discriminator='pet_type')\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    Pet.model_validate({'pet': None})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': None}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'None' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': None}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'None', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'fox'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'fox' found using 'pet_type' does not match any of the expected tags: 'cat', 'dog', 'lizard', 'reptile'\", 'input': {'pet_type': 'fox'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'fox', 'expected_tags': \"'cat', 'dog', 'lizard', 'reptile'\"}}]"
        ]
    },
    {
        "func_name": "test_nested_discriminated_union",
        "original": "def test_nested_discriminated_union() -> None:\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'CAT']\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog', 'DOG']\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'LIZARD']\n    CatDog = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n    CatDogLizard = Annotated[Union[CatDog, Lizard], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: CatDogLizard\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'reptile' found using 'pet_type' does not match any of the expected tags: 'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\", 'input': {'pet_type': 'reptile'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'reptile', 'expected_tags': \"'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\"}}]",
        "mutated": [
            "def test_nested_discriminated_union() -> None:\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'CAT']\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog', 'DOG']\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'LIZARD']\n    CatDog = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n    CatDogLizard = Annotated[Union[CatDog, Lizard], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: CatDogLizard\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'reptile' found using 'pet_type' does not match any of the expected tags: 'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\", 'input': {'pet_type': 'reptile'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'reptile', 'expected_tags': \"'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\"}}]",
            "def test_nested_discriminated_union() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'CAT']\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog', 'DOG']\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'LIZARD']\n    CatDog = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n    CatDogLizard = Annotated[Union[CatDog, Lizard], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: CatDogLizard\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'reptile' found using 'pet_type' does not match any of the expected tags: 'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\", 'input': {'pet_type': 'reptile'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'reptile', 'expected_tags': \"'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\"}}]",
            "def test_nested_discriminated_union() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'CAT']\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog', 'DOG']\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'LIZARD']\n    CatDog = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n    CatDogLizard = Annotated[Union[CatDog, Lizard], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: CatDogLizard\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'reptile' found using 'pet_type' does not match any of the expected tags: 'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\", 'input': {'pet_type': 'reptile'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'reptile', 'expected_tags': \"'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\"}}]",
            "def test_nested_discriminated_union() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'CAT']\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog', 'DOG']\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'LIZARD']\n    CatDog = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n    CatDogLizard = Annotated[Union[CatDog, Lizard], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: CatDogLizard\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'reptile' found using 'pet_type' does not match any of the expected tags: 'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\", 'input': {'pet_type': 'reptile'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'reptile', 'expected_tags': \"'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\"}}]",
            "def test_nested_discriminated_union() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'CAT']\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog', 'DOG']\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard', 'LIZARD']\n    CatDog = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n    CatDogLizard = Annotated[Union[CatDog, Lizard], Field(discriminator='pet_type')]\n\n    class Pet(BaseModel):\n        pet: CatDogLizard\n    Pet.model_validate({'pet': {'pet_type': 'dog'}})\n    Pet.model_validate({'pet': {'pet_type': 'cat'}})\n    Pet.model_validate({'pet': {'pet_type': 'lizard'}})\n    with pytest.raises(ValidationError) as exc_info:\n        Pet.model_validate({'pet': {'pet_type': 'reptile'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'reptile' found using 'pet_type' does not match any of the expected tags: 'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\", 'input': {'pet_type': 'reptile'}, 'ctx': {'discriminator': \"'pet_type'\", 'tag': 'reptile', 'expected_tags': \"'cat', 'CAT', 'dog', 'DOG', 'lizard', 'LIZARD'\"}}]"
        ]
    },
    {
        "func_name": "test_unions_of_optionals",
        "original": "def test_unions_of_optionals() -> None:\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard'] = Field(alias='typeOfPet')\n    MaybeCat = Annotated[Union[Cat, None], 'some annotation']\n    MaybeDogLizard = Annotated[Optional[Union[Dog, Lizard]], 'some other annotation']\n\n    class Model(BaseModel):\n        maybe_pet: Union[MaybeCat, MaybeDogLizard] = Field(discriminator='pet_type')\n    assert Model(**{'maybe_pet': None}).maybe_pet is None\n    assert Model(**{'maybe_pet': {'typeOfPet': 'dog', 'd': 'milou'}}).maybe_pet.pet_type == 'dog'\n    assert Model(**{'maybe_pet': {'typeOfPet': 'lizard'}}).maybe_pet.pet_type == 'lizard'",
        "mutated": [
            "def test_unions_of_optionals() -> None:\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard'] = Field(alias='typeOfPet')\n    MaybeCat = Annotated[Union[Cat, None], 'some annotation']\n    MaybeDogLizard = Annotated[Optional[Union[Dog, Lizard]], 'some other annotation']\n\n    class Model(BaseModel):\n        maybe_pet: Union[MaybeCat, MaybeDogLizard] = Field(discriminator='pet_type')\n    assert Model(**{'maybe_pet': None}).maybe_pet is None\n    assert Model(**{'maybe_pet': {'typeOfPet': 'dog', 'd': 'milou'}}).maybe_pet.pet_type == 'dog'\n    assert Model(**{'maybe_pet': {'typeOfPet': 'lizard'}}).maybe_pet.pet_type == 'lizard'",
            "def test_unions_of_optionals() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard'] = Field(alias='typeOfPet')\n    MaybeCat = Annotated[Union[Cat, None], 'some annotation']\n    MaybeDogLizard = Annotated[Optional[Union[Dog, Lizard]], 'some other annotation']\n\n    class Model(BaseModel):\n        maybe_pet: Union[MaybeCat, MaybeDogLizard] = Field(discriminator='pet_type')\n    assert Model(**{'maybe_pet': None}).maybe_pet is None\n    assert Model(**{'maybe_pet': {'typeOfPet': 'dog', 'd': 'milou'}}).maybe_pet.pet_type == 'dog'\n    assert Model(**{'maybe_pet': {'typeOfPet': 'lizard'}}).maybe_pet.pet_type == 'lizard'",
            "def test_unions_of_optionals() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard'] = Field(alias='typeOfPet')\n    MaybeCat = Annotated[Union[Cat, None], 'some annotation']\n    MaybeDogLizard = Annotated[Optional[Union[Dog, Lizard]], 'some other annotation']\n\n    class Model(BaseModel):\n        maybe_pet: Union[MaybeCat, MaybeDogLizard] = Field(discriminator='pet_type')\n    assert Model(**{'maybe_pet': None}).maybe_pet is None\n    assert Model(**{'maybe_pet': {'typeOfPet': 'dog', 'd': 'milou'}}).maybe_pet.pet_type == 'dog'\n    assert Model(**{'maybe_pet': {'typeOfPet': 'lizard'}}).maybe_pet.pet_type == 'lizard'",
            "def test_unions_of_optionals() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard'] = Field(alias='typeOfPet')\n    MaybeCat = Annotated[Union[Cat, None], 'some annotation']\n    MaybeDogLizard = Annotated[Optional[Union[Dog, Lizard]], 'some other annotation']\n\n    class Model(BaseModel):\n        maybe_pet: Union[MaybeCat, MaybeDogLizard] = Field(discriminator='pet_type')\n    assert Model(**{'maybe_pet': None}).maybe_pet is None\n    assert Model(**{'maybe_pet': {'typeOfPet': 'dog', 'd': 'milou'}}).maybe_pet.pet_type == 'dog'\n    assert Model(**{'maybe_pet': {'typeOfPet': 'lizard'}}).maybe_pet.pet_type == 'lizard'",
            "def test_unions_of_optionals() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n        c: str\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n        d: str\n\n    class Lizard(BaseModel):\n        pet_type: Literal['lizard'] = Field(alias='typeOfPet')\n    MaybeCat = Annotated[Union[Cat, None], 'some annotation']\n    MaybeDogLizard = Annotated[Optional[Union[Dog, Lizard]], 'some other annotation']\n\n    class Model(BaseModel):\n        maybe_pet: Union[MaybeCat, MaybeDogLizard] = Field(discriminator='pet_type')\n    assert Model(**{'maybe_pet': None}).maybe_pet is None\n    assert Model(**{'maybe_pet': {'typeOfPet': 'dog', 'd': 'milou'}}).maybe_pet.pet_type == 'dog'\n    assert Model(**{'maybe_pet': {'typeOfPet': 'lizard'}}).maybe_pet.pet_type == 'lizard'"
        ]
    },
    {
        "func_name": "test_union_discriminator_literals",
        "original": "def test_union_discriminator_literals() -> None:\n\n    class Cat(BaseModel):\n        pet_type: Union[Literal['cat'], Literal['CAT']] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog'}}).pet.pet_type == 'dog'\n    assert Model(**{'pet': {'typeOfPet': 'cat'}}).pet.pet_type == 'cat'\n    assert Model(**{'pet': {'typeOfPet': 'CAT'}}).pet.pet_type == 'CAT'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(**{'pet': {'typeOfPet': 'Cat'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'Cat' found using 'pet_type' | 'typeOfPet' does not match any of the expected tags: 'cat', 'CAT', 'dog'\", 'input': {'typeOfPet': 'Cat'}, 'ctx': {'discriminator': \"'pet_type' | 'typeOfPet'\", 'tag': 'Cat', 'expected_tags': \"'cat', 'CAT', 'dog'\"}}]",
        "mutated": [
            "def test_union_discriminator_literals() -> None:\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Union[Literal['cat'], Literal['CAT']] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog'}}).pet.pet_type == 'dog'\n    assert Model(**{'pet': {'typeOfPet': 'cat'}}).pet.pet_type == 'cat'\n    assert Model(**{'pet': {'typeOfPet': 'CAT'}}).pet.pet_type == 'CAT'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(**{'pet': {'typeOfPet': 'Cat'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'Cat' found using 'pet_type' | 'typeOfPet' does not match any of the expected tags: 'cat', 'CAT', 'dog'\", 'input': {'typeOfPet': 'Cat'}, 'ctx': {'discriminator': \"'pet_type' | 'typeOfPet'\", 'tag': 'Cat', 'expected_tags': \"'cat', 'CAT', 'dog'\"}}]",
            "def test_union_discriminator_literals() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Union[Literal['cat'], Literal['CAT']] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog'}}).pet.pet_type == 'dog'\n    assert Model(**{'pet': {'typeOfPet': 'cat'}}).pet.pet_type == 'cat'\n    assert Model(**{'pet': {'typeOfPet': 'CAT'}}).pet.pet_type == 'CAT'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(**{'pet': {'typeOfPet': 'Cat'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'Cat' found using 'pet_type' | 'typeOfPet' does not match any of the expected tags: 'cat', 'CAT', 'dog'\", 'input': {'typeOfPet': 'Cat'}, 'ctx': {'discriminator': \"'pet_type' | 'typeOfPet'\", 'tag': 'Cat', 'expected_tags': \"'cat', 'CAT', 'dog'\"}}]",
            "def test_union_discriminator_literals() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Union[Literal['cat'], Literal['CAT']] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog'}}).pet.pet_type == 'dog'\n    assert Model(**{'pet': {'typeOfPet': 'cat'}}).pet.pet_type == 'cat'\n    assert Model(**{'pet': {'typeOfPet': 'CAT'}}).pet.pet_type == 'CAT'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(**{'pet': {'typeOfPet': 'Cat'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'Cat' found using 'pet_type' | 'typeOfPet' does not match any of the expected tags: 'cat', 'CAT', 'dog'\", 'input': {'typeOfPet': 'Cat'}, 'ctx': {'discriminator': \"'pet_type' | 'typeOfPet'\", 'tag': 'Cat', 'expected_tags': \"'cat', 'CAT', 'dog'\"}}]",
            "def test_union_discriminator_literals() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Union[Literal['cat'], Literal['CAT']] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog'}}).pet.pet_type == 'dog'\n    assert Model(**{'pet': {'typeOfPet': 'cat'}}).pet.pet_type == 'cat'\n    assert Model(**{'pet': {'typeOfPet': 'CAT'}}).pet.pet_type == 'CAT'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(**{'pet': {'typeOfPet': 'Cat'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'Cat' found using 'pet_type' | 'typeOfPet' does not match any of the expected tags: 'cat', 'CAT', 'dog'\", 'input': {'typeOfPet': 'Cat'}, 'ctx': {'discriminator': \"'pet_type' | 'typeOfPet'\", 'tag': 'Cat', 'expected_tags': \"'cat', 'CAT', 'dog'\"}}]",
            "def test_union_discriminator_literals() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Union[Literal['cat'], Literal['CAT']] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n    assert Model(**{'pet': {'typeOfPet': 'dog'}}).pet.pet_type == 'dog'\n    assert Model(**{'pet': {'typeOfPet': 'cat'}}).pet.pet_type == 'cat'\n    assert Model(**{'pet': {'typeOfPet': 'CAT'}}).pet.pet_type == 'CAT'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(**{'pet': {'typeOfPet': 'Cat'}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'union_tag_invalid', 'loc': ('pet',), 'msg': \"Input tag 'Cat' found using 'pet_type' | 'typeOfPet' does not match any of the expected tags: 'cat', 'CAT', 'dog'\", 'input': {'typeOfPet': 'Cat'}, 'ctx': {'discriminator': \"'pet_type' | 'typeOfPet'\", 'tag': 'Cat', 'expected_tags': \"'cat', 'CAT', 'dog'\"}}]"
        ]
    },
    {
        "func_name": "test_none_schema",
        "original": "def test_none_schema() -> None:\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog, core_schema.none_schema()])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
        "mutated": [
            "def test_none_schema() -> None:\n    if False:\n        i = 10\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog, core_schema.none_schema()])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_none_schema() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog, core_schema.none_schema()])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_none_schema() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog, core_schema.none_schema()])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_none_schema() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog, core_schema.none_schema()])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_none_schema() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog, core_schema.none_schema()])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]"
        ]
    },
    {
        "func_name": "test_nested_unwrapping",
        "original": "def test_nested_unwrapping() -> None:\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    for _ in range(3):\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.definitions_schema(schema, [])\n        schema = core_schema.definitions_schema(schema, [])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
        "mutated": [
            "def test_nested_unwrapping() -> None:\n    if False:\n        i = 10\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    for _ in range(3):\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.definitions_schema(schema, [])\n        schema = core_schema.definitions_schema(schema, [])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_nested_unwrapping() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    for _ in range(3):\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.definitions_schema(schema, [])\n        schema = core_schema.definitions_schema(schema, [])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_nested_unwrapping() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    for _ in range(3):\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.definitions_schema(schema, [])\n        schema = core_schema.definitions_schema(schema, [])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_nested_unwrapping() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    for _ in range(3):\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.definitions_schema(schema, [])\n        schema = core_schema.definitions_schema(schema, [])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_nested_unwrapping() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    for _ in range(3):\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.nullable_schema(schema)\n        schema = core_schema.definitions_schema(schema, [])\n        schema = core_schema.definitions_schema(schema, [])\n    schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(schema)\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python({'kind': 'dog'})['kind'] == 'dog'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'cat', 'dog'\", 'tag': 'lizard'}, 'input': {'kind': 'lizard'}, 'loc': (), 'msg': \"Input tag 'lizard' found using 'kind' does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]"
        ]
    },
    {
        "func_name": "test_distinct_choices",
        "original": "def test_distinct_choices() -> None:\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'dog'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"Value 'dog' for discriminator 'pet_type' mapped to multiple choices\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
        "mutated": [
            "def test_distinct_choices() -> None:\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'dog'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"Value 'dog' for discriminator 'pet_type' mapped to multiple choices\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
            "def test_distinct_choices() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'dog'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"Value 'dog' for discriminator 'pet_type' mapped to multiple choices\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
            "def test_distinct_choices() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'dog'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"Value 'dog' for discriminator 'pet_type' mapped to multiple choices\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
            "def test_distinct_choices() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'dog'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"Value 'dog' for discriminator 'pet_type' mapped to multiple choices\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')",
            "def test_distinct_choices() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat', 'dog'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"Value 'dog' for discriminator 'pet_type' mapped to multiple choices\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog] = Field(discriminator='pet_type')"
        ]
    },
    {
        "func_name": "test_invalid_discriminated_union_type",
        "original": "def test_invalid_discriminated_union_type() -> None:\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog, str] = Field(discriminator='pet_type')",
        "mutated": [
            "def test_invalid_discriminated_union_type() -> None:\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog, str] = Field(discriminator='pet_type')",
            "def test_invalid_discriminated_union_type() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog, str] = Field(discriminator='pet_type')",
            "def test_invalid_discriminated_union_type() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog, str] = Field(discriminator='pet_type')",
            "def test_invalid_discriminated_union_type() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog, str] = Field(discriminator='pet_type')",
            "def test_invalid_discriminated_union_type() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = Field(alias='typeOfPet')\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog'] = Field(alias='typeOfPet')\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n\n        class Model(BaseModel):\n            pet: Union[Cat, Dog, str] = Field(discriminator='pet_type')"
        ]
    },
    {
        "func_name": "test_invalid_alias",
        "original": "def test_invalid_alias() -> None:\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']), validation_alias=['cat', 'CAT'])}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    with pytest.raises(TypeError, match=re.escape(\"Alias ['cat', 'CAT'] is not supported in a discriminated union\")):\n        apply_discriminator(schema, 'kind')",
        "mutated": [
            "def test_invalid_alias() -> None:\n    if False:\n        i = 10\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']), validation_alias=['cat', 'CAT'])}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    with pytest.raises(TypeError, match=re.escape(\"Alias ['cat', 'CAT'] is not supported in a discriminated union\")):\n        apply_discriminator(schema, 'kind')",
            "def test_invalid_alias() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']), validation_alias=['cat', 'CAT'])}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    with pytest.raises(TypeError, match=re.escape(\"Alias ['cat', 'CAT'] is not supported in a discriminated union\")):\n        apply_discriminator(schema, 'kind')",
            "def test_invalid_alias() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']), validation_alias=['cat', 'CAT'])}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    with pytest.raises(TypeError, match=re.escape(\"Alias ['cat', 'CAT'] is not supported in a discriminated union\")):\n        apply_discriminator(schema, 'kind')",
            "def test_invalid_alias() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']), validation_alias=['cat', 'CAT'])}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    with pytest.raises(TypeError, match=re.escape(\"Alias ['cat', 'CAT'] is not supported in a discriminated union\")):\n        apply_discriminator(schema, 'kind')",
            "def test_invalid_alias() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']), validation_alias=['cat', 'CAT'])}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    with pytest.raises(TypeError, match=re.escape(\"Alias ['cat', 'CAT'] is not supported in a discriminated union\")):\n        apply_discriminator(schema, 'kind')"
        ]
    },
    {
        "func_name": "test_invalid_discriminator_type",
        "original": "def test_invalid_discriminator_type() -> None:\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.str_schema())}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs field 'kind' to be of type `Literal`\")):\n        apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')",
        "mutated": [
            "def test_invalid_discriminator_type() -> None:\n    if False:\n        i = 10\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.str_schema())}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs field 'kind' to be of type `Literal`\")):\n        apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')",
            "def test_invalid_discriminator_type() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.str_schema())}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs field 'kind' to be of type `Literal`\")):\n        apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')",
            "def test_invalid_discriminator_type() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.str_schema())}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs field 'kind' to be of type `Literal`\")):\n        apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')",
            "def test_invalid_discriminator_type() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.str_schema())}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs field 'kind' to be of type `Literal`\")):\n        apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')",
            "def test_invalid_discriminator_type() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.str_schema())}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs field 'kind' to be of type `Literal`\")):\n        apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')"
        ]
    },
    {
        "func_name": "test_missing_discriminator_field",
        "original": "def test_missing_discriminator_field() -> None:\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs a discriminator field for key 'kind'\")):\n        apply_discriminator(core_schema.union_schema([dog, cat]), 'kind')",
        "mutated": [
            "def test_missing_discriminator_field() -> None:\n    if False:\n        i = 10\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs a discriminator field for key 'kind'\")):\n        apply_discriminator(core_schema.union_schema([dog, cat]), 'kind')",
            "def test_missing_discriminator_field() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs a discriminator field for key 'kind'\")):\n        apply_discriminator(core_schema.union_schema([dog, cat]), 'kind')",
            "def test_missing_discriminator_field() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs a discriminator field for key 'kind'\")):\n        apply_discriminator(core_schema.union_schema([dog, cat]), 'kind')",
            "def test_missing_discriminator_field() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs a discriminator field for key 'kind'\")):\n        apply_discriminator(core_schema.union_schema([dog, cat]), 'kind')",
            "def test_missing_discriminator_field() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.int_schema())}\n    dog_fields = {}\n    cat = core_schema.typed_dict_schema(cat_fields)\n    dog = core_schema.typed_dict_schema(dog_fields)\n    with pytest.raises(TypeError, match=re.escape(\"TypedDict needs a discriminator field for key 'kind'\")):\n        apply_discriminator(core_schema.union_schema([dog, cat]), 'kind')"
        ]
    },
    {
        "func_name": "test_wrap_function_schema",
        "original": "def test_wrap_function_schema() -> None:\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.with_info_wrap_validator_function(lambda x, y, z: None, core_schema.typed_dict_schema(cat_fields))\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    assert apply_discriminator(schema, 'kind') == {'choices': {'cat': {'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'fields': {'kind': {'schema': {'expected': ['cat'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}, 'type': 'function-wrap'}, 'dog': {'fields': {'kind': {'schema': {'expected': ['dog'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}}, 'discriminator': 'kind', 'from_attributes': True, 'strict': False, 'type': 'tagged-union'}",
        "mutated": [
            "def test_wrap_function_schema() -> None:\n    if False:\n        i = 10\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.with_info_wrap_validator_function(lambda x, y, z: None, core_schema.typed_dict_schema(cat_fields))\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    assert apply_discriminator(schema, 'kind') == {'choices': {'cat': {'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'fields': {'kind': {'schema': {'expected': ['cat'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}, 'type': 'function-wrap'}, 'dog': {'fields': {'kind': {'schema': {'expected': ['dog'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}}, 'discriminator': 'kind', 'from_attributes': True, 'strict': False, 'type': 'tagged-union'}",
            "def test_wrap_function_schema() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.with_info_wrap_validator_function(lambda x, y, z: None, core_schema.typed_dict_schema(cat_fields))\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    assert apply_discriminator(schema, 'kind') == {'choices': {'cat': {'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'fields': {'kind': {'schema': {'expected': ['cat'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}, 'type': 'function-wrap'}, 'dog': {'fields': {'kind': {'schema': {'expected': ['dog'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}}, 'discriminator': 'kind', 'from_attributes': True, 'strict': False, 'type': 'tagged-union'}",
            "def test_wrap_function_schema() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.with_info_wrap_validator_function(lambda x, y, z: None, core_schema.typed_dict_schema(cat_fields))\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    assert apply_discriminator(schema, 'kind') == {'choices': {'cat': {'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'fields': {'kind': {'schema': {'expected': ['cat'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}, 'type': 'function-wrap'}, 'dog': {'fields': {'kind': {'schema': {'expected': ['dog'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}}, 'discriminator': 'kind', 'from_attributes': True, 'strict': False, 'type': 'tagged-union'}",
            "def test_wrap_function_schema() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.with_info_wrap_validator_function(lambda x, y, z: None, core_schema.typed_dict_schema(cat_fields))\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    assert apply_discriminator(schema, 'kind') == {'choices': {'cat': {'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'fields': {'kind': {'schema': {'expected': ['cat'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}, 'type': 'function-wrap'}, 'dog': {'fields': {'kind': {'schema': {'expected': ['dog'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}}, 'discriminator': 'kind', 'from_attributes': True, 'strict': False, 'type': 'tagged-union'}",
            "def test_wrap_function_schema() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cat_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))}\n    dog_fields = {'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}\n    cat = core_schema.with_info_wrap_validator_function(lambda x, y, z: None, core_schema.typed_dict_schema(cat_fields))\n    dog = core_schema.typed_dict_schema(dog_fields)\n    schema = core_schema.union_schema([cat, dog])\n    assert apply_discriminator(schema, 'kind') == {'choices': {'cat': {'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'fields': {'kind': {'schema': {'expected': ['cat'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}, 'type': 'function-wrap'}, 'dog': {'fields': {'kind': {'schema': {'expected': ['dog'], 'type': 'literal'}, 'type': 'typed-dict-field'}}, 'type': 'typed-dict'}}, 'discriminator': 'kind', 'from_attributes': True, 'strict': False, 'type': 'tagged-union'}"
        ]
    },
    {
        "func_name": "test_plain_function_schema_is_invalid",
        "original": "def test_plain_function_schema_is_invalid() -> None:\n    with pytest.raises(TypeError, match=\"'function-plain' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(core_schema.union_schema([core_schema.with_info_plain_validator_function(lambda x, y: None), core_schema.int_schema()]), 'kind')",
        "mutated": [
            "def test_plain_function_schema_is_invalid() -> None:\n    if False:\n        i = 10\n    with pytest.raises(TypeError, match=\"'function-plain' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(core_schema.union_schema([core_schema.with_info_plain_validator_function(lambda x, y: None), core_schema.int_schema()]), 'kind')",
            "def test_plain_function_schema_is_invalid() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with pytest.raises(TypeError, match=\"'function-plain' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(core_schema.union_schema([core_schema.with_info_plain_validator_function(lambda x, y: None), core_schema.int_schema()]), 'kind')",
            "def test_plain_function_schema_is_invalid() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with pytest.raises(TypeError, match=\"'function-plain' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(core_schema.union_schema([core_schema.with_info_plain_validator_function(lambda x, y: None), core_schema.int_schema()]), 'kind')",
            "def test_plain_function_schema_is_invalid() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with pytest.raises(TypeError, match=\"'function-plain' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(core_schema.union_schema([core_schema.with_info_plain_validator_function(lambda x, y: None), core_schema.int_schema()]), 'kind')",
            "def test_plain_function_schema_is_invalid() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with pytest.raises(TypeError, match=\"'function-plain' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(core_schema.union_schema([core_schema.with_info_plain_validator_function(lambda x, y: None), core_schema.int_schema()]), 'kind')"
        ]
    },
    {
        "func_name": "test_invalid_str_choice_discriminator_values",
        "original": "def test_invalid_str_choice_discriminator_values() -> None:\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.str_schema()\n    schema = core_schema.union_schema([cat, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, dog)])\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(schema, 'kind')",
        "mutated": [
            "def test_invalid_str_choice_discriminator_values() -> None:\n    if False:\n        i = 10\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.str_schema()\n    schema = core_schema.union_schema([cat, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, dog)])\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(schema, 'kind')",
            "def test_invalid_str_choice_discriminator_values() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.str_schema()\n    schema = core_schema.union_schema([cat, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, dog)])\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(schema, 'kind')",
            "def test_invalid_str_choice_discriminator_values() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.str_schema()\n    schema = core_schema.union_schema([cat, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, dog)])\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(schema, 'kind')",
            "def test_invalid_str_choice_discriminator_values() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.str_schema()\n    schema = core_schema.union_schema([cat, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, dog)])\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(schema, 'kind')",
            "def test_invalid_str_choice_discriminator_values() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.str_schema()\n    schema = core_schema.union_schema([cat, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, dog)])\n    with pytest.raises(TypeError, match=\"'str' is not a valid discriminated union variant; should be a `BaseModel` or `dataclass`\"):\n        apply_discriminator(schema, 'kind')"
        ]
    },
    {
        "func_name": "test_lax_or_strict_definitions",
        "original": "def test_lax_or_strict_definitions() -> None:\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    lax_dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['DOG']))})\n    strict_dog = core_schema.definitions_schema(core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}), [core_schema.int_schema(ref='my-int-definition')])\n    dog = core_schema.definitions_schema(core_schema.lax_or_strict_schema(lax_schema=lax_dog, strict_schema=strict_dog), [core_schema.str_schema(ref='my-str-definition')])\n    discriminated_schema = apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')\n    assert discriminated_schema == {'type': 'definitions', 'schema': {'type': 'tagged-union', 'choices': {'cat': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, 'DOG': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}, 'dog': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}, 'definitions': [{'type': 'str', 'ref': 'my-str-definition'}]}",
        "mutated": [
            "def test_lax_or_strict_definitions() -> None:\n    if False:\n        i = 10\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    lax_dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['DOG']))})\n    strict_dog = core_schema.definitions_schema(core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}), [core_schema.int_schema(ref='my-int-definition')])\n    dog = core_schema.definitions_schema(core_schema.lax_or_strict_schema(lax_schema=lax_dog, strict_schema=strict_dog), [core_schema.str_schema(ref='my-str-definition')])\n    discriminated_schema = apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')\n    assert discriminated_schema == {'type': 'definitions', 'schema': {'type': 'tagged-union', 'choices': {'cat': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, 'DOG': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}, 'dog': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}, 'definitions': [{'type': 'str', 'ref': 'my-str-definition'}]}",
            "def test_lax_or_strict_definitions() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    lax_dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['DOG']))})\n    strict_dog = core_schema.definitions_schema(core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}), [core_schema.int_schema(ref='my-int-definition')])\n    dog = core_schema.definitions_schema(core_schema.lax_or_strict_schema(lax_schema=lax_dog, strict_schema=strict_dog), [core_schema.str_schema(ref='my-str-definition')])\n    discriminated_schema = apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')\n    assert discriminated_schema == {'type': 'definitions', 'schema': {'type': 'tagged-union', 'choices': {'cat': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, 'DOG': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}, 'dog': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}, 'definitions': [{'type': 'str', 'ref': 'my-str-definition'}]}",
            "def test_lax_or_strict_definitions() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    lax_dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['DOG']))})\n    strict_dog = core_schema.definitions_schema(core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}), [core_schema.int_schema(ref='my-int-definition')])\n    dog = core_schema.definitions_schema(core_schema.lax_or_strict_schema(lax_schema=lax_dog, strict_schema=strict_dog), [core_schema.str_schema(ref='my-str-definition')])\n    discriminated_schema = apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')\n    assert discriminated_schema == {'type': 'definitions', 'schema': {'type': 'tagged-union', 'choices': {'cat': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, 'DOG': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}, 'dog': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}, 'definitions': [{'type': 'str', 'ref': 'my-str-definition'}]}",
            "def test_lax_or_strict_definitions() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    lax_dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['DOG']))})\n    strict_dog = core_schema.definitions_schema(core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}), [core_schema.int_schema(ref='my-int-definition')])\n    dog = core_schema.definitions_schema(core_schema.lax_or_strict_schema(lax_schema=lax_dog, strict_schema=strict_dog), [core_schema.str_schema(ref='my-str-definition')])\n    discriminated_schema = apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')\n    assert discriminated_schema == {'type': 'definitions', 'schema': {'type': 'tagged-union', 'choices': {'cat': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, 'DOG': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}, 'dog': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}, 'definitions': [{'type': 'str', 'ref': 'my-str-definition'}]}",
            "def test_lax_or_strict_definitions() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    lax_dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['DOG']))})\n    strict_dog = core_schema.definitions_schema(core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))}), [core_schema.int_schema(ref='my-int-definition')])\n    dog = core_schema.definitions_schema(core_schema.lax_or_strict_schema(lax_schema=lax_dog, strict_schema=strict_dog), [core_schema.str_schema(ref='my-str-definition')])\n    discriminated_schema = apply_discriminator(core_schema.union_schema([cat, dog]), 'kind')\n    assert discriminated_schema == {'type': 'definitions', 'schema': {'type': 'tagged-union', 'choices': {'cat': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, 'DOG': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}, 'dog': {'type': 'lax-or-strict', 'lax_schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['DOG']}}}}, 'strict_schema': {'type': 'definitions', 'schema': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}, 'definitions': [{'type': 'int', 'ref': 'my-int-definition'}]}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}, 'definitions': [{'type': 'str', 'ref': 'my-str-definition'}]}"
        ]
    },
    {
        "func_name": "test_wrapped_nullable_union",
        "original": "def test_wrapped_nullable_union() -> None:\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))})\n    ant = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['ant']))})\n    schema = core_schema.union_schema([ant, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, core_schema.nullable_schema(core_schema.union_schema([cat, dog])))])\n    discriminated_schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(discriminated_schema)\n    assert validator.validate_python({'kind': 'ant'})['kind'] == 'ant'\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'armadillo'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'ant', 'cat', 'dog'\", 'tag': 'armadillo'}, 'input': {'kind': 'armadillo'}, 'loc': (), 'msg': \"Input tag 'armadillo' found using 'kind' does not match any of the expected tags: 'ant', 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    assert discriminated_schema == {'type': 'nullable', 'schema': {'type': 'tagged-union', 'choices': {'ant': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['ant']}}}}, 'cat': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}, 'dog': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}}",
        "mutated": [
            "def test_wrapped_nullable_union() -> None:\n    if False:\n        i = 10\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))})\n    ant = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['ant']))})\n    schema = core_schema.union_schema([ant, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, core_schema.nullable_schema(core_schema.union_schema([cat, dog])))])\n    discriminated_schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(discriminated_schema)\n    assert validator.validate_python({'kind': 'ant'})['kind'] == 'ant'\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'armadillo'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'ant', 'cat', 'dog'\", 'tag': 'armadillo'}, 'input': {'kind': 'armadillo'}, 'loc': (), 'msg': \"Input tag 'armadillo' found using 'kind' does not match any of the expected tags: 'ant', 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    assert discriminated_schema == {'type': 'nullable', 'schema': {'type': 'tagged-union', 'choices': {'ant': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['ant']}}}}, 'cat': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}, 'dog': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}}",
            "def test_wrapped_nullable_union() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))})\n    ant = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['ant']))})\n    schema = core_schema.union_schema([ant, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, core_schema.nullable_schema(core_schema.union_schema([cat, dog])))])\n    discriminated_schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(discriminated_schema)\n    assert validator.validate_python({'kind': 'ant'})['kind'] == 'ant'\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'armadillo'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'ant', 'cat', 'dog'\", 'tag': 'armadillo'}, 'input': {'kind': 'armadillo'}, 'loc': (), 'msg': \"Input tag 'armadillo' found using 'kind' does not match any of the expected tags: 'ant', 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    assert discriminated_schema == {'type': 'nullable', 'schema': {'type': 'tagged-union', 'choices': {'ant': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['ant']}}}}, 'cat': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}, 'dog': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}}",
            "def test_wrapped_nullable_union() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))})\n    ant = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['ant']))})\n    schema = core_schema.union_schema([ant, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, core_schema.nullable_schema(core_schema.union_schema([cat, dog])))])\n    discriminated_schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(discriminated_schema)\n    assert validator.validate_python({'kind': 'ant'})['kind'] == 'ant'\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'armadillo'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'ant', 'cat', 'dog'\", 'tag': 'armadillo'}, 'input': {'kind': 'armadillo'}, 'loc': (), 'msg': \"Input tag 'armadillo' found using 'kind' does not match any of the expected tags: 'ant', 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    assert discriminated_schema == {'type': 'nullable', 'schema': {'type': 'tagged-union', 'choices': {'ant': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['ant']}}}}, 'cat': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}, 'dog': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}}",
            "def test_wrapped_nullable_union() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))})\n    ant = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['ant']))})\n    schema = core_schema.union_schema([ant, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, core_schema.nullable_schema(core_schema.union_schema([cat, dog])))])\n    discriminated_schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(discriminated_schema)\n    assert validator.validate_python({'kind': 'ant'})['kind'] == 'ant'\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'armadillo'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'ant', 'cat', 'dog'\", 'tag': 'armadillo'}, 'input': {'kind': 'armadillo'}, 'loc': (), 'msg': \"Input tag 'armadillo' found using 'kind' does not match any of the expected tags: 'ant', 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    assert discriminated_schema == {'type': 'nullable', 'schema': {'type': 'tagged-union', 'choices': {'ant': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['ant']}}}}, 'cat': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}, 'dog': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}}",
            "def test_wrapped_nullable_union() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cat = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['cat']))})\n    dog = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['dog']))})\n    ant = core_schema.typed_dict_schema({'kind': core_schema.typed_dict_field(core_schema.literal_schema(['ant']))})\n    schema = core_schema.union_schema([ant, core_schema.with_info_wrap_validator_function(lambda x, y, z: x, core_schema.nullable_schema(core_schema.union_schema([cat, dog])))])\n    discriminated_schema = apply_discriminator(schema, 'kind')\n    validator = SchemaValidator(discriminated_schema)\n    assert validator.validate_python({'kind': 'ant'})['kind'] == 'ant'\n    assert validator.validate_python({'kind': 'cat'})['kind'] == 'cat'\n    assert validator.validate_python(None) is None\n    with pytest.raises(ValidationError) as exc_info:\n        validator.validate_python({'kind': 'armadillo'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'kind'\", 'expected_tags': \"'ant', 'cat', 'dog'\", 'tag': 'armadillo'}, 'input': {'kind': 'armadillo'}, 'loc': (), 'msg': \"Input tag 'armadillo' found using 'kind' does not match any of the expected tags: 'ant', 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    assert discriminated_schema == {'type': 'nullable', 'schema': {'type': 'tagged-union', 'choices': {'ant': {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['ant']}}}}, 'cat': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}, 'dog': {'type': 'function-wrap', 'function': {'type': 'with-info', 'function': HasRepr(IsStr(regex='<function [a-z_]*\\\\.<locals>\\\\.<lambda> at 0x[0-9a-fA-F]+>'))}, 'schema': {'type': 'nullable', 'schema': {'type': 'union', 'choices': [{'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['cat']}}}}, {'type': 'typed-dict', 'fields': {'kind': {'type': 'typed-dict-field', 'schema': {'type': 'literal', 'expected': ['dog']}}}}]}}}}, 'discriminator': 'kind', 'strict': False, 'from_attributes': True}}"
        ]
    },
    {
        "func_name": "test_union_in_submodel",
        "original": "def test_union_in_submodel() -> None:\n\n    class UnionModel1(BaseModel):\n        type: Literal[1] = 1\n        other: Literal['UnionModel1'] = 'UnionModel1'\n\n    class UnionModel2(BaseModel):\n        type: Literal[2] = 2\n        other: Literal['UnionModel2'] = 'UnionModel2'\n    UnionModel = Annotated[Union[UnionModel1, UnionModel2], Field(discriminator='type')]\n\n    class SubModel1(BaseModel):\n        union_model: UnionModel\n\n    class SubModel2(BaseModel):\n        union_model: UnionModel\n\n    class TestModel(BaseModel):\n        submodel: Union[SubModel1, SubModel2]\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 1}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel1)\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 2}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel2)\n    with pytest.raises(ValidationError) as exc_info:\n        TestModel.model_validate({'submodel': {'union_model': {'type': 1, 'other': 'UnionModel2'}}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'literal_error', 'loc': ('submodel', 'SubModel1', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}, {'type': 'literal_error', 'loc': ('submodel', 'SubModel2', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}]\n    assert TestModel.model_json_schema() == {'$defs': {'SubModel1': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel1', 'type': 'object'}, 'SubModel2': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel2', 'type': 'object'}, 'UnionModel1': {'properties': {'type': {'const': 1, 'default': 1, 'title': 'Type'}, 'other': {'const': 'UnionModel1', 'default': 'UnionModel1', 'title': 'Other'}}, 'title': 'UnionModel1', 'type': 'object'}, 'UnionModel2': {'properties': {'type': {'const': 2, 'default': 2, 'title': 'Type'}, 'other': {'const': 'UnionModel2', 'default': 'UnionModel2', 'title': 'Other'}}, 'title': 'UnionModel2', 'type': 'object'}}, 'properties': {'submodel': {'anyOf': [{'$ref': '#/$defs/SubModel1'}, {'$ref': '#/$defs/SubModel2'}], 'title': 'Submodel'}}, 'required': ['submodel'], 'title': 'TestModel', 'type': 'object'}",
        "mutated": [
            "def test_union_in_submodel() -> None:\n    if False:\n        i = 10\n\n    class UnionModel1(BaseModel):\n        type: Literal[1] = 1\n        other: Literal['UnionModel1'] = 'UnionModel1'\n\n    class UnionModel2(BaseModel):\n        type: Literal[2] = 2\n        other: Literal['UnionModel2'] = 'UnionModel2'\n    UnionModel = Annotated[Union[UnionModel1, UnionModel2], Field(discriminator='type')]\n\n    class SubModel1(BaseModel):\n        union_model: UnionModel\n\n    class SubModel2(BaseModel):\n        union_model: UnionModel\n\n    class TestModel(BaseModel):\n        submodel: Union[SubModel1, SubModel2]\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 1}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel1)\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 2}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel2)\n    with pytest.raises(ValidationError) as exc_info:\n        TestModel.model_validate({'submodel': {'union_model': {'type': 1, 'other': 'UnionModel2'}}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'literal_error', 'loc': ('submodel', 'SubModel1', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}, {'type': 'literal_error', 'loc': ('submodel', 'SubModel2', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}]\n    assert TestModel.model_json_schema() == {'$defs': {'SubModel1': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel1', 'type': 'object'}, 'SubModel2': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel2', 'type': 'object'}, 'UnionModel1': {'properties': {'type': {'const': 1, 'default': 1, 'title': 'Type'}, 'other': {'const': 'UnionModel1', 'default': 'UnionModel1', 'title': 'Other'}}, 'title': 'UnionModel1', 'type': 'object'}, 'UnionModel2': {'properties': {'type': {'const': 2, 'default': 2, 'title': 'Type'}, 'other': {'const': 'UnionModel2', 'default': 'UnionModel2', 'title': 'Other'}}, 'title': 'UnionModel2', 'type': 'object'}}, 'properties': {'submodel': {'anyOf': [{'$ref': '#/$defs/SubModel1'}, {'$ref': '#/$defs/SubModel2'}], 'title': 'Submodel'}}, 'required': ['submodel'], 'title': 'TestModel', 'type': 'object'}",
            "def test_union_in_submodel() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class UnionModel1(BaseModel):\n        type: Literal[1] = 1\n        other: Literal['UnionModel1'] = 'UnionModel1'\n\n    class UnionModel2(BaseModel):\n        type: Literal[2] = 2\n        other: Literal['UnionModel2'] = 'UnionModel2'\n    UnionModel = Annotated[Union[UnionModel1, UnionModel2], Field(discriminator='type')]\n\n    class SubModel1(BaseModel):\n        union_model: UnionModel\n\n    class SubModel2(BaseModel):\n        union_model: UnionModel\n\n    class TestModel(BaseModel):\n        submodel: Union[SubModel1, SubModel2]\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 1}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel1)\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 2}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel2)\n    with pytest.raises(ValidationError) as exc_info:\n        TestModel.model_validate({'submodel': {'union_model': {'type': 1, 'other': 'UnionModel2'}}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'literal_error', 'loc': ('submodel', 'SubModel1', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}, {'type': 'literal_error', 'loc': ('submodel', 'SubModel2', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}]\n    assert TestModel.model_json_schema() == {'$defs': {'SubModel1': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel1', 'type': 'object'}, 'SubModel2': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel2', 'type': 'object'}, 'UnionModel1': {'properties': {'type': {'const': 1, 'default': 1, 'title': 'Type'}, 'other': {'const': 'UnionModel1', 'default': 'UnionModel1', 'title': 'Other'}}, 'title': 'UnionModel1', 'type': 'object'}, 'UnionModel2': {'properties': {'type': {'const': 2, 'default': 2, 'title': 'Type'}, 'other': {'const': 'UnionModel2', 'default': 'UnionModel2', 'title': 'Other'}}, 'title': 'UnionModel2', 'type': 'object'}}, 'properties': {'submodel': {'anyOf': [{'$ref': '#/$defs/SubModel1'}, {'$ref': '#/$defs/SubModel2'}], 'title': 'Submodel'}}, 'required': ['submodel'], 'title': 'TestModel', 'type': 'object'}",
            "def test_union_in_submodel() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class UnionModel1(BaseModel):\n        type: Literal[1] = 1\n        other: Literal['UnionModel1'] = 'UnionModel1'\n\n    class UnionModel2(BaseModel):\n        type: Literal[2] = 2\n        other: Literal['UnionModel2'] = 'UnionModel2'\n    UnionModel = Annotated[Union[UnionModel1, UnionModel2], Field(discriminator='type')]\n\n    class SubModel1(BaseModel):\n        union_model: UnionModel\n\n    class SubModel2(BaseModel):\n        union_model: UnionModel\n\n    class TestModel(BaseModel):\n        submodel: Union[SubModel1, SubModel2]\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 1}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel1)\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 2}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel2)\n    with pytest.raises(ValidationError) as exc_info:\n        TestModel.model_validate({'submodel': {'union_model': {'type': 1, 'other': 'UnionModel2'}}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'literal_error', 'loc': ('submodel', 'SubModel1', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}, {'type': 'literal_error', 'loc': ('submodel', 'SubModel2', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}]\n    assert TestModel.model_json_schema() == {'$defs': {'SubModel1': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel1', 'type': 'object'}, 'SubModel2': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel2', 'type': 'object'}, 'UnionModel1': {'properties': {'type': {'const': 1, 'default': 1, 'title': 'Type'}, 'other': {'const': 'UnionModel1', 'default': 'UnionModel1', 'title': 'Other'}}, 'title': 'UnionModel1', 'type': 'object'}, 'UnionModel2': {'properties': {'type': {'const': 2, 'default': 2, 'title': 'Type'}, 'other': {'const': 'UnionModel2', 'default': 'UnionModel2', 'title': 'Other'}}, 'title': 'UnionModel2', 'type': 'object'}}, 'properties': {'submodel': {'anyOf': [{'$ref': '#/$defs/SubModel1'}, {'$ref': '#/$defs/SubModel2'}], 'title': 'Submodel'}}, 'required': ['submodel'], 'title': 'TestModel', 'type': 'object'}",
            "def test_union_in_submodel() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class UnionModel1(BaseModel):\n        type: Literal[1] = 1\n        other: Literal['UnionModel1'] = 'UnionModel1'\n\n    class UnionModel2(BaseModel):\n        type: Literal[2] = 2\n        other: Literal['UnionModel2'] = 'UnionModel2'\n    UnionModel = Annotated[Union[UnionModel1, UnionModel2], Field(discriminator='type')]\n\n    class SubModel1(BaseModel):\n        union_model: UnionModel\n\n    class SubModel2(BaseModel):\n        union_model: UnionModel\n\n    class TestModel(BaseModel):\n        submodel: Union[SubModel1, SubModel2]\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 1}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel1)\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 2}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel2)\n    with pytest.raises(ValidationError) as exc_info:\n        TestModel.model_validate({'submodel': {'union_model': {'type': 1, 'other': 'UnionModel2'}}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'literal_error', 'loc': ('submodel', 'SubModel1', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}, {'type': 'literal_error', 'loc': ('submodel', 'SubModel2', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}]\n    assert TestModel.model_json_schema() == {'$defs': {'SubModel1': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel1', 'type': 'object'}, 'SubModel2': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel2', 'type': 'object'}, 'UnionModel1': {'properties': {'type': {'const': 1, 'default': 1, 'title': 'Type'}, 'other': {'const': 'UnionModel1', 'default': 'UnionModel1', 'title': 'Other'}}, 'title': 'UnionModel1', 'type': 'object'}, 'UnionModel2': {'properties': {'type': {'const': 2, 'default': 2, 'title': 'Type'}, 'other': {'const': 'UnionModel2', 'default': 'UnionModel2', 'title': 'Other'}}, 'title': 'UnionModel2', 'type': 'object'}}, 'properties': {'submodel': {'anyOf': [{'$ref': '#/$defs/SubModel1'}, {'$ref': '#/$defs/SubModel2'}], 'title': 'Submodel'}}, 'required': ['submodel'], 'title': 'TestModel', 'type': 'object'}",
            "def test_union_in_submodel() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class UnionModel1(BaseModel):\n        type: Literal[1] = 1\n        other: Literal['UnionModel1'] = 'UnionModel1'\n\n    class UnionModel2(BaseModel):\n        type: Literal[2] = 2\n        other: Literal['UnionModel2'] = 'UnionModel2'\n    UnionModel = Annotated[Union[UnionModel1, UnionModel2], Field(discriminator='type')]\n\n    class SubModel1(BaseModel):\n        union_model: UnionModel\n\n    class SubModel2(BaseModel):\n        union_model: UnionModel\n\n    class TestModel(BaseModel):\n        submodel: Union[SubModel1, SubModel2]\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 1}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel1)\n    m = TestModel.model_validate({'submodel': {'union_model': {'type': 2}}})\n    assert isinstance(m.submodel, SubModel1)\n    assert isinstance(m.submodel.union_model, UnionModel2)\n    with pytest.raises(ValidationError) as exc_info:\n        TestModel.model_validate({'submodel': {'union_model': {'type': 1, 'other': 'UnionModel2'}}})\n    assert exc_info.value.errors(include_url=False) == [{'type': 'literal_error', 'loc': ('submodel', 'SubModel1', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}, {'type': 'literal_error', 'loc': ('submodel', 'SubModel2', 'union_model', 1, 'other'), 'msg': \"Input should be 'UnionModel1'\", 'input': 'UnionModel2', 'ctx': {'expected': \"'UnionModel1'\"}}]\n    assert TestModel.model_json_schema() == {'$defs': {'SubModel1': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel1', 'type': 'object'}, 'SubModel2': {'properties': {'union_model': {'discriminator': {'mapping': {'1': '#/$defs/UnionModel1', '2': '#/$defs/UnionModel2'}, 'propertyName': 'type'}, 'oneOf': [{'$ref': '#/$defs/UnionModel1'}, {'$ref': '#/$defs/UnionModel2'}], 'title': 'Union Model'}}, 'required': ['union_model'], 'title': 'SubModel2', 'type': 'object'}, 'UnionModel1': {'properties': {'type': {'const': 1, 'default': 1, 'title': 'Type'}, 'other': {'const': 'UnionModel1', 'default': 'UnionModel1', 'title': 'Other'}}, 'title': 'UnionModel1', 'type': 'object'}, 'UnionModel2': {'properties': {'type': {'const': 2, 'default': 2, 'title': 'Type'}, 'other': {'const': 'UnionModel2', 'default': 'UnionModel2', 'title': 'Other'}}, 'title': 'UnionModel2', 'type': 'object'}}, 'properties': {'submodel': {'anyOf': [{'$ref': '#/$defs/SubModel1'}, {'$ref': '#/$defs/SubModel2'}], 'title': 'Submodel'}}, 'required': ['submodel'], 'title': 'TestModel', 'type': 'object'}"
        ]
    },
    {
        "func_name": "replace_name",
        "original": "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    return 'cat'",
        "mutated": [
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n    return 'cat'",
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'cat'",
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'cat'",
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'cat'",
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'cat'"
        ]
    },
    {
        "func_name": "replace_name",
        "original": "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    return 'dog'",
        "mutated": [
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n    return 'dog'",
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return 'dog'",
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return 'dog'",
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return 'dog'",
            "@field_validator('name', mode='after')\ndef replace_name(cls, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return 'dog'"
        ]
    },
    {
        "func_name": "test_function_after_discriminator",
        "original": "def test_function_after_discriminator():\n\n    class CatModel(BaseModel):\n        name: Literal['kitty', 'cat']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'cat'\n\n    class DogModel(BaseModel):\n        name: Literal['puppy', 'dog']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'dog'\n    AllowedAnimal = Annotated[Union[CatModel, DogModel], Field(discriminator='name')]\n\n    class Model(BaseModel):\n        x: AllowedAnimal\n    m = Model(x={'name': 'kitty'})\n    assert m.x.name == 'cat'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'name': 'invalid'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'name'\", 'expected_tags': \"'kitty', 'cat', 'puppy', 'dog'\", 'tag': 'invalid'}, 'input': {'name': 'invalid'}, 'loc': ('x',), 'msg': \"Input tag 'invalid' found using 'name' does not match any of the expected tags: 'kitty', 'cat', 'puppy', 'dog'\", 'type': 'union_tag_invalid'}]",
        "mutated": [
            "def test_function_after_discriminator():\n    if False:\n        i = 10\n\n    class CatModel(BaseModel):\n        name: Literal['kitty', 'cat']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'cat'\n\n    class DogModel(BaseModel):\n        name: Literal['puppy', 'dog']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'dog'\n    AllowedAnimal = Annotated[Union[CatModel, DogModel], Field(discriminator='name')]\n\n    class Model(BaseModel):\n        x: AllowedAnimal\n    m = Model(x={'name': 'kitty'})\n    assert m.x.name == 'cat'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'name': 'invalid'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'name'\", 'expected_tags': \"'kitty', 'cat', 'puppy', 'dog'\", 'tag': 'invalid'}, 'input': {'name': 'invalid'}, 'loc': ('x',), 'msg': \"Input tag 'invalid' found using 'name' does not match any of the expected tags: 'kitty', 'cat', 'puppy', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_function_after_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class CatModel(BaseModel):\n        name: Literal['kitty', 'cat']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'cat'\n\n    class DogModel(BaseModel):\n        name: Literal['puppy', 'dog']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'dog'\n    AllowedAnimal = Annotated[Union[CatModel, DogModel], Field(discriminator='name')]\n\n    class Model(BaseModel):\n        x: AllowedAnimal\n    m = Model(x={'name': 'kitty'})\n    assert m.x.name == 'cat'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'name': 'invalid'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'name'\", 'expected_tags': \"'kitty', 'cat', 'puppy', 'dog'\", 'tag': 'invalid'}, 'input': {'name': 'invalid'}, 'loc': ('x',), 'msg': \"Input tag 'invalid' found using 'name' does not match any of the expected tags: 'kitty', 'cat', 'puppy', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_function_after_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class CatModel(BaseModel):\n        name: Literal['kitty', 'cat']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'cat'\n\n    class DogModel(BaseModel):\n        name: Literal['puppy', 'dog']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'dog'\n    AllowedAnimal = Annotated[Union[CatModel, DogModel], Field(discriminator='name')]\n\n    class Model(BaseModel):\n        x: AllowedAnimal\n    m = Model(x={'name': 'kitty'})\n    assert m.x.name == 'cat'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'name': 'invalid'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'name'\", 'expected_tags': \"'kitty', 'cat', 'puppy', 'dog'\", 'tag': 'invalid'}, 'input': {'name': 'invalid'}, 'loc': ('x',), 'msg': \"Input tag 'invalid' found using 'name' does not match any of the expected tags: 'kitty', 'cat', 'puppy', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_function_after_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class CatModel(BaseModel):\n        name: Literal['kitty', 'cat']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'cat'\n\n    class DogModel(BaseModel):\n        name: Literal['puppy', 'dog']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'dog'\n    AllowedAnimal = Annotated[Union[CatModel, DogModel], Field(discriminator='name')]\n\n    class Model(BaseModel):\n        x: AllowedAnimal\n    m = Model(x={'name': 'kitty'})\n    assert m.x.name == 'cat'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'name': 'invalid'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'name'\", 'expected_tags': \"'kitty', 'cat', 'puppy', 'dog'\", 'tag': 'invalid'}, 'input': {'name': 'invalid'}, 'loc': ('x',), 'msg': \"Input tag 'invalid' found using 'name' does not match any of the expected tags: 'kitty', 'cat', 'puppy', 'dog'\", 'type': 'union_tag_invalid'}]",
            "def test_function_after_discriminator():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class CatModel(BaseModel):\n        name: Literal['kitty', 'cat']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'cat'\n\n    class DogModel(BaseModel):\n        name: Literal['puppy', 'dog']\n\n        @field_validator('name', mode='after')\n        def replace_name(cls, v):\n            return 'dog'\n    AllowedAnimal = Annotated[Union[CatModel, DogModel], Field(discriminator='name')]\n\n    class Model(BaseModel):\n        x: AllowedAnimal\n    m = Model(x={'name': 'kitty'})\n    assert m.x.name == 'cat'\n    with pytest.raises(ValidationError) as exc_info:\n        Model(x={'name': 'invalid'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': \"'name'\", 'expected_tags': \"'kitty', 'cat', 'puppy', 'dog'\", 'tag': 'invalid'}, 'input': {'name': 'invalid'}, 'loc': ('x',), 'msg': \"Input tag 'invalid' found using 'name' does not match any of the expected tags: 'kitty', 'cat', 'puppy', 'dog'\", 'type': 'union_tag_invalid'}]"
        ]
    },
    {
        "func_name": "test_sequence_discriminated_union",
        "original": "def test_sequence_discriminated_union():\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        meows: int\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        barks: float\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        scales: bool\n    Pet = Annotated[Union[Cat, Dog, Lizard], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Sequence[Pet]\n        n: int\n    assert Model.model_json_schema() == {'$defs': {'Cat': {'properties': {'pet_type': {'const': 'cat', 'title': 'Pet Type'}, 'meows': {'title': 'Meows', 'type': 'integer'}}, 'required': ['pet_type', 'meows'], 'title': 'Cat', 'type': 'object'}, 'Dog': {'properties': {'pet_type': {'const': 'dog', 'title': 'Pet Type'}, 'barks': {'title': 'Barks', 'type': 'number'}}, 'required': ['pet_type', 'barks'], 'title': 'Dog', 'type': 'object'}, 'Lizard': {'properties': {'pet_type': {'enum': ['reptile', 'lizard'], 'title': 'Pet Type', 'type': 'string'}, 'scales': {'title': 'Scales', 'type': 'boolean'}}, 'required': ['pet_type', 'scales'], 'title': 'Lizard', 'type': 'object'}}, 'properties': {'pet': {'items': {'discriminator': {'mapping': {'cat': '#/$defs/Cat', 'dog': '#/$defs/Dog', 'lizard': '#/$defs/Lizard', 'reptile': '#/$defs/Lizard'}, 'propertyName': 'pet_type'}, 'oneOf': [{'$ref': '#/$defs/Cat'}, {'$ref': '#/$defs/Dog'}, {'$ref': '#/$defs/Lizard'}]}, 'title': 'Pet', 'type': 'array'}, 'n': {'title': 'N', 'type': 'integer'}}, 'required': ['pet', 'n'], 'title': 'Model', 'type': 'object'}",
        "mutated": [
            "def test_sequence_discriminated_union():\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        meows: int\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        barks: float\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        scales: bool\n    Pet = Annotated[Union[Cat, Dog, Lizard], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Sequence[Pet]\n        n: int\n    assert Model.model_json_schema() == {'$defs': {'Cat': {'properties': {'pet_type': {'const': 'cat', 'title': 'Pet Type'}, 'meows': {'title': 'Meows', 'type': 'integer'}}, 'required': ['pet_type', 'meows'], 'title': 'Cat', 'type': 'object'}, 'Dog': {'properties': {'pet_type': {'const': 'dog', 'title': 'Pet Type'}, 'barks': {'title': 'Barks', 'type': 'number'}}, 'required': ['pet_type', 'barks'], 'title': 'Dog', 'type': 'object'}, 'Lizard': {'properties': {'pet_type': {'enum': ['reptile', 'lizard'], 'title': 'Pet Type', 'type': 'string'}, 'scales': {'title': 'Scales', 'type': 'boolean'}}, 'required': ['pet_type', 'scales'], 'title': 'Lizard', 'type': 'object'}}, 'properties': {'pet': {'items': {'discriminator': {'mapping': {'cat': '#/$defs/Cat', 'dog': '#/$defs/Dog', 'lizard': '#/$defs/Lizard', 'reptile': '#/$defs/Lizard'}, 'propertyName': 'pet_type'}, 'oneOf': [{'$ref': '#/$defs/Cat'}, {'$ref': '#/$defs/Dog'}, {'$ref': '#/$defs/Lizard'}]}, 'title': 'Pet', 'type': 'array'}, 'n': {'title': 'N', 'type': 'integer'}}, 'required': ['pet', 'n'], 'title': 'Model', 'type': 'object'}",
            "def test_sequence_discriminated_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        meows: int\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        barks: float\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        scales: bool\n    Pet = Annotated[Union[Cat, Dog, Lizard], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Sequence[Pet]\n        n: int\n    assert Model.model_json_schema() == {'$defs': {'Cat': {'properties': {'pet_type': {'const': 'cat', 'title': 'Pet Type'}, 'meows': {'title': 'Meows', 'type': 'integer'}}, 'required': ['pet_type', 'meows'], 'title': 'Cat', 'type': 'object'}, 'Dog': {'properties': {'pet_type': {'const': 'dog', 'title': 'Pet Type'}, 'barks': {'title': 'Barks', 'type': 'number'}}, 'required': ['pet_type', 'barks'], 'title': 'Dog', 'type': 'object'}, 'Lizard': {'properties': {'pet_type': {'enum': ['reptile', 'lizard'], 'title': 'Pet Type', 'type': 'string'}, 'scales': {'title': 'Scales', 'type': 'boolean'}}, 'required': ['pet_type', 'scales'], 'title': 'Lizard', 'type': 'object'}}, 'properties': {'pet': {'items': {'discriminator': {'mapping': {'cat': '#/$defs/Cat', 'dog': '#/$defs/Dog', 'lizard': '#/$defs/Lizard', 'reptile': '#/$defs/Lizard'}, 'propertyName': 'pet_type'}, 'oneOf': [{'$ref': '#/$defs/Cat'}, {'$ref': '#/$defs/Dog'}, {'$ref': '#/$defs/Lizard'}]}, 'title': 'Pet', 'type': 'array'}, 'n': {'title': 'N', 'type': 'integer'}}, 'required': ['pet', 'n'], 'title': 'Model', 'type': 'object'}",
            "def test_sequence_discriminated_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        meows: int\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        barks: float\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        scales: bool\n    Pet = Annotated[Union[Cat, Dog, Lizard], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Sequence[Pet]\n        n: int\n    assert Model.model_json_schema() == {'$defs': {'Cat': {'properties': {'pet_type': {'const': 'cat', 'title': 'Pet Type'}, 'meows': {'title': 'Meows', 'type': 'integer'}}, 'required': ['pet_type', 'meows'], 'title': 'Cat', 'type': 'object'}, 'Dog': {'properties': {'pet_type': {'const': 'dog', 'title': 'Pet Type'}, 'barks': {'title': 'Barks', 'type': 'number'}}, 'required': ['pet_type', 'barks'], 'title': 'Dog', 'type': 'object'}, 'Lizard': {'properties': {'pet_type': {'enum': ['reptile', 'lizard'], 'title': 'Pet Type', 'type': 'string'}, 'scales': {'title': 'Scales', 'type': 'boolean'}}, 'required': ['pet_type', 'scales'], 'title': 'Lizard', 'type': 'object'}}, 'properties': {'pet': {'items': {'discriminator': {'mapping': {'cat': '#/$defs/Cat', 'dog': '#/$defs/Dog', 'lizard': '#/$defs/Lizard', 'reptile': '#/$defs/Lizard'}, 'propertyName': 'pet_type'}, 'oneOf': [{'$ref': '#/$defs/Cat'}, {'$ref': '#/$defs/Dog'}, {'$ref': '#/$defs/Lizard'}]}, 'title': 'Pet', 'type': 'array'}, 'n': {'title': 'N', 'type': 'integer'}}, 'required': ['pet', 'n'], 'title': 'Model', 'type': 'object'}",
            "def test_sequence_discriminated_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        meows: int\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        barks: float\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        scales: bool\n    Pet = Annotated[Union[Cat, Dog, Lizard], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Sequence[Pet]\n        n: int\n    assert Model.model_json_schema() == {'$defs': {'Cat': {'properties': {'pet_type': {'const': 'cat', 'title': 'Pet Type'}, 'meows': {'title': 'Meows', 'type': 'integer'}}, 'required': ['pet_type', 'meows'], 'title': 'Cat', 'type': 'object'}, 'Dog': {'properties': {'pet_type': {'const': 'dog', 'title': 'Pet Type'}, 'barks': {'title': 'Barks', 'type': 'number'}}, 'required': ['pet_type', 'barks'], 'title': 'Dog', 'type': 'object'}, 'Lizard': {'properties': {'pet_type': {'enum': ['reptile', 'lizard'], 'title': 'Pet Type', 'type': 'string'}, 'scales': {'title': 'Scales', 'type': 'boolean'}}, 'required': ['pet_type', 'scales'], 'title': 'Lizard', 'type': 'object'}}, 'properties': {'pet': {'items': {'discriminator': {'mapping': {'cat': '#/$defs/Cat', 'dog': '#/$defs/Dog', 'lizard': '#/$defs/Lizard', 'reptile': '#/$defs/Lizard'}, 'propertyName': 'pet_type'}, 'oneOf': [{'$ref': '#/$defs/Cat'}, {'$ref': '#/$defs/Dog'}, {'$ref': '#/$defs/Lizard'}]}, 'title': 'Pet', 'type': 'array'}, 'n': {'title': 'N', 'type': 'integer'}}, 'required': ['pet', 'n'], 'title': 'Model', 'type': 'object'}",
            "def test_sequence_discriminated_union():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat']\n        meows: int\n\n    class Dog(BaseModel):\n        pet_type: Literal['dog']\n        barks: float\n\n    class Lizard(BaseModel):\n        pet_type: Literal['reptile', 'lizard']\n        scales: bool\n    Pet = Annotated[Union[Cat, Dog, Lizard], Field(discriminator='pet_type')]\n\n    class Model(BaseModel):\n        pet: Sequence[Pet]\n        n: int\n    assert Model.model_json_schema() == {'$defs': {'Cat': {'properties': {'pet_type': {'const': 'cat', 'title': 'Pet Type'}, 'meows': {'title': 'Meows', 'type': 'integer'}}, 'required': ['pet_type', 'meows'], 'title': 'Cat', 'type': 'object'}, 'Dog': {'properties': {'pet_type': {'const': 'dog', 'title': 'Pet Type'}, 'barks': {'title': 'Barks', 'type': 'number'}}, 'required': ['pet_type', 'barks'], 'title': 'Dog', 'type': 'object'}, 'Lizard': {'properties': {'pet_type': {'enum': ['reptile', 'lizard'], 'title': 'Pet Type', 'type': 'string'}, 'scales': {'title': 'Scales', 'type': 'boolean'}}, 'required': ['pet_type', 'scales'], 'title': 'Lizard', 'type': 'object'}}, 'properties': {'pet': {'items': {'discriminator': {'mapping': {'cat': '#/$defs/Cat', 'dog': '#/$defs/Dog', 'lizard': '#/$defs/Lizard', 'reptile': '#/$defs/Lizard'}, 'propertyName': 'pet_type'}, 'oneOf': [{'$ref': '#/$defs/Cat'}, {'$ref': '#/$defs/Dog'}, {'$ref': '#/$defs/Lizard'}]}, 'title': 'Pet', 'type': 'array'}, 'n': {'title': 'N', 'type': 'integer'}}, 'required': ['pet', 'n'], 'title': 'Model', 'type': 'object'}"
        ]
    },
    {
        "func_name": "callable_discriminated_union_animals",
        "original": "@pytest.fixture(scope='session', name='animals')\ndef callable_discriminated_union_animals() -> SimpleNamespace:\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_kind: Literal['dog'] = 'dog'\n\n    class Fish(BaseModel):\n        pet_kind: Literal['fish'] = 'fish'\n\n    class Lizard(BaseModel):\n        pet_variety: Literal['lizard'] = 'lizard'\n    animals = SimpleNamespace(cat=Cat, dog=Dog, fish=Fish, lizard=Lizard)\n    return animals",
        "mutated": [
            "@pytest.fixture(scope='session', name='animals')\ndef callable_discriminated_union_animals() -> SimpleNamespace:\n    if False:\n        i = 10\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_kind: Literal['dog'] = 'dog'\n\n    class Fish(BaseModel):\n        pet_kind: Literal['fish'] = 'fish'\n\n    class Lizard(BaseModel):\n        pet_variety: Literal['lizard'] = 'lizard'\n    animals = SimpleNamespace(cat=Cat, dog=Dog, fish=Fish, lizard=Lizard)\n    return animals",
            "@pytest.fixture(scope='session', name='animals')\ndef callable_discriminated_union_animals() -> SimpleNamespace:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_kind: Literal['dog'] = 'dog'\n\n    class Fish(BaseModel):\n        pet_kind: Literal['fish'] = 'fish'\n\n    class Lizard(BaseModel):\n        pet_variety: Literal['lizard'] = 'lizard'\n    animals = SimpleNamespace(cat=Cat, dog=Dog, fish=Fish, lizard=Lizard)\n    return animals",
            "@pytest.fixture(scope='session', name='animals')\ndef callable_discriminated_union_animals() -> SimpleNamespace:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_kind: Literal['dog'] = 'dog'\n\n    class Fish(BaseModel):\n        pet_kind: Literal['fish'] = 'fish'\n\n    class Lizard(BaseModel):\n        pet_variety: Literal['lizard'] = 'lizard'\n    animals = SimpleNamespace(cat=Cat, dog=Dog, fish=Fish, lizard=Lizard)\n    return animals",
            "@pytest.fixture(scope='session', name='animals')\ndef callable_discriminated_union_animals() -> SimpleNamespace:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_kind: Literal['dog'] = 'dog'\n\n    class Fish(BaseModel):\n        pet_kind: Literal['fish'] = 'fish'\n\n    class Lizard(BaseModel):\n        pet_variety: Literal['lizard'] = 'lizard'\n    animals = SimpleNamespace(cat=Cat, dog=Dog, fish=Fish, lizard=Lizard)\n    return animals",
            "@pytest.fixture(scope='session', name='animals')\ndef callable_discriminated_union_animals() -> SimpleNamespace:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Cat(BaseModel):\n        pet_type: Literal['cat'] = 'cat'\n\n    class Dog(BaseModel):\n        pet_kind: Literal['dog'] = 'dog'\n\n    class Fish(BaseModel):\n        pet_kind: Literal['fish'] = 'fish'\n\n    class Lizard(BaseModel):\n        pet_variety: Literal['lizard'] = 'lizard'\n    animals = SimpleNamespace(cat=Cat, dog=Dog, fish=Fish, lizard=Lizard)\n    return animals"
        ]
    },
    {
        "func_name": "get_discriminator_value",
        "original": "def get_discriminator_value(v):\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))",
        "mutated": [
            "def get_discriminator_value(v):\n    if False:\n        i = 10\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))",
            "def get_discriminator_value(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))",
            "def get_discriminator_value(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))",
            "def get_discriminator_value(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))",
            "def get_discriminator_value(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))"
        ]
    },
    {
        "func_name": "shared_pet_discriminator_value",
        "original": "@pytest.fixture(scope='session', name='get_pet_discriminator_value')\ndef shared_pet_discriminator_value() -> Callable[[Any], str]:\n\n    def get_discriminator_value(v):\n        if isinstance(v, dict):\n            return v.get('pet_type', v.get('pet_kind'))\n        return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n    return get_discriminator_value",
        "mutated": [
            "@pytest.fixture(scope='session', name='get_pet_discriminator_value')\ndef shared_pet_discriminator_value() -> Callable[[Any], str]:\n    if False:\n        i = 10\n\n    def get_discriminator_value(v):\n        if isinstance(v, dict):\n            return v.get('pet_type', v.get('pet_kind'))\n        return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n    return get_discriminator_value",
            "@pytest.fixture(scope='session', name='get_pet_discriminator_value')\ndef shared_pet_discriminator_value() -> Callable[[Any], str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def get_discriminator_value(v):\n        if isinstance(v, dict):\n            return v.get('pet_type', v.get('pet_kind'))\n        return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n    return get_discriminator_value",
            "@pytest.fixture(scope='session', name='get_pet_discriminator_value')\ndef shared_pet_discriminator_value() -> Callable[[Any], str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def get_discriminator_value(v):\n        if isinstance(v, dict):\n            return v.get('pet_type', v.get('pet_kind'))\n        return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n    return get_discriminator_value",
            "@pytest.fixture(scope='session', name='get_pet_discriminator_value')\ndef shared_pet_discriminator_value() -> Callable[[Any], str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def get_discriminator_value(v):\n        if isinstance(v, dict):\n            return v.get('pet_type', v.get('pet_kind'))\n        return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n    return get_discriminator_value",
            "@pytest.fixture(scope='session', name='get_pet_discriminator_value')\ndef shared_pet_discriminator_value() -> Callable[[Any], str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def get_discriminator_value(v):\n        if isinstance(v, dict):\n            return v.get('pet_type', v.get('pet_kind'))\n        return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n    return get_discriminator_value"
        ]
    },
    {
        "func_name": "test_callable_discriminated_union_with_type_adapter",
        "original": "def test_callable_discriminated_union_with_type_adapter(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    pet_adapter = TypeAdapter(Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)])\n    assert pet_adapter.validate_python({'pet_type': 'cat'}).pet_type == 'cat'\n    assert pet_adapter.validate_python({'pet_kind': 'dog'}).pet_kind == 'dog'\n    assert pet_adapter.validate_python(animals.cat()).pet_type == 'cat'\n    assert pet_adapter.validate_python(animals.dog()).pet_kind == 'dog'\n    assert pet_adapter.validate_json('{\"pet_type\":\"cat\"}').pet_type == 'cat'\n    assert pet_adapter.validate_json('{\"pet_kind\":\"dog\"}').pet_kind == 'dog'\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_kind': 'fish'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_variety': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.fish())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.lizard())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
        "mutated": [
            "def test_callable_discriminated_union_with_type_adapter(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n    pet_adapter = TypeAdapter(Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)])\n    assert pet_adapter.validate_python({'pet_type': 'cat'}).pet_type == 'cat'\n    assert pet_adapter.validate_python({'pet_kind': 'dog'}).pet_kind == 'dog'\n    assert pet_adapter.validate_python(animals.cat()).pet_type == 'cat'\n    assert pet_adapter.validate_python(animals.dog()).pet_kind == 'dog'\n    assert pet_adapter.validate_json('{\"pet_type\":\"cat\"}').pet_type == 'cat'\n    assert pet_adapter.validate_json('{\"pet_kind\":\"dog\"}').pet_kind == 'dog'\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_kind': 'fish'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_variety': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.fish())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.lizard())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
            "def test_callable_discriminated_union_with_type_adapter(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pet_adapter = TypeAdapter(Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)])\n    assert pet_adapter.validate_python({'pet_type': 'cat'}).pet_type == 'cat'\n    assert pet_adapter.validate_python({'pet_kind': 'dog'}).pet_kind == 'dog'\n    assert pet_adapter.validate_python(animals.cat()).pet_type == 'cat'\n    assert pet_adapter.validate_python(animals.dog()).pet_kind == 'dog'\n    assert pet_adapter.validate_json('{\"pet_type\":\"cat\"}').pet_type == 'cat'\n    assert pet_adapter.validate_json('{\"pet_kind\":\"dog\"}').pet_kind == 'dog'\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_kind': 'fish'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_variety': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.fish())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.lizard())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
            "def test_callable_discriminated_union_with_type_adapter(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pet_adapter = TypeAdapter(Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)])\n    assert pet_adapter.validate_python({'pet_type': 'cat'}).pet_type == 'cat'\n    assert pet_adapter.validate_python({'pet_kind': 'dog'}).pet_kind == 'dog'\n    assert pet_adapter.validate_python(animals.cat()).pet_type == 'cat'\n    assert pet_adapter.validate_python(animals.dog()).pet_kind == 'dog'\n    assert pet_adapter.validate_json('{\"pet_type\":\"cat\"}').pet_type == 'cat'\n    assert pet_adapter.validate_json('{\"pet_kind\":\"dog\"}').pet_kind == 'dog'\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_kind': 'fish'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_variety': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.fish())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.lizard())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
            "def test_callable_discriminated_union_with_type_adapter(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pet_adapter = TypeAdapter(Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)])\n    assert pet_adapter.validate_python({'pet_type': 'cat'}).pet_type == 'cat'\n    assert pet_adapter.validate_python({'pet_kind': 'dog'}).pet_kind == 'dog'\n    assert pet_adapter.validate_python(animals.cat()).pet_type == 'cat'\n    assert pet_adapter.validate_python(animals.dog()).pet_kind == 'dog'\n    assert pet_adapter.validate_json('{\"pet_type\":\"cat\"}').pet_type == 'cat'\n    assert pet_adapter.validate_json('{\"pet_kind\":\"dog\"}').pet_kind == 'dog'\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_kind': 'fish'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_variety': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.fish())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.lizard())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
            "def test_callable_discriminated_union_with_type_adapter(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pet_adapter = TypeAdapter(Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)])\n    assert pet_adapter.validate_python({'pet_type': 'cat'}).pet_type == 'cat'\n    assert pet_adapter.validate_python({'pet_kind': 'dog'}).pet_kind == 'dog'\n    assert pet_adapter.validate_python(animals.cat()).pet_type == 'cat'\n    assert pet_adapter.validate_python(animals.dog()).pet_kind == 'dog'\n    assert pet_adapter.validate_json('{\"pet_type\":\"cat\"}').pet_type == 'cat'\n    assert pet_adapter.validate_json('{\"pet_kind\":\"dog\"}').pet_kind == 'dog'\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_kind': 'fish'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python({'pet_variety': 'lizard'})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.fish())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': (), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n    with pytest.raises(ValidationError) as exc_info:\n        pet_adapter.validate_python(animals.lizard())\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': (), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]"
        ]
    },
    {
        "func_name": "test_various_syntax_options_for_callable_union",
        "original": "def test_various_syntax_options_for_callable_union(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n\n    class PetModelField(BaseModel):\n        pet: Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]] = Field(discriminator=Discriminator(get_pet_discriminator_value))\n\n    class PetModelAnnotated(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)]\n\n    class PetModelAnnotatedWithField(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Field(discriminator=Discriminator(get_pet_discriminator_value))]\n    models = [PetModelField, PetModelAnnotated, PetModelAnnotatedWithField]\n    for model in models:\n        assert model.model_validate({'pet': {'pet_type': 'cat'}}).pet.pet_type == 'cat'\n        assert model.model_validate({'pet': {'pet_kind': 'dog'}}).pet.pet_kind == 'dog'\n        assert model(pet=animals.cat()).pet.pet_type == 'cat'\n        assert model(pet=animals.dog()).pet.pet_kind == 'dog'\n        assert model.model_validate_json('{\"pet\": {\"pet_type\":\"cat\"}}').pet.pet_type == 'cat'\n        assert model.model_validate_json('{\"pet\": {\"pet_kind\":\"dog\"}}').pet.pet_kind == 'dog'\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_kind': 'fish'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_variety': 'lizard'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.fish())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.lizard())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
        "mutated": [
            "def test_various_syntax_options_for_callable_union(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n\n    class PetModelField(BaseModel):\n        pet: Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]] = Field(discriminator=Discriminator(get_pet_discriminator_value))\n\n    class PetModelAnnotated(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)]\n\n    class PetModelAnnotatedWithField(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Field(discriminator=Discriminator(get_pet_discriminator_value))]\n    models = [PetModelField, PetModelAnnotated, PetModelAnnotatedWithField]\n    for model in models:\n        assert model.model_validate({'pet': {'pet_type': 'cat'}}).pet.pet_type == 'cat'\n        assert model.model_validate({'pet': {'pet_kind': 'dog'}}).pet.pet_kind == 'dog'\n        assert model(pet=animals.cat()).pet.pet_type == 'cat'\n        assert model(pet=animals.dog()).pet.pet_kind == 'dog'\n        assert model.model_validate_json('{\"pet\": {\"pet_type\":\"cat\"}}').pet.pet_type == 'cat'\n        assert model.model_validate_json('{\"pet\": {\"pet_kind\":\"dog\"}}').pet.pet_kind == 'dog'\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_kind': 'fish'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_variety': 'lizard'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.fish())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.lizard())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
            "def test_various_syntax_options_for_callable_union(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class PetModelField(BaseModel):\n        pet: Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]] = Field(discriminator=Discriminator(get_pet_discriminator_value))\n\n    class PetModelAnnotated(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)]\n\n    class PetModelAnnotatedWithField(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Field(discriminator=Discriminator(get_pet_discriminator_value))]\n    models = [PetModelField, PetModelAnnotated, PetModelAnnotatedWithField]\n    for model in models:\n        assert model.model_validate({'pet': {'pet_type': 'cat'}}).pet.pet_type == 'cat'\n        assert model.model_validate({'pet': {'pet_kind': 'dog'}}).pet.pet_kind == 'dog'\n        assert model(pet=animals.cat()).pet.pet_type == 'cat'\n        assert model(pet=animals.dog()).pet.pet_kind == 'dog'\n        assert model.model_validate_json('{\"pet\": {\"pet_type\":\"cat\"}}').pet.pet_type == 'cat'\n        assert model.model_validate_json('{\"pet\": {\"pet_kind\":\"dog\"}}').pet.pet_kind == 'dog'\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_kind': 'fish'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_variety': 'lizard'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.fish())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.lizard())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
            "def test_various_syntax_options_for_callable_union(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class PetModelField(BaseModel):\n        pet: Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]] = Field(discriminator=Discriminator(get_pet_discriminator_value))\n\n    class PetModelAnnotated(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)]\n\n    class PetModelAnnotatedWithField(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Field(discriminator=Discriminator(get_pet_discriminator_value))]\n    models = [PetModelField, PetModelAnnotated, PetModelAnnotatedWithField]\n    for model in models:\n        assert model.model_validate({'pet': {'pet_type': 'cat'}}).pet.pet_type == 'cat'\n        assert model.model_validate({'pet': {'pet_kind': 'dog'}}).pet.pet_kind == 'dog'\n        assert model(pet=animals.cat()).pet.pet_type == 'cat'\n        assert model(pet=animals.dog()).pet.pet_kind == 'dog'\n        assert model.model_validate_json('{\"pet\": {\"pet_type\":\"cat\"}}').pet.pet_type == 'cat'\n        assert model.model_validate_json('{\"pet\": {\"pet_kind\":\"dog\"}}').pet.pet_kind == 'dog'\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_kind': 'fish'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_variety': 'lizard'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.fish())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.lizard())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
            "def test_various_syntax_options_for_callable_union(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class PetModelField(BaseModel):\n        pet: Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]] = Field(discriminator=Discriminator(get_pet_discriminator_value))\n\n    class PetModelAnnotated(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)]\n\n    class PetModelAnnotatedWithField(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Field(discriminator=Discriminator(get_pet_discriminator_value))]\n    models = [PetModelField, PetModelAnnotated, PetModelAnnotatedWithField]\n    for model in models:\n        assert model.model_validate({'pet': {'pet_type': 'cat'}}).pet.pet_type == 'cat'\n        assert model.model_validate({'pet': {'pet_kind': 'dog'}}).pet.pet_kind == 'dog'\n        assert model(pet=animals.cat()).pet.pet_type == 'cat'\n        assert model(pet=animals.dog()).pet.pet_kind == 'dog'\n        assert model.model_validate_json('{\"pet\": {\"pet_type\":\"cat\"}}').pet.pet_type == 'cat'\n        assert model.model_validate_json('{\"pet\": {\"pet_kind\":\"dog\"}}').pet.pet_kind == 'dog'\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_kind': 'fish'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_variety': 'lizard'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.fish())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.lizard())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]",
            "def test_various_syntax_options_for_callable_union(animals: SimpleNamespace, get_pet_discriminator_value: Callable[[Any], str]) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class PetModelField(BaseModel):\n        pet: Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]] = Field(discriminator=Discriminator(get_pet_discriminator_value))\n\n    class PetModelAnnotated(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Discriminator(get_pet_discriminator_value)]\n\n    class PetModelAnnotatedWithField(BaseModel):\n        pet: Annotated[Union[Annotated[animals.cat, Tag('cat')], Annotated[animals.dog, Tag('dog')]], Field(discriminator=Discriminator(get_pet_discriminator_value))]\n    models = [PetModelField, PetModelAnnotated, PetModelAnnotatedWithField]\n    for model in models:\n        assert model.model_validate({'pet': {'pet_type': 'cat'}}).pet.pet_type == 'cat'\n        assert model.model_validate({'pet': {'pet_kind': 'dog'}}).pet.pet_kind == 'dog'\n        assert model(pet=animals.cat()).pet.pet_type == 'cat'\n        assert model(pet=animals.dog()).pet.pet_kind == 'dog'\n        assert model.model_validate_json('{\"pet\": {\"pet_type\":\"cat\"}}').pet.pet_type == 'cat'\n        assert model.model_validate_json('{\"pet\": {\"pet_kind\":\"dog\"}}').pet.pet_kind == 'dog'\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_kind': 'fish'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': {'pet_kind': 'fish'}, 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model.model_validate({'pet': {'pet_variety': 'lizard'}})\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': {'pet_variety': 'lizard'}, 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.fish())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()', 'expected_tags': \"'cat', 'dog'\", 'tag': 'fish'}, 'input': animals.fish(pet_kind='fish'), 'loc': ('pet',), 'msg': \"Input tag 'fish' found using get_discriminator_value() does not match any of the expected tags: 'cat', 'dog'\", 'type': 'union_tag_invalid'}]\n        with pytest.raises(ValidationError) as exc_info:\n            model(pet=animals.lizard())\n        assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'get_discriminator_value()'}, 'input': animals.lizard(pet_variety='lizard'), 'loc': ('pet',), 'msg': 'Unable to extract tag using discriminator get_discriminator_value()', 'type': 'union_tag_not_found'}]"
        ]
    },
    {
        "func_name": "model_x_discriminator",
        "original": "def model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
        "mutated": [
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'"
        ]
    },
    {
        "func_name": "test_callable_discriminated_union_recursive",
        "original": "def test_callable_discriminated_union_recursive():\n\n    class Model(BaseModel):\n        x: Union[str, 'Model']\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': 1}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': 1}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'ctx': {'class_name': 'Model'}, 'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model'), 'msg': 'Input should be a valid dictionary or instance of Model', 'type': 'model_type'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': {}}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': {}}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[Union[Annotated[str, Tag('str')], Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator, custom_error_type='invalid_union_member', custom_error_message='Invalid union member', custom_error_context={'discriminator': 'str_or_model'})]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'str_or_model'}, 'input': 1, 'loc': ('x', 'model', 'x', 'model', 'x'), 'msg': 'Invalid union member', 'type': 'invalid_union_member'}]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('x', 'model', 'x', 'model', 'x', 'model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n    data = {'x': {'x': {'x': 'a'}}}\n    m = DiscriminatedModel.model_validate(data)\n    assert m == DiscriminatedModel(x=DiscriminatedModel(x=DiscriminatedModel(x='a')))\n    assert m.model_dump() == data",
        "mutated": [
            "def test_callable_discriminated_union_recursive():\n    if False:\n        i = 10\n\n    class Model(BaseModel):\n        x: Union[str, 'Model']\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': 1}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': 1}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'ctx': {'class_name': 'Model'}, 'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model'), 'msg': 'Input should be a valid dictionary or instance of Model', 'type': 'model_type'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': {}}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': {}}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[Union[Annotated[str, Tag('str')], Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator, custom_error_type='invalid_union_member', custom_error_message='Invalid union member', custom_error_context={'discriminator': 'str_or_model'})]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'str_or_model'}, 'input': 1, 'loc': ('x', 'model', 'x', 'model', 'x'), 'msg': 'Invalid union member', 'type': 'invalid_union_member'}]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('x', 'model', 'x', 'model', 'x', 'model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n    data = {'x': {'x': {'x': 'a'}}}\n    m = DiscriminatedModel.model_validate(data)\n    assert m == DiscriminatedModel(x=DiscriminatedModel(x=DiscriminatedModel(x='a')))\n    assert m.model_dump() == data",
            "def test_callable_discriminated_union_recursive():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class Model(BaseModel):\n        x: Union[str, 'Model']\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': 1}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': 1}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'ctx': {'class_name': 'Model'}, 'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model'), 'msg': 'Input should be a valid dictionary or instance of Model', 'type': 'model_type'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': {}}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': {}}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[Union[Annotated[str, Tag('str')], Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator, custom_error_type='invalid_union_member', custom_error_message='Invalid union member', custom_error_context={'discriminator': 'str_or_model'})]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'str_or_model'}, 'input': 1, 'loc': ('x', 'model', 'x', 'model', 'x'), 'msg': 'Invalid union member', 'type': 'invalid_union_member'}]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('x', 'model', 'x', 'model', 'x', 'model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n    data = {'x': {'x': {'x': 'a'}}}\n    m = DiscriminatedModel.model_validate(data)\n    assert m == DiscriminatedModel(x=DiscriminatedModel(x=DiscriminatedModel(x='a')))\n    assert m.model_dump() == data",
            "def test_callable_discriminated_union_recursive():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class Model(BaseModel):\n        x: Union[str, 'Model']\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': 1}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': 1}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'ctx': {'class_name': 'Model'}, 'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model'), 'msg': 'Input should be a valid dictionary or instance of Model', 'type': 'model_type'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': {}}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': {}}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[Union[Annotated[str, Tag('str')], Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator, custom_error_type='invalid_union_member', custom_error_message='Invalid union member', custom_error_context={'discriminator': 'str_or_model'})]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'str_or_model'}, 'input': 1, 'loc': ('x', 'model', 'x', 'model', 'x'), 'msg': 'Invalid union member', 'type': 'invalid_union_member'}]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('x', 'model', 'x', 'model', 'x', 'model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n    data = {'x': {'x': {'x': 'a'}}}\n    m = DiscriminatedModel.model_validate(data)\n    assert m == DiscriminatedModel(x=DiscriminatedModel(x=DiscriminatedModel(x='a')))\n    assert m.model_dump() == data",
            "def test_callable_discriminated_union_recursive():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class Model(BaseModel):\n        x: Union[str, 'Model']\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': 1}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': 1}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'ctx': {'class_name': 'Model'}, 'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model'), 'msg': 'Input should be a valid dictionary or instance of Model', 'type': 'model_type'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': {}}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': {}}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[Union[Annotated[str, Tag('str')], Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator, custom_error_type='invalid_union_member', custom_error_message='Invalid union member', custom_error_context={'discriminator': 'str_or_model'})]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'str_or_model'}, 'input': 1, 'loc': ('x', 'model', 'x', 'model', 'x'), 'msg': 'Invalid union member', 'type': 'invalid_union_member'}]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('x', 'model', 'x', 'model', 'x', 'model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n    data = {'x': {'x': {'x': 'a'}}}\n    m = DiscriminatedModel.model_validate(data)\n    assert m == DiscriminatedModel(x=DiscriminatedModel(x=DiscriminatedModel(x='a')))\n    assert m.model_dump() == data",
            "def test_callable_discriminated_union_recursive():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class Model(BaseModel):\n        x: Union[str, 'Model']\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': 1}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': 1}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'ctx': {'class_name': 'Model'}, 'input': 1, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model'), 'msg': 'Input should be a valid dictionary or instance of Model', 'type': 'model_type'}]\n    with pytest.raises(ValidationError) as exc_info:\n        Model.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {'x': {'x': {}}}, 'loc': ('x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {'x': {}}, 'loc': ('x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'str'), 'msg': 'Input should be a valid string', 'type': 'string_type'}, {'input': {}, 'loc': ('x', 'Model', 'x', 'Model', 'x', 'Model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[Union[Annotated[str, Tag('str')], Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator, custom_error_type='invalid_union_member', custom_error_message='Invalid union member', custom_error_context={'discriminator': 'str_or_model'})]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': 1}}})\n    assert exc_info.value.errors(include_url=False) == [{'ctx': {'discriminator': 'str_or_model'}, 'input': 1, 'loc': ('x', 'model', 'x', 'model', 'x'), 'msg': 'Invalid union member', 'type': 'invalid_union_member'}]\n    with pytest.raises(ValidationError) as exc_info:\n        DiscriminatedModel.model_validate({'x': {'x': {'x': {}}}})\n    assert exc_info.value.errors(include_url=False) == [{'input': {}, 'loc': ('x', 'model', 'x', 'model', 'x', 'model', 'x'), 'msg': 'Field required', 'type': 'missing'}]\n    data = {'x': {'x': {'x': 'a'}}}\n    m = DiscriminatedModel.model_validate(data)\n    assert m == DiscriminatedModel(x=DiscriminatedModel(x=DiscriminatedModel(x='a')))\n    assert m.model_dump() == data"
        ]
    },
    {
        "func_name": "model_x_discriminator",
        "original": "def model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
        "mutated": [
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'",
            "def model_x_discriminator(v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'"
        ]
    },
    {
        "func_name": "test_callable_discriminated_union_with_missing_tag",
        "original": "def test_callable_discriminated_union_with_missing_tag() -> None:\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[Annotated[str, Tag('str')], 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'",
        "mutated": [
            "def test_callable_discriminated_union_with_missing_tag() -> None:\n    if False:\n        i = 10\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[Annotated[str, Tag('str')], 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'",
            "def test_callable_discriminated_union_with_missing_tag() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[Annotated[str, Tag('str')], 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'",
            "def test_callable_discriminated_union_with_missing_tag() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[Annotated[str, Tag('str')], 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'",
            "def test_callable_discriminated_union_with_missing_tag() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[Annotated[str, Tag('str')], 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'",
            "def test_callable_discriminated_union_with_missing_tag() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    def model_x_discriminator(v):\n        if isinstance(v, str):\n            return 'str'\n        if isinstance(v, (dict, BaseModel)):\n            return 'model'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[Annotated[str, Tag('str')], 'DiscriminatedModel'], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'\n    try:\n\n        class DiscriminatedModel(BaseModel):\n            x: Annotated[Union[str, Annotated['DiscriminatedModel', Tag('model')]], Discriminator(model_x_discriminator)]\n    except PydanticUserError as exc_info:\n        assert exc_info.code == 'callable-discriminator-no-tag'"
        ]
    }
]