[
    {
        "func_name": "sqrt",
        "original": "def sqrt(x):\n    \"\"\"\n    EXPERIMENTAL Computes the upper triangular square root of an\n    symmetric arrowhead matrix.\n\n    :param SymmArrowhead x: an symmetric arrowhead matrix\n    :return: the square root of `x`\n    :rtype: TriuArrowhead\n    \"\"\"\n    assert isinstance(x, SymmArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.sqrt())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    Dsqrt = x.bottom_diag.sqrt()\n    num_attempts = 6\n    for i in range(num_attempts):\n        B_Dsqrt = B / Dsqrt.unsqueeze(-2)\n        schur_complement = A - B_Dsqrt.matmul(B_Dsqrt.t())\n        try:\n            top_left = torch.flip(torch.linalg.cholesky(torch.flip(schur_complement, (-2, -1))), (-2, -1))\n            break\n        except RuntimeError:\n            B = B / 2\n            continue\n        raise RuntimeError('Singular schur complement in computing Cholesky of the input arrowhead matrix')\n    top_right = B_Dsqrt\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = Dsqrt\n    return TriuArrowhead(top, bottom_diag)",
        "mutated": [
            "def sqrt(x):\n    if False:\n        i = 10\n    '\\n    EXPERIMENTAL Computes the upper triangular square root of an\\n    symmetric arrowhead matrix.\\n\\n    :param SymmArrowhead x: an symmetric arrowhead matrix\\n    :return: the square root of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, SymmArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.sqrt())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    Dsqrt = x.bottom_diag.sqrt()\n    num_attempts = 6\n    for i in range(num_attempts):\n        B_Dsqrt = B / Dsqrt.unsqueeze(-2)\n        schur_complement = A - B_Dsqrt.matmul(B_Dsqrt.t())\n        try:\n            top_left = torch.flip(torch.linalg.cholesky(torch.flip(schur_complement, (-2, -1))), (-2, -1))\n            break\n        except RuntimeError:\n            B = B / 2\n            continue\n        raise RuntimeError('Singular schur complement in computing Cholesky of the input arrowhead matrix')\n    top_right = B_Dsqrt\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = Dsqrt\n    return TriuArrowhead(top, bottom_diag)",
            "def sqrt(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    EXPERIMENTAL Computes the upper triangular square root of an\\n    symmetric arrowhead matrix.\\n\\n    :param SymmArrowhead x: an symmetric arrowhead matrix\\n    :return: the square root of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, SymmArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.sqrt())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    Dsqrt = x.bottom_diag.sqrt()\n    num_attempts = 6\n    for i in range(num_attempts):\n        B_Dsqrt = B / Dsqrt.unsqueeze(-2)\n        schur_complement = A - B_Dsqrt.matmul(B_Dsqrt.t())\n        try:\n            top_left = torch.flip(torch.linalg.cholesky(torch.flip(schur_complement, (-2, -1))), (-2, -1))\n            break\n        except RuntimeError:\n            B = B / 2\n            continue\n        raise RuntimeError('Singular schur complement in computing Cholesky of the input arrowhead matrix')\n    top_right = B_Dsqrt\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = Dsqrt\n    return TriuArrowhead(top, bottom_diag)",
            "def sqrt(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    EXPERIMENTAL Computes the upper triangular square root of an\\n    symmetric arrowhead matrix.\\n\\n    :param SymmArrowhead x: an symmetric arrowhead matrix\\n    :return: the square root of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, SymmArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.sqrt())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    Dsqrt = x.bottom_diag.sqrt()\n    num_attempts = 6\n    for i in range(num_attempts):\n        B_Dsqrt = B / Dsqrt.unsqueeze(-2)\n        schur_complement = A - B_Dsqrt.matmul(B_Dsqrt.t())\n        try:\n            top_left = torch.flip(torch.linalg.cholesky(torch.flip(schur_complement, (-2, -1))), (-2, -1))\n            break\n        except RuntimeError:\n            B = B / 2\n            continue\n        raise RuntimeError('Singular schur complement in computing Cholesky of the input arrowhead matrix')\n    top_right = B_Dsqrt\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = Dsqrt\n    return TriuArrowhead(top, bottom_diag)",
            "def sqrt(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    EXPERIMENTAL Computes the upper triangular square root of an\\n    symmetric arrowhead matrix.\\n\\n    :param SymmArrowhead x: an symmetric arrowhead matrix\\n    :return: the square root of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, SymmArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.sqrt())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    Dsqrt = x.bottom_diag.sqrt()\n    num_attempts = 6\n    for i in range(num_attempts):\n        B_Dsqrt = B / Dsqrt.unsqueeze(-2)\n        schur_complement = A - B_Dsqrt.matmul(B_Dsqrt.t())\n        try:\n            top_left = torch.flip(torch.linalg.cholesky(torch.flip(schur_complement, (-2, -1))), (-2, -1))\n            break\n        except RuntimeError:\n            B = B / 2\n            continue\n        raise RuntimeError('Singular schur complement in computing Cholesky of the input arrowhead matrix')\n    top_right = B_Dsqrt\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = Dsqrt\n    return TriuArrowhead(top, bottom_diag)",
            "def sqrt(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    EXPERIMENTAL Computes the upper triangular square root of an\\n    symmetric arrowhead matrix.\\n\\n    :param SymmArrowhead x: an symmetric arrowhead matrix\\n    :return: the square root of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, SymmArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.sqrt())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    Dsqrt = x.bottom_diag.sqrt()\n    num_attempts = 6\n    for i in range(num_attempts):\n        B_Dsqrt = B / Dsqrt.unsqueeze(-2)\n        schur_complement = A - B_Dsqrt.matmul(B_Dsqrt.t())\n        try:\n            top_left = torch.flip(torch.linalg.cholesky(torch.flip(schur_complement, (-2, -1))), (-2, -1))\n            break\n        except RuntimeError:\n            B = B / 2\n            continue\n        raise RuntimeError('Singular schur complement in computing Cholesky of the input arrowhead matrix')\n    top_right = B_Dsqrt\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = Dsqrt\n    return TriuArrowhead(top, bottom_diag)"
        ]
    },
    {
        "func_name": "triu_inverse",
        "original": "def triu_inverse(x):\n    \"\"\"\n    EXPERIMENTAL Computes the inverse of an upper-triangular arrowhead matrix.\n\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\n    :return: the inverse of `x`\n    :rtype: TriuArrowhead\n    \"\"\"\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.reciprocal())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    B_Dinv = B / x.bottom_diag.unsqueeze(-2)\n    identity = torch.eye(head_size, dtype=A.dtype, device=A.device)\n    top_left = torch.linalg.solve_triangular(A, identity, upper=True)\n    top_right = -top_left.matmul(B_Dinv)\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = x.bottom_diag.reciprocal()\n    return TriuArrowhead(top, bottom_diag)",
        "mutated": [
            "def triu_inverse(x):\n    if False:\n        i = 10\n    '\\n    EXPERIMENTAL Computes the inverse of an upper-triangular arrowhead matrix.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the inverse of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.reciprocal())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    B_Dinv = B / x.bottom_diag.unsqueeze(-2)\n    identity = torch.eye(head_size, dtype=A.dtype, device=A.device)\n    top_left = torch.linalg.solve_triangular(A, identity, upper=True)\n    top_right = -top_left.matmul(B_Dinv)\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = x.bottom_diag.reciprocal()\n    return TriuArrowhead(top, bottom_diag)",
            "def triu_inverse(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    EXPERIMENTAL Computes the inverse of an upper-triangular arrowhead matrix.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the inverse of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.reciprocal())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    B_Dinv = B / x.bottom_diag.unsqueeze(-2)\n    identity = torch.eye(head_size, dtype=A.dtype, device=A.device)\n    top_left = torch.linalg.solve_triangular(A, identity, upper=True)\n    top_right = -top_left.matmul(B_Dinv)\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = x.bottom_diag.reciprocal()\n    return TriuArrowhead(top, bottom_diag)",
            "def triu_inverse(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    EXPERIMENTAL Computes the inverse of an upper-triangular arrowhead matrix.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the inverse of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.reciprocal())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    B_Dinv = B / x.bottom_diag.unsqueeze(-2)\n    identity = torch.eye(head_size, dtype=A.dtype, device=A.device)\n    top_left = torch.linalg.solve_triangular(A, identity, upper=True)\n    top_right = -top_left.matmul(B_Dinv)\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = x.bottom_diag.reciprocal()\n    return TriuArrowhead(top, bottom_diag)",
            "def triu_inverse(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    EXPERIMENTAL Computes the inverse of an upper-triangular arrowhead matrix.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the inverse of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.reciprocal())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    B_Dinv = B / x.bottom_diag.unsqueeze(-2)\n    identity = torch.eye(head_size, dtype=A.dtype, device=A.device)\n    top_left = torch.linalg.solve_triangular(A, identity, upper=True)\n    top_right = -top_left.matmul(B_Dinv)\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = x.bottom_diag.reciprocal()\n    return TriuArrowhead(top, bottom_diag)",
            "def triu_inverse(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    EXPERIMENTAL Computes the inverse of an upper-triangular arrowhead matrix.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the inverse of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return TriuArrowhead(x.top, x.bottom_diag.reciprocal())\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    B_Dinv = B / x.bottom_diag.unsqueeze(-2)\n    identity = torch.eye(head_size, dtype=A.dtype, device=A.device)\n    top_left = torch.linalg.solve_triangular(A, identity, upper=True)\n    top_right = -top_left.matmul(B_Dinv)\n    top = torch.cat([top_left, top_right], -1)\n    bottom_diag = x.bottom_diag.reciprocal()\n    return TriuArrowhead(top, bottom_diag)"
        ]
    },
    {
        "func_name": "triu_matvecmul",
        "original": "def triu_matvecmul(x, y, transpose=False):\n    \"\"\"\n    EXPERIMENTAL Computes matrix-vector product of an upper-triangular\n    arrowhead matrix `x` and a vector `y`.\n\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\n    :param torch.Tensor y: a 1D tensor\n    :return: matrix-vector product of `x` and `y`\n    :rtype: TriuArrowhead\n    \"\"\"\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if transpose:\n        z = x.top.transpose(-2, -1).matmul(y[:head_size])\n        top = z[:head_size]\n        bottom = z[head_size:] + x.bottom_diag * y[head_size:]\n    else:\n        top = x.top.matmul(y)\n        bottom = x.bottom_diag * y[head_size:]\n    return torch.cat([top, bottom], 0)",
        "mutated": [
            "def triu_matvecmul(x, y, transpose=False):\n    if False:\n        i = 10\n    '\\n    EXPERIMENTAL Computes matrix-vector product of an upper-triangular\\n    arrowhead matrix `x` and a vector `y`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :param torch.Tensor y: a 1D tensor\\n    :return: matrix-vector product of `x` and `y`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if transpose:\n        z = x.top.transpose(-2, -1).matmul(y[:head_size])\n        top = z[:head_size]\n        bottom = z[head_size:] + x.bottom_diag * y[head_size:]\n    else:\n        top = x.top.matmul(y)\n        bottom = x.bottom_diag * y[head_size:]\n    return torch.cat([top, bottom], 0)",
            "def triu_matvecmul(x, y, transpose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    EXPERIMENTAL Computes matrix-vector product of an upper-triangular\\n    arrowhead matrix `x` and a vector `y`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :param torch.Tensor y: a 1D tensor\\n    :return: matrix-vector product of `x` and `y`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if transpose:\n        z = x.top.transpose(-2, -1).matmul(y[:head_size])\n        top = z[:head_size]\n        bottom = z[head_size:] + x.bottom_diag * y[head_size:]\n    else:\n        top = x.top.matmul(y)\n        bottom = x.bottom_diag * y[head_size:]\n    return torch.cat([top, bottom], 0)",
            "def triu_matvecmul(x, y, transpose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    EXPERIMENTAL Computes matrix-vector product of an upper-triangular\\n    arrowhead matrix `x` and a vector `y`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :param torch.Tensor y: a 1D tensor\\n    :return: matrix-vector product of `x` and `y`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if transpose:\n        z = x.top.transpose(-2, -1).matmul(y[:head_size])\n        top = z[:head_size]\n        bottom = z[head_size:] + x.bottom_diag * y[head_size:]\n    else:\n        top = x.top.matmul(y)\n        bottom = x.bottom_diag * y[head_size:]\n    return torch.cat([top, bottom], 0)",
            "def triu_matvecmul(x, y, transpose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    EXPERIMENTAL Computes matrix-vector product of an upper-triangular\\n    arrowhead matrix `x` and a vector `y`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :param torch.Tensor y: a 1D tensor\\n    :return: matrix-vector product of `x` and `y`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if transpose:\n        z = x.top.transpose(-2, -1).matmul(y[:head_size])\n        top = z[:head_size]\n        bottom = z[head_size:] + x.bottom_diag * y[head_size:]\n    else:\n        top = x.top.matmul(y)\n        bottom = x.bottom_diag * y[head_size:]\n    return torch.cat([top, bottom], 0)",
            "def triu_matvecmul(x, y, transpose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    EXPERIMENTAL Computes matrix-vector product of an upper-triangular\\n    arrowhead matrix `x` and a vector `y`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :param torch.Tensor y: a 1D tensor\\n    :return: matrix-vector product of `x` and `y`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if transpose:\n        z = x.top.transpose(-2, -1).matmul(y[:head_size])\n        top = z[:head_size]\n        bottom = z[head_size:] + x.bottom_diag * y[head_size:]\n    else:\n        top = x.top.matmul(y)\n        bottom = x.bottom_diag * y[head_size:]\n    return torch.cat([top, bottom], 0)"
        ]
    },
    {
        "func_name": "triu_gram",
        "original": "def triu_gram(x):\n    \"\"\"\n    EXPERIMENTAL Computes the gram matrix `x.T @ x` from an upper-triangular\n    arrowhead matrix `x`.\n\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\n    :return: the square of `x`\n    :rtype: TriuArrowhead\n    \"\"\"\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return x.bottom_diag.pow(2)\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    top = A.t().matmul(x.top)\n    bottom_left = top[:, head_size:].t()\n    bottom_right = B.t().matmul(B) + x.bottom_diag.pow(2).diag()\n    return torch.cat([top, torch.cat([bottom_left, bottom_right], -1)], 0)",
        "mutated": [
            "def triu_gram(x):\n    if False:\n        i = 10\n    '\\n    EXPERIMENTAL Computes the gram matrix `x.T @ x` from an upper-triangular\\n    arrowhead matrix `x`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the square of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return x.bottom_diag.pow(2)\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    top = A.t().matmul(x.top)\n    bottom_left = top[:, head_size:].t()\n    bottom_right = B.t().matmul(B) + x.bottom_diag.pow(2).diag()\n    return torch.cat([top, torch.cat([bottom_left, bottom_right], -1)], 0)",
            "def triu_gram(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    EXPERIMENTAL Computes the gram matrix `x.T @ x` from an upper-triangular\\n    arrowhead matrix `x`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the square of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return x.bottom_diag.pow(2)\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    top = A.t().matmul(x.top)\n    bottom_left = top[:, head_size:].t()\n    bottom_right = B.t().matmul(B) + x.bottom_diag.pow(2).diag()\n    return torch.cat([top, torch.cat([bottom_left, bottom_right], -1)], 0)",
            "def triu_gram(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    EXPERIMENTAL Computes the gram matrix `x.T @ x` from an upper-triangular\\n    arrowhead matrix `x`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the square of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return x.bottom_diag.pow(2)\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    top = A.t().matmul(x.top)\n    bottom_left = top[:, head_size:].t()\n    bottom_right = B.t().matmul(B) + x.bottom_diag.pow(2).diag()\n    return torch.cat([top, torch.cat([bottom_left, bottom_right], -1)], 0)",
            "def triu_gram(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    EXPERIMENTAL Computes the gram matrix `x.T @ x` from an upper-triangular\\n    arrowhead matrix `x`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the square of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return x.bottom_diag.pow(2)\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    top = A.t().matmul(x.top)\n    bottom_left = top[:, head_size:].t()\n    bottom_right = B.t().matmul(B) + x.bottom_diag.pow(2).diag()\n    return torch.cat([top, torch.cat([bottom_left, bottom_right], -1)], 0)",
            "def triu_gram(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    EXPERIMENTAL Computes the gram matrix `x.T @ x` from an upper-triangular\\n    arrowhead matrix `x`.\\n\\n    :param TriuArrowhead x: an upper-triangular arrowhead matrix.\\n    :return: the square of `x`\\n    :rtype: TriuArrowhead\\n    '\n    assert isinstance(x, TriuArrowhead)\n    head_size = x.top.size(0)\n    if head_size == 0:\n        return x.bottom_diag.pow(2)\n    (A, B) = (x.top[:, :head_size], x.top[:, head_size:])\n    top = A.t().matmul(x.top)\n    bottom_left = top[:, head_size:].t()\n    bottom_right = B.t().matmul(B) + x.bottom_diag.pow(2).diag()\n    return torch.cat([top, torch.cat([bottom_left, bottom_right], -1)], 0)"
        ]
    }
]