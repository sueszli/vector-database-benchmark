[
    {
        "func_name": "test_endpoint_span_extractor_can_build_from_params",
        "original": "def test_endpoint_span_extractor_can_build_from_params(self):\n    params = Params({'type': 'endpoint', 'input_dim': 7, 'num_width_embeddings': 5, 'span_width_embedding_dim': 3})\n    extractor = SpanExtractor.from_params(params)\n    assert isinstance(extractor, EndpointSpanExtractor)\n    assert extractor.get_output_dim() == 17",
        "mutated": [
            "def test_endpoint_span_extractor_can_build_from_params(self):\n    if False:\n        i = 10\n    params = Params({'type': 'endpoint', 'input_dim': 7, 'num_width_embeddings': 5, 'span_width_embedding_dim': 3})\n    extractor = SpanExtractor.from_params(params)\n    assert isinstance(extractor, EndpointSpanExtractor)\n    assert extractor.get_output_dim() == 17",
            "def test_endpoint_span_extractor_can_build_from_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    params = Params({'type': 'endpoint', 'input_dim': 7, 'num_width_embeddings': 5, 'span_width_embedding_dim': 3})\n    extractor = SpanExtractor.from_params(params)\n    assert isinstance(extractor, EndpointSpanExtractor)\n    assert extractor.get_output_dim() == 17",
            "def test_endpoint_span_extractor_can_build_from_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    params = Params({'type': 'endpoint', 'input_dim': 7, 'num_width_embeddings': 5, 'span_width_embedding_dim': 3})\n    extractor = SpanExtractor.from_params(params)\n    assert isinstance(extractor, EndpointSpanExtractor)\n    assert extractor.get_output_dim() == 17",
            "def test_endpoint_span_extractor_can_build_from_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    params = Params({'type': 'endpoint', 'input_dim': 7, 'num_width_embeddings': 5, 'span_width_embedding_dim': 3})\n    extractor = SpanExtractor.from_params(params)\n    assert isinstance(extractor, EndpointSpanExtractor)\n    assert extractor.get_output_dim() == 17",
            "def test_endpoint_span_extractor_can_build_from_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    params = Params({'type': 'endpoint', 'input_dim': 7, 'num_width_embeddings': 5, 'span_width_embedding_dim': 3})\n    extractor = SpanExtractor.from_params(params)\n    assert isinstance(extractor, EndpointSpanExtractor)\n    assert extractor.get_output_dim() == 17"
        ]
    },
    {
        "func_name": "test_correct_sequence_elements_are_embedded",
        "original": "def test_correct_sequence_elements_are_embedded(self):\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    assert list(span_representations.size()) == [2, 2, 14]\n    assert extractor.get_output_dim() == 14\n    assert extractor.get_input_dim() == 7\n    (start_indices, end_indices) = indices.split(1, -1)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze())\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze())\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
        "mutated": [
            "def test_correct_sequence_elements_are_embedded(self):\n    if False:\n        i = 10\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    assert list(span_representations.size()) == [2, 2, 14]\n    assert extractor.get_output_dim() == 14\n    assert extractor.get_input_dim() == 7\n    (start_indices, end_indices) = indices.split(1, -1)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze())\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze())\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
            "def test_correct_sequence_elements_are_embedded(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    assert list(span_representations.size()) == [2, 2, 14]\n    assert extractor.get_output_dim() == 14\n    assert extractor.get_input_dim() == 7\n    (start_indices, end_indices) = indices.split(1, -1)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze())\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze())\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
            "def test_correct_sequence_elements_are_embedded(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    assert list(span_representations.size()) == [2, 2, 14]\n    assert extractor.get_output_dim() == 14\n    assert extractor.get_input_dim() == 7\n    (start_indices, end_indices) = indices.split(1, -1)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze())\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze())\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
            "def test_correct_sequence_elements_are_embedded(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    assert list(span_representations.size()) == [2, 2, 14]\n    assert extractor.get_output_dim() == 14\n    assert extractor.get_input_dim() == 7\n    (start_indices, end_indices) = indices.split(1, -1)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze())\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze())\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
            "def test_correct_sequence_elements_are_embedded(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    assert list(span_representations.size()) == [2, 2, 14]\n    assert extractor.get_output_dim() == 14\n    assert extractor.get_input_dim() == 7\n    (start_indices, end_indices) = indices.split(1, -1)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze())\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze())\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())"
        ]
    },
    {
        "func_name": "test_masked_indices_are_handled_correctly",
        "original": "def test_masked_indices_are_handled_correctly(self):\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    indices_mask = torch.tensor([[True, True], [False, False]])\n    span_representations = extractor(sequence_tensor, indices, span_indices_mask=indices_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    (start_indices, end_indices) = indices.split(1, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze()).data\n    correct_start_embeddings[1, :, :].fill_(0)\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze()).data\n    correct_end_embeddings[1, :, :].fill_(0)\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.numpy())",
        "mutated": [
            "def test_masked_indices_are_handled_correctly(self):\n    if False:\n        i = 10\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    indices_mask = torch.tensor([[True, True], [False, False]])\n    span_representations = extractor(sequence_tensor, indices, span_indices_mask=indices_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    (start_indices, end_indices) = indices.split(1, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze()).data\n    correct_start_embeddings[1, :, :].fill_(0)\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze()).data\n    correct_end_embeddings[1, :, :].fill_(0)\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.numpy())",
            "def test_masked_indices_are_handled_correctly(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    indices_mask = torch.tensor([[True, True], [False, False]])\n    span_representations = extractor(sequence_tensor, indices, span_indices_mask=indices_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    (start_indices, end_indices) = indices.split(1, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze()).data\n    correct_start_embeddings[1, :, :].fill_(0)\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze()).data\n    correct_end_embeddings[1, :, :].fill_(0)\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.numpy())",
            "def test_masked_indices_are_handled_correctly(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    indices_mask = torch.tensor([[True, True], [False, False]])\n    span_representations = extractor(sequence_tensor, indices, span_indices_mask=indices_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    (start_indices, end_indices) = indices.split(1, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze()).data\n    correct_start_embeddings[1, :, :].fill_(0)\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze()).data\n    correct_end_embeddings[1, :, :].fill_(0)\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.numpy())",
            "def test_masked_indices_are_handled_correctly(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    indices_mask = torch.tensor([[True, True], [False, False]])\n    span_representations = extractor(sequence_tensor, indices, span_indices_mask=indices_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    (start_indices, end_indices) = indices.split(1, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze()).data\n    correct_start_embeddings[1, :, :].fill_(0)\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze()).data\n    correct_end_embeddings[1, :, :].fill_(0)\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.numpy())",
            "def test_masked_indices_are_handled_correctly(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sequence_tensor = torch.randn([2, 5, 7])\n    extractor = EndpointSpanExtractor(7, 'x,y')\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [3, 4]]])\n    span_representations = extractor(sequence_tensor, indices)\n    indices_mask = torch.tensor([[True, True], [False, False]])\n    span_representations = extractor(sequence_tensor, indices, span_indices_mask=indices_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(7, -1)\n    (start_indices, end_indices) = indices.split(1, -1)\n    correct_start_embeddings = batched_index_select(sequence_tensor, start_indices.squeeze()).data\n    correct_start_embeddings[1, :, :].fill_(0)\n    correct_end_embeddings = batched_index_select(sequence_tensor, end_indices.squeeze()).data\n    correct_end_embeddings[1, :, :].fill_(0)\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.numpy())\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.numpy())"
        ]
    },
    {
        "func_name": "test_masked_indices_are_handled_correctly_with_exclusive_indices",
        "original": "def test_masked_indices_are_handled_correctly_with_exclusive_indices(self):\n    sequence_tensor = torch.randn([2, 5, 8])\n    extractor = EndpointSpanExtractor(8, 'x,y', use_exclusive_start_indices=True)\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [0, 1]]])\n    sequence_mask = torch.tensor([[True, True, True, True, True], [True, True, True, False, False]])\n    span_representations = extractor(sequence_tensor, indices, sequence_mask=sequence_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(8, -1)\n    correct_start_indices = torch.LongTensor([[0, 1], [-1, -1]])\n    correct_start_indices[1, 0] = 1\n    correct_start_indices[1, 1] = 1\n    correct_end_indices = torch.LongTensor([[3, 4], [2, 1]])\n    correct_start_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_start_indices)\n    correct_start_embeddings[1, 0] = extractor._start_sentinel.data\n    correct_start_embeddings[1, 1] = extractor._start_sentinel.data\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    correct_end_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_end_indices)\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
        "mutated": [
            "def test_masked_indices_are_handled_correctly_with_exclusive_indices(self):\n    if False:\n        i = 10\n    sequence_tensor = torch.randn([2, 5, 8])\n    extractor = EndpointSpanExtractor(8, 'x,y', use_exclusive_start_indices=True)\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [0, 1]]])\n    sequence_mask = torch.tensor([[True, True, True, True, True], [True, True, True, False, False]])\n    span_representations = extractor(sequence_tensor, indices, sequence_mask=sequence_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(8, -1)\n    correct_start_indices = torch.LongTensor([[0, 1], [-1, -1]])\n    correct_start_indices[1, 0] = 1\n    correct_start_indices[1, 1] = 1\n    correct_end_indices = torch.LongTensor([[3, 4], [2, 1]])\n    correct_start_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_start_indices)\n    correct_start_embeddings[1, 0] = extractor._start_sentinel.data\n    correct_start_embeddings[1, 1] = extractor._start_sentinel.data\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    correct_end_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_end_indices)\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
            "def test_masked_indices_are_handled_correctly_with_exclusive_indices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    sequence_tensor = torch.randn([2, 5, 8])\n    extractor = EndpointSpanExtractor(8, 'x,y', use_exclusive_start_indices=True)\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [0, 1]]])\n    sequence_mask = torch.tensor([[True, True, True, True, True], [True, True, True, False, False]])\n    span_representations = extractor(sequence_tensor, indices, sequence_mask=sequence_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(8, -1)\n    correct_start_indices = torch.LongTensor([[0, 1], [-1, -1]])\n    correct_start_indices[1, 0] = 1\n    correct_start_indices[1, 1] = 1\n    correct_end_indices = torch.LongTensor([[3, 4], [2, 1]])\n    correct_start_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_start_indices)\n    correct_start_embeddings[1, 0] = extractor._start_sentinel.data\n    correct_start_embeddings[1, 1] = extractor._start_sentinel.data\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    correct_end_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_end_indices)\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
            "def test_masked_indices_are_handled_correctly_with_exclusive_indices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    sequence_tensor = torch.randn([2, 5, 8])\n    extractor = EndpointSpanExtractor(8, 'x,y', use_exclusive_start_indices=True)\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [0, 1]]])\n    sequence_mask = torch.tensor([[True, True, True, True, True], [True, True, True, False, False]])\n    span_representations = extractor(sequence_tensor, indices, sequence_mask=sequence_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(8, -1)\n    correct_start_indices = torch.LongTensor([[0, 1], [-1, -1]])\n    correct_start_indices[1, 0] = 1\n    correct_start_indices[1, 1] = 1\n    correct_end_indices = torch.LongTensor([[3, 4], [2, 1]])\n    correct_start_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_start_indices)\n    correct_start_embeddings[1, 0] = extractor._start_sentinel.data\n    correct_start_embeddings[1, 1] = extractor._start_sentinel.data\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    correct_end_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_end_indices)\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
            "def test_masked_indices_are_handled_correctly_with_exclusive_indices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    sequence_tensor = torch.randn([2, 5, 8])\n    extractor = EndpointSpanExtractor(8, 'x,y', use_exclusive_start_indices=True)\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [0, 1]]])\n    sequence_mask = torch.tensor([[True, True, True, True, True], [True, True, True, False, False]])\n    span_representations = extractor(sequence_tensor, indices, sequence_mask=sequence_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(8, -1)\n    correct_start_indices = torch.LongTensor([[0, 1], [-1, -1]])\n    correct_start_indices[1, 0] = 1\n    correct_start_indices[1, 1] = 1\n    correct_end_indices = torch.LongTensor([[3, 4], [2, 1]])\n    correct_start_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_start_indices)\n    correct_start_embeddings[1, 0] = extractor._start_sentinel.data\n    correct_start_embeddings[1, 1] = extractor._start_sentinel.data\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    correct_end_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_end_indices)\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())",
            "def test_masked_indices_are_handled_correctly_with_exclusive_indices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    sequence_tensor = torch.randn([2, 5, 8])\n    extractor = EndpointSpanExtractor(8, 'x,y', use_exclusive_start_indices=True)\n    indices = torch.LongTensor([[[1, 3], [2, 4]], [[0, 2], [0, 1]]])\n    sequence_mask = torch.tensor([[True, True, True, True, True], [True, True, True, False, False]])\n    span_representations = extractor(sequence_tensor, indices, sequence_mask=sequence_mask)\n    (start_embeddings, end_embeddings) = span_representations.split(8, -1)\n    correct_start_indices = torch.LongTensor([[0, 1], [-1, -1]])\n    correct_start_indices[1, 0] = 1\n    correct_start_indices[1, 1] = 1\n    correct_end_indices = torch.LongTensor([[3, 4], [2, 1]])\n    correct_start_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_start_indices)\n    correct_start_embeddings[1, 0] = extractor._start_sentinel.data\n    correct_start_embeddings[1, 1] = extractor._start_sentinel.data\n    numpy.testing.assert_array_equal(start_embeddings.data.numpy(), correct_start_embeddings.data.numpy())\n    correct_end_embeddings = batched_index_select(sequence_tensor.contiguous(), correct_end_indices)\n    numpy.testing.assert_array_equal(end_embeddings.data.numpy(), correct_end_embeddings.data.numpy())"
        ]
    }
]