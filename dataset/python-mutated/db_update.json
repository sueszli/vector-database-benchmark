[
    {
        "func_name": "get_today_feedback",
        "original": "def get_today_feedback():\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(f'SELECT * FROM recommendation_feedback WHERE insertion_time > %(time_lower_bound)s;', {'time_lower_bound': int(datetime.now().timestamp()) - execute_interval})\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
        "mutated": [
            "def get_today_feedback():\n    if False:\n        i = 10\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(f'SELECT * FROM recommendation_feedback WHERE insertion_time > %(time_lower_bound)s;', {'time_lower_bound': int(datetime.now().timestamp()) - execute_interval})\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
            "def get_today_feedback():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(f'SELECT * FROM recommendation_feedback WHERE insertion_time > %(time_lower_bound)s;', {'time_lower_bound': int(datetime.now().timestamp()) - execute_interval})\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
            "def get_today_feedback():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(f'SELECT * FROM recommendation_feedback WHERE insertion_time > %(time_lower_bound)s;', {'time_lower_bound': int(datetime.now().timestamp()) - execute_interval})\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
            "def get_today_feedback():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(f'SELECT * FROM recommendation_feedback WHERE insertion_time > %(time_lower_bound)s;', {'time_lower_bound': int(datetime.now().timestamp()) - execute_interval})\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
            "def get_today_feedback():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(f'SELECT * FROM recommendation_feedback WHERE insertion_time > %(time_lower_bound)s;', {'time_lower_bound': int(datetime.now().timestamp()) - execute_interval})\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()"
        ]
    },
    {
        "func_name": "get_features_pg",
        "original": "def get_features_pg(ti):\n    os.environ['PG_POOL'] = 'true'\n    asyncio.run(pg_client.init())\n    sessionIds = ti.xcom_pull(key='sessionIds')\n    userIds = ti.xcom_pull(key='userIds').split(',')\n    with pg_client.PostgresClient() as conn:\n        conn.execute(\"SELECT T.project_id,\\n                                   T.session_id,\\n                                   T2.viewer_id,\\n                                   T.pages_count,\\n                                   T.events_count,\\n                                   T.errors_count,\\n                                   T.duration,\\n                                   T.country,\\n                                   T.issue_score,\\n                                   T.device_type,\\n                                   T2.replays,\\n                                   T2.network_access,\\n                                   T2.storage_access,\\n                                   T2.console_access,\\n                                   T2.stack_access\\n                            FROM (SELECT project_id,\\n                                         user_id                                                            as viewer_id,\\n                                         session_id,\\n                                         count(CASE WHEN source = 'replay' THEN 1 END) as replays,\\n                                         count(CASE WHEN source = 'network' THEN 1 END) as network_access,\\n                                         count(CASE WHEN source = 'storage' THEN 1 END) as storage_access,\\n                                         count(CASE WHEN source = 'console' THEN 1 END) as console_access,\\n                                         count(CASE WHEN source = 'stack_events' THEN 1 END) as stack_access\\n                                  FROM frontend_signals\\n                                  WHERE session_id IN ({sessionIds})\\n                                  GROUP BY project_id, viewer_id, session_id) as T2\\n                                     INNER JOIN (SELECT project_id,\\n                                                        session_id,\\n                                                        user_id,\\n                                                        pages_count,\\n                                                        events_count,\\n                                                        errors_count,\\n                                                        duration,\\n                                                        user_country     as country,\\n                                                        issue_score,\\n                                                        user_device_type as device_type\\n                                                 FROM sessions\\n                                                 WHERE session_id IN ({sessionIds})\\n                                                   AND duration IS NOT NULL) as T\\n                                                USING (session_id);\".format(sessionIds=sessionIds))\n        response = conn.fetchall()\n    sessionIds = [int(sessId) for sessId in sessionIds.split(',')]\n    df = pd.DataFrame(response)\n    df2 = pd.DataFrame(zip(userIds, sessionIds), columns=['viewer_id', 'session_id'])\n    base_query = f'INSERT INTO {features_table_name} (project_id, session_id, viewer_id, pages_count, events_count,\\n       issues_count, duration, country, issue_score, device_type,\\n       replays, network_access, storage_access, console_access,\\n       stack_access) VALUES '\n    count = 0\n    params = {}\n    for i in range(len(df)):\n        viewer = df['viewer_id'].iloc[i]\n        session = df['session_id'].iloc[i]\n        d = df2[df2['viewer_id'] == viewer]\n        x = d[d['session_id'] == session]\n        if len(x) > 0:\n            template = '('\n            for (k, v) in x.items():\n                params[f'{k}_{count}'] = v.values[0]\n                template += f's({k}_{count})%'\n            base_query += template + '), '\n            count += 1\n    base_query = base_query[:-2]\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(base_query, params)\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
        "mutated": [
            "def get_features_pg(ti):\n    if False:\n        i = 10\n    os.environ['PG_POOL'] = 'true'\n    asyncio.run(pg_client.init())\n    sessionIds = ti.xcom_pull(key='sessionIds')\n    userIds = ti.xcom_pull(key='userIds').split(',')\n    with pg_client.PostgresClient() as conn:\n        conn.execute(\"SELECT T.project_id,\\n                                   T.session_id,\\n                                   T2.viewer_id,\\n                                   T.pages_count,\\n                                   T.events_count,\\n                                   T.errors_count,\\n                                   T.duration,\\n                                   T.country,\\n                                   T.issue_score,\\n                                   T.device_type,\\n                                   T2.replays,\\n                                   T2.network_access,\\n                                   T2.storage_access,\\n                                   T2.console_access,\\n                                   T2.stack_access\\n                            FROM (SELECT project_id,\\n                                         user_id                                                            as viewer_id,\\n                                         session_id,\\n                                         count(CASE WHEN source = 'replay' THEN 1 END) as replays,\\n                                         count(CASE WHEN source = 'network' THEN 1 END) as network_access,\\n                                         count(CASE WHEN source = 'storage' THEN 1 END) as storage_access,\\n                                         count(CASE WHEN source = 'console' THEN 1 END) as console_access,\\n                                         count(CASE WHEN source = 'stack_events' THEN 1 END) as stack_access\\n                                  FROM frontend_signals\\n                                  WHERE session_id IN ({sessionIds})\\n                                  GROUP BY project_id, viewer_id, session_id) as T2\\n                                     INNER JOIN (SELECT project_id,\\n                                                        session_id,\\n                                                        user_id,\\n                                                        pages_count,\\n                                                        events_count,\\n                                                        errors_count,\\n                                                        duration,\\n                                                        user_country     as country,\\n                                                        issue_score,\\n                                                        user_device_type as device_type\\n                                                 FROM sessions\\n                                                 WHERE session_id IN ({sessionIds})\\n                                                   AND duration IS NOT NULL) as T\\n                                                USING (session_id);\".format(sessionIds=sessionIds))\n        response = conn.fetchall()\n    sessionIds = [int(sessId) for sessId in sessionIds.split(',')]\n    df = pd.DataFrame(response)\n    df2 = pd.DataFrame(zip(userIds, sessionIds), columns=['viewer_id', 'session_id'])\n    base_query = f'INSERT INTO {features_table_name} (project_id, session_id, viewer_id, pages_count, events_count,\\n       issues_count, duration, country, issue_score, device_type,\\n       replays, network_access, storage_access, console_access,\\n       stack_access) VALUES '\n    count = 0\n    params = {}\n    for i in range(len(df)):\n        viewer = df['viewer_id'].iloc[i]\n        session = df['session_id'].iloc[i]\n        d = df2[df2['viewer_id'] == viewer]\n        x = d[d['session_id'] == session]\n        if len(x) > 0:\n            template = '('\n            for (k, v) in x.items():\n                params[f'{k}_{count}'] = v.values[0]\n                template += f's({k}_{count})%'\n            base_query += template + '), '\n            count += 1\n    base_query = base_query[:-2]\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(base_query, params)\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
            "def get_features_pg(ti):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    os.environ['PG_POOL'] = 'true'\n    asyncio.run(pg_client.init())\n    sessionIds = ti.xcom_pull(key='sessionIds')\n    userIds = ti.xcom_pull(key='userIds').split(',')\n    with pg_client.PostgresClient() as conn:\n        conn.execute(\"SELECT T.project_id,\\n                                   T.session_id,\\n                                   T2.viewer_id,\\n                                   T.pages_count,\\n                                   T.events_count,\\n                                   T.errors_count,\\n                                   T.duration,\\n                                   T.country,\\n                                   T.issue_score,\\n                                   T.device_type,\\n                                   T2.replays,\\n                                   T2.network_access,\\n                                   T2.storage_access,\\n                                   T2.console_access,\\n                                   T2.stack_access\\n                            FROM (SELECT project_id,\\n                                         user_id                                                            as viewer_id,\\n                                         session_id,\\n                                         count(CASE WHEN source = 'replay' THEN 1 END) as replays,\\n                                         count(CASE WHEN source = 'network' THEN 1 END) as network_access,\\n                                         count(CASE WHEN source = 'storage' THEN 1 END) as storage_access,\\n                                         count(CASE WHEN source = 'console' THEN 1 END) as console_access,\\n                                         count(CASE WHEN source = 'stack_events' THEN 1 END) as stack_access\\n                                  FROM frontend_signals\\n                                  WHERE session_id IN ({sessionIds})\\n                                  GROUP BY project_id, viewer_id, session_id) as T2\\n                                     INNER JOIN (SELECT project_id,\\n                                                        session_id,\\n                                                        user_id,\\n                                                        pages_count,\\n                                                        events_count,\\n                                                        errors_count,\\n                                                        duration,\\n                                                        user_country     as country,\\n                                                        issue_score,\\n                                                        user_device_type as device_type\\n                                                 FROM sessions\\n                                                 WHERE session_id IN ({sessionIds})\\n                                                   AND duration IS NOT NULL) as T\\n                                                USING (session_id);\".format(sessionIds=sessionIds))\n        response = conn.fetchall()\n    sessionIds = [int(sessId) for sessId in sessionIds.split(',')]\n    df = pd.DataFrame(response)\n    df2 = pd.DataFrame(zip(userIds, sessionIds), columns=['viewer_id', 'session_id'])\n    base_query = f'INSERT INTO {features_table_name} (project_id, session_id, viewer_id, pages_count, events_count,\\n       issues_count, duration, country, issue_score, device_type,\\n       replays, network_access, storage_access, console_access,\\n       stack_access) VALUES '\n    count = 0\n    params = {}\n    for i in range(len(df)):\n        viewer = df['viewer_id'].iloc[i]\n        session = df['session_id'].iloc[i]\n        d = df2[df2['viewer_id'] == viewer]\n        x = d[d['session_id'] == session]\n        if len(x) > 0:\n            template = '('\n            for (k, v) in x.items():\n                params[f'{k}_{count}'] = v.values[0]\n                template += f's({k}_{count})%'\n            base_query += template + '), '\n            count += 1\n    base_query = base_query[:-2]\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(base_query, params)\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
            "def get_features_pg(ti):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    os.environ['PG_POOL'] = 'true'\n    asyncio.run(pg_client.init())\n    sessionIds = ti.xcom_pull(key='sessionIds')\n    userIds = ti.xcom_pull(key='userIds').split(',')\n    with pg_client.PostgresClient() as conn:\n        conn.execute(\"SELECT T.project_id,\\n                                   T.session_id,\\n                                   T2.viewer_id,\\n                                   T.pages_count,\\n                                   T.events_count,\\n                                   T.errors_count,\\n                                   T.duration,\\n                                   T.country,\\n                                   T.issue_score,\\n                                   T.device_type,\\n                                   T2.replays,\\n                                   T2.network_access,\\n                                   T2.storage_access,\\n                                   T2.console_access,\\n                                   T2.stack_access\\n                            FROM (SELECT project_id,\\n                                         user_id                                                            as viewer_id,\\n                                         session_id,\\n                                         count(CASE WHEN source = 'replay' THEN 1 END) as replays,\\n                                         count(CASE WHEN source = 'network' THEN 1 END) as network_access,\\n                                         count(CASE WHEN source = 'storage' THEN 1 END) as storage_access,\\n                                         count(CASE WHEN source = 'console' THEN 1 END) as console_access,\\n                                         count(CASE WHEN source = 'stack_events' THEN 1 END) as stack_access\\n                                  FROM frontend_signals\\n                                  WHERE session_id IN ({sessionIds})\\n                                  GROUP BY project_id, viewer_id, session_id) as T2\\n                                     INNER JOIN (SELECT project_id,\\n                                                        session_id,\\n                                                        user_id,\\n                                                        pages_count,\\n                                                        events_count,\\n                                                        errors_count,\\n                                                        duration,\\n                                                        user_country     as country,\\n                                                        issue_score,\\n                                                        user_device_type as device_type\\n                                                 FROM sessions\\n                                                 WHERE session_id IN ({sessionIds})\\n                                                   AND duration IS NOT NULL) as T\\n                                                USING (session_id);\".format(sessionIds=sessionIds))\n        response = conn.fetchall()\n    sessionIds = [int(sessId) for sessId in sessionIds.split(',')]\n    df = pd.DataFrame(response)\n    df2 = pd.DataFrame(zip(userIds, sessionIds), columns=['viewer_id', 'session_id'])\n    base_query = f'INSERT INTO {features_table_name} (project_id, session_id, viewer_id, pages_count, events_count,\\n       issues_count, duration, country, issue_score, device_type,\\n       replays, network_access, storage_access, console_access,\\n       stack_access) VALUES '\n    count = 0\n    params = {}\n    for i in range(len(df)):\n        viewer = df['viewer_id'].iloc[i]\n        session = df['session_id'].iloc[i]\n        d = df2[df2['viewer_id'] == viewer]\n        x = d[d['session_id'] == session]\n        if len(x) > 0:\n            template = '('\n            for (k, v) in x.items():\n                params[f'{k}_{count}'] = v.values[0]\n                template += f's({k}_{count})%'\n            base_query += template + '), '\n            count += 1\n    base_query = base_query[:-2]\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(base_query, params)\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
            "def get_features_pg(ti):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    os.environ['PG_POOL'] = 'true'\n    asyncio.run(pg_client.init())\n    sessionIds = ti.xcom_pull(key='sessionIds')\n    userIds = ti.xcom_pull(key='userIds').split(',')\n    with pg_client.PostgresClient() as conn:\n        conn.execute(\"SELECT T.project_id,\\n                                   T.session_id,\\n                                   T2.viewer_id,\\n                                   T.pages_count,\\n                                   T.events_count,\\n                                   T.errors_count,\\n                                   T.duration,\\n                                   T.country,\\n                                   T.issue_score,\\n                                   T.device_type,\\n                                   T2.replays,\\n                                   T2.network_access,\\n                                   T2.storage_access,\\n                                   T2.console_access,\\n                                   T2.stack_access\\n                            FROM (SELECT project_id,\\n                                         user_id                                                            as viewer_id,\\n                                         session_id,\\n                                         count(CASE WHEN source = 'replay' THEN 1 END) as replays,\\n                                         count(CASE WHEN source = 'network' THEN 1 END) as network_access,\\n                                         count(CASE WHEN source = 'storage' THEN 1 END) as storage_access,\\n                                         count(CASE WHEN source = 'console' THEN 1 END) as console_access,\\n                                         count(CASE WHEN source = 'stack_events' THEN 1 END) as stack_access\\n                                  FROM frontend_signals\\n                                  WHERE session_id IN ({sessionIds})\\n                                  GROUP BY project_id, viewer_id, session_id) as T2\\n                                     INNER JOIN (SELECT project_id,\\n                                                        session_id,\\n                                                        user_id,\\n                                                        pages_count,\\n                                                        events_count,\\n                                                        errors_count,\\n                                                        duration,\\n                                                        user_country     as country,\\n                                                        issue_score,\\n                                                        user_device_type as device_type\\n                                                 FROM sessions\\n                                                 WHERE session_id IN ({sessionIds})\\n                                                   AND duration IS NOT NULL) as T\\n                                                USING (session_id);\".format(sessionIds=sessionIds))\n        response = conn.fetchall()\n    sessionIds = [int(sessId) for sessId in sessionIds.split(',')]\n    df = pd.DataFrame(response)\n    df2 = pd.DataFrame(zip(userIds, sessionIds), columns=['viewer_id', 'session_id'])\n    base_query = f'INSERT INTO {features_table_name} (project_id, session_id, viewer_id, pages_count, events_count,\\n       issues_count, duration, country, issue_score, device_type,\\n       replays, network_access, storage_access, console_access,\\n       stack_access) VALUES '\n    count = 0\n    params = {}\n    for i in range(len(df)):\n        viewer = df['viewer_id'].iloc[i]\n        session = df['session_id'].iloc[i]\n        d = df2[df2['viewer_id'] == viewer]\n        x = d[d['session_id'] == session]\n        if len(x) > 0:\n            template = '('\n            for (k, v) in x.items():\n                params[f'{k}_{count}'] = v.values[0]\n                template += f's({k}_{count})%'\n            base_query += template + '), '\n            count += 1\n    base_query = base_query[:-2]\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(base_query, params)\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()",
            "def get_features_pg(ti):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    os.environ['PG_POOL'] = 'true'\n    asyncio.run(pg_client.init())\n    sessionIds = ti.xcom_pull(key='sessionIds')\n    userIds = ti.xcom_pull(key='userIds').split(',')\n    with pg_client.PostgresClient() as conn:\n        conn.execute(\"SELECT T.project_id,\\n                                   T.session_id,\\n                                   T2.viewer_id,\\n                                   T.pages_count,\\n                                   T.events_count,\\n                                   T.errors_count,\\n                                   T.duration,\\n                                   T.country,\\n                                   T.issue_score,\\n                                   T.device_type,\\n                                   T2.replays,\\n                                   T2.network_access,\\n                                   T2.storage_access,\\n                                   T2.console_access,\\n                                   T2.stack_access\\n                            FROM (SELECT project_id,\\n                                         user_id                                                            as viewer_id,\\n                                         session_id,\\n                                         count(CASE WHEN source = 'replay' THEN 1 END) as replays,\\n                                         count(CASE WHEN source = 'network' THEN 1 END) as network_access,\\n                                         count(CASE WHEN source = 'storage' THEN 1 END) as storage_access,\\n                                         count(CASE WHEN source = 'console' THEN 1 END) as console_access,\\n                                         count(CASE WHEN source = 'stack_events' THEN 1 END) as stack_access\\n                                  FROM frontend_signals\\n                                  WHERE session_id IN ({sessionIds})\\n                                  GROUP BY project_id, viewer_id, session_id) as T2\\n                                     INNER JOIN (SELECT project_id,\\n                                                        session_id,\\n                                                        user_id,\\n                                                        pages_count,\\n                                                        events_count,\\n                                                        errors_count,\\n                                                        duration,\\n                                                        user_country     as country,\\n                                                        issue_score,\\n                                                        user_device_type as device_type\\n                                                 FROM sessions\\n                                                 WHERE session_id IN ({sessionIds})\\n                                                   AND duration IS NOT NULL) as T\\n                                                USING (session_id);\".format(sessionIds=sessionIds))\n        response = conn.fetchall()\n    sessionIds = [int(sessId) for sessId in sessionIds.split(',')]\n    df = pd.DataFrame(response)\n    df2 = pd.DataFrame(zip(userIds, sessionIds), columns=['viewer_id', 'session_id'])\n    base_query = f'INSERT INTO {features_table_name} (project_id, session_id, viewer_id, pages_count, events_count,\\n       issues_count, duration, country, issue_score, device_type,\\n       replays, network_access, storage_access, console_access,\\n       stack_access) VALUES '\n    count = 0\n    params = {}\n    for i in range(len(df)):\n        viewer = df['viewer_id'].iloc[i]\n        session = df['session_id'].iloc[i]\n        d = df2[df2['viewer_id'] == viewer]\n        x = d[d['session_id'] == session]\n        if len(x) > 0:\n            template = '('\n            for (k, v) in x.items():\n                params[f'{k}_{count}'] = v.values[0]\n                template += f's({k}_{count})%'\n            base_query += template + '), '\n            count += 1\n    base_query = base_query[:-2]\n    connection_handler = ConnectionHandler(tracking_uri)\n    with connection_handler.get_live_session() as conn:\n        cur = conn.connection().connection.cursor()\n        query = cur.mogrify(base_query, params)\n        conn.execute(text(query.decode('utf-8')))\n        conn.commit()"
        ]
    }
]