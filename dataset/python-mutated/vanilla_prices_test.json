[
    {
        "func_name": "test_option_prices",
        "original": "def test_option_prices(self):\n    \"\"\"Tests that the BS prices are correct.\"\"\"\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.0480684764112578, 1.0002029716043364, 2.0730313058959933])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
        "mutated": [
            "def test_option_prices(self):\n    if False:\n        i = 10\n    'Tests that the BS prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.0480684764112578, 1.0002029716043364, 2.0730313058959933])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_option_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that the BS prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.0480684764112578, 1.0002029716043364, 2.0730313058959933])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_option_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that the BS prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.0480684764112578, 1.0002029716043364, 2.0730313058959933])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_option_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that the BS prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.0480684764112578, 1.0002029716043364, 2.0730313058959933])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_option_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that the BS prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.0480684764112578, 1.0002029716043364, 2.0730313058959933])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)"
        ]
    },
    {
        "func_name": "test_option_prices_normal",
        "original": "def test_option_prices_normal(self):\n    \"\"\"Tests that the prices using normal model are correct.\"\"\"\n    forwards = np.array([0.01, 0.02, 0.03, 0.03, 0.05])\n    strikes = np.array([0.03, 0.03, 0.03, 0.03, 0.03])\n    volatilities = np.array([0.0001, 0.001, 0.01, 0.005, 0.02])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_normal_volatility=True))\n    expected_prices = np.array([0.0, 0.0, 0.0039894228040143, 0.0019947114020072, 0.0216663094117537])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
        "mutated": [
            "def test_option_prices_normal(self):\n    if False:\n        i = 10\n    'Tests that the prices using normal model are correct.'\n    forwards = np.array([0.01, 0.02, 0.03, 0.03, 0.05])\n    strikes = np.array([0.03, 0.03, 0.03, 0.03, 0.03])\n    volatilities = np.array([0.0001, 0.001, 0.01, 0.005, 0.02])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_normal_volatility=True))\n    expected_prices = np.array([0.0, 0.0, 0.0039894228040143, 0.0019947114020072, 0.0216663094117537])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_option_prices_normal(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that the prices using normal model are correct.'\n    forwards = np.array([0.01, 0.02, 0.03, 0.03, 0.05])\n    strikes = np.array([0.03, 0.03, 0.03, 0.03, 0.03])\n    volatilities = np.array([0.0001, 0.001, 0.01, 0.005, 0.02])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_normal_volatility=True))\n    expected_prices = np.array([0.0, 0.0, 0.0039894228040143, 0.0019947114020072, 0.0216663094117537])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_option_prices_normal(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that the prices using normal model are correct.'\n    forwards = np.array([0.01, 0.02, 0.03, 0.03, 0.05])\n    strikes = np.array([0.03, 0.03, 0.03, 0.03, 0.03])\n    volatilities = np.array([0.0001, 0.001, 0.01, 0.005, 0.02])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_normal_volatility=True))\n    expected_prices = np.array([0.0, 0.0, 0.0039894228040143, 0.0019947114020072, 0.0216663094117537])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_option_prices_normal(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that the prices using normal model are correct.'\n    forwards = np.array([0.01, 0.02, 0.03, 0.03, 0.05])\n    strikes = np.array([0.03, 0.03, 0.03, 0.03, 0.03])\n    volatilities = np.array([0.0001, 0.001, 0.01, 0.005, 0.02])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_normal_volatility=True))\n    expected_prices = np.array([0.0, 0.0, 0.0039894228040143, 0.0019947114020072, 0.0216663094117537])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_option_prices_normal(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that the prices using normal model are correct.'\n    forwards = np.array([0.01, 0.02, 0.03, 0.03, 0.05])\n    strikes = np.array([0.03, 0.03, 0.03, 0.03, 0.03])\n    volatilities = np.array([0.0001, 0.001, 0.01, 0.005, 0.02])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_normal_volatility=True))\n    expected_prices = np.array([0.0, 0.0, 0.0039894228040143, 0.0019947114020072, 0.0216663094117537])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)"
        ]
    },
    {
        "func_name": "test_price_zero_vol",
        "original": "def test_price_zero_vol(self):\n    \"\"\"Tests that zero volatility is handled correctly.\"\"\"\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.0, 0.0, 0.0, 0.0])\n    expiries = 1.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
        "mutated": [
            "def test_price_zero_vol(self):\n    if False:\n        i = 10\n    'Tests that zero volatility is handled correctly.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.0, 0.0, 0.0, 0.0])\n    expiries = 1.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_zero_vol(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that zero volatility is handled correctly.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.0, 0.0, 0.0, 0.0])\n    expiries = 1.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_zero_vol(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that zero volatility is handled correctly.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.0, 0.0, 0.0, 0.0])\n    expiries = 1.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_zero_vol(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that zero volatility is handled correctly.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.0, 0.0, 0.0, 0.0])\n    expiries = 1.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_zero_vol(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that zero volatility is handled correctly.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.0, 0.0, 0.0, 0.0])\n    expiries = 1.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)"
        ]
    },
    {
        "func_name": "test_price_zero_expiry",
        "original": "def test_price_zero_expiry(self):\n    \"\"\"Tests that zero expiry is correctly handled.\"\"\"\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 0.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
        "mutated": [
            "def test_price_zero_expiry(self):\n    if False:\n        i = 10\n    'Tests that zero expiry is correctly handled.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 0.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_zero_expiry(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that zero expiry is correctly handled.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 0.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_zero_expiry(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that zero expiry is correctly handled.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 0.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_zero_expiry(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that zero expiry is correctly handled.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 0.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_zero_expiry(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that zero expiry is correctly handled.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 0.0\n    is_call_options = np.array([True, True, False, False])\n    expected_prices = np.array([0.0, 0.1, 0.1, 0.0])\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)"
        ]
    },
    {
        "func_name": "test_price_long_expiry_calls",
        "original": "def test_price_long_expiry_calls(self):\n    \"\"\"Tests that very long expiry call option behaves like the asset.\"\"\"\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = forwards\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
        "mutated": [
            "def test_price_long_expiry_calls(self):\n    if False:\n        i = 10\n    'Tests that very long expiry call option behaves like the asset.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = forwards\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_long_expiry_calls(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that very long expiry call option behaves like the asset.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = forwards\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_long_expiry_calls(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that very long expiry call option behaves like the asset.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = forwards\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_long_expiry_calls(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that very long expiry call option behaves like the asset.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = forwards\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_long_expiry_calls(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that very long expiry call option behaves like the asset.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([1.1, 0.9, 1.1, 0.9])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = forwards\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)"
        ]
    },
    {
        "func_name": "test_price_long_expiry_puts",
        "original": "def test_price_long_expiry_puts(self):\n    \"\"\"Tests that very long expiry put option is worth the strike.\"\"\"\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([0.1, 10.0, 3.0, 0.0001])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = strikes\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=False))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
        "mutated": [
            "def test_price_long_expiry_puts(self):\n    if False:\n        i = 10\n    'Tests that very long expiry put option is worth the strike.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([0.1, 10.0, 3.0, 0.0001])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = strikes\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=False))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_long_expiry_puts(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that very long expiry put option is worth the strike.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([0.1, 10.0, 3.0, 0.0001])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = strikes\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=False))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_long_expiry_puts(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that very long expiry put option is worth the strike.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([0.1, 10.0, 3.0, 0.0001])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = strikes\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=False))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_long_expiry_puts(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that very long expiry put option is worth the strike.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([0.1, 10.0, 3.0, 0.0001])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = strikes\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=False))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_price_long_expiry_puts(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that very long expiry put option is worth the strike.'\n    forwards = np.array([1.0, 1.0, 1.0, 1.0])\n    strikes = np.array([0.1, 10.0, 3.0, 0.0001])\n    volatilities = np.array([0.1, 0.2, 0.5, 0.9])\n    expiries = 10000000000.0\n    expected_prices = strikes\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=False))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)"
        ]
    },
    {
        "func_name": "test_price_vol_and_expiry_scaling",
        "original": "def test_price_vol_and_expiry_scaling(self):\n    \"\"\"Tests that the price is invariant under vol->k vol, T->T/k**2.\"\"\"\n    np.random.seed(1234)\n    n = 20\n    forwards = np.exp(np.random.randn(n))\n    volatilities = np.exp(np.random.randn(n) / 2)\n    strikes = np.exp(np.random.randn(n))\n    expiries = np.exp(np.random.randn(n))\n    scaling = 5.0\n    base_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    scaled_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities * scaling, strikes=strikes, expiries=expiries / scaling / scaling, forwards=forwards))\n    self.assertArrayNear(base_prices, scaled_prices, 1e-10)",
        "mutated": [
            "def test_price_vol_and_expiry_scaling(self):\n    if False:\n        i = 10\n    'Tests that the price is invariant under vol->k vol, T->T/k**2.'\n    np.random.seed(1234)\n    n = 20\n    forwards = np.exp(np.random.randn(n))\n    volatilities = np.exp(np.random.randn(n) / 2)\n    strikes = np.exp(np.random.randn(n))\n    expiries = np.exp(np.random.randn(n))\n    scaling = 5.0\n    base_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    scaled_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities * scaling, strikes=strikes, expiries=expiries / scaling / scaling, forwards=forwards))\n    self.assertArrayNear(base_prices, scaled_prices, 1e-10)",
            "def test_price_vol_and_expiry_scaling(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that the price is invariant under vol->k vol, T->T/k**2.'\n    np.random.seed(1234)\n    n = 20\n    forwards = np.exp(np.random.randn(n))\n    volatilities = np.exp(np.random.randn(n) / 2)\n    strikes = np.exp(np.random.randn(n))\n    expiries = np.exp(np.random.randn(n))\n    scaling = 5.0\n    base_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    scaled_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities * scaling, strikes=strikes, expiries=expiries / scaling / scaling, forwards=forwards))\n    self.assertArrayNear(base_prices, scaled_prices, 1e-10)",
            "def test_price_vol_and_expiry_scaling(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that the price is invariant under vol->k vol, T->T/k**2.'\n    np.random.seed(1234)\n    n = 20\n    forwards = np.exp(np.random.randn(n))\n    volatilities = np.exp(np.random.randn(n) / 2)\n    strikes = np.exp(np.random.randn(n))\n    expiries = np.exp(np.random.randn(n))\n    scaling = 5.0\n    base_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    scaled_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities * scaling, strikes=strikes, expiries=expiries / scaling / scaling, forwards=forwards))\n    self.assertArrayNear(base_prices, scaled_prices, 1e-10)",
            "def test_price_vol_and_expiry_scaling(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that the price is invariant under vol->k vol, T->T/k**2.'\n    np.random.seed(1234)\n    n = 20\n    forwards = np.exp(np.random.randn(n))\n    volatilities = np.exp(np.random.randn(n) / 2)\n    strikes = np.exp(np.random.randn(n))\n    expiries = np.exp(np.random.randn(n))\n    scaling = 5.0\n    base_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    scaled_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities * scaling, strikes=strikes, expiries=expiries / scaling / scaling, forwards=forwards))\n    self.assertArrayNear(base_prices, scaled_prices, 1e-10)",
            "def test_price_vol_and_expiry_scaling(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that the price is invariant under vol->k vol, T->T/k**2.'\n    np.random.seed(1234)\n    n = 20\n    forwards = np.exp(np.random.randn(n))\n    volatilities = np.exp(np.random.randn(n) / 2)\n    strikes = np.exp(np.random.randn(n))\n    expiries = np.exp(np.random.randn(n))\n    scaling = 5.0\n    base_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    scaled_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities * scaling, strikes=strikes, expiries=expiries / scaling / scaling, forwards=forwards))\n    self.assertArrayNear(base_prices, scaled_prices, 1e-10)"
        ]
    },
    {
        "func_name": "test_option_prices_detailed_discount",
        "original": "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_option_prices_detailed_discount(self, dtype):\n    \"\"\"Tests the prices with discount_rates.\"\"\"\n    spots = np.array([80.0, 90.0, 100.0, 110.0, 120.0] * 2)\n    strikes = np.array([100.0] * 10)\n    discount_rates = 0.08\n    volatilities = 0.2\n    expiries = 0.25\n    is_call_options = np.array([True] * 5 + [False] * 5)\n    dividend_rates = 0.12\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, dtype=dtype))\n    expected_prices = np.array([0.03, 0.57, 3.42, 9.85, 18.62, 20.41, 11.25, 4.4, 1.12, 0.18])\n    self.assertArrayNear(expected_prices, computed_prices, 0.005)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_option_prices_detailed_discount(self, dtype):\n    if False:\n        i = 10\n    'Tests the prices with discount_rates.'\n    spots = np.array([80.0, 90.0, 100.0, 110.0, 120.0] * 2)\n    strikes = np.array([100.0] * 10)\n    discount_rates = 0.08\n    volatilities = 0.2\n    expiries = 0.25\n    is_call_options = np.array([True] * 5 + [False] * 5)\n    dividend_rates = 0.12\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, dtype=dtype))\n    expected_prices = np.array([0.03, 0.57, 3.42, 9.85, 18.62, 20.41, 11.25, 4.4, 1.12, 0.18])\n    self.assertArrayNear(expected_prices, computed_prices, 0.005)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_option_prices_detailed_discount(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the prices with discount_rates.'\n    spots = np.array([80.0, 90.0, 100.0, 110.0, 120.0] * 2)\n    strikes = np.array([100.0] * 10)\n    discount_rates = 0.08\n    volatilities = 0.2\n    expiries = 0.25\n    is_call_options = np.array([True] * 5 + [False] * 5)\n    dividend_rates = 0.12\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, dtype=dtype))\n    expected_prices = np.array([0.03, 0.57, 3.42, 9.85, 18.62, 20.41, 11.25, 4.4, 1.12, 0.18])\n    self.assertArrayNear(expected_prices, computed_prices, 0.005)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_option_prices_detailed_discount(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the prices with discount_rates.'\n    spots = np.array([80.0, 90.0, 100.0, 110.0, 120.0] * 2)\n    strikes = np.array([100.0] * 10)\n    discount_rates = 0.08\n    volatilities = 0.2\n    expiries = 0.25\n    is_call_options = np.array([True] * 5 + [False] * 5)\n    dividend_rates = 0.12\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, dtype=dtype))\n    expected_prices = np.array([0.03, 0.57, 3.42, 9.85, 18.62, 20.41, 11.25, 4.4, 1.12, 0.18])\n    self.assertArrayNear(expected_prices, computed_prices, 0.005)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_option_prices_detailed_discount(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the prices with discount_rates.'\n    spots = np.array([80.0, 90.0, 100.0, 110.0, 120.0] * 2)\n    strikes = np.array([100.0] * 10)\n    discount_rates = 0.08\n    volatilities = 0.2\n    expiries = 0.25\n    is_call_options = np.array([True] * 5 + [False] * 5)\n    dividend_rates = 0.12\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, dtype=dtype))\n    expected_prices = np.array([0.03, 0.57, 3.42, 9.85, 18.62, 20.41, 11.25, 4.4, 1.12, 0.18])\n    self.assertArrayNear(expected_prices, computed_prices, 0.005)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_option_prices_detailed_discount(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the prices with discount_rates.'\n    spots = np.array([80.0, 90.0, 100.0, 110.0, 120.0] * 2)\n    strikes = np.array([100.0] * 10)\n    discount_rates = 0.08\n    volatilities = 0.2\n    expiries = 0.25\n    is_call_options = np.array([True] * 5 + [False] * 5)\n    dividend_rates = 0.12\n    computed_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, dtype=dtype))\n    expected_prices = np.array([0.03, 0.57, 3.42, 9.85, 18.62, 20.41, 11.25, 4.4, 1.12, 0.18])\n    self.assertArrayNear(expected_prices, computed_prices, 0.005)"
        ]
    },
    {
        "func_name": "test_binary_prices",
        "original": "def test_binary_prices(self):\n    \"\"\"Tests that the BS binary option prices are correct.\"\"\"\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 0.0, 0.15865525, 0.99764937, 0.85927418])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)",
        "mutated": [
            "def test_binary_prices(self):\n    if False:\n        i = 10\n    'Tests that the BS binary option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 0.0, 0.15865525, 0.99764937, 0.85927418])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)",
            "def test_binary_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that the BS binary option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 0.0, 0.15865525, 0.99764937, 0.85927418])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)",
            "def test_binary_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that the BS binary option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 0.0, 0.15865525, 0.99764937, 0.85927418])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)",
            "def test_binary_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that the BS binary option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 0.0, 0.15865525, 0.99764937, 0.85927418])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)",
            "def test_binary_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that the BS binary option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 0.0, 0.15865525, 0.99764937, 0.85927418])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)"
        ]
    },
    {
        "func_name": "test_binary_prices_bulk",
        "original": "def test_binary_prices_bulk(self):\n    \"\"\"Tests unit of cash binary option pricing over a wide range of settings.\n\n    Uses the fact that if the underlying follows a geometric brownian motion\n    then, given the mean on the exponential scale and the variance on the log\n    scale, the mean on the log scale is known. In particular for underlying S\n    with forward price F, strike K, volatility sig, and expiry T:\n\n    log(S) ~ N(log(F) - sig^2 T, sig^2 T)\n\n    The price of the binary call option is the discounted probability that S\n    will be greater than K at expiry (and for a put option, less than K). Since\n    quantiles are preserved under monotonic transformations we can find this\n    probability on the log scale. This provides an alternate calculation for the\n    same price which we can use to corroborate the standard method.\n    \"\"\"\n    np.random.seed(321)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    log_scale = np.sqrt(expiries) * volatilities\n    log_loc = np.log(forwards) - 0.5 * log_scale ** 2\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n    cdf_values = self.evaluate(tfp.distributions.Normal(loc=log_loc, scale=log_scale).cdf(np.log(strikes)))\n    expected_prices = discount_factors * (call_options + (-1.0) ** call_options * cdf_values)\n    is_call_options = np.array(call_options, dtype=bool)\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
        "mutated": [
            "def test_binary_prices_bulk(self):\n    if False:\n        i = 10\n    'Tests unit of cash binary option pricing over a wide range of settings.\\n\\n    Uses the fact that if the underlying follows a geometric brownian motion\\n    then, given the mean on the exponential scale and the variance on the log\\n    scale, the mean on the log scale is known. In particular for underlying S\\n    with forward price F, strike K, volatility sig, and expiry T:\\n\\n    log(S) ~ N(log(F) - sig^2 T, sig^2 T)\\n\\n    The price of the binary call option is the discounted probability that S\\n    will be greater than K at expiry (and for a put option, less than K). Since\\n    quantiles are preserved under monotonic transformations we can find this\\n    probability on the log scale. This provides an alternate calculation for the\\n    same price which we can use to corroborate the standard method.\\n    '\n    np.random.seed(321)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    log_scale = np.sqrt(expiries) * volatilities\n    log_loc = np.log(forwards) - 0.5 * log_scale ** 2\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n    cdf_values = self.evaluate(tfp.distributions.Normal(loc=log_loc, scale=log_scale).cdf(np.log(strikes)))\n    expected_prices = discount_factors * (call_options + (-1.0) ** call_options * cdf_values)\n    is_call_options = np.array(call_options, dtype=bool)\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_binary_prices_bulk(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests unit of cash binary option pricing over a wide range of settings.\\n\\n    Uses the fact that if the underlying follows a geometric brownian motion\\n    then, given the mean on the exponential scale and the variance on the log\\n    scale, the mean on the log scale is known. In particular for underlying S\\n    with forward price F, strike K, volatility sig, and expiry T:\\n\\n    log(S) ~ N(log(F) - sig^2 T, sig^2 T)\\n\\n    The price of the binary call option is the discounted probability that S\\n    will be greater than K at expiry (and for a put option, less than K). Since\\n    quantiles are preserved under monotonic transformations we can find this\\n    probability on the log scale. This provides an alternate calculation for the\\n    same price which we can use to corroborate the standard method.\\n    '\n    np.random.seed(321)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    log_scale = np.sqrt(expiries) * volatilities\n    log_loc = np.log(forwards) - 0.5 * log_scale ** 2\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n    cdf_values = self.evaluate(tfp.distributions.Normal(loc=log_loc, scale=log_scale).cdf(np.log(strikes)))\n    expected_prices = discount_factors * (call_options + (-1.0) ** call_options * cdf_values)\n    is_call_options = np.array(call_options, dtype=bool)\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_binary_prices_bulk(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests unit of cash binary option pricing over a wide range of settings.\\n\\n    Uses the fact that if the underlying follows a geometric brownian motion\\n    then, given the mean on the exponential scale and the variance on the log\\n    scale, the mean on the log scale is known. In particular for underlying S\\n    with forward price F, strike K, volatility sig, and expiry T:\\n\\n    log(S) ~ N(log(F) - sig^2 T, sig^2 T)\\n\\n    The price of the binary call option is the discounted probability that S\\n    will be greater than K at expiry (and for a put option, less than K). Since\\n    quantiles are preserved under monotonic transformations we can find this\\n    probability on the log scale. This provides an alternate calculation for the\\n    same price which we can use to corroborate the standard method.\\n    '\n    np.random.seed(321)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    log_scale = np.sqrt(expiries) * volatilities\n    log_loc = np.log(forwards) - 0.5 * log_scale ** 2\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n    cdf_values = self.evaluate(tfp.distributions.Normal(loc=log_loc, scale=log_scale).cdf(np.log(strikes)))\n    expected_prices = discount_factors * (call_options + (-1.0) ** call_options * cdf_values)\n    is_call_options = np.array(call_options, dtype=bool)\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_binary_prices_bulk(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests unit of cash binary option pricing over a wide range of settings.\\n\\n    Uses the fact that if the underlying follows a geometric brownian motion\\n    then, given the mean on the exponential scale and the variance on the log\\n    scale, the mean on the log scale is known. In particular for underlying S\\n    with forward price F, strike K, volatility sig, and expiry T:\\n\\n    log(S) ~ N(log(F) - sig^2 T, sig^2 T)\\n\\n    The price of the binary call option is the discounted probability that S\\n    will be greater than K at expiry (and for a put option, less than K). Since\\n    quantiles are preserved under monotonic transformations we can find this\\n    probability on the log scale. This provides an alternate calculation for the\\n    same price which we can use to corroborate the standard method.\\n    '\n    np.random.seed(321)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    log_scale = np.sqrt(expiries) * volatilities\n    log_loc = np.log(forwards) - 0.5 * log_scale ** 2\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n    cdf_values = self.evaluate(tfp.distributions.Normal(loc=log_loc, scale=log_scale).cdf(np.log(strikes)))\n    expected_prices = discount_factors * (call_options + (-1.0) ** call_options * cdf_values)\n    is_call_options = np.array(call_options, dtype=bool)\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)",
            "def test_binary_prices_bulk(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests unit of cash binary option pricing over a wide range of settings.\\n\\n    Uses the fact that if the underlying follows a geometric brownian motion\\n    then, given the mean on the exponential scale and the variance on the log\\n    scale, the mean on the log scale is known. In particular for underlying S\\n    with forward price F, strike K, volatility sig, and expiry T:\\n\\n    log(S) ~ N(log(F) - sig^2 T, sig^2 T)\\n\\n    The price of the binary call option is the discounted probability that S\\n    will be greater than K at expiry (and for a put option, less than K). Since\\n    quantiles are preserved under monotonic transformations we can find this\\n    probability on the log scale. This provides an alternate calculation for the\\n    same price which we can use to corroborate the standard method.\\n    '\n    np.random.seed(321)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    log_scale = np.sqrt(expiries) * volatilities\n    log_loc = np.log(forwards) - 0.5 * log_scale ** 2\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n    cdf_values = self.evaluate(tfp.distributions.Normal(loc=log_loc, scale=log_scale).cdf(np.log(strikes)))\n    expected_prices = discount_factors * (call_options + (-1.0) ** call_options * cdf_values)\n    is_call_options = np.array(call_options, dtype=bool)\n    computed_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(expected_prices, computed_prices, 1e-10)"
        ]
    },
    {
        "func_name": "test_binary_vanilla_call_consistency",
        "original": "def test_binary_vanilla_call_consistency(self):\n    \"\"\"Tests code consistency through relationship of binary and vanilla prices.\n\n    With forward F, strike K, discount rate r, and expiry T, a vanilla call\n    option should have price CV:\n\n    $$ VC(K) = e^{-rT}( N(d_1)F - N(d_2)K ) $$\n\n    A unit of cash paying binary call option should have price BC:\n\n    $$ BC(K) = e^{-rT} N(d_2) $$\n\n    Where d_1 and d_2 are standard Black-Scholes quanitities and depend on K\n    through the ratio F/K. Hence for a small increment e:\n\n    $$ (VC(K + e) - Vc(K))/e \\\\approx -N(d_2)e^{-rT} = -BC(K + e) $$\n\n    Similarly, for a vanilla put:\n\n    $$ (VP(K + e) - VP(K))/e \\\\approx N(-d_2)e^{-rT} = BP(K + e) $$\n\n    This enables a test for consistency of pricing between vanilla and binary\n    options prices.\n    \"\"\"\n    np.random.seed(135)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes_0 = np.exp(np.random.normal(size=num_examples))\n    epsilon = 1e-08\n    strikes_1 = strikes_0 + epsilon\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    discount_factors = np.ones_like(forwards)\n    option_prices_0 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_0, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    option_prices_1 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    binary_approximation = (-1.0) ** call_options * (option_prices_1 - option_prices_0) / epsilon\n    binary_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(binary_approximation, binary_prices, 1e-06)",
        "mutated": [
            "def test_binary_vanilla_call_consistency(self):\n    if False:\n        i = 10\n    'Tests code consistency through relationship of binary and vanilla prices.\\n\\n    With forward F, strike K, discount rate r, and expiry T, a vanilla call\\n    option should have price CV:\\n\\n    $$ VC(K) = e^{-rT}( N(d_1)F - N(d_2)K ) $$\\n\\n    A unit of cash paying binary call option should have price BC:\\n\\n    $$ BC(K) = e^{-rT} N(d_2) $$\\n\\n    Where d_1 and d_2 are standard Black-Scholes quanitities and depend on K\\n    through the ratio F/K. Hence for a small increment e:\\n\\n    $$ (VC(K + e) - Vc(K))/e \\\\approx -N(d_2)e^{-rT} = -BC(K + e) $$\\n\\n    Similarly, for a vanilla put:\\n\\n    $$ (VP(K + e) - VP(K))/e \\\\approx N(-d_2)e^{-rT} = BP(K + e) $$\\n\\n    This enables a test for consistency of pricing between vanilla and binary\\n    options prices.\\n    '\n    np.random.seed(135)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes_0 = np.exp(np.random.normal(size=num_examples))\n    epsilon = 1e-08\n    strikes_1 = strikes_0 + epsilon\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    discount_factors = np.ones_like(forwards)\n    option_prices_0 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_0, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    option_prices_1 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    binary_approximation = (-1.0) ** call_options * (option_prices_1 - option_prices_0) / epsilon\n    binary_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(binary_approximation, binary_prices, 1e-06)",
            "def test_binary_vanilla_call_consistency(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests code consistency through relationship of binary and vanilla prices.\\n\\n    With forward F, strike K, discount rate r, and expiry T, a vanilla call\\n    option should have price CV:\\n\\n    $$ VC(K) = e^{-rT}( N(d_1)F - N(d_2)K ) $$\\n\\n    A unit of cash paying binary call option should have price BC:\\n\\n    $$ BC(K) = e^{-rT} N(d_2) $$\\n\\n    Where d_1 and d_2 are standard Black-Scholes quanitities and depend on K\\n    through the ratio F/K. Hence for a small increment e:\\n\\n    $$ (VC(K + e) - Vc(K))/e \\\\approx -N(d_2)e^{-rT} = -BC(K + e) $$\\n\\n    Similarly, for a vanilla put:\\n\\n    $$ (VP(K + e) - VP(K))/e \\\\approx N(-d_2)e^{-rT} = BP(K + e) $$\\n\\n    This enables a test for consistency of pricing between vanilla and binary\\n    options prices.\\n    '\n    np.random.seed(135)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes_0 = np.exp(np.random.normal(size=num_examples))\n    epsilon = 1e-08\n    strikes_1 = strikes_0 + epsilon\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    discount_factors = np.ones_like(forwards)\n    option_prices_0 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_0, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    option_prices_1 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    binary_approximation = (-1.0) ** call_options * (option_prices_1 - option_prices_0) / epsilon\n    binary_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(binary_approximation, binary_prices, 1e-06)",
            "def test_binary_vanilla_call_consistency(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests code consistency through relationship of binary and vanilla prices.\\n\\n    With forward F, strike K, discount rate r, and expiry T, a vanilla call\\n    option should have price CV:\\n\\n    $$ VC(K) = e^{-rT}( N(d_1)F - N(d_2)K ) $$\\n\\n    A unit of cash paying binary call option should have price BC:\\n\\n    $$ BC(K) = e^{-rT} N(d_2) $$\\n\\n    Where d_1 and d_2 are standard Black-Scholes quanitities and depend on K\\n    through the ratio F/K. Hence for a small increment e:\\n\\n    $$ (VC(K + e) - Vc(K))/e \\\\approx -N(d_2)e^{-rT} = -BC(K + e) $$\\n\\n    Similarly, for a vanilla put:\\n\\n    $$ (VP(K + e) - VP(K))/e \\\\approx N(-d_2)e^{-rT} = BP(K + e) $$\\n\\n    This enables a test for consistency of pricing between vanilla and binary\\n    options prices.\\n    '\n    np.random.seed(135)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes_0 = np.exp(np.random.normal(size=num_examples))\n    epsilon = 1e-08\n    strikes_1 = strikes_0 + epsilon\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    discount_factors = np.ones_like(forwards)\n    option_prices_0 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_0, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    option_prices_1 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    binary_approximation = (-1.0) ** call_options * (option_prices_1 - option_prices_0) / epsilon\n    binary_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(binary_approximation, binary_prices, 1e-06)",
            "def test_binary_vanilla_call_consistency(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests code consistency through relationship of binary and vanilla prices.\\n\\n    With forward F, strike K, discount rate r, and expiry T, a vanilla call\\n    option should have price CV:\\n\\n    $$ VC(K) = e^{-rT}( N(d_1)F - N(d_2)K ) $$\\n\\n    A unit of cash paying binary call option should have price BC:\\n\\n    $$ BC(K) = e^{-rT} N(d_2) $$\\n\\n    Where d_1 and d_2 are standard Black-Scholes quanitities and depend on K\\n    through the ratio F/K. Hence for a small increment e:\\n\\n    $$ (VC(K + e) - Vc(K))/e \\\\approx -N(d_2)e^{-rT} = -BC(K + e) $$\\n\\n    Similarly, for a vanilla put:\\n\\n    $$ (VP(K + e) - VP(K))/e \\\\approx N(-d_2)e^{-rT} = BP(K + e) $$\\n\\n    This enables a test for consistency of pricing between vanilla and binary\\n    options prices.\\n    '\n    np.random.seed(135)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes_0 = np.exp(np.random.normal(size=num_examples))\n    epsilon = 1e-08\n    strikes_1 = strikes_0 + epsilon\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    discount_factors = np.ones_like(forwards)\n    option_prices_0 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_0, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    option_prices_1 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    binary_approximation = (-1.0) ** call_options * (option_prices_1 - option_prices_0) / epsilon\n    binary_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(binary_approximation, binary_prices, 1e-06)",
            "def test_binary_vanilla_call_consistency(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests code consistency through relationship of binary and vanilla prices.\\n\\n    With forward F, strike K, discount rate r, and expiry T, a vanilla call\\n    option should have price CV:\\n\\n    $$ VC(K) = e^{-rT}( N(d_1)F - N(d_2)K ) $$\\n\\n    A unit of cash paying binary call option should have price BC:\\n\\n    $$ BC(K) = e^{-rT} N(d_2) $$\\n\\n    Where d_1 and d_2 are standard Black-Scholes quanitities and depend on K\\n    through the ratio F/K. Hence for a small increment e:\\n\\n    $$ (VC(K + e) - Vc(K))/e \\\\approx -N(d_2)e^{-rT} = -BC(K + e) $$\\n\\n    Similarly, for a vanilla put:\\n\\n    $$ (VP(K + e) - VP(K))/e \\\\approx N(-d_2)e^{-rT} = BP(K + e) $$\\n\\n    This enables a test for consistency of pricing between vanilla and binary\\n    options prices.\\n    '\n    np.random.seed(135)\n    num_examples = 1000\n    forwards = np.exp(np.random.normal(size=num_examples))\n    strikes_0 = np.exp(np.random.normal(size=num_examples))\n    epsilon = 1e-08\n    strikes_1 = strikes_0 + epsilon\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    discount_factors = np.ones_like(forwards)\n    option_prices_0 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_0, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    option_prices_1 = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    binary_approximation = (-1.0) ** call_options * (option_prices_1 - option_prices_0) / epsilon\n    binary_prices = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes_1, expiries=expiries, forwards=forwards, is_call_options=is_call_options, discount_factors=discount_factors))\n    self.assertArrayNear(binary_approximation, binary_prices, 1e-06)"
        ]
    },
    {
        "func_name": "test_binary_vanilla_consistency_exact",
        "original": "def test_binary_vanilla_consistency_exact(self):\n    \"\"\"Tests that the binary price is the negative gradient of vanilla price.\"\"\"\n    dtype = np.float64\n    strikes = tf.constant([1.0, 2.0], dtype=dtype)\n    spots = tf.constant([1.5, 1.5], dtype=dtype)\n    expiries = tf.constant([2.1, 1.3], dtype=dtype)\n    discount_rates = tf.constant([0.03, 0.04], dtype=dtype)\n    discount_factors = tf.exp(-discount_rates * expiries)\n    is_call_options = tf.constant([True, False])\n    volatilities = tf.constant([0.3, 0.4], dtype=dtype)\n    actual_binary_price = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options))\n    price_fn = functools.partial(tff.black_scholes.option_price, volatilities=volatilities, spots=spots, expiries=expiries, discount_rates=discount_rates, is_call_options=is_call_options)\n    implied_binary_price = tff.math.fwd_gradient(lambda x: price_fn(strikes=x), strikes)\n    implied_binary_price = self.evaluate(tf.where(is_call_options, -implied_binary_price, implied_binary_price))\n    self.assertArrayNear(implied_binary_price, actual_binary_price, 1e-10)",
        "mutated": [
            "def test_binary_vanilla_consistency_exact(self):\n    if False:\n        i = 10\n    'Tests that the binary price is the negative gradient of vanilla price.'\n    dtype = np.float64\n    strikes = tf.constant([1.0, 2.0], dtype=dtype)\n    spots = tf.constant([1.5, 1.5], dtype=dtype)\n    expiries = tf.constant([2.1, 1.3], dtype=dtype)\n    discount_rates = tf.constant([0.03, 0.04], dtype=dtype)\n    discount_factors = tf.exp(-discount_rates * expiries)\n    is_call_options = tf.constant([True, False])\n    volatilities = tf.constant([0.3, 0.4], dtype=dtype)\n    actual_binary_price = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options))\n    price_fn = functools.partial(tff.black_scholes.option_price, volatilities=volatilities, spots=spots, expiries=expiries, discount_rates=discount_rates, is_call_options=is_call_options)\n    implied_binary_price = tff.math.fwd_gradient(lambda x: price_fn(strikes=x), strikes)\n    implied_binary_price = self.evaluate(tf.where(is_call_options, -implied_binary_price, implied_binary_price))\n    self.assertArrayNear(implied_binary_price, actual_binary_price, 1e-10)",
            "def test_binary_vanilla_consistency_exact(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that the binary price is the negative gradient of vanilla price.'\n    dtype = np.float64\n    strikes = tf.constant([1.0, 2.0], dtype=dtype)\n    spots = tf.constant([1.5, 1.5], dtype=dtype)\n    expiries = tf.constant([2.1, 1.3], dtype=dtype)\n    discount_rates = tf.constant([0.03, 0.04], dtype=dtype)\n    discount_factors = tf.exp(-discount_rates * expiries)\n    is_call_options = tf.constant([True, False])\n    volatilities = tf.constant([0.3, 0.4], dtype=dtype)\n    actual_binary_price = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options))\n    price_fn = functools.partial(tff.black_scholes.option_price, volatilities=volatilities, spots=spots, expiries=expiries, discount_rates=discount_rates, is_call_options=is_call_options)\n    implied_binary_price = tff.math.fwd_gradient(lambda x: price_fn(strikes=x), strikes)\n    implied_binary_price = self.evaluate(tf.where(is_call_options, -implied_binary_price, implied_binary_price))\n    self.assertArrayNear(implied_binary_price, actual_binary_price, 1e-10)",
            "def test_binary_vanilla_consistency_exact(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that the binary price is the negative gradient of vanilla price.'\n    dtype = np.float64\n    strikes = tf.constant([1.0, 2.0], dtype=dtype)\n    spots = tf.constant([1.5, 1.5], dtype=dtype)\n    expiries = tf.constant([2.1, 1.3], dtype=dtype)\n    discount_rates = tf.constant([0.03, 0.04], dtype=dtype)\n    discount_factors = tf.exp(-discount_rates * expiries)\n    is_call_options = tf.constant([True, False])\n    volatilities = tf.constant([0.3, 0.4], dtype=dtype)\n    actual_binary_price = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options))\n    price_fn = functools.partial(tff.black_scholes.option_price, volatilities=volatilities, spots=spots, expiries=expiries, discount_rates=discount_rates, is_call_options=is_call_options)\n    implied_binary_price = tff.math.fwd_gradient(lambda x: price_fn(strikes=x), strikes)\n    implied_binary_price = self.evaluate(tf.where(is_call_options, -implied_binary_price, implied_binary_price))\n    self.assertArrayNear(implied_binary_price, actual_binary_price, 1e-10)",
            "def test_binary_vanilla_consistency_exact(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that the binary price is the negative gradient of vanilla price.'\n    dtype = np.float64\n    strikes = tf.constant([1.0, 2.0], dtype=dtype)\n    spots = tf.constant([1.5, 1.5], dtype=dtype)\n    expiries = tf.constant([2.1, 1.3], dtype=dtype)\n    discount_rates = tf.constant([0.03, 0.04], dtype=dtype)\n    discount_factors = tf.exp(-discount_rates * expiries)\n    is_call_options = tf.constant([True, False])\n    volatilities = tf.constant([0.3, 0.4], dtype=dtype)\n    actual_binary_price = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options))\n    price_fn = functools.partial(tff.black_scholes.option_price, volatilities=volatilities, spots=spots, expiries=expiries, discount_rates=discount_rates, is_call_options=is_call_options)\n    implied_binary_price = tff.math.fwd_gradient(lambda x: price_fn(strikes=x), strikes)\n    implied_binary_price = self.evaluate(tf.where(is_call_options, -implied_binary_price, implied_binary_price))\n    self.assertArrayNear(implied_binary_price, actual_binary_price, 1e-10)",
            "def test_binary_vanilla_consistency_exact(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that the binary price is the negative gradient of vanilla price.'\n    dtype = np.float64\n    strikes = tf.constant([1.0, 2.0], dtype=dtype)\n    spots = tf.constant([1.5, 1.5], dtype=dtype)\n    expiries = tf.constant([2.1, 1.3], dtype=dtype)\n    discount_rates = tf.constant([0.03, 0.04], dtype=dtype)\n    discount_factors = tf.exp(-discount_rates * expiries)\n    is_call_options = tf.constant([True, False])\n    volatilities = tf.constant([0.3, 0.4], dtype=dtype)\n    actual_binary_price = self.evaluate(tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_factors=discount_factors, is_call_options=is_call_options))\n    price_fn = functools.partial(tff.black_scholes.option_price, volatilities=volatilities, spots=spots, expiries=expiries, discount_rates=discount_rates, is_call_options=is_call_options)\n    implied_binary_price = tff.math.fwd_gradient(lambda x: price_fn(strikes=x), strikes)\n    implied_binary_price = self.evaluate(tf.where(is_call_options, -implied_binary_price, implied_binary_price))\n    self.assertArrayNear(implied_binary_price, actual_binary_price, 1e-10)"
        ]
    },
    {
        "func_name": "test_asset_or_nothing_prices",
        "original": "def test_asset_or_nothing_prices(self):\n    \"\"\"Tests that the BS asset-or-nothing option prices are correct.\"\"\"\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.52403424, 3.99315108, 4.65085383])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)\n    is_call_options = True\n    vanilla_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    cash_or_nothing_prices = self.evaluate(strikes * tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    asset_or_nothing_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(vanilla_prices, asset_or_nothing_prices - cash_or_nothing_prices, 1e-10)",
        "mutated": [
            "def test_asset_or_nothing_prices(self):\n    if False:\n        i = 10\n    'Tests that the BS asset-or-nothing option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.52403424, 3.99315108, 4.65085383])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)\n    is_call_options = True\n    vanilla_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    cash_or_nothing_prices = self.evaluate(strikes * tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    asset_or_nothing_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(vanilla_prices, asset_or_nothing_prices - cash_or_nothing_prices, 1e-10)",
            "def test_asset_or_nothing_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that the BS asset-or-nothing option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.52403424, 3.99315108, 4.65085383])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)\n    is_call_options = True\n    vanilla_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    cash_or_nothing_prices = self.evaluate(strikes * tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    asset_or_nothing_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(vanilla_prices, asset_or_nothing_prices - cash_or_nothing_prices, 1e-10)",
            "def test_asset_or_nothing_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that the BS asset-or-nothing option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.52403424, 3.99315108, 4.65085383])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)\n    is_call_options = True\n    vanilla_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    cash_or_nothing_prices = self.evaluate(strikes * tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    asset_or_nothing_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(vanilla_prices, asset_or_nothing_prices - cash_or_nothing_prices, 1e-10)",
            "def test_asset_or_nothing_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that the BS asset-or-nothing option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.52403424, 3.99315108, 4.65085383])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)\n    is_call_options = True\n    vanilla_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    cash_or_nothing_prices = self.evaluate(strikes * tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    asset_or_nothing_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(vanilla_prices, asset_or_nothing_prices - cash_or_nothing_prices, 1e-10)",
            "def test_asset_or_nothing_prices(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that the BS asset-or-nothing option prices are correct.'\n    forwards = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    strikes = np.array([3.0, 3.0, 3.0, 3.0, 3.0])\n    volatilities = np.array([0.0001, 102.0, 2.0, 0.1, 0.4])\n    expiries = 1.0\n    computed_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards))\n    expected_prices = np.array([0.0, 2.0, 2.52403424, 3.99315108, 4.65085383])\n    self.assertArrayNear(expected_prices, computed_prices, 1e-08)\n    is_call_options = True\n    vanilla_prices = self.evaluate(tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    cash_or_nothing_prices = self.evaluate(strikes * tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    asset_or_nothing_prices = self.evaluate(tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call_options))\n    self.assertArrayNear(vanilla_prices, asset_or_nothing_prices - cash_or_nothing_prices, 1e-10)"
        ]
    },
    {
        "func_name": "test_vanilla_and_binary_prices_consistency_bulk",
        "original": "@parameterized.product(discount_mode=('rates', 'factors'), is_normal=(True, False))\ndef test_vanilla_and_binary_prices_consistency_bulk(self, discount_mode, is_normal):\n    \"\"\"Tests the consistency between vanilla and binary option prices.\"\"\"\n    np.random.seed(321)\n    num_examples = 1000\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    forwards = np.exp(np.random.normal(size=num_examples))\n    if discount_mode == 'rates':\n        discount_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n        discount_factors = None\n    else:\n        discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n        discount_rates = None\n    dividend_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    asset_or_nothing_prices = tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    cash_or_nothing_prices = tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    synthetic_vanilla_from_binary_prices = tf.where(is_call_options, asset_or_nothing_prices - strikes * cash_or_nothing_prices, strikes * cash_or_nothing_prices - asset_or_nothing_prices)\n    directly_computed_vanilla_prices = tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    self.assertArrayNear(self.evaluate(synthetic_vanilla_from_binary_prices), self.evaluate(directly_computed_vanilla_prices), 1e-10)",
        "mutated": [
            "@parameterized.product(discount_mode=('rates', 'factors'), is_normal=(True, False))\ndef test_vanilla_and_binary_prices_consistency_bulk(self, discount_mode, is_normal):\n    if False:\n        i = 10\n    'Tests the consistency between vanilla and binary option prices.'\n    np.random.seed(321)\n    num_examples = 1000\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    forwards = np.exp(np.random.normal(size=num_examples))\n    if discount_mode == 'rates':\n        discount_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n        discount_factors = None\n    else:\n        discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n        discount_rates = None\n    dividend_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    asset_or_nothing_prices = tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    cash_or_nothing_prices = tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    synthetic_vanilla_from_binary_prices = tf.where(is_call_options, asset_or_nothing_prices - strikes * cash_or_nothing_prices, strikes * cash_or_nothing_prices - asset_or_nothing_prices)\n    directly_computed_vanilla_prices = tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    self.assertArrayNear(self.evaluate(synthetic_vanilla_from_binary_prices), self.evaluate(directly_computed_vanilla_prices), 1e-10)",
            "@parameterized.product(discount_mode=('rates', 'factors'), is_normal=(True, False))\ndef test_vanilla_and_binary_prices_consistency_bulk(self, discount_mode, is_normal):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests the consistency between vanilla and binary option prices.'\n    np.random.seed(321)\n    num_examples = 1000\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    forwards = np.exp(np.random.normal(size=num_examples))\n    if discount_mode == 'rates':\n        discount_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n        discount_factors = None\n    else:\n        discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n        discount_rates = None\n    dividend_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    asset_or_nothing_prices = tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    cash_or_nothing_prices = tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    synthetic_vanilla_from_binary_prices = tf.where(is_call_options, asset_or_nothing_prices - strikes * cash_or_nothing_prices, strikes * cash_or_nothing_prices - asset_or_nothing_prices)\n    directly_computed_vanilla_prices = tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    self.assertArrayNear(self.evaluate(synthetic_vanilla_from_binary_prices), self.evaluate(directly_computed_vanilla_prices), 1e-10)",
            "@parameterized.product(discount_mode=('rates', 'factors'), is_normal=(True, False))\ndef test_vanilla_and_binary_prices_consistency_bulk(self, discount_mode, is_normal):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests the consistency between vanilla and binary option prices.'\n    np.random.seed(321)\n    num_examples = 1000\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    forwards = np.exp(np.random.normal(size=num_examples))\n    if discount_mode == 'rates':\n        discount_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n        discount_factors = None\n    else:\n        discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n        discount_rates = None\n    dividend_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    asset_or_nothing_prices = tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    cash_or_nothing_prices = tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    synthetic_vanilla_from_binary_prices = tf.where(is_call_options, asset_or_nothing_prices - strikes * cash_or_nothing_prices, strikes * cash_or_nothing_prices - asset_or_nothing_prices)\n    directly_computed_vanilla_prices = tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    self.assertArrayNear(self.evaluate(synthetic_vanilla_from_binary_prices), self.evaluate(directly_computed_vanilla_prices), 1e-10)",
            "@parameterized.product(discount_mode=('rates', 'factors'), is_normal=(True, False))\ndef test_vanilla_and_binary_prices_consistency_bulk(self, discount_mode, is_normal):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests the consistency between vanilla and binary option prices.'\n    np.random.seed(321)\n    num_examples = 1000\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    forwards = np.exp(np.random.normal(size=num_examples))\n    if discount_mode == 'rates':\n        discount_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n        discount_factors = None\n    else:\n        discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n        discount_rates = None\n    dividend_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    asset_or_nothing_prices = tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    cash_or_nothing_prices = tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    synthetic_vanilla_from_binary_prices = tf.where(is_call_options, asset_or_nothing_prices - strikes * cash_or_nothing_prices, strikes * cash_or_nothing_prices - asset_or_nothing_prices)\n    directly_computed_vanilla_prices = tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    self.assertArrayNear(self.evaluate(synthetic_vanilla_from_binary_prices), self.evaluate(directly_computed_vanilla_prices), 1e-10)",
            "@parameterized.product(discount_mode=('rates', 'factors'), is_normal=(True, False))\ndef test_vanilla_and_binary_prices_consistency_bulk(self, discount_mode, is_normal):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests the consistency between vanilla and binary option prices.'\n    np.random.seed(321)\n    num_examples = 1000\n    volatilities = np.exp(np.random.normal(size=num_examples))\n    strikes = np.exp(np.random.normal(size=num_examples))\n    expiries = np.random.gamma(shape=1.0, scale=1.0, size=num_examples)\n    forwards = np.exp(np.random.normal(size=num_examples))\n    if discount_mode == 'rates':\n        discount_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n        discount_factors = None\n    else:\n        discount_factors = np.random.beta(a=1.0, b=1.0, size=num_examples)\n        discount_rates = None\n    dividend_rates = np.random.uniform(0.0, 0.05, size=num_examples)\n    call_options = np.random.binomial(n=1, p=0.5, size=num_examples)\n    is_call_options = np.array(call_options, dtype=bool)\n    asset_or_nothing_prices = tff.black_scholes.asset_or_nothing_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    cash_or_nothing_prices = tff.black_scholes.binary_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    synthetic_vanilla_from_binary_prices = tf.where(is_call_options, asset_or_nothing_prices - strikes * cash_or_nothing_prices, strikes * cash_or_nothing_prices - asset_or_nothing_prices)\n    directly_computed_vanilla_prices = tff.black_scholes.option_price(volatilities=volatilities, strikes=strikes, expiries=expiries, forwards=forwards, discount_rates=discount_rates, dividend_rates=dividend_rates, is_call_options=is_call_options, is_normal_volatility=is_normal, discount_factors=discount_factors)\n    self.assertArrayNear(self.evaluate(synthetic_vanilla_from_binary_prices), self.evaluate(directly_computed_vanilla_prices), 1e-10)"
        ]
    },
    {
        "func_name": "test_vanilla_options_price_gradient_continuous",
        "original": "@parameterized.product(({'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.0, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 90.0}), is_call=(True, False), is_normal=(True, False))\ndef test_vanilla_options_price_gradient_continuous(self, vol, strikes, expiries, forwards, is_call, is_normal):\n    \"\"\"Tests that the gradient exists, and is also right-continuous.\"\"\"\n    dtype = tf.float64\n    vol = tf.convert_to_tensor(vol, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad = tape.gradient(target=price, sources=[vol, strikes, expiries, forwards])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_vol = tff.black_scholes.option_price(volatilities=vol + 1e-06, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_vol = tape.gradient(target=price_perturb_vol, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_vol = self.evaluate(grad_perturb_vol)\n    self.assertAllClose(grad, grad_perturb_vol, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_expiries = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries + 1e-06, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_expiries = tape.gradient(target=price_perturb_expiries, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_expiries = self.evaluate(grad_perturb_expiries)\n    self.assertAllClose(grad, grad_perturb_expiries, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_strikes = tff.black_scholes.option_price(volatilities=vol, strikes=strikes + 1e-06, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_strikes = tape.gradient(target=price_perturb_strikes, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_strikes = self.evaluate(grad_perturb_strikes)\n    self.assertAllClose(grad, grad_perturb_strikes, rtol=0.0001)",
        "mutated": [
            "@parameterized.product(({'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.0, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 90.0}), is_call=(True, False), is_normal=(True, False))\ndef test_vanilla_options_price_gradient_continuous(self, vol, strikes, expiries, forwards, is_call, is_normal):\n    if False:\n        i = 10\n    'Tests that the gradient exists, and is also right-continuous.'\n    dtype = tf.float64\n    vol = tf.convert_to_tensor(vol, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad = tape.gradient(target=price, sources=[vol, strikes, expiries, forwards])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_vol = tff.black_scholes.option_price(volatilities=vol + 1e-06, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_vol = tape.gradient(target=price_perturb_vol, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_vol = self.evaluate(grad_perturb_vol)\n    self.assertAllClose(grad, grad_perturb_vol, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_expiries = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries + 1e-06, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_expiries = tape.gradient(target=price_perturb_expiries, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_expiries = self.evaluate(grad_perturb_expiries)\n    self.assertAllClose(grad, grad_perturb_expiries, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_strikes = tff.black_scholes.option_price(volatilities=vol, strikes=strikes + 1e-06, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_strikes = tape.gradient(target=price_perturb_strikes, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_strikes = self.evaluate(grad_perturb_strikes)\n    self.assertAllClose(grad, grad_perturb_strikes, rtol=0.0001)",
            "@parameterized.product(({'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.0, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 90.0}), is_call=(True, False), is_normal=(True, False))\ndef test_vanilla_options_price_gradient_continuous(self, vol, strikes, expiries, forwards, is_call, is_normal):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests that the gradient exists, and is also right-continuous.'\n    dtype = tf.float64\n    vol = tf.convert_to_tensor(vol, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad = tape.gradient(target=price, sources=[vol, strikes, expiries, forwards])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_vol = tff.black_scholes.option_price(volatilities=vol + 1e-06, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_vol = tape.gradient(target=price_perturb_vol, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_vol = self.evaluate(grad_perturb_vol)\n    self.assertAllClose(grad, grad_perturb_vol, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_expiries = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries + 1e-06, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_expiries = tape.gradient(target=price_perturb_expiries, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_expiries = self.evaluate(grad_perturb_expiries)\n    self.assertAllClose(grad, grad_perturb_expiries, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_strikes = tff.black_scholes.option_price(volatilities=vol, strikes=strikes + 1e-06, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_strikes = tape.gradient(target=price_perturb_strikes, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_strikes = self.evaluate(grad_perturb_strikes)\n    self.assertAllClose(grad, grad_perturb_strikes, rtol=0.0001)",
            "@parameterized.product(({'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.0, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 90.0}), is_call=(True, False), is_normal=(True, False))\ndef test_vanilla_options_price_gradient_continuous(self, vol, strikes, expiries, forwards, is_call, is_normal):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests that the gradient exists, and is also right-continuous.'\n    dtype = tf.float64\n    vol = tf.convert_to_tensor(vol, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad = tape.gradient(target=price, sources=[vol, strikes, expiries, forwards])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_vol = tff.black_scholes.option_price(volatilities=vol + 1e-06, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_vol = tape.gradient(target=price_perturb_vol, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_vol = self.evaluate(grad_perturb_vol)\n    self.assertAllClose(grad, grad_perturb_vol, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_expiries = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries + 1e-06, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_expiries = tape.gradient(target=price_perturb_expiries, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_expiries = self.evaluate(grad_perturb_expiries)\n    self.assertAllClose(grad, grad_perturb_expiries, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_strikes = tff.black_scholes.option_price(volatilities=vol, strikes=strikes + 1e-06, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_strikes = tape.gradient(target=price_perturb_strikes, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_strikes = self.evaluate(grad_perturb_strikes)\n    self.assertAllClose(grad, grad_perturb_strikes, rtol=0.0001)",
            "@parameterized.product(({'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.0, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 90.0}), is_call=(True, False), is_normal=(True, False))\ndef test_vanilla_options_price_gradient_continuous(self, vol, strikes, expiries, forwards, is_call, is_normal):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests that the gradient exists, and is also right-continuous.'\n    dtype = tf.float64\n    vol = tf.convert_to_tensor(vol, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad = tape.gradient(target=price, sources=[vol, strikes, expiries, forwards])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_vol = tff.black_scholes.option_price(volatilities=vol + 1e-06, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_vol = tape.gradient(target=price_perturb_vol, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_vol = self.evaluate(grad_perturb_vol)\n    self.assertAllClose(grad, grad_perturb_vol, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_expiries = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries + 1e-06, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_expiries = tape.gradient(target=price_perturb_expiries, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_expiries = self.evaluate(grad_perturb_expiries)\n    self.assertAllClose(grad, grad_perturb_expiries, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_strikes = tff.black_scholes.option_price(volatilities=vol, strikes=strikes + 1e-06, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_strikes = tape.gradient(target=price_perturb_strikes, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_strikes = self.evaluate(grad_perturb_strikes)\n    self.assertAllClose(grad, grad_perturb_strikes, rtol=0.0001)",
            "@parameterized.product(({'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.0, 'forwards': 100.0}, {'vol': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'forwards': 90.0}), is_call=(True, False), is_normal=(True, False))\ndef test_vanilla_options_price_gradient_continuous(self, vol, strikes, expiries, forwards, is_call, is_normal):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests that the gradient exists, and is also right-continuous.'\n    dtype = tf.float64\n    vol = tf.convert_to_tensor(vol, dtype=dtype)\n    strikes = tf.convert_to_tensor(strikes, dtype=dtype)\n    expiries = tf.convert_to_tensor(expiries, dtype=dtype)\n    forwards = tf.convert_to_tensor(forwards, dtype=dtype)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad = tape.gradient(target=price, sources=[vol, strikes, expiries, forwards])\n    grad = self.evaluate(grad)\n    self.assertTrue(all((np.all(np.isfinite(x)) for x in grad)))\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_vol = tff.black_scholes.option_price(volatilities=vol + 1e-06, strikes=strikes, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_vol = tape.gradient(target=price_perturb_vol, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_vol = self.evaluate(grad_perturb_vol)\n    self.assertAllClose(grad, grad_perturb_vol, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_expiries = tff.black_scholes.option_price(volatilities=vol, strikes=strikes, expiries=expiries + 1e-06, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_expiries = tape.gradient(target=price_perturb_expiries, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_expiries = self.evaluate(grad_perturb_expiries)\n    self.assertAllClose(grad, grad_perturb_expiries, rtol=0.0001)\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch([vol, strikes, expiries, forwards])\n        price_perturb_strikes = tff.black_scholes.option_price(volatilities=vol, strikes=strikes + 1e-06, expiries=expiries, forwards=forwards, is_call_options=is_call, is_normal_volatility=is_normal, dtype=dtype)\n        grad_perturb_strikes = tape.gradient(target=price_perturb_strikes, sources=[vol, strikes, expiries, forwards])\n    grad_perturb_strikes = self.evaluate(grad_perturb_strikes)\n    self.assertAllClose(grad, grad_perturb_strikes, rtol=0.0001)"
        ]
    },
    {
        "func_name": "test_barrier_option",
        "original": "@parameterized.named_parameters({'testcase_name': 'ScalarInputsUIP', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653}, {'testcase_name': 'ScalarInputsUIP_Default_Values', 'volatilities': 0.3, 'strikes': 105.0, 'expiries': 10.0, 'spots': 100.0, 'discount_rates': None, 'dividend_rates': None, 'barriers': 90.0, 'rebates': None, 'is_barrier_down': True, 'is_knock_out': True, 'is_call_options': True, 'expected_price': 9.2848}, {'testcase_name': 'VectorInputs', 'volatilities': [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25], 'strikes': [90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0], 'expiries': [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], 'spots': [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], 'discount_rates': [0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08], 'dividend_rates': [0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04], 'barriers': [95.0, 95.0, 105.0, 105.0, 95.0, 105.0, 95.0, 105.0], 'rebates': [3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], 'is_barrier_down': [True, True, False, False, True, False, True, False], 'is_knock_out': [True, False, True, False, True, True, False, False], 'is_call_options': [True, True, True, True, False, False, False, False], 'expected_price': [9.024, 7.7627, 2.6789, 14.1112, 2.2798, 3.776, 2.95586, 1.4653]}, {'testcase_name': 'MatrixInputs', 'volatilities': [[0.25, 0.25], [0.25, 0.25], [0.25, 0.25], [0.25, 0.25]], 'strikes': [[90.0, 90.0], [90.0, 90.0], [90.0, 90.0], [90.0, 90.0]], 'expiries': [[0.5, 0.5], [0.5, 0.5], [0.5, 0.5], [0.5, 0.5]], 'spots': [[100.0, 100.0], [100.0, 100.0], [100.0, 100.0], [100.0, 100.0]], 'discount_rates': [[0.08, 0.08], [0.08, 0.08], [0.08, 0.08], [0.08, 0.08]], 'dividend_rates': [[0.04, 0.04], [0.04, 0.04], [0.04, 0.04], [0.04, 0.04]], 'barriers': [[95.0, 95.0], [105.0, 105.0], [95.0, 105.0], [95.0, 105.0]], 'rebates': [[3.0, 3.0], [3.0, 3.0], [3.0, 3.0], [3.0, 3.0]], 'is_barrier_down': [[True, True], [False, False], [True, False], [True, False]], 'is_knock_out': [[True, False], [True, False], [True, True], [False, False]], 'is_call_options': [[True, True], [True, True], [False, False], [False, False]], 'expected_price': [[9.024, 7.7627], [2.6789, 14.1112], [2.2798, 3.776], [2.95586, 1.4653]]}, {'testcase_name': 'dividend_rates', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653})\ndef test_barrier_option(self, *, volatilities, strikes, expiries, spots, discount_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options, expected_price, dividend_rates=None):\n    \"\"\"Computes test barrier option prices for the parameterized inputs.\"\"\"\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options)\n    self.assertAllClose(price, expected_price, 0.01)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'ScalarInputsUIP', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653}, {'testcase_name': 'ScalarInputsUIP_Default_Values', 'volatilities': 0.3, 'strikes': 105.0, 'expiries': 10.0, 'spots': 100.0, 'discount_rates': None, 'dividend_rates': None, 'barriers': 90.0, 'rebates': None, 'is_barrier_down': True, 'is_knock_out': True, 'is_call_options': True, 'expected_price': 9.2848}, {'testcase_name': 'VectorInputs', 'volatilities': [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25], 'strikes': [90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0], 'expiries': [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], 'spots': [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], 'discount_rates': [0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08], 'dividend_rates': [0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04], 'barriers': [95.0, 95.0, 105.0, 105.0, 95.0, 105.0, 95.0, 105.0], 'rebates': [3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], 'is_barrier_down': [True, True, False, False, True, False, True, False], 'is_knock_out': [True, False, True, False, True, True, False, False], 'is_call_options': [True, True, True, True, False, False, False, False], 'expected_price': [9.024, 7.7627, 2.6789, 14.1112, 2.2798, 3.776, 2.95586, 1.4653]}, {'testcase_name': 'MatrixInputs', 'volatilities': [[0.25, 0.25], [0.25, 0.25], [0.25, 0.25], [0.25, 0.25]], 'strikes': [[90.0, 90.0], [90.0, 90.0], [90.0, 90.0], [90.0, 90.0]], 'expiries': [[0.5, 0.5], [0.5, 0.5], [0.5, 0.5], [0.5, 0.5]], 'spots': [[100.0, 100.0], [100.0, 100.0], [100.0, 100.0], [100.0, 100.0]], 'discount_rates': [[0.08, 0.08], [0.08, 0.08], [0.08, 0.08], [0.08, 0.08]], 'dividend_rates': [[0.04, 0.04], [0.04, 0.04], [0.04, 0.04], [0.04, 0.04]], 'barriers': [[95.0, 95.0], [105.0, 105.0], [95.0, 105.0], [95.0, 105.0]], 'rebates': [[3.0, 3.0], [3.0, 3.0], [3.0, 3.0], [3.0, 3.0]], 'is_barrier_down': [[True, True], [False, False], [True, False], [True, False]], 'is_knock_out': [[True, False], [True, False], [True, True], [False, False]], 'is_call_options': [[True, True], [True, True], [False, False], [False, False]], 'expected_price': [[9.024, 7.7627], [2.6789, 14.1112], [2.2798, 3.776], [2.95586, 1.4653]]}, {'testcase_name': 'dividend_rates', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653})\ndef test_barrier_option(self, *, volatilities, strikes, expiries, spots, discount_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options, expected_price, dividend_rates=None):\n    if False:\n        i = 10\n    'Computes test barrier option prices for the parameterized inputs.'\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options)\n    self.assertAllClose(price, expected_price, 0.01)",
            "@parameterized.named_parameters({'testcase_name': 'ScalarInputsUIP', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653}, {'testcase_name': 'ScalarInputsUIP_Default_Values', 'volatilities': 0.3, 'strikes': 105.0, 'expiries': 10.0, 'spots': 100.0, 'discount_rates': None, 'dividend_rates': None, 'barriers': 90.0, 'rebates': None, 'is_barrier_down': True, 'is_knock_out': True, 'is_call_options': True, 'expected_price': 9.2848}, {'testcase_name': 'VectorInputs', 'volatilities': [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25], 'strikes': [90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0], 'expiries': [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], 'spots': [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], 'discount_rates': [0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08], 'dividend_rates': [0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04], 'barriers': [95.0, 95.0, 105.0, 105.0, 95.0, 105.0, 95.0, 105.0], 'rebates': [3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], 'is_barrier_down': [True, True, False, False, True, False, True, False], 'is_knock_out': [True, False, True, False, True, True, False, False], 'is_call_options': [True, True, True, True, False, False, False, False], 'expected_price': [9.024, 7.7627, 2.6789, 14.1112, 2.2798, 3.776, 2.95586, 1.4653]}, {'testcase_name': 'MatrixInputs', 'volatilities': [[0.25, 0.25], [0.25, 0.25], [0.25, 0.25], [0.25, 0.25]], 'strikes': [[90.0, 90.0], [90.0, 90.0], [90.0, 90.0], [90.0, 90.0]], 'expiries': [[0.5, 0.5], [0.5, 0.5], [0.5, 0.5], [0.5, 0.5]], 'spots': [[100.0, 100.0], [100.0, 100.0], [100.0, 100.0], [100.0, 100.0]], 'discount_rates': [[0.08, 0.08], [0.08, 0.08], [0.08, 0.08], [0.08, 0.08]], 'dividend_rates': [[0.04, 0.04], [0.04, 0.04], [0.04, 0.04], [0.04, 0.04]], 'barriers': [[95.0, 95.0], [105.0, 105.0], [95.0, 105.0], [95.0, 105.0]], 'rebates': [[3.0, 3.0], [3.0, 3.0], [3.0, 3.0], [3.0, 3.0]], 'is_barrier_down': [[True, True], [False, False], [True, False], [True, False]], 'is_knock_out': [[True, False], [True, False], [True, True], [False, False]], 'is_call_options': [[True, True], [True, True], [False, False], [False, False]], 'expected_price': [[9.024, 7.7627], [2.6789, 14.1112], [2.2798, 3.776], [2.95586, 1.4653]]}, {'testcase_name': 'dividend_rates', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653})\ndef test_barrier_option(self, *, volatilities, strikes, expiries, spots, discount_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options, expected_price, dividend_rates=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Computes test barrier option prices for the parameterized inputs.'\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options)\n    self.assertAllClose(price, expected_price, 0.01)",
            "@parameterized.named_parameters({'testcase_name': 'ScalarInputsUIP', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653}, {'testcase_name': 'ScalarInputsUIP_Default_Values', 'volatilities': 0.3, 'strikes': 105.0, 'expiries': 10.0, 'spots': 100.0, 'discount_rates': None, 'dividend_rates': None, 'barriers': 90.0, 'rebates': None, 'is_barrier_down': True, 'is_knock_out': True, 'is_call_options': True, 'expected_price': 9.2848}, {'testcase_name': 'VectorInputs', 'volatilities': [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25], 'strikes': [90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0], 'expiries': [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], 'spots': [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], 'discount_rates': [0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08], 'dividend_rates': [0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04], 'barriers': [95.0, 95.0, 105.0, 105.0, 95.0, 105.0, 95.0, 105.0], 'rebates': [3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], 'is_barrier_down': [True, True, False, False, True, False, True, False], 'is_knock_out': [True, False, True, False, True, True, False, False], 'is_call_options': [True, True, True, True, False, False, False, False], 'expected_price': [9.024, 7.7627, 2.6789, 14.1112, 2.2798, 3.776, 2.95586, 1.4653]}, {'testcase_name': 'MatrixInputs', 'volatilities': [[0.25, 0.25], [0.25, 0.25], [0.25, 0.25], [0.25, 0.25]], 'strikes': [[90.0, 90.0], [90.0, 90.0], [90.0, 90.0], [90.0, 90.0]], 'expiries': [[0.5, 0.5], [0.5, 0.5], [0.5, 0.5], [0.5, 0.5]], 'spots': [[100.0, 100.0], [100.0, 100.0], [100.0, 100.0], [100.0, 100.0]], 'discount_rates': [[0.08, 0.08], [0.08, 0.08], [0.08, 0.08], [0.08, 0.08]], 'dividend_rates': [[0.04, 0.04], [0.04, 0.04], [0.04, 0.04], [0.04, 0.04]], 'barriers': [[95.0, 95.0], [105.0, 105.0], [95.0, 105.0], [95.0, 105.0]], 'rebates': [[3.0, 3.0], [3.0, 3.0], [3.0, 3.0], [3.0, 3.0]], 'is_barrier_down': [[True, True], [False, False], [True, False], [True, False]], 'is_knock_out': [[True, False], [True, False], [True, True], [False, False]], 'is_call_options': [[True, True], [True, True], [False, False], [False, False]], 'expected_price': [[9.024, 7.7627], [2.6789, 14.1112], [2.2798, 3.776], [2.95586, 1.4653]]}, {'testcase_name': 'dividend_rates', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653})\ndef test_barrier_option(self, *, volatilities, strikes, expiries, spots, discount_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options, expected_price, dividend_rates=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Computes test barrier option prices for the parameterized inputs.'\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options)\n    self.assertAllClose(price, expected_price, 0.01)",
            "@parameterized.named_parameters({'testcase_name': 'ScalarInputsUIP', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653}, {'testcase_name': 'ScalarInputsUIP_Default_Values', 'volatilities': 0.3, 'strikes': 105.0, 'expiries': 10.0, 'spots': 100.0, 'discount_rates': None, 'dividend_rates': None, 'barriers': 90.0, 'rebates': None, 'is_barrier_down': True, 'is_knock_out': True, 'is_call_options': True, 'expected_price': 9.2848}, {'testcase_name': 'VectorInputs', 'volatilities': [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25], 'strikes': [90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0], 'expiries': [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], 'spots': [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], 'discount_rates': [0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08], 'dividend_rates': [0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04], 'barriers': [95.0, 95.0, 105.0, 105.0, 95.0, 105.0, 95.0, 105.0], 'rebates': [3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], 'is_barrier_down': [True, True, False, False, True, False, True, False], 'is_knock_out': [True, False, True, False, True, True, False, False], 'is_call_options': [True, True, True, True, False, False, False, False], 'expected_price': [9.024, 7.7627, 2.6789, 14.1112, 2.2798, 3.776, 2.95586, 1.4653]}, {'testcase_name': 'MatrixInputs', 'volatilities': [[0.25, 0.25], [0.25, 0.25], [0.25, 0.25], [0.25, 0.25]], 'strikes': [[90.0, 90.0], [90.0, 90.0], [90.0, 90.0], [90.0, 90.0]], 'expiries': [[0.5, 0.5], [0.5, 0.5], [0.5, 0.5], [0.5, 0.5]], 'spots': [[100.0, 100.0], [100.0, 100.0], [100.0, 100.0], [100.0, 100.0]], 'discount_rates': [[0.08, 0.08], [0.08, 0.08], [0.08, 0.08], [0.08, 0.08]], 'dividend_rates': [[0.04, 0.04], [0.04, 0.04], [0.04, 0.04], [0.04, 0.04]], 'barriers': [[95.0, 95.0], [105.0, 105.0], [95.0, 105.0], [95.0, 105.0]], 'rebates': [[3.0, 3.0], [3.0, 3.0], [3.0, 3.0], [3.0, 3.0]], 'is_barrier_down': [[True, True], [False, False], [True, False], [True, False]], 'is_knock_out': [[True, False], [True, False], [True, True], [False, False]], 'is_call_options': [[True, True], [True, True], [False, False], [False, False]], 'expected_price': [[9.024, 7.7627], [2.6789, 14.1112], [2.2798, 3.776], [2.95586, 1.4653]]}, {'testcase_name': 'dividend_rates', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653})\ndef test_barrier_option(self, *, volatilities, strikes, expiries, spots, discount_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options, expected_price, dividend_rates=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Computes test barrier option prices for the parameterized inputs.'\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options)\n    self.assertAllClose(price, expected_price, 0.01)",
            "@parameterized.named_parameters({'testcase_name': 'ScalarInputsUIP', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653}, {'testcase_name': 'ScalarInputsUIP_Default_Values', 'volatilities': 0.3, 'strikes': 105.0, 'expiries': 10.0, 'spots': 100.0, 'discount_rates': None, 'dividend_rates': None, 'barriers': 90.0, 'rebates': None, 'is_barrier_down': True, 'is_knock_out': True, 'is_call_options': True, 'expected_price': 9.2848}, {'testcase_name': 'VectorInputs', 'volatilities': [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25], 'strikes': [90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0], 'expiries': [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], 'spots': [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], 'discount_rates': [0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08], 'dividend_rates': [0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04], 'barriers': [95.0, 95.0, 105.0, 105.0, 95.0, 105.0, 95.0, 105.0], 'rebates': [3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0], 'is_barrier_down': [True, True, False, False, True, False, True, False], 'is_knock_out': [True, False, True, False, True, True, False, False], 'is_call_options': [True, True, True, True, False, False, False, False], 'expected_price': [9.024, 7.7627, 2.6789, 14.1112, 2.2798, 3.776, 2.95586, 1.4653]}, {'testcase_name': 'MatrixInputs', 'volatilities': [[0.25, 0.25], [0.25, 0.25], [0.25, 0.25], [0.25, 0.25]], 'strikes': [[90.0, 90.0], [90.0, 90.0], [90.0, 90.0], [90.0, 90.0]], 'expiries': [[0.5, 0.5], [0.5, 0.5], [0.5, 0.5], [0.5, 0.5]], 'spots': [[100.0, 100.0], [100.0, 100.0], [100.0, 100.0], [100.0, 100.0]], 'discount_rates': [[0.08, 0.08], [0.08, 0.08], [0.08, 0.08], [0.08, 0.08]], 'dividend_rates': [[0.04, 0.04], [0.04, 0.04], [0.04, 0.04], [0.04, 0.04]], 'barriers': [[95.0, 95.0], [105.0, 105.0], [95.0, 105.0], [95.0, 105.0]], 'rebates': [[3.0, 3.0], [3.0, 3.0], [3.0, 3.0], [3.0, 3.0]], 'is_barrier_down': [[True, True], [False, False], [True, False], [True, False]], 'is_knock_out': [[True, False], [True, False], [True, True], [False, False]], 'is_call_options': [[True, True], [True, True], [False, False], [False, False]], 'expected_price': [[9.024, 7.7627], [2.6789, 14.1112], [2.2798, 3.776], [2.95586, 1.4653]]}, {'testcase_name': 'dividend_rates', 'volatilities': 0.25, 'strikes': 90.0, 'expiries': 0.5, 'spots': 100.0, 'discount_rates': 0.08, 'dividend_rates': 0.04, 'barriers': 105.0, 'rebates': 3.0, 'is_barrier_down': False, 'is_knock_out': False, 'is_call_options': False, 'expected_price': 1.4653})\ndef test_barrier_option(self, *, volatilities, strikes, expiries, spots, discount_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options, expected_price, dividend_rates=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Computes test barrier option prices for the parameterized inputs.'\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options)\n    self.assertAllClose(price, expected_price, 0.01)"
        ]
    },
    {
        "func_name": "test_barrier_option_dtype",
        "original": "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_barrier_option_dtype(self, dtype):\n    \"\"\"Function tests barrier option pricing for with given data type.\"\"\"\n    spots = 100.0\n    rebates = 3.0\n    expiries = 0.5\n    discount_rates = 0.08\n    dividend_rates = 0.04\n    strikes = 90.0\n    barriers = 95.0\n    expected_price = 9.0246\n    is_call_options = True\n    is_barrier_down = True\n    is_knock_out = True\n    volatilities = 0.25\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options, dtype=dtype)\n    self.assertAllClose(price, expected_price, 0.01)\n    self.assertEqual(price.dtype, dtype)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_barrier_option_dtype(self, dtype):\n    if False:\n        i = 10\n    'Function tests barrier option pricing for with given data type.'\n    spots = 100.0\n    rebates = 3.0\n    expiries = 0.5\n    discount_rates = 0.08\n    dividend_rates = 0.04\n    strikes = 90.0\n    barriers = 95.0\n    expected_price = 9.0246\n    is_call_options = True\n    is_barrier_down = True\n    is_knock_out = True\n    volatilities = 0.25\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options, dtype=dtype)\n    self.assertAllClose(price, expected_price, 0.01)\n    self.assertEqual(price.dtype, dtype)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_barrier_option_dtype(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Function tests barrier option pricing for with given data type.'\n    spots = 100.0\n    rebates = 3.0\n    expiries = 0.5\n    discount_rates = 0.08\n    dividend_rates = 0.04\n    strikes = 90.0\n    barriers = 95.0\n    expected_price = 9.0246\n    is_call_options = True\n    is_barrier_down = True\n    is_knock_out = True\n    volatilities = 0.25\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options, dtype=dtype)\n    self.assertAllClose(price, expected_price, 0.01)\n    self.assertEqual(price.dtype, dtype)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_barrier_option_dtype(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Function tests barrier option pricing for with given data type.'\n    spots = 100.0\n    rebates = 3.0\n    expiries = 0.5\n    discount_rates = 0.08\n    dividend_rates = 0.04\n    strikes = 90.0\n    barriers = 95.0\n    expected_price = 9.0246\n    is_call_options = True\n    is_barrier_down = True\n    is_knock_out = True\n    volatilities = 0.25\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options, dtype=dtype)\n    self.assertAllClose(price, expected_price, 0.01)\n    self.assertEqual(price.dtype, dtype)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_barrier_option_dtype(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Function tests barrier option pricing for with given data type.'\n    spots = 100.0\n    rebates = 3.0\n    expiries = 0.5\n    discount_rates = 0.08\n    dividend_rates = 0.04\n    strikes = 90.0\n    barriers = 95.0\n    expected_price = 9.0246\n    is_call_options = True\n    is_barrier_down = True\n    is_knock_out = True\n    volatilities = 0.25\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options, dtype=dtype)\n    self.assertAllClose(price, expected_price, 0.01)\n    self.assertEqual(price.dtype, dtype)",
            "@parameterized.named_parameters({'testcase_name': 'SinglePrecision', 'dtype': np.float32}, {'testcase_name': 'DoublePrecision', 'dtype': np.float64})\ndef test_barrier_option_dtype(self, dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Function tests barrier option pricing for with given data type.'\n    spots = 100.0\n    rebates = 3.0\n    expiries = 0.5\n    discount_rates = 0.08\n    dividend_rates = 0.04\n    strikes = 90.0\n    barriers = 95.0\n    expected_price = 9.0246\n    is_call_options = True\n    is_barrier_down = True\n    is_knock_out = True\n    volatilities = 0.25\n    price = tff.black_scholes.barrier_price(volatilities=volatilities, strikes=strikes, expiries=expiries, spots=spots, discount_rates=discount_rates, dividend_rates=dividend_rates, barriers=barriers, rebates=rebates, is_barrier_down=is_barrier_down, is_knock_out=is_knock_out, is_call_options=is_call_options, dtype=dtype)\n    self.assertAllClose(price, expected_price, 0.01)\n    self.assertEqual(price.dtype, dtype)"
        ]
    },
    {
        "func_name": "price_barriers_option",
        "original": "def price_barriers_option(samples):\n    return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]",
        "mutated": [
            "def price_barriers_option(samples):\n    if False:\n        i = 10\n    return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]",
            "def price_barriers_option(samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]",
            "def price_barriers_option(samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]",
            "def price_barriers_option(samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]",
            "def price_barriers_option(samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]"
        ]
    },
    {
        "func_name": "xla_compiled_op",
        "original": "def xla_compiled_op(samples):\n    return tf.function(price_barriers_option, jit_compile=True)(samples)",
        "mutated": [
            "def xla_compiled_op(samples):\n    if False:\n        i = 10\n    return tf.function(price_barriers_option, jit_compile=True)(samples)",
            "def xla_compiled_op(samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return tf.function(price_barriers_option, jit_compile=True)(samples)",
            "def xla_compiled_op(samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return tf.function(price_barriers_option, jit_compile=True)(samples)",
            "def xla_compiled_op(samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return tf.function(price_barriers_option, jit_compile=True)(samples)",
            "def xla_compiled_op(samples):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return tf.function(price_barriers_option, jit_compile=True)(samples)"
        ]
    },
    {
        "func_name": "barrier_option_call_xla",
        "original": "def barrier_option_call_xla(self):\n    \"\"\"Tests barrier option price with XLA.\"\"\"\n    dtype = tf.float64\n    spots = tf.convert_to_tensor(100.0, dtype=dtype)\n    rebates = tf.convert_to_tensor(3.0, dtype=dtype)\n    expiries = tf.convert_to_tensor(0.5, dtype=dtype)\n    discount_rates = tf.convert_to_tensor(0.08, dtype=dtype)\n    dividend_rates = tf.convert_to_tensor(0.04, dtype=dtype)\n    strikes = tf.convert_to_tensor(90.0, dtype=dtype)\n    barriers = tf.convert_to_tensor(95.0, dtype=dtype)\n    expected_price = tf.convert_to_tensor(9.0246, dtype=dtype)\n    is_call_options = tf.convert_to_tensor(True)\n    is_barrier_down = tf.convert_to_tensor(True)\n    is_knock_out = tf.convert_to_tensor(True)\n    volatilities = tf.convert_to_tensor(0.25, dtype=dtype)\n\n    def price_barriers_option(samples):\n        return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]\n\n    def xla_compiled_op(samples):\n        return tf.function(price_barriers_option, jit_compile=True)(samples)\n    price = xla_compiled_op([volatilities, strikes, expiries, spots, discount_rates, dividend_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options])\n    self.assertAllClose(price, expected_price, 0.01)",
        "mutated": [
            "def barrier_option_call_xla(self):\n    if False:\n        i = 10\n    'Tests barrier option price with XLA.'\n    dtype = tf.float64\n    spots = tf.convert_to_tensor(100.0, dtype=dtype)\n    rebates = tf.convert_to_tensor(3.0, dtype=dtype)\n    expiries = tf.convert_to_tensor(0.5, dtype=dtype)\n    discount_rates = tf.convert_to_tensor(0.08, dtype=dtype)\n    dividend_rates = tf.convert_to_tensor(0.04, dtype=dtype)\n    strikes = tf.convert_to_tensor(90.0, dtype=dtype)\n    barriers = tf.convert_to_tensor(95.0, dtype=dtype)\n    expected_price = tf.convert_to_tensor(9.0246, dtype=dtype)\n    is_call_options = tf.convert_to_tensor(True)\n    is_barrier_down = tf.convert_to_tensor(True)\n    is_knock_out = tf.convert_to_tensor(True)\n    volatilities = tf.convert_to_tensor(0.25, dtype=dtype)\n\n    def price_barriers_option(samples):\n        return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]\n\n    def xla_compiled_op(samples):\n        return tf.function(price_barriers_option, jit_compile=True)(samples)\n    price = xla_compiled_op([volatilities, strikes, expiries, spots, discount_rates, dividend_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options])\n    self.assertAllClose(price, expected_price, 0.01)",
            "def barrier_option_call_xla(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests barrier option price with XLA.'\n    dtype = tf.float64\n    spots = tf.convert_to_tensor(100.0, dtype=dtype)\n    rebates = tf.convert_to_tensor(3.0, dtype=dtype)\n    expiries = tf.convert_to_tensor(0.5, dtype=dtype)\n    discount_rates = tf.convert_to_tensor(0.08, dtype=dtype)\n    dividend_rates = tf.convert_to_tensor(0.04, dtype=dtype)\n    strikes = tf.convert_to_tensor(90.0, dtype=dtype)\n    barriers = tf.convert_to_tensor(95.0, dtype=dtype)\n    expected_price = tf.convert_to_tensor(9.0246, dtype=dtype)\n    is_call_options = tf.convert_to_tensor(True)\n    is_barrier_down = tf.convert_to_tensor(True)\n    is_knock_out = tf.convert_to_tensor(True)\n    volatilities = tf.convert_to_tensor(0.25, dtype=dtype)\n\n    def price_barriers_option(samples):\n        return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]\n\n    def xla_compiled_op(samples):\n        return tf.function(price_barriers_option, jit_compile=True)(samples)\n    price = xla_compiled_op([volatilities, strikes, expiries, spots, discount_rates, dividend_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options])\n    self.assertAllClose(price, expected_price, 0.01)",
            "def barrier_option_call_xla(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests barrier option price with XLA.'\n    dtype = tf.float64\n    spots = tf.convert_to_tensor(100.0, dtype=dtype)\n    rebates = tf.convert_to_tensor(3.0, dtype=dtype)\n    expiries = tf.convert_to_tensor(0.5, dtype=dtype)\n    discount_rates = tf.convert_to_tensor(0.08, dtype=dtype)\n    dividend_rates = tf.convert_to_tensor(0.04, dtype=dtype)\n    strikes = tf.convert_to_tensor(90.0, dtype=dtype)\n    barriers = tf.convert_to_tensor(95.0, dtype=dtype)\n    expected_price = tf.convert_to_tensor(9.0246, dtype=dtype)\n    is_call_options = tf.convert_to_tensor(True)\n    is_barrier_down = tf.convert_to_tensor(True)\n    is_knock_out = tf.convert_to_tensor(True)\n    volatilities = tf.convert_to_tensor(0.25, dtype=dtype)\n\n    def price_barriers_option(samples):\n        return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]\n\n    def xla_compiled_op(samples):\n        return tf.function(price_barriers_option, jit_compile=True)(samples)\n    price = xla_compiled_op([volatilities, strikes, expiries, spots, discount_rates, dividend_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options])\n    self.assertAllClose(price, expected_price, 0.01)",
            "def barrier_option_call_xla(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests barrier option price with XLA.'\n    dtype = tf.float64\n    spots = tf.convert_to_tensor(100.0, dtype=dtype)\n    rebates = tf.convert_to_tensor(3.0, dtype=dtype)\n    expiries = tf.convert_to_tensor(0.5, dtype=dtype)\n    discount_rates = tf.convert_to_tensor(0.08, dtype=dtype)\n    dividend_rates = tf.convert_to_tensor(0.04, dtype=dtype)\n    strikes = tf.convert_to_tensor(90.0, dtype=dtype)\n    barriers = tf.convert_to_tensor(95.0, dtype=dtype)\n    expected_price = tf.convert_to_tensor(9.0246, dtype=dtype)\n    is_call_options = tf.convert_to_tensor(True)\n    is_barrier_down = tf.convert_to_tensor(True)\n    is_knock_out = tf.convert_to_tensor(True)\n    volatilities = tf.convert_to_tensor(0.25, dtype=dtype)\n\n    def price_barriers_option(samples):\n        return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]\n\n    def xla_compiled_op(samples):\n        return tf.function(price_barriers_option, jit_compile=True)(samples)\n    price = xla_compiled_op([volatilities, strikes, expiries, spots, discount_rates, dividend_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options])\n    self.assertAllClose(price, expected_price, 0.01)",
            "def barrier_option_call_xla(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests barrier option price with XLA.'\n    dtype = tf.float64\n    spots = tf.convert_to_tensor(100.0, dtype=dtype)\n    rebates = tf.convert_to_tensor(3.0, dtype=dtype)\n    expiries = tf.convert_to_tensor(0.5, dtype=dtype)\n    discount_rates = tf.convert_to_tensor(0.08, dtype=dtype)\n    dividend_rates = tf.convert_to_tensor(0.04, dtype=dtype)\n    strikes = tf.convert_to_tensor(90.0, dtype=dtype)\n    barriers = tf.convert_to_tensor(95.0, dtype=dtype)\n    expected_price = tf.convert_to_tensor(9.0246, dtype=dtype)\n    is_call_options = tf.convert_to_tensor(True)\n    is_barrier_down = tf.convert_to_tensor(True)\n    is_knock_out = tf.convert_to_tensor(True)\n    volatilities = tf.convert_to_tensor(0.25, dtype=dtype)\n\n    def price_barriers_option(samples):\n        return tff.black_scholes.barrier_price(volatilities=samples[0], strikes=samples[1], expiries=samples[2], spots=samples[3], discount_rates=samples[3], dividend_rates=samples[4], barriers=samples[5], rebates=samples[6], is_barrier_down=samples[7], is_knock_out=samples[8], is_call_options=samples[9])[0]\n\n    def xla_compiled_op(samples):\n        return tf.function(price_barriers_option, jit_compile=True)(samples)\n    price = xla_compiled_op([volatilities, strikes, expiries, spots, discount_rates, dividend_rates, barriers, rebates, is_barrier_down, is_knock_out, is_call_options])\n    self.assertAllClose(price, expected_price, 0.01)"
        ]
    },
    {
        "func_name": "test_swaption_price",
        "original": "@parameterized.named_parameters({'testcase_name': 'NormalModel', 'is_normal_model': True, 'volatilities': [0.01, 0.005], 'expected_price': [0.3458467885511461, 0.3014786656395892]}, {'testcase_name': 'LognormalModel', 'is_normal_model': False, 'volatilities': [1.0, 0.5], 'expected_price': [0.34885593, 0.31643427]})\ndef test_swaption_price(self, is_normal_model, volatilities, expected_price):\n    \"\"\"Function tests swaption pricing.\"\"\"\n    dtype = tf.float64\n    expiries = [1.0, 1.0]\n    float_leg_start_times = [[1.0, 1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0], [1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75]]\n    float_leg_end_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    fixed_leg_payment_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    float_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_coupon = [0.011, 0.011]\n    discount_fn = lambda x: np.exp(-0.01 * np.array(x))\n    price = self.evaluate(tff.black_scholes.swaption_price(volatilities=volatilities, expiries=expiries, floating_leg_start_times=float_leg_start_times, floating_leg_end_times=float_leg_end_times, fixed_leg_payment_times=fixed_leg_payment_times, floating_leg_daycount_fractions=float_leg_daycount_fractions, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, floating_leg_start_times_discount_factors=discount_fn(float_leg_start_times), floating_leg_end_times_discount_factors=discount_fn(float_leg_end_times), fixed_leg_payment_times_discount_factors=discount_fn(fixed_leg_payment_times), is_normal_volatility=is_normal_model, notional=100.0, dtype=dtype))\n    self.assertAllClose(price, expected_price, 1e-06)",
        "mutated": [
            "@parameterized.named_parameters({'testcase_name': 'NormalModel', 'is_normal_model': True, 'volatilities': [0.01, 0.005], 'expected_price': [0.3458467885511461, 0.3014786656395892]}, {'testcase_name': 'LognormalModel', 'is_normal_model': False, 'volatilities': [1.0, 0.5], 'expected_price': [0.34885593, 0.31643427]})\ndef test_swaption_price(self, is_normal_model, volatilities, expected_price):\n    if False:\n        i = 10\n    'Function tests swaption pricing.'\n    dtype = tf.float64\n    expiries = [1.0, 1.0]\n    float_leg_start_times = [[1.0, 1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0], [1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75]]\n    float_leg_end_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    fixed_leg_payment_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    float_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_coupon = [0.011, 0.011]\n    discount_fn = lambda x: np.exp(-0.01 * np.array(x))\n    price = self.evaluate(tff.black_scholes.swaption_price(volatilities=volatilities, expiries=expiries, floating_leg_start_times=float_leg_start_times, floating_leg_end_times=float_leg_end_times, fixed_leg_payment_times=fixed_leg_payment_times, floating_leg_daycount_fractions=float_leg_daycount_fractions, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, floating_leg_start_times_discount_factors=discount_fn(float_leg_start_times), floating_leg_end_times_discount_factors=discount_fn(float_leg_end_times), fixed_leg_payment_times_discount_factors=discount_fn(fixed_leg_payment_times), is_normal_volatility=is_normal_model, notional=100.0, dtype=dtype))\n    self.assertAllClose(price, expected_price, 1e-06)",
            "@parameterized.named_parameters({'testcase_name': 'NormalModel', 'is_normal_model': True, 'volatilities': [0.01, 0.005], 'expected_price': [0.3458467885511461, 0.3014786656395892]}, {'testcase_name': 'LognormalModel', 'is_normal_model': False, 'volatilities': [1.0, 0.5], 'expected_price': [0.34885593, 0.31643427]})\ndef test_swaption_price(self, is_normal_model, volatilities, expected_price):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Function tests swaption pricing.'\n    dtype = tf.float64\n    expiries = [1.0, 1.0]\n    float_leg_start_times = [[1.0, 1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0], [1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75]]\n    float_leg_end_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    fixed_leg_payment_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    float_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_coupon = [0.011, 0.011]\n    discount_fn = lambda x: np.exp(-0.01 * np.array(x))\n    price = self.evaluate(tff.black_scholes.swaption_price(volatilities=volatilities, expiries=expiries, floating_leg_start_times=float_leg_start_times, floating_leg_end_times=float_leg_end_times, fixed_leg_payment_times=fixed_leg_payment_times, floating_leg_daycount_fractions=float_leg_daycount_fractions, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, floating_leg_start_times_discount_factors=discount_fn(float_leg_start_times), floating_leg_end_times_discount_factors=discount_fn(float_leg_end_times), fixed_leg_payment_times_discount_factors=discount_fn(fixed_leg_payment_times), is_normal_volatility=is_normal_model, notional=100.0, dtype=dtype))\n    self.assertAllClose(price, expected_price, 1e-06)",
            "@parameterized.named_parameters({'testcase_name': 'NormalModel', 'is_normal_model': True, 'volatilities': [0.01, 0.005], 'expected_price': [0.3458467885511461, 0.3014786656395892]}, {'testcase_name': 'LognormalModel', 'is_normal_model': False, 'volatilities': [1.0, 0.5], 'expected_price': [0.34885593, 0.31643427]})\ndef test_swaption_price(self, is_normal_model, volatilities, expected_price):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Function tests swaption pricing.'\n    dtype = tf.float64\n    expiries = [1.0, 1.0]\n    float_leg_start_times = [[1.0, 1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0], [1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75]]\n    float_leg_end_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    fixed_leg_payment_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    float_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_coupon = [0.011, 0.011]\n    discount_fn = lambda x: np.exp(-0.01 * np.array(x))\n    price = self.evaluate(tff.black_scholes.swaption_price(volatilities=volatilities, expiries=expiries, floating_leg_start_times=float_leg_start_times, floating_leg_end_times=float_leg_end_times, fixed_leg_payment_times=fixed_leg_payment_times, floating_leg_daycount_fractions=float_leg_daycount_fractions, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, floating_leg_start_times_discount_factors=discount_fn(float_leg_start_times), floating_leg_end_times_discount_factors=discount_fn(float_leg_end_times), fixed_leg_payment_times_discount_factors=discount_fn(fixed_leg_payment_times), is_normal_volatility=is_normal_model, notional=100.0, dtype=dtype))\n    self.assertAllClose(price, expected_price, 1e-06)",
            "@parameterized.named_parameters({'testcase_name': 'NormalModel', 'is_normal_model': True, 'volatilities': [0.01, 0.005], 'expected_price': [0.3458467885511461, 0.3014786656395892]}, {'testcase_name': 'LognormalModel', 'is_normal_model': False, 'volatilities': [1.0, 0.5], 'expected_price': [0.34885593, 0.31643427]})\ndef test_swaption_price(self, is_normal_model, volatilities, expected_price):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Function tests swaption pricing.'\n    dtype = tf.float64\n    expiries = [1.0, 1.0]\n    float_leg_start_times = [[1.0, 1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0], [1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75]]\n    float_leg_end_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    fixed_leg_payment_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    float_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_coupon = [0.011, 0.011]\n    discount_fn = lambda x: np.exp(-0.01 * np.array(x))\n    price = self.evaluate(tff.black_scholes.swaption_price(volatilities=volatilities, expiries=expiries, floating_leg_start_times=float_leg_start_times, floating_leg_end_times=float_leg_end_times, fixed_leg_payment_times=fixed_leg_payment_times, floating_leg_daycount_fractions=float_leg_daycount_fractions, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, floating_leg_start_times_discount_factors=discount_fn(float_leg_start_times), floating_leg_end_times_discount_factors=discount_fn(float_leg_end_times), fixed_leg_payment_times_discount_factors=discount_fn(fixed_leg_payment_times), is_normal_volatility=is_normal_model, notional=100.0, dtype=dtype))\n    self.assertAllClose(price, expected_price, 1e-06)",
            "@parameterized.named_parameters({'testcase_name': 'NormalModel', 'is_normal_model': True, 'volatilities': [0.01, 0.005], 'expected_price': [0.3458467885511461, 0.3014786656395892]}, {'testcase_name': 'LognormalModel', 'is_normal_model': False, 'volatilities': [1.0, 0.5], 'expected_price': [0.34885593, 0.31643427]})\ndef test_swaption_price(self, is_normal_model, volatilities, expected_price):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Function tests swaption pricing.'\n    dtype = tf.float64\n    expiries = [1.0, 1.0]\n    float_leg_start_times = [[1.0, 1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0], [1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75]]\n    float_leg_end_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    fixed_leg_payment_times = [[1.25, 1.5, 1.75, 2.0, 2.0, 2.0, 2.0, 2.0], [1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]]\n    float_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_daycount_fractions = [[0.25, 0.25, 0.25, 0.25, 0.0, 0.0, 0.0, 0.0], [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]]\n    fixed_leg_coupon = [0.011, 0.011]\n    discount_fn = lambda x: np.exp(-0.01 * np.array(x))\n    price = self.evaluate(tff.black_scholes.swaption_price(volatilities=volatilities, expiries=expiries, floating_leg_start_times=float_leg_start_times, floating_leg_end_times=float_leg_end_times, fixed_leg_payment_times=fixed_leg_payment_times, floating_leg_daycount_fractions=float_leg_daycount_fractions, fixed_leg_daycount_fractions=fixed_leg_daycount_fractions, fixed_leg_coupon=fixed_leg_coupon, floating_leg_start_times_discount_factors=discount_fn(float_leg_start_times), floating_leg_end_times_discount_factors=discount_fn(float_leg_end_times), fixed_leg_payment_times_discount_factors=discount_fn(fixed_leg_payment_times), is_normal_volatility=is_normal_model, notional=100.0, dtype=dtype))\n    self.assertAllClose(price, expected_price, 1e-06)"
        ]
    }
]