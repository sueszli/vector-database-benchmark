[
    {
        "func_name": "__init__",
        "original": "def __init__(self, endog):\n    if not isinstance(endog, pd.DataFrame):\n        endog = pd.DataFrame(endog)\n    k = endog.shape[1]\n    augmented = lagmat(endog, 1, trim='both', original='in', use_pandas=True)\n    endog = augmented.iloc[:, :k]\n    exog = add_constant(augmented.iloc[:, k:])\n    k_states = k * (k + 1)\n    super().__init__(endog, k_states=k_states)\n    self.ssm.initialize('known', stationary_cov=np.eye(self.k_states) * 5)\n    self['design'] = np.zeros((self.k_endog, self.k_states, self.nobs))\n    for i in range(self.k_endog):\n        start = i * (self.k_endog + 1)\n        end = start + self.k_endog + 1\n        self['design', i, start:end, :] = exog.T\n    self['transition'] = np.eye(k_states)\n    self['selection'] = np.eye(k_states)\n    self._obs_cov_slice = np.s_[:self.k_endog * (self.k_endog + 1) // 2]\n    self._obs_cov_tril = np.tril_indices(self.k_endog)\n    self._state_cov_slice = np.s_[-self.k_states:]\n    self._state_cov_ix = ('state_cov',) + np.diag_indices(self.k_states)",
        "mutated": [
            "def __init__(self, endog):\n    if False:\n        i = 10\n    if not isinstance(endog, pd.DataFrame):\n        endog = pd.DataFrame(endog)\n    k = endog.shape[1]\n    augmented = lagmat(endog, 1, trim='both', original='in', use_pandas=True)\n    endog = augmented.iloc[:, :k]\n    exog = add_constant(augmented.iloc[:, k:])\n    k_states = k * (k + 1)\n    super().__init__(endog, k_states=k_states)\n    self.ssm.initialize('known', stationary_cov=np.eye(self.k_states) * 5)\n    self['design'] = np.zeros((self.k_endog, self.k_states, self.nobs))\n    for i in range(self.k_endog):\n        start = i * (self.k_endog + 1)\n        end = start + self.k_endog + 1\n        self['design', i, start:end, :] = exog.T\n    self['transition'] = np.eye(k_states)\n    self['selection'] = np.eye(k_states)\n    self._obs_cov_slice = np.s_[:self.k_endog * (self.k_endog + 1) // 2]\n    self._obs_cov_tril = np.tril_indices(self.k_endog)\n    self._state_cov_slice = np.s_[-self.k_states:]\n    self._state_cov_ix = ('state_cov',) + np.diag_indices(self.k_states)",
            "def __init__(self, endog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not isinstance(endog, pd.DataFrame):\n        endog = pd.DataFrame(endog)\n    k = endog.shape[1]\n    augmented = lagmat(endog, 1, trim='both', original='in', use_pandas=True)\n    endog = augmented.iloc[:, :k]\n    exog = add_constant(augmented.iloc[:, k:])\n    k_states = k * (k + 1)\n    super().__init__(endog, k_states=k_states)\n    self.ssm.initialize('known', stationary_cov=np.eye(self.k_states) * 5)\n    self['design'] = np.zeros((self.k_endog, self.k_states, self.nobs))\n    for i in range(self.k_endog):\n        start = i * (self.k_endog + 1)\n        end = start + self.k_endog + 1\n        self['design', i, start:end, :] = exog.T\n    self['transition'] = np.eye(k_states)\n    self['selection'] = np.eye(k_states)\n    self._obs_cov_slice = np.s_[:self.k_endog * (self.k_endog + 1) // 2]\n    self._obs_cov_tril = np.tril_indices(self.k_endog)\n    self._state_cov_slice = np.s_[-self.k_states:]\n    self._state_cov_ix = ('state_cov',) + np.diag_indices(self.k_states)",
            "def __init__(self, endog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not isinstance(endog, pd.DataFrame):\n        endog = pd.DataFrame(endog)\n    k = endog.shape[1]\n    augmented = lagmat(endog, 1, trim='both', original='in', use_pandas=True)\n    endog = augmented.iloc[:, :k]\n    exog = add_constant(augmented.iloc[:, k:])\n    k_states = k * (k + 1)\n    super().__init__(endog, k_states=k_states)\n    self.ssm.initialize('known', stationary_cov=np.eye(self.k_states) * 5)\n    self['design'] = np.zeros((self.k_endog, self.k_states, self.nobs))\n    for i in range(self.k_endog):\n        start = i * (self.k_endog + 1)\n        end = start + self.k_endog + 1\n        self['design', i, start:end, :] = exog.T\n    self['transition'] = np.eye(k_states)\n    self['selection'] = np.eye(k_states)\n    self._obs_cov_slice = np.s_[:self.k_endog * (self.k_endog + 1) // 2]\n    self._obs_cov_tril = np.tril_indices(self.k_endog)\n    self._state_cov_slice = np.s_[-self.k_states:]\n    self._state_cov_ix = ('state_cov',) + np.diag_indices(self.k_states)",
            "def __init__(self, endog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not isinstance(endog, pd.DataFrame):\n        endog = pd.DataFrame(endog)\n    k = endog.shape[1]\n    augmented = lagmat(endog, 1, trim='both', original='in', use_pandas=True)\n    endog = augmented.iloc[:, :k]\n    exog = add_constant(augmented.iloc[:, k:])\n    k_states = k * (k + 1)\n    super().__init__(endog, k_states=k_states)\n    self.ssm.initialize('known', stationary_cov=np.eye(self.k_states) * 5)\n    self['design'] = np.zeros((self.k_endog, self.k_states, self.nobs))\n    for i in range(self.k_endog):\n        start = i * (self.k_endog + 1)\n        end = start + self.k_endog + 1\n        self['design', i, start:end, :] = exog.T\n    self['transition'] = np.eye(k_states)\n    self['selection'] = np.eye(k_states)\n    self._obs_cov_slice = np.s_[:self.k_endog * (self.k_endog + 1) // 2]\n    self._obs_cov_tril = np.tril_indices(self.k_endog)\n    self._state_cov_slice = np.s_[-self.k_states:]\n    self._state_cov_ix = ('state_cov',) + np.diag_indices(self.k_states)",
            "def __init__(self, endog):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not isinstance(endog, pd.DataFrame):\n        endog = pd.DataFrame(endog)\n    k = endog.shape[1]\n    augmented = lagmat(endog, 1, trim='both', original='in', use_pandas=True)\n    endog = augmented.iloc[:, :k]\n    exog = add_constant(augmented.iloc[:, k:])\n    k_states = k * (k + 1)\n    super().__init__(endog, k_states=k_states)\n    self.ssm.initialize('known', stationary_cov=np.eye(self.k_states) * 5)\n    self['design'] = np.zeros((self.k_endog, self.k_states, self.nobs))\n    for i in range(self.k_endog):\n        start = i * (self.k_endog + 1)\n        end = start + self.k_endog + 1\n        self['design', i, start:end, :] = exog.T\n    self['transition'] = np.eye(k_states)\n    self['selection'] = np.eye(k_states)\n    self._obs_cov_slice = np.s_[:self.k_endog * (self.k_endog + 1) // 2]\n    self._obs_cov_tril = np.tril_indices(self.k_endog)\n    self._state_cov_slice = np.s_[-self.k_states:]\n    self._state_cov_ix = ('state_cov',) + np.diag_indices(self.k_states)"
        ]
    },
    {
        "func_name": "state_names",
        "original": "@property\ndef state_names(self):\n    state_names = []\n    for i in range(self.k_endog):\n        endog_name = self.endog_names[i]\n        state_names += ['intercept.%s' % endog_name]\n        state_names += ['L1.%s->%s' % (other_name, endog_name) for other_name in self.endog_names]\n    return state_names",
        "mutated": [
            "@property\ndef state_names(self):\n    if False:\n        i = 10\n    state_names = []\n    for i in range(self.k_endog):\n        endog_name = self.endog_names[i]\n        state_names += ['intercept.%s' % endog_name]\n        state_names += ['L1.%s->%s' % (other_name, endog_name) for other_name in self.endog_names]\n    return state_names",
            "@property\ndef state_names(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    state_names = []\n    for i in range(self.k_endog):\n        endog_name = self.endog_names[i]\n        state_names += ['intercept.%s' % endog_name]\n        state_names += ['L1.%s->%s' % (other_name, endog_name) for other_name in self.endog_names]\n    return state_names",
            "@property\ndef state_names(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    state_names = []\n    for i in range(self.k_endog):\n        endog_name = self.endog_names[i]\n        state_names += ['intercept.%s' % endog_name]\n        state_names += ['L1.%s->%s' % (other_name, endog_name) for other_name in self.endog_names]\n    return state_names",
            "@property\ndef state_names(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    state_names = []\n    for i in range(self.k_endog):\n        endog_name = self.endog_names[i]\n        state_names += ['intercept.%s' % endog_name]\n        state_names += ['L1.%s->%s' % (other_name, endog_name) for other_name in self.endog_names]\n    return state_names",
            "@property\ndef state_names(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    state_names = []\n    for i in range(self.k_endog):\n        endog_name = self.endog_names[i]\n        state_names += ['intercept.%s' % endog_name]\n        state_names += ['L1.%s->%s' % (other_name, endog_name) for other_name in self.endog_names]\n    return state_names"
        ]
    },
    {
        "func_name": "update_direct",
        "original": "def update_direct(self, obs_cov, state_cov_diag):\n    self['obs_cov'] = obs_cov\n    self[self._state_cov_ix] = state_cov_diag",
        "mutated": [
            "def update_direct(self, obs_cov, state_cov_diag):\n    if False:\n        i = 10\n    self['obs_cov'] = obs_cov\n    self[self._state_cov_ix] = state_cov_diag",
            "def update_direct(self, obs_cov, state_cov_diag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self['obs_cov'] = obs_cov\n    self[self._state_cov_ix] = state_cov_diag",
            "def update_direct(self, obs_cov, state_cov_diag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self['obs_cov'] = obs_cov\n    self[self._state_cov_ix] = state_cov_diag",
            "def update_direct(self, obs_cov, state_cov_diag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self['obs_cov'] = obs_cov\n    self[self._state_cov_ix] = state_cov_diag",
            "def update_direct(self, obs_cov, state_cov_diag):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self['obs_cov'] = obs_cov\n    self[self._state_cov_ix] = state_cov_diag"
        ]
    },
    {
        "func_name": "test_tvpvar",
        "original": "def test_tvpvar():\n    mod = TVPVAR(endog.iloc[2:])\n    sim = mod.simulation_smoother(method='cfa')\n    v10 = mod.k_endog + 3\n    S10 = np.eye(mod.k_endog)\n    vi0 = np.ones(mod.k_states) * 6 / 2\n    Si0 = np.ones(mod.k_states) * 0.01 / 2\n    initial_obs_cov = np.cov(endog.T)\n    initial_state_cov_vars = np.ones(mod.k_states) * 0.01\n    mod.update_direct(initial_obs_cov, initial_state_cov_vars)\n    res = mod.ssm.smooth()\n    variates_1 = results['state_variates'].iloc[:6]\n    sim.simulate(variates_1)\n    posterior_mean_1 = results['posterior_mean'].iloc[:6]\n    assert_allclose(sim.posterior_mean, posterior_mean_1)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_1 = np.linalg.inv(results['invP'].iloc[:54])\n    assert_allclose(sim.posterior_cov, posterior_cov_1)\n    simulated_state_1 = results['beta'].iloc[:6]\n    assert_allclose(sim.simulated_state, simulated_state_1)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[:2])\n    assert_allclose(scale, results['S10'].iloc[:, :2])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 0])\n    assert_allclose(scales, results['Si0'].iloc[:, 0])\n    mod.update_direct(results['Omega_11'].iloc[:, :2], results['Omega_22'].iloc[:, 0])\n    res = mod.ssm.smooth()\n    variates_2 = results['state_variates'].iloc[6:]\n    sim.simulate(variates_2)\n    posterior_mean_2 = results['posterior_mean'].iloc[6:]\n    assert_allclose(sim.posterior_mean, posterior_mean_2)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_2 = np.linalg.inv(results['invP'].iloc[54:])\n    assert_allclose(sim.posterior_cov, posterior_cov_2)\n    simulated_state_2 = results['beta'].iloc[6:]\n    assert_allclose(sim.simulated_state, simulated_state_2)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[2:])\n    assert_allclose(scale, results['S10'].iloc[:, 2:])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 1])\n    assert_allclose(scales, results['Si0'].iloc[:, 1])",
        "mutated": [
            "def test_tvpvar():\n    if False:\n        i = 10\n    mod = TVPVAR(endog.iloc[2:])\n    sim = mod.simulation_smoother(method='cfa')\n    v10 = mod.k_endog + 3\n    S10 = np.eye(mod.k_endog)\n    vi0 = np.ones(mod.k_states) * 6 / 2\n    Si0 = np.ones(mod.k_states) * 0.01 / 2\n    initial_obs_cov = np.cov(endog.T)\n    initial_state_cov_vars = np.ones(mod.k_states) * 0.01\n    mod.update_direct(initial_obs_cov, initial_state_cov_vars)\n    res = mod.ssm.smooth()\n    variates_1 = results['state_variates'].iloc[:6]\n    sim.simulate(variates_1)\n    posterior_mean_1 = results['posterior_mean'].iloc[:6]\n    assert_allclose(sim.posterior_mean, posterior_mean_1)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_1 = np.linalg.inv(results['invP'].iloc[:54])\n    assert_allclose(sim.posterior_cov, posterior_cov_1)\n    simulated_state_1 = results['beta'].iloc[:6]\n    assert_allclose(sim.simulated_state, simulated_state_1)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[:2])\n    assert_allclose(scale, results['S10'].iloc[:, :2])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 0])\n    assert_allclose(scales, results['Si0'].iloc[:, 0])\n    mod.update_direct(results['Omega_11'].iloc[:, :2], results['Omega_22'].iloc[:, 0])\n    res = mod.ssm.smooth()\n    variates_2 = results['state_variates'].iloc[6:]\n    sim.simulate(variates_2)\n    posterior_mean_2 = results['posterior_mean'].iloc[6:]\n    assert_allclose(sim.posterior_mean, posterior_mean_2)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_2 = np.linalg.inv(results['invP'].iloc[54:])\n    assert_allclose(sim.posterior_cov, posterior_cov_2)\n    simulated_state_2 = results['beta'].iloc[6:]\n    assert_allclose(sim.simulated_state, simulated_state_2)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[2:])\n    assert_allclose(scale, results['S10'].iloc[:, 2:])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 1])\n    assert_allclose(scales, results['Si0'].iloc[:, 1])",
            "def test_tvpvar():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    mod = TVPVAR(endog.iloc[2:])\n    sim = mod.simulation_smoother(method='cfa')\n    v10 = mod.k_endog + 3\n    S10 = np.eye(mod.k_endog)\n    vi0 = np.ones(mod.k_states) * 6 / 2\n    Si0 = np.ones(mod.k_states) * 0.01 / 2\n    initial_obs_cov = np.cov(endog.T)\n    initial_state_cov_vars = np.ones(mod.k_states) * 0.01\n    mod.update_direct(initial_obs_cov, initial_state_cov_vars)\n    res = mod.ssm.smooth()\n    variates_1 = results['state_variates'].iloc[:6]\n    sim.simulate(variates_1)\n    posterior_mean_1 = results['posterior_mean'].iloc[:6]\n    assert_allclose(sim.posterior_mean, posterior_mean_1)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_1 = np.linalg.inv(results['invP'].iloc[:54])\n    assert_allclose(sim.posterior_cov, posterior_cov_1)\n    simulated_state_1 = results['beta'].iloc[:6]\n    assert_allclose(sim.simulated_state, simulated_state_1)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[:2])\n    assert_allclose(scale, results['S10'].iloc[:, :2])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 0])\n    assert_allclose(scales, results['Si0'].iloc[:, 0])\n    mod.update_direct(results['Omega_11'].iloc[:, :2], results['Omega_22'].iloc[:, 0])\n    res = mod.ssm.smooth()\n    variates_2 = results['state_variates'].iloc[6:]\n    sim.simulate(variates_2)\n    posterior_mean_2 = results['posterior_mean'].iloc[6:]\n    assert_allclose(sim.posterior_mean, posterior_mean_2)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_2 = np.linalg.inv(results['invP'].iloc[54:])\n    assert_allclose(sim.posterior_cov, posterior_cov_2)\n    simulated_state_2 = results['beta'].iloc[6:]\n    assert_allclose(sim.simulated_state, simulated_state_2)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[2:])\n    assert_allclose(scale, results['S10'].iloc[:, 2:])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 1])\n    assert_allclose(scales, results['Si0'].iloc[:, 1])",
            "def test_tvpvar():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    mod = TVPVAR(endog.iloc[2:])\n    sim = mod.simulation_smoother(method='cfa')\n    v10 = mod.k_endog + 3\n    S10 = np.eye(mod.k_endog)\n    vi0 = np.ones(mod.k_states) * 6 / 2\n    Si0 = np.ones(mod.k_states) * 0.01 / 2\n    initial_obs_cov = np.cov(endog.T)\n    initial_state_cov_vars = np.ones(mod.k_states) * 0.01\n    mod.update_direct(initial_obs_cov, initial_state_cov_vars)\n    res = mod.ssm.smooth()\n    variates_1 = results['state_variates'].iloc[:6]\n    sim.simulate(variates_1)\n    posterior_mean_1 = results['posterior_mean'].iloc[:6]\n    assert_allclose(sim.posterior_mean, posterior_mean_1)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_1 = np.linalg.inv(results['invP'].iloc[:54])\n    assert_allclose(sim.posterior_cov, posterior_cov_1)\n    simulated_state_1 = results['beta'].iloc[:6]\n    assert_allclose(sim.simulated_state, simulated_state_1)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[:2])\n    assert_allclose(scale, results['S10'].iloc[:, :2])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 0])\n    assert_allclose(scales, results['Si0'].iloc[:, 0])\n    mod.update_direct(results['Omega_11'].iloc[:, :2], results['Omega_22'].iloc[:, 0])\n    res = mod.ssm.smooth()\n    variates_2 = results['state_variates'].iloc[6:]\n    sim.simulate(variates_2)\n    posterior_mean_2 = results['posterior_mean'].iloc[6:]\n    assert_allclose(sim.posterior_mean, posterior_mean_2)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_2 = np.linalg.inv(results['invP'].iloc[54:])\n    assert_allclose(sim.posterior_cov, posterior_cov_2)\n    simulated_state_2 = results['beta'].iloc[6:]\n    assert_allclose(sim.simulated_state, simulated_state_2)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[2:])\n    assert_allclose(scale, results['S10'].iloc[:, 2:])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 1])\n    assert_allclose(scales, results['Si0'].iloc[:, 1])",
            "def test_tvpvar():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    mod = TVPVAR(endog.iloc[2:])\n    sim = mod.simulation_smoother(method='cfa')\n    v10 = mod.k_endog + 3\n    S10 = np.eye(mod.k_endog)\n    vi0 = np.ones(mod.k_states) * 6 / 2\n    Si0 = np.ones(mod.k_states) * 0.01 / 2\n    initial_obs_cov = np.cov(endog.T)\n    initial_state_cov_vars = np.ones(mod.k_states) * 0.01\n    mod.update_direct(initial_obs_cov, initial_state_cov_vars)\n    res = mod.ssm.smooth()\n    variates_1 = results['state_variates'].iloc[:6]\n    sim.simulate(variates_1)\n    posterior_mean_1 = results['posterior_mean'].iloc[:6]\n    assert_allclose(sim.posterior_mean, posterior_mean_1)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_1 = np.linalg.inv(results['invP'].iloc[:54])\n    assert_allclose(sim.posterior_cov, posterior_cov_1)\n    simulated_state_1 = results['beta'].iloc[:6]\n    assert_allclose(sim.simulated_state, simulated_state_1)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[:2])\n    assert_allclose(scale, results['S10'].iloc[:, :2])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 0])\n    assert_allclose(scales, results['Si0'].iloc[:, 0])\n    mod.update_direct(results['Omega_11'].iloc[:, :2], results['Omega_22'].iloc[:, 0])\n    res = mod.ssm.smooth()\n    variates_2 = results['state_variates'].iloc[6:]\n    sim.simulate(variates_2)\n    posterior_mean_2 = results['posterior_mean'].iloc[6:]\n    assert_allclose(sim.posterior_mean, posterior_mean_2)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_2 = np.linalg.inv(results['invP'].iloc[54:])\n    assert_allclose(sim.posterior_cov, posterior_cov_2)\n    simulated_state_2 = results['beta'].iloc[6:]\n    assert_allclose(sim.simulated_state, simulated_state_2)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[2:])\n    assert_allclose(scale, results['S10'].iloc[:, 2:])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 1])\n    assert_allclose(scales, results['Si0'].iloc[:, 1])",
            "def test_tvpvar():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    mod = TVPVAR(endog.iloc[2:])\n    sim = mod.simulation_smoother(method='cfa')\n    v10 = mod.k_endog + 3\n    S10 = np.eye(mod.k_endog)\n    vi0 = np.ones(mod.k_states) * 6 / 2\n    Si0 = np.ones(mod.k_states) * 0.01 / 2\n    initial_obs_cov = np.cov(endog.T)\n    initial_state_cov_vars = np.ones(mod.k_states) * 0.01\n    mod.update_direct(initial_obs_cov, initial_state_cov_vars)\n    res = mod.ssm.smooth()\n    variates_1 = results['state_variates'].iloc[:6]\n    sim.simulate(variates_1)\n    posterior_mean_1 = results['posterior_mean'].iloc[:6]\n    assert_allclose(sim.posterior_mean, posterior_mean_1)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_1 = np.linalg.inv(results['invP'].iloc[:54])\n    assert_allclose(sim.posterior_cov, posterior_cov_1)\n    simulated_state_1 = results['beta'].iloc[:6]\n    assert_allclose(sim.simulated_state, simulated_state_1)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[:2])\n    assert_allclose(scale, results['S10'].iloc[:, :2])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 0])\n    assert_allclose(scales, results['Si0'].iloc[:, 0])\n    mod.update_direct(results['Omega_11'].iloc[:, :2], results['Omega_22'].iloc[:, 0])\n    res = mod.ssm.smooth()\n    variates_2 = results['state_variates'].iloc[6:]\n    sim.simulate(variates_2)\n    posterior_mean_2 = results['posterior_mean'].iloc[6:]\n    assert_allclose(sim.posterior_mean, posterior_mean_2)\n    assert_allclose(sim.posterior_mean, res.smoothed_state)\n    posterior_cov_2 = np.linalg.inv(results['invP'].iloc[54:])\n    assert_allclose(sim.posterior_cov, posterior_cov_2)\n    simulated_state_2 = results['beta'].iloc[6:]\n    assert_allclose(sim.simulated_state, simulated_state_2)\n    fitted = np.matmul(mod['design'].transpose(2, 0, 1), sim.simulated_state.T[..., None])[..., 0]\n    resid = mod.endog - fitted\n    df = v10 + mod.nobs\n    scale = S10 + np.dot(resid.T, resid)\n    assert_allclose(df, results['v10'].iloc[2:])\n    assert_allclose(scale, results['S10'].iloc[:, 2:])\n    resid = sim.simulated_state.T[1:] - sim.simulated_state.T[:-1]\n    sse = np.sum(resid ** 2, axis=0)\n    shapes = vi0 + (mod.nobs - 1) / 2\n    scales = Si0 + sse / 2\n    assert_allclose(shapes, results['vi0'].values[0, 1])\n    assert_allclose(scales, results['Si0'].iloc[:, 1])"
        ]
    }
]