[
    {
        "func_name": "test_inpaint_biharmonic_2d",
        "original": "@testing.parametrize('dtype', [np.float16, np.float32, np.float64])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_2d(dtype, split_into_regions):\n    img = np.tile(np.square(np.linspace(0, 1, 5, dtype=dtype)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    assert out.dtype == _supported_float_type(img.dtype)\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    rtol = 1e-07 if dtype == np.float64 else 1e-06\n    assert_allclose(ref, out, rtol=rtol)",
        "mutated": [
            "@testing.parametrize('dtype', [np.float16, np.float32, np.float64])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_2d(dtype, split_into_regions):\n    if False:\n        i = 10\n    img = np.tile(np.square(np.linspace(0, 1, 5, dtype=dtype)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    assert out.dtype == _supported_float_type(img.dtype)\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    rtol = 1e-07 if dtype == np.float64 else 1e-06\n    assert_allclose(ref, out, rtol=rtol)",
            "@testing.parametrize('dtype', [np.float16, np.float32, np.float64])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_2d(dtype, split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    img = np.tile(np.square(np.linspace(0, 1, 5, dtype=dtype)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    assert out.dtype == _supported_float_type(img.dtype)\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    rtol = 1e-07 if dtype == np.float64 else 1e-06\n    assert_allclose(ref, out, rtol=rtol)",
            "@testing.parametrize('dtype', [np.float16, np.float32, np.float64])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_2d(dtype, split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    img = np.tile(np.square(np.linspace(0, 1, 5, dtype=dtype)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    assert out.dtype == _supported_float_type(img.dtype)\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    rtol = 1e-07 if dtype == np.float64 else 1e-06\n    assert_allclose(ref, out, rtol=rtol)",
            "@testing.parametrize('dtype', [np.float16, np.float32, np.float64])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_2d(dtype, split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    img = np.tile(np.square(np.linspace(0, 1, 5, dtype=dtype)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    assert out.dtype == _supported_float_type(img.dtype)\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    rtol = 1e-07 if dtype == np.float64 else 1e-06\n    assert_allclose(ref, out, rtol=rtol)",
            "@testing.parametrize('dtype', [np.float16, np.float32, np.float64])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_2d(dtype, split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    img = np.tile(np.square(np.linspace(0, 1, 5, dtype=dtype)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    assert out.dtype == _supported_float_type(img.dtype)\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    rtol = 1e-07 if dtype == np.float64 else 1e-06\n    assert_allclose(ref, out, rtol=rtol)"
        ]
    },
    {
        "func_name": "test_inpaint_biharmonic_2d_color",
        "original": "@testing.parametrize('channel_axis', [0, 1, -1])\ndef test_inpaint_biharmonic_2d_color(channel_axis):\n    img = img_as_float(data.astronaut()[:64, :64])\n    mask = np.zeros(img.shape[:2], dtype=bool)\n    mask[8:16, :16] = 1\n    img_defect = img * ~mask[..., np.newaxis]\n    mse_defect = mean_squared_error(img, img_defect)\n    img_defect = np.moveaxis(img_defect, -1, channel_axis)\n    img_restored = inpaint.inpaint_biharmonic(img_defect, mask, channel_axis=channel_axis)\n    img_restored = np.moveaxis(img_restored, channel_axis, -1)\n    mse_restored = mean_squared_error(img, img_restored)\n    assert mse_restored < 0.01 * mse_defect",
        "mutated": [
            "@testing.parametrize('channel_axis', [0, 1, -1])\ndef test_inpaint_biharmonic_2d_color(channel_axis):\n    if False:\n        i = 10\n    img = img_as_float(data.astronaut()[:64, :64])\n    mask = np.zeros(img.shape[:2], dtype=bool)\n    mask[8:16, :16] = 1\n    img_defect = img * ~mask[..., np.newaxis]\n    mse_defect = mean_squared_error(img, img_defect)\n    img_defect = np.moveaxis(img_defect, -1, channel_axis)\n    img_restored = inpaint.inpaint_biharmonic(img_defect, mask, channel_axis=channel_axis)\n    img_restored = np.moveaxis(img_restored, channel_axis, -1)\n    mse_restored = mean_squared_error(img, img_restored)\n    assert mse_restored < 0.01 * mse_defect",
            "@testing.parametrize('channel_axis', [0, 1, -1])\ndef test_inpaint_biharmonic_2d_color(channel_axis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    img = img_as_float(data.astronaut()[:64, :64])\n    mask = np.zeros(img.shape[:2], dtype=bool)\n    mask[8:16, :16] = 1\n    img_defect = img * ~mask[..., np.newaxis]\n    mse_defect = mean_squared_error(img, img_defect)\n    img_defect = np.moveaxis(img_defect, -1, channel_axis)\n    img_restored = inpaint.inpaint_biharmonic(img_defect, mask, channel_axis=channel_axis)\n    img_restored = np.moveaxis(img_restored, channel_axis, -1)\n    mse_restored = mean_squared_error(img, img_restored)\n    assert mse_restored < 0.01 * mse_defect",
            "@testing.parametrize('channel_axis', [0, 1, -1])\ndef test_inpaint_biharmonic_2d_color(channel_axis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    img = img_as_float(data.astronaut()[:64, :64])\n    mask = np.zeros(img.shape[:2], dtype=bool)\n    mask[8:16, :16] = 1\n    img_defect = img * ~mask[..., np.newaxis]\n    mse_defect = mean_squared_error(img, img_defect)\n    img_defect = np.moveaxis(img_defect, -1, channel_axis)\n    img_restored = inpaint.inpaint_biharmonic(img_defect, mask, channel_axis=channel_axis)\n    img_restored = np.moveaxis(img_restored, channel_axis, -1)\n    mse_restored = mean_squared_error(img, img_restored)\n    assert mse_restored < 0.01 * mse_defect",
            "@testing.parametrize('channel_axis', [0, 1, -1])\ndef test_inpaint_biharmonic_2d_color(channel_axis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    img = img_as_float(data.astronaut()[:64, :64])\n    mask = np.zeros(img.shape[:2], dtype=bool)\n    mask[8:16, :16] = 1\n    img_defect = img * ~mask[..., np.newaxis]\n    mse_defect = mean_squared_error(img, img_defect)\n    img_defect = np.moveaxis(img_defect, -1, channel_axis)\n    img_restored = inpaint.inpaint_biharmonic(img_defect, mask, channel_axis=channel_axis)\n    img_restored = np.moveaxis(img_restored, channel_axis, -1)\n    mse_restored = mean_squared_error(img, img_restored)\n    assert mse_restored < 0.01 * mse_defect",
            "@testing.parametrize('channel_axis', [0, 1, -1])\ndef test_inpaint_biharmonic_2d_color(channel_axis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    img = img_as_float(data.astronaut()[:64, :64])\n    mask = np.zeros(img.shape[:2], dtype=bool)\n    mask[8:16, :16] = 1\n    img_defect = img * ~mask[..., np.newaxis]\n    mse_defect = mean_squared_error(img, img_defect)\n    img_defect = np.moveaxis(img_defect, -1, channel_axis)\n    img_restored = inpaint.inpaint_biharmonic(img_defect, mask, channel_axis=channel_axis)\n    img_restored = np.moveaxis(img_restored, channel_axis, -1)\n    mse_restored = mean_squared_error(img, img_restored)\n    assert mse_restored < 0.01 * mse_defect"
        ]
    },
    {
        "func_name": "test_inpaint_biharmonic_2d_float_dtypes",
        "original": "@testing.parametrize('dtype', [np.float32, np.float64])\ndef test_inpaint_biharmonic_2d_float_dtypes(dtype):\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    img = img.astype(dtype, copy=False)\n    out = inpaint.inpaint_biharmonic(img, mask)\n    assert out.dtype == img.dtype\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    assert_allclose(ref, out, rtol=1e-05)",
        "mutated": [
            "@testing.parametrize('dtype', [np.float32, np.float64])\ndef test_inpaint_biharmonic_2d_float_dtypes(dtype):\n    if False:\n        i = 10\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    img = img.astype(dtype, copy=False)\n    out = inpaint.inpaint_biharmonic(img, mask)\n    assert out.dtype == img.dtype\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    assert_allclose(ref, out, rtol=1e-05)",
            "@testing.parametrize('dtype', [np.float32, np.float64])\ndef test_inpaint_biharmonic_2d_float_dtypes(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    img = img.astype(dtype, copy=False)\n    out = inpaint.inpaint_biharmonic(img, mask)\n    assert out.dtype == img.dtype\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    assert_allclose(ref, out, rtol=1e-05)",
            "@testing.parametrize('dtype', [np.float32, np.float64])\ndef test_inpaint_biharmonic_2d_float_dtypes(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    img = img.astype(dtype, copy=False)\n    out = inpaint.inpaint_biharmonic(img, mask)\n    assert out.dtype == img.dtype\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    assert_allclose(ref, out, rtol=1e-05)",
            "@testing.parametrize('dtype', [np.float32, np.float64])\ndef test_inpaint_biharmonic_2d_float_dtypes(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    img = img.astype(dtype, copy=False)\n    out = inpaint.inpaint_biharmonic(img, mask)\n    assert out.dtype == img.dtype\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    assert_allclose(ref, out, rtol=1e-05)",
            "@testing.parametrize('dtype', [np.float32, np.float64])\ndef test_inpaint_biharmonic_2d_float_dtypes(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    mask = np.zeros_like(img)\n    mask[2, 2:] = 1\n    mask[1, 3:] = 1\n    mask[0, 4:] = 1\n    img[np.where(mask)] = 0\n    img = img.astype(dtype, copy=False)\n    out = inpaint.inpaint_biharmonic(img, mask)\n    assert out.dtype == img.dtype\n    ref = np.array([[0.0, 0.0625, 0.25, 0.5625, 0.73925058], [0.0, 0.0625, 0.25, 0.5478048, 0.76557821], [0.0, 0.0625, 0.25842878, 0.5623079, 0.85927796], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]])\n    assert_allclose(ref, out, rtol=1e-05)"
        ]
    },
    {
        "func_name": "test_inpaint_biharmonic_3d",
        "original": "@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_3d(split_into_regions):\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    img = np.dstack((img, img.T))\n    mask = np.zeros_like(img)\n    mask[2, 2:, :] = 1\n    mask[1, 3:, :] = 1\n    mask[0, 4:, :] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    ref = np.dstack((np.array([[0.0, 0.0625, 0.25, 0.5625, 0.53752796], [0.0, 0.0625, 0.25, 0.4444378, 0.5376221], [0.0, 0.0625, 0.23693666, 0.46621112, 0.68615592], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]]), np.array([[0.0, 0.0, 0.0, 0.0, 0.19621902], [0.0625, 0.0625, 0.0625, 0.17470756, 0.30140091], [0.25, 0.25, 0.27241289, 0.3515544, 0.43068654], [0.5625, 0.5625, 0.5625, 0.5625, 0.5625], [1.0, 1.0, 1.0, 1.0, 1.0]])))\n    assert_allclose(ref, out)",
        "mutated": [
            "@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_3d(split_into_regions):\n    if False:\n        i = 10\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    img = np.dstack((img, img.T))\n    mask = np.zeros_like(img)\n    mask[2, 2:, :] = 1\n    mask[1, 3:, :] = 1\n    mask[0, 4:, :] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    ref = np.dstack((np.array([[0.0, 0.0625, 0.25, 0.5625, 0.53752796], [0.0, 0.0625, 0.25, 0.4444378, 0.5376221], [0.0, 0.0625, 0.23693666, 0.46621112, 0.68615592], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]]), np.array([[0.0, 0.0, 0.0, 0.0, 0.19621902], [0.0625, 0.0625, 0.0625, 0.17470756, 0.30140091], [0.25, 0.25, 0.27241289, 0.3515544, 0.43068654], [0.5625, 0.5625, 0.5625, 0.5625, 0.5625], [1.0, 1.0, 1.0, 1.0, 1.0]])))\n    assert_allclose(ref, out)",
            "@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_3d(split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    img = np.dstack((img, img.T))\n    mask = np.zeros_like(img)\n    mask[2, 2:, :] = 1\n    mask[1, 3:, :] = 1\n    mask[0, 4:, :] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    ref = np.dstack((np.array([[0.0, 0.0625, 0.25, 0.5625, 0.53752796], [0.0, 0.0625, 0.25, 0.4444378, 0.5376221], [0.0, 0.0625, 0.23693666, 0.46621112, 0.68615592], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]]), np.array([[0.0, 0.0, 0.0, 0.0, 0.19621902], [0.0625, 0.0625, 0.0625, 0.17470756, 0.30140091], [0.25, 0.25, 0.27241289, 0.3515544, 0.43068654], [0.5625, 0.5625, 0.5625, 0.5625, 0.5625], [1.0, 1.0, 1.0, 1.0, 1.0]])))\n    assert_allclose(ref, out)",
            "@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_3d(split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    img = np.dstack((img, img.T))\n    mask = np.zeros_like(img)\n    mask[2, 2:, :] = 1\n    mask[1, 3:, :] = 1\n    mask[0, 4:, :] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    ref = np.dstack((np.array([[0.0, 0.0625, 0.25, 0.5625, 0.53752796], [0.0, 0.0625, 0.25, 0.4444378, 0.5376221], [0.0, 0.0625, 0.23693666, 0.46621112, 0.68615592], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]]), np.array([[0.0, 0.0, 0.0, 0.0, 0.19621902], [0.0625, 0.0625, 0.0625, 0.17470756, 0.30140091], [0.25, 0.25, 0.27241289, 0.3515544, 0.43068654], [0.5625, 0.5625, 0.5625, 0.5625, 0.5625], [1.0, 1.0, 1.0, 1.0, 1.0]])))\n    assert_allclose(ref, out)",
            "@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_3d(split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    img = np.dstack((img, img.T))\n    mask = np.zeros_like(img)\n    mask[2, 2:, :] = 1\n    mask[1, 3:, :] = 1\n    mask[0, 4:, :] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    ref = np.dstack((np.array([[0.0, 0.0625, 0.25, 0.5625, 0.53752796], [0.0, 0.0625, 0.25, 0.4444378, 0.5376221], [0.0, 0.0625, 0.23693666, 0.46621112, 0.68615592], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]]), np.array([[0.0, 0.0, 0.0, 0.0, 0.19621902], [0.0625, 0.0625, 0.0625, 0.17470756, 0.30140091], [0.25, 0.25, 0.27241289, 0.3515544, 0.43068654], [0.5625, 0.5625, 0.5625, 0.5625, 0.5625], [1.0, 1.0, 1.0, 1.0, 1.0]])))\n    assert_allclose(ref, out)",
            "@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_biharmonic_3d(split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))\n    img = np.dstack((img, img.T))\n    mask = np.zeros_like(img)\n    mask[2, 2:, :] = 1\n    mask[1, 3:, :] = 1\n    mask[0, 4:, :] = 1\n    img[np.where(mask)] = 0\n    out = inpaint.inpaint_biharmonic(img, mask, split_into_regions=split_into_regions)\n    ref = np.dstack((np.array([[0.0, 0.0625, 0.25, 0.5625, 0.53752796], [0.0, 0.0625, 0.25, 0.4444378, 0.5376221], [0.0, 0.0625, 0.23693666, 0.46621112, 0.68615592], [0.0, 0.0625, 0.25, 0.5625, 1.0], [0.0, 0.0625, 0.25, 0.5625, 1.0]]), np.array([[0.0, 0.0, 0.0, 0.0, 0.19621902], [0.0625, 0.0625, 0.0625, 0.17470756, 0.30140091], [0.25, 0.25, 0.27241289, 0.3515544, 0.43068654], [0.5625, 0.5625, 0.5625, 0.5625, 0.5625], [1.0, 1.0, 1.0, 1.0, 1.0]])))\n    assert_allclose(ref, out)"
        ]
    },
    {
        "func_name": "test_invalid_input",
        "original": "def test_invalid_input():\n    (img, mask) = (np.zeros([]), np.zeros([]))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    (img, mask) = (np.zeros((2, 2)), np.zeros((4, 1)))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    img = np.ma.array(np.zeros((2, 2)), mask=[[0, 0], [0, 0]])\n    mask = np.zeros((2, 2))\n    with testing.raises(TypeError):\n        inpaint.inpaint_biharmonic(img, mask)",
        "mutated": [
            "def test_invalid_input():\n    if False:\n        i = 10\n    (img, mask) = (np.zeros([]), np.zeros([]))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    (img, mask) = (np.zeros((2, 2)), np.zeros((4, 1)))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    img = np.ma.array(np.zeros((2, 2)), mask=[[0, 0], [0, 0]])\n    mask = np.zeros((2, 2))\n    with testing.raises(TypeError):\n        inpaint.inpaint_biharmonic(img, mask)",
            "def test_invalid_input():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (img, mask) = (np.zeros([]), np.zeros([]))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    (img, mask) = (np.zeros((2, 2)), np.zeros((4, 1)))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    img = np.ma.array(np.zeros((2, 2)), mask=[[0, 0], [0, 0]])\n    mask = np.zeros((2, 2))\n    with testing.raises(TypeError):\n        inpaint.inpaint_biharmonic(img, mask)",
            "def test_invalid_input():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (img, mask) = (np.zeros([]), np.zeros([]))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    (img, mask) = (np.zeros((2, 2)), np.zeros((4, 1)))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    img = np.ma.array(np.zeros((2, 2)), mask=[[0, 0], [0, 0]])\n    mask = np.zeros((2, 2))\n    with testing.raises(TypeError):\n        inpaint.inpaint_biharmonic(img, mask)",
            "def test_invalid_input():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (img, mask) = (np.zeros([]), np.zeros([]))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    (img, mask) = (np.zeros((2, 2)), np.zeros((4, 1)))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    img = np.ma.array(np.zeros((2, 2)), mask=[[0, 0], [0, 0]])\n    mask = np.zeros((2, 2))\n    with testing.raises(TypeError):\n        inpaint.inpaint_biharmonic(img, mask)",
            "def test_invalid_input():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (img, mask) = (np.zeros([]), np.zeros([]))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    (img, mask) = (np.zeros((2, 2)), np.zeros((4, 1)))\n    with testing.raises(ValueError):\n        inpaint.inpaint_biharmonic(img, mask)\n    img = np.ma.array(np.zeros((2, 2)), mask=[[0, 0], [0, 0]])\n    mask = np.zeros((2, 2))\n    with testing.raises(TypeError):\n        inpaint.inpaint_biharmonic(img, mask)"
        ]
    },
    {
        "func_name": "test_inpaint_nrmse",
        "original": "@testing.parametrize('dtype', [np.uint8, np.float32, np.float64])\n@testing.parametrize('order', ['C', 'F'])\n@testing.parametrize('channel_axis', [None, -1])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_nrmse(dtype, order, channel_axis, split_into_regions):\n    image_orig = data.astronaut()[:, :200]\n    float_dtype = np.float32 if dtype == np.float32 else np.float64\n    image_orig = image_orig.astype(float_dtype, copy=False)\n    mask = np.zeros(image_orig.shape[:-1], dtype=bool)\n    mask[20:50, 3:20] = 1\n    mask[165:180, 90:155] = 1\n    mask[40:60, 170:195] = 1\n    mask[-60:-40, 170:195] = 1\n    mask[-180:-165, 90:155] = 1\n    mask[-50:-20, :20] = 1\n    mask[200:205, -200:] = 1\n    mask[150:255, 20:22] = 1\n    mask[365:368, 60:130] = 1\n    rstate = np.random.default_rng(0)\n    for radius in [0, 2, 4]:\n        thresh = 3.25 + 0.25 * radius\n        tmp_mask = rstate.standard_normal(image_orig.shape[:-1]) > thresh\n        if radius > 0:\n            tmp_mask = binary_dilation(tmp_mask, disk(radius, dtype=bool))\n        mask[tmp_mask] = 1\n    image_defect = image_orig.copy()\n    for layer in range(image_defect.shape[-1]):\n        image_defect[np.where(mask)] = 0\n    if channel_axis is None:\n        image_orig = rgb2gray(image_orig)\n        image_defect = rgb2gray(image_defect)\n    image_orig = image_orig.astype(dtype, copy=False)\n    image_defect = image_defect.astype(dtype, copy=False)\n    image_defect = np.asarray(image_defect, order=order)\n    image_result = inpaint.inpaint_biharmonic(image_defect, mask, channel_axis=channel_axis, split_into_regions=split_into_regions)\n    assert image_result.dtype == float_dtype\n    nrmse_defect = normalized_root_mse(image_orig, image_defect)\n    nrmse_result = normalized_root_mse(img_as_float(image_orig), image_result)\n    assert nrmse_result < 0.2 * nrmse_defect",
        "mutated": [
            "@testing.parametrize('dtype', [np.uint8, np.float32, np.float64])\n@testing.parametrize('order', ['C', 'F'])\n@testing.parametrize('channel_axis', [None, -1])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_nrmse(dtype, order, channel_axis, split_into_regions):\n    if False:\n        i = 10\n    image_orig = data.astronaut()[:, :200]\n    float_dtype = np.float32 if dtype == np.float32 else np.float64\n    image_orig = image_orig.astype(float_dtype, copy=False)\n    mask = np.zeros(image_orig.shape[:-1], dtype=bool)\n    mask[20:50, 3:20] = 1\n    mask[165:180, 90:155] = 1\n    mask[40:60, 170:195] = 1\n    mask[-60:-40, 170:195] = 1\n    mask[-180:-165, 90:155] = 1\n    mask[-50:-20, :20] = 1\n    mask[200:205, -200:] = 1\n    mask[150:255, 20:22] = 1\n    mask[365:368, 60:130] = 1\n    rstate = np.random.default_rng(0)\n    for radius in [0, 2, 4]:\n        thresh = 3.25 + 0.25 * radius\n        tmp_mask = rstate.standard_normal(image_orig.shape[:-1]) > thresh\n        if radius > 0:\n            tmp_mask = binary_dilation(tmp_mask, disk(radius, dtype=bool))\n        mask[tmp_mask] = 1\n    image_defect = image_orig.copy()\n    for layer in range(image_defect.shape[-1]):\n        image_defect[np.where(mask)] = 0\n    if channel_axis is None:\n        image_orig = rgb2gray(image_orig)\n        image_defect = rgb2gray(image_defect)\n    image_orig = image_orig.astype(dtype, copy=False)\n    image_defect = image_defect.astype(dtype, copy=False)\n    image_defect = np.asarray(image_defect, order=order)\n    image_result = inpaint.inpaint_biharmonic(image_defect, mask, channel_axis=channel_axis, split_into_regions=split_into_regions)\n    assert image_result.dtype == float_dtype\n    nrmse_defect = normalized_root_mse(image_orig, image_defect)\n    nrmse_result = normalized_root_mse(img_as_float(image_orig), image_result)\n    assert nrmse_result < 0.2 * nrmse_defect",
            "@testing.parametrize('dtype', [np.uint8, np.float32, np.float64])\n@testing.parametrize('order', ['C', 'F'])\n@testing.parametrize('channel_axis', [None, -1])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_nrmse(dtype, order, channel_axis, split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    image_orig = data.astronaut()[:, :200]\n    float_dtype = np.float32 if dtype == np.float32 else np.float64\n    image_orig = image_orig.astype(float_dtype, copy=False)\n    mask = np.zeros(image_orig.shape[:-1], dtype=bool)\n    mask[20:50, 3:20] = 1\n    mask[165:180, 90:155] = 1\n    mask[40:60, 170:195] = 1\n    mask[-60:-40, 170:195] = 1\n    mask[-180:-165, 90:155] = 1\n    mask[-50:-20, :20] = 1\n    mask[200:205, -200:] = 1\n    mask[150:255, 20:22] = 1\n    mask[365:368, 60:130] = 1\n    rstate = np.random.default_rng(0)\n    for radius in [0, 2, 4]:\n        thresh = 3.25 + 0.25 * radius\n        tmp_mask = rstate.standard_normal(image_orig.shape[:-1]) > thresh\n        if radius > 0:\n            tmp_mask = binary_dilation(tmp_mask, disk(radius, dtype=bool))\n        mask[tmp_mask] = 1\n    image_defect = image_orig.copy()\n    for layer in range(image_defect.shape[-1]):\n        image_defect[np.where(mask)] = 0\n    if channel_axis is None:\n        image_orig = rgb2gray(image_orig)\n        image_defect = rgb2gray(image_defect)\n    image_orig = image_orig.astype(dtype, copy=False)\n    image_defect = image_defect.astype(dtype, copy=False)\n    image_defect = np.asarray(image_defect, order=order)\n    image_result = inpaint.inpaint_biharmonic(image_defect, mask, channel_axis=channel_axis, split_into_regions=split_into_regions)\n    assert image_result.dtype == float_dtype\n    nrmse_defect = normalized_root_mse(image_orig, image_defect)\n    nrmse_result = normalized_root_mse(img_as_float(image_orig), image_result)\n    assert nrmse_result < 0.2 * nrmse_defect",
            "@testing.parametrize('dtype', [np.uint8, np.float32, np.float64])\n@testing.parametrize('order', ['C', 'F'])\n@testing.parametrize('channel_axis', [None, -1])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_nrmse(dtype, order, channel_axis, split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    image_orig = data.astronaut()[:, :200]\n    float_dtype = np.float32 if dtype == np.float32 else np.float64\n    image_orig = image_orig.astype(float_dtype, copy=False)\n    mask = np.zeros(image_orig.shape[:-1], dtype=bool)\n    mask[20:50, 3:20] = 1\n    mask[165:180, 90:155] = 1\n    mask[40:60, 170:195] = 1\n    mask[-60:-40, 170:195] = 1\n    mask[-180:-165, 90:155] = 1\n    mask[-50:-20, :20] = 1\n    mask[200:205, -200:] = 1\n    mask[150:255, 20:22] = 1\n    mask[365:368, 60:130] = 1\n    rstate = np.random.default_rng(0)\n    for radius in [0, 2, 4]:\n        thresh = 3.25 + 0.25 * radius\n        tmp_mask = rstate.standard_normal(image_orig.shape[:-1]) > thresh\n        if radius > 0:\n            tmp_mask = binary_dilation(tmp_mask, disk(radius, dtype=bool))\n        mask[tmp_mask] = 1\n    image_defect = image_orig.copy()\n    for layer in range(image_defect.shape[-1]):\n        image_defect[np.where(mask)] = 0\n    if channel_axis is None:\n        image_orig = rgb2gray(image_orig)\n        image_defect = rgb2gray(image_defect)\n    image_orig = image_orig.astype(dtype, copy=False)\n    image_defect = image_defect.astype(dtype, copy=False)\n    image_defect = np.asarray(image_defect, order=order)\n    image_result = inpaint.inpaint_biharmonic(image_defect, mask, channel_axis=channel_axis, split_into_regions=split_into_regions)\n    assert image_result.dtype == float_dtype\n    nrmse_defect = normalized_root_mse(image_orig, image_defect)\n    nrmse_result = normalized_root_mse(img_as_float(image_orig), image_result)\n    assert nrmse_result < 0.2 * nrmse_defect",
            "@testing.parametrize('dtype', [np.uint8, np.float32, np.float64])\n@testing.parametrize('order', ['C', 'F'])\n@testing.parametrize('channel_axis', [None, -1])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_nrmse(dtype, order, channel_axis, split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    image_orig = data.astronaut()[:, :200]\n    float_dtype = np.float32 if dtype == np.float32 else np.float64\n    image_orig = image_orig.astype(float_dtype, copy=False)\n    mask = np.zeros(image_orig.shape[:-1], dtype=bool)\n    mask[20:50, 3:20] = 1\n    mask[165:180, 90:155] = 1\n    mask[40:60, 170:195] = 1\n    mask[-60:-40, 170:195] = 1\n    mask[-180:-165, 90:155] = 1\n    mask[-50:-20, :20] = 1\n    mask[200:205, -200:] = 1\n    mask[150:255, 20:22] = 1\n    mask[365:368, 60:130] = 1\n    rstate = np.random.default_rng(0)\n    for radius in [0, 2, 4]:\n        thresh = 3.25 + 0.25 * radius\n        tmp_mask = rstate.standard_normal(image_orig.shape[:-1]) > thresh\n        if radius > 0:\n            tmp_mask = binary_dilation(tmp_mask, disk(radius, dtype=bool))\n        mask[tmp_mask] = 1\n    image_defect = image_orig.copy()\n    for layer in range(image_defect.shape[-1]):\n        image_defect[np.where(mask)] = 0\n    if channel_axis is None:\n        image_orig = rgb2gray(image_orig)\n        image_defect = rgb2gray(image_defect)\n    image_orig = image_orig.astype(dtype, copy=False)\n    image_defect = image_defect.astype(dtype, copy=False)\n    image_defect = np.asarray(image_defect, order=order)\n    image_result = inpaint.inpaint_biharmonic(image_defect, mask, channel_axis=channel_axis, split_into_regions=split_into_regions)\n    assert image_result.dtype == float_dtype\n    nrmse_defect = normalized_root_mse(image_orig, image_defect)\n    nrmse_result = normalized_root_mse(img_as_float(image_orig), image_result)\n    assert nrmse_result < 0.2 * nrmse_defect",
            "@testing.parametrize('dtype', [np.uint8, np.float32, np.float64])\n@testing.parametrize('order', ['C', 'F'])\n@testing.parametrize('channel_axis', [None, -1])\n@testing.parametrize('split_into_regions', [False, True])\ndef test_inpaint_nrmse(dtype, order, channel_axis, split_into_regions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    image_orig = data.astronaut()[:, :200]\n    float_dtype = np.float32 if dtype == np.float32 else np.float64\n    image_orig = image_orig.astype(float_dtype, copy=False)\n    mask = np.zeros(image_orig.shape[:-1], dtype=bool)\n    mask[20:50, 3:20] = 1\n    mask[165:180, 90:155] = 1\n    mask[40:60, 170:195] = 1\n    mask[-60:-40, 170:195] = 1\n    mask[-180:-165, 90:155] = 1\n    mask[-50:-20, :20] = 1\n    mask[200:205, -200:] = 1\n    mask[150:255, 20:22] = 1\n    mask[365:368, 60:130] = 1\n    rstate = np.random.default_rng(0)\n    for radius in [0, 2, 4]:\n        thresh = 3.25 + 0.25 * radius\n        tmp_mask = rstate.standard_normal(image_orig.shape[:-1]) > thresh\n        if radius > 0:\n            tmp_mask = binary_dilation(tmp_mask, disk(radius, dtype=bool))\n        mask[tmp_mask] = 1\n    image_defect = image_orig.copy()\n    for layer in range(image_defect.shape[-1]):\n        image_defect[np.where(mask)] = 0\n    if channel_axis is None:\n        image_orig = rgb2gray(image_orig)\n        image_defect = rgb2gray(image_defect)\n    image_orig = image_orig.astype(dtype, copy=False)\n    image_defect = image_defect.astype(dtype, copy=False)\n    image_defect = np.asarray(image_defect, order=order)\n    image_result = inpaint.inpaint_biharmonic(image_defect, mask, channel_axis=channel_axis, split_into_regions=split_into_regions)\n    assert image_result.dtype == float_dtype\n    nrmse_defect = normalized_root_mse(image_orig, image_defect)\n    nrmse_result = normalized_root_mse(img_as_float(image_orig), image_result)\n    assert nrmse_result < 0.2 * nrmse_defect"
        ]
    }
]