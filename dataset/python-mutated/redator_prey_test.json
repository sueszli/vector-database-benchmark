[
    {
        "func_name": "test_load",
        "original": "def test_load(self):\n    game = pyspiel.load_game('python_mfg_predator_prey')\n    game.new_initial_state_for_population(0)\n    game.new_initial_state_for_population(1)",
        "mutated": [
            "def test_load(self):\n    if False:\n        i = 10\n    game = pyspiel.load_game('python_mfg_predator_prey')\n    game.new_initial_state_for_population(0)\n    game.new_initial_state_for_population(1)",
            "def test_load(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    game = pyspiel.load_game('python_mfg_predator_prey')\n    game.new_initial_state_for_population(0)\n    game.new_initial_state_for_population(1)",
            "def test_load(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    game = pyspiel.load_game('python_mfg_predator_prey')\n    game.new_initial_state_for_population(0)\n    game.new_initial_state_for_population(1)",
            "def test_load(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    game = pyspiel.load_game('python_mfg_predator_prey')\n    game.new_initial_state_for_population(0)\n    game.new_initial_state_for_population(1)",
            "def test_load(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    game = pyspiel.load_game('python_mfg_predator_prey')\n    game.new_initial_state_for_population(0)\n    game.new_initial_state_for_population(1)"
        ]
    },
    {
        "func_name": "test_dynamics",
        "original": "@parameterized.parameters({'geometry': predator_prey.Geometry.SQUARE, 'expected_pos': np.array([0, 4])}, {'geometry': predator_prey.Geometry.TORUS, 'expected_pos': np.array([0, 0])})\ndef test_dynamics(self, geometry, expected_pos):\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    init_distrib = np.array([[1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0]])\n    game = pyspiel.load_game('python_mfg_predator_prey', {'geometry': geometry, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten())), 'players': num_players, 'horizon': 10})\n    state = game.new_initial_state_for_population(2)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    self.assertLen(state.chance_outcomes(), 1)\n    self.assertEqual(state.chance_outcomes()[0][0], predator_prey.pos_to_merged(np.array([0, 4]), state.size))\n    state.apply_action(state.chance_outcomes()[0][0])\n    self.assertEqual(state.current_player(), 2)\n    npt.assert_array_equal(state.pos, [0, 4])\n    self.assertEqual(state._action_to_string(player=2, action=2), '[0 1]')\n    state.apply_action(2)\n    npt.assert_array_equal(state.pos, expected_pos)",
        "mutated": [
            "@parameterized.parameters({'geometry': predator_prey.Geometry.SQUARE, 'expected_pos': np.array([0, 4])}, {'geometry': predator_prey.Geometry.TORUS, 'expected_pos': np.array([0, 0])})\ndef test_dynamics(self, geometry, expected_pos):\n    if False:\n        i = 10\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    init_distrib = np.array([[1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0]])\n    game = pyspiel.load_game('python_mfg_predator_prey', {'geometry': geometry, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten())), 'players': num_players, 'horizon': 10})\n    state = game.new_initial_state_for_population(2)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    self.assertLen(state.chance_outcomes(), 1)\n    self.assertEqual(state.chance_outcomes()[0][0], predator_prey.pos_to_merged(np.array([0, 4]), state.size))\n    state.apply_action(state.chance_outcomes()[0][0])\n    self.assertEqual(state.current_player(), 2)\n    npt.assert_array_equal(state.pos, [0, 4])\n    self.assertEqual(state._action_to_string(player=2, action=2), '[0 1]')\n    state.apply_action(2)\n    npt.assert_array_equal(state.pos, expected_pos)",
            "@parameterized.parameters({'geometry': predator_prey.Geometry.SQUARE, 'expected_pos': np.array([0, 4])}, {'geometry': predator_prey.Geometry.TORUS, 'expected_pos': np.array([0, 0])})\ndef test_dynamics(self, geometry, expected_pos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    init_distrib = np.array([[1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0]])\n    game = pyspiel.load_game('python_mfg_predator_prey', {'geometry': geometry, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten())), 'players': num_players, 'horizon': 10})\n    state = game.new_initial_state_for_population(2)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    self.assertLen(state.chance_outcomes(), 1)\n    self.assertEqual(state.chance_outcomes()[0][0], predator_prey.pos_to_merged(np.array([0, 4]), state.size))\n    state.apply_action(state.chance_outcomes()[0][0])\n    self.assertEqual(state.current_player(), 2)\n    npt.assert_array_equal(state.pos, [0, 4])\n    self.assertEqual(state._action_to_string(player=2, action=2), '[0 1]')\n    state.apply_action(2)\n    npt.assert_array_equal(state.pos, expected_pos)",
            "@parameterized.parameters({'geometry': predator_prey.Geometry.SQUARE, 'expected_pos': np.array([0, 4])}, {'geometry': predator_prey.Geometry.TORUS, 'expected_pos': np.array([0, 0])})\ndef test_dynamics(self, geometry, expected_pos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    init_distrib = np.array([[1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0]])\n    game = pyspiel.load_game('python_mfg_predator_prey', {'geometry': geometry, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten())), 'players': num_players, 'horizon': 10})\n    state = game.new_initial_state_for_population(2)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    self.assertLen(state.chance_outcomes(), 1)\n    self.assertEqual(state.chance_outcomes()[0][0], predator_prey.pos_to_merged(np.array([0, 4]), state.size))\n    state.apply_action(state.chance_outcomes()[0][0])\n    self.assertEqual(state.current_player(), 2)\n    npt.assert_array_equal(state.pos, [0, 4])\n    self.assertEqual(state._action_to_string(player=2, action=2), '[0 1]')\n    state.apply_action(2)\n    npt.assert_array_equal(state.pos, expected_pos)",
            "@parameterized.parameters({'geometry': predator_prey.Geometry.SQUARE, 'expected_pos': np.array([0, 4])}, {'geometry': predator_prey.Geometry.TORUS, 'expected_pos': np.array([0, 0])})\ndef test_dynamics(self, geometry, expected_pos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    init_distrib = np.array([[1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0]])\n    game = pyspiel.load_game('python_mfg_predator_prey', {'geometry': geometry, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten())), 'players': num_players, 'horizon': 10})\n    state = game.new_initial_state_for_population(2)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    self.assertLen(state.chance_outcomes(), 1)\n    self.assertEqual(state.chance_outcomes()[0][0], predator_prey.pos_to_merged(np.array([0, 4]), state.size))\n    state.apply_action(state.chance_outcomes()[0][0])\n    self.assertEqual(state.current_player(), 2)\n    npt.assert_array_equal(state.pos, [0, 4])\n    self.assertEqual(state._action_to_string(player=2, action=2), '[0 1]')\n    state.apply_action(2)\n    npt.assert_array_equal(state.pos, expected_pos)",
            "@parameterized.parameters({'geometry': predator_prey.Geometry.SQUARE, 'expected_pos': np.array([0, 4])}, {'geometry': predator_prey.Geometry.TORUS, 'expected_pos': np.array([0, 0])})\ndef test_dynamics(self, geometry, expected_pos):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    init_distrib = np.array([[1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0, 0.0]])\n    game = pyspiel.load_game('python_mfg_predator_prey', {'geometry': geometry, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten())), 'players': num_players, 'horizon': 10})\n    state = game.new_initial_state_for_population(2)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    self.assertLen(state.chance_outcomes(), 1)\n    self.assertEqual(state.chance_outcomes()[0][0], predator_prey.pos_to_merged(np.array([0, 4]), state.size))\n    state.apply_action(state.chance_outcomes()[0][0])\n    self.assertEqual(state.current_player(), 2)\n    npt.assert_array_equal(state.pos, [0, 4])\n    self.assertEqual(state._action_to_string(player=2, action=2), '[0 1]')\n    state.apply_action(2)\n    npt.assert_array_equal(state.pos, expected_pos)"
        ]
    },
    {
        "func_name": "test_create_with_params",
        "original": "def test_create_with_params(self):\n    horizon = 100\n    size = 20\n    num_players = 3\n    zero_mat = np.zeros((size, size))\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    reward_matrix_flat = ' '.join((str(v) for v in reward_matrix.flatten()))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    init_distrib = np.array(pop_1 + pop_2 + pop_3)\n    init_distrib_flat = ' '.join((str(v) for v in init_distrib.flatten()))\n    setting = 'python_mfg_predator_prey(horizon={}'.format(horizon)\n    setting += ',size={}'.format(size)\n    setting += ',players={}'.format(num_players)\n    setting += ',reward_matrix={}'.format(reward_matrix_flat)\n    setting += ',init_distrib={}'.format(init_distrib_flat)\n    setting += ')'\n    game = pyspiel.load_game(setting)\n    self.assertEqual(game.size, 20)\n    self.assertEqual(game.horizon, 100)",
        "mutated": [
            "def test_create_with_params(self):\n    if False:\n        i = 10\n    horizon = 100\n    size = 20\n    num_players = 3\n    zero_mat = np.zeros((size, size))\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    reward_matrix_flat = ' '.join((str(v) for v in reward_matrix.flatten()))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    init_distrib = np.array(pop_1 + pop_2 + pop_3)\n    init_distrib_flat = ' '.join((str(v) for v in init_distrib.flatten()))\n    setting = 'python_mfg_predator_prey(horizon={}'.format(horizon)\n    setting += ',size={}'.format(size)\n    setting += ',players={}'.format(num_players)\n    setting += ',reward_matrix={}'.format(reward_matrix_flat)\n    setting += ',init_distrib={}'.format(init_distrib_flat)\n    setting += ')'\n    game = pyspiel.load_game(setting)\n    self.assertEqual(game.size, 20)\n    self.assertEqual(game.horizon, 100)",
            "def test_create_with_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    horizon = 100\n    size = 20\n    num_players = 3\n    zero_mat = np.zeros((size, size))\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    reward_matrix_flat = ' '.join((str(v) for v in reward_matrix.flatten()))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    init_distrib = np.array(pop_1 + pop_2 + pop_3)\n    init_distrib_flat = ' '.join((str(v) for v in init_distrib.flatten()))\n    setting = 'python_mfg_predator_prey(horizon={}'.format(horizon)\n    setting += ',size={}'.format(size)\n    setting += ',players={}'.format(num_players)\n    setting += ',reward_matrix={}'.format(reward_matrix_flat)\n    setting += ',init_distrib={}'.format(init_distrib_flat)\n    setting += ')'\n    game = pyspiel.load_game(setting)\n    self.assertEqual(game.size, 20)\n    self.assertEqual(game.horizon, 100)",
            "def test_create_with_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    horizon = 100\n    size = 20\n    num_players = 3\n    zero_mat = np.zeros((size, size))\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    reward_matrix_flat = ' '.join((str(v) for v in reward_matrix.flatten()))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    init_distrib = np.array(pop_1 + pop_2 + pop_3)\n    init_distrib_flat = ' '.join((str(v) for v in init_distrib.flatten()))\n    setting = 'python_mfg_predator_prey(horizon={}'.format(horizon)\n    setting += ',size={}'.format(size)\n    setting += ',players={}'.format(num_players)\n    setting += ',reward_matrix={}'.format(reward_matrix_flat)\n    setting += ',init_distrib={}'.format(init_distrib_flat)\n    setting += ')'\n    game = pyspiel.load_game(setting)\n    self.assertEqual(game.size, 20)\n    self.assertEqual(game.horizon, 100)",
            "def test_create_with_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    horizon = 100\n    size = 20\n    num_players = 3\n    zero_mat = np.zeros((size, size))\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    reward_matrix_flat = ' '.join((str(v) for v in reward_matrix.flatten()))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    init_distrib = np.array(pop_1 + pop_2 + pop_3)\n    init_distrib_flat = ' '.join((str(v) for v in init_distrib.flatten()))\n    setting = 'python_mfg_predator_prey(horizon={}'.format(horizon)\n    setting += ',size={}'.format(size)\n    setting += ',players={}'.format(num_players)\n    setting += ',reward_matrix={}'.format(reward_matrix_flat)\n    setting += ',init_distrib={}'.format(init_distrib_flat)\n    setting += ')'\n    game = pyspiel.load_game(setting)\n    self.assertEqual(game.size, 20)\n    self.assertEqual(game.horizon, 100)",
            "def test_create_with_params(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    horizon = 100\n    size = 20\n    num_players = 3\n    zero_mat = np.zeros((size, size))\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    reward_matrix_flat = ' '.join((str(v) for v in reward_matrix.flatten()))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    init_distrib = np.array(pop_1 + pop_2 + pop_3)\n    init_distrib_flat = ' '.join((str(v) for v in init_distrib.flatten()))\n    setting = 'python_mfg_predator_prey(horizon={}'.format(horizon)\n    setting += ',size={}'.format(size)\n    setting += ',players={}'.format(num_players)\n    setting += ',reward_matrix={}'.format(reward_matrix_flat)\n    setting += ',init_distrib={}'.format(init_distrib_flat)\n    setting += ')'\n    game = pyspiel.load_game(setting)\n    self.assertEqual(game.size, 20)\n    self.assertEqual(game.horizon, 100)"
        ]
    },
    {
        "func_name": "test_random_game",
        "original": "@parameterized.parameters({'population': 0}, {'population': 1}, {'population': 2})\ndef test_random_game(self, population):\n    \"\"\"Tests basic API functions.\"\"\"\n    horizon = 10\n    size = 20\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    zero_mat = np.zeros((size, size))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    pop_4 = zero_mat.copy()\n    pop_4[-1, -1] = 1.0\n    pop_4 = pop_4.tolist()\n    pops = [pop_1, pop_2, pop_3, pop_4]\n    init_distrib = []\n    for p in range(3):\n        init_distrib += pops[p]\n    init_distrib = np.array(init_distrib)\n    game = predator_prey.MFGPredatorPreyGame(params={'horizon': horizon, 'size': size, 'players': num_players, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    pyspiel.random_sim_test(game, num_sims=10, serialize=False, verbose=True, mean_field_population=population)",
        "mutated": [
            "@parameterized.parameters({'population': 0}, {'population': 1}, {'population': 2})\ndef test_random_game(self, population):\n    if False:\n        i = 10\n    'Tests basic API functions.'\n    horizon = 10\n    size = 20\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    zero_mat = np.zeros((size, size))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    pop_4 = zero_mat.copy()\n    pop_4[-1, -1] = 1.0\n    pop_4 = pop_4.tolist()\n    pops = [pop_1, pop_2, pop_3, pop_4]\n    init_distrib = []\n    for p in range(3):\n        init_distrib += pops[p]\n    init_distrib = np.array(init_distrib)\n    game = predator_prey.MFGPredatorPreyGame(params={'horizon': horizon, 'size': size, 'players': num_players, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    pyspiel.random_sim_test(game, num_sims=10, serialize=False, verbose=True, mean_field_population=population)",
            "@parameterized.parameters({'population': 0}, {'population': 1}, {'population': 2})\ndef test_random_game(self, population):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Tests basic API functions.'\n    horizon = 10\n    size = 20\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    zero_mat = np.zeros((size, size))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    pop_4 = zero_mat.copy()\n    pop_4[-1, -1] = 1.0\n    pop_4 = pop_4.tolist()\n    pops = [pop_1, pop_2, pop_3, pop_4]\n    init_distrib = []\n    for p in range(3):\n        init_distrib += pops[p]\n    init_distrib = np.array(init_distrib)\n    game = predator_prey.MFGPredatorPreyGame(params={'horizon': horizon, 'size': size, 'players': num_players, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    pyspiel.random_sim_test(game, num_sims=10, serialize=False, verbose=True, mean_field_population=population)",
            "@parameterized.parameters({'population': 0}, {'population': 1}, {'population': 2})\ndef test_random_game(self, population):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Tests basic API functions.'\n    horizon = 10\n    size = 20\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    zero_mat = np.zeros((size, size))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    pop_4 = zero_mat.copy()\n    pop_4[-1, -1] = 1.0\n    pop_4 = pop_4.tolist()\n    pops = [pop_1, pop_2, pop_3, pop_4]\n    init_distrib = []\n    for p in range(3):\n        init_distrib += pops[p]\n    init_distrib = np.array(init_distrib)\n    game = predator_prey.MFGPredatorPreyGame(params={'horizon': horizon, 'size': size, 'players': num_players, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    pyspiel.random_sim_test(game, num_sims=10, serialize=False, verbose=True, mean_field_population=population)",
            "@parameterized.parameters({'population': 0}, {'population': 1}, {'population': 2})\ndef test_random_game(self, population):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Tests basic API functions.'\n    horizon = 10\n    size = 20\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    zero_mat = np.zeros((size, size))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    pop_4 = zero_mat.copy()\n    pop_4[-1, -1] = 1.0\n    pop_4 = pop_4.tolist()\n    pops = [pop_1, pop_2, pop_3, pop_4]\n    init_distrib = []\n    for p in range(3):\n        init_distrib += pops[p]\n    init_distrib = np.array(init_distrib)\n    game = predator_prey.MFGPredatorPreyGame(params={'horizon': horizon, 'size': size, 'players': num_players, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    pyspiel.random_sim_test(game, num_sims=10, serialize=False, verbose=True, mean_field_population=population)",
            "@parameterized.parameters({'population': 0}, {'population': 1}, {'population': 2})\ndef test_random_game(self, population):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Tests basic API functions.'\n    horizon = 10\n    size = 20\n    num_players = 3\n    reward_matrix = np.array([[0, -1, 1], [1, 0, -1], [-1, 1, 0]])\n    zero_mat = np.zeros((size, size))\n    pop_1 = zero_mat.copy()\n    pop_1[0, 0] = 1.0\n    pop_1 = pop_1.tolist()\n    pop_2 = zero_mat.copy()\n    pop_2[0, -1] = 1.0\n    pop_2 = pop_2.tolist()\n    pop_3 = zero_mat.copy()\n    pop_3[-1, 0] = 1.0\n    pop_3 = pop_3.tolist()\n    pop_4 = zero_mat.copy()\n    pop_4[-1, -1] = 1.0\n    pop_4 = pop_4.tolist()\n    pops = [pop_1, pop_2, pop_3, pop_4]\n    init_distrib = []\n    for p in range(3):\n        init_distrib += pops[p]\n    init_distrib = np.array(init_distrib)\n    game = predator_prey.MFGPredatorPreyGame(params={'horizon': horizon, 'size': size, 'players': num_players, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    pyspiel.random_sim_test(game, num_sims=10, serialize=False, verbose=True, mean_field_population=population)"
        ]
    },
    {
        "func_name": "test_rewards",
        "original": "@parameterized.parameters({'reward_matrix': np.array([[0, 1], [-1, 0]]), 'population': 0, 'players': 2, 'initial_pos': np.array([0, 0]), 'distributions': [np.array([[1, 0], [0, 0]]), np.array([[0.5, 0.1], [0, 0.9]])], 'expected_rewards': np.array([-math.log(1 + 1e-25) + 0.5, -math.log(0.5 + 1e-25) - 1]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0]])}, {'reward_matrix': np.array([[0, -1, 0.5], [0.5, 0, -1], [-0.5, 1, 0]]), 'population': 2, 'players': 3, 'initial_pos': np.array([1, 1]), 'distributions': [np.array([[0.1, 0.2], [0.3, 0.4]]), np.array([[0.2, 0.1], [0.1, 0.6]]), np.array([[0, 0.1], [0.1, 0.8]])], 'expected_rewards': np.array([-math.log(0.4 + 1e-25) - 0.6 + 0.5 * 0.8, -math.log(0.6 + 1e-25) + 0.5 * 0.4 - 0.8, -math.log(0.8 + 1e-25) - 0.5 * 0.4 + 0.6]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0], [0.0, 0.0], [1.0, 0.0]])})\ndef test_rewards(self, reward_matrix, players, population, initial_pos, distributions, expected_rewards, init_distrib):\n    game = pyspiel.load_game('python_mfg_predator_prey', {'size': 2, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'players': players, 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    state = game.new_initial_state_for_population(population)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(predator_prey.pos_to_merged(initial_pos, state.size))\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.pos, initial_pos)\n    state.apply_action(state._NEUTRAL_ACTION)\n    npt.assert_array_equal(state.pos, initial_pos)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(state._NEUTRAL_ACTION)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.MEAN_FIELD)\n    dist = {}\n    for x in range(state.size):\n        for y in range(state.size):\n            for pop in range(len(reward_matrix)):\n                state_str = state.state_to_str(np.array([x, y]), state.t, pop, player_id=pyspiel.PlayerId.MEAN_FIELD)\n                dist[state_str] = distributions[pop][y][x]\n    support = state.distribution_support()\n    state.update_distribution([dist[s] for s in support])\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.rewards(), expected_rewards)",
        "mutated": [
            "@parameterized.parameters({'reward_matrix': np.array([[0, 1], [-1, 0]]), 'population': 0, 'players': 2, 'initial_pos': np.array([0, 0]), 'distributions': [np.array([[1, 0], [0, 0]]), np.array([[0.5, 0.1], [0, 0.9]])], 'expected_rewards': np.array([-math.log(1 + 1e-25) + 0.5, -math.log(0.5 + 1e-25) - 1]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0]])}, {'reward_matrix': np.array([[0, -1, 0.5], [0.5, 0, -1], [-0.5, 1, 0]]), 'population': 2, 'players': 3, 'initial_pos': np.array([1, 1]), 'distributions': [np.array([[0.1, 0.2], [0.3, 0.4]]), np.array([[0.2, 0.1], [0.1, 0.6]]), np.array([[0, 0.1], [0.1, 0.8]])], 'expected_rewards': np.array([-math.log(0.4 + 1e-25) - 0.6 + 0.5 * 0.8, -math.log(0.6 + 1e-25) + 0.5 * 0.4 - 0.8, -math.log(0.8 + 1e-25) - 0.5 * 0.4 + 0.6]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0], [0.0, 0.0], [1.0, 0.0]])})\ndef test_rewards(self, reward_matrix, players, population, initial_pos, distributions, expected_rewards, init_distrib):\n    if False:\n        i = 10\n    game = pyspiel.load_game('python_mfg_predator_prey', {'size': 2, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'players': players, 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    state = game.new_initial_state_for_population(population)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(predator_prey.pos_to_merged(initial_pos, state.size))\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.pos, initial_pos)\n    state.apply_action(state._NEUTRAL_ACTION)\n    npt.assert_array_equal(state.pos, initial_pos)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(state._NEUTRAL_ACTION)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.MEAN_FIELD)\n    dist = {}\n    for x in range(state.size):\n        for y in range(state.size):\n            for pop in range(len(reward_matrix)):\n                state_str = state.state_to_str(np.array([x, y]), state.t, pop, player_id=pyspiel.PlayerId.MEAN_FIELD)\n                dist[state_str] = distributions[pop][y][x]\n    support = state.distribution_support()\n    state.update_distribution([dist[s] for s in support])\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.rewards(), expected_rewards)",
            "@parameterized.parameters({'reward_matrix': np.array([[0, 1], [-1, 0]]), 'population': 0, 'players': 2, 'initial_pos': np.array([0, 0]), 'distributions': [np.array([[1, 0], [0, 0]]), np.array([[0.5, 0.1], [0, 0.9]])], 'expected_rewards': np.array([-math.log(1 + 1e-25) + 0.5, -math.log(0.5 + 1e-25) - 1]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0]])}, {'reward_matrix': np.array([[0, -1, 0.5], [0.5, 0, -1], [-0.5, 1, 0]]), 'population': 2, 'players': 3, 'initial_pos': np.array([1, 1]), 'distributions': [np.array([[0.1, 0.2], [0.3, 0.4]]), np.array([[0.2, 0.1], [0.1, 0.6]]), np.array([[0, 0.1], [0.1, 0.8]])], 'expected_rewards': np.array([-math.log(0.4 + 1e-25) - 0.6 + 0.5 * 0.8, -math.log(0.6 + 1e-25) + 0.5 * 0.4 - 0.8, -math.log(0.8 + 1e-25) - 0.5 * 0.4 + 0.6]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0], [0.0, 0.0], [1.0, 0.0]])})\ndef test_rewards(self, reward_matrix, players, population, initial_pos, distributions, expected_rewards, init_distrib):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    game = pyspiel.load_game('python_mfg_predator_prey', {'size': 2, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'players': players, 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    state = game.new_initial_state_for_population(population)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(predator_prey.pos_to_merged(initial_pos, state.size))\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.pos, initial_pos)\n    state.apply_action(state._NEUTRAL_ACTION)\n    npt.assert_array_equal(state.pos, initial_pos)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(state._NEUTRAL_ACTION)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.MEAN_FIELD)\n    dist = {}\n    for x in range(state.size):\n        for y in range(state.size):\n            for pop in range(len(reward_matrix)):\n                state_str = state.state_to_str(np.array([x, y]), state.t, pop, player_id=pyspiel.PlayerId.MEAN_FIELD)\n                dist[state_str] = distributions[pop][y][x]\n    support = state.distribution_support()\n    state.update_distribution([dist[s] for s in support])\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.rewards(), expected_rewards)",
            "@parameterized.parameters({'reward_matrix': np.array([[0, 1], [-1, 0]]), 'population': 0, 'players': 2, 'initial_pos': np.array([0, 0]), 'distributions': [np.array([[1, 0], [0, 0]]), np.array([[0.5, 0.1], [0, 0.9]])], 'expected_rewards': np.array([-math.log(1 + 1e-25) + 0.5, -math.log(0.5 + 1e-25) - 1]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0]])}, {'reward_matrix': np.array([[0, -1, 0.5], [0.5, 0, -1], [-0.5, 1, 0]]), 'population': 2, 'players': 3, 'initial_pos': np.array([1, 1]), 'distributions': [np.array([[0.1, 0.2], [0.3, 0.4]]), np.array([[0.2, 0.1], [0.1, 0.6]]), np.array([[0, 0.1], [0.1, 0.8]])], 'expected_rewards': np.array([-math.log(0.4 + 1e-25) - 0.6 + 0.5 * 0.8, -math.log(0.6 + 1e-25) + 0.5 * 0.4 - 0.8, -math.log(0.8 + 1e-25) - 0.5 * 0.4 + 0.6]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0], [0.0, 0.0], [1.0, 0.0]])})\ndef test_rewards(self, reward_matrix, players, population, initial_pos, distributions, expected_rewards, init_distrib):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    game = pyspiel.load_game('python_mfg_predator_prey', {'size': 2, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'players': players, 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    state = game.new_initial_state_for_population(population)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(predator_prey.pos_to_merged(initial_pos, state.size))\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.pos, initial_pos)\n    state.apply_action(state._NEUTRAL_ACTION)\n    npt.assert_array_equal(state.pos, initial_pos)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(state._NEUTRAL_ACTION)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.MEAN_FIELD)\n    dist = {}\n    for x in range(state.size):\n        for y in range(state.size):\n            for pop in range(len(reward_matrix)):\n                state_str = state.state_to_str(np.array([x, y]), state.t, pop, player_id=pyspiel.PlayerId.MEAN_FIELD)\n                dist[state_str] = distributions[pop][y][x]\n    support = state.distribution_support()\n    state.update_distribution([dist[s] for s in support])\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.rewards(), expected_rewards)",
            "@parameterized.parameters({'reward_matrix': np.array([[0, 1], [-1, 0]]), 'population': 0, 'players': 2, 'initial_pos': np.array([0, 0]), 'distributions': [np.array([[1, 0], [0, 0]]), np.array([[0.5, 0.1], [0, 0.9]])], 'expected_rewards': np.array([-math.log(1 + 1e-25) + 0.5, -math.log(0.5 + 1e-25) - 1]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0]])}, {'reward_matrix': np.array([[0, -1, 0.5], [0.5, 0, -1], [-0.5, 1, 0]]), 'population': 2, 'players': 3, 'initial_pos': np.array([1, 1]), 'distributions': [np.array([[0.1, 0.2], [0.3, 0.4]]), np.array([[0.2, 0.1], [0.1, 0.6]]), np.array([[0, 0.1], [0.1, 0.8]])], 'expected_rewards': np.array([-math.log(0.4 + 1e-25) - 0.6 + 0.5 * 0.8, -math.log(0.6 + 1e-25) + 0.5 * 0.4 - 0.8, -math.log(0.8 + 1e-25) - 0.5 * 0.4 + 0.6]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0], [0.0, 0.0], [1.0, 0.0]])})\ndef test_rewards(self, reward_matrix, players, population, initial_pos, distributions, expected_rewards, init_distrib):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    game = pyspiel.load_game('python_mfg_predator_prey', {'size': 2, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'players': players, 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    state = game.new_initial_state_for_population(population)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(predator_prey.pos_to_merged(initial_pos, state.size))\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.pos, initial_pos)\n    state.apply_action(state._NEUTRAL_ACTION)\n    npt.assert_array_equal(state.pos, initial_pos)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(state._NEUTRAL_ACTION)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.MEAN_FIELD)\n    dist = {}\n    for x in range(state.size):\n        for y in range(state.size):\n            for pop in range(len(reward_matrix)):\n                state_str = state.state_to_str(np.array([x, y]), state.t, pop, player_id=pyspiel.PlayerId.MEAN_FIELD)\n                dist[state_str] = distributions[pop][y][x]\n    support = state.distribution_support()\n    state.update_distribution([dist[s] for s in support])\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.rewards(), expected_rewards)",
            "@parameterized.parameters({'reward_matrix': np.array([[0, 1], [-1, 0]]), 'population': 0, 'players': 2, 'initial_pos': np.array([0, 0]), 'distributions': [np.array([[1, 0], [0, 0]]), np.array([[0.5, 0.1], [0, 0.9]])], 'expected_rewards': np.array([-math.log(1 + 1e-25) + 0.5, -math.log(0.5 + 1e-25) - 1]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0]])}, {'reward_matrix': np.array([[0, -1, 0.5], [0.5, 0, -1], [-0.5, 1, 0]]), 'population': 2, 'players': 3, 'initial_pos': np.array([1, 1]), 'distributions': [np.array([[0.1, 0.2], [0.3, 0.4]]), np.array([[0.2, 0.1], [0.1, 0.6]]), np.array([[0, 0.1], [0.1, 0.8]])], 'expected_rewards': np.array([-math.log(0.4 + 1e-25) - 0.6 + 0.5 * 0.8, -math.log(0.6 + 1e-25) + 0.5 * 0.4 - 0.8, -math.log(0.8 + 1e-25) - 0.5 * 0.4 + 0.6]), 'init_distrib': np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0], [0.0, 0.0], [0.0, 0.0], [1.0, 0.0]])})\ndef test_rewards(self, reward_matrix, players, population, initial_pos, distributions, expected_rewards, init_distrib):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    game = pyspiel.load_game('python_mfg_predator_prey', {'size': 2, 'reward_matrix': ' '.join((str(v) for v in reward_matrix.flatten())), 'players': players, 'init_distrib': ' '.join((str(v) for v in init_distrib.flatten()))})\n    state = game.new_initial_state_for_population(population)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(predator_prey.pos_to_merged(initial_pos, state.size))\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.pos, initial_pos)\n    state.apply_action(state._NEUTRAL_ACTION)\n    npt.assert_array_equal(state.pos, initial_pos)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.CHANCE)\n    state.apply_action(state._NEUTRAL_ACTION)\n    self.assertEqual(state.current_player(), pyspiel.PlayerId.MEAN_FIELD)\n    dist = {}\n    for x in range(state.size):\n        for y in range(state.size):\n            for pop in range(len(reward_matrix)):\n                state_str = state.state_to_str(np.array([x, y]), state.t, pop, player_id=pyspiel.PlayerId.MEAN_FIELD)\n                dist[state_str] = distributions[pop][y][x]\n    support = state.distribution_support()\n    state.update_distribution([dist[s] for s in support])\n    self.assertEqual(state.current_player(), population)\n    npt.assert_array_equal(state.rewards(), expected_rewards)"
        ]
    }
]