[
    {
        "func_name": "DynExPcdTokenNumberMapping",
        "original": "def DynExPcdTokenNumberMapping(Info, AutoGenH):\n    ExTokenCNameList = []\n    PcdExList = []\n    PcdList = Info.ModulePcdList\n    for Pcd in PcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n            ExTokenCNameList.append(Pcd.TokenCName)\n            PcdExList.append(Pcd)\n    if len(ExTokenCNameList) == 0:\n        return\n    AutoGenH.Append('\\n#define COMPAREGUID(Guid1, Guid2) (BOOLEAN)(*(CONST UINT64*)Guid1 == *(CONST UINT64*)Guid2 && *((CONST UINT64*)Guid1 + 1) == *((CONST UINT64*)Guid2 + 1))\\n')\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_ADDR_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                TokenCNameList.add(TokenCName)\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_VAL_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == NULL) ? 0:')\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                    AutoGenH.Append('#define _PCD_TOKEN_EX_%s(GuidPtr)   __PCD_%s_ADDR_CMP(GuidPtr) ? __PCD_%s_ADDR_CMP(GuidPtr) : __PCD_%s_VAL_CMP(GuidPtr)  \\n' % (RealTokenCName, RealTokenCName, RealTokenCName, RealTokenCName))\n                TokenCNameList.add(TokenCName)",
        "mutated": [
            "def DynExPcdTokenNumberMapping(Info, AutoGenH):\n    if False:\n        i = 10\n    ExTokenCNameList = []\n    PcdExList = []\n    PcdList = Info.ModulePcdList\n    for Pcd in PcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n            ExTokenCNameList.append(Pcd.TokenCName)\n            PcdExList.append(Pcd)\n    if len(ExTokenCNameList) == 0:\n        return\n    AutoGenH.Append('\\n#define COMPAREGUID(Guid1, Guid2) (BOOLEAN)(*(CONST UINT64*)Guid1 == *(CONST UINT64*)Guid2 && *((CONST UINT64*)Guid1 + 1) == *((CONST UINT64*)Guid2 + 1))\\n')\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_ADDR_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                TokenCNameList.add(TokenCName)\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_VAL_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == NULL) ? 0:')\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                    AutoGenH.Append('#define _PCD_TOKEN_EX_%s(GuidPtr)   __PCD_%s_ADDR_CMP(GuidPtr) ? __PCD_%s_ADDR_CMP(GuidPtr) : __PCD_%s_VAL_CMP(GuidPtr)  \\n' % (RealTokenCName, RealTokenCName, RealTokenCName, RealTokenCName))\n                TokenCNameList.add(TokenCName)",
            "def DynExPcdTokenNumberMapping(Info, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ExTokenCNameList = []\n    PcdExList = []\n    PcdList = Info.ModulePcdList\n    for Pcd in PcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n            ExTokenCNameList.append(Pcd.TokenCName)\n            PcdExList.append(Pcd)\n    if len(ExTokenCNameList) == 0:\n        return\n    AutoGenH.Append('\\n#define COMPAREGUID(Guid1, Guid2) (BOOLEAN)(*(CONST UINT64*)Guid1 == *(CONST UINT64*)Guid2 && *((CONST UINT64*)Guid1 + 1) == *((CONST UINT64*)Guid2 + 1))\\n')\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_ADDR_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                TokenCNameList.add(TokenCName)\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_VAL_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == NULL) ? 0:')\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                    AutoGenH.Append('#define _PCD_TOKEN_EX_%s(GuidPtr)   __PCD_%s_ADDR_CMP(GuidPtr) ? __PCD_%s_ADDR_CMP(GuidPtr) : __PCD_%s_VAL_CMP(GuidPtr)  \\n' % (RealTokenCName, RealTokenCName, RealTokenCName, RealTokenCName))\n                TokenCNameList.add(TokenCName)",
            "def DynExPcdTokenNumberMapping(Info, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ExTokenCNameList = []\n    PcdExList = []\n    PcdList = Info.ModulePcdList\n    for Pcd in PcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n            ExTokenCNameList.append(Pcd.TokenCName)\n            PcdExList.append(Pcd)\n    if len(ExTokenCNameList) == 0:\n        return\n    AutoGenH.Append('\\n#define COMPAREGUID(Guid1, Guid2) (BOOLEAN)(*(CONST UINT64*)Guid1 == *(CONST UINT64*)Guid2 && *((CONST UINT64*)Guid1 + 1) == *((CONST UINT64*)Guid2 + 1))\\n')\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_ADDR_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                TokenCNameList.add(TokenCName)\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_VAL_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == NULL) ? 0:')\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                    AutoGenH.Append('#define _PCD_TOKEN_EX_%s(GuidPtr)   __PCD_%s_ADDR_CMP(GuidPtr) ? __PCD_%s_ADDR_CMP(GuidPtr) : __PCD_%s_VAL_CMP(GuidPtr)  \\n' % (RealTokenCName, RealTokenCName, RealTokenCName, RealTokenCName))\n                TokenCNameList.add(TokenCName)",
            "def DynExPcdTokenNumberMapping(Info, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ExTokenCNameList = []\n    PcdExList = []\n    PcdList = Info.ModulePcdList\n    for Pcd in PcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n            ExTokenCNameList.append(Pcd.TokenCName)\n            PcdExList.append(Pcd)\n    if len(ExTokenCNameList) == 0:\n        return\n    AutoGenH.Append('\\n#define COMPAREGUID(Guid1, Guid2) (BOOLEAN)(*(CONST UINT64*)Guid1 == *(CONST UINT64*)Guid2 && *((CONST UINT64*)Guid1 + 1) == *((CONST UINT64*)Guid2 + 1))\\n')\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_ADDR_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                TokenCNameList.add(TokenCName)\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_VAL_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == NULL) ? 0:')\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                    AutoGenH.Append('#define _PCD_TOKEN_EX_%s(GuidPtr)   __PCD_%s_ADDR_CMP(GuidPtr) ? __PCD_%s_ADDR_CMP(GuidPtr) : __PCD_%s_VAL_CMP(GuidPtr)  \\n' % (RealTokenCName, RealTokenCName, RealTokenCName, RealTokenCName))\n                TokenCNameList.add(TokenCName)",
            "def DynExPcdTokenNumberMapping(Info, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ExTokenCNameList = []\n    PcdExList = []\n    PcdList = Info.ModulePcdList\n    for Pcd in PcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n            ExTokenCNameList.append(Pcd.TokenCName)\n            PcdExList.append(Pcd)\n    if len(ExTokenCNameList) == 0:\n        return\n    AutoGenH.Append('\\n#define COMPAREGUID(Guid1, Guid2) (BOOLEAN)(*(CONST UINT64*)Guid1 == *(CONST UINT64*)Guid2 && *((CONST UINT64*)Guid1 + 1) == *((CONST UINT64*)Guid2 + 1))\\n')\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_ADDR_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                TokenCNameList.add(TokenCName)\n    TokenCNameList = set()\n    for TokenCName in ExTokenCNameList:\n        if TokenCName in TokenCNameList:\n            continue\n        Index = 0\n        Count = ExTokenCNameList.count(TokenCName)\n        for Pcd in PcdExList:\n            RealTokenCName = Pcd.TokenCName\n            for PcdItem in GlobalData.MixedPcd:\n                if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                    RealTokenCName = PcdItem[0]\n                    break\n            if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == TokenCName:\n                Index = Index + 1\n                if Index == 1:\n                    AutoGenH.Append('\\n#define __PCD_%s_VAL_CMP(GuidPtr)  (' % RealTokenCName)\n                    AutoGenH.Append('\\\\\\n  (GuidPtr == NULL) ? 0:')\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                else:\n                    AutoGenH.Append('\\\\\\n  COMPAREGUID (GuidPtr, &%s) ? _PCD_TOKEN_%s_%s:' % (Pcd.TokenSpaceGuidCName, Pcd.TokenSpaceGuidCName, RealTokenCName))\n                if Index == Count:\n                    AutoGenH.Append('0 \\\\\\n  )\\n')\n                    AutoGenH.Append('#define _PCD_TOKEN_EX_%s(GuidPtr)   __PCD_%s_ADDR_CMP(GuidPtr) ? __PCD_%s_ADDR_CMP(GuidPtr) : __PCD_%s_VAL_CMP(GuidPtr)  \\n' % (RealTokenCName, RealTokenCName, RealTokenCName, RealTokenCName))\n                TokenCNameList.add(TokenCName)"
        ]
    },
    {
        "func_name": "CreateModulePcdCode",
        "original": "def CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    TokenSpaceGuidValue = Pcd.TokenSpaceGuidValue\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n        PcdExTokenName = '_PCD_TOKEN_' + Pcd.TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n    else:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n            if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n                TokenNumber = 0\n            else:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n        else:\n            TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdTokenName, TokenNumber))\n    EdkLogger.debug(EdkLogger.DEBUG_3, 'Creating code for ' + TokenCName + '.' + Pcd.TokenSpaceGuidCName)\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList + Info.LibraryPcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    elif Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n        PcdCNameTest = 0\n        for PcdModule in Info.LibraryPcdList + Info.ModulePcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdCNameTest += 1\n            if PcdCNameTest > 1:\n                break\n        if PcdCNameTest > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName. They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    else:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        Const = 'const'\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            Const = ''\n        Type = ''\n        Array = ''\n        Value = Pcd.DefaultValue\n        Unicode = False\n        ValueNumber = 0\n        if Pcd.DatumType == 'BOOLEAN':\n            BoolValue = Value.upper()\n            if BoolValue == 'TRUE' or BoolValue == '1':\n                Value = '1U'\n            elif BoolValue == 'FALSE' or BoolValue == '0':\n                Value = '0U'\n        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n            try:\n                if Value.upper().endswith('L'):\n                    Value = Value[:-1]\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                ValueNumber = int(Value, 0)\n            except:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'PCD value is not valid dec or hex number for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if ValueNumber < 0:\n                EdkLogger.error('build', AUTOGEN_ERROR, \"PCD can't be set to negative value for datum type [%s] of PCD %s.%s\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            elif ValueNumber > MAX_VAL_TYPE[Pcd.DatumType]:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Too large PCD value for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if Pcd.DatumType == TAB_UINT64 and (not Value.endswith('ULL')):\n                Value += 'ULL'\n            elif Pcd.DatumType != TAB_UINT64 and (not Value.endswith('U')):\n                Value += 'U'\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if not Pcd.MaxDatumSize:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown [MaxDatumSize] of PCD [%s.%s]' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            ArraySize = int(Pcd.MaxDatumSize, 0)\n            if Value[0] == '{':\n                Type = '(VOID *)'\n                ValueSize = len(Value.split(','))\n            else:\n                if Value[0] == 'L':\n                    Unicode = True\n                Value = Value.lstrip('L')\n                Value = eval(Value)\n                ValueSize = len(Value) + 1\n                NewValue = '{'\n                for Index in range(0, len(Value)):\n                    if Unicode:\n                        NewValue = NewValue + str(ord(Value[Index]) % 65536) + ', '\n                    else:\n                        NewValue = NewValue + str(ord(Value[Index]) % 256) + ', '\n                if Unicode:\n                    ArraySize = ArraySize // 2\n                Value = NewValue + '0 }'\n            if ArraySize < ValueSize:\n                if Pcd.MaxSizeUserSet:\n                    EdkLogger.error('build', AUTOGEN_ERROR, \"The maximum size of VOID* type PCD '%s.%s' is less than its actual size occupied.\" % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n                else:\n                    ArraySize = Pcd.GetPcdSize()\n                    if Unicode:\n                        ArraySize = ArraySize // 2\n            Array = '[%d]' % ArraySize\n        elif Pcd.Type != TAB_PCDS_FIXED_AT_BUILD and Pcd.DatumType in TAB_PCD_NUMERIC_TYPES_VOID:\n            Value = '((%s)%s)' % (Pcd.DatumType, Value)\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            PcdValueName = '_PCD_PATCHABLE_VALUE_' + TokenCName\n        else:\n            PcdValueName = '_PCD_VALUE_' + TokenCName\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s  %s%s\\n' % (PcdValueName, Type, PcdVariableName))\n            if Unicode:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT16 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT16 %s%s;\\n' % (Const, PcdVariableName, Array))\n            else:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT8 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT8 %s%s;\\n' % (Const, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            if Pcd.Type == TAB_PCDS_FIXED_AT_BUILD:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (FixedPcdSizeVariableName, PcdDataSize))\n            if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n                AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, Pcd.MaxDatumSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n                AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (PatchPcdMaxSizeVariable, Pcd.MaxDatumSize))\n        elif Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('volatile %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern volatile %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n            AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n        else:\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n            else:\n                AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n                AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS) \\n' % (SetModeStatusName, PcdVariableName))\n        else:\n            AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)",
        "mutated": [
            "def CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n    TokenSpaceGuidValue = Pcd.TokenSpaceGuidValue\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n        PcdExTokenName = '_PCD_TOKEN_' + Pcd.TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n    else:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n            if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n                TokenNumber = 0\n            else:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n        else:\n            TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdTokenName, TokenNumber))\n    EdkLogger.debug(EdkLogger.DEBUG_3, 'Creating code for ' + TokenCName + '.' + Pcd.TokenSpaceGuidCName)\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList + Info.LibraryPcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    elif Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n        PcdCNameTest = 0\n        for PcdModule in Info.LibraryPcdList + Info.ModulePcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdCNameTest += 1\n            if PcdCNameTest > 1:\n                break\n        if PcdCNameTest > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName. They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    else:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        Const = 'const'\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            Const = ''\n        Type = ''\n        Array = ''\n        Value = Pcd.DefaultValue\n        Unicode = False\n        ValueNumber = 0\n        if Pcd.DatumType == 'BOOLEAN':\n            BoolValue = Value.upper()\n            if BoolValue == 'TRUE' or BoolValue == '1':\n                Value = '1U'\n            elif BoolValue == 'FALSE' or BoolValue == '0':\n                Value = '0U'\n        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n            try:\n                if Value.upper().endswith('L'):\n                    Value = Value[:-1]\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                ValueNumber = int(Value, 0)\n            except:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'PCD value is not valid dec or hex number for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if ValueNumber < 0:\n                EdkLogger.error('build', AUTOGEN_ERROR, \"PCD can't be set to negative value for datum type [%s] of PCD %s.%s\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            elif ValueNumber > MAX_VAL_TYPE[Pcd.DatumType]:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Too large PCD value for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if Pcd.DatumType == TAB_UINT64 and (not Value.endswith('ULL')):\n                Value += 'ULL'\n            elif Pcd.DatumType != TAB_UINT64 and (not Value.endswith('U')):\n                Value += 'U'\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if not Pcd.MaxDatumSize:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown [MaxDatumSize] of PCD [%s.%s]' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            ArraySize = int(Pcd.MaxDatumSize, 0)\n            if Value[0] == '{':\n                Type = '(VOID *)'\n                ValueSize = len(Value.split(','))\n            else:\n                if Value[0] == 'L':\n                    Unicode = True\n                Value = Value.lstrip('L')\n                Value = eval(Value)\n                ValueSize = len(Value) + 1\n                NewValue = '{'\n                for Index in range(0, len(Value)):\n                    if Unicode:\n                        NewValue = NewValue + str(ord(Value[Index]) % 65536) + ', '\n                    else:\n                        NewValue = NewValue + str(ord(Value[Index]) % 256) + ', '\n                if Unicode:\n                    ArraySize = ArraySize // 2\n                Value = NewValue + '0 }'\n            if ArraySize < ValueSize:\n                if Pcd.MaxSizeUserSet:\n                    EdkLogger.error('build', AUTOGEN_ERROR, \"The maximum size of VOID* type PCD '%s.%s' is less than its actual size occupied.\" % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n                else:\n                    ArraySize = Pcd.GetPcdSize()\n                    if Unicode:\n                        ArraySize = ArraySize // 2\n            Array = '[%d]' % ArraySize\n        elif Pcd.Type != TAB_PCDS_FIXED_AT_BUILD and Pcd.DatumType in TAB_PCD_NUMERIC_TYPES_VOID:\n            Value = '((%s)%s)' % (Pcd.DatumType, Value)\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            PcdValueName = '_PCD_PATCHABLE_VALUE_' + TokenCName\n        else:\n            PcdValueName = '_PCD_VALUE_' + TokenCName\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s  %s%s\\n' % (PcdValueName, Type, PcdVariableName))\n            if Unicode:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT16 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT16 %s%s;\\n' % (Const, PcdVariableName, Array))\n            else:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT8 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT8 %s%s;\\n' % (Const, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            if Pcd.Type == TAB_PCDS_FIXED_AT_BUILD:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (FixedPcdSizeVariableName, PcdDataSize))\n            if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n                AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, Pcd.MaxDatumSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n                AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (PatchPcdMaxSizeVariable, Pcd.MaxDatumSize))\n        elif Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('volatile %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern volatile %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n            AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n        else:\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n            else:\n                AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n                AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS) \\n' % (SetModeStatusName, PcdVariableName))\n        else:\n            AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)",
            "def CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    TokenSpaceGuidValue = Pcd.TokenSpaceGuidValue\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n        PcdExTokenName = '_PCD_TOKEN_' + Pcd.TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n    else:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n            if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n                TokenNumber = 0\n            else:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n        else:\n            TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdTokenName, TokenNumber))\n    EdkLogger.debug(EdkLogger.DEBUG_3, 'Creating code for ' + TokenCName + '.' + Pcd.TokenSpaceGuidCName)\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList + Info.LibraryPcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    elif Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n        PcdCNameTest = 0\n        for PcdModule in Info.LibraryPcdList + Info.ModulePcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdCNameTest += 1\n            if PcdCNameTest > 1:\n                break\n        if PcdCNameTest > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName. They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    else:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        Const = 'const'\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            Const = ''\n        Type = ''\n        Array = ''\n        Value = Pcd.DefaultValue\n        Unicode = False\n        ValueNumber = 0\n        if Pcd.DatumType == 'BOOLEAN':\n            BoolValue = Value.upper()\n            if BoolValue == 'TRUE' or BoolValue == '1':\n                Value = '1U'\n            elif BoolValue == 'FALSE' or BoolValue == '0':\n                Value = '0U'\n        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n            try:\n                if Value.upper().endswith('L'):\n                    Value = Value[:-1]\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                ValueNumber = int(Value, 0)\n            except:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'PCD value is not valid dec or hex number for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if ValueNumber < 0:\n                EdkLogger.error('build', AUTOGEN_ERROR, \"PCD can't be set to negative value for datum type [%s] of PCD %s.%s\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            elif ValueNumber > MAX_VAL_TYPE[Pcd.DatumType]:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Too large PCD value for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if Pcd.DatumType == TAB_UINT64 and (not Value.endswith('ULL')):\n                Value += 'ULL'\n            elif Pcd.DatumType != TAB_UINT64 and (not Value.endswith('U')):\n                Value += 'U'\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if not Pcd.MaxDatumSize:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown [MaxDatumSize] of PCD [%s.%s]' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            ArraySize = int(Pcd.MaxDatumSize, 0)\n            if Value[0] == '{':\n                Type = '(VOID *)'\n                ValueSize = len(Value.split(','))\n            else:\n                if Value[0] == 'L':\n                    Unicode = True\n                Value = Value.lstrip('L')\n                Value = eval(Value)\n                ValueSize = len(Value) + 1\n                NewValue = '{'\n                for Index in range(0, len(Value)):\n                    if Unicode:\n                        NewValue = NewValue + str(ord(Value[Index]) % 65536) + ', '\n                    else:\n                        NewValue = NewValue + str(ord(Value[Index]) % 256) + ', '\n                if Unicode:\n                    ArraySize = ArraySize // 2\n                Value = NewValue + '0 }'\n            if ArraySize < ValueSize:\n                if Pcd.MaxSizeUserSet:\n                    EdkLogger.error('build', AUTOGEN_ERROR, \"The maximum size of VOID* type PCD '%s.%s' is less than its actual size occupied.\" % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n                else:\n                    ArraySize = Pcd.GetPcdSize()\n                    if Unicode:\n                        ArraySize = ArraySize // 2\n            Array = '[%d]' % ArraySize\n        elif Pcd.Type != TAB_PCDS_FIXED_AT_BUILD and Pcd.DatumType in TAB_PCD_NUMERIC_TYPES_VOID:\n            Value = '((%s)%s)' % (Pcd.DatumType, Value)\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            PcdValueName = '_PCD_PATCHABLE_VALUE_' + TokenCName\n        else:\n            PcdValueName = '_PCD_VALUE_' + TokenCName\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s  %s%s\\n' % (PcdValueName, Type, PcdVariableName))\n            if Unicode:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT16 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT16 %s%s;\\n' % (Const, PcdVariableName, Array))\n            else:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT8 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT8 %s%s;\\n' % (Const, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            if Pcd.Type == TAB_PCDS_FIXED_AT_BUILD:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (FixedPcdSizeVariableName, PcdDataSize))\n            if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n                AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, Pcd.MaxDatumSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n                AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (PatchPcdMaxSizeVariable, Pcd.MaxDatumSize))\n        elif Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('volatile %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern volatile %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n            AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n        else:\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n            else:\n                AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n                AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS) \\n' % (SetModeStatusName, PcdVariableName))\n        else:\n            AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)",
            "def CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    TokenSpaceGuidValue = Pcd.TokenSpaceGuidValue\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n        PcdExTokenName = '_PCD_TOKEN_' + Pcd.TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n    else:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n            if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n                TokenNumber = 0\n            else:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n        else:\n            TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdTokenName, TokenNumber))\n    EdkLogger.debug(EdkLogger.DEBUG_3, 'Creating code for ' + TokenCName + '.' + Pcd.TokenSpaceGuidCName)\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList + Info.LibraryPcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    elif Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n        PcdCNameTest = 0\n        for PcdModule in Info.LibraryPcdList + Info.ModulePcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdCNameTest += 1\n            if PcdCNameTest > 1:\n                break\n        if PcdCNameTest > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName. They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    else:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        Const = 'const'\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            Const = ''\n        Type = ''\n        Array = ''\n        Value = Pcd.DefaultValue\n        Unicode = False\n        ValueNumber = 0\n        if Pcd.DatumType == 'BOOLEAN':\n            BoolValue = Value.upper()\n            if BoolValue == 'TRUE' or BoolValue == '1':\n                Value = '1U'\n            elif BoolValue == 'FALSE' or BoolValue == '0':\n                Value = '0U'\n        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n            try:\n                if Value.upper().endswith('L'):\n                    Value = Value[:-1]\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                ValueNumber = int(Value, 0)\n            except:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'PCD value is not valid dec or hex number for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if ValueNumber < 0:\n                EdkLogger.error('build', AUTOGEN_ERROR, \"PCD can't be set to negative value for datum type [%s] of PCD %s.%s\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            elif ValueNumber > MAX_VAL_TYPE[Pcd.DatumType]:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Too large PCD value for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if Pcd.DatumType == TAB_UINT64 and (not Value.endswith('ULL')):\n                Value += 'ULL'\n            elif Pcd.DatumType != TAB_UINT64 and (not Value.endswith('U')):\n                Value += 'U'\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if not Pcd.MaxDatumSize:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown [MaxDatumSize] of PCD [%s.%s]' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            ArraySize = int(Pcd.MaxDatumSize, 0)\n            if Value[0] == '{':\n                Type = '(VOID *)'\n                ValueSize = len(Value.split(','))\n            else:\n                if Value[0] == 'L':\n                    Unicode = True\n                Value = Value.lstrip('L')\n                Value = eval(Value)\n                ValueSize = len(Value) + 1\n                NewValue = '{'\n                for Index in range(0, len(Value)):\n                    if Unicode:\n                        NewValue = NewValue + str(ord(Value[Index]) % 65536) + ', '\n                    else:\n                        NewValue = NewValue + str(ord(Value[Index]) % 256) + ', '\n                if Unicode:\n                    ArraySize = ArraySize // 2\n                Value = NewValue + '0 }'\n            if ArraySize < ValueSize:\n                if Pcd.MaxSizeUserSet:\n                    EdkLogger.error('build', AUTOGEN_ERROR, \"The maximum size of VOID* type PCD '%s.%s' is less than its actual size occupied.\" % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n                else:\n                    ArraySize = Pcd.GetPcdSize()\n                    if Unicode:\n                        ArraySize = ArraySize // 2\n            Array = '[%d]' % ArraySize\n        elif Pcd.Type != TAB_PCDS_FIXED_AT_BUILD and Pcd.DatumType in TAB_PCD_NUMERIC_TYPES_VOID:\n            Value = '((%s)%s)' % (Pcd.DatumType, Value)\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            PcdValueName = '_PCD_PATCHABLE_VALUE_' + TokenCName\n        else:\n            PcdValueName = '_PCD_VALUE_' + TokenCName\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s  %s%s\\n' % (PcdValueName, Type, PcdVariableName))\n            if Unicode:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT16 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT16 %s%s;\\n' % (Const, PcdVariableName, Array))\n            else:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT8 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT8 %s%s;\\n' % (Const, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            if Pcd.Type == TAB_PCDS_FIXED_AT_BUILD:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (FixedPcdSizeVariableName, PcdDataSize))\n            if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n                AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, Pcd.MaxDatumSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n                AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (PatchPcdMaxSizeVariable, Pcd.MaxDatumSize))\n        elif Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('volatile %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern volatile %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n            AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n        else:\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n            else:\n                AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n                AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS) \\n' % (SetModeStatusName, PcdVariableName))\n        else:\n            AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)",
            "def CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    TokenSpaceGuidValue = Pcd.TokenSpaceGuidValue\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n        PcdExTokenName = '_PCD_TOKEN_' + Pcd.TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n    else:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n            if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n                TokenNumber = 0\n            else:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n        else:\n            TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdTokenName, TokenNumber))\n    EdkLogger.debug(EdkLogger.DEBUG_3, 'Creating code for ' + TokenCName + '.' + Pcd.TokenSpaceGuidCName)\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList + Info.LibraryPcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    elif Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n        PcdCNameTest = 0\n        for PcdModule in Info.LibraryPcdList + Info.ModulePcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdCNameTest += 1\n            if PcdCNameTest > 1:\n                break\n        if PcdCNameTest > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName. They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    else:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        Const = 'const'\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            Const = ''\n        Type = ''\n        Array = ''\n        Value = Pcd.DefaultValue\n        Unicode = False\n        ValueNumber = 0\n        if Pcd.DatumType == 'BOOLEAN':\n            BoolValue = Value.upper()\n            if BoolValue == 'TRUE' or BoolValue == '1':\n                Value = '1U'\n            elif BoolValue == 'FALSE' or BoolValue == '0':\n                Value = '0U'\n        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n            try:\n                if Value.upper().endswith('L'):\n                    Value = Value[:-1]\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                ValueNumber = int(Value, 0)\n            except:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'PCD value is not valid dec or hex number for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if ValueNumber < 0:\n                EdkLogger.error('build', AUTOGEN_ERROR, \"PCD can't be set to negative value for datum type [%s] of PCD %s.%s\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            elif ValueNumber > MAX_VAL_TYPE[Pcd.DatumType]:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Too large PCD value for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if Pcd.DatumType == TAB_UINT64 and (not Value.endswith('ULL')):\n                Value += 'ULL'\n            elif Pcd.DatumType != TAB_UINT64 and (not Value.endswith('U')):\n                Value += 'U'\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if not Pcd.MaxDatumSize:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown [MaxDatumSize] of PCD [%s.%s]' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            ArraySize = int(Pcd.MaxDatumSize, 0)\n            if Value[0] == '{':\n                Type = '(VOID *)'\n                ValueSize = len(Value.split(','))\n            else:\n                if Value[0] == 'L':\n                    Unicode = True\n                Value = Value.lstrip('L')\n                Value = eval(Value)\n                ValueSize = len(Value) + 1\n                NewValue = '{'\n                for Index in range(0, len(Value)):\n                    if Unicode:\n                        NewValue = NewValue + str(ord(Value[Index]) % 65536) + ', '\n                    else:\n                        NewValue = NewValue + str(ord(Value[Index]) % 256) + ', '\n                if Unicode:\n                    ArraySize = ArraySize // 2\n                Value = NewValue + '0 }'\n            if ArraySize < ValueSize:\n                if Pcd.MaxSizeUserSet:\n                    EdkLogger.error('build', AUTOGEN_ERROR, \"The maximum size of VOID* type PCD '%s.%s' is less than its actual size occupied.\" % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n                else:\n                    ArraySize = Pcd.GetPcdSize()\n                    if Unicode:\n                        ArraySize = ArraySize // 2\n            Array = '[%d]' % ArraySize\n        elif Pcd.Type != TAB_PCDS_FIXED_AT_BUILD and Pcd.DatumType in TAB_PCD_NUMERIC_TYPES_VOID:\n            Value = '((%s)%s)' % (Pcd.DatumType, Value)\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            PcdValueName = '_PCD_PATCHABLE_VALUE_' + TokenCName\n        else:\n            PcdValueName = '_PCD_VALUE_' + TokenCName\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s  %s%s\\n' % (PcdValueName, Type, PcdVariableName))\n            if Unicode:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT16 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT16 %s%s;\\n' % (Const, PcdVariableName, Array))\n            else:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT8 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT8 %s%s;\\n' % (Const, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            if Pcd.Type == TAB_PCDS_FIXED_AT_BUILD:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (FixedPcdSizeVariableName, PcdDataSize))\n            if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n                AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, Pcd.MaxDatumSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n                AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (PatchPcdMaxSizeVariable, Pcd.MaxDatumSize))\n        elif Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('volatile %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern volatile %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n            AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n        else:\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n            else:\n                AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n                AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS) \\n' % (SetModeStatusName, PcdVariableName))\n        else:\n            AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)",
            "def CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    TokenSpaceGuidValue = Pcd.TokenSpaceGuidValue\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n        PcdExTokenName = '_PCD_TOKEN_' + Pcd.TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n    else:\n        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n            if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n                TokenNumber = 0\n            else:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n        else:\n            TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdTokenName, TokenNumber))\n    EdkLogger.debug(EdkLogger.DEBUG_3, 'Creating code for ' + TokenCName + '.' + Pcd.TokenSpaceGuidCName)\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList + Info.LibraryPcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    elif Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n        PcdCNameTest = 0\n        for PcdModule in Info.LibraryPcdList + Info.ModulePcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdCNameTest += 1\n            if PcdCNameTest > 1:\n                break\n        if PcdCNameTest > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName. They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    else:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        Const = 'const'\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            Const = ''\n        Type = ''\n        Array = ''\n        Value = Pcd.DefaultValue\n        Unicode = False\n        ValueNumber = 0\n        if Pcd.DatumType == 'BOOLEAN':\n            BoolValue = Value.upper()\n            if BoolValue == 'TRUE' or BoolValue == '1':\n                Value = '1U'\n            elif BoolValue == 'FALSE' or BoolValue == '0':\n                Value = '0U'\n        if Pcd.DatumType in TAB_PCD_CLEAN_NUMERIC_TYPES:\n            try:\n                if Value.upper().endswith('L'):\n                    Value = Value[:-1]\n                if Value.startswith('0') and (not Value.lower().startswith('0x')) and (len(Value) > 1) and Value.lstrip('0'):\n                    Value = Value.lstrip('0')\n                ValueNumber = int(Value, 0)\n            except:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'PCD value is not valid dec or hex number for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if ValueNumber < 0:\n                EdkLogger.error('build', AUTOGEN_ERROR, \"PCD can't be set to negative value for datum type [%s] of PCD %s.%s\" % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            elif ValueNumber > MAX_VAL_TYPE[Pcd.DatumType]:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Too large PCD value for datum type [%s] of PCD %s.%s' % (Pcd.DatumType, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            if Pcd.DatumType == TAB_UINT64 and (not Value.endswith('ULL')):\n                Value += 'ULL'\n            elif Pcd.DatumType != TAB_UINT64 and (not Value.endswith('U')):\n                Value += 'U'\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if not Pcd.MaxDatumSize:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown [MaxDatumSize] of PCD [%s.%s]' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n            ArraySize = int(Pcd.MaxDatumSize, 0)\n            if Value[0] == '{':\n                Type = '(VOID *)'\n                ValueSize = len(Value.split(','))\n            else:\n                if Value[0] == 'L':\n                    Unicode = True\n                Value = Value.lstrip('L')\n                Value = eval(Value)\n                ValueSize = len(Value) + 1\n                NewValue = '{'\n                for Index in range(0, len(Value)):\n                    if Unicode:\n                        NewValue = NewValue + str(ord(Value[Index]) % 65536) + ', '\n                    else:\n                        NewValue = NewValue + str(ord(Value[Index]) % 256) + ', '\n                if Unicode:\n                    ArraySize = ArraySize // 2\n                Value = NewValue + '0 }'\n            if ArraySize < ValueSize:\n                if Pcd.MaxSizeUserSet:\n                    EdkLogger.error('build', AUTOGEN_ERROR, \"The maximum size of VOID* type PCD '%s.%s' is less than its actual size occupied.\" % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n                else:\n                    ArraySize = Pcd.GetPcdSize()\n                    if Unicode:\n                        ArraySize = ArraySize // 2\n            Array = '[%d]' % ArraySize\n        elif Pcd.Type != TAB_PCDS_FIXED_AT_BUILD and Pcd.DatumType in TAB_PCD_NUMERIC_TYPES_VOID:\n            Value = '((%s)%s)' % (Pcd.DatumType, Value)\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            PcdValueName = '_PCD_PATCHABLE_VALUE_' + TokenCName\n        else:\n            PcdValueName = '_PCD_VALUE_' + TokenCName\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s  %s%s\\n' % (PcdValueName, Type, PcdVariableName))\n            if Unicode:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT16 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT16 %s%s;\\n' % (Const, PcdVariableName, Array))\n            else:\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s UINT8 %s%s = %s;\\n' % (Const, PcdVariableName, Array, Value))\n                AutoGenH.Append('extern %s UINT8 %s%s;\\n' % (Const, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            if Pcd.Type == TAB_PCDS_FIXED_AT_BUILD:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (FixedPcdSizeVariableName, PcdDataSize))\n            if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n                AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, Pcd.MaxDatumSize))\n                AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n                AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n                AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED const UINTN %s = %s;\\n' % (PatchPcdMaxSizeVariable, Pcd.MaxDatumSize))\n        elif Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('volatile %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern volatile %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n            AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINTN %s = %s;\\n' % (PatchPcdSizeVariableName, PcdDataSize))\n        else:\n            PcdDataSize = Pcd.GetPcdSize()\n            AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n            AutoGenH.Append('#define %s  %s \\n' % (GetModeSizeName, FixPcdSizeTokenName))\n            AutoGenH.Append('#define %s  %s\\n' % (PcdValueName, Value))\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s %s = %s;\\n' % (Const, Pcd.DatumType, PcdVariableName, PcdValueName))\n            AutoGenH.Append('extern %s  %s  %s%s;\\n' % (Const, Pcd.DatumType, PcdVariableName, Array))\n            AutoGenH.Append('#define %s  %s%s\\n' % (GetModeName, Type, PcdVariableName))\n        if Pcd.Type == TAB_PCDS_PATCHABLE_IN_MODULE:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &_gPcd_BinaryPatch_Size_%s, (UINTN)_PCD_PATCHABLE_%s_SIZE, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, Pcd.TokenCName, Pcd.TokenCName, Pcd.TokenCName))\n            else:\n                AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n                AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS) \\n' % (SetModeStatusName, PcdVariableName))\n        else:\n            AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)"
        ]
    },
    {
        "func_name": "CreateLibraryPcdCode",
        "original": "def CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenSpaceGuidCName = Pcd.TokenSpaceGuidCName\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (TokenCName, TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n    elif (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n            TokenNumber = 0\n        else:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    else:\n        TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumType = Pcd.DatumType\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    Type = ''\n    Array = ''\n    if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n        if Pcd.DefaultValue[0] == '{':\n            Type = '(VOID *)'\n        Array = '[]'\n    PcdItemType = Pcd.Type\n    if PcdItemType in PCD_DYNAMIC_EX_TYPE_SET:\n        PcdExTokenName = '_PCD_TOKEN_' + TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    else:\n        AutoGenH.Append('#define _PCD_TOKEN_%s  %dU\\n' % (TokenCName, TokenNumber))\n    if PcdItemType in PCD_DYNAMIC_TYPE_SET:\n        PcdList = []\n        PcdCNameList = []\n        PcdList.extend(Info.LibraryPcdList)\n        PcdList.extend(Info.ModulePcdList)\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET:\n                PcdCNameList.append(PcdModule.TokenCName)\n        if PcdCNameList.count(Pcd.TokenCName) > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName.They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    if PcdItemType == TAB_PCDS_PATCHABLE_IN_MODULE:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[TAB_PCDS_PATCHABLE_IN_MODULE] + '_' + TokenCName\n        if DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if DatumType == TAB_VOID and Array == '[]':\n                DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n            else:\n                DatumType = TAB_UINT8\n            AutoGenH.Append('extern %s _gPcd_BinaryPatch_%s%s;\\n' % (DatumType, TokenCName, Array))\n        else:\n            AutoGenH.Append('extern volatile  %s  %s%s;\\n' % (DatumType, PcdVariableName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_BinaryPatch_%s\\n' % (GetModeName, Type, TokenCName))\n        PcdDataSize = Pcd.GetPcdSize()\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('extern const UINTN %s; \\n' % PatchPcdMaxSizeVariable)\n        else:\n            AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n            AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS)\\n' % (SetModeStatusName, PcdVariableName))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n        AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n        AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n    if PcdItemType == TAB_PCDS_FIXED_AT_BUILD or PcdItemType == TAB_PCDS_FEATURE_FLAG:\n        key = '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        if DatumType == TAB_VOID and Array == '[]':\n            DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n        if DatumType not in TAB_PCD_NUMERIC_TYPES_VOID:\n            DatumType = TAB_UINT8\n        AutoGenH.Append('extern const %s _gPcd_FixedAtBuild_%s%s;\\n' % (DatumType, TokenCName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_FixedAtBuild_%s\\n' % (GetModeName, Type, TokenCName))\n        AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)\n        ConstFixedPcd = False\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD and (key in Info.ConstPcd or (Info.IsLibrary and (not Info.ReferenceModules))):\n            ConstFixedPcd = True\n            if key in Info.ConstPcd:\n                Pcd.DefaultValue = Info.ConstPcd[key]\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s%s\\n' % (TokenCName, Type, PcdVariableName))\n            else:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s\\n' % (TokenCName, Pcd.DefaultValue))\n        PcdDataSize = Pcd.GetPcdSize()\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                if ConstFixedPcd:\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                else:\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('extern const UINTN %s; \\n' % FixedPcdSizeVariableName)\n            else:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))",
        "mutated": [
            "def CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenSpaceGuidCName = Pcd.TokenSpaceGuidCName\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (TokenCName, TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n    elif (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n            TokenNumber = 0\n        else:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    else:\n        TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumType = Pcd.DatumType\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    Type = ''\n    Array = ''\n    if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n        if Pcd.DefaultValue[0] == '{':\n            Type = '(VOID *)'\n        Array = '[]'\n    PcdItemType = Pcd.Type\n    if PcdItemType in PCD_DYNAMIC_EX_TYPE_SET:\n        PcdExTokenName = '_PCD_TOKEN_' + TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    else:\n        AutoGenH.Append('#define _PCD_TOKEN_%s  %dU\\n' % (TokenCName, TokenNumber))\n    if PcdItemType in PCD_DYNAMIC_TYPE_SET:\n        PcdList = []\n        PcdCNameList = []\n        PcdList.extend(Info.LibraryPcdList)\n        PcdList.extend(Info.ModulePcdList)\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET:\n                PcdCNameList.append(PcdModule.TokenCName)\n        if PcdCNameList.count(Pcd.TokenCName) > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName.They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    if PcdItemType == TAB_PCDS_PATCHABLE_IN_MODULE:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[TAB_PCDS_PATCHABLE_IN_MODULE] + '_' + TokenCName\n        if DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if DatumType == TAB_VOID and Array == '[]':\n                DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n            else:\n                DatumType = TAB_UINT8\n            AutoGenH.Append('extern %s _gPcd_BinaryPatch_%s%s;\\n' % (DatumType, TokenCName, Array))\n        else:\n            AutoGenH.Append('extern volatile  %s  %s%s;\\n' % (DatumType, PcdVariableName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_BinaryPatch_%s\\n' % (GetModeName, Type, TokenCName))\n        PcdDataSize = Pcd.GetPcdSize()\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('extern const UINTN %s; \\n' % PatchPcdMaxSizeVariable)\n        else:\n            AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n            AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS)\\n' % (SetModeStatusName, PcdVariableName))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n        AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n        AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n    if PcdItemType == TAB_PCDS_FIXED_AT_BUILD or PcdItemType == TAB_PCDS_FEATURE_FLAG:\n        key = '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        if DatumType == TAB_VOID and Array == '[]':\n            DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n        if DatumType not in TAB_PCD_NUMERIC_TYPES_VOID:\n            DatumType = TAB_UINT8\n        AutoGenH.Append('extern const %s _gPcd_FixedAtBuild_%s%s;\\n' % (DatumType, TokenCName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_FixedAtBuild_%s\\n' % (GetModeName, Type, TokenCName))\n        AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)\n        ConstFixedPcd = False\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD and (key in Info.ConstPcd or (Info.IsLibrary and (not Info.ReferenceModules))):\n            ConstFixedPcd = True\n            if key in Info.ConstPcd:\n                Pcd.DefaultValue = Info.ConstPcd[key]\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s%s\\n' % (TokenCName, Type, PcdVariableName))\n            else:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s\\n' % (TokenCName, Pcd.DefaultValue))\n        PcdDataSize = Pcd.GetPcdSize()\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                if ConstFixedPcd:\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                else:\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('extern const UINTN %s; \\n' % FixedPcdSizeVariableName)\n            else:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))",
            "def CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenSpaceGuidCName = Pcd.TokenSpaceGuidCName\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (TokenCName, TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n    elif (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n            TokenNumber = 0\n        else:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    else:\n        TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumType = Pcd.DatumType\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    Type = ''\n    Array = ''\n    if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n        if Pcd.DefaultValue[0] == '{':\n            Type = '(VOID *)'\n        Array = '[]'\n    PcdItemType = Pcd.Type\n    if PcdItemType in PCD_DYNAMIC_EX_TYPE_SET:\n        PcdExTokenName = '_PCD_TOKEN_' + TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    else:\n        AutoGenH.Append('#define _PCD_TOKEN_%s  %dU\\n' % (TokenCName, TokenNumber))\n    if PcdItemType in PCD_DYNAMIC_TYPE_SET:\n        PcdList = []\n        PcdCNameList = []\n        PcdList.extend(Info.LibraryPcdList)\n        PcdList.extend(Info.ModulePcdList)\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET:\n                PcdCNameList.append(PcdModule.TokenCName)\n        if PcdCNameList.count(Pcd.TokenCName) > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName.They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    if PcdItemType == TAB_PCDS_PATCHABLE_IN_MODULE:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[TAB_PCDS_PATCHABLE_IN_MODULE] + '_' + TokenCName\n        if DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if DatumType == TAB_VOID and Array == '[]':\n                DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n            else:\n                DatumType = TAB_UINT8\n            AutoGenH.Append('extern %s _gPcd_BinaryPatch_%s%s;\\n' % (DatumType, TokenCName, Array))\n        else:\n            AutoGenH.Append('extern volatile  %s  %s%s;\\n' % (DatumType, PcdVariableName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_BinaryPatch_%s\\n' % (GetModeName, Type, TokenCName))\n        PcdDataSize = Pcd.GetPcdSize()\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('extern const UINTN %s; \\n' % PatchPcdMaxSizeVariable)\n        else:\n            AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n            AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS)\\n' % (SetModeStatusName, PcdVariableName))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n        AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n        AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n    if PcdItemType == TAB_PCDS_FIXED_AT_BUILD or PcdItemType == TAB_PCDS_FEATURE_FLAG:\n        key = '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        if DatumType == TAB_VOID and Array == '[]':\n            DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n        if DatumType not in TAB_PCD_NUMERIC_TYPES_VOID:\n            DatumType = TAB_UINT8\n        AutoGenH.Append('extern const %s _gPcd_FixedAtBuild_%s%s;\\n' % (DatumType, TokenCName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_FixedAtBuild_%s\\n' % (GetModeName, Type, TokenCName))\n        AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)\n        ConstFixedPcd = False\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD and (key in Info.ConstPcd or (Info.IsLibrary and (not Info.ReferenceModules))):\n            ConstFixedPcd = True\n            if key in Info.ConstPcd:\n                Pcd.DefaultValue = Info.ConstPcd[key]\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s%s\\n' % (TokenCName, Type, PcdVariableName))\n            else:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s\\n' % (TokenCName, Pcd.DefaultValue))\n        PcdDataSize = Pcd.GetPcdSize()\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                if ConstFixedPcd:\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                else:\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('extern const UINTN %s; \\n' % FixedPcdSizeVariableName)\n            else:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))",
            "def CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenSpaceGuidCName = Pcd.TokenSpaceGuidCName\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (TokenCName, TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n    elif (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n            TokenNumber = 0\n        else:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    else:\n        TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumType = Pcd.DatumType\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    Type = ''\n    Array = ''\n    if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n        if Pcd.DefaultValue[0] == '{':\n            Type = '(VOID *)'\n        Array = '[]'\n    PcdItemType = Pcd.Type\n    if PcdItemType in PCD_DYNAMIC_EX_TYPE_SET:\n        PcdExTokenName = '_PCD_TOKEN_' + TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    else:\n        AutoGenH.Append('#define _PCD_TOKEN_%s  %dU\\n' % (TokenCName, TokenNumber))\n    if PcdItemType in PCD_DYNAMIC_TYPE_SET:\n        PcdList = []\n        PcdCNameList = []\n        PcdList.extend(Info.LibraryPcdList)\n        PcdList.extend(Info.ModulePcdList)\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET:\n                PcdCNameList.append(PcdModule.TokenCName)\n        if PcdCNameList.count(Pcd.TokenCName) > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName.They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    if PcdItemType == TAB_PCDS_PATCHABLE_IN_MODULE:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[TAB_PCDS_PATCHABLE_IN_MODULE] + '_' + TokenCName\n        if DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if DatumType == TAB_VOID and Array == '[]':\n                DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n            else:\n                DatumType = TAB_UINT8\n            AutoGenH.Append('extern %s _gPcd_BinaryPatch_%s%s;\\n' % (DatumType, TokenCName, Array))\n        else:\n            AutoGenH.Append('extern volatile  %s  %s%s;\\n' % (DatumType, PcdVariableName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_BinaryPatch_%s\\n' % (GetModeName, Type, TokenCName))\n        PcdDataSize = Pcd.GetPcdSize()\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('extern const UINTN %s; \\n' % PatchPcdMaxSizeVariable)\n        else:\n            AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n            AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS)\\n' % (SetModeStatusName, PcdVariableName))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n        AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n        AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n    if PcdItemType == TAB_PCDS_FIXED_AT_BUILD or PcdItemType == TAB_PCDS_FEATURE_FLAG:\n        key = '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        if DatumType == TAB_VOID and Array == '[]':\n            DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n        if DatumType not in TAB_PCD_NUMERIC_TYPES_VOID:\n            DatumType = TAB_UINT8\n        AutoGenH.Append('extern const %s _gPcd_FixedAtBuild_%s%s;\\n' % (DatumType, TokenCName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_FixedAtBuild_%s\\n' % (GetModeName, Type, TokenCName))\n        AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)\n        ConstFixedPcd = False\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD and (key in Info.ConstPcd or (Info.IsLibrary and (not Info.ReferenceModules))):\n            ConstFixedPcd = True\n            if key in Info.ConstPcd:\n                Pcd.DefaultValue = Info.ConstPcd[key]\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s%s\\n' % (TokenCName, Type, PcdVariableName))\n            else:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s\\n' % (TokenCName, Pcd.DefaultValue))\n        PcdDataSize = Pcd.GetPcdSize()\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                if ConstFixedPcd:\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                else:\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('extern const UINTN %s; \\n' % FixedPcdSizeVariableName)\n            else:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))",
            "def CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenSpaceGuidCName = Pcd.TokenSpaceGuidCName\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (TokenCName, TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n    elif (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n            TokenNumber = 0\n        else:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    else:\n        TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumType = Pcd.DatumType\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    Type = ''\n    Array = ''\n    if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n        if Pcd.DefaultValue[0] == '{':\n            Type = '(VOID *)'\n        Array = '[]'\n    PcdItemType = Pcd.Type\n    if PcdItemType in PCD_DYNAMIC_EX_TYPE_SET:\n        PcdExTokenName = '_PCD_TOKEN_' + TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    else:\n        AutoGenH.Append('#define _PCD_TOKEN_%s  %dU\\n' % (TokenCName, TokenNumber))\n    if PcdItemType in PCD_DYNAMIC_TYPE_SET:\n        PcdList = []\n        PcdCNameList = []\n        PcdList.extend(Info.LibraryPcdList)\n        PcdList.extend(Info.ModulePcdList)\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET:\n                PcdCNameList.append(PcdModule.TokenCName)\n        if PcdCNameList.count(Pcd.TokenCName) > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName.They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    if PcdItemType == TAB_PCDS_PATCHABLE_IN_MODULE:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[TAB_PCDS_PATCHABLE_IN_MODULE] + '_' + TokenCName\n        if DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if DatumType == TAB_VOID and Array == '[]':\n                DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n            else:\n                DatumType = TAB_UINT8\n            AutoGenH.Append('extern %s _gPcd_BinaryPatch_%s%s;\\n' % (DatumType, TokenCName, Array))\n        else:\n            AutoGenH.Append('extern volatile  %s  %s%s;\\n' % (DatumType, PcdVariableName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_BinaryPatch_%s\\n' % (GetModeName, Type, TokenCName))\n        PcdDataSize = Pcd.GetPcdSize()\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('extern const UINTN %s; \\n' % PatchPcdMaxSizeVariable)\n        else:\n            AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n            AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS)\\n' % (SetModeStatusName, PcdVariableName))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n        AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n        AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n    if PcdItemType == TAB_PCDS_FIXED_AT_BUILD or PcdItemType == TAB_PCDS_FEATURE_FLAG:\n        key = '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        if DatumType == TAB_VOID and Array == '[]':\n            DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n        if DatumType not in TAB_PCD_NUMERIC_TYPES_VOID:\n            DatumType = TAB_UINT8\n        AutoGenH.Append('extern const %s _gPcd_FixedAtBuild_%s%s;\\n' % (DatumType, TokenCName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_FixedAtBuild_%s\\n' % (GetModeName, Type, TokenCName))\n        AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)\n        ConstFixedPcd = False\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD and (key in Info.ConstPcd or (Info.IsLibrary and (not Info.ReferenceModules))):\n            ConstFixedPcd = True\n            if key in Info.ConstPcd:\n                Pcd.DefaultValue = Info.ConstPcd[key]\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s%s\\n' % (TokenCName, Type, PcdVariableName))\n            else:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s\\n' % (TokenCName, Pcd.DefaultValue))\n        PcdDataSize = Pcd.GetPcdSize()\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                if ConstFixedPcd:\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                else:\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('extern const UINTN %s; \\n' % FixedPcdSizeVariableName)\n            else:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))",
            "def CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    PcdTokenNumber = Info.PlatformInfo.PcdTokenNumber\n    TokenSpaceGuidCName = Pcd.TokenSpaceGuidCName\n    TokenCName = Pcd.TokenCName\n    for PcdItem in GlobalData.MixedPcd:\n        if (TokenCName, TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n            TokenCName = PcdItem[0]\n            break\n    PcdTokenName = '_PCD_TOKEN_' + TokenCName\n    FixPcdSizeTokenName = '_PCD_SIZE_' + TokenCName\n    PatchPcdSizeTokenName = '_PCD_PATCHABLE_' + TokenCName + '_SIZE'\n    PatchPcdSizeVariableName = '_gPcd_BinaryPatch_Size_' + TokenCName\n    PatchPcdMaxSizeVariable = '_gPcd_BinaryPatch_MaxSize_' + TokenCName\n    FixedPcdSizeVariableName = '_gPcd_FixedAtBuild_Size_' + TokenCName\n    if Pcd.PcdValueFromComm:\n        Pcd.DefaultValue = Pcd.PcdValueFromComm\n    elif Pcd.PcdValueFromFdf:\n        Pcd.DefaultValue = Pcd.PcdValueFromFdf\n    if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET:\n        TokenNumber = int(Pcd.TokenValue, 0)\n    elif (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) not in PcdTokenNumber:\n        if Pcd.Type in PCD_DYNAMIC_TYPE_SET:\n            TokenNumber = 0\n        else:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'No generated token number for %s.%s\\n' % (Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    else:\n        TokenNumber = PcdTokenNumber[Pcd.TokenCName, Pcd.TokenSpaceGuidCName]\n    if Pcd.Type not in gItemTypeStringDatabase:\n        EdkLogger.error('build', AUTOGEN_ERROR, 'Unknown PCD type [%s] of PCD %s.%s' % (Pcd.Type, Pcd.TokenSpaceGuidCName, TokenCName), ExtraData='[%s]' % str(Info))\n    DatumType = Pcd.DatumType\n    DatumSize = gDatumSizeStringDatabase[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabase else gDatumSizeStringDatabase[TAB_VOID]\n    DatumSizeLib = gDatumSizeStringDatabaseLib[Pcd.DatumType] if Pcd.DatumType in gDatumSizeStringDatabaseLib else gDatumSizeStringDatabaseLib[TAB_VOID]\n    GetModeName = '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_GET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_' + TokenCName\n    SetModeStatusName = '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[Pcd.DatumType] + '_S_' + TokenCName if Pcd.DatumType in gDatumSizeStringDatabaseH else '_PCD_SET_MODE_' + gDatumSizeStringDatabaseH[TAB_VOID] + '_S_' + TokenCName\n    GetModeSizeName = '_PCD_GET_MODE_SIZE' + '_' + TokenCName\n    Type = ''\n    Array = ''\n    if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n        if Pcd.DefaultValue[0] == '{':\n            Type = '(VOID *)'\n        Array = '[]'\n    PcdItemType = Pcd.Type\n    if PcdItemType in PCD_DYNAMIC_EX_TYPE_SET:\n        PcdExTokenName = '_PCD_TOKEN_' + TokenSpaceGuidCName + '_' + TokenCName\n        AutoGenH.Append('\\n#define %s  %dU\\n' % (PcdExTokenName, TokenNumber))\n        if Info.IsLibrary:\n            PcdList = Info.LibraryPcdList\n        else:\n            PcdList = Info.ModulePcdList\n        PcdExCNameTest = 0\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenCName == PcdModule.TokenCName:\n                PcdExCNameTest += 1\n            if PcdExCNameTest > 1:\n                break\n        if PcdExCNameTest > 1:\n            AutoGenH.Append('// Disabled the macros, as PcdToken and PcdGet/Set are not allowed in the case that more than one DynamicEx Pcds are different Guids but same CName.\\n')\n            AutoGenH.Append('// #define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('// #define %s  LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('// #define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n        else:\n            AutoGenH.Append('#define %s  %s\\n' % (PcdTokenName, PcdExTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetEx%s(&%s, %s)\\n' % (GetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            AutoGenH.Append('#define %s LibPcdGetExSize(&%s, %s)\\n' % (GetModeSizeName, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%s(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSetEx%sS(&%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%s(&%s, %s, (Value))\\n' % (SetModeName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSetEx%sS(&%s, %s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, Pcd.TokenSpaceGuidCName, PcdTokenName))\n    else:\n        AutoGenH.Append('#define _PCD_TOKEN_%s  %dU\\n' % (TokenCName, TokenNumber))\n    if PcdItemType in PCD_DYNAMIC_TYPE_SET:\n        PcdList = []\n        PcdCNameList = []\n        PcdList.extend(Info.LibraryPcdList)\n        PcdList.extend(Info.ModulePcdList)\n        for PcdModule in PcdList:\n            if PcdModule.Type in PCD_DYNAMIC_TYPE_SET:\n                PcdCNameList.append(PcdModule.TokenCName)\n        if PcdCNameList.count(Pcd.TokenCName) > 1:\n            EdkLogger.error('build', AUTOGEN_ERROR, 'More than one Dynamic Pcds [%s] are different Guids but same CName.They need to be changed to DynamicEx type to avoid the confliction.\\n' % TokenCName, ExtraData='[%s]' % str(Info.MetaFile.Path))\n        else:\n            AutoGenH.Append('#define %s  LibPcdGet%s(%s)\\n' % (GetModeName, DatumSizeLib, PcdTokenName))\n            AutoGenH.Append('#define %s  LibPcdGetSize(%s)\\n' % (GetModeSizeName, PcdTokenName))\n            if DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%s(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPcdSet%sS(%s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n            else:\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%s(%s, (Value))\\n' % (SetModeName, DatumSizeLib, PcdTokenName))\n                AutoGenH.Append('#define %s(Value)  LibPcdSet%sS(%s, (Value))\\n' % (SetModeStatusName, DatumSizeLib, PcdTokenName))\n    if PcdItemType == TAB_PCDS_PATCHABLE_IN_MODULE:\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[TAB_PCDS_PATCHABLE_IN_MODULE] + '_' + TokenCName\n        if DatumType not in TAB_PCD_NUMERIC_TYPES:\n            if DatumType == TAB_VOID and Array == '[]':\n                DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n            else:\n                DatumType = TAB_UINT8\n            AutoGenH.Append('extern %s _gPcd_BinaryPatch_%s%s;\\n' % (DatumType, TokenCName, Array))\n        else:\n            AutoGenH.Append('extern volatile  %s  %s%s;\\n' % (DatumType, PcdVariableName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_BinaryPatch_%s\\n' % (GetModeName, Type, TokenCName))\n        PcdDataSize = Pcd.GetPcdSize()\n        if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSize((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s(SizeOfBuffer, Buffer)  LibPatchPcdSetPtrAndSizeS((VOID *)_gPcd_BinaryPatch_%s, &%s, %s, (SizeOfBuffer), (Buffer))\\n' % (SetModeStatusName, TokenCName, PatchPcdSizeVariableName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PatchPcdMaxSizeVariable))\n            AutoGenH.Append('extern const UINTN %s; \\n' % PatchPcdMaxSizeVariable)\n        else:\n            AutoGenH.Append('#define %s(Value)  (%s = (Value))\\n' % (SetModeName, PcdVariableName))\n            AutoGenH.Append('#define %s(Value)  ((%s = (Value)), RETURN_SUCCESS)\\n' % (SetModeStatusName, PcdVariableName))\n            AutoGenH.Append('#define %s %s\\n' % (PatchPcdSizeTokenName, PcdDataSize))\n        AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, PatchPcdSizeVariableName))\n        AutoGenH.Append('extern UINTN %s; \\n' % PatchPcdSizeVariableName)\n    if PcdItemType == TAB_PCDS_FIXED_AT_BUILD or PcdItemType == TAB_PCDS_FEATURE_FLAG:\n        key = '.'.join((Pcd.TokenSpaceGuidCName, Pcd.TokenCName))\n        PcdVariableName = '_gPcd_' + gItemTypeStringDatabase[Pcd.Type] + '_' + TokenCName\n        if DatumType == TAB_VOID and Array == '[]':\n            DatumType = [TAB_UINT8, TAB_UINT16][Pcd.DefaultValue[0] == 'L']\n        if DatumType not in TAB_PCD_NUMERIC_TYPES_VOID:\n            DatumType = TAB_UINT8\n        AutoGenH.Append('extern const %s _gPcd_FixedAtBuild_%s%s;\\n' % (DatumType, TokenCName, Array))\n        AutoGenH.Append('#define %s  %s_gPcd_FixedAtBuild_%s\\n' % (GetModeName, Type, TokenCName))\n        AutoGenH.Append('//#define %s  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD\\n' % SetModeName)\n        ConstFixedPcd = False\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD and (key in Info.ConstPcd or (Info.IsLibrary and (not Info.ReferenceModules))):\n            ConstFixedPcd = True\n            if key in Info.ConstPcd:\n                Pcd.DefaultValue = Info.ConstPcd[key]\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s%s\\n' % (TokenCName, Type, PcdVariableName))\n            else:\n                AutoGenH.Append('#define _PCD_VALUE_%s %s\\n' % (TokenCName, Pcd.DefaultValue))\n        PcdDataSize = Pcd.GetPcdSize()\n        if PcdItemType == TAB_PCDS_FIXED_AT_BUILD:\n            if Pcd.DatumType not in TAB_PCD_NUMERIC_TYPES:\n                if ConstFixedPcd:\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))\n                else:\n                    AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, FixedPcdSizeVariableName))\n                    AutoGenH.Append('extern const UINTN %s; \\n' % FixedPcdSizeVariableName)\n            else:\n                AutoGenH.Append('#define %s %s\\n' % (FixPcdSizeTokenName, PcdDataSize))\n                AutoGenH.Append('#define %s %s\\n' % (GetModeSizeName, FixPcdSizeTokenName))"
        ]
    },
    {
        "func_name": "CreateLibraryConstructorCode",
        "original": "def CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH):\n    ConstructorPrototypeString = TemplateString()\n    ConstructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Lib in DependentLibraryList:\n        if len(Lib.ConstructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.ConstructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            ConstructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            ConstructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(ConstructorPrototypeString) == '':\n        ConstructorPrototypeList = []\n    else:\n        ConstructorPrototypeList = [str(ConstructorPrototypeString)]\n    if str(ConstructorCallingString) == '':\n        ConstructorCallingList = []\n    else:\n        ConstructorCallingList = [str(ConstructorCallingString)]\n    Dict = {'Type': 'Constructor', 'FunctionPrototype': ConstructorPrototypeList, 'FunctionCall': ConstructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
        "mutated": [
            "def CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    ConstructorPrototypeString = TemplateString()\n    ConstructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Lib in DependentLibraryList:\n        if len(Lib.ConstructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.ConstructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            ConstructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            ConstructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(ConstructorPrototypeString) == '':\n        ConstructorPrototypeList = []\n    else:\n        ConstructorPrototypeList = [str(ConstructorPrototypeString)]\n    if str(ConstructorCallingString) == '':\n        ConstructorCallingList = []\n    else:\n        ConstructorCallingList = [str(ConstructorCallingString)]\n    Dict = {'Type': 'Constructor', 'FunctionPrototype': ConstructorPrototypeList, 'FunctionCall': ConstructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
            "def CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ConstructorPrototypeString = TemplateString()\n    ConstructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Lib in DependentLibraryList:\n        if len(Lib.ConstructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.ConstructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            ConstructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            ConstructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(ConstructorPrototypeString) == '':\n        ConstructorPrototypeList = []\n    else:\n        ConstructorPrototypeList = [str(ConstructorPrototypeString)]\n    if str(ConstructorCallingString) == '':\n        ConstructorCallingList = []\n    else:\n        ConstructorCallingList = [str(ConstructorCallingString)]\n    Dict = {'Type': 'Constructor', 'FunctionPrototype': ConstructorPrototypeList, 'FunctionCall': ConstructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
            "def CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ConstructorPrototypeString = TemplateString()\n    ConstructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Lib in DependentLibraryList:\n        if len(Lib.ConstructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.ConstructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            ConstructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            ConstructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(ConstructorPrototypeString) == '':\n        ConstructorPrototypeList = []\n    else:\n        ConstructorPrototypeList = [str(ConstructorPrototypeString)]\n    if str(ConstructorCallingString) == '':\n        ConstructorCallingList = []\n    else:\n        ConstructorCallingList = [str(ConstructorCallingString)]\n    Dict = {'Type': 'Constructor', 'FunctionPrototype': ConstructorPrototypeList, 'FunctionCall': ConstructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
            "def CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ConstructorPrototypeString = TemplateString()\n    ConstructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Lib in DependentLibraryList:\n        if len(Lib.ConstructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.ConstructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            ConstructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            ConstructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(ConstructorPrototypeString) == '':\n        ConstructorPrototypeList = []\n    else:\n        ConstructorPrototypeList = [str(ConstructorPrototypeString)]\n    if str(ConstructorCallingString) == '':\n        ConstructorCallingList = []\n    else:\n        ConstructorCallingList = [str(ConstructorCallingString)]\n    Dict = {'Type': 'Constructor', 'FunctionPrototype': ConstructorPrototypeList, 'FunctionCall': ConstructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
            "def CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ConstructorPrototypeString = TemplateString()\n    ConstructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Lib in DependentLibraryList:\n        if len(Lib.ConstructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.ConstructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            ConstructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            ConstructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                ConstructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                ConstructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(ConstructorPrototypeString) == '':\n        ConstructorPrototypeList = []\n    else:\n        ConstructorPrototypeList = [str(ConstructorPrototypeString)]\n    if str(ConstructorCallingString) == '':\n        ConstructorCallingList = []\n    else:\n        ConstructorCallingList = [str(ConstructorCallingString)]\n    Dict = {'Type': 'Constructor', 'FunctionPrototype': ConstructorPrototypeList, 'FunctionCall': ConstructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))"
        ]
    },
    {
        "func_name": "CreateLibraryDestructorCode",
        "original": "def CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH):\n    DestructorPrototypeString = TemplateString()\n    DestructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Index in range(len(DependentLibraryList) - 1, -1, -1):\n        Lib = DependentLibraryList[Index]\n        if len(Lib.DestructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.DestructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            DestructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            DestructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(DestructorPrototypeString) == '':\n        DestructorPrototypeList = []\n    else:\n        DestructorPrototypeList = [str(DestructorPrototypeString)]\n    if str(DestructorCallingString) == '':\n        DestructorCallingList = []\n    else:\n        DestructorCallingList = [str(DestructorCallingString)]\n    Dict = {'Type': 'Destructor', 'FunctionPrototype': DestructorPrototypeList, 'FunctionCall': DestructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
        "mutated": [
            "def CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    DestructorPrototypeString = TemplateString()\n    DestructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Index in range(len(DependentLibraryList) - 1, -1, -1):\n        Lib = DependentLibraryList[Index]\n        if len(Lib.DestructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.DestructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            DestructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            DestructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(DestructorPrototypeString) == '':\n        DestructorPrototypeList = []\n    else:\n        DestructorPrototypeList = [str(DestructorPrototypeString)]\n    if str(DestructorCallingString) == '':\n        DestructorCallingList = []\n    else:\n        DestructorCallingList = [str(DestructorCallingString)]\n    Dict = {'Type': 'Destructor', 'FunctionPrototype': DestructorPrototypeList, 'FunctionCall': DestructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
            "def CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    DestructorPrototypeString = TemplateString()\n    DestructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Index in range(len(DependentLibraryList) - 1, -1, -1):\n        Lib = DependentLibraryList[Index]\n        if len(Lib.DestructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.DestructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            DestructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            DestructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(DestructorPrototypeString) == '':\n        DestructorPrototypeList = []\n    else:\n        DestructorPrototypeList = [str(DestructorPrototypeString)]\n    if str(DestructorCallingString) == '':\n        DestructorCallingList = []\n    else:\n        DestructorCallingList = [str(DestructorCallingString)]\n    Dict = {'Type': 'Destructor', 'FunctionPrototype': DestructorPrototypeList, 'FunctionCall': DestructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
            "def CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    DestructorPrototypeString = TemplateString()\n    DestructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Index in range(len(DependentLibraryList) - 1, -1, -1):\n        Lib = DependentLibraryList[Index]\n        if len(Lib.DestructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.DestructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            DestructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            DestructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(DestructorPrototypeString) == '':\n        DestructorPrototypeList = []\n    else:\n        DestructorPrototypeList = [str(DestructorPrototypeString)]\n    if str(DestructorCallingString) == '':\n        DestructorCallingList = []\n    else:\n        DestructorCallingList = [str(DestructorCallingString)]\n    Dict = {'Type': 'Destructor', 'FunctionPrototype': DestructorPrototypeList, 'FunctionCall': DestructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
            "def CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    DestructorPrototypeString = TemplateString()\n    DestructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Index in range(len(DependentLibraryList) - 1, -1, -1):\n        Lib = DependentLibraryList[Index]\n        if len(Lib.DestructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.DestructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            DestructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            DestructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(DestructorPrototypeString) == '':\n        DestructorPrototypeList = []\n    else:\n        DestructorPrototypeList = [str(DestructorPrototypeString)]\n    if str(DestructorCallingString) == '':\n        DestructorCallingList = []\n    else:\n        DestructorCallingList = [str(DestructorCallingString)]\n    Dict = {'Type': 'Destructor', 'FunctionPrototype': DestructorPrototypeList, 'FunctionCall': DestructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))",
            "def CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    DestructorPrototypeString = TemplateString()\n    DestructorCallingString = TemplateString()\n    if Info.IsLibrary:\n        DependentLibraryList = [Info.Module]\n    else:\n        DependentLibraryList = Info.DependentLibraryList\n    for Index in range(len(DependentLibraryList) - 1, -1, -1):\n        Lib = DependentLibraryList[Index]\n        if len(Lib.DestructorList) <= 0:\n            continue\n        Dict = {'Function': Lib.DestructorList}\n        if Lib.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC]:\n            DestructorPrototypeString.Append(gLibraryStructorPrototype[SUP_MODULE_BASE].Replace(Dict))\n            DestructorCallingString.Append(gLibraryStructorCall[SUP_MODULE_BASE].Replace(Dict))\n        if Info.ModuleType not in [SUP_MODULE_BASE, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n            if Lib.ModuleType in SUP_MODULE_SET_PEI:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['PEI'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['PEI'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['DXE'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['DXE'].Replace(Dict))\n            elif Lib.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n                DestructorPrototypeString.Append(gLibraryStructorPrototype['MM'].Replace(Dict))\n                DestructorCallingString.Append(gLibraryStructorCall['MM'].Replace(Dict))\n    if str(DestructorPrototypeString) == '':\n        DestructorPrototypeList = []\n    else:\n        DestructorPrototypeList = [str(DestructorPrototypeString)]\n    if str(DestructorCallingString) == '':\n        DestructorCallingList = []\n    else:\n        DestructorCallingList = [str(DestructorCallingString)]\n    Dict = {'Type': 'Destructor', 'FunctionPrototype': DestructorPrototypeList, 'FunctionCall': DestructorCallingList}\n    if Info.IsLibrary:\n        AutoGenH.Append('${BEGIN}${FunctionPrototype}${END}', Dict)\n    elif Info.ModuleType in [SUP_MODULE_BASE, SUP_MODULE_SEC, SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION]:\n        AutoGenC.Append(gLibraryString[SUP_MODULE_BASE].Replace(Dict))\n    elif Info.ModuleType in SUP_MODULE_SET_PEI:\n        AutoGenC.Append(gLibraryString['PEI'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_CORE, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SMM_DRIVER, SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER, SUP_MODULE_UEFI_APPLICATION, SUP_MODULE_SMM_CORE]:\n        AutoGenC.Append(gLibraryString['DXE'].Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_MM_STANDALONE, SUP_MODULE_MM_CORE_STANDALONE]:\n        AutoGenC.Append(gLibraryString['MM'].Replace(Dict))"
        ]
    },
    {
        "func_name": "CreateModuleEntryPointCode",
        "original": "def CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH):\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_SEC]:\n        return\n    NumEntryPoints = len(Info.Module.ModuleEntryPointList)\n    if 'PI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        PiSpecVersion = Info.Module.Specification['PI_SPECIFICATION_VERSION']\n    else:\n        PiSpecVersion = '0x00000000'\n    if 'UEFI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        UefiSpecVersion = Info.Module.Specification['UEFI_SPECIFICATION_VERSION']\n    else:\n        UefiSpecVersion = '0x00000000'\n    Dict = {'Function': Info.Module.ModuleEntryPointList, 'PiSpecVersion': PiSpecVersion + 'U', 'UefiSpecVersion': UefiSpecVersion + 'U'}\n    if Info.ModuleType in [SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE]:\n        if Info.SourceFileList:\n            if NumEntryPoints != 1:\n                EdkLogger.error('build', AUTOGEN_ERROR, '%s must have exactly one entry point' % Info.ModuleType, File=str(Info), ExtraData=', '.join(Info.Module.ModuleEntryPointList))\n    if Info.ModuleType == SUP_MODULE_PEI_CORE:\n        AutoGenC.Append(gPeiCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gPeiCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_CORE:\n        AutoGenC.Append(gDxeCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gDxeCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_SMM_CORE:\n        AutoGenC.Append(gSmmCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gSmmCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_CORE_STANDALONE:\n        AutoGenC.Append(gMmCoreStandaloneEntryPointString.Replace(Dict))\n        AutoGenH.Append(gMmCoreStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_PEIM:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gPeimEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gPeimEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gPeimEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER]:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiDriverEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiDriverEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiDriverEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n        if NumEntryPoints == 0:\n            AutoGenC.Append(gDxeSmmEntryPointString[0].Replace(Dict))\n        else:\n            AutoGenC.Append(gDxeSmmEntryPointString[1].Replace(Dict))\n        AutoGenH.Append(gDxeSmmEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_STANDALONE:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gMmStandaloneEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gMmStandaloneEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gMmStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_UEFI_APPLICATION:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiApplicationEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiApplicationEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiApplicationEntryPointPrototype.Replace(Dict))",
        "mutated": [
            "def CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_SEC]:\n        return\n    NumEntryPoints = len(Info.Module.ModuleEntryPointList)\n    if 'PI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        PiSpecVersion = Info.Module.Specification['PI_SPECIFICATION_VERSION']\n    else:\n        PiSpecVersion = '0x00000000'\n    if 'UEFI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        UefiSpecVersion = Info.Module.Specification['UEFI_SPECIFICATION_VERSION']\n    else:\n        UefiSpecVersion = '0x00000000'\n    Dict = {'Function': Info.Module.ModuleEntryPointList, 'PiSpecVersion': PiSpecVersion + 'U', 'UefiSpecVersion': UefiSpecVersion + 'U'}\n    if Info.ModuleType in [SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE]:\n        if Info.SourceFileList:\n            if NumEntryPoints != 1:\n                EdkLogger.error('build', AUTOGEN_ERROR, '%s must have exactly one entry point' % Info.ModuleType, File=str(Info), ExtraData=', '.join(Info.Module.ModuleEntryPointList))\n    if Info.ModuleType == SUP_MODULE_PEI_CORE:\n        AutoGenC.Append(gPeiCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gPeiCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_CORE:\n        AutoGenC.Append(gDxeCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gDxeCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_SMM_CORE:\n        AutoGenC.Append(gSmmCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gSmmCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_CORE_STANDALONE:\n        AutoGenC.Append(gMmCoreStandaloneEntryPointString.Replace(Dict))\n        AutoGenH.Append(gMmCoreStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_PEIM:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gPeimEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gPeimEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gPeimEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER]:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiDriverEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiDriverEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiDriverEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n        if NumEntryPoints == 0:\n            AutoGenC.Append(gDxeSmmEntryPointString[0].Replace(Dict))\n        else:\n            AutoGenC.Append(gDxeSmmEntryPointString[1].Replace(Dict))\n        AutoGenH.Append(gDxeSmmEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_STANDALONE:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gMmStandaloneEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gMmStandaloneEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gMmStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_UEFI_APPLICATION:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiApplicationEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiApplicationEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiApplicationEntryPointPrototype.Replace(Dict))",
            "def CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_SEC]:\n        return\n    NumEntryPoints = len(Info.Module.ModuleEntryPointList)\n    if 'PI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        PiSpecVersion = Info.Module.Specification['PI_SPECIFICATION_VERSION']\n    else:\n        PiSpecVersion = '0x00000000'\n    if 'UEFI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        UefiSpecVersion = Info.Module.Specification['UEFI_SPECIFICATION_VERSION']\n    else:\n        UefiSpecVersion = '0x00000000'\n    Dict = {'Function': Info.Module.ModuleEntryPointList, 'PiSpecVersion': PiSpecVersion + 'U', 'UefiSpecVersion': UefiSpecVersion + 'U'}\n    if Info.ModuleType in [SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE]:\n        if Info.SourceFileList:\n            if NumEntryPoints != 1:\n                EdkLogger.error('build', AUTOGEN_ERROR, '%s must have exactly one entry point' % Info.ModuleType, File=str(Info), ExtraData=', '.join(Info.Module.ModuleEntryPointList))\n    if Info.ModuleType == SUP_MODULE_PEI_CORE:\n        AutoGenC.Append(gPeiCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gPeiCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_CORE:\n        AutoGenC.Append(gDxeCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gDxeCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_SMM_CORE:\n        AutoGenC.Append(gSmmCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gSmmCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_CORE_STANDALONE:\n        AutoGenC.Append(gMmCoreStandaloneEntryPointString.Replace(Dict))\n        AutoGenH.Append(gMmCoreStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_PEIM:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gPeimEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gPeimEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gPeimEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER]:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiDriverEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiDriverEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiDriverEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n        if NumEntryPoints == 0:\n            AutoGenC.Append(gDxeSmmEntryPointString[0].Replace(Dict))\n        else:\n            AutoGenC.Append(gDxeSmmEntryPointString[1].Replace(Dict))\n        AutoGenH.Append(gDxeSmmEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_STANDALONE:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gMmStandaloneEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gMmStandaloneEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gMmStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_UEFI_APPLICATION:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiApplicationEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiApplicationEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiApplicationEntryPointPrototype.Replace(Dict))",
            "def CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_SEC]:\n        return\n    NumEntryPoints = len(Info.Module.ModuleEntryPointList)\n    if 'PI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        PiSpecVersion = Info.Module.Specification['PI_SPECIFICATION_VERSION']\n    else:\n        PiSpecVersion = '0x00000000'\n    if 'UEFI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        UefiSpecVersion = Info.Module.Specification['UEFI_SPECIFICATION_VERSION']\n    else:\n        UefiSpecVersion = '0x00000000'\n    Dict = {'Function': Info.Module.ModuleEntryPointList, 'PiSpecVersion': PiSpecVersion + 'U', 'UefiSpecVersion': UefiSpecVersion + 'U'}\n    if Info.ModuleType in [SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE]:\n        if Info.SourceFileList:\n            if NumEntryPoints != 1:\n                EdkLogger.error('build', AUTOGEN_ERROR, '%s must have exactly one entry point' % Info.ModuleType, File=str(Info), ExtraData=', '.join(Info.Module.ModuleEntryPointList))\n    if Info.ModuleType == SUP_MODULE_PEI_CORE:\n        AutoGenC.Append(gPeiCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gPeiCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_CORE:\n        AutoGenC.Append(gDxeCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gDxeCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_SMM_CORE:\n        AutoGenC.Append(gSmmCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gSmmCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_CORE_STANDALONE:\n        AutoGenC.Append(gMmCoreStandaloneEntryPointString.Replace(Dict))\n        AutoGenH.Append(gMmCoreStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_PEIM:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gPeimEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gPeimEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gPeimEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER]:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiDriverEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiDriverEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiDriverEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n        if NumEntryPoints == 0:\n            AutoGenC.Append(gDxeSmmEntryPointString[0].Replace(Dict))\n        else:\n            AutoGenC.Append(gDxeSmmEntryPointString[1].Replace(Dict))\n        AutoGenH.Append(gDxeSmmEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_STANDALONE:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gMmStandaloneEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gMmStandaloneEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gMmStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_UEFI_APPLICATION:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiApplicationEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiApplicationEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiApplicationEntryPointPrototype.Replace(Dict))",
            "def CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_SEC]:\n        return\n    NumEntryPoints = len(Info.Module.ModuleEntryPointList)\n    if 'PI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        PiSpecVersion = Info.Module.Specification['PI_SPECIFICATION_VERSION']\n    else:\n        PiSpecVersion = '0x00000000'\n    if 'UEFI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        UefiSpecVersion = Info.Module.Specification['UEFI_SPECIFICATION_VERSION']\n    else:\n        UefiSpecVersion = '0x00000000'\n    Dict = {'Function': Info.Module.ModuleEntryPointList, 'PiSpecVersion': PiSpecVersion + 'U', 'UefiSpecVersion': UefiSpecVersion + 'U'}\n    if Info.ModuleType in [SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE]:\n        if Info.SourceFileList:\n            if NumEntryPoints != 1:\n                EdkLogger.error('build', AUTOGEN_ERROR, '%s must have exactly one entry point' % Info.ModuleType, File=str(Info), ExtraData=', '.join(Info.Module.ModuleEntryPointList))\n    if Info.ModuleType == SUP_MODULE_PEI_CORE:\n        AutoGenC.Append(gPeiCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gPeiCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_CORE:\n        AutoGenC.Append(gDxeCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gDxeCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_SMM_CORE:\n        AutoGenC.Append(gSmmCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gSmmCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_CORE_STANDALONE:\n        AutoGenC.Append(gMmCoreStandaloneEntryPointString.Replace(Dict))\n        AutoGenH.Append(gMmCoreStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_PEIM:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gPeimEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gPeimEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gPeimEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER]:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiDriverEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiDriverEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiDriverEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n        if NumEntryPoints == 0:\n            AutoGenC.Append(gDxeSmmEntryPointString[0].Replace(Dict))\n        else:\n            AutoGenC.Append(gDxeSmmEntryPointString[1].Replace(Dict))\n        AutoGenH.Append(gDxeSmmEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_STANDALONE:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gMmStandaloneEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gMmStandaloneEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gMmStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_UEFI_APPLICATION:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiApplicationEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiApplicationEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiApplicationEntryPointPrototype.Replace(Dict))",
            "def CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_SEC]:\n        return\n    NumEntryPoints = len(Info.Module.ModuleEntryPointList)\n    if 'PI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        PiSpecVersion = Info.Module.Specification['PI_SPECIFICATION_VERSION']\n    else:\n        PiSpecVersion = '0x00000000'\n    if 'UEFI_SPECIFICATION_VERSION' in Info.Module.Specification:\n        UefiSpecVersion = Info.Module.Specification['UEFI_SPECIFICATION_VERSION']\n    else:\n        UefiSpecVersion = '0x00000000'\n    Dict = {'Function': Info.Module.ModuleEntryPointList, 'PiSpecVersion': PiSpecVersion + 'U', 'UefiSpecVersion': UefiSpecVersion + 'U'}\n    if Info.ModuleType in [SUP_MODULE_PEI_CORE, SUP_MODULE_DXE_CORE, SUP_MODULE_SMM_CORE, SUP_MODULE_MM_CORE_STANDALONE]:\n        if Info.SourceFileList:\n            if NumEntryPoints != 1:\n                EdkLogger.error('build', AUTOGEN_ERROR, '%s must have exactly one entry point' % Info.ModuleType, File=str(Info), ExtraData=', '.join(Info.Module.ModuleEntryPointList))\n    if Info.ModuleType == SUP_MODULE_PEI_CORE:\n        AutoGenC.Append(gPeiCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gPeiCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_CORE:\n        AutoGenC.Append(gDxeCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gDxeCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_SMM_CORE:\n        AutoGenC.Append(gSmmCoreEntryPointString.Replace(Dict))\n        AutoGenH.Append(gSmmCoreEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_CORE_STANDALONE:\n        AutoGenC.Append(gMmCoreStandaloneEntryPointString.Replace(Dict))\n        AutoGenH.Append(gMmCoreStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_PEIM:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gPeimEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gPeimEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gPeimEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType in [SUP_MODULE_DXE_RUNTIME_DRIVER, SUP_MODULE_DXE_DRIVER, SUP_MODULE_DXE_SAL_DRIVER, SUP_MODULE_UEFI_DRIVER]:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiDriverEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiDriverEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiDriverEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_DXE_SMM_DRIVER:\n        if NumEntryPoints == 0:\n            AutoGenC.Append(gDxeSmmEntryPointString[0].Replace(Dict))\n        else:\n            AutoGenC.Append(gDxeSmmEntryPointString[1].Replace(Dict))\n        AutoGenH.Append(gDxeSmmEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_MM_STANDALONE:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gMmStandaloneEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gMmStandaloneEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gMmStandaloneEntryPointPrototype.Replace(Dict))\n    elif Info.ModuleType == SUP_MODULE_UEFI_APPLICATION:\n        if NumEntryPoints < 2:\n            AutoGenC.Append(gUefiApplicationEntryPointString[NumEntryPoints].Replace(Dict))\n        else:\n            AutoGenC.Append(gUefiApplicationEntryPointString[2].Replace(Dict))\n        AutoGenH.Append(gUefiApplicationEntryPointPrototype.Replace(Dict))"
        ]
    },
    {
        "func_name": "CreateModuleUnloadImageCode",
        "original": "def CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH):\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE, SUP_MODULE_SEC]:\n        return\n    NumUnloadImage = len(Info.Module.ModuleUnloadImageList)\n    Dict = {'Count': str(NumUnloadImage) + 'U', 'Function': Info.Module.ModuleUnloadImageList}\n    if NumUnloadImage < 2:\n        AutoGenC.Append(gUefiUnloadImageString[NumUnloadImage].Replace(Dict))\n    else:\n        AutoGenC.Append(gUefiUnloadImageString[2].Replace(Dict))\n    AutoGenH.Append(gUefiUnloadImagePrototype.Replace(Dict))",
        "mutated": [
            "def CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE, SUP_MODULE_SEC]:\n        return\n    NumUnloadImage = len(Info.Module.ModuleUnloadImageList)\n    Dict = {'Count': str(NumUnloadImage) + 'U', 'Function': Info.Module.ModuleUnloadImageList}\n    if NumUnloadImage < 2:\n        AutoGenC.Append(gUefiUnloadImageString[NumUnloadImage].Replace(Dict))\n    else:\n        AutoGenC.Append(gUefiUnloadImageString[2].Replace(Dict))\n    AutoGenH.Append(gUefiUnloadImagePrototype.Replace(Dict))",
            "def CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE, SUP_MODULE_SEC]:\n        return\n    NumUnloadImage = len(Info.Module.ModuleUnloadImageList)\n    Dict = {'Count': str(NumUnloadImage) + 'U', 'Function': Info.Module.ModuleUnloadImageList}\n    if NumUnloadImage < 2:\n        AutoGenC.Append(gUefiUnloadImageString[NumUnloadImage].Replace(Dict))\n    else:\n        AutoGenC.Append(gUefiUnloadImageString[2].Replace(Dict))\n    AutoGenH.Append(gUefiUnloadImagePrototype.Replace(Dict))",
            "def CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE, SUP_MODULE_SEC]:\n        return\n    NumUnloadImage = len(Info.Module.ModuleUnloadImageList)\n    Dict = {'Count': str(NumUnloadImage) + 'U', 'Function': Info.Module.ModuleUnloadImageList}\n    if NumUnloadImage < 2:\n        AutoGenC.Append(gUefiUnloadImageString[NumUnloadImage].Replace(Dict))\n    else:\n        AutoGenC.Append(gUefiUnloadImageString[2].Replace(Dict))\n    AutoGenH.Append(gUefiUnloadImagePrototype.Replace(Dict))",
            "def CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE, SUP_MODULE_SEC]:\n        return\n    NumUnloadImage = len(Info.Module.ModuleUnloadImageList)\n    Dict = {'Count': str(NumUnloadImage) + 'U', 'Function': Info.Module.ModuleUnloadImageList}\n    if NumUnloadImage < 2:\n        AutoGenC.Append(gUefiUnloadImageString[NumUnloadImage].Replace(Dict))\n    else:\n        AutoGenC.Append(gUefiUnloadImageString[2].Replace(Dict))\n    AutoGenH.Append(gUefiUnloadImagePrototype.Replace(Dict))",
            "def CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Info.IsLibrary or Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE, SUP_MODULE_SEC]:\n        return\n    NumUnloadImage = len(Info.Module.ModuleUnloadImageList)\n    Dict = {'Count': str(NumUnloadImage) + 'U', 'Function': Info.Module.ModuleUnloadImageList}\n    if NumUnloadImage < 2:\n        AutoGenC.Append(gUefiUnloadImageString[NumUnloadImage].Replace(Dict))\n    else:\n        AutoGenC.Append(gUefiUnloadImageString[2].Replace(Dict))\n    AutoGenH.Append(gUefiUnloadImagePrototype.Replace(Dict))"
        ]
    },
    {
        "func_name": "CreateGuidDefinitionCode",
        "original": "def CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH):\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Guids\\n')\n        AutoGenH.Append('\\n// Guids\\n')\n    for Key in Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.GuidList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
        "mutated": [
            "def CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Guids\\n')\n        AutoGenH.Append('\\n// Guids\\n')\n    for Key in Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.GuidList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Guids\\n')\n        AutoGenH.Append('\\n// Guids\\n')\n    for Key in Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.GuidList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Guids\\n')\n        AutoGenH.Append('\\n// Guids\\n')\n    for Key in Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.GuidList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Guids\\n')\n        AutoGenH.Append('\\n// Guids\\n')\n    for Key in Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.GuidList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Guids\\n')\n        AutoGenH.Append('\\n// Guids\\n')\n    for Key in Info.GuidList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.GuidList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))"
        ]
    },
    {
        "func_name": "CreateProtocolDefinitionCode",
        "original": "def CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH):\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Protocols\\n')\n        AutoGenH.Append('\\n// Protocols\\n')\n    for Key in Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.ProtocolList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
        "mutated": [
            "def CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Protocols\\n')\n        AutoGenH.Append('\\n// Protocols\\n')\n    for Key in Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.ProtocolList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Protocols\\n')\n        AutoGenH.Append('\\n// Protocols\\n')\n    for Key in Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.ProtocolList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Protocols\\n')\n        AutoGenH.Append('\\n// Protocols\\n')\n    for Key in Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.ProtocolList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Protocols\\n')\n        AutoGenH.Append('\\n// Protocols\\n')\n    for Key in Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.ProtocolList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// Protocols\\n')\n        AutoGenH.Append('\\n// Protocols\\n')\n    for Key in Info.ProtocolList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.ProtocolList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))"
        ]
    },
    {
        "func_name": "CreatePpiDefinitionCode",
        "original": "def CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH):\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// PPIs\\n')\n        AutoGenH.Append('\\n// PPIs\\n')\n    for Key in Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.PpiList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
        "mutated": [
            "def CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// PPIs\\n')\n        AutoGenH.Append('\\n// PPIs\\n')\n    for Key in Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.PpiList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// PPIs\\n')\n        AutoGenH.Append('\\n// PPIs\\n')\n    for Key in Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.PpiList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// PPIs\\n')\n        AutoGenH.Append('\\n// PPIs\\n')\n    for Key in Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.PpiList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// PPIs\\n')\n        AutoGenH.Append('\\n// PPIs\\n')\n    for Key in Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.PpiList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))",
            "def CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n        GuidType = TAB_GUID\n    else:\n        GuidType = 'EFI_GUID'\n    if Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('\\n// PPIs\\n')\n        AutoGenH.Append('\\n// PPIs\\n')\n    for Key in Info.PpiList:\n        if not Info.IsLibrary:\n            AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED %s %s = %s;\\n' % (GuidType, Key, Info.PpiList[Key]))\n        AutoGenH.Append('extern %s %s;\\n' % (GuidType, Key))"
        ]
    },
    {
        "func_name": "CreatePcdCode",
        "original": "def CreatePcdCode(Info, AutoGenC, AutoGenH):\n    TokenSpaceList = []\n    for Pcd in Info.ModulePcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenSpaceGuidCName not in TokenSpaceList:\n            TokenSpaceList.append(Pcd.TokenSpaceGuidCName)\n    SkuMgr = Info.PlatformInfo.Platform.SkuIdMgr\n    AutoGenH.Append('\\n// Definition of SkuId Array\\n')\n    AutoGenH.Append('extern UINT64 _gPcd_SkuId_Array[];\\n')\n    if TokenSpaceList:\n        AutoGenH.Append('\\n// Definition of PCD Token Space GUIDs used in this module\\n\\n')\n        if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n            GuidType = TAB_GUID\n        else:\n            GuidType = 'EFI_GUID'\n        for Item in TokenSpaceList:\n            AutoGenH.Append('extern %s %s;\\n' % (GuidType, Item))\n    if Info.IsLibrary:\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// PCD definitions\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n    else:\n        AutoGenC.Append('\\n// Definition of SkuId Array\\n')\n        AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINT64 _gPcd_SkuId_Array[] = %s;\\n' % SkuMgr.DumpSkuIdArrary())\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in this module\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in this module\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n        if Info.LibraryPcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in libraries is in AutoGen.c\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in libraries\\n')\n        for Pcd in Info.LibraryPcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenC, Pcd)\n    CreatePcdDatabaseCode(Info, AutoGenC, AutoGenH)",
        "mutated": [
            "def CreatePcdCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    TokenSpaceList = []\n    for Pcd in Info.ModulePcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenSpaceGuidCName not in TokenSpaceList:\n            TokenSpaceList.append(Pcd.TokenSpaceGuidCName)\n    SkuMgr = Info.PlatformInfo.Platform.SkuIdMgr\n    AutoGenH.Append('\\n// Definition of SkuId Array\\n')\n    AutoGenH.Append('extern UINT64 _gPcd_SkuId_Array[];\\n')\n    if TokenSpaceList:\n        AutoGenH.Append('\\n// Definition of PCD Token Space GUIDs used in this module\\n\\n')\n        if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n            GuidType = TAB_GUID\n        else:\n            GuidType = 'EFI_GUID'\n        for Item in TokenSpaceList:\n            AutoGenH.Append('extern %s %s;\\n' % (GuidType, Item))\n    if Info.IsLibrary:\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// PCD definitions\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n    else:\n        AutoGenC.Append('\\n// Definition of SkuId Array\\n')\n        AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINT64 _gPcd_SkuId_Array[] = %s;\\n' % SkuMgr.DumpSkuIdArrary())\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in this module\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in this module\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n        if Info.LibraryPcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in libraries is in AutoGen.c\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in libraries\\n')\n        for Pcd in Info.LibraryPcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenC, Pcd)\n    CreatePcdDatabaseCode(Info, AutoGenC, AutoGenH)",
            "def CreatePcdCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    TokenSpaceList = []\n    for Pcd in Info.ModulePcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenSpaceGuidCName not in TokenSpaceList:\n            TokenSpaceList.append(Pcd.TokenSpaceGuidCName)\n    SkuMgr = Info.PlatformInfo.Platform.SkuIdMgr\n    AutoGenH.Append('\\n// Definition of SkuId Array\\n')\n    AutoGenH.Append('extern UINT64 _gPcd_SkuId_Array[];\\n')\n    if TokenSpaceList:\n        AutoGenH.Append('\\n// Definition of PCD Token Space GUIDs used in this module\\n\\n')\n        if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n            GuidType = TAB_GUID\n        else:\n            GuidType = 'EFI_GUID'\n        for Item in TokenSpaceList:\n            AutoGenH.Append('extern %s %s;\\n' % (GuidType, Item))\n    if Info.IsLibrary:\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// PCD definitions\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n    else:\n        AutoGenC.Append('\\n// Definition of SkuId Array\\n')\n        AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINT64 _gPcd_SkuId_Array[] = %s;\\n' % SkuMgr.DumpSkuIdArrary())\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in this module\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in this module\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n        if Info.LibraryPcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in libraries is in AutoGen.c\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in libraries\\n')\n        for Pcd in Info.LibraryPcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenC, Pcd)\n    CreatePcdDatabaseCode(Info, AutoGenC, AutoGenH)",
            "def CreatePcdCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    TokenSpaceList = []\n    for Pcd in Info.ModulePcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenSpaceGuidCName not in TokenSpaceList:\n            TokenSpaceList.append(Pcd.TokenSpaceGuidCName)\n    SkuMgr = Info.PlatformInfo.Platform.SkuIdMgr\n    AutoGenH.Append('\\n// Definition of SkuId Array\\n')\n    AutoGenH.Append('extern UINT64 _gPcd_SkuId_Array[];\\n')\n    if TokenSpaceList:\n        AutoGenH.Append('\\n// Definition of PCD Token Space GUIDs used in this module\\n\\n')\n        if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n            GuidType = TAB_GUID\n        else:\n            GuidType = 'EFI_GUID'\n        for Item in TokenSpaceList:\n            AutoGenH.Append('extern %s %s;\\n' % (GuidType, Item))\n    if Info.IsLibrary:\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// PCD definitions\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n    else:\n        AutoGenC.Append('\\n// Definition of SkuId Array\\n')\n        AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINT64 _gPcd_SkuId_Array[] = %s;\\n' % SkuMgr.DumpSkuIdArrary())\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in this module\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in this module\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n        if Info.LibraryPcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in libraries is in AutoGen.c\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in libraries\\n')\n        for Pcd in Info.LibraryPcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenC, Pcd)\n    CreatePcdDatabaseCode(Info, AutoGenC, AutoGenH)",
            "def CreatePcdCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    TokenSpaceList = []\n    for Pcd in Info.ModulePcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenSpaceGuidCName not in TokenSpaceList:\n            TokenSpaceList.append(Pcd.TokenSpaceGuidCName)\n    SkuMgr = Info.PlatformInfo.Platform.SkuIdMgr\n    AutoGenH.Append('\\n// Definition of SkuId Array\\n')\n    AutoGenH.Append('extern UINT64 _gPcd_SkuId_Array[];\\n')\n    if TokenSpaceList:\n        AutoGenH.Append('\\n// Definition of PCD Token Space GUIDs used in this module\\n\\n')\n        if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n            GuidType = TAB_GUID\n        else:\n            GuidType = 'EFI_GUID'\n        for Item in TokenSpaceList:\n            AutoGenH.Append('extern %s %s;\\n' % (GuidType, Item))\n    if Info.IsLibrary:\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// PCD definitions\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n    else:\n        AutoGenC.Append('\\n// Definition of SkuId Array\\n')\n        AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINT64 _gPcd_SkuId_Array[] = %s;\\n' % SkuMgr.DumpSkuIdArrary())\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in this module\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in this module\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n        if Info.LibraryPcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in libraries is in AutoGen.c\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in libraries\\n')\n        for Pcd in Info.LibraryPcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenC, Pcd)\n    CreatePcdDatabaseCode(Info, AutoGenC, AutoGenH)",
            "def CreatePcdCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    TokenSpaceList = []\n    for Pcd in Info.ModulePcdList:\n        if Pcd.Type in PCD_DYNAMIC_EX_TYPE_SET and Pcd.TokenSpaceGuidCName not in TokenSpaceList:\n            TokenSpaceList.append(Pcd.TokenSpaceGuidCName)\n    SkuMgr = Info.PlatformInfo.Platform.SkuIdMgr\n    AutoGenH.Append('\\n// Definition of SkuId Array\\n')\n    AutoGenH.Append('extern UINT64 _gPcd_SkuId_Array[];\\n')\n    if TokenSpaceList:\n        AutoGenH.Append('\\n// Definition of PCD Token Space GUIDs used in this module\\n\\n')\n        if Info.ModuleType in [SUP_MODULE_USER_DEFINED, SUP_MODULE_HOST_APPLICATION, SUP_MODULE_BASE]:\n            GuidType = TAB_GUID\n        else:\n            GuidType = 'EFI_GUID'\n        for Item in TokenSpaceList:\n            AutoGenH.Append('extern %s %s;\\n' % (GuidType, Item))\n    if Info.IsLibrary:\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// PCD definitions\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateLibraryPcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n    else:\n        AutoGenC.Append('\\n// Definition of SkuId Array\\n')\n        AutoGenC.Append('GLOBAL_REMOVE_IF_UNREFERENCED UINT64 _gPcd_SkuId_Array[] = %s;\\n' % SkuMgr.DumpSkuIdArrary())\n        if Info.ModulePcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in this module\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in this module\\n')\n        for Pcd in Info.ModulePcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenH, Pcd)\n        DynExPcdTokenNumberMapping(Info, AutoGenH)\n        if Info.LibraryPcdList:\n            AutoGenH.Append('\\n// Definition of PCDs used in libraries is in AutoGen.c\\n')\n            AutoGenC.Append('\\n// Definition of PCDs used in libraries\\n')\n        for Pcd in Info.LibraryPcdList:\n            CreateModulePcdCode(Info, AutoGenC, AutoGenC, Pcd)\n    CreatePcdDatabaseCode(Info, AutoGenC, AutoGenH)"
        ]
    },
    {
        "func_name": "CreateUnicodeStringCode",
        "original": "def CreateUnicodeStringCode(Info, AutoGenC, AutoGenH, UniGenCFlag, UniGenBinBuffer):\n    WorkingDir = os.getcwd()\n    os.chdir(Info.WorkspaceDir)\n    IncList = [Info.MetaFile.Dir]\n    EDK2Module = True\n    SrcList = [F for F in Info.SourceFileList]\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-c') > -1:\n        CompatibleMode = True\n    else:\n        CompatibleMode = False\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-s') > -1:\n        if CompatibleMode:\n            EdkLogger.error('build', AUTOGEN_ERROR, '-c and -s build options should be used exclusively', ExtraData='[%s]' % str(Info))\n        ShellMode = True\n    else:\n        ShellMode = False\n    if EDK2Module:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.RFCLanguages]\n    else:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.ISOLanguages]\n    (Header, Code) = GetStringFiles(Info.UnicodeFileList, SrcList, IncList, Info.IncludePathList, ['.uni', '.inf'], Info.Name, CompatibleMode, ShellMode, UniGenCFlag, UniGenBinBuffer, FilterInfo)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenC.Append('\\n//\\n//Unicode String Pack Definition\\n//\\n')\n        AutoGenC.Append(Code)\n        AutoGenC.Append('\\n')\n    AutoGenH.Append('\\n//\\n//Unicode String ID\\n//\\n')\n    AutoGenH.Append(Header)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenH.Append('\\n#define STRING_ARRAY_NAME %sStrings\\n' % Info.Name)\n    os.chdir(WorkingDir)",
        "mutated": [
            "def CreateUnicodeStringCode(Info, AutoGenC, AutoGenH, UniGenCFlag, UniGenBinBuffer):\n    if False:\n        i = 10\n    WorkingDir = os.getcwd()\n    os.chdir(Info.WorkspaceDir)\n    IncList = [Info.MetaFile.Dir]\n    EDK2Module = True\n    SrcList = [F for F in Info.SourceFileList]\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-c') > -1:\n        CompatibleMode = True\n    else:\n        CompatibleMode = False\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-s') > -1:\n        if CompatibleMode:\n            EdkLogger.error('build', AUTOGEN_ERROR, '-c and -s build options should be used exclusively', ExtraData='[%s]' % str(Info))\n        ShellMode = True\n    else:\n        ShellMode = False\n    if EDK2Module:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.RFCLanguages]\n    else:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.ISOLanguages]\n    (Header, Code) = GetStringFiles(Info.UnicodeFileList, SrcList, IncList, Info.IncludePathList, ['.uni', '.inf'], Info.Name, CompatibleMode, ShellMode, UniGenCFlag, UniGenBinBuffer, FilterInfo)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenC.Append('\\n//\\n//Unicode String Pack Definition\\n//\\n')\n        AutoGenC.Append(Code)\n        AutoGenC.Append('\\n')\n    AutoGenH.Append('\\n//\\n//Unicode String ID\\n//\\n')\n    AutoGenH.Append(Header)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenH.Append('\\n#define STRING_ARRAY_NAME %sStrings\\n' % Info.Name)\n    os.chdir(WorkingDir)",
            "def CreateUnicodeStringCode(Info, AutoGenC, AutoGenH, UniGenCFlag, UniGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    WorkingDir = os.getcwd()\n    os.chdir(Info.WorkspaceDir)\n    IncList = [Info.MetaFile.Dir]\n    EDK2Module = True\n    SrcList = [F for F in Info.SourceFileList]\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-c') > -1:\n        CompatibleMode = True\n    else:\n        CompatibleMode = False\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-s') > -1:\n        if CompatibleMode:\n            EdkLogger.error('build', AUTOGEN_ERROR, '-c and -s build options should be used exclusively', ExtraData='[%s]' % str(Info))\n        ShellMode = True\n    else:\n        ShellMode = False\n    if EDK2Module:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.RFCLanguages]\n    else:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.ISOLanguages]\n    (Header, Code) = GetStringFiles(Info.UnicodeFileList, SrcList, IncList, Info.IncludePathList, ['.uni', '.inf'], Info.Name, CompatibleMode, ShellMode, UniGenCFlag, UniGenBinBuffer, FilterInfo)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenC.Append('\\n//\\n//Unicode String Pack Definition\\n//\\n')\n        AutoGenC.Append(Code)\n        AutoGenC.Append('\\n')\n    AutoGenH.Append('\\n//\\n//Unicode String ID\\n//\\n')\n    AutoGenH.Append(Header)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenH.Append('\\n#define STRING_ARRAY_NAME %sStrings\\n' % Info.Name)\n    os.chdir(WorkingDir)",
            "def CreateUnicodeStringCode(Info, AutoGenC, AutoGenH, UniGenCFlag, UniGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    WorkingDir = os.getcwd()\n    os.chdir(Info.WorkspaceDir)\n    IncList = [Info.MetaFile.Dir]\n    EDK2Module = True\n    SrcList = [F for F in Info.SourceFileList]\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-c') > -1:\n        CompatibleMode = True\n    else:\n        CompatibleMode = False\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-s') > -1:\n        if CompatibleMode:\n            EdkLogger.error('build', AUTOGEN_ERROR, '-c and -s build options should be used exclusively', ExtraData='[%s]' % str(Info))\n        ShellMode = True\n    else:\n        ShellMode = False\n    if EDK2Module:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.RFCLanguages]\n    else:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.ISOLanguages]\n    (Header, Code) = GetStringFiles(Info.UnicodeFileList, SrcList, IncList, Info.IncludePathList, ['.uni', '.inf'], Info.Name, CompatibleMode, ShellMode, UniGenCFlag, UniGenBinBuffer, FilterInfo)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenC.Append('\\n//\\n//Unicode String Pack Definition\\n//\\n')\n        AutoGenC.Append(Code)\n        AutoGenC.Append('\\n')\n    AutoGenH.Append('\\n//\\n//Unicode String ID\\n//\\n')\n    AutoGenH.Append(Header)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenH.Append('\\n#define STRING_ARRAY_NAME %sStrings\\n' % Info.Name)\n    os.chdir(WorkingDir)",
            "def CreateUnicodeStringCode(Info, AutoGenC, AutoGenH, UniGenCFlag, UniGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    WorkingDir = os.getcwd()\n    os.chdir(Info.WorkspaceDir)\n    IncList = [Info.MetaFile.Dir]\n    EDK2Module = True\n    SrcList = [F for F in Info.SourceFileList]\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-c') > -1:\n        CompatibleMode = True\n    else:\n        CompatibleMode = False\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-s') > -1:\n        if CompatibleMode:\n            EdkLogger.error('build', AUTOGEN_ERROR, '-c and -s build options should be used exclusively', ExtraData='[%s]' % str(Info))\n        ShellMode = True\n    else:\n        ShellMode = False\n    if EDK2Module:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.RFCLanguages]\n    else:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.ISOLanguages]\n    (Header, Code) = GetStringFiles(Info.UnicodeFileList, SrcList, IncList, Info.IncludePathList, ['.uni', '.inf'], Info.Name, CompatibleMode, ShellMode, UniGenCFlag, UniGenBinBuffer, FilterInfo)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenC.Append('\\n//\\n//Unicode String Pack Definition\\n//\\n')\n        AutoGenC.Append(Code)\n        AutoGenC.Append('\\n')\n    AutoGenH.Append('\\n//\\n//Unicode String ID\\n//\\n')\n    AutoGenH.Append(Header)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenH.Append('\\n#define STRING_ARRAY_NAME %sStrings\\n' % Info.Name)\n    os.chdir(WorkingDir)",
            "def CreateUnicodeStringCode(Info, AutoGenC, AutoGenH, UniGenCFlag, UniGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    WorkingDir = os.getcwd()\n    os.chdir(Info.WorkspaceDir)\n    IncList = [Info.MetaFile.Dir]\n    EDK2Module = True\n    SrcList = [F for F in Info.SourceFileList]\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-c') > -1:\n        CompatibleMode = True\n    else:\n        CompatibleMode = False\n    if 'BUILD' in Info.BuildOption and Info.BuildOption['BUILD']['FLAGS'].find('-s') > -1:\n        if CompatibleMode:\n            EdkLogger.error('build', AUTOGEN_ERROR, '-c and -s build options should be used exclusively', ExtraData='[%s]' % str(Info))\n        ShellMode = True\n    else:\n        ShellMode = False\n    if EDK2Module:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.RFCLanguages]\n    else:\n        FilterInfo = [EDK2Module] + [Info.PlatformInfo.Platform.ISOLanguages]\n    (Header, Code) = GetStringFiles(Info.UnicodeFileList, SrcList, IncList, Info.IncludePathList, ['.uni', '.inf'], Info.Name, CompatibleMode, ShellMode, UniGenCFlag, UniGenBinBuffer, FilterInfo)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenC.Append('\\n//\\n//Unicode String Pack Definition\\n//\\n')\n        AutoGenC.Append(Code)\n        AutoGenC.Append('\\n')\n    AutoGenH.Append('\\n//\\n//Unicode String ID\\n//\\n')\n    AutoGenH.Append(Header)\n    if CompatibleMode or UniGenCFlag:\n        AutoGenH.Append('\\n#define STRING_ARRAY_NAME %sStrings\\n' % Info.Name)\n    os.chdir(WorkingDir)"
        ]
    },
    {
        "func_name": "CreateIdfFileCode",
        "original": "def CreateIdfFileCode(Info, AutoGenC, StringH, IdfGenCFlag, IdfGenBinBuffer):\n    if len(Info.IdfFileList) > 0:\n        ImageFiles = IdfFileClassObject(sorted(Info.IdfFileList))\n        if ImageFiles.ImageFilesDict:\n            Index = 1\n            PaletteIndex = 1\n            IncList = [Info.MetaFile.Dir]\n            SrcList = [F for F in Info.SourceFileList]\n            SkipList = ['.jpg', '.png', '.bmp', '.inf', '.idf']\n            FileList = GetFileList(SrcList, IncList, SkipList)\n            ValueStartPtr = 60\n            StringH.Append('\\n//\\n//Image ID\\n//\\n')\n            ImageInfoOffset = 0\n            PaletteInfoOffset = 0\n            ImageBuffer = pack('x')\n            PaletteBuffer = pack('x')\n            BufferStr = ''\n            PaletteStr = ''\n            FileDict = {}\n            for Idf in ImageFiles.ImageFilesDict:\n                if ImageFiles.ImageFilesDict[Idf]:\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        for sourcefile in Info.SourceFileList:\n                            if FileObj.FileName == sourcefile.File:\n                                if not sourcefile.Ext.upper() in ['.PNG', '.BMP', '.JPG']:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"The %s's postfix must be one of .bmp, .jpg, .png\" % FileObj.FileName, ExtraData='[%s]' % str(Info))\n                                FileObj.File = sourcefile\n                                break\n                        else:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"The %s in %s is not defined in the driver's [Sources] section\" % (FileObj.FileName, Idf), ExtraData='[%s]' % str(Info))\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        ID = FileObj.ImageID\n                        File = FileObj.File\n                        try:\n                            SearchImageID(FileObj, FileList)\n                            if FileObj.Referenced:\n                                if ValueStartPtr - len(DEFINE_STR + ID) <= 0:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' + DecToHexStr(Index, 4) + '\\n'\n                                else:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' * (ValueStartPtr - len(DEFINE_STR + ID)) + DecToHexStr(Index, 4) + '\\n'\n                                if File not in FileDict:\n                                    FileDict[File] = Index\n                                else:\n                                    DuplicateBlock = pack('B', EFI_HII_IIBT_DUPLICATE)\n                                    DuplicateBlock += pack('H', FileDict[File])\n                                    ImageBuffer += DuplicateBlock\n                                    BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                    TempBufferList = AscToHexList(DuplicateBlock)\n                                    BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                    StringH.Append(Line)\n                                    Index += 1\n                                    continue\n                                TmpFile = open(File.Path, 'rb')\n                                Buffer = TmpFile.read()\n                                TmpFile.close()\n                                if File.Ext.upper() == '.PNG':\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_PNG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.JPG':\n                                    (ImageType,) = struct.unpack('4s', Buffer[6:10])\n                                    if ImageType != b'JFIF':\n                                        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard JPG file.' % File.Path)\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_JPEG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.BMP':\n                                    (TempBuffer, TempPalette) = BmpImageDecoder(File, Buffer, PaletteIndex, FileObj.TransParent)\n                                    if len(TempPalette) > 1:\n                                        PaletteIndex += 1\n                                        NewPalette = pack('H', len(TempPalette))\n                                        NewPalette += TempPalette\n                                        PaletteBuffer += NewPalette\n                                        PaletteStr = WriteLine(PaletteStr, '// %s: %s: %s' % (DecToHexStr(PaletteIndex - 1, 4), ID, DecToHexStr(PaletteIndex - 1, 4)))\n                                        TempPaletteList = AscToHexList(NewPalette)\n                                        PaletteStr = WriteLine(PaletteStr, CreateArrayItem(TempPaletteList, 16) + '\\n')\n                                ImageBuffer += TempBuffer\n                                BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                TempBufferList = AscToHexList(TempBuffer)\n                                BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                StringH.Append(Line)\n                                Index += 1\n                        except IOError:\n                            EdkLogger.error('build', FILE_NOT_FOUND, ExtraData=File.Path)\n            BufferStr = WriteLine(BufferStr, '// End of the Image Info')\n            BufferStr = WriteLine(BufferStr, CreateArrayItem(DecToHexList(EFI_HII_IIBT_END, 2)) + '\\n')\n            ImageEnd = pack('B', EFI_HII_IIBT_END)\n            ImageBuffer += ImageEnd\n            if len(ImageBuffer) > 1:\n                ImageInfoOffset = 12\n            if len(PaletteBuffer) > 1:\n                PaletteInfoOffset = 12 + len(ImageBuffer) - 1\n            IMAGE_PACKAGE_HDR = pack('=II', ImageInfoOffset, PaletteInfoOffset)\n            if len(PaletteBuffer) > 1:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1 + 2 + len(PaletteBuffer) - 1\n            else:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1\n            if PaletteIndex > 1:\n                PALETTE_INFO_HEADER = pack('H', PaletteIndex - 1)\n            Hex_Length = '%06X' % PACKAGE_HEADER_Length\n            if PACKAGE_HEADER_Length > 16777215:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'The Length of EFI_HII_PACKAGE_HEADER exceed its maximum value', ExtraData='[%s]' % str(Info))\n            PACKAGE_HEADER = pack('=HBB', int('0x' + Hex_Length[2:], 16), int('0x' + Hex_Length[0:2], 16), EFI_HII_PACKAGE_IMAGES)\n            IdfGenBinBuffer.write(PACKAGE_HEADER)\n            IdfGenBinBuffer.write(IMAGE_PACKAGE_HDR)\n            if len(ImageBuffer) > 1:\n                IdfGenBinBuffer.write(ImageBuffer[1:])\n            if PaletteIndex > 1:\n                IdfGenBinBuffer.write(PALETTE_INFO_HEADER)\n            if len(PaletteBuffer) > 1:\n                IdfGenBinBuffer.write(PaletteBuffer[1:])\n            if IdfGenCFlag:\n                TotalLength = EFI_HII_ARRAY_SIZE_LENGTH + PACKAGE_HEADER_Length\n                AutoGenC.Append('\\n//\\n//Image Pack Definition\\n//\\n')\n                AllStr = WriteLine('', CHAR_ARRAY_DEFIN + ' ' + Info.Module.BaseName + 'Images' + '[] = {\\n')\n                AllStr = WriteLine(AllStr, '// STRGATHER_OUTPUT_HEADER')\n                AllStr = WriteLine(AllStr, CreateArrayItem(DecToHexList(TotalLength)) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image PACKAGE HEADER\\n')\n                IMAGE_PACKAGE_HDR_List = AscToHexList(PACKAGE_HEADER)\n                IMAGE_PACKAGE_HDR_List += AscToHexList(IMAGE_PACKAGE_HDR)\n                AllStr = WriteLine(AllStr, CreateArrayItem(IMAGE_PACKAGE_HDR_List, 16) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image DATA\\n')\n                if BufferStr:\n                    AllStr = WriteLine(AllStr, BufferStr)\n                if PaletteStr:\n                    AllStr = WriteLine(AllStr, '// Palette Header\\n')\n                    PALETTE_INFO_HEADER_List = AscToHexList(PALETTE_INFO_HEADER)\n                    AllStr = WriteLine(AllStr, CreateArrayItem(PALETTE_INFO_HEADER_List, 16) + '\\n')\n                    AllStr = WriteLine(AllStr, '// Palette Data\\n')\n                    AllStr = WriteLine(AllStr, PaletteStr)\n                AllStr = WriteLine(AllStr, '};')\n                AutoGenC.Append(AllStr)\n                AutoGenC.Append('\\n')\n                StringH.Append('\\nextern unsigned char ' + Info.Module.BaseName + 'Images[];\\n')\n                StringH.Append('\\n#define IMAGE_ARRAY_NAME %sImages\\n' % Info.Module.BaseName)",
        "mutated": [
            "def CreateIdfFileCode(Info, AutoGenC, StringH, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n    if len(Info.IdfFileList) > 0:\n        ImageFiles = IdfFileClassObject(sorted(Info.IdfFileList))\n        if ImageFiles.ImageFilesDict:\n            Index = 1\n            PaletteIndex = 1\n            IncList = [Info.MetaFile.Dir]\n            SrcList = [F for F in Info.SourceFileList]\n            SkipList = ['.jpg', '.png', '.bmp', '.inf', '.idf']\n            FileList = GetFileList(SrcList, IncList, SkipList)\n            ValueStartPtr = 60\n            StringH.Append('\\n//\\n//Image ID\\n//\\n')\n            ImageInfoOffset = 0\n            PaletteInfoOffset = 0\n            ImageBuffer = pack('x')\n            PaletteBuffer = pack('x')\n            BufferStr = ''\n            PaletteStr = ''\n            FileDict = {}\n            for Idf in ImageFiles.ImageFilesDict:\n                if ImageFiles.ImageFilesDict[Idf]:\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        for sourcefile in Info.SourceFileList:\n                            if FileObj.FileName == sourcefile.File:\n                                if not sourcefile.Ext.upper() in ['.PNG', '.BMP', '.JPG']:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"The %s's postfix must be one of .bmp, .jpg, .png\" % FileObj.FileName, ExtraData='[%s]' % str(Info))\n                                FileObj.File = sourcefile\n                                break\n                        else:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"The %s in %s is not defined in the driver's [Sources] section\" % (FileObj.FileName, Idf), ExtraData='[%s]' % str(Info))\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        ID = FileObj.ImageID\n                        File = FileObj.File\n                        try:\n                            SearchImageID(FileObj, FileList)\n                            if FileObj.Referenced:\n                                if ValueStartPtr - len(DEFINE_STR + ID) <= 0:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' + DecToHexStr(Index, 4) + '\\n'\n                                else:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' * (ValueStartPtr - len(DEFINE_STR + ID)) + DecToHexStr(Index, 4) + '\\n'\n                                if File not in FileDict:\n                                    FileDict[File] = Index\n                                else:\n                                    DuplicateBlock = pack('B', EFI_HII_IIBT_DUPLICATE)\n                                    DuplicateBlock += pack('H', FileDict[File])\n                                    ImageBuffer += DuplicateBlock\n                                    BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                    TempBufferList = AscToHexList(DuplicateBlock)\n                                    BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                    StringH.Append(Line)\n                                    Index += 1\n                                    continue\n                                TmpFile = open(File.Path, 'rb')\n                                Buffer = TmpFile.read()\n                                TmpFile.close()\n                                if File.Ext.upper() == '.PNG':\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_PNG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.JPG':\n                                    (ImageType,) = struct.unpack('4s', Buffer[6:10])\n                                    if ImageType != b'JFIF':\n                                        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard JPG file.' % File.Path)\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_JPEG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.BMP':\n                                    (TempBuffer, TempPalette) = BmpImageDecoder(File, Buffer, PaletteIndex, FileObj.TransParent)\n                                    if len(TempPalette) > 1:\n                                        PaletteIndex += 1\n                                        NewPalette = pack('H', len(TempPalette))\n                                        NewPalette += TempPalette\n                                        PaletteBuffer += NewPalette\n                                        PaletteStr = WriteLine(PaletteStr, '// %s: %s: %s' % (DecToHexStr(PaletteIndex - 1, 4), ID, DecToHexStr(PaletteIndex - 1, 4)))\n                                        TempPaletteList = AscToHexList(NewPalette)\n                                        PaletteStr = WriteLine(PaletteStr, CreateArrayItem(TempPaletteList, 16) + '\\n')\n                                ImageBuffer += TempBuffer\n                                BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                TempBufferList = AscToHexList(TempBuffer)\n                                BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                StringH.Append(Line)\n                                Index += 1\n                        except IOError:\n                            EdkLogger.error('build', FILE_NOT_FOUND, ExtraData=File.Path)\n            BufferStr = WriteLine(BufferStr, '// End of the Image Info')\n            BufferStr = WriteLine(BufferStr, CreateArrayItem(DecToHexList(EFI_HII_IIBT_END, 2)) + '\\n')\n            ImageEnd = pack('B', EFI_HII_IIBT_END)\n            ImageBuffer += ImageEnd\n            if len(ImageBuffer) > 1:\n                ImageInfoOffset = 12\n            if len(PaletteBuffer) > 1:\n                PaletteInfoOffset = 12 + len(ImageBuffer) - 1\n            IMAGE_PACKAGE_HDR = pack('=II', ImageInfoOffset, PaletteInfoOffset)\n            if len(PaletteBuffer) > 1:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1 + 2 + len(PaletteBuffer) - 1\n            else:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1\n            if PaletteIndex > 1:\n                PALETTE_INFO_HEADER = pack('H', PaletteIndex - 1)\n            Hex_Length = '%06X' % PACKAGE_HEADER_Length\n            if PACKAGE_HEADER_Length > 16777215:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'The Length of EFI_HII_PACKAGE_HEADER exceed its maximum value', ExtraData='[%s]' % str(Info))\n            PACKAGE_HEADER = pack('=HBB', int('0x' + Hex_Length[2:], 16), int('0x' + Hex_Length[0:2], 16), EFI_HII_PACKAGE_IMAGES)\n            IdfGenBinBuffer.write(PACKAGE_HEADER)\n            IdfGenBinBuffer.write(IMAGE_PACKAGE_HDR)\n            if len(ImageBuffer) > 1:\n                IdfGenBinBuffer.write(ImageBuffer[1:])\n            if PaletteIndex > 1:\n                IdfGenBinBuffer.write(PALETTE_INFO_HEADER)\n            if len(PaletteBuffer) > 1:\n                IdfGenBinBuffer.write(PaletteBuffer[1:])\n            if IdfGenCFlag:\n                TotalLength = EFI_HII_ARRAY_SIZE_LENGTH + PACKAGE_HEADER_Length\n                AutoGenC.Append('\\n//\\n//Image Pack Definition\\n//\\n')\n                AllStr = WriteLine('', CHAR_ARRAY_DEFIN + ' ' + Info.Module.BaseName + 'Images' + '[] = {\\n')\n                AllStr = WriteLine(AllStr, '// STRGATHER_OUTPUT_HEADER')\n                AllStr = WriteLine(AllStr, CreateArrayItem(DecToHexList(TotalLength)) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image PACKAGE HEADER\\n')\n                IMAGE_PACKAGE_HDR_List = AscToHexList(PACKAGE_HEADER)\n                IMAGE_PACKAGE_HDR_List += AscToHexList(IMAGE_PACKAGE_HDR)\n                AllStr = WriteLine(AllStr, CreateArrayItem(IMAGE_PACKAGE_HDR_List, 16) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image DATA\\n')\n                if BufferStr:\n                    AllStr = WriteLine(AllStr, BufferStr)\n                if PaletteStr:\n                    AllStr = WriteLine(AllStr, '// Palette Header\\n')\n                    PALETTE_INFO_HEADER_List = AscToHexList(PALETTE_INFO_HEADER)\n                    AllStr = WriteLine(AllStr, CreateArrayItem(PALETTE_INFO_HEADER_List, 16) + '\\n')\n                    AllStr = WriteLine(AllStr, '// Palette Data\\n')\n                    AllStr = WriteLine(AllStr, PaletteStr)\n                AllStr = WriteLine(AllStr, '};')\n                AutoGenC.Append(AllStr)\n                AutoGenC.Append('\\n')\n                StringH.Append('\\nextern unsigned char ' + Info.Module.BaseName + 'Images[];\\n')\n                StringH.Append('\\n#define IMAGE_ARRAY_NAME %sImages\\n' % Info.Module.BaseName)",
            "def CreateIdfFileCode(Info, AutoGenC, StringH, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if len(Info.IdfFileList) > 0:\n        ImageFiles = IdfFileClassObject(sorted(Info.IdfFileList))\n        if ImageFiles.ImageFilesDict:\n            Index = 1\n            PaletteIndex = 1\n            IncList = [Info.MetaFile.Dir]\n            SrcList = [F for F in Info.SourceFileList]\n            SkipList = ['.jpg', '.png', '.bmp', '.inf', '.idf']\n            FileList = GetFileList(SrcList, IncList, SkipList)\n            ValueStartPtr = 60\n            StringH.Append('\\n//\\n//Image ID\\n//\\n')\n            ImageInfoOffset = 0\n            PaletteInfoOffset = 0\n            ImageBuffer = pack('x')\n            PaletteBuffer = pack('x')\n            BufferStr = ''\n            PaletteStr = ''\n            FileDict = {}\n            for Idf in ImageFiles.ImageFilesDict:\n                if ImageFiles.ImageFilesDict[Idf]:\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        for sourcefile in Info.SourceFileList:\n                            if FileObj.FileName == sourcefile.File:\n                                if not sourcefile.Ext.upper() in ['.PNG', '.BMP', '.JPG']:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"The %s's postfix must be one of .bmp, .jpg, .png\" % FileObj.FileName, ExtraData='[%s]' % str(Info))\n                                FileObj.File = sourcefile\n                                break\n                        else:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"The %s in %s is not defined in the driver's [Sources] section\" % (FileObj.FileName, Idf), ExtraData='[%s]' % str(Info))\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        ID = FileObj.ImageID\n                        File = FileObj.File\n                        try:\n                            SearchImageID(FileObj, FileList)\n                            if FileObj.Referenced:\n                                if ValueStartPtr - len(DEFINE_STR + ID) <= 0:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' + DecToHexStr(Index, 4) + '\\n'\n                                else:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' * (ValueStartPtr - len(DEFINE_STR + ID)) + DecToHexStr(Index, 4) + '\\n'\n                                if File not in FileDict:\n                                    FileDict[File] = Index\n                                else:\n                                    DuplicateBlock = pack('B', EFI_HII_IIBT_DUPLICATE)\n                                    DuplicateBlock += pack('H', FileDict[File])\n                                    ImageBuffer += DuplicateBlock\n                                    BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                    TempBufferList = AscToHexList(DuplicateBlock)\n                                    BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                    StringH.Append(Line)\n                                    Index += 1\n                                    continue\n                                TmpFile = open(File.Path, 'rb')\n                                Buffer = TmpFile.read()\n                                TmpFile.close()\n                                if File.Ext.upper() == '.PNG':\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_PNG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.JPG':\n                                    (ImageType,) = struct.unpack('4s', Buffer[6:10])\n                                    if ImageType != b'JFIF':\n                                        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard JPG file.' % File.Path)\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_JPEG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.BMP':\n                                    (TempBuffer, TempPalette) = BmpImageDecoder(File, Buffer, PaletteIndex, FileObj.TransParent)\n                                    if len(TempPalette) > 1:\n                                        PaletteIndex += 1\n                                        NewPalette = pack('H', len(TempPalette))\n                                        NewPalette += TempPalette\n                                        PaletteBuffer += NewPalette\n                                        PaletteStr = WriteLine(PaletteStr, '// %s: %s: %s' % (DecToHexStr(PaletteIndex - 1, 4), ID, DecToHexStr(PaletteIndex - 1, 4)))\n                                        TempPaletteList = AscToHexList(NewPalette)\n                                        PaletteStr = WriteLine(PaletteStr, CreateArrayItem(TempPaletteList, 16) + '\\n')\n                                ImageBuffer += TempBuffer\n                                BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                TempBufferList = AscToHexList(TempBuffer)\n                                BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                StringH.Append(Line)\n                                Index += 1\n                        except IOError:\n                            EdkLogger.error('build', FILE_NOT_FOUND, ExtraData=File.Path)\n            BufferStr = WriteLine(BufferStr, '// End of the Image Info')\n            BufferStr = WriteLine(BufferStr, CreateArrayItem(DecToHexList(EFI_HII_IIBT_END, 2)) + '\\n')\n            ImageEnd = pack('B', EFI_HII_IIBT_END)\n            ImageBuffer += ImageEnd\n            if len(ImageBuffer) > 1:\n                ImageInfoOffset = 12\n            if len(PaletteBuffer) > 1:\n                PaletteInfoOffset = 12 + len(ImageBuffer) - 1\n            IMAGE_PACKAGE_HDR = pack('=II', ImageInfoOffset, PaletteInfoOffset)\n            if len(PaletteBuffer) > 1:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1 + 2 + len(PaletteBuffer) - 1\n            else:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1\n            if PaletteIndex > 1:\n                PALETTE_INFO_HEADER = pack('H', PaletteIndex - 1)\n            Hex_Length = '%06X' % PACKAGE_HEADER_Length\n            if PACKAGE_HEADER_Length > 16777215:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'The Length of EFI_HII_PACKAGE_HEADER exceed its maximum value', ExtraData='[%s]' % str(Info))\n            PACKAGE_HEADER = pack('=HBB', int('0x' + Hex_Length[2:], 16), int('0x' + Hex_Length[0:2], 16), EFI_HII_PACKAGE_IMAGES)\n            IdfGenBinBuffer.write(PACKAGE_HEADER)\n            IdfGenBinBuffer.write(IMAGE_PACKAGE_HDR)\n            if len(ImageBuffer) > 1:\n                IdfGenBinBuffer.write(ImageBuffer[1:])\n            if PaletteIndex > 1:\n                IdfGenBinBuffer.write(PALETTE_INFO_HEADER)\n            if len(PaletteBuffer) > 1:\n                IdfGenBinBuffer.write(PaletteBuffer[1:])\n            if IdfGenCFlag:\n                TotalLength = EFI_HII_ARRAY_SIZE_LENGTH + PACKAGE_HEADER_Length\n                AutoGenC.Append('\\n//\\n//Image Pack Definition\\n//\\n')\n                AllStr = WriteLine('', CHAR_ARRAY_DEFIN + ' ' + Info.Module.BaseName + 'Images' + '[] = {\\n')\n                AllStr = WriteLine(AllStr, '// STRGATHER_OUTPUT_HEADER')\n                AllStr = WriteLine(AllStr, CreateArrayItem(DecToHexList(TotalLength)) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image PACKAGE HEADER\\n')\n                IMAGE_PACKAGE_HDR_List = AscToHexList(PACKAGE_HEADER)\n                IMAGE_PACKAGE_HDR_List += AscToHexList(IMAGE_PACKAGE_HDR)\n                AllStr = WriteLine(AllStr, CreateArrayItem(IMAGE_PACKAGE_HDR_List, 16) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image DATA\\n')\n                if BufferStr:\n                    AllStr = WriteLine(AllStr, BufferStr)\n                if PaletteStr:\n                    AllStr = WriteLine(AllStr, '// Palette Header\\n')\n                    PALETTE_INFO_HEADER_List = AscToHexList(PALETTE_INFO_HEADER)\n                    AllStr = WriteLine(AllStr, CreateArrayItem(PALETTE_INFO_HEADER_List, 16) + '\\n')\n                    AllStr = WriteLine(AllStr, '// Palette Data\\n')\n                    AllStr = WriteLine(AllStr, PaletteStr)\n                AllStr = WriteLine(AllStr, '};')\n                AutoGenC.Append(AllStr)\n                AutoGenC.Append('\\n')\n                StringH.Append('\\nextern unsigned char ' + Info.Module.BaseName + 'Images[];\\n')\n                StringH.Append('\\n#define IMAGE_ARRAY_NAME %sImages\\n' % Info.Module.BaseName)",
            "def CreateIdfFileCode(Info, AutoGenC, StringH, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if len(Info.IdfFileList) > 0:\n        ImageFiles = IdfFileClassObject(sorted(Info.IdfFileList))\n        if ImageFiles.ImageFilesDict:\n            Index = 1\n            PaletteIndex = 1\n            IncList = [Info.MetaFile.Dir]\n            SrcList = [F for F in Info.SourceFileList]\n            SkipList = ['.jpg', '.png', '.bmp', '.inf', '.idf']\n            FileList = GetFileList(SrcList, IncList, SkipList)\n            ValueStartPtr = 60\n            StringH.Append('\\n//\\n//Image ID\\n//\\n')\n            ImageInfoOffset = 0\n            PaletteInfoOffset = 0\n            ImageBuffer = pack('x')\n            PaletteBuffer = pack('x')\n            BufferStr = ''\n            PaletteStr = ''\n            FileDict = {}\n            for Idf in ImageFiles.ImageFilesDict:\n                if ImageFiles.ImageFilesDict[Idf]:\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        for sourcefile in Info.SourceFileList:\n                            if FileObj.FileName == sourcefile.File:\n                                if not sourcefile.Ext.upper() in ['.PNG', '.BMP', '.JPG']:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"The %s's postfix must be one of .bmp, .jpg, .png\" % FileObj.FileName, ExtraData='[%s]' % str(Info))\n                                FileObj.File = sourcefile\n                                break\n                        else:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"The %s in %s is not defined in the driver's [Sources] section\" % (FileObj.FileName, Idf), ExtraData='[%s]' % str(Info))\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        ID = FileObj.ImageID\n                        File = FileObj.File\n                        try:\n                            SearchImageID(FileObj, FileList)\n                            if FileObj.Referenced:\n                                if ValueStartPtr - len(DEFINE_STR + ID) <= 0:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' + DecToHexStr(Index, 4) + '\\n'\n                                else:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' * (ValueStartPtr - len(DEFINE_STR + ID)) + DecToHexStr(Index, 4) + '\\n'\n                                if File not in FileDict:\n                                    FileDict[File] = Index\n                                else:\n                                    DuplicateBlock = pack('B', EFI_HII_IIBT_DUPLICATE)\n                                    DuplicateBlock += pack('H', FileDict[File])\n                                    ImageBuffer += DuplicateBlock\n                                    BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                    TempBufferList = AscToHexList(DuplicateBlock)\n                                    BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                    StringH.Append(Line)\n                                    Index += 1\n                                    continue\n                                TmpFile = open(File.Path, 'rb')\n                                Buffer = TmpFile.read()\n                                TmpFile.close()\n                                if File.Ext.upper() == '.PNG':\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_PNG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.JPG':\n                                    (ImageType,) = struct.unpack('4s', Buffer[6:10])\n                                    if ImageType != b'JFIF':\n                                        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard JPG file.' % File.Path)\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_JPEG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.BMP':\n                                    (TempBuffer, TempPalette) = BmpImageDecoder(File, Buffer, PaletteIndex, FileObj.TransParent)\n                                    if len(TempPalette) > 1:\n                                        PaletteIndex += 1\n                                        NewPalette = pack('H', len(TempPalette))\n                                        NewPalette += TempPalette\n                                        PaletteBuffer += NewPalette\n                                        PaletteStr = WriteLine(PaletteStr, '// %s: %s: %s' % (DecToHexStr(PaletteIndex - 1, 4), ID, DecToHexStr(PaletteIndex - 1, 4)))\n                                        TempPaletteList = AscToHexList(NewPalette)\n                                        PaletteStr = WriteLine(PaletteStr, CreateArrayItem(TempPaletteList, 16) + '\\n')\n                                ImageBuffer += TempBuffer\n                                BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                TempBufferList = AscToHexList(TempBuffer)\n                                BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                StringH.Append(Line)\n                                Index += 1\n                        except IOError:\n                            EdkLogger.error('build', FILE_NOT_FOUND, ExtraData=File.Path)\n            BufferStr = WriteLine(BufferStr, '// End of the Image Info')\n            BufferStr = WriteLine(BufferStr, CreateArrayItem(DecToHexList(EFI_HII_IIBT_END, 2)) + '\\n')\n            ImageEnd = pack('B', EFI_HII_IIBT_END)\n            ImageBuffer += ImageEnd\n            if len(ImageBuffer) > 1:\n                ImageInfoOffset = 12\n            if len(PaletteBuffer) > 1:\n                PaletteInfoOffset = 12 + len(ImageBuffer) - 1\n            IMAGE_PACKAGE_HDR = pack('=II', ImageInfoOffset, PaletteInfoOffset)\n            if len(PaletteBuffer) > 1:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1 + 2 + len(PaletteBuffer) - 1\n            else:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1\n            if PaletteIndex > 1:\n                PALETTE_INFO_HEADER = pack('H', PaletteIndex - 1)\n            Hex_Length = '%06X' % PACKAGE_HEADER_Length\n            if PACKAGE_HEADER_Length > 16777215:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'The Length of EFI_HII_PACKAGE_HEADER exceed its maximum value', ExtraData='[%s]' % str(Info))\n            PACKAGE_HEADER = pack('=HBB', int('0x' + Hex_Length[2:], 16), int('0x' + Hex_Length[0:2], 16), EFI_HII_PACKAGE_IMAGES)\n            IdfGenBinBuffer.write(PACKAGE_HEADER)\n            IdfGenBinBuffer.write(IMAGE_PACKAGE_HDR)\n            if len(ImageBuffer) > 1:\n                IdfGenBinBuffer.write(ImageBuffer[1:])\n            if PaletteIndex > 1:\n                IdfGenBinBuffer.write(PALETTE_INFO_HEADER)\n            if len(PaletteBuffer) > 1:\n                IdfGenBinBuffer.write(PaletteBuffer[1:])\n            if IdfGenCFlag:\n                TotalLength = EFI_HII_ARRAY_SIZE_LENGTH + PACKAGE_HEADER_Length\n                AutoGenC.Append('\\n//\\n//Image Pack Definition\\n//\\n')\n                AllStr = WriteLine('', CHAR_ARRAY_DEFIN + ' ' + Info.Module.BaseName + 'Images' + '[] = {\\n')\n                AllStr = WriteLine(AllStr, '// STRGATHER_OUTPUT_HEADER')\n                AllStr = WriteLine(AllStr, CreateArrayItem(DecToHexList(TotalLength)) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image PACKAGE HEADER\\n')\n                IMAGE_PACKAGE_HDR_List = AscToHexList(PACKAGE_HEADER)\n                IMAGE_PACKAGE_HDR_List += AscToHexList(IMAGE_PACKAGE_HDR)\n                AllStr = WriteLine(AllStr, CreateArrayItem(IMAGE_PACKAGE_HDR_List, 16) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image DATA\\n')\n                if BufferStr:\n                    AllStr = WriteLine(AllStr, BufferStr)\n                if PaletteStr:\n                    AllStr = WriteLine(AllStr, '// Palette Header\\n')\n                    PALETTE_INFO_HEADER_List = AscToHexList(PALETTE_INFO_HEADER)\n                    AllStr = WriteLine(AllStr, CreateArrayItem(PALETTE_INFO_HEADER_List, 16) + '\\n')\n                    AllStr = WriteLine(AllStr, '// Palette Data\\n')\n                    AllStr = WriteLine(AllStr, PaletteStr)\n                AllStr = WriteLine(AllStr, '};')\n                AutoGenC.Append(AllStr)\n                AutoGenC.Append('\\n')\n                StringH.Append('\\nextern unsigned char ' + Info.Module.BaseName + 'Images[];\\n')\n                StringH.Append('\\n#define IMAGE_ARRAY_NAME %sImages\\n' % Info.Module.BaseName)",
            "def CreateIdfFileCode(Info, AutoGenC, StringH, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if len(Info.IdfFileList) > 0:\n        ImageFiles = IdfFileClassObject(sorted(Info.IdfFileList))\n        if ImageFiles.ImageFilesDict:\n            Index = 1\n            PaletteIndex = 1\n            IncList = [Info.MetaFile.Dir]\n            SrcList = [F for F in Info.SourceFileList]\n            SkipList = ['.jpg', '.png', '.bmp', '.inf', '.idf']\n            FileList = GetFileList(SrcList, IncList, SkipList)\n            ValueStartPtr = 60\n            StringH.Append('\\n//\\n//Image ID\\n//\\n')\n            ImageInfoOffset = 0\n            PaletteInfoOffset = 0\n            ImageBuffer = pack('x')\n            PaletteBuffer = pack('x')\n            BufferStr = ''\n            PaletteStr = ''\n            FileDict = {}\n            for Idf in ImageFiles.ImageFilesDict:\n                if ImageFiles.ImageFilesDict[Idf]:\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        for sourcefile in Info.SourceFileList:\n                            if FileObj.FileName == sourcefile.File:\n                                if not sourcefile.Ext.upper() in ['.PNG', '.BMP', '.JPG']:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"The %s's postfix must be one of .bmp, .jpg, .png\" % FileObj.FileName, ExtraData='[%s]' % str(Info))\n                                FileObj.File = sourcefile\n                                break\n                        else:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"The %s in %s is not defined in the driver's [Sources] section\" % (FileObj.FileName, Idf), ExtraData='[%s]' % str(Info))\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        ID = FileObj.ImageID\n                        File = FileObj.File\n                        try:\n                            SearchImageID(FileObj, FileList)\n                            if FileObj.Referenced:\n                                if ValueStartPtr - len(DEFINE_STR + ID) <= 0:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' + DecToHexStr(Index, 4) + '\\n'\n                                else:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' * (ValueStartPtr - len(DEFINE_STR + ID)) + DecToHexStr(Index, 4) + '\\n'\n                                if File not in FileDict:\n                                    FileDict[File] = Index\n                                else:\n                                    DuplicateBlock = pack('B', EFI_HII_IIBT_DUPLICATE)\n                                    DuplicateBlock += pack('H', FileDict[File])\n                                    ImageBuffer += DuplicateBlock\n                                    BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                    TempBufferList = AscToHexList(DuplicateBlock)\n                                    BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                    StringH.Append(Line)\n                                    Index += 1\n                                    continue\n                                TmpFile = open(File.Path, 'rb')\n                                Buffer = TmpFile.read()\n                                TmpFile.close()\n                                if File.Ext.upper() == '.PNG':\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_PNG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.JPG':\n                                    (ImageType,) = struct.unpack('4s', Buffer[6:10])\n                                    if ImageType != b'JFIF':\n                                        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard JPG file.' % File.Path)\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_JPEG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.BMP':\n                                    (TempBuffer, TempPalette) = BmpImageDecoder(File, Buffer, PaletteIndex, FileObj.TransParent)\n                                    if len(TempPalette) > 1:\n                                        PaletteIndex += 1\n                                        NewPalette = pack('H', len(TempPalette))\n                                        NewPalette += TempPalette\n                                        PaletteBuffer += NewPalette\n                                        PaletteStr = WriteLine(PaletteStr, '// %s: %s: %s' % (DecToHexStr(PaletteIndex - 1, 4), ID, DecToHexStr(PaletteIndex - 1, 4)))\n                                        TempPaletteList = AscToHexList(NewPalette)\n                                        PaletteStr = WriteLine(PaletteStr, CreateArrayItem(TempPaletteList, 16) + '\\n')\n                                ImageBuffer += TempBuffer\n                                BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                TempBufferList = AscToHexList(TempBuffer)\n                                BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                StringH.Append(Line)\n                                Index += 1\n                        except IOError:\n                            EdkLogger.error('build', FILE_NOT_FOUND, ExtraData=File.Path)\n            BufferStr = WriteLine(BufferStr, '// End of the Image Info')\n            BufferStr = WriteLine(BufferStr, CreateArrayItem(DecToHexList(EFI_HII_IIBT_END, 2)) + '\\n')\n            ImageEnd = pack('B', EFI_HII_IIBT_END)\n            ImageBuffer += ImageEnd\n            if len(ImageBuffer) > 1:\n                ImageInfoOffset = 12\n            if len(PaletteBuffer) > 1:\n                PaletteInfoOffset = 12 + len(ImageBuffer) - 1\n            IMAGE_PACKAGE_HDR = pack('=II', ImageInfoOffset, PaletteInfoOffset)\n            if len(PaletteBuffer) > 1:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1 + 2 + len(PaletteBuffer) - 1\n            else:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1\n            if PaletteIndex > 1:\n                PALETTE_INFO_HEADER = pack('H', PaletteIndex - 1)\n            Hex_Length = '%06X' % PACKAGE_HEADER_Length\n            if PACKAGE_HEADER_Length > 16777215:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'The Length of EFI_HII_PACKAGE_HEADER exceed its maximum value', ExtraData='[%s]' % str(Info))\n            PACKAGE_HEADER = pack('=HBB', int('0x' + Hex_Length[2:], 16), int('0x' + Hex_Length[0:2], 16), EFI_HII_PACKAGE_IMAGES)\n            IdfGenBinBuffer.write(PACKAGE_HEADER)\n            IdfGenBinBuffer.write(IMAGE_PACKAGE_HDR)\n            if len(ImageBuffer) > 1:\n                IdfGenBinBuffer.write(ImageBuffer[1:])\n            if PaletteIndex > 1:\n                IdfGenBinBuffer.write(PALETTE_INFO_HEADER)\n            if len(PaletteBuffer) > 1:\n                IdfGenBinBuffer.write(PaletteBuffer[1:])\n            if IdfGenCFlag:\n                TotalLength = EFI_HII_ARRAY_SIZE_LENGTH + PACKAGE_HEADER_Length\n                AutoGenC.Append('\\n//\\n//Image Pack Definition\\n//\\n')\n                AllStr = WriteLine('', CHAR_ARRAY_DEFIN + ' ' + Info.Module.BaseName + 'Images' + '[] = {\\n')\n                AllStr = WriteLine(AllStr, '// STRGATHER_OUTPUT_HEADER')\n                AllStr = WriteLine(AllStr, CreateArrayItem(DecToHexList(TotalLength)) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image PACKAGE HEADER\\n')\n                IMAGE_PACKAGE_HDR_List = AscToHexList(PACKAGE_HEADER)\n                IMAGE_PACKAGE_HDR_List += AscToHexList(IMAGE_PACKAGE_HDR)\n                AllStr = WriteLine(AllStr, CreateArrayItem(IMAGE_PACKAGE_HDR_List, 16) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image DATA\\n')\n                if BufferStr:\n                    AllStr = WriteLine(AllStr, BufferStr)\n                if PaletteStr:\n                    AllStr = WriteLine(AllStr, '// Palette Header\\n')\n                    PALETTE_INFO_HEADER_List = AscToHexList(PALETTE_INFO_HEADER)\n                    AllStr = WriteLine(AllStr, CreateArrayItem(PALETTE_INFO_HEADER_List, 16) + '\\n')\n                    AllStr = WriteLine(AllStr, '// Palette Data\\n')\n                    AllStr = WriteLine(AllStr, PaletteStr)\n                AllStr = WriteLine(AllStr, '};')\n                AutoGenC.Append(AllStr)\n                AutoGenC.Append('\\n')\n                StringH.Append('\\nextern unsigned char ' + Info.Module.BaseName + 'Images[];\\n')\n                StringH.Append('\\n#define IMAGE_ARRAY_NAME %sImages\\n' % Info.Module.BaseName)",
            "def CreateIdfFileCode(Info, AutoGenC, StringH, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if len(Info.IdfFileList) > 0:\n        ImageFiles = IdfFileClassObject(sorted(Info.IdfFileList))\n        if ImageFiles.ImageFilesDict:\n            Index = 1\n            PaletteIndex = 1\n            IncList = [Info.MetaFile.Dir]\n            SrcList = [F for F in Info.SourceFileList]\n            SkipList = ['.jpg', '.png', '.bmp', '.inf', '.idf']\n            FileList = GetFileList(SrcList, IncList, SkipList)\n            ValueStartPtr = 60\n            StringH.Append('\\n//\\n//Image ID\\n//\\n')\n            ImageInfoOffset = 0\n            PaletteInfoOffset = 0\n            ImageBuffer = pack('x')\n            PaletteBuffer = pack('x')\n            BufferStr = ''\n            PaletteStr = ''\n            FileDict = {}\n            for Idf in ImageFiles.ImageFilesDict:\n                if ImageFiles.ImageFilesDict[Idf]:\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        for sourcefile in Info.SourceFileList:\n                            if FileObj.FileName == sourcefile.File:\n                                if not sourcefile.Ext.upper() in ['.PNG', '.BMP', '.JPG']:\n                                    EdkLogger.error('build', AUTOGEN_ERROR, \"The %s's postfix must be one of .bmp, .jpg, .png\" % FileObj.FileName, ExtraData='[%s]' % str(Info))\n                                FileObj.File = sourcefile\n                                break\n                        else:\n                            EdkLogger.error('build', AUTOGEN_ERROR, \"The %s in %s is not defined in the driver's [Sources] section\" % (FileObj.FileName, Idf), ExtraData='[%s]' % str(Info))\n                    for FileObj in ImageFiles.ImageFilesDict[Idf]:\n                        ID = FileObj.ImageID\n                        File = FileObj.File\n                        try:\n                            SearchImageID(FileObj, FileList)\n                            if FileObj.Referenced:\n                                if ValueStartPtr - len(DEFINE_STR + ID) <= 0:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' + DecToHexStr(Index, 4) + '\\n'\n                                else:\n                                    Line = DEFINE_STR + ' ' + ID + ' ' * (ValueStartPtr - len(DEFINE_STR + ID)) + DecToHexStr(Index, 4) + '\\n'\n                                if File not in FileDict:\n                                    FileDict[File] = Index\n                                else:\n                                    DuplicateBlock = pack('B', EFI_HII_IIBT_DUPLICATE)\n                                    DuplicateBlock += pack('H', FileDict[File])\n                                    ImageBuffer += DuplicateBlock\n                                    BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                    TempBufferList = AscToHexList(DuplicateBlock)\n                                    BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                    StringH.Append(Line)\n                                    Index += 1\n                                    continue\n                                TmpFile = open(File.Path, 'rb')\n                                Buffer = TmpFile.read()\n                                TmpFile.close()\n                                if File.Ext.upper() == '.PNG':\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_PNG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.JPG':\n                                    (ImageType,) = struct.unpack('4s', Buffer[6:10])\n                                    if ImageType != b'JFIF':\n                                        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard JPG file.' % File.Path)\n                                    TempBuffer = pack('B', EFI_HII_IIBT_IMAGE_JPEG)\n                                    TempBuffer += pack('I', len(Buffer))\n                                    TempBuffer += Buffer\n                                elif File.Ext.upper() == '.BMP':\n                                    (TempBuffer, TempPalette) = BmpImageDecoder(File, Buffer, PaletteIndex, FileObj.TransParent)\n                                    if len(TempPalette) > 1:\n                                        PaletteIndex += 1\n                                        NewPalette = pack('H', len(TempPalette))\n                                        NewPalette += TempPalette\n                                        PaletteBuffer += NewPalette\n                                        PaletteStr = WriteLine(PaletteStr, '// %s: %s: %s' % (DecToHexStr(PaletteIndex - 1, 4), ID, DecToHexStr(PaletteIndex - 1, 4)))\n                                        TempPaletteList = AscToHexList(NewPalette)\n                                        PaletteStr = WriteLine(PaletteStr, CreateArrayItem(TempPaletteList, 16) + '\\n')\n                                ImageBuffer += TempBuffer\n                                BufferStr = WriteLine(BufferStr, '// %s: %s: %s' % (DecToHexStr(Index, 4), ID, DecToHexStr(Index, 4)))\n                                TempBufferList = AscToHexList(TempBuffer)\n                                BufferStr = WriteLine(BufferStr, CreateArrayItem(TempBufferList, 16) + '\\n')\n                                StringH.Append(Line)\n                                Index += 1\n                        except IOError:\n                            EdkLogger.error('build', FILE_NOT_FOUND, ExtraData=File.Path)\n            BufferStr = WriteLine(BufferStr, '// End of the Image Info')\n            BufferStr = WriteLine(BufferStr, CreateArrayItem(DecToHexList(EFI_HII_IIBT_END, 2)) + '\\n')\n            ImageEnd = pack('B', EFI_HII_IIBT_END)\n            ImageBuffer += ImageEnd\n            if len(ImageBuffer) > 1:\n                ImageInfoOffset = 12\n            if len(PaletteBuffer) > 1:\n                PaletteInfoOffset = 12 + len(ImageBuffer) - 1\n            IMAGE_PACKAGE_HDR = pack('=II', ImageInfoOffset, PaletteInfoOffset)\n            if len(PaletteBuffer) > 1:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1 + 2 + len(PaletteBuffer) - 1\n            else:\n                PACKAGE_HEADER_Length = 4 + 4 + 4 + len(ImageBuffer) - 1\n            if PaletteIndex > 1:\n                PALETTE_INFO_HEADER = pack('H', PaletteIndex - 1)\n            Hex_Length = '%06X' % PACKAGE_HEADER_Length\n            if PACKAGE_HEADER_Length > 16777215:\n                EdkLogger.error('build', AUTOGEN_ERROR, 'The Length of EFI_HII_PACKAGE_HEADER exceed its maximum value', ExtraData='[%s]' % str(Info))\n            PACKAGE_HEADER = pack('=HBB', int('0x' + Hex_Length[2:], 16), int('0x' + Hex_Length[0:2], 16), EFI_HII_PACKAGE_IMAGES)\n            IdfGenBinBuffer.write(PACKAGE_HEADER)\n            IdfGenBinBuffer.write(IMAGE_PACKAGE_HDR)\n            if len(ImageBuffer) > 1:\n                IdfGenBinBuffer.write(ImageBuffer[1:])\n            if PaletteIndex > 1:\n                IdfGenBinBuffer.write(PALETTE_INFO_HEADER)\n            if len(PaletteBuffer) > 1:\n                IdfGenBinBuffer.write(PaletteBuffer[1:])\n            if IdfGenCFlag:\n                TotalLength = EFI_HII_ARRAY_SIZE_LENGTH + PACKAGE_HEADER_Length\n                AutoGenC.Append('\\n//\\n//Image Pack Definition\\n//\\n')\n                AllStr = WriteLine('', CHAR_ARRAY_DEFIN + ' ' + Info.Module.BaseName + 'Images' + '[] = {\\n')\n                AllStr = WriteLine(AllStr, '// STRGATHER_OUTPUT_HEADER')\n                AllStr = WriteLine(AllStr, CreateArrayItem(DecToHexList(TotalLength)) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image PACKAGE HEADER\\n')\n                IMAGE_PACKAGE_HDR_List = AscToHexList(PACKAGE_HEADER)\n                IMAGE_PACKAGE_HDR_List += AscToHexList(IMAGE_PACKAGE_HDR)\n                AllStr = WriteLine(AllStr, CreateArrayItem(IMAGE_PACKAGE_HDR_List, 16) + '\\n')\n                AllStr = WriteLine(AllStr, '// Image DATA\\n')\n                if BufferStr:\n                    AllStr = WriteLine(AllStr, BufferStr)\n                if PaletteStr:\n                    AllStr = WriteLine(AllStr, '// Palette Header\\n')\n                    PALETTE_INFO_HEADER_List = AscToHexList(PALETTE_INFO_HEADER)\n                    AllStr = WriteLine(AllStr, CreateArrayItem(PALETTE_INFO_HEADER_List, 16) + '\\n')\n                    AllStr = WriteLine(AllStr, '// Palette Data\\n')\n                    AllStr = WriteLine(AllStr, PaletteStr)\n                AllStr = WriteLine(AllStr, '};')\n                AutoGenC.Append(AllStr)\n                AutoGenC.Append('\\n')\n                StringH.Append('\\nextern unsigned char ' + Info.Module.BaseName + 'Images[];\\n')\n                StringH.Append('\\n#define IMAGE_ARRAY_NAME %sImages\\n' % Info.Module.BaseName)"
        ]
    },
    {
        "func_name": "BmpImageDecoder",
        "original": "def BmpImageDecoder(File, Buffer, PaletteIndex, TransParent):\n    (ImageType,) = struct.unpack('2s', Buffer[0:2])\n    if ImageType != b'BM':\n        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard BMP file.' % File.Path)\n    BMP_IMAGE_HEADER = collections.namedtuple('BMP_IMAGE_HEADER', ['bfSize', 'bfReserved1', 'bfReserved2', 'bfOffBits', 'biSize', 'biWidth', 'biHeight', 'biPlanes', 'biBitCount', 'biCompression', 'biSizeImage', 'biXPelsPerMeter', 'biYPelsPerMeter', 'biClrUsed', 'biClrImportant'])\n    BMP_IMAGE_HEADER_STRUCT = struct.Struct('IHHIIIIHHIIIIII')\n    BmpHeader = BMP_IMAGE_HEADER._make(BMP_IMAGE_HEADER_STRUCT.unpack_from(Buffer[2:]))\n    if BmpHeader.biCompression != 0:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The compress BMP file %s is not support.' % File.Path)\n    if BmpHeader.biWidth > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Width is exceed 0xFFFF.' % File.Path)\n    if BmpHeader.biHeight > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Height is exceed 0xFFFF.' % File.Path)\n    PaletteBuffer = pack('x')\n    if BmpHeader.biBitCount == 1:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 7) // 8\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 4:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 1) // 2\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 8:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = BmpHeader.biWidth\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 24:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT)\n        Width = BmpHeader.biWidth * 3\n    else:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'Only support the 1 bit, 4 bit, 8bit, 24 bit BMP files.', ExtraData='[%s]' % str(File.Path))\n    ImageBuffer += pack('H', BmpHeader.biWidth)\n    ImageBuffer += pack('H', BmpHeader.biHeight)\n    Start = BmpHeader.bfOffBits\n    End = BmpHeader.bfSize - 1\n    for Height in range(0, BmpHeader.biHeight):\n        if Width % 4 != 0:\n            Start = End + Width % 4 - 4 - Width\n        else:\n            Start = End - Width\n        ImageBuffer += Buffer[Start + 1:Start + Width + 1]\n        End = Start\n    if PaletteBuffer and len(PaletteBuffer) > 1:\n        PaletteTemp = pack('x')\n        for Index in range(0, len(PaletteBuffer)):\n            if Index % 4 == 3:\n                continue\n            PaletteTemp += PaletteBuffer[Index:Index + 1]\n        PaletteBuffer = PaletteTemp[1:]\n    return (ImageBuffer, PaletteBuffer)",
        "mutated": [
            "def BmpImageDecoder(File, Buffer, PaletteIndex, TransParent):\n    if False:\n        i = 10\n    (ImageType,) = struct.unpack('2s', Buffer[0:2])\n    if ImageType != b'BM':\n        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard BMP file.' % File.Path)\n    BMP_IMAGE_HEADER = collections.namedtuple('BMP_IMAGE_HEADER', ['bfSize', 'bfReserved1', 'bfReserved2', 'bfOffBits', 'biSize', 'biWidth', 'biHeight', 'biPlanes', 'biBitCount', 'biCompression', 'biSizeImage', 'biXPelsPerMeter', 'biYPelsPerMeter', 'biClrUsed', 'biClrImportant'])\n    BMP_IMAGE_HEADER_STRUCT = struct.Struct('IHHIIIIHHIIIIII')\n    BmpHeader = BMP_IMAGE_HEADER._make(BMP_IMAGE_HEADER_STRUCT.unpack_from(Buffer[2:]))\n    if BmpHeader.biCompression != 0:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The compress BMP file %s is not support.' % File.Path)\n    if BmpHeader.biWidth > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Width is exceed 0xFFFF.' % File.Path)\n    if BmpHeader.biHeight > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Height is exceed 0xFFFF.' % File.Path)\n    PaletteBuffer = pack('x')\n    if BmpHeader.biBitCount == 1:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 7) // 8\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 4:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 1) // 2\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 8:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = BmpHeader.biWidth\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 24:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT)\n        Width = BmpHeader.biWidth * 3\n    else:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'Only support the 1 bit, 4 bit, 8bit, 24 bit BMP files.', ExtraData='[%s]' % str(File.Path))\n    ImageBuffer += pack('H', BmpHeader.biWidth)\n    ImageBuffer += pack('H', BmpHeader.biHeight)\n    Start = BmpHeader.bfOffBits\n    End = BmpHeader.bfSize - 1\n    for Height in range(0, BmpHeader.biHeight):\n        if Width % 4 != 0:\n            Start = End + Width % 4 - 4 - Width\n        else:\n            Start = End - Width\n        ImageBuffer += Buffer[Start + 1:Start + Width + 1]\n        End = Start\n    if PaletteBuffer and len(PaletteBuffer) > 1:\n        PaletteTemp = pack('x')\n        for Index in range(0, len(PaletteBuffer)):\n            if Index % 4 == 3:\n                continue\n            PaletteTemp += PaletteBuffer[Index:Index + 1]\n        PaletteBuffer = PaletteTemp[1:]\n    return (ImageBuffer, PaletteBuffer)",
            "def BmpImageDecoder(File, Buffer, PaletteIndex, TransParent):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (ImageType,) = struct.unpack('2s', Buffer[0:2])\n    if ImageType != b'BM':\n        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard BMP file.' % File.Path)\n    BMP_IMAGE_HEADER = collections.namedtuple('BMP_IMAGE_HEADER', ['bfSize', 'bfReserved1', 'bfReserved2', 'bfOffBits', 'biSize', 'biWidth', 'biHeight', 'biPlanes', 'biBitCount', 'biCompression', 'biSizeImage', 'biXPelsPerMeter', 'biYPelsPerMeter', 'biClrUsed', 'biClrImportant'])\n    BMP_IMAGE_HEADER_STRUCT = struct.Struct('IHHIIIIHHIIIIII')\n    BmpHeader = BMP_IMAGE_HEADER._make(BMP_IMAGE_HEADER_STRUCT.unpack_from(Buffer[2:]))\n    if BmpHeader.biCompression != 0:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The compress BMP file %s is not support.' % File.Path)\n    if BmpHeader.biWidth > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Width is exceed 0xFFFF.' % File.Path)\n    if BmpHeader.biHeight > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Height is exceed 0xFFFF.' % File.Path)\n    PaletteBuffer = pack('x')\n    if BmpHeader.biBitCount == 1:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 7) // 8\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 4:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 1) // 2\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 8:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = BmpHeader.biWidth\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 24:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT)\n        Width = BmpHeader.biWidth * 3\n    else:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'Only support the 1 bit, 4 bit, 8bit, 24 bit BMP files.', ExtraData='[%s]' % str(File.Path))\n    ImageBuffer += pack('H', BmpHeader.biWidth)\n    ImageBuffer += pack('H', BmpHeader.biHeight)\n    Start = BmpHeader.bfOffBits\n    End = BmpHeader.bfSize - 1\n    for Height in range(0, BmpHeader.biHeight):\n        if Width % 4 != 0:\n            Start = End + Width % 4 - 4 - Width\n        else:\n            Start = End - Width\n        ImageBuffer += Buffer[Start + 1:Start + Width + 1]\n        End = Start\n    if PaletteBuffer and len(PaletteBuffer) > 1:\n        PaletteTemp = pack('x')\n        for Index in range(0, len(PaletteBuffer)):\n            if Index % 4 == 3:\n                continue\n            PaletteTemp += PaletteBuffer[Index:Index + 1]\n        PaletteBuffer = PaletteTemp[1:]\n    return (ImageBuffer, PaletteBuffer)",
            "def BmpImageDecoder(File, Buffer, PaletteIndex, TransParent):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (ImageType,) = struct.unpack('2s', Buffer[0:2])\n    if ImageType != b'BM':\n        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard BMP file.' % File.Path)\n    BMP_IMAGE_HEADER = collections.namedtuple('BMP_IMAGE_HEADER', ['bfSize', 'bfReserved1', 'bfReserved2', 'bfOffBits', 'biSize', 'biWidth', 'biHeight', 'biPlanes', 'biBitCount', 'biCompression', 'biSizeImage', 'biXPelsPerMeter', 'biYPelsPerMeter', 'biClrUsed', 'biClrImportant'])\n    BMP_IMAGE_HEADER_STRUCT = struct.Struct('IHHIIIIHHIIIIII')\n    BmpHeader = BMP_IMAGE_HEADER._make(BMP_IMAGE_HEADER_STRUCT.unpack_from(Buffer[2:]))\n    if BmpHeader.biCompression != 0:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The compress BMP file %s is not support.' % File.Path)\n    if BmpHeader.biWidth > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Width is exceed 0xFFFF.' % File.Path)\n    if BmpHeader.biHeight > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Height is exceed 0xFFFF.' % File.Path)\n    PaletteBuffer = pack('x')\n    if BmpHeader.biBitCount == 1:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 7) // 8\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 4:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 1) // 2\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 8:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = BmpHeader.biWidth\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 24:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT)\n        Width = BmpHeader.biWidth * 3\n    else:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'Only support the 1 bit, 4 bit, 8bit, 24 bit BMP files.', ExtraData='[%s]' % str(File.Path))\n    ImageBuffer += pack('H', BmpHeader.biWidth)\n    ImageBuffer += pack('H', BmpHeader.biHeight)\n    Start = BmpHeader.bfOffBits\n    End = BmpHeader.bfSize - 1\n    for Height in range(0, BmpHeader.biHeight):\n        if Width % 4 != 0:\n            Start = End + Width % 4 - 4 - Width\n        else:\n            Start = End - Width\n        ImageBuffer += Buffer[Start + 1:Start + Width + 1]\n        End = Start\n    if PaletteBuffer and len(PaletteBuffer) > 1:\n        PaletteTemp = pack('x')\n        for Index in range(0, len(PaletteBuffer)):\n            if Index % 4 == 3:\n                continue\n            PaletteTemp += PaletteBuffer[Index:Index + 1]\n        PaletteBuffer = PaletteTemp[1:]\n    return (ImageBuffer, PaletteBuffer)",
            "def BmpImageDecoder(File, Buffer, PaletteIndex, TransParent):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (ImageType,) = struct.unpack('2s', Buffer[0:2])\n    if ImageType != b'BM':\n        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard BMP file.' % File.Path)\n    BMP_IMAGE_HEADER = collections.namedtuple('BMP_IMAGE_HEADER', ['bfSize', 'bfReserved1', 'bfReserved2', 'bfOffBits', 'biSize', 'biWidth', 'biHeight', 'biPlanes', 'biBitCount', 'biCompression', 'biSizeImage', 'biXPelsPerMeter', 'biYPelsPerMeter', 'biClrUsed', 'biClrImportant'])\n    BMP_IMAGE_HEADER_STRUCT = struct.Struct('IHHIIIIHHIIIIII')\n    BmpHeader = BMP_IMAGE_HEADER._make(BMP_IMAGE_HEADER_STRUCT.unpack_from(Buffer[2:]))\n    if BmpHeader.biCompression != 0:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The compress BMP file %s is not support.' % File.Path)\n    if BmpHeader.biWidth > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Width is exceed 0xFFFF.' % File.Path)\n    if BmpHeader.biHeight > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Height is exceed 0xFFFF.' % File.Path)\n    PaletteBuffer = pack('x')\n    if BmpHeader.biBitCount == 1:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 7) // 8\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 4:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 1) // 2\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 8:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = BmpHeader.biWidth\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 24:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT)\n        Width = BmpHeader.biWidth * 3\n    else:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'Only support the 1 bit, 4 bit, 8bit, 24 bit BMP files.', ExtraData='[%s]' % str(File.Path))\n    ImageBuffer += pack('H', BmpHeader.biWidth)\n    ImageBuffer += pack('H', BmpHeader.biHeight)\n    Start = BmpHeader.bfOffBits\n    End = BmpHeader.bfSize - 1\n    for Height in range(0, BmpHeader.biHeight):\n        if Width % 4 != 0:\n            Start = End + Width % 4 - 4 - Width\n        else:\n            Start = End - Width\n        ImageBuffer += Buffer[Start + 1:Start + Width + 1]\n        End = Start\n    if PaletteBuffer and len(PaletteBuffer) > 1:\n        PaletteTemp = pack('x')\n        for Index in range(0, len(PaletteBuffer)):\n            if Index % 4 == 3:\n                continue\n            PaletteTemp += PaletteBuffer[Index:Index + 1]\n        PaletteBuffer = PaletteTemp[1:]\n    return (ImageBuffer, PaletteBuffer)",
            "def BmpImageDecoder(File, Buffer, PaletteIndex, TransParent):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (ImageType,) = struct.unpack('2s', Buffer[0:2])\n    if ImageType != b'BM':\n        EdkLogger.error('build', FILE_TYPE_MISMATCH, 'The file %s is not a standard BMP file.' % File.Path)\n    BMP_IMAGE_HEADER = collections.namedtuple('BMP_IMAGE_HEADER', ['bfSize', 'bfReserved1', 'bfReserved2', 'bfOffBits', 'biSize', 'biWidth', 'biHeight', 'biPlanes', 'biBitCount', 'biCompression', 'biSizeImage', 'biXPelsPerMeter', 'biYPelsPerMeter', 'biClrUsed', 'biClrImportant'])\n    BMP_IMAGE_HEADER_STRUCT = struct.Struct('IHHIIIIHHIIIIII')\n    BmpHeader = BMP_IMAGE_HEADER._make(BMP_IMAGE_HEADER_STRUCT.unpack_from(Buffer[2:]))\n    if BmpHeader.biCompression != 0:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The compress BMP file %s is not support.' % File.Path)\n    if BmpHeader.biWidth > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Width is exceed 0xFFFF.' % File.Path)\n    if BmpHeader.biHeight > 65535:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'The BMP file %s Height is exceed 0xFFFF.' % File.Path)\n    PaletteBuffer = pack('x')\n    if BmpHeader.biBitCount == 1:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_1BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 7) // 8\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 4:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_4BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = (BmpHeader.biWidth + 1) // 2\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 8:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_8BIT)\n        ImageBuffer += pack('B', PaletteIndex)\n        Width = BmpHeader.biWidth\n        if BmpHeader.bfOffBits > BMP_IMAGE_HEADER_STRUCT.size + 2:\n            PaletteBuffer = Buffer[BMP_IMAGE_HEADER_STRUCT.size + 2:BmpHeader.bfOffBits]\n    elif BmpHeader.biBitCount == 24:\n        if TransParent:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT_TRANS)\n        else:\n            ImageBuffer = pack('B', EFI_HII_IIBT_IMAGE_24BIT)\n        Width = BmpHeader.biWidth * 3\n    else:\n        EdkLogger.error('build', FORMAT_NOT_SUPPORTED, 'Only support the 1 bit, 4 bit, 8bit, 24 bit BMP files.', ExtraData='[%s]' % str(File.Path))\n    ImageBuffer += pack('H', BmpHeader.biWidth)\n    ImageBuffer += pack('H', BmpHeader.biHeight)\n    Start = BmpHeader.bfOffBits\n    End = BmpHeader.bfSize - 1\n    for Height in range(0, BmpHeader.biHeight):\n        if Width % 4 != 0:\n            Start = End + Width % 4 - 4 - Width\n        else:\n            Start = End - Width\n        ImageBuffer += Buffer[Start + 1:Start + Width + 1]\n        End = Start\n    if PaletteBuffer and len(PaletteBuffer) > 1:\n        PaletteTemp = pack('x')\n        for Index in range(0, len(PaletteBuffer)):\n            if Index % 4 == 3:\n                continue\n            PaletteTemp += PaletteBuffer[Index:Index + 1]\n        PaletteBuffer = PaletteTemp[1:]\n    return (ImageBuffer, PaletteBuffer)"
        ]
    },
    {
        "func_name": "CreateHeaderCode",
        "original": "def CreateHeaderCode(Info, AutoGenC, AutoGenH):\n    AutoGenH.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.h'}))\n    AutoGenH.Append(gAutoGenHPrologueString.Replace({'File': 'AUTOGENH', 'Guid': Info.Guid.replace('-', '_')}))\n    AutoGenH.Append(gAutoGenHCppPrologueString)\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        AutoGenH.Append('#include <%s>\\n' % gModuleTypeHeaderFile[Info.ModuleType][0])\n    if 'PcdLib' in Info.Module.LibraryClasses or Info.Module.Pcds:\n        AutoGenH.Append('#include <Library/PcdLib.h>\\n')\n    AutoGenH.Append('\\nextern GUID  gEfiCallerIdGuid;')\n    AutoGenH.Append('\\nextern GUID  gEdkiiDscPlatformGuid;')\n    AutoGenH.Append('\\nextern CHAR8 *gEfiCallerBaseName;\\n\\n')\n    if Info.IsLibrary:\n        return\n    AutoGenH.Append('#define EFI_CALLER_ID_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenH.Append('#define EDKII_DSC_PLATFORM_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    if Info.IsLibrary:\n        return\n    AutoGenC.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.c'}))\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        for Inc in gModuleTypeHeaderFile[Info.ModuleType]:\n            AutoGenC.Append('#include <%s>\\n' % Inc)\n    else:\n        AutoGenC.Append('#include <%s>\\n' % gBasicHeaderFile)\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEfiCallerIdGuid = %s;\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEdkiiDscPlatformGuid = %s;\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED CHAR8 *gEfiCallerBaseName = \"%s\";\\n' % Info.Name)",
        "mutated": [
            "def CreateHeaderCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    AutoGenH.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.h'}))\n    AutoGenH.Append(gAutoGenHPrologueString.Replace({'File': 'AUTOGENH', 'Guid': Info.Guid.replace('-', '_')}))\n    AutoGenH.Append(gAutoGenHCppPrologueString)\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        AutoGenH.Append('#include <%s>\\n' % gModuleTypeHeaderFile[Info.ModuleType][0])\n    if 'PcdLib' in Info.Module.LibraryClasses or Info.Module.Pcds:\n        AutoGenH.Append('#include <Library/PcdLib.h>\\n')\n    AutoGenH.Append('\\nextern GUID  gEfiCallerIdGuid;')\n    AutoGenH.Append('\\nextern GUID  gEdkiiDscPlatformGuid;')\n    AutoGenH.Append('\\nextern CHAR8 *gEfiCallerBaseName;\\n\\n')\n    if Info.IsLibrary:\n        return\n    AutoGenH.Append('#define EFI_CALLER_ID_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenH.Append('#define EDKII_DSC_PLATFORM_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    if Info.IsLibrary:\n        return\n    AutoGenC.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.c'}))\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        for Inc in gModuleTypeHeaderFile[Info.ModuleType]:\n            AutoGenC.Append('#include <%s>\\n' % Inc)\n    else:\n        AutoGenC.Append('#include <%s>\\n' % gBasicHeaderFile)\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEfiCallerIdGuid = %s;\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEdkiiDscPlatformGuid = %s;\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED CHAR8 *gEfiCallerBaseName = \"%s\";\\n' % Info.Name)",
            "def CreateHeaderCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    AutoGenH.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.h'}))\n    AutoGenH.Append(gAutoGenHPrologueString.Replace({'File': 'AUTOGENH', 'Guid': Info.Guid.replace('-', '_')}))\n    AutoGenH.Append(gAutoGenHCppPrologueString)\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        AutoGenH.Append('#include <%s>\\n' % gModuleTypeHeaderFile[Info.ModuleType][0])\n    if 'PcdLib' in Info.Module.LibraryClasses or Info.Module.Pcds:\n        AutoGenH.Append('#include <Library/PcdLib.h>\\n')\n    AutoGenH.Append('\\nextern GUID  gEfiCallerIdGuid;')\n    AutoGenH.Append('\\nextern GUID  gEdkiiDscPlatformGuid;')\n    AutoGenH.Append('\\nextern CHAR8 *gEfiCallerBaseName;\\n\\n')\n    if Info.IsLibrary:\n        return\n    AutoGenH.Append('#define EFI_CALLER_ID_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenH.Append('#define EDKII_DSC_PLATFORM_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    if Info.IsLibrary:\n        return\n    AutoGenC.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.c'}))\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        for Inc in gModuleTypeHeaderFile[Info.ModuleType]:\n            AutoGenC.Append('#include <%s>\\n' % Inc)\n    else:\n        AutoGenC.Append('#include <%s>\\n' % gBasicHeaderFile)\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEfiCallerIdGuid = %s;\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEdkiiDscPlatformGuid = %s;\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED CHAR8 *gEfiCallerBaseName = \"%s\";\\n' % Info.Name)",
            "def CreateHeaderCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    AutoGenH.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.h'}))\n    AutoGenH.Append(gAutoGenHPrologueString.Replace({'File': 'AUTOGENH', 'Guid': Info.Guid.replace('-', '_')}))\n    AutoGenH.Append(gAutoGenHCppPrologueString)\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        AutoGenH.Append('#include <%s>\\n' % gModuleTypeHeaderFile[Info.ModuleType][0])\n    if 'PcdLib' in Info.Module.LibraryClasses or Info.Module.Pcds:\n        AutoGenH.Append('#include <Library/PcdLib.h>\\n')\n    AutoGenH.Append('\\nextern GUID  gEfiCallerIdGuid;')\n    AutoGenH.Append('\\nextern GUID  gEdkiiDscPlatformGuid;')\n    AutoGenH.Append('\\nextern CHAR8 *gEfiCallerBaseName;\\n\\n')\n    if Info.IsLibrary:\n        return\n    AutoGenH.Append('#define EFI_CALLER_ID_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenH.Append('#define EDKII_DSC_PLATFORM_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    if Info.IsLibrary:\n        return\n    AutoGenC.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.c'}))\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        for Inc in gModuleTypeHeaderFile[Info.ModuleType]:\n            AutoGenC.Append('#include <%s>\\n' % Inc)\n    else:\n        AutoGenC.Append('#include <%s>\\n' % gBasicHeaderFile)\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEfiCallerIdGuid = %s;\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEdkiiDscPlatformGuid = %s;\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED CHAR8 *gEfiCallerBaseName = \"%s\";\\n' % Info.Name)",
            "def CreateHeaderCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    AutoGenH.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.h'}))\n    AutoGenH.Append(gAutoGenHPrologueString.Replace({'File': 'AUTOGENH', 'Guid': Info.Guid.replace('-', '_')}))\n    AutoGenH.Append(gAutoGenHCppPrologueString)\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        AutoGenH.Append('#include <%s>\\n' % gModuleTypeHeaderFile[Info.ModuleType][0])\n    if 'PcdLib' in Info.Module.LibraryClasses or Info.Module.Pcds:\n        AutoGenH.Append('#include <Library/PcdLib.h>\\n')\n    AutoGenH.Append('\\nextern GUID  gEfiCallerIdGuid;')\n    AutoGenH.Append('\\nextern GUID  gEdkiiDscPlatformGuid;')\n    AutoGenH.Append('\\nextern CHAR8 *gEfiCallerBaseName;\\n\\n')\n    if Info.IsLibrary:\n        return\n    AutoGenH.Append('#define EFI_CALLER_ID_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenH.Append('#define EDKII_DSC_PLATFORM_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    if Info.IsLibrary:\n        return\n    AutoGenC.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.c'}))\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        for Inc in gModuleTypeHeaderFile[Info.ModuleType]:\n            AutoGenC.Append('#include <%s>\\n' % Inc)\n    else:\n        AutoGenC.Append('#include <%s>\\n' % gBasicHeaderFile)\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEfiCallerIdGuid = %s;\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEdkiiDscPlatformGuid = %s;\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED CHAR8 *gEfiCallerBaseName = \"%s\";\\n' % Info.Name)",
            "def CreateHeaderCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    AutoGenH.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.h'}))\n    AutoGenH.Append(gAutoGenHPrologueString.Replace({'File': 'AUTOGENH', 'Guid': Info.Guid.replace('-', '_')}))\n    AutoGenH.Append(gAutoGenHCppPrologueString)\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        AutoGenH.Append('#include <%s>\\n' % gModuleTypeHeaderFile[Info.ModuleType][0])\n    if 'PcdLib' in Info.Module.LibraryClasses or Info.Module.Pcds:\n        AutoGenH.Append('#include <Library/PcdLib.h>\\n')\n    AutoGenH.Append('\\nextern GUID  gEfiCallerIdGuid;')\n    AutoGenH.Append('\\nextern GUID  gEdkiiDscPlatformGuid;')\n    AutoGenH.Append('\\nextern CHAR8 *gEfiCallerBaseName;\\n\\n')\n    if Info.IsLibrary:\n        return\n    AutoGenH.Append('#define EFI_CALLER_ID_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenH.Append('#define EDKII_DSC_PLATFORM_GUID \\\\\\n  %s\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    if Info.IsLibrary:\n        return\n    AutoGenC.Append(gAutoGenHeaderString.Replace({'FileName': 'AutoGen.c'}))\n    if Info.ModuleType in gModuleTypeHeaderFile:\n        for Inc in gModuleTypeHeaderFile[Info.ModuleType]:\n            AutoGenC.Append('#include <%s>\\n' % Inc)\n    else:\n        AutoGenC.Append('#include <%s>\\n' % gBasicHeaderFile)\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEfiCallerIdGuid = %s;\\n' % GuidStringToGuidStructureString(Info.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED GUID gEdkiiDscPlatformGuid = %s;\\n' % GuidStringToGuidStructureString(Info.PlatformInfo.Guid))\n    AutoGenC.Append('\\nGLOBAL_REMOVE_IF_UNREFERENCED CHAR8 *gEfiCallerBaseName = \"%s\";\\n' % Info.Name)"
        ]
    },
    {
        "func_name": "CreateFooterCode",
        "original": "def CreateFooterCode(Info, AutoGenC, AutoGenH):\n    AutoGenH.Append(gAutoGenHEpilogueString)",
        "mutated": [
            "def CreateFooterCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n    AutoGenH.Append(gAutoGenHEpilogueString)",
            "def CreateFooterCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    AutoGenH.Append(gAutoGenHEpilogueString)",
            "def CreateFooterCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    AutoGenH.Append(gAutoGenHEpilogueString)",
            "def CreateFooterCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    AutoGenH.Append(gAutoGenHEpilogueString)",
            "def CreateFooterCode(Info, AutoGenC, AutoGenH):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    AutoGenH.Append(gAutoGenHEpilogueString)"
        ]
    },
    {
        "func_name": "CreateCode",
        "original": "def CreateCode(Info, AutoGenC, AutoGenH, StringH, UniGenCFlag, UniGenBinBuffer, StringIdf, IdfGenCFlag, IdfGenBinBuffer):\n    CreateHeaderCode(Info, AutoGenC, AutoGenH)\n    CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePcdCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH)\n    CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH)\n    CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH)\n    if Info.UnicodeFileList:\n        FileName = '%sStrDefs.h' % Info.Name\n        StringH.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringH.Append(gAutoGenHPrologueString.Replace({'File': 'STRDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateUnicodeStringCode(Info, AutoGenC, StringH, UniGenCFlag, UniGenBinBuffer)\n        GuidMacros = []\n        for Guid in Info.Module.Guids:\n            if Guid in Info.Module.GetGuidsUsedByPcd():\n                continue\n            GuidMacros.append('#define %s %s' % (Guid, Info.Module.Guids[Guid]))\n        for (Guid, Value) in list(Info.Module.Protocols.items()) + list(Info.Module.Ppis.items()):\n            GuidMacros.append('#define %s %s' % (Guid, Value))\n        if Info.VfrFileList and Info.ModulePcdList:\n            GuidMacros.append('#define %s %s' % ('FixedPcdGetBool(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet8(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet16(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet32(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet64(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FeaturePcdGet(TokenName)', '_PCD_VALUE_##TokenName'))\n            for Pcd in Info.ModulePcdList:\n                if Pcd.Type in [TAB_PCDS_FIXED_AT_BUILD, TAB_PCDS_FEATURE_FLAG]:\n                    TokenCName = Pcd.TokenCName\n                    Value = Pcd.DefaultValue\n                    if Pcd.DatumType == 'BOOLEAN':\n                        BoolValue = Value.upper()\n                        if BoolValue == 'TRUE':\n                            Value = '1'\n                        elif BoolValue == 'FALSE':\n                            Value = '0'\n                    for PcdItem in GlobalData.MixedPcd:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                            TokenCName = PcdItem[0]\n                            break\n                    GuidMacros.append('#define %s %s' % ('_PCD_VALUE_' + TokenCName, Value))\n        if Info.IdfFileList:\n            GuidMacros.append('#include \"%sImgDefs.h\"' % Info.Name)\n        if GuidMacros:\n            StringH.Append('\\n#ifdef VFRCOMPILE\\n%s\\n#endif\\n' % '\\n'.join(GuidMacros))\n        StringH.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    if Info.IdfFileList:\n        FileName = '%sImgDefs.h' % Info.Name\n        StringIdf.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringIdf.Append(gAutoGenHPrologueString.Replace({'File': 'IMAGEDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateIdfFileCode(Info, AutoGenC, StringIdf, IdfGenCFlag, IdfGenBinBuffer)\n        StringIdf.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    CreateFooterCode(Info, AutoGenC, AutoGenH)",
        "mutated": [
            "def CreateCode(Info, AutoGenC, AutoGenH, StringH, UniGenCFlag, UniGenBinBuffer, StringIdf, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n    CreateHeaderCode(Info, AutoGenC, AutoGenH)\n    CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePcdCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH)\n    CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH)\n    CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH)\n    if Info.UnicodeFileList:\n        FileName = '%sStrDefs.h' % Info.Name\n        StringH.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringH.Append(gAutoGenHPrologueString.Replace({'File': 'STRDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateUnicodeStringCode(Info, AutoGenC, StringH, UniGenCFlag, UniGenBinBuffer)\n        GuidMacros = []\n        for Guid in Info.Module.Guids:\n            if Guid in Info.Module.GetGuidsUsedByPcd():\n                continue\n            GuidMacros.append('#define %s %s' % (Guid, Info.Module.Guids[Guid]))\n        for (Guid, Value) in list(Info.Module.Protocols.items()) + list(Info.Module.Ppis.items()):\n            GuidMacros.append('#define %s %s' % (Guid, Value))\n        if Info.VfrFileList and Info.ModulePcdList:\n            GuidMacros.append('#define %s %s' % ('FixedPcdGetBool(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet8(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet16(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet32(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet64(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FeaturePcdGet(TokenName)', '_PCD_VALUE_##TokenName'))\n            for Pcd in Info.ModulePcdList:\n                if Pcd.Type in [TAB_PCDS_FIXED_AT_BUILD, TAB_PCDS_FEATURE_FLAG]:\n                    TokenCName = Pcd.TokenCName\n                    Value = Pcd.DefaultValue\n                    if Pcd.DatumType == 'BOOLEAN':\n                        BoolValue = Value.upper()\n                        if BoolValue == 'TRUE':\n                            Value = '1'\n                        elif BoolValue == 'FALSE':\n                            Value = '0'\n                    for PcdItem in GlobalData.MixedPcd:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                            TokenCName = PcdItem[0]\n                            break\n                    GuidMacros.append('#define %s %s' % ('_PCD_VALUE_' + TokenCName, Value))\n        if Info.IdfFileList:\n            GuidMacros.append('#include \"%sImgDefs.h\"' % Info.Name)\n        if GuidMacros:\n            StringH.Append('\\n#ifdef VFRCOMPILE\\n%s\\n#endif\\n' % '\\n'.join(GuidMacros))\n        StringH.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    if Info.IdfFileList:\n        FileName = '%sImgDefs.h' % Info.Name\n        StringIdf.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringIdf.Append(gAutoGenHPrologueString.Replace({'File': 'IMAGEDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateIdfFileCode(Info, AutoGenC, StringIdf, IdfGenCFlag, IdfGenBinBuffer)\n        StringIdf.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    CreateFooterCode(Info, AutoGenC, AutoGenH)",
            "def CreateCode(Info, AutoGenC, AutoGenH, StringH, UniGenCFlag, UniGenBinBuffer, StringIdf, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    CreateHeaderCode(Info, AutoGenC, AutoGenH)\n    CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePcdCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH)\n    CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH)\n    CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH)\n    if Info.UnicodeFileList:\n        FileName = '%sStrDefs.h' % Info.Name\n        StringH.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringH.Append(gAutoGenHPrologueString.Replace({'File': 'STRDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateUnicodeStringCode(Info, AutoGenC, StringH, UniGenCFlag, UniGenBinBuffer)\n        GuidMacros = []\n        for Guid in Info.Module.Guids:\n            if Guid in Info.Module.GetGuidsUsedByPcd():\n                continue\n            GuidMacros.append('#define %s %s' % (Guid, Info.Module.Guids[Guid]))\n        for (Guid, Value) in list(Info.Module.Protocols.items()) + list(Info.Module.Ppis.items()):\n            GuidMacros.append('#define %s %s' % (Guid, Value))\n        if Info.VfrFileList and Info.ModulePcdList:\n            GuidMacros.append('#define %s %s' % ('FixedPcdGetBool(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet8(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet16(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet32(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet64(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FeaturePcdGet(TokenName)', '_PCD_VALUE_##TokenName'))\n            for Pcd in Info.ModulePcdList:\n                if Pcd.Type in [TAB_PCDS_FIXED_AT_BUILD, TAB_PCDS_FEATURE_FLAG]:\n                    TokenCName = Pcd.TokenCName\n                    Value = Pcd.DefaultValue\n                    if Pcd.DatumType == 'BOOLEAN':\n                        BoolValue = Value.upper()\n                        if BoolValue == 'TRUE':\n                            Value = '1'\n                        elif BoolValue == 'FALSE':\n                            Value = '0'\n                    for PcdItem in GlobalData.MixedPcd:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                            TokenCName = PcdItem[0]\n                            break\n                    GuidMacros.append('#define %s %s' % ('_PCD_VALUE_' + TokenCName, Value))\n        if Info.IdfFileList:\n            GuidMacros.append('#include \"%sImgDefs.h\"' % Info.Name)\n        if GuidMacros:\n            StringH.Append('\\n#ifdef VFRCOMPILE\\n%s\\n#endif\\n' % '\\n'.join(GuidMacros))\n        StringH.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    if Info.IdfFileList:\n        FileName = '%sImgDefs.h' % Info.Name\n        StringIdf.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringIdf.Append(gAutoGenHPrologueString.Replace({'File': 'IMAGEDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateIdfFileCode(Info, AutoGenC, StringIdf, IdfGenCFlag, IdfGenBinBuffer)\n        StringIdf.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    CreateFooterCode(Info, AutoGenC, AutoGenH)",
            "def CreateCode(Info, AutoGenC, AutoGenH, StringH, UniGenCFlag, UniGenBinBuffer, StringIdf, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    CreateHeaderCode(Info, AutoGenC, AutoGenH)\n    CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePcdCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH)\n    CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH)\n    CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH)\n    if Info.UnicodeFileList:\n        FileName = '%sStrDefs.h' % Info.Name\n        StringH.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringH.Append(gAutoGenHPrologueString.Replace({'File': 'STRDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateUnicodeStringCode(Info, AutoGenC, StringH, UniGenCFlag, UniGenBinBuffer)\n        GuidMacros = []\n        for Guid in Info.Module.Guids:\n            if Guid in Info.Module.GetGuidsUsedByPcd():\n                continue\n            GuidMacros.append('#define %s %s' % (Guid, Info.Module.Guids[Guid]))\n        for (Guid, Value) in list(Info.Module.Protocols.items()) + list(Info.Module.Ppis.items()):\n            GuidMacros.append('#define %s %s' % (Guid, Value))\n        if Info.VfrFileList and Info.ModulePcdList:\n            GuidMacros.append('#define %s %s' % ('FixedPcdGetBool(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet8(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet16(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet32(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet64(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FeaturePcdGet(TokenName)', '_PCD_VALUE_##TokenName'))\n            for Pcd in Info.ModulePcdList:\n                if Pcd.Type in [TAB_PCDS_FIXED_AT_BUILD, TAB_PCDS_FEATURE_FLAG]:\n                    TokenCName = Pcd.TokenCName\n                    Value = Pcd.DefaultValue\n                    if Pcd.DatumType == 'BOOLEAN':\n                        BoolValue = Value.upper()\n                        if BoolValue == 'TRUE':\n                            Value = '1'\n                        elif BoolValue == 'FALSE':\n                            Value = '0'\n                    for PcdItem in GlobalData.MixedPcd:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                            TokenCName = PcdItem[0]\n                            break\n                    GuidMacros.append('#define %s %s' % ('_PCD_VALUE_' + TokenCName, Value))\n        if Info.IdfFileList:\n            GuidMacros.append('#include \"%sImgDefs.h\"' % Info.Name)\n        if GuidMacros:\n            StringH.Append('\\n#ifdef VFRCOMPILE\\n%s\\n#endif\\n' % '\\n'.join(GuidMacros))\n        StringH.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    if Info.IdfFileList:\n        FileName = '%sImgDefs.h' % Info.Name\n        StringIdf.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringIdf.Append(gAutoGenHPrologueString.Replace({'File': 'IMAGEDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateIdfFileCode(Info, AutoGenC, StringIdf, IdfGenCFlag, IdfGenBinBuffer)\n        StringIdf.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    CreateFooterCode(Info, AutoGenC, AutoGenH)",
            "def CreateCode(Info, AutoGenC, AutoGenH, StringH, UniGenCFlag, UniGenBinBuffer, StringIdf, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    CreateHeaderCode(Info, AutoGenC, AutoGenH)\n    CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePcdCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH)\n    CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH)\n    CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH)\n    if Info.UnicodeFileList:\n        FileName = '%sStrDefs.h' % Info.Name\n        StringH.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringH.Append(gAutoGenHPrologueString.Replace({'File': 'STRDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateUnicodeStringCode(Info, AutoGenC, StringH, UniGenCFlag, UniGenBinBuffer)\n        GuidMacros = []\n        for Guid in Info.Module.Guids:\n            if Guid in Info.Module.GetGuidsUsedByPcd():\n                continue\n            GuidMacros.append('#define %s %s' % (Guid, Info.Module.Guids[Guid]))\n        for (Guid, Value) in list(Info.Module.Protocols.items()) + list(Info.Module.Ppis.items()):\n            GuidMacros.append('#define %s %s' % (Guid, Value))\n        if Info.VfrFileList and Info.ModulePcdList:\n            GuidMacros.append('#define %s %s' % ('FixedPcdGetBool(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet8(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet16(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet32(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet64(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FeaturePcdGet(TokenName)', '_PCD_VALUE_##TokenName'))\n            for Pcd in Info.ModulePcdList:\n                if Pcd.Type in [TAB_PCDS_FIXED_AT_BUILD, TAB_PCDS_FEATURE_FLAG]:\n                    TokenCName = Pcd.TokenCName\n                    Value = Pcd.DefaultValue\n                    if Pcd.DatumType == 'BOOLEAN':\n                        BoolValue = Value.upper()\n                        if BoolValue == 'TRUE':\n                            Value = '1'\n                        elif BoolValue == 'FALSE':\n                            Value = '0'\n                    for PcdItem in GlobalData.MixedPcd:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                            TokenCName = PcdItem[0]\n                            break\n                    GuidMacros.append('#define %s %s' % ('_PCD_VALUE_' + TokenCName, Value))\n        if Info.IdfFileList:\n            GuidMacros.append('#include \"%sImgDefs.h\"' % Info.Name)\n        if GuidMacros:\n            StringH.Append('\\n#ifdef VFRCOMPILE\\n%s\\n#endif\\n' % '\\n'.join(GuidMacros))\n        StringH.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    if Info.IdfFileList:\n        FileName = '%sImgDefs.h' % Info.Name\n        StringIdf.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringIdf.Append(gAutoGenHPrologueString.Replace({'File': 'IMAGEDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateIdfFileCode(Info, AutoGenC, StringIdf, IdfGenCFlag, IdfGenBinBuffer)\n        StringIdf.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    CreateFooterCode(Info, AutoGenC, AutoGenH)",
            "def CreateCode(Info, AutoGenC, AutoGenH, StringH, UniGenCFlag, UniGenBinBuffer, StringIdf, IdfGenCFlag, IdfGenBinBuffer):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    CreateHeaderCode(Info, AutoGenC, AutoGenH)\n    CreateGuidDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreateProtocolDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePpiDefinitionCode(Info, AutoGenC, AutoGenH)\n    CreatePcdCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryConstructorCode(Info, AutoGenC, AutoGenH)\n    CreateLibraryDestructorCode(Info, AutoGenC, AutoGenH)\n    CreateModuleEntryPointCode(Info, AutoGenC, AutoGenH)\n    CreateModuleUnloadImageCode(Info, AutoGenC, AutoGenH)\n    if Info.UnicodeFileList:\n        FileName = '%sStrDefs.h' % Info.Name\n        StringH.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringH.Append(gAutoGenHPrologueString.Replace({'File': 'STRDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateUnicodeStringCode(Info, AutoGenC, StringH, UniGenCFlag, UniGenBinBuffer)\n        GuidMacros = []\n        for Guid in Info.Module.Guids:\n            if Guid in Info.Module.GetGuidsUsedByPcd():\n                continue\n            GuidMacros.append('#define %s %s' % (Guid, Info.Module.Guids[Guid]))\n        for (Guid, Value) in list(Info.Module.Protocols.items()) + list(Info.Module.Ppis.items()):\n            GuidMacros.append('#define %s %s' % (Guid, Value))\n        if Info.VfrFileList and Info.ModulePcdList:\n            GuidMacros.append('#define %s %s' % ('FixedPcdGetBool(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet8(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet16(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet32(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FixedPcdGet64(TokenName)', '_PCD_VALUE_##TokenName'))\n            GuidMacros.append('#define %s %s' % ('FeaturePcdGet(TokenName)', '_PCD_VALUE_##TokenName'))\n            for Pcd in Info.ModulePcdList:\n                if Pcd.Type in [TAB_PCDS_FIXED_AT_BUILD, TAB_PCDS_FEATURE_FLAG]:\n                    TokenCName = Pcd.TokenCName\n                    Value = Pcd.DefaultValue\n                    if Pcd.DatumType == 'BOOLEAN':\n                        BoolValue = Value.upper()\n                        if BoolValue == 'TRUE':\n                            Value = '1'\n                        elif BoolValue == 'FALSE':\n                            Value = '0'\n                    for PcdItem in GlobalData.MixedPcd:\n                        if (Pcd.TokenCName, Pcd.TokenSpaceGuidCName) in GlobalData.MixedPcd[PcdItem]:\n                            TokenCName = PcdItem[0]\n                            break\n                    GuidMacros.append('#define %s %s' % ('_PCD_VALUE_' + TokenCName, Value))\n        if Info.IdfFileList:\n            GuidMacros.append('#include \"%sImgDefs.h\"' % Info.Name)\n        if GuidMacros:\n            StringH.Append('\\n#ifdef VFRCOMPILE\\n%s\\n#endif\\n' % '\\n'.join(GuidMacros))\n        StringH.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    if Info.IdfFileList:\n        FileName = '%sImgDefs.h' % Info.Name\n        StringIdf.Append(gAutoGenHeaderString.Replace({'FileName': FileName}))\n        StringIdf.Append(gAutoGenHPrologueString.Replace({'File': 'IMAGEDEFS', 'Guid': Info.Guid.replace('-', '_')}))\n        CreateIdfFileCode(Info, AutoGenC, StringIdf, IdfGenCFlag, IdfGenBinBuffer)\n        StringIdf.Append('\\n#endif\\n')\n        AutoGenH.Append('#include \"%s\"\\n' % FileName)\n    CreateFooterCode(Info, AutoGenC, AutoGenH)"
        ]
    },
    {
        "func_name": "Generate",
        "original": "def Generate(FilePath, Content, IsBinaryFile):\n    return SaveFileOnChange(FilePath, Content, IsBinaryFile)",
        "mutated": [
            "def Generate(FilePath, Content, IsBinaryFile):\n    if False:\n        i = 10\n    return SaveFileOnChange(FilePath, Content, IsBinaryFile)",
            "def Generate(FilePath, Content, IsBinaryFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return SaveFileOnChange(FilePath, Content, IsBinaryFile)",
            "def Generate(FilePath, Content, IsBinaryFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return SaveFileOnChange(FilePath, Content, IsBinaryFile)",
            "def Generate(FilePath, Content, IsBinaryFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return SaveFileOnChange(FilePath, Content, IsBinaryFile)",
            "def Generate(FilePath, Content, IsBinaryFile):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return SaveFileOnChange(FilePath, Content, IsBinaryFile)"
        ]
    }
]