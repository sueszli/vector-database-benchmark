"""Amazon PARQUET S3 Parquet Write Module (PRIVATE)."""
import logging
import math
from contextlib import contextmanager
from typing import TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Literal, Optional, Tuple, Union, cast
import boto3
import pandas as pd
import pyarrow as pa
import pyarrow.lib
import pyarrow.parquet
from awswrangler import _utils, catalog, exceptions, typing
from awswrangler._arrow import _df_to_table
from awswrangler._config import apply_configs
from awswrangler._distributed import engine
from awswrangler.catalog._create import _create_parquet_table
from awswrangler.s3._fs import open_s3_object
from awswrangler.s3._read_parquet import _read_parquet_metadata
from awswrangler.s3._write import _COMPRESSION_2_EXT, _get_chunk_file_path, _get_file_path, _get_write_table_args, _S3WriteStrategy, _validate_args
from awswrangler.s3._write_concurrent import _WriteProxy
from awswrangler.typing import AthenaPartitionProjectionSettings, BucketingInfoTuple, GlueTableSettings, _S3WriteDataReturnValue
if TYPE_CHECKING:
    from mypy_boto3_s3 import S3Client
_logger: logging.Logger = logging.getLogger(__name__)

@contextmanager
def _new_writer(file_path: str, compression: Optional[str], pyarrow_additional_kwargs: Optional[Dict[str, Any]], schema: pa.Schema, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int]) -> Iterator[pyarrow.parquet.ParquetWriter]:
    if False:
        while True:
            i = 10
    writer: Optional[pyarrow.parquet.ParquetWriter] = None
    if not pyarrow_additional_kwargs:
        pyarrow_additional_kwargs = {}
    if not pyarrow_additional_kwargs.get('coerce_timestamps'):
        pyarrow_additional_kwargs['coerce_timestamps'] = 'ms'
    if 'flavor' not in pyarrow_additional_kwargs:
        pyarrow_additional_kwargs['flavor'] = 'spark'
    if 'version' not in pyarrow_additional_kwargs:
        pyarrow_additional_kwargs['version'] = '1.0'
    if not pyarrow_additional_kwargs.get('use_dictionary'):
        pyarrow_additional_kwargs['use_dictionary'] = True
    if not pyarrow_additional_kwargs.get('write_statistics'):
        pyarrow_additional_kwargs['write_statistics'] = True
    if not pyarrow_additional_kwargs.get('schema'):
        pyarrow_additional_kwargs['schema'] = schema
    with open_s3_object(path=file_path, mode='wb', use_threads=use_threads, s3_additional_kwargs=s3_additional_kwargs, s3_client=s3_client) as f:
        try:
            writer = pyarrow.parquet.ParquetWriter(where=f, compression='NONE' if compression is None else compression, **pyarrow_additional_kwargs)
            yield writer
        finally:
            if writer is not None and writer.is_open is True:
                writer.close()

def _write_chunk(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, str], table: pa.Table, offset: int, chunk_size: int, use_threads: Union[bool, int]) -> List[str]:
    if False:
        print('Hello World!')
    write_table_args = _get_write_table_args(pyarrow_additional_kwargs)
    with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, schema=table.schema, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:
        writer.write_table(table.slice(offset, chunk_size), **write_table_args)
    return [file_path]

def _to_parquet_chunked(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, Any], table: pa.Table, max_rows_by_file: int, num_of_rows: int, cpus: int) -> List[str]:
    if False:
        return 10
    chunks: int = math.ceil(num_of_rows / max_rows_by_file)
    use_threads: Union[bool, int] = cpus > 1
    proxy: _WriteProxy = _WriteProxy(use_threads=use_threads)
    for chunk in range(chunks):
        offset: int = chunk * max_rows_by_file
        write_path: str = _get_chunk_file_path(chunk, file_path)
        proxy.write(func=_write_chunk, file_path=write_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, offset=offset, chunk_size=max_rows_by_file, use_threads=use_threads)
    return proxy.close()

@engine.dispatch_on_engine
def _to_parquet(df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:
    if False:
        print('Hello World!')
    s3_client = s3_client if s3_client else _utils.client(service_name='s3')
    file_path = _get_file_path(path_root=path_root, path=path, filename_prefix=filename_prefix, compression_ext=compression_ext, extension='.parquet')
    table: pa.Table = _df_to_table(df, schema, index, dtype)
    if max_rows_by_file is not None and max_rows_by_file > 0:
        paths: List[str] = _to_parquet_chunked(file_path=file_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, max_rows_by_file=max_rows_by_file, num_of_rows=df.shape[0], cpus=cpus)
    else:
        write_table_args = _get_write_table_args(pyarrow_additional_kwargs)
        with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, schema=table.schema, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:
            writer.write_table(table, **write_table_args)
        paths = [file_path]
    return paths

class _S3ParquetWriteStrategy(_S3WriteStrategy):

    @property
    def _write_to_s3_func(self) -> Callable[..., List[str]]:
        if False:
            return 10
        return _to_parquet

    def _write_to_s3(self, df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:
        if False:
            i = 10
            return i + 15
        return _to_parquet(df=df, schema=schema, index=index, compression=compression, compression_ext=compression_ext, pyarrow_additional_kwargs=pyarrow_additional_kwargs, cpus=cpus, dtype=dtype, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads, path=path, path_root=path_root, filename_prefix=filename_prefix, max_rows_by_file=max_rows_by_file, bucketing=bucketing)

    def _create_glue_table(self, database: str, table: str, path: str, columns_types: Dict[str, str], table_type: Optional[str]=None, partitions_types: Optional[Dict[str, str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, description: Optional[str]=None, parameters: Optional[Dict[str, str]]=None, columns_comments: Optional[Dict[str, str]]=None, mode: str='overwrite', catalog_versioning: bool=False, transaction_id: Optional[str]=None, athena_partition_projection_settings: Optional[AthenaPartitionProjectionSettings]=None, boto3_session: Optional[boto3.Session]=None, catalog_table_input: Optional[Dict[str, Any]]=None) -> None:
        if False:
            print('Hello World!')
        return _create_parquet_table(database=database, table=table, path=path, columns_types=columns_types, table_type=table_type, partitions_types=partitions_types, bucketing_info=bucketing_info, catalog_id=catalog_id, compression=compression, description=description, parameters=parameters, columns_comments=columns_comments, mode=mode, catalog_versioning=catalog_versioning, transaction_id=transaction_id, athena_partition_projection_settings=athena_partition_projection_settings, boto3_session=boto3_session, catalog_table_input=catalog_table_input)

    def _add_glue_partitions(self, database: str, table: str, partitions_values: Dict[str, List[str]], bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, boto3_session: Optional[boto3.Session]=None, columns_types: Optional[Dict[str, str]]=None, partitions_parameters: Optional[Dict[str, str]]=None) -> None:
        if False:
            return 10
        return catalog.add_parquet_partitions(database=database, table=table, partitions_values=partitions_values, bucketing_info=bucketing_info, compression=compression, boto3_session=boto3_session, catalog_id=catalog_id, columns_types=columns_types, partitions_parameters=partitions_parameters)

@apply_configs
@_utils.validate_distributed_kwargs(unsupported_kwargs=['boto3_session', 's3_additional_kwargs'])
def to_parquet(df: pd.DataFrame, path: Optional[str]=None, index: bool=False, compression: Optional[str]='snappy', pyarrow_additional_kwargs: Optional[Dict[str, Any]]=None, max_rows_by_file: Optional[int]=None, use_threads: Union[bool, int]=True, boto3_session: Optional[boto3.Session]=None, s3_additional_kwargs: Optional[Dict[str, Any]]=None, sanitize_columns: bool=False, dataset: bool=False, filename_prefix: Optional[str]=None, partition_cols: Optional[List[str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, concurrent_partitioning: bool=False, mode: Optional[Literal['append', 'overwrite', 'overwrite_partitions']]=None, catalog_versioning: bool=False, schema_evolution: bool=True, database: Optional[str]=None, table: Optional[str]=None, glue_table_settings: Optional[GlueTableSettings]=None, dtype: Optional[Dict[str, str]]=None, athena_partition_projection_settings: Optional[typing.AthenaPartitionProjectionSettings]=None, catalog_id: Optional[str]=None) -> _S3WriteDataReturnValue:
    if False:
        print('Hello World!')
    'Write Parquet file or dataset on Amazon S3.\n\n    The concept of Dataset goes beyond the simple idea of ordinary files and enable more\n    complex features like partitioning and catalog integration (Amazon Athena/AWS Glue Catalog).\n\n    Note\n    ----\n    This operation may mutate the original pandas DataFrame in-place. To avoid this behaviour\n    please pass in a deep copy instead (i.e. `df.copy()`)\n\n    Note\n    ----\n    If `database` and `table` arguments are passed, the table name and all column names\n    will be automatically sanitized using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`.\n    Please, pass `sanitize_columns=True` to enforce this behaviour always.\n\n    Note\n    ----\n    In case of `use_threads=True` the number of threads\n    that will be spawned will be gotten from os.cpu_count().\n\n    Parameters\n    ----------\n    df: pandas.DataFrame\n        Pandas DataFrame https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html\n    path : str, optional\n        S3 path (for file e.g. ``s3://bucket/prefix/filename.parquet``) (for dataset e.g. ``s3://bucket/prefix``).\n        Required if dataset=False or when dataset=True and creating a new dataset\n    index : bool\n        True to store the DataFrame index in file, otherwise False to ignore it.\n        Is not supported in conjunction with `max_rows_by_file` when running the library with Ray/Modin.\n    compression: str, optional\n        Compression style (``None``, ``snappy``, ``gzip``, ``zstd``).\n    pyarrow_additional_kwargs : Optional[Dict[str, Any]]\n        Additional parameters forwarded to pyarrow.\n        e.g. pyarrow_additional_kwargs={\'coerce_timestamps\': \'ns\', \'use_deprecated_int96_timestamps\': False,\n        \'allow_truncated_timestamps\'=False}\n    max_rows_by_file : int\n        Max number of rows in each file.\n        Default is None i.e. don\'t split the files.\n        (e.g. 33554432, 268435456)\n        Is not supported in conjunction with `index=True` when running the library with Ray/Modin.\n    use_threads : bool, int\n        True to enable concurrent requests, False to disable multiple threads.\n        If enabled os.cpu_count() will be used as the max number of threads.\n        If integer is provided, specified number is used.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n    s3_additional_kwargs : Optional[Dict[str, Any]]\n        Forwarded to botocore requests.\n        e.g. s3_additional_kwargs={\'ServerSideEncryption\': \'aws:kms\', \'SSEKMSKeyId\': \'YOUR_KMS_KEY_ARN\'}\n    sanitize_columns : bool\n        True to sanitize columns names (using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`)\n        or False to keep it as is.\n        True value behaviour is enforced if `database` and `table` arguments are passed.\n    dataset : bool\n        If True store a parquet dataset instead of a ordinary file(s)\n        If True, enable all follow arguments:\n        partition_cols, mode, database, table, description, parameters, columns_comments, concurrent_partitioning,\n        catalog_versioning, projection_params, catalog_id, schema_evolution.\n    filename_prefix: str, optional\n        If dataset=True, add a filename prefix to the output files.\n    partition_cols: List[str], optional\n        List of column names that will be used to create partitions. Only takes effect if dataset=True.\n    bucketing_info: Tuple[List[str], int], optional\n        Tuple consisting of the column names used for bucketing as the first element and the number of buckets as the\n        second element.\n        Only `str`, `int` and `bool` are supported as column data types for bucketing.\n    concurrent_partitioning: bool\n        If True will increase the parallelism level during the partitions writing. It will decrease the\n        writing time and increase the memory usage.\n        https://aws-sdk-pandas.readthedocs.io/en/3.4.2/tutorials/022%20-%20Writing%20Partitions%20Concurrently.html\n    mode: str, optional\n        ``append`` (Default), ``overwrite``, ``overwrite_partitions``. Only takes effect if dataset=True.\n        For details check the related tutorial:\n        https://aws-sdk-pandas.readthedocs.io/en/3.4.2/tutorials/004%20-%20Parquet%20Datasets.html\n    catalog_versioning : bool\n        If True and `mode="overwrite"`, creates an archived version of the table catalog before updating it.\n    schema_evolution : bool\n        If True allows schema evolution (new or missing columns), otherwise a exception will be raised. True by default.\n        (Only considered if dataset=True and mode in ("append", "overwrite_partitions"))\n        Related tutorial:\n        https://aws-sdk-pandas.readthedocs.io/en/3.4.2/tutorials/014%20-%20Schema%20Evolution.html\n    database : str, optional\n        Glue/Athena catalog: Database name.\n    table : str, optional\n        Glue/Athena catalog: Table name.\n    glue_table_settings: dict (GlueTableSettings), optional\n        Settings for writing to the Glue table.\n    dtype : Dict[str, str], optional\n        Dictionary of columns names and Athena/Glue types to be casted.\n        Useful when you have columns with undetermined or mixed data types.\n        (e.g. {\'col name\': \'bigint\', \'col2 name\': \'int\'})\n    athena_partition_projection_settings: typing.AthenaPartitionProjectionSettings, optional\n        Parameters of the Athena Partition Projection\n        (https://docs.aws.amazon.com/athena/latest/ug/partition-projection.html).\n        AthenaPartitionProjectionSettings is a `TypedDict`, meaning the passed parameter can be instantiated either as\n        an instance of AthenaPartitionProjectionSettings or as a regular Python dict.\n\n        Following projection parameters are supported:\n\n        .. list-table:: Projection Parameters\n           :header-rows: 1\n\n           * - Name\n             - Type\n             - Description\n           * - projection_types\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections types.\n               Valid types: "enum", "integer", "date", "injected"\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'enum\', \'col2_name\': \'integer\'})\n           * - projection_ranges\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections ranges.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'0,10\', \'col2_name\': \'-1,8675309\'})\n           * - projection_values\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections values.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'A,B,Unknown\', \'col2_name\': \'foo,boo,bar\'})\n           * - projection_intervals\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections intervals.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'1\', \'col2_name\': \'5\'})\n           * - projection_digits\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections digits.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'1\', \'col2_name\': \'2\'})\n           * - projection_formats\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections formats.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_date\': \'yyyy-MM-dd\', \'col2_timestamp\': \'yyyy-MM-dd HH:mm:ss\'})\n           * - projection_storage_location_template\n             - Optional[str]\n             - Value which is allows Athena to properly map partition values if the S3 file locations do not follow\n               a typical `.../column=value/...` pattern.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-setting-up.html\n               (e.g. s3://bucket/table_root/a=${a}/${b}/some_static_subdirectory/${c}/)\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n\n    Returns\n    -------\n    wr.typing._S3WriteDataReturnValue\n        Dictionary with:\n        \'paths\': List of all stored files paths on S3.\n        \'partitions_values\': Dictionary of partitions added with keys as S3 path locations\n        and values as a list of partitions values as str.\n\n    Examples\n    --------\n    Writing single file\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_parquet(\n    ...     df=pd.DataFrame({\'col\': [1, 2, 3]}),\n    ...     path=\'s3://bucket/prefix/my_file.parquet\',\n    ... )\n    {\n        \'paths\': [\'s3://bucket/prefix/my_file.parquet\'],\n        \'partitions_values\': {}\n    }\n\n    Writing single file encrypted with a KMS key\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_parquet(\n    ...     df=pd.DataFrame({\'col\': [1, 2, 3]}),\n    ...     path=\'s3://bucket/prefix/my_file.parquet\',\n    ...     s3_additional_kwargs={\n    ...         \'ServerSideEncryption\': \'aws:kms\',\n    ...         \'SSEKMSKeyId\': \'YOUR_KMS_KEY_ARN\'\n    ...     }\n    ... )\n    {\n        \'paths\': [\'s3://bucket/prefix/my_file.parquet\'],\n        \'partitions_values\': {}\n    }\n\n    Writing partitioned dataset\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_parquet(\n    ...     df=pd.DataFrame({\n    ...         \'col\': [1, 2, 3],\n    ...         \'col2\': [\'A\', \'A\', \'B\']\n    ...     }),\n    ...     path=\'s3://bucket/prefix\',\n    ...     dataset=True,\n    ...     partition_cols=[\'col2\']\n    ... )\n    {\n        \'paths\': [\'s3://.../col2=A/x.parquet\', \'s3://.../col2=B/y.parquet\'],\n        \'partitions_values: {\n            \'s3://.../col2=A/\': [\'A\'],\n            \'s3://.../col2=B/\': [\'B\']\n        }\n    }\n\n    Writing partitioned dataset with partition projection\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> from datetime import datetime\n    >>> dt = lambda x: datetime.strptime(x, "%Y-%m-%d").date()\n    >>> wr.s3.to_parquet(\n    ...     df=pd.DataFrame({\n    ...         "id": [1, 2, 3],\n    ...         "value": [1000, 1001, 1002],\n    ...         "category": [\'A\', \'B\', \'C\'],\n    ...     }),\n    ...     path=\'s3://bucket/prefix\',\n    ...     dataset=True,\n    ...     partition_cols=[\'value\', \'category\'],\n    ...     athena_partition_projection_settings={\n    ...        "projection_types": {\n    ...             "value": "integer",\n    ...             "category": "enum",\n    ...         },\n    ...         "projection_ranges": {\n    ...             "value": "1000,2000",\n    ...             "category": "A,B,C",\n    ...         },\n    ...     },\n    ... )\n    {\n        \'paths\': [\n            \'s3://.../value=1000/category=A/x.snappy.parquet\', ...\n        ],\n        \'partitions_values\': {\n            \'s3://.../value=1000/category=A/\': [\n                \'1000\',\n                \'A\',\n            ], ...\n        }\n    }\n\n    Writing bucketed dataset\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_parquet(\n    ...     df=pd.DataFrame({\n    ...         \'col\': [1, 2, 3],\n    ...         \'col2\': [\'A\', \'A\', \'B\']\n    ...     }),\n    ...     path=\'s3://bucket/prefix\',\n    ...     dataset=True,\n    ...     bucketing_info=(["col2"], 2)\n    ... )\n    {\n        \'paths\': [\'s3://.../x_bucket-00000.csv\', \'s3://.../col2=B/x_bucket-00001.csv\'],\n        \'partitions_values: {}\n    }\n\n    Writing dataset to S3 with metadata on Athena/Glue Catalog.\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_parquet(\n    ...     df=pd.DataFrame({\n    ...         \'col\': [1, 2, 3],\n    ...         \'col2\': [\'A\', \'A\', \'B\']\n    ...     }),\n    ...     path=\'s3://bucket/prefix\',\n    ...     dataset=True,\n    ...     partition_cols=[\'col2\'],\n    ...     database=\'default\',  # Athena/Glue database\n    ...     table=\'my_table\'  # Athena/Glue table\n    ... )\n    {\n        \'paths\': [\'s3://.../col2=A/x.parquet\', \'s3://.../col2=B/y.parquet\'],\n        \'partitions_values: {\n            \'s3://.../col2=A/\': [\'A\'],\n            \'s3://.../col2=B/\': [\'B\']\n        }\n    }\n\n    Writing dataset to Glue governed table\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_parquet(\n    ...     df=pd.DataFrame({\n    ...         \'col\': [1, 2, 3],\n    ...         \'col2\': [\'A\', \'A\', \'B\'],\n    ...         \'col3\': [None, None, None]\n    ...     }),\n    ...     dataset=True,\n    ...     mode=\'append\',\n    ...     database=\'default\',  # Athena/Glue database\n    ...     table=\'my_table\',  # Athena/Glue table\n    ...     glue_table_settings=wr.typing.GlueTableSettings(\n    ...         table_type="GOVERNED",\n    ...         transaction_id="xxx",\n    ...     ),\n    ... )\n    {\n        \'paths\': [\'s3://.../x.parquet\'],\n        \'partitions_values: {}\n    }\n\n    Writing dataset casting empty column data type\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_parquet(\n    ...     df=pd.DataFrame({\n    ...         \'col\': [1, 2, 3],\n    ...         \'col2\': [\'A\', \'A\', \'B\'],\n    ...         \'col3\': [None, None, None]\n    ...     }),\n    ...     path=\'s3://bucket/prefix\',\n    ...     dataset=True,\n    ...     database=\'default\',  # Athena/Glue database\n    ...     table=\'my_table\'  # Athena/Glue table\n    ...     dtype={\'col3\': \'date\'}\n    ... )\n    {\n        \'paths\': [\'s3://.../x.parquet\'],\n        \'partitions_values: {}\n    }\n\n    '
    glue_table_settings = cast(GlueTableSettings, glue_table_settings if glue_table_settings else {})
    table_type = glue_table_settings.get('table_type')
    transaction_id = glue_table_settings.get('transaction_id')
    description = glue_table_settings.get('description')
    parameters = glue_table_settings.get('parameters')
    columns_comments = glue_table_settings.get('columns_comments')
    regular_partitions = glue_table_settings.get('regular_partitions', True)
    _validate_args(df=df, table=table, database=database, dataset=dataset, path=path, partition_cols=partition_cols, bucketing_info=bucketing_info, mode=mode, description=description, parameters=parameters, columns_comments=columns_comments, execution_engine=engine.get())
    if _COMPRESSION_2_EXT.get(compression, None) is None:
        raise exceptions.InvalidCompression(f"{compression} is invalid, please use None, 'snappy', 'gzip' or 'zstd'.")
    compression_ext: str = _COMPRESSION_2_EXT[compression]
    if not pyarrow_additional_kwargs:
        pyarrow_additional_kwargs = {}
    if not pyarrow_additional_kwargs.get('coerce_timestamps'):
        pyarrow_additional_kwargs['coerce_timestamps'] = 'ms'
    if 'flavor' not in pyarrow_additional_kwargs:
        pyarrow_additional_kwargs['flavor'] = 'spark'
    strategy = _S3ParquetWriteStrategy()
    return strategy.write(df=df, path=path, index=index, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, max_rows_by_file=max_rows_by_file, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, sanitize_columns=sanitize_columns, dataset=dataset, filename_prefix=filename_prefix, partition_cols=partition_cols, bucketing_info=bucketing_info, concurrent_partitioning=concurrent_partitioning, mode=mode, catalog_versioning=catalog_versioning, schema_evolution=schema_evolution, database=database, table=table, description=description, parameters=parameters, columns_comments=columns_comments, table_type=table_type, transaction_id=transaction_id, regular_partitions=regular_partitions, dtype=dtype, athena_partition_projection_settings=athena_partition_projection_settings, catalog_id=catalog_id, compression_ext=compression_ext)

@apply_configs
@_utils.validate_distributed_kwargs(unsupported_kwargs=['boto3_session'])
def store_parquet_metadata(path: str, database: str, table: str, catalog_id: Optional[str]=None, path_suffix: Optional[str]=None, path_ignore_suffix: Union[str, List[str], None]=None, ignore_empty: bool=True, ignore_null: bool=False, dtype: Optional[Dict[str, str]]=None, sampling: float=1.0, dataset: bool=False, use_threads: Union[bool, int]=True, description: Optional[str]=None, parameters: Optional[Dict[str, str]]=None, columns_comments: Optional[Dict[str, str]]=None, compression: Optional[str]=None, mode: Literal['append', 'overwrite']='overwrite', catalog_versioning: bool=False, regular_partitions: bool=True, athena_partition_projection_settings: Optional[typing.AthenaPartitionProjectionSettings]=None, s3_additional_kwargs: Optional[Dict[str, Any]]=None, boto3_session: Optional[boto3.Session]=None) -> Tuple[Dict[str, str], Optional[Dict[str, str]], Optional[Dict[str, List[str]]]]:
    if False:
        return 10
    'Infer and store parquet metadata on AWS Glue Catalog.\n\n    Infer Apache Parquet file(s) metadata from a received S3 prefix\n    And then stores it on AWS Glue Catalog including all inferred partitions\n    (No need for \'MSCK REPAIR TABLE\')\n\n    The concept of Dataset goes beyond the simple idea of files and enables more\n    complex features like partitioning and catalog integration (AWS Glue Catalog).\n\n    This function accepts Unix shell-style wildcards in the path argument.\n    * (matches everything), ? (matches any single character),\n    [seq] (matches any character in seq), [!seq] (matches any character not in seq).\n    If you want to use a path which includes Unix shell-style wildcard characters (`*, ?, []`),\n    you can use `glob.escape(path)` before passing the path to this function.\n\n    Note\n    ----\n    In case of `use_threads=True` the number of threads\n    that will be spawned will be gotten from os.cpu_count().\n\n    Parameters\n    ----------\n    path : str\n        S3 prefix (accepts Unix shell-style wildcards) (e.g. s3://bucket/prefix).\n    table : str\n        Glue/Athena catalog: Table name.\n    database : str\n        AWS Glue Catalog database name.\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n    path_suffix: Union[str, List[str], None]\n        Suffix or List of suffixes for filtering S3 keys.\n    path_ignore_suffix: Union[str, List[str], None]\n        Suffix or List of suffixes for S3 keys to be ignored.\n    ignore_empty: bool\n        Ignore files with 0 bytes.\n    ignore_null: bool\n        Ignore columns with null type.\n    dtype : Dict[str, str], optional\n        Dictionary of columns names and Athena/Glue types to be casted.\n        Useful when you have columns with undetermined data types as partitions columns.\n        (e.g. {\'col name\': \'bigint\', \'col2 name\': \'int\'})\n    sampling : float\n        Random sample ratio of files that will have the metadata inspected.\n        Must be `0.0 < sampling <= 1.0`.\n        The higher, the more accurate.\n        The lower, the faster.\n    dataset: bool\n        If True read a parquet dataset instead of simple file(s) loading all the related partitions as columns.\n    use_threads : bool, int\n        True to enable concurrent requests, False to disable multiple threads.\n        If enabled os.cpu_count() will be used as the max number of threads.\n        If integer is provided, specified number is used.\n    description: str, optional\n        Glue/Athena catalog: Table description\n    parameters: Dict[str, str], optional\n        Glue/Athena catalog: Key/value pairs to tag the table.\n    columns_comments: Dict[str, str], optional\n        Glue/Athena catalog:\n        Columns names and the related comments (e.g. {\'col0\': \'Column 0.\', \'col1\': \'Column 1.\', \'col2\': \'Partition.\'}).\n    compression: str, optional\n        Compression style (``None``, ``snappy``, ``gzip``, etc).\n    mode: str\n        \'overwrite\' to recreate any possible existing table or \'append\' to keep any possible existing table.\n    catalog_versioning : bool\n        If True and `mode="overwrite"`, creates an archived version of the table catalog before updating it.\n    regular_partitions : bool\n        Create regular partitions (Non projected partitions) on Glue Catalog.\n        Disable when you will work only with Partition Projection.\n        Keep enabled even when working with projections is useful to keep\n        Redshift Spectrum working with the regular partitions.\n    athena_partition_projection_settings: typing.AthenaPartitionProjectionSettings, optional\n        Parameters of the Athena Partition Projection\n        (https://docs.aws.amazon.com/athena/latest/ug/partition-projection.html).\n        AthenaPartitionProjectionSettings is a `TypedDict`, meaning the passed parameter can be instantiated either as\n        an instance of AthenaPartitionProjectionSettings or as a regular Python dict.\n\n        Following projection parameters are supported:\n\n        .. list-table:: Projection Parameters\n           :header-rows: 1\n\n           * - Name\n             - Type\n             - Description\n           * - projection_types\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections types.\n               Valid types: "enum", "integer", "date", "injected"\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'enum\', \'col2_name\': \'integer\'})\n           * - projection_ranges\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections ranges.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'0,10\', \'col2_name\': \'-1,8675309\'})\n           * - projection_values\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections values.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'A,B,Unknown\', \'col2_name\': \'foo,boo,bar\'})\n           * - projection_intervals\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections intervals.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'1\', \'col2_name\': \'5\'})\n           * - projection_digits\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections digits.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_name\': \'1\', \'col2_name\': \'2\'})\n           * - projection_formats\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections formats.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {\'col_date\': \'yyyy-MM-dd\', \'col2_timestamp\': \'yyyy-MM-dd HH:mm:ss\'})\n           * - projection_storage_location_template\n             - Optional[str]\n             - Value which is allows Athena to properly map partition values if the S3 file locations do not follow\n               a typical `.../column=value/...` pattern.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-setting-up.html\n               (e.g. s3://bucket/table_root/a=${a}/${b}/some_static_subdirectory/${c}/)\n    s3_additional_kwargs : Optional[Dict[str, Any]]\n        Forwarded to botocore requests.\n        e.g. s3_additional_kwargs={\'ServerSideEncryption\': \'aws:kms\', \'SSEKMSKeyId\': \'YOUR_KMS_KEY_ARN\'}\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n\n    Returns\n    -------\n    Tuple[Dict[str, str], Optional[Dict[str, str]], Optional[Dict[str, List[str]]]]\n        The metadata used to create the Glue Table.\n        columns_types: Dictionary with keys as column names and values as\n        data types (e.g. {\'col0\': \'bigint\', \'col1\': \'double\'}). /\n        partitions_types: Dictionary with keys as partition names\n        and values as data types (e.g. {\'col2\': \'date\'}). /\n        partitions_values: Dictionary with keys as S3 path locations and values as a\n        list of partitions values as str (e.g. {\'s3://bucket/prefix/y=2020/m=10/\': [\'2020\', \'10\']}).\n\n    Examples\n    --------\n    Reading all Parquet files metadata under a prefix\n\n    >>> import awswrangler as wr\n    >>> columns_types, partitions_types, partitions_values = wr.s3.store_parquet_metadata(\n    ...     path=\'s3://bucket/prefix/\',\n    ...     database=\'...\',\n    ...     table=\'...\',\n    ...     dataset=True\n    ... )\n\n    '
    columns_types: Dict[str, str]
    partitions_types: Optional[Dict[str, str]]
    partitions_values: Optional[Dict[str, List[str]]]
    (columns_types, partitions_types, partitions_values) = _read_parquet_metadata(path=path, dtype=dtype, sampling=sampling, dataset=dataset, path_suffix=path_suffix, path_ignore_suffix=path_ignore_suffix, ignore_empty=ignore_empty, ignore_null=ignore_null, use_threads=use_threads, s3_additional_kwargs=s3_additional_kwargs, boto3_session=boto3_session)
    _logger.debug('Resolved columns_types: %s', columns_types)
    _logger.debug('Resolved partitions_types: %s', partitions_types)
    _logger.debug('Resolved partitions_values: %s', partitions_values)
    catalog.create_parquet_table(database=database, table=table, path=path, columns_types=columns_types, partitions_types=partitions_types, description=description, parameters=parameters, columns_comments=columns_comments, mode=mode, compression=compression, catalog_versioning=catalog_versioning, athena_partition_projection_settings=athena_partition_projection_settings, boto3_session=boto3_session, catalog_id=catalog_id)
    if partitions_types is not None and partitions_values is not None and (regular_partitions is True):
        catalog.add_parquet_partitions(database=database, table=table, partitions_values=partitions_values, compression=compression, boto3_session=boto3_session, catalog_id=catalog_id, columns_types=columns_types)
    return (columns_types, partitions_types, partitions_values)