[
    {
        "func_name": "comp_purity",
        "original": "def comp_purity(p_xy, axis):\n    max_p = p_xy.max(axis=axis)\n    marg_p = p_xy.sum(axis=axis)\n    indv_pur = max_p / marg_p\n    aggr_pur = max_p.sum()\n    return (indv_pur, aggr_pur)",
        "mutated": [
            "def comp_purity(p_xy, axis):\n    if False:\n        i = 10\n    max_p = p_xy.max(axis=axis)\n    marg_p = p_xy.sum(axis=axis)\n    indv_pur = max_p / marg_p\n    aggr_pur = max_p.sum()\n    return (indv_pur, aggr_pur)",
            "def comp_purity(p_xy, axis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    max_p = p_xy.max(axis=axis)\n    marg_p = p_xy.sum(axis=axis)\n    indv_pur = max_p / marg_p\n    aggr_pur = max_p.sum()\n    return (indv_pur, aggr_pur)",
            "def comp_purity(p_xy, axis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    max_p = p_xy.max(axis=axis)\n    marg_p = p_xy.sum(axis=axis)\n    indv_pur = max_p / marg_p\n    aggr_pur = max_p.sum()\n    return (indv_pur, aggr_pur)",
            "def comp_purity(p_xy, axis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    max_p = p_xy.max(axis=axis)\n    marg_p = p_xy.sum(axis=axis)\n    indv_pur = max_p / marg_p\n    aggr_pur = max_p.sum()\n    return (indv_pur, aggr_pur)",
            "def comp_purity(p_xy, axis):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    max_p = p_xy.max(axis=axis)\n    marg_p = p_xy.sum(axis=axis)\n    indv_pur = max_p / marg_p\n    aggr_pur = max_p.sum()\n    return (indv_pur, aggr_pur)"
        ]
    },
    {
        "func_name": "comp_entropy",
        "original": "def comp_entropy(p):\n    return (-p * np.log(p + 1e-08)).sum()",
        "mutated": [
            "def comp_entropy(p):\n    if False:\n        i = 10\n    return (-p * np.log(p + 1e-08)).sum()",
            "def comp_entropy(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return (-p * np.log(p + 1e-08)).sum()",
            "def comp_entropy(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return (-p * np.log(p + 1e-08)).sum()",
            "def comp_entropy(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return (-p * np.log(p + 1e-08)).sum()",
            "def comp_entropy(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return (-p * np.log(p + 1e-08)).sum()"
        ]
    },
    {
        "func_name": "comp_norm_mutual_info",
        "original": "def comp_norm_mutual_info(p_xy):\n    p_x = p_xy.sum(axis=1, keepdims=True)\n    p_y = p_xy.sum(axis=0, keepdims=True)\n    pmi = np.log(p_xy / np.matmul(p_x, p_y) + 1e-08)\n    mi = (p_xy * pmi).sum()\n    h_x = comp_entropy(p_x)\n    h_y = comp_entropy(p_y)\n    return (mi, mi / h_x, mi / h_y, h_x, h_y)",
        "mutated": [
            "def comp_norm_mutual_info(p_xy):\n    if False:\n        i = 10\n    p_x = p_xy.sum(axis=1, keepdims=True)\n    p_y = p_xy.sum(axis=0, keepdims=True)\n    pmi = np.log(p_xy / np.matmul(p_x, p_y) + 1e-08)\n    mi = (p_xy * pmi).sum()\n    h_x = comp_entropy(p_x)\n    h_y = comp_entropy(p_y)\n    return (mi, mi / h_x, mi / h_y, h_x, h_y)",
            "def comp_norm_mutual_info(p_xy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    p_x = p_xy.sum(axis=1, keepdims=True)\n    p_y = p_xy.sum(axis=0, keepdims=True)\n    pmi = np.log(p_xy / np.matmul(p_x, p_y) + 1e-08)\n    mi = (p_xy * pmi).sum()\n    h_x = comp_entropy(p_x)\n    h_y = comp_entropy(p_y)\n    return (mi, mi / h_x, mi / h_y, h_x, h_y)",
            "def comp_norm_mutual_info(p_xy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    p_x = p_xy.sum(axis=1, keepdims=True)\n    p_y = p_xy.sum(axis=0, keepdims=True)\n    pmi = np.log(p_xy / np.matmul(p_x, p_y) + 1e-08)\n    mi = (p_xy * pmi).sum()\n    h_x = comp_entropy(p_x)\n    h_y = comp_entropy(p_y)\n    return (mi, mi / h_x, mi / h_y, h_x, h_y)",
            "def comp_norm_mutual_info(p_xy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    p_x = p_xy.sum(axis=1, keepdims=True)\n    p_y = p_xy.sum(axis=0, keepdims=True)\n    pmi = np.log(p_xy / np.matmul(p_x, p_y) + 1e-08)\n    mi = (p_xy * pmi).sum()\n    h_x = comp_entropy(p_x)\n    h_y = comp_entropy(p_y)\n    return (mi, mi / h_x, mi / h_y, h_x, h_y)",
            "def comp_norm_mutual_info(p_xy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    p_x = p_xy.sum(axis=1, keepdims=True)\n    p_y = p_xy.sum(axis=0, keepdims=True)\n    pmi = np.log(p_xy / np.matmul(p_x, p_y) + 1e-08)\n    mi = (p_xy * pmi).sum()\n    h_x = comp_entropy(p_x)\n    h_y = comp_entropy(p_y)\n    return (mi, mi / h_x, mi / h_y, h_x, h_y)"
        ]
    },
    {
        "func_name": "pad",
        "original": "def pad(labs, n):\n    if n == 0:\n        return np.array(labs)\n    return np.concatenate([[labs[0]] * n, labs, [labs[-1]] * n])",
        "mutated": [
            "def pad(labs, n):\n    if False:\n        i = 10\n    if n == 0:\n        return np.array(labs)\n    return np.concatenate([[labs[0]] * n, labs, [labs[-1]] * n])",
            "def pad(labs, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if n == 0:\n        return np.array(labs)\n    return np.concatenate([[labs[0]] * n, labs, [labs[-1]] * n])",
            "def pad(labs, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if n == 0:\n        return np.array(labs)\n    return np.concatenate([[labs[0]] * n, labs, [labs[-1]] * n])",
            "def pad(labs, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if n == 0:\n        return np.array(labs)\n    return np.concatenate([[labs[0]] * n, labs, [labs[-1]] * n])",
            "def pad(labs, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if n == 0:\n        return np.array(labs)\n    return np.concatenate([[labs[0]] * n, labs, [labs[-1]] * n])"
        ]
    },
    {
        "func_name": "comp_avg_seg_dur",
        "original": "def comp_avg_seg_dur(labs_list):\n    n_frms = 0\n    n_segs = 0\n    for labs in labs_list:\n        labs = np.array(labs)\n        edges = np.zeros(len(labs)).astype(bool)\n        edges[0] = True\n        edges[1:] = labs[1:] != labs[:-1]\n        n_frms += len(edges)\n        n_segs += edges.astype(int).sum()\n    return n_frms / n_segs",
        "mutated": [
            "def comp_avg_seg_dur(labs_list):\n    if False:\n        i = 10\n    n_frms = 0\n    n_segs = 0\n    for labs in labs_list:\n        labs = np.array(labs)\n        edges = np.zeros(len(labs)).astype(bool)\n        edges[0] = True\n        edges[1:] = labs[1:] != labs[:-1]\n        n_frms += len(edges)\n        n_segs += edges.astype(int).sum()\n    return n_frms / n_segs",
            "def comp_avg_seg_dur(labs_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n_frms = 0\n    n_segs = 0\n    for labs in labs_list:\n        labs = np.array(labs)\n        edges = np.zeros(len(labs)).astype(bool)\n        edges[0] = True\n        edges[1:] = labs[1:] != labs[:-1]\n        n_frms += len(edges)\n        n_segs += edges.astype(int).sum()\n    return n_frms / n_segs",
            "def comp_avg_seg_dur(labs_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n_frms = 0\n    n_segs = 0\n    for labs in labs_list:\n        labs = np.array(labs)\n        edges = np.zeros(len(labs)).astype(bool)\n        edges[0] = True\n        edges[1:] = labs[1:] != labs[:-1]\n        n_frms += len(edges)\n        n_segs += edges.astype(int).sum()\n    return n_frms / n_segs",
            "def comp_avg_seg_dur(labs_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n_frms = 0\n    n_segs = 0\n    for labs in labs_list:\n        labs = np.array(labs)\n        edges = np.zeros(len(labs)).astype(bool)\n        edges[0] = True\n        edges[1:] = labs[1:] != labs[:-1]\n        n_frms += len(edges)\n        n_segs += edges.astype(int).sum()\n    return n_frms / n_segs",
            "def comp_avg_seg_dur(labs_list):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n_frms = 0\n    n_segs = 0\n    for labs in labs_list:\n        labs = np.array(labs)\n        edges = np.zeros(len(labs)).astype(bool)\n        edges[0] = True\n        edges[1:] = labs[1:] != labs[:-1]\n        n_frms += len(edges)\n        n_segs += edges.astype(int).sum()\n    return n_frms / n_segs"
        ]
    },
    {
        "func_name": "comp_joint_prob",
        "original": "def comp_joint_prob(uid2refs, uid2hyps):\n    \"\"\"\n    Args:\n        pad: padding for spliced-feature derived labels\n    \"\"\"\n    cnts = Counter()\n    skipped = []\n    abs_frmdiff = 0\n    for uid in uid2refs:\n        if uid not in uid2hyps:\n            skipped.append(uid)\n            continue\n        refs = uid2refs[uid]\n        hyps = uid2hyps[uid]\n        abs_frmdiff += abs(len(refs) - len(hyps))\n        min_len = min(len(refs), len(hyps))\n        refs = refs[:min_len]\n        hyps = hyps[:min_len]\n        cnts.update(zip(refs, hyps))\n    tot = sum(cnts.values())\n    ref_set = sorted({ref for (ref, _) in cnts.keys()})\n    hyp_set = sorted({hyp for (_, hyp) in cnts.keys()})\n    ref2pid = dict(zip(ref_set, range(len(ref_set))))\n    hyp2lid = dict(zip(hyp_set, range(len(hyp_set))))\n    p_xy = np.zeros((len(ref2pid), len(hyp2lid)), dtype=float)\n    for ((ref, hyp), cnt) in cnts.items():\n        p_xy[ref2pid[ref], hyp2lid[hyp]] = cnt\n    p_xy /= p_xy.sum()\n    return (p_xy, ref2pid, hyp2lid, tot, abs_frmdiff, skipped)",
        "mutated": [
            "def comp_joint_prob(uid2refs, uid2hyps):\n    if False:\n        i = 10\n    '\\n    Args:\\n        pad: padding for spliced-feature derived labels\\n    '\n    cnts = Counter()\n    skipped = []\n    abs_frmdiff = 0\n    for uid in uid2refs:\n        if uid not in uid2hyps:\n            skipped.append(uid)\n            continue\n        refs = uid2refs[uid]\n        hyps = uid2hyps[uid]\n        abs_frmdiff += abs(len(refs) - len(hyps))\n        min_len = min(len(refs), len(hyps))\n        refs = refs[:min_len]\n        hyps = hyps[:min_len]\n        cnts.update(zip(refs, hyps))\n    tot = sum(cnts.values())\n    ref_set = sorted({ref for (ref, _) in cnts.keys()})\n    hyp_set = sorted({hyp for (_, hyp) in cnts.keys()})\n    ref2pid = dict(zip(ref_set, range(len(ref_set))))\n    hyp2lid = dict(zip(hyp_set, range(len(hyp_set))))\n    p_xy = np.zeros((len(ref2pid), len(hyp2lid)), dtype=float)\n    for ((ref, hyp), cnt) in cnts.items():\n        p_xy[ref2pid[ref], hyp2lid[hyp]] = cnt\n    p_xy /= p_xy.sum()\n    return (p_xy, ref2pid, hyp2lid, tot, abs_frmdiff, skipped)",
            "def comp_joint_prob(uid2refs, uid2hyps):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Args:\\n        pad: padding for spliced-feature derived labels\\n    '\n    cnts = Counter()\n    skipped = []\n    abs_frmdiff = 0\n    for uid in uid2refs:\n        if uid not in uid2hyps:\n            skipped.append(uid)\n            continue\n        refs = uid2refs[uid]\n        hyps = uid2hyps[uid]\n        abs_frmdiff += abs(len(refs) - len(hyps))\n        min_len = min(len(refs), len(hyps))\n        refs = refs[:min_len]\n        hyps = hyps[:min_len]\n        cnts.update(zip(refs, hyps))\n    tot = sum(cnts.values())\n    ref_set = sorted({ref for (ref, _) in cnts.keys()})\n    hyp_set = sorted({hyp for (_, hyp) in cnts.keys()})\n    ref2pid = dict(zip(ref_set, range(len(ref_set))))\n    hyp2lid = dict(zip(hyp_set, range(len(hyp_set))))\n    p_xy = np.zeros((len(ref2pid), len(hyp2lid)), dtype=float)\n    for ((ref, hyp), cnt) in cnts.items():\n        p_xy[ref2pid[ref], hyp2lid[hyp]] = cnt\n    p_xy /= p_xy.sum()\n    return (p_xy, ref2pid, hyp2lid, tot, abs_frmdiff, skipped)",
            "def comp_joint_prob(uid2refs, uid2hyps):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Args:\\n        pad: padding for spliced-feature derived labels\\n    '\n    cnts = Counter()\n    skipped = []\n    abs_frmdiff = 0\n    for uid in uid2refs:\n        if uid not in uid2hyps:\n            skipped.append(uid)\n            continue\n        refs = uid2refs[uid]\n        hyps = uid2hyps[uid]\n        abs_frmdiff += abs(len(refs) - len(hyps))\n        min_len = min(len(refs), len(hyps))\n        refs = refs[:min_len]\n        hyps = hyps[:min_len]\n        cnts.update(zip(refs, hyps))\n    tot = sum(cnts.values())\n    ref_set = sorted({ref for (ref, _) in cnts.keys()})\n    hyp_set = sorted({hyp for (_, hyp) in cnts.keys()})\n    ref2pid = dict(zip(ref_set, range(len(ref_set))))\n    hyp2lid = dict(zip(hyp_set, range(len(hyp_set))))\n    p_xy = np.zeros((len(ref2pid), len(hyp2lid)), dtype=float)\n    for ((ref, hyp), cnt) in cnts.items():\n        p_xy[ref2pid[ref], hyp2lid[hyp]] = cnt\n    p_xy /= p_xy.sum()\n    return (p_xy, ref2pid, hyp2lid, tot, abs_frmdiff, skipped)",
            "def comp_joint_prob(uid2refs, uid2hyps):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Args:\\n        pad: padding for spliced-feature derived labels\\n    '\n    cnts = Counter()\n    skipped = []\n    abs_frmdiff = 0\n    for uid in uid2refs:\n        if uid not in uid2hyps:\n            skipped.append(uid)\n            continue\n        refs = uid2refs[uid]\n        hyps = uid2hyps[uid]\n        abs_frmdiff += abs(len(refs) - len(hyps))\n        min_len = min(len(refs), len(hyps))\n        refs = refs[:min_len]\n        hyps = hyps[:min_len]\n        cnts.update(zip(refs, hyps))\n    tot = sum(cnts.values())\n    ref_set = sorted({ref for (ref, _) in cnts.keys()})\n    hyp_set = sorted({hyp for (_, hyp) in cnts.keys()})\n    ref2pid = dict(zip(ref_set, range(len(ref_set))))\n    hyp2lid = dict(zip(hyp_set, range(len(hyp_set))))\n    p_xy = np.zeros((len(ref2pid), len(hyp2lid)), dtype=float)\n    for ((ref, hyp), cnt) in cnts.items():\n        p_xy[ref2pid[ref], hyp2lid[hyp]] = cnt\n    p_xy /= p_xy.sum()\n    return (p_xy, ref2pid, hyp2lid, tot, abs_frmdiff, skipped)",
            "def comp_joint_prob(uid2refs, uid2hyps):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Args:\\n        pad: padding for spliced-feature derived labels\\n    '\n    cnts = Counter()\n    skipped = []\n    abs_frmdiff = 0\n    for uid in uid2refs:\n        if uid not in uid2hyps:\n            skipped.append(uid)\n            continue\n        refs = uid2refs[uid]\n        hyps = uid2hyps[uid]\n        abs_frmdiff += abs(len(refs) - len(hyps))\n        min_len = min(len(refs), len(hyps))\n        refs = refs[:min_len]\n        hyps = hyps[:min_len]\n        cnts.update(zip(refs, hyps))\n    tot = sum(cnts.values())\n    ref_set = sorted({ref for (ref, _) in cnts.keys()})\n    hyp_set = sorted({hyp for (_, hyp) in cnts.keys()})\n    ref2pid = dict(zip(ref_set, range(len(ref_set))))\n    hyp2lid = dict(zip(hyp_set, range(len(hyp_set))))\n    p_xy = np.zeros((len(ref2pid), len(hyp2lid)), dtype=float)\n    for ((ref, hyp), cnt) in cnts.items():\n        p_xy[ref2pid[ref], hyp2lid[hyp]] = cnt\n    p_xy /= p_xy.sum()\n    return (p_xy, ref2pid, hyp2lid, tot, abs_frmdiff, skipped)"
        ]
    },
    {
        "func_name": "read_phn",
        "original": "def read_phn(tsv_path, rm_stress=True):\n    uid2phns = {}\n    with open(tsv_path) as f:\n        for line in f:\n            (uid, phns) = line.rstrip().split('\\t')\n            phns = phns.split(',')\n            if rm_stress:\n                phns = [re.sub('[0-9]', '', phn) for phn in phns]\n            uid2phns[uid] = phns\n    return uid2phns",
        "mutated": [
            "def read_phn(tsv_path, rm_stress=True):\n    if False:\n        i = 10\n    uid2phns = {}\n    with open(tsv_path) as f:\n        for line in f:\n            (uid, phns) = line.rstrip().split('\\t')\n            phns = phns.split(',')\n            if rm_stress:\n                phns = [re.sub('[0-9]', '', phn) for phn in phns]\n            uid2phns[uid] = phns\n    return uid2phns",
            "def read_phn(tsv_path, rm_stress=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    uid2phns = {}\n    with open(tsv_path) as f:\n        for line in f:\n            (uid, phns) = line.rstrip().split('\\t')\n            phns = phns.split(',')\n            if rm_stress:\n                phns = [re.sub('[0-9]', '', phn) for phn in phns]\n            uid2phns[uid] = phns\n    return uid2phns",
            "def read_phn(tsv_path, rm_stress=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    uid2phns = {}\n    with open(tsv_path) as f:\n        for line in f:\n            (uid, phns) = line.rstrip().split('\\t')\n            phns = phns.split(',')\n            if rm_stress:\n                phns = [re.sub('[0-9]', '', phn) for phn in phns]\n            uid2phns[uid] = phns\n    return uid2phns",
            "def read_phn(tsv_path, rm_stress=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    uid2phns = {}\n    with open(tsv_path) as f:\n        for line in f:\n            (uid, phns) = line.rstrip().split('\\t')\n            phns = phns.split(',')\n            if rm_stress:\n                phns = [re.sub('[0-9]', '', phn) for phn in phns]\n            uid2phns[uid] = phns\n    return uid2phns",
            "def read_phn(tsv_path, rm_stress=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    uid2phns = {}\n    with open(tsv_path) as f:\n        for line in f:\n            (uid, phns) = line.rstrip().split('\\t')\n            phns = phns.split(',')\n            if rm_stress:\n                phns = [re.sub('[0-9]', '', phn) for phn in phns]\n            uid2phns[uid] = phns\n    return uid2phns"
        ]
    },
    {
        "func_name": "read_lab",
        "original": "def read_lab(tsv_path, lab_path, pad_len=0, upsample=1):\n    \"\"\"\n    tsv is needed to retrieve the uids for the labels\n    \"\"\"\n    with open(tsv_path) as f:\n        f.readline()\n        uids = [op.splitext(op.basename(line.rstrip().split()[0]))[0] for line in f]\n    with open(lab_path) as f:\n        labs_list = [pad(line.rstrip().split(), pad_len).repeat(upsample) for line in f]\n    assert len(uids) == len(labs_list)\n    return dict(zip(uids, labs_list))",
        "mutated": [
            "def read_lab(tsv_path, lab_path, pad_len=0, upsample=1):\n    if False:\n        i = 10\n    '\\n    tsv is needed to retrieve the uids for the labels\\n    '\n    with open(tsv_path) as f:\n        f.readline()\n        uids = [op.splitext(op.basename(line.rstrip().split()[0]))[0] for line in f]\n    with open(lab_path) as f:\n        labs_list = [pad(line.rstrip().split(), pad_len).repeat(upsample) for line in f]\n    assert len(uids) == len(labs_list)\n    return dict(zip(uids, labs_list))",
            "def read_lab(tsv_path, lab_path, pad_len=0, upsample=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    tsv is needed to retrieve the uids for the labels\\n    '\n    with open(tsv_path) as f:\n        f.readline()\n        uids = [op.splitext(op.basename(line.rstrip().split()[0]))[0] for line in f]\n    with open(lab_path) as f:\n        labs_list = [pad(line.rstrip().split(), pad_len).repeat(upsample) for line in f]\n    assert len(uids) == len(labs_list)\n    return dict(zip(uids, labs_list))",
            "def read_lab(tsv_path, lab_path, pad_len=0, upsample=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    tsv is needed to retrieve the uids for the labels\\n    '\n    with open(tsv_path) as f:\n        f.readline()\n        uids = [op.splitext(op.basename(line.rstrip().split()[0]))[0] for line in f]\n    with open(lab_path) as f:\n        labs_list = [pad(line.rstrip().split(), pad_len).repeat(upsample) for line in f]\n    assert len(uids) == len(labs_list)\n    return dict(zip(uids, labs_list))",
            "def read_lab(tsv_path, lab_path, pad_len=0, upsample=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    tsv is needed to retrieve the uids for the labels\\n    '\n    with open(tsv_path) as f:\n        f.readline()\n        uids = [op.splitext(op.basename(line.rstrip().split()[0]))[0] for line in f]\n    with open(lab_path) as f:\n        labs_list = [pad(line.rstrip().split(), pad_len).repeat(upsample) for line in f]\n    assert len(uids) == len(labs_list)\n    return dict(zip(uids, labs_list))",
            "def read_lab(tsv_path, lab_path, pad_len=0, upsample=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    tsv is needed to retrieve the uids for the labels\\n    '\n    with open(tsv_path) as f:\n        f.readline()\n        uids = [op.splitext(op.basename(line.rstrip().split()[0]))[0] for line in f]\n    with open(lab_path) as f:\n        labs_list = [pad(line.rstrip().split(), pad_len).repeat(upsample) for line in f]\n    assert len(uids) == len(labs_list)\n    return dict(zip(uids, labs_list))"
        ]
    },
    {
        "func_name": "main_lab_lab",
        "original": "def main_lab_lab(tsv_dir, lab_dir, lab_name, lab_sets, ref_dir, ref_name, pad_len=0, upsample=1, verbose=False):\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    uid2refs = {}\n    for s in lab_sets:\n        uid2refs.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{ref_dir}/{s}.{ref_name}'))\n    uid2hyps = {}\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
        "mutated": [
            "def main_lab_lab(tsv_dir, lab_dir, lab_name, lab_sets, ref_dir, ref_name, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    uid2refs = {}\n    for s in lab_sets:\n        uid2refs.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{ref_dir}/{s}.{ref_name}'))\n    uid2hyps = {}\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
            "def main_lab_lab(tsv_dir, lab_dir, lab_name, lab_sets, ref_dir, ref_name, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    uid2refs = {}\n    for s in lab_sets:\n        uid2refs.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{ref_dir}/{s}.{ref_name}'))\n    uid2hyps = {}\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
            "def main_lab_lab(tsv_dir, lab_dir, lab_name, lab_sets, ref_dir, ref_name, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    uid2refs = {}\n    for s in lab_sets:\n        uid2refs.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{ref_dir}/{s}.{ref_name}'))\n    uid2hyps = {}\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
            "def main_lab_lab(tsv_dir, lab_dir, lab_name, lab_sets, ref_dir, ref_name, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    uid2refs = {}\n    for s in lab_sets:\n        uid2refs.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{ref_dir}/{s}.{ref_name}'))\n    uid2hyps = {}\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
            "def main_lab_lab(tsv_dir, lab_dir, lab_name, lab_sets, ref_dir, ref_name, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    uid2refs = {}\n    for s in lab_sets:\n        uid2refs.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{ref_dir}/{s}.{ref_name}'))\n    uid2hyps = {}\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)"
        ]
    },
    {
        "func_name": "main_phn_lab",
        "original": "def main_phn_lab(tsv_dir, lab_dir, lab_name, lab_sets, phn_dir, phn_sets, pad_len=0, upsample=1, verbose=False):\n    uid2refs = {}\n    for s in phn_sets:\n        uid2refs.update(read_phn(f'{phn_dir}/{s}.tsv'))\n    uid2hyps = {}\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
        "mutated": [
            "def main_phn_lab(tsv_dir, lab_dir, lab_name, lab_sets, phn_dir, phn_sets, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n    uid2refs = {}\n    for s in phn_sets:\n        uid2refs.update(read_phn(f'{phn_dir}/{s}.tsv'))\n    uid2hyps = {}\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
            "def main_phn_lab(tsv_dir, lab_dir, lab_name, lab_sets, phn_dir, phn_sets, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    uid2refs = {}\n    for s in phn_sets:\n        uid2refs.update(read_phn(f'{phn_dir}/{s}.tsv'))\n    uid2hyps = {}\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
            "def main_phn_lab(tsv_dir, lab_dir, lab_name, lab_sets, phn_dir, phn_sets, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    uid2refs = {}\n    for s in phn_sets:\n        uid2refs.update(read_phn(f'{phn_dir}/{s}.tsv'))\n    uid2hyps = {}\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
            "def main_phn_lab(tsv_dir, lab_dir, lab_name, lab_sets, phn_dir, phn_sets, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    uid2refs = {}\n    for s in phn_sets:\n        uid2refs.update(read_phn(f'{phn_dir}/{s}.tsv'))\n    uid2hyps = {}\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)",
            "def main_phn_lab(tsv_dir, lab_dir, lab_name, lab_sets, phn_dir, phn_sets, pad_len=0, upsample=1, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    uid2refs = {}\n    for s in phn_sets:\n        uid2refs.update(read_phn(f'{phn_dir}/{s}.tsv'))\n    uid2hyps = {}\n    tsv_dir = lab_dir if tsv_dir is None else tsv_dir\n    for s in lab_sets:\n        uid2hyps.update(read_lab(f'{tsv_dir}/{s}.tsv', f'{lab_dir}/{s}.{lab_name}', pad_len, upsample))\n    _main(uid2refs, uid2hyps, verbose)"
        ]
    },
    {
        "func_name": "_main",
        "original": "def _main(uid2refs, uid2hyps, verbose):\n    (p_xy, ref2pid, hyp2lid, tot, frmdiff, skipped) = comp_joint_prob(uid2refs, uid2hyps)\n    (ref_pur_by_hyp, ref_pur) = comp_purity(p_xy, axis=0)\n    (hyp_pur_by_ref, hyp_pur) = comp_purity(p_xy, axis=1)\n    (mi, mi_norm_by_ref, mi_norm_by_hyp, h_ref, h_hyp) = comp_norm_mutual_info(p_xy)\n    outputs = {'ref pur': ref_pur, 'hyp pur': hyp_pur, 'H(ref)': h_ref, 'H(hyp)': h_hyp, 'MI': mi, 'MI/H(ref)': mi_norm_by_ref, 'ref segL': comp_avg_seg_dur(uid2refs.values()), 'hyp segL': comp_avg_seg_dur(uid2hyps.values()), 'p_xy shape': p_xy.shape, 'frm tot': tot, 'frm diff': frmdiff, 'utt tot': len(uid2refs), 'utt miss': len(skipped)}\n    print(tabulate([outputs.values()], outputs.keys(), floatfmt='.4f'))",
        "mutated": [
            "def _main(uid2refs, uid2hyps, verbose):\n    if False:\n        i = 10\n    (p_xy, ref2pid, hyp2lid, tot, frmdiff, skipped) = comp_joint_prob(uid2refs, uid2hyps)\n    (ref_pur_by_hyp, ref_pur) = comp_purity(p_xy, axis=0)\n    (hyp_pur_by_ref, hyp_pur) = comp_purity(p_xy, axis=1)\n    (mi, mi_norm_by_ref, mi_norm_by_hyp, h_ref, h_hyp) = comp_norm_mutual_info(p_xy)\n    outputs = {'ref pur': ref_pur, 'hyp pur': hyp_pur, 'H(ref)': h_ref, 'H(hyp)': h_hyp, 'MI': mi, 'MI/H(ref)': mi_norm_by_ref, 'ref segL': comp_avg_seg_dur(uid2refs.values()), 'hyp segL': comp_avg_seg_dur(uid2hyps.values()), 'p_xy shape': p_xy.shape, 'frm tot': tot, 'frm diff': frmdiff, 'utt tot': len(uid2refs), 'utt miss': len(skipped)}\n    print(tabulate([outputs.values()], outputs.keys(), floatfmt='.4f'))",
            "def _main(uid2refs, uid2hyps, verbose):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (p_xy, ref2pid, hyp2lid, tot, frmdiff, skipped) = comp_joint_prob(uid2refs, uid2hyps)\n    (ref_pur_by_hyp, ref_pur) = comp_purity(p_xy, axis=0)\n    (hyp_pur_by_ref, hyp_pur) = comp_purity(p_xy, axis=1)\n    (mi, mi_norm_by_ref, mi_norm_by_hyp, h_ref, h_hyp) = comp_norm_mutual_info(p_xy)\n    outputs = {'ref pur': ref_pur, 'hyp pur': hyp_pur, 'H(ref)': h_ref, 'H(hyp)': h_hyp, 'MI': mi, 'MI/H(ref)': mi_norm_by_ref, 'ref segL': comp_avg_seg_dur(uid2refs.values()), 'hyp segL': comp_avg_seg_dur(uid2hyps.values()), 'p_xy shape': p_xy.shape, 'frm tot': tot, 'frm diff': frmdiff, 'utt tot': len(uid2refs), 'utt miss': len(skipped)}\n    print(tabulate([outputs.values()], outputs.keys(), floatfmt='.4f'))",
            "def _main(uid2refs, uid2hyps, verbose):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (p_xy, ref2pid, hyp2lid, tot, frmdiff, skipped) = comp_joint_prob(uid2refs, uid2hyps)\n    (ref_pur_by_hyp, ref_pur) = comp_purity(p_xy, axis=0)\n    (hyp_pur_by_ref, hyp_pur) = comp_purity(p_xy, axis=1)\n    (mi, mi_norm_by_ref, mi_norm_by_hyp, h_ref, h_hyp) = comp_norm_mutual_info(p_xy)\n    outputs = {'ref pur': ref_pur, 'hyp pur': hyp_pur, 'H(ref)': h_ref, 'H(hyp)': h_hyp, 'MI': mi, 'MI/H(ref)': mi_norm_by_ref, 'ref segL': comp_avg_seg_dur(uid2refs.values()), 'hyp segL': comp_avg_seg_dur(uid2hyps.values()), 'p_xy shape': p_xy.shape, 'frm tot': tot, 'frm diff': frmdiff, 'utt tot': len(uid2refs), 'utt miss': len(skipped)}\n    print(tabulate([outputs.values()], outputs.keys(), floatfmt='.4f'))",
            "def _main(uid2refs, uid2hyps, verbose):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (p_xy, ref2pid, hyp2lid, tot, frmdiff, skipped) = comp_joint_prob(uid2refs, uid2hyps)\n    (ref_pur_by_hyp, ref_pur) = comp_purity(p_xy, axis=0)\n    (hyp_pur_by_ref, hyp_pur) = comp_purity(p_xy, axis=1)\n    (mi, mi_norm_by_ref, mi_norm_by_hyp, h_ref, h_hyp) = comp_norm_mutual_info(p_xy)\n    outputs = {'ref pur': ref_pur, 'hyp pur': hyp_pur, 'H(ref)': h_ref, 'H(hyp)': h_hyp, 'MI': mi, 'MI/H(ref)': mi_norm_by_ref, 'ref segL': comp_avg_seg_dur(uid2refs.values()), 'hyp segL': comp_avg_seg_dur(uid2hyps.values()), 'p_xy shape': p_xy.shape, 'frm tot': tot, 'frm diff': frmdiff, 'utt tot': len(uid2refs), 'utt miss': len(skipped)}\n    print(tabulate([outputs.values()], outputs.keys(), floatfmt='.4f'))",
            "def _main(uid2refs, uid2hyps, verbose):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (p_xy, ref2pid, hyp2lid, tot, frmdiff, skipped) = comp_joint_prob(uid2refs, uid2hyps)\n    (ref_pur_by_hyp, ref_pur) = comp_purity(p_xy, axis=0)\n    (hyp_pur_by_ref, hyp_pur) = comp_purity(p_xy, axis=1)\n    (mi, mi_norm_by_ref, mi_norm_by_hyp, h_ref, h_hyp) = comp_norm_mutual_info(p_xy)\n    outputs = {'ref pur': ref_pur, 'hyp pur': hyp_pur, 'H(ref)': h_ref, 'H(hyp)': h_hyp, 'MI': mi, 'MI/H(ref)': mi_norm_by_ref, 'ref segL': comp_avg_seg_dur(uid2refs.values()), 'hyp segL': comp_avg_seg_dur(uid2hyps.values()), 'p_xy shape': p_xy.shape, 'frm tot': tot, 'frm diff': frmdiff, 'utt tot': len(uid2refs), 'utt miss': len(skipped)}\n    print(tabulate([outputs.values()], outputs.keys(), floatfmt='.4f'))"
        ]
    }
]