[
    {
        "func_name": "__init__",
        "original": "def __init__(self, num_dir_bins, with_rot=True):\n    super(AnchorFreeBBoxCoder, self).__init__(num_dir_bins, 0, [], with_rot=with_rot)\n    self.num_dir_bins = num_dir_bins\n    self.with_rot = with_rot",
        "mutated": [
            "def __init__(self, num_dir_bins, with_rot=True):\n    if False:\n        i = 10\n    super(AnchorFreeBBoxCoder, self).__init__(num_dir_bins, 0, [], with_rot=with_rot)\n    self.num_dir_bins = num_dir_bins\n    self.with_rot = with_rot",
            "def __init__(self, num_dir_bins, with_rot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(AnchorFreeBBoxCoder, self).__init__(num_dir_bins, 0, [], with_rot=with_rot)\n    self.num_dir_bins = num_dir_bins\n    self.with_rot = with_rot",
            "def __init__(self, num_dir_bins, with_rot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(AnchorFreeBBoxCoder, self).__init__(num_dir_bins, 0, [], with_rot=with_rot)\n    self.num_dir_bins = num_dir_bins\n    self.with_rot = with_rot",
            "def __init__(self, num_dir_bins, with_rot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(AnchorFreeBBoxCoder, self).__init__(num_dir_bins, 0, [], with_rot=with_rot)\n    self.num_dir_bins = num_dir_bins\n    self.with_rot = with_rot",
            "def __init__(self, num_dir_bins, with_rot=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(AnchorFreeBBoxCoder, self).__init__(num_dir_bins, 0, [], with_rot=with_rot)\n    self.num_dir_bins = num_dir_bins\n    self.with_rot = with_rot"
        ]
    },
    {
        "func_name": "encode",
        "original": "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    \"\"\"Encode ground truth to prediction targets.\n\n        Args:\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\n                with shape (n, 7).\n            gt_labels_3d (torch.Tensor): Ground truth classes.\n\n        Returns:\n            tuple: Targets of center, size and direction.\n        \"\"\"\n    center_target = gt_bboxes_3d.gravity_center\n    size_res_target = gt_bboxes_3d.dims / 2\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n        dir_res_target /= 2 * np.pi / self.num_dir_bins\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_res_target, dir_class_target, dir_res_target)",
        "mutated": [
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_res_target = gt_bboxes_3d.dims / 2\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n        dir_res_target /= 2 * np.pi / self.num_dir_bins\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_res_target = gt_bboxes_3d.dims / 2\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n        dir_res_target /= 2 * np.pi / self.num_dir_bins\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_res_target = gt_bboxes_3d.dims / 2\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n        dir_res_target /= 2 * np.pi / self.num_dir_bins\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_res_target = gt_bboxes_3d.dims / 2\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n        dir_res_target /= 2 * np.pi / self.num_dir_bins\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_res_target, dir_class_target, dir_res_target)",
            "def encode(self, gt_bboxes_3d, gt_labels_3d):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Encode ground truth to prediction targets.\\n\\n        Args:\\n            gt_bboxes_3d (BaseInstance3DBoxes): Ground truth bboxes\\n                with shape (n, 7).\\n            gt_labels_3d (torch.Tensor): Ground truth classes.\\n\\n        Returns:\\n            tuple: Targets of center, size and direction.\\n        '\n    center_target = gt_bboxes_3d.gravity_center\n    size_res_target = gt_bboxes_3d.dims / 2\n    box_num = gt_labels_3d.shape[0]\n    if self.with_rot:\n        (dir_class_target, dir_res_target) = self.angle2class(gt_bboxes_3d.yaw)\n        dir_res_target /= 2 * np.pi / self.num_dir_bins\n    else:\n        dir_class_target = gt_labels_3d.new_zeros(box_num)\n        dir_res_target = gt_bboxes_3d.tensor.new_zeros(box_num)\n    return (center_target, size_res_target, dir_class_target, dir_res_target)"
        ]
    },
    {
        "func_name": "decode",
        "original": "def decode(self, bbox_out):\n    \"\"\"Decode predicted parts to bbox3d.\n\n        Args:\n            bbox_out (dict): Predictions from model, should contain keys below.\n\n                - center: predicted bottom center of bboxes.\n                - dir_class: predicted bbox direction class.\n                - dir_res: predicted bbox direction residual.\n                - size: predicted bbox size.\n\n        Returns:\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\n        \"\"\"\n    center = bbox_out['center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class'], -1)\n        dir_res = torch.gather(bbox_out['dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    bbox_size = torch.clamp(bbox_out['size'] * 2, min=0.1)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
        "mutated": [
            "def decode(self, bbox_out):\n    if False:\n        i = 10\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size: predicted bbox size.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class'], -1)\n        dir_res = torch.gather(bbox_out['dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    bbox_size = torch.clamp(bbox_out['size'] * 2, min=0.1)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size: predicted bbox size.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class'], -1)\n        dir_res = torch.gather(bbox_out['dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    bbox_size = torch.clamp(bbox_out['size'] * 2, min=0.1)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size: predicted bbox size.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class'], -1)\n        dir_res = torch.gather(bbox_out['dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    bbox_size = torch.clamp(bbox_out['size'] * 2, min=0.1)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size: predicted bbox size.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class'], -1)\n        dir_res = torch.gather(bbox_out['dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    bbox_size = torch.clamp(bbox_out['size'] * 2, min=0.1)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d",
            "def decode(self, bbox_out):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Decode predicted parts to bbox3d.\\n\\n        Args:\\n            bbox_out (dict): Predictions from model, should contain keys below.\\n\\n                - center: predicted bottom center of bboxes.\\n                - dir_class: predicted bbox direction class.\\n                - dir_res: predicted bbox direction residual.\\n                - size: predicted bbox size.\\n\\n        Returns:\\n            torch.Tensor: Decoded bbox3d with shape (batch, n, 7).\\n        '\n    center = bbox_out['center']\n    (batch_size, num_proposal) = center.shape[:2]\n    if self.with_rot:\n        dir_class = torch.argmax(bbox_out['dir_class'], -1)\n        dir_res = torch.gather(bbox_out['dir_res'], 2, dir_class.unsqueeze(-1))\n        dir_res.squeeze_(2)\n        dir_angle = self.class2angle(dir_class, dir_res).reshape(batch_size, num_proposal, 1)\n    else:\n        dir_angle = center.new_zeros(batch_size, num_proposal, 1)\n    bbox_size = torch.clamp(bbox_out['size'] * 2, min=0.1)\n    bbox3d = torch.cat([center, bbox_size, dir_angle], dim=-1)\n    return bbox3d"
        ]
    },
    {
        "func_name": "split_pred",
        "original": "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    \"\"\"Split predicted features to specific parts.\n\n        Args:\n            cls_preds (torch.Tensor): Class predicted features to split.\n            reg_preds (torch.Tensor): Regression predicted features to split.\n            base_xyz (torch.Tensor): Coordinates of points.\n\n        Returns:\n            dict[str, torch.Tensor]: Split results.\n        \"\"\"\n    results = {}\n    results['obj_scores'] = cls_preds\n    (start, end) = (0, 0)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center_offset'] = reg_preds_trans[..., start:end]\n    results['center'] = base_xyz.detach() + reg_preds_trans[..., start:end]\n    start = end\n    end += 3\n    results['size'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end]\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (2 * np.pi / self.num_dir_bins)\n    return results",
        "mutated": [
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    results['obj_scores'] = cls_preds\n    (start, end) = (0, 0)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center_offset'] = reg_preds_trans[..., start:end]\n    results['center'] = base_xyz.detach() + reg_preds_trans[..., start:end]\n    start = end\n    end += 3\n    results['size'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end]\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (2 * np.pi / self.num_dir_bins)\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    results['obj_scores'] = cls_preds\n    (start, end) = (0, 0)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center_offset'] = reg_preds_trans[..., start:end]\n    results['center'] = base_xyz.detach() + reg_preds_trans[..., start:end]\n    start = end\n    end += 3\n    results['size'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end]\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (2 * np.pi / self.num_dir_bins)\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    results['obj_scores'] = cls_preds\n    (start, end) = (0, 0)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center_offset'] = reg_preds_trans[..., start:end]\n    results['center'] = base_xyz.detach() + reg_preds_trans[..., start:end]\n    start = end\n    end += 3\n    results['size'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end]\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (2 * np.pi / self.num_dir_bins)\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    results['obj_scores'] = cls_preds\n    (start, end) = (0, 0)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center_offset'] = reg_preds_trans[..., start:end]\n    results['center'] = base_xyz.detach() + reg_preds_trans[..., start:end]\n    start = end\n    end += 3\n    results['size'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end]\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (2 * np.pi / self.num_dir_bins)\n    return results",
            "def split_pred(self, cls_preds, reg_preds, base_xyz):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Split predicted features to specific parts.\\n\\n        Args:\\n            cls_preds (torch.Tensor): Class predicted features to split.\\n            reg_preds (torch.Tensor): Regression predicted features to split.\\n            base_xyz (torch.Tensor): Coordinates of points.\\n\\n        Returns:\\n            dict[str, torch.Tensor]: Split results.\\n        '\n    results = {}\n    results['obj_scores'] = cls_preds\n    (start, end) = (0, 0)\n    reg_preds_trans = reg_preds.transpose(2, 1)\n    end += 3\n    results['center_offset'] = reg_preds_trans[..., start:end]\n    results['center'] = base_xyz.detach() + reg_preds_trans[..., start:end]\n    start = end\n    end += 3\n    results['size'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    results['dir_class'] = reg_preds_trans[..., start:end]\n    start = end\n    end += self.num_dir_bins\n    dir_res_norm = reg_preds_trans[..., start:end]\n    start = end\n    results['dir_res_norm'] = dir_res_norm\n    results['dir_res'] = dir_res_norm * (2 * np.pi / self.num_dir_bins)\n    return results"
        ]
    }
]