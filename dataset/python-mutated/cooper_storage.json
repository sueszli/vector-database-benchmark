[
    {
        "func_name": "__init__",
        "original": "def __init__(self, featstruct):\n    \"\"\"\n        :param featstruct: The value of the ``sem`` node in a tree from\n            ``parse_with_bindops()``\n        :type featstruct: FeatStruct (with features ``core`` and ``store``)\n\n        \"\"\"\n    self.featstruct = featstruct\n    self.readings = []\n    try:\n        self.core = featstruct['CORE']\n        self.store = featstruct['STORE']\n    except KeyError:\n        print('%s is not a Cooper storage structure' % featstruct)",
        "mutated": [
            "def __init__(self, featstruct):\n    if False:\n        i = 10\n    '\\n        :param featstruct: The value of the ``sem`` node in a tree from\\n            ``parse_with_bindops()``\\n        :type featstruct: FeatStruct (with features ``core`` and ``store``)\\n\\n        '\n    self.featstruct = featstruct\n    self.readings = []\n    try:\n        self.core = featstruct['CORE']\n        self.store = featstruct['STORE']\n    except KeyError:\n        print('%s is not a Cooper storage structure' % featstruct)",
            "def __init__(self, featstruct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :param featstruct: The value of the ``sem`` node in a tree from\\n            ``parse_with_bindops()``\\n        :type featstruct: FeatStruct (with features ``core`` and ``store``)\\n\\n        '\n    self.featstruct = featstruct\n    self.readings = []\n    try:\n        self.core = featstruct['CORE']\n        self.store = featstruct['STORE']\n    except KeyError:\n        print('%s is not a Cooper storage structure' % featstruct)",
            "def __init__(self, featstruct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :param featstruct: The value of the ``sem`` node in a tree from\\n            ``parse_with_bindops()``\\n        :type featstruct: FeatStruct (with features ``core`` and ``store``)\\n\\n        '\n    self.featstruct = featstruct\n    self.readings = []\n    try:\n        self.core = featstruct['CORE']\n        self.store = featstruct['STORE']\n    except KeyError:\n        print('%s is not a Cooper storage structure' % featstruct)",
            "def __init__(self, featstruct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :param featstruct: The value of the ``sem`` node in a tree from\\n            ``parse_with_bindops()``\\n        :type featstruct: FeatStruct (with features ``core`` and ``store``)\\n\\n        '\n    self.featstruct = featstruct\n    self.readings = []\n    try:\n        self.core = featstruct['CORE']\n        self.store = featstruct['STORE']\n    except KeyError:\n        print('%s is not a Cooper storage structure' % featstruct)",
            "def __init__(self, featstruct):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :param featstruct: The value of the ``sem`` node in a tree from\\n            ``parse_with_bindops()``\\n        :type featstruct: FeatStruct (with features ``core`` and ``store``)\\n\\n        '\n    self.featstruct = featstruct\n    self.readings = []\n    try:\n        self.core = featstruct['CORE']\n        self.store = featstruct['STORE']\n    except KeyError:\n        print('%s is not a Cooper storage structure' % featstruct)"
        ]
    },
    {
        "func_name": "_permute",
        "original": "def _permute(self, lst):\n    \"\"\"\n        :return: An iterator over the permutations of the input list\n        :type lst: list\n        :rtype: iter\n        \"\"\"\n    remove = lambda lst0, index: lst0[:index] + lst0[index + 1:]\n    if lst:\n        for (index, x) in enumerate(lst):\n            for y in self._permute(remove(lst, index)):\n                yield ((x,) + y)\n    else:\n        yield ()",
        "mutated": [
            "def _permute(self, lst):\n    if False:\n        i = 10\n    '\\n        :return: An iterator over the permutations of the input list\\n        :type lst: list\\n        :rtype: iter\\n        '\n    remove = lambda lst0, index: lst0[:index] + lst0[index + 1:]\n    if lst:\n        for (index, x) in enumerate(lst):\n            for y in self._permute(remove(lst, index)):\n                yield ((x,) + y)\n    else:\n        yield ()",
            "def _permute(self, lst):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :return: An iterator over the permutations of the input list\\n        :type lst: list\\n        :rtype: iter\\n        '\n    remove = lambda lst0, index: lst0[:index] + lst0[index + 1:]\n    if lst:\n        for (index, x) in enumerate(lst):\n            for y in self._permute(remove(lst, index)):\n                yield ((x,) + y)\n    else:\n        yield ()",
            "def _permute(self, lst):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :return: An iterator over the permutations of the input list\\n        :type lst: list\\n        :rtype: iter\\n        '\n    remove = lambda lst0, index: lst0[:index] + lst0[index + 1:]\n    if lst:\n        for (index, x) in enumerate(lst):\n            for y in self._permute(remove(lst, index)):\n                yield ((x,) + y)\n    else:\n        yield ()",
            "def _permute(self, lst):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :return: An iterator over the permutations of the input list\\n        :type lst: list\\n        :rtype: iter\\n        '\n    remove = lambda lst0, index: lst0[:index] + lst0[index + 1:]\n    if lst:\n        for (index, x) in enumerate(lst):\n            for y in self._permute(remove(lst, index)):\n                yield ((x,) + y)\n    else:\n        yield ()",
            "def _permute(self, lst):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :return: An iterator over the permutations of the input list\\n        :type lst: list\\n        :rtype: iter\\n        '\n    remove = lambda lst0, index: lst0[:index] + lst0[index + 1:]\n    if lst:\n        for (index, x) in enumerate(lst):\n            for y in self._permute(remove(lst, index)):\n                yield ((x,) + y)\n    else:\n        yield ()"
        ]
    },
    {
        "func_name": "s_retrieve",
        "original": "def s_retrieve(self, trace=False):\n    \"\"\"\n        Carry out S-Retrieval of binding operators in store. If hack=True,\n        serialize the bindop and core as strings and reparse. Ugh.\n\n        Each permutation of the store (i.e. list of binding operators) is\n        taken to be a possible scoping of quantifiers. We iterate through the\n        binding operators in each permutation, and successively apply them to\n        the current term, starting with the core semantic representation,\n        working from the inside out.\n\n        Binding operators are of the form::\n\n             bo(\\\\P.all x.(man(x) -> P(x)),z1)\n        \"\"\"\n    for (perm, store_perm) in enumerate(self._permute(self.store)):\n        if trace:\n            print('Permutation %s' % (perm + 1))\n        term = self.core\n        for bindop in store_perm:\n            (quant, varex) = tuple(bindop.args)\n            term = ApplicationExpression(quant, LambdaExpression(varex.variable, term))\n            if trace:\n                print('  ', term)\n            term = term.simplify()\n        self.readings.append(term)",
        "mutated": [
            "def s_retrieve(self, trace=False):\n    if False:\n        i = 10\n    '\\n        Carry out S-Retrieval of binding operators in store. If hack=True,\\n        serialize the bindop and core as strings and reparse. Ugh.\\n\\n        Each permutation of the store (i.e. list of binding operators) is\\n        taken to be a possible scoping of quantifiers. We iterate through the\\n        binding operators in each permutation, and successively apply them to\\n        the current term, starting with the core semantic representation,\\n        working from the inside out.\\n\\n        Binding operators are of the form::\\n\\n             bo(\\\\P.all x.(man(x) -> P(x)),z1)\\n        '\n    for (perm, store_perm) in enumerate(self._permute(self.store)):\n        if trace:\n            print('Permutation %s' % (perm + 1))\n        term = self.core\n        for bindop in store_perm:\n            (quant, varex) = tuple(bindop.args)\n            term = ApplicationExpression(quant, LambdaExpression(varex.variable, term))\n            if trace:\n                print('  ', term)\n            term = term.simplify()\n        self.readings.append(term)",
            "def s_retrieve(self, trace=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Carry out S-Retrieval of binding operators in store. If hack=True,\\n        serialize the bindop and core as strings and reparse. Ugh.\\n\\n        Each permutation of the store (i.e. list of binding operators) is\\n        taken to be a possible scoping of quantifiers. We iterate through the\\n        binding operators in each permutation, and successively apply them to\\n        the current term, starting with the core semantic representation,\\n        working from the inside out.\\n\\n        Binding operators are of the form::\\n\\n             bo(\\\\P.all x.(man(x) -> P(x)),z1)\\n        '\n    for (perm, store_perm) in enumerate(self._permute(self.store)):\n        if trace:\n            print('Permutation %s' % (perm + 1))\n        term = self.core\n        for bindop in store_perm:\n            (quant, varex) = tuple(bindop.args)\n            term = ApplicationExpression(quant, LambdaExpression(varex.variable, term))\n            if trace:\n                print('  ', term)\n            term = term.simplify()\n        self.readings.append(term)",
            "def s_retrieve(self, trace=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Carry out S-Retrieval of binding operators in store. If hack=True,\\n        serialize the bindop and core as strings and reparse. Ugh.\\n\\n        Each permutation of the store (i.e. list of binding operators) is\\n        taken to be a possible scoping of quantifiers. We iterate through the\\n        binding operators in each permutation, and successively apply them to\\n        the current term, starting with the core semantic representation,\\n        working from the inside out.\\n\\n        Binding operators are of the form::\\n\\n             bo(\\\\P.all x.(man(x) -> P(x)),z1)\\n        '\n    for (perm, store_perm) in enumerate(self._permute(self.store)):\n        if trace:\n            print('Permutation %s' % (perm + 1))\n        term = self.core\n        for bindop in store_perm:\n            (quant, varex) = tuple(bindop.args)\n            term = ApplicationExpression(quant, LambdaExpression(varex.variable, term))\n            if trace:\n                print('  ', term)\n            term = term.simplify()\n        self.readings.append(term)",
            "def s_retrieve(self, trace=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Carry out S-Retrieval of binding operators in store. If hack=True,\\n        serialize the bindop and core as strings and reparse. Ugh.\\n\\n        Each permutation of the store (i.e. list of binding operators) is\\n        taken to be a possible scoping of quantifiers. We iterate through the\\n        binding operators in each permutation, and successively apply them to\\n        the current term, starting with the core semantic representation,\\n        working from the inside out.\\n\\n        Binding operators are of the form::\\n\\n             bo(\\\\P.all x.(man(x) -> P(x)),z1)\\n        '\n    for (perm, store_perm) in enumerate(self._permute(self.store)):\n        if trace:\n            print('Permutation %s' % (perm + 1))\n        term = self.core\n        for bindop in store_perm:\n            (quant, varex) = tuple(bindop.args)\n            term = ApplicationExpression(quant, LambdaExpression(varex.variable, term))\n            if trace:\n                print('  ', term)\n            term = term.simplify()\n        self.readings.append(term)",
            "def s_retrieve(self, trace=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Carry out S-Retrieval of binding operators in store. If hack=True,\\n        serialize the bindop and core as strings and reparse. Ugh.\\n\\n        Each permutation of the store (i.e. list of binding operators) is\\n        taken to be a possible scoping of quantifiers. We iterate through the\\n        binding operators in each permutation, and successively apply them to\\n        the current term, starting with the core semantic representation,\\n        working from the inside out.\\n\\n        Binding operators are of the form::\\n\\n             bo(\\\\P.all x.(man(x) -> P(x)),z1)\\n        '\n    for (perm, store_perm) in enumerate(self._permute(self.store)):\n        if trace:\n            print('Permutation %s' % (perm + 1))\n        term = self.core\n        for bindop in store_perm:\n            (quant, varex) = tuple(bindop.args)\n            term = ApplicationExpression(quant, LambdaExpression(varex.variable, term))\n            if trace:\n                print('  ', term)\n            term = term.simplify()\n        self.readings.append(term)"
        ]
    },
    {
        "func_name": "parse_with_bindops",
        "original": "def parse_with_bindops(sentence, grammar=None, trace=0):\n    \"\"\"\n    Use a grammar with Binding Operators to parse a sentence.\n    \"\"\"\n    if not grammar:\n        grammar = 'grammars/book_grammars/storage.fcfg'\n    parser = load_parser(grammar, trace=trace, chart_class=InstantiateVarsChart)\n    tokens = sentence.split()\n    return list(parser.parse(tokens))",
        "mutated": [
            "def parse_with_bindops(sentence, grammar=None, trace=0):\n    if False:\n        i = 10\n    '\\n    Use a grammar with Binding Operators to parse a sentence.\\n    '\n    if not grammar:\n        grammar = 'grammars/book_grammars/storage.fcfg'\n    parser = load_parser(grammar, trace=trace, chart_class=InstantiateVarsChart)\n    tokens = sentence.split()\n    return list(parser.parse(tokens))",
            "def parse_with_bindops(sentence, grammar=None, trace=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Use a grammar with Binding Operators to parse a sentence.\\n    '\n    if not grammar:\n        grammar = 'grammars/book_grammars/storage.fcfg'\n    parser = load_parser(grammar, trace=trace, chart_class=InstantiateVarsChart)\n    tokens = sentence.split()\n    return list(parser.parse(tokens))",
            "def parse_with_bindops(sentence, grammar=None, trace=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Use a grammar with Binding Operators to parse a sentence.\\n    '\n    if not grammar:\n        grammar = 'grammars/book_grammars/storage.fcfg'\n    parser = load_parser(grammar, trace=trace, chart_class=InstantiateVarsChart)\n    tokens = sentence.split()\n    return list(parser.parse(tokens))",
            "def parse_with_bindops(sentence, grammar=None, trace=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Use a grammar with Binding Operators to parse a sentence.\\n    '\n    if not grammar:\n        grammar = 'grammars/book_grammars/storage.fcfg'\n    parser = load_parser(grammar, trace=trace, chart_class=InstantiateVarsChart)\n    tokens = sentence.split()\n    return list(parser.parse(tokens))",
            "def parse_with_bindops(sentence, grammar=None, trace=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Use a grammar with Binding Operators to parse a sentence.\\n    '\n    if not grammar:\n        grammar = 'grammars/book_grammars/storage.fcfg'\n    parser = load_parser(grammar, trace=trace, chart_class=InstantiateVarsChart)\n    tokens = sentence.split()\n    return list(parser.parse(tokens))"
        ]
    },
    {
        "func_name": "demo",
        "original": "def demo():\n    from nltk.sem import cooper_storage as cs\n    sentence = 'every girl chases a dog'\n    print()\n    print(\"Analysis of sentence '%s'\" % sentence)\n    print('=' * 50)\n    trees = cs.parse_with_bindops(sentence, trace=0)\n    for tree in trees:\n        semrep = cs.CooperStore(tree.label()['SEM'])\n        print()\n        print('Binding operators:')\n        print('-' * 15)\n        for s in semrep.store:\n            print(s)\n        print()\n        print('Core:')\n        print('-' * 15)\n        print(semrep.core)\n        print()\n        print('S-Retrieval:')\n        print('-' * 15)\n        semrep.s_retrieve(trace=True)\n        print('Readings:')\n        print('-' * 15)\n        for (i, reading) in enumerate(semrep.readings):\n            print(f'{i + 1}: {reading}')",
        "mutated": [
            "def demo():\n    if False:\n        i = 10\n    from nltk.sem import cooper_storage as cs\n    sentence = 'every girl chases a dog'\n    print()\n    print(\"Analysis of sentence '%s'\" % sentence)\n    print('=' * 50)\n    trees = cs.parse_with_bindops(sentence, trace=0)\n    for tree in trees:\n        semrep = cs.CooperStore(tree.label()['SEM'])\n        print()\n        print('Binding operators:')\n        print('-' * 15)\n        for s in semrep.store:\n            print(s)\n        print()\n        print('Core:')\n        print('-' * 15)\n        print(semrep.core)\n        print()\n        print('S-Retrieval:')\n        print('-' * 15)\n        semrep.s_retrieve(trace=True)\n        print('Readings:')\n        print('-' * 15)\n        for (i, reading) in enumerate(semrep.readings):\n            print(f'{i + 1}: {reading}')",
            "def demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from nltk.sem import cooper_storage as cs\n    sentence = 'every girl chases a dog'\n    print()\n    print(\"Analysis of sentence '%s'\" % sentence)\n    print('=' * 50)\n    trees = cs.parse_with_bindops(sentence, trace=0)\n    for tree in trees:\n        semrep = cs.CooperStore(tree.label()['SEM'])\n        print()\n        print('Binding operators:')\n        print('-' * 15)\n        for s in semrep.store:\n            print(s)\n        print()\n        print('Core:')\n        print('-' * 15)\n        print(semrep.core)\n        print()\n        print('S-Retrieval:')\n        print('-' * 15)\n        semrep.s_retrieve(trace=True)\n        print('Readings:')\n        print('-' * 15)\n        for (i, reading) in enumerate(semrep.readings):\n            print(f'{i + 1}: {reading}')",
            "def demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from nltk.sem import cooper_storage as cs\n    sentence = 'every girl chases a dog'\n    print()\n    print(\"Analysis of sentence '%s'\" % sentence)\n    print('=' * 50)\n    trees = cs.parse_with_bindops(sentence, trace=0)\n    for tree in trees:\n        semrep = cs.CooperStore(tree.label()['SEM'])\n        print()\n        print('Binding operators:')\n        print('-' * 15)\n        for s in semrep.store:\n            print(s)\n        print()\n        print('Core:')\n        print('-' * 15)\n        print(semrep.core)\n        print()\n        print('S-Retrieval:')\n        print('-' * 15)\n        semrep.s_retrieve(trace=True)\n        print('Readings:')\n        print('-' * 15)\n        for (i, reading) in enumerate(semrep.readings):\n            print(f'{i + 1}: {reading}')",
            "def demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from nltk.sem import cooper_storage as cs\n    sentence = 'every girl chases a dog'\n    print()\n    print(\"Analysis of sentence '%s'\" % sentence)\n    print('=' * 50)\n    trees = cs.parse_with_bindops(sentence, trace=0)\n    for tree in trees:\n        semrep = cs.CooperStore(tree.label()['SEM'])\n        print()\n        print('Binding operators:')\n        print('-' * 15)\n        for s in semrep.store:\n            print(s)\n        print()\n        print('Core:')\n        print('-' * 15)\n        print(semrep.core)\n        print()\n        print('S-Retrieval:')\n        print('-' * 15)\n        semrep.s_retrieve(trace=True)\n        print('Readings:')\n        print('-' * 15)\n        for (i, reading) in enumerate(semrep.readings):\n            print(f'{i + 1}: {reading}')",
            "def demo():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from nltk.sem import cooper_storage as cs\n    sentence = 'every girl chases a dog'\n    print()\n    print(\"Analysis of sentence '%s'\" % sentence)\n    print('=' * 50)\n    trees = cs.parse_with_bindops(sentence, trace=0)\n    for tree in trees:\n        semrep = cs.CooperStore(tree.label()['SEM'])\n        print()\n        print('Binding operators:')\n        print('-' * 15)\n        for s in semrep.store:\n            print(s)\n        print()\n        print('Core:')\n        print('-' * 15)\n        print(semrep.core)\n        print()\n        print('S-Retrieval:')\n        print('-' * 15)\n        semrep.s_retrieve(trace=True)\n        print('Readings:')\n        print('-' * 15)\n        for (i, reading) in enumerate(semrep.readings):\n            print(f'{i + 1}: {reading}')"
        ]
    }
]