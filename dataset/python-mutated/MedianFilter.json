[
    {
        "func_name": "__init__",
        "original": "def __init__(self, kernel_size=3, stride=1, padding=0, same=False):\n    super(MedianPool2d, self).__init__()\n    self.k = _pair(kernel_size)\n    self.stride = _pair(stride)\n    self.padding = _quadruple(padding)\n    self.same = same",
        "mutated": [
            "def __init__(self, kernel_size=3, stride=1, padding=0, same=False):\n    if False:\n        i = 10\n    super(MedianPool2d, self).__init__()\n    self.k = _pair(kernel_size)\n    self.stride = _pair(stride)\n    self.padding = _quadruple(padding)\n    self.same = same",
            "def __init__(self, kernel_size=3, stride=1, padding=0, same=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super(MedianPool2d, self).__init__()\n    self.k = _pair(kernel_size)\n    self.stride = _pair(stride)\n    self.padding = _quadruple(padding)\n    self.same = same",
            "def __init__(self, kernel_size=3, stride=1, padding=0, same=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super(MedianPool2d, self).__init__()\n    self.k = _pair(kernel_size)\n    self.stride = _pair(stride)\n    self.padding = _quadruple(padding)\n    self.same = same",
            "def __init__(self, kernel_size=3, stride=1, padding=0, same=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super(MedianPool2d, self).__init__()\n    self.k = _pair(kernel_size)\n    self.stride = _pair(stride)\n    self.padding = _quadruple(padding)\n    self.same = same",
            "def __init__(self, kernel_size=3, stride=1, padding=0, same=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super(MedianPool2d, self).__init__()\n    self.k = _pair(kernel_size)\n    self.stride = _pair(stride)\n    self.padding = _quadruple(padding)\n    self.same = same"
        ]
    },
    {
        "func_name": "_padding",
        "original": "def _padding(self, x):\n    if self.same:\n        (ih, iw) = x.size()[2:]\n        if ih % self.stride[0] == 0:\n            ph = max(self.k[0] - self.stride[0], 0)\n        else:\n            ph = max(self.k[0] - ih % self.stride[0], 0)\n        if iw % self.stride[1] == 0:\n            pw = max(self.k[1] - self.stride[1], 0)\n        else:\n            pw = max(self.k[1] - iw % self.stride[1], 0)\n        pl = pw // 2\n        pr = pw - pl\n        pt = ph // 2\n        pb = ph - pt\n        padding = (pl, pr, pt, pb)\n    else:\n        padding = self.padding\n    return padding",
        "mutated": [
            "def _padding(self, x):\n    if False:\n        i = 10\n    if self.same:\n        (ih, iw) = x.size()[2:]\n        if ih % self.stride[0] == 0:\n            ph = max(self.k[0] - self.stride[0], 0)\n        else:\n            ph = max(self.k[0] - ih % self.stride[0], 0)\n        if iw % self.stride[1] == 0:\n            pw = max(self.k[1] - self.stride[1], 0)\n        else:\n            pw = max(self.k[1] - iw % self.stride[1], 0)\n        pl = pw // 2\n        pr = pw - pl\n        pt = ph // 2\n        pb = ph - pt\n        padding = (pl, pr, pt, pb)\n    else:\n        padding = self.padding\n    return padding",
            "def _padding(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.same:\n        (ih, iw) = x.size()[2:]\n        if ih % self.stride[0] == 0:\n            ph = max(self.k[0] - self.stride[0], 0)\n        else:\n            ph = max(self.k[0] - ih % self.stride[0], 0)\n        if iw % self.stride[1] == 0:\n            pw = max(self.k[1] - self.stride[1], 0)\n        else:\n            pw = max(self.k[1] - iw % self.stride[1], 0)\n        pl = pw // 2\n        pr = pw - pl\n        pt = ph // 2\n        pb = ph - pt\n        padding = (pl, pr, pt, pb)\n    else:\n        padding = self.padding\n    return padding",
            "def _padding(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.same:\n        (ih, iw) = x.size()[2:]\n        if ih % self.stride[0] == 0:\n            ph = max(self.k[0] - self.stride[0], 0)\n        else:\n            ph = max(self.k[0] - ih % self.stride[0], 0)\n        if iw % self.stride[1] == 0:\n            pw = max(self.k[1] - self.stride[1], 0)\n        else:\n            pw = max(self.k[1] - iw % self.stride[1], 0)\n        pl = pw // 2\n        pr = pw - pl\n        pt = ph // 2\n        pb = ph - pt\n        padding = (pl, pr, pt, pb)\n    else:\n        padding = self.padding\n    return padding",
            "def _padding(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.same:\n        (ih, iw) = x.size()[2:]\n        if ih % self.stride[0] == 0:\n            ph = max(self.k[0] - self.stride[0], 0)\n        else:\n            ph = max(self.k[0] - ih % self.stride[0], 0)\n        if iw % self.stride[1] == 0:\n            pw = max(self.k[1] - self.stride[1], 0)\n        else:\n            pw = max(self.k[1] - iw % self.stride[1], 0)\n        pl = pw // 2\n        pr = pw - pl\n        pt = ph // 2\n        pb = ph - pt\n        padding = (pl, pr, pt, pb)\n    else:\n        padding = self.padding\n    return padding",
            "def _padding(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.same:\n        (ih, iw) = x.size()[2:]\n        if ih % self.stride[0] == 0:\n            ph = max(self.k[0] - self.stride[0], 0)\n        else:\n            ph = max(self.k[0] - ih % self.stride[0], 0)\n        if iw % self.stride[1] == 0:\n            pw = max(self.k[1] - self.stride[1], 0)\n        else:\n            pw = max(self.k[1] - iw % self.stride[1], 0)\n        pl = pw // 2\n        pr = pw - pl\n        pt = ph // 2\n        pb = ph - pt\n        padding = (pl, pr, pt, pb)\n    else:\n        padding = self.padding\n    return padding"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, x):\n    x = F.pad(x, self._padding(x), mode='reflect')\n    x = x.unfold(2, self.k[0], self.stride[0]).unfold(3, self.k[1], self.stride[1])\n    x = x.contiguous().view(x.size()[:4] + (-1,)).median(dim=-1)[0]\n    return x",
        "mutated": [
            "def forward(self, x):\n    if False:\n        i = 10\n    x = F.pad(x, self._padding(x), mode='reflect')\n    x = x.unfold(2, self.k[0], self.stride[0]).unfold(3, self.k[1], self.stride[1])\n    x = x.contiguous().view(x.size()[:4] + (-1,)).median(dim=-1)[0]\n    return x",
            "def forward(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = F.pad(x, self._padding(x), mode='reflect')\n    x = x.unfold(2, self.k[0], self.stride[0]).unfold(3, self.k[1], self.stride[1])\n    x = x.contiguous().view(x.size()[:4] + (-1,)).median(dim=-1)[0]\n    return x",
            "def forward(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = F.pad(x, self._padding(x), mode='reflect')\n    x = x.unfold(2, self.k[0], self.stride[0]).unfold(3, self.k[1], self.stride[1])\n    x = x.contiguous().view(x.size()[:4] + (-1,)).median(dim=-1)[0]\n    return x",
            "def forward(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = F.pad(x, self._padding(x), mode='reflect')\n    x = x.unfold(2, self.k[0], self.stride[0]).unfold(3, self.k[1], self.stride[1])\n    x = x.contiguous().view(x.size()[:4] + (-1,)).median(dim=-1)[0]\n    return x",
            "def forward(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = F.pad(x, self._padding(x), mode='reflect')\n    x = x.unfold(2, self.k[0], self.stride[0]).unfold(3, self.k[1], self.stride[1])\n    x = x.contiguous().view(x.size()[:4] + (-1,)).median(dim=-1)[0]\n    return x"
        ]
    },
    {
        "func_name": "SingleMotionPropagate",
        "original": "def SingleMotionPropagate(x_flow, y_flow, pts):\n    \"\"\"\n    Traditional median filter for motion propagation\n    @param: x_flow [B, 1, H, W]\n    @param: y_flow [B, 1, H, W]\n    @param: pts    [B*topk, 4]\n    \"\"\"\n    pts = pts.float()\n    medfilt = MedianPool2d(same=True)\n    (_, _, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points_S = new_points.clone()\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    (Homo, state) = cv2.findHomography(old_points_numpy, new_points_numpy, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((pts[:, 2] - i * cfg.MODEL.PIXELS) ** 2 + (pts[:, 3] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            old_points_median = pts[index[:, 0].long(), :]\n            dominator = old_points_median[:, 3:4] * Homo[2, 0] + old_points_median[:, 2:3] * Homo[2, 1] + Homo[2, 2] + 1e-05\n            x_nominator = old_points_median[:, 3:4] * Homo[0, 0] + old_points_median[:, 2:3] * Homo[0, 1] + Homo[0, 2]\n            y_nominator = old_points_median[:, 3:4] * Homo[1, 0] + old_points_median[:, 2:3] * Homo[1, 1] + Homo[1, 2]\n            new_points_homo = torch.cat([x_nominator / dominator, y_nominator / dominator], -1)\n            new_points_flow = new_points_S[0, :, old_points_median[:, 2].long(), old_points_median[:, 3].long()].permute(1, 0)\n            temp_motion = new_points_flow - new_points_homo\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
        "mutated": [
            "def SingleMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n    '\\n    Traditional median filter for motion propagation\\n    @param: x_flow [B, 1, H, W]\\n    @param: y_flow [B, 1, H, W]\\n    @param: pts    [B*topk, 4]\\n    '\n    pts = pts.float()\n    medfilt = MedianPool2d(same=True)\n    (_, _, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points_S = new_points.clone()\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    (Homo, state) = cv2.findHomography(old_points_numpy, new_points_numpy, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((pts[:, 2] - i * cfg.MODEL.PIXELS) ** 2 + (pts[:, 3] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            old_points_median = pts[index[:, 0].long(), :]\n            dominator = old_points_median[:, 3:4] * Homo[2, 0] + old_points_median[:, 2:3] * Homo[2, 1] + Homo[2, 2] + 1e-05\n            x_nominator = old_points_median[:, 3:4] * Homo[0, 0] + old_points_median[:, 2:3] * Homo[0, 1] + Homo[0, 2]\n            y_nominator = old_points_median[:, 3:4] * Homo[1, 0] + old_points_median[:, 2:3] * Homo[1, 1] + Homo[1, 2]\n            new_points_homo = torch.cat([x_nominator / dominator, y_nominator / dominator], -1)\n            new_points_flow = new_points_S[0, :, old_points_median[:, 2].long(), old_points_median[:, 3].long()].permute(1, 0)\n            temp_motion = new_points_flow - new_points_homo\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
            "def SingleMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Traditional median filter for motion propagation\\n    @param: x_flow [B, 1, H, W]\\n    @param: y_flow [B, 1, H, W]\\n    @param: pts    [B*topk, 4]\\n    '\n    pts = pts.float()\n    medfilt = MedianPool2d(same=True)\n    (_, _, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points_S = new_points.clone()\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    (Homo, state) = cv2.findHomography(old_points_numpy, new_points_numpy, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((pts[:, 2] - i * cfg.MODEL.PIXELS) ** 2 + (pts[:, 3] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            old_points_median = pts[index[:, 0].long(), :]\n            dominator = old_points_median[:, 3:4] * Homo[2, 0] + old_points_median[:, 2:3] * Homo[2, 1] + Homo[2, 2] + 1e-05\n            x_nominator = old_points_median[:, 3:4] * Homo[0, 0] + old_points_median[:, 2:3] * Homo[0, 1] + Homo[0, 2]\n            y_nominator = old_points_median[:, 3:4] * Homo[1, 0] + old_points_median[:, 2:3] * Homo[1, 1] + Homo[1, 2]\n            new_points_homo = torch.cat([x_nominator / dominator, y_nominator / dominator], -1)\n            new_points_flow = new_points_S[0, :, old_points_median[:, 2].long(), old_points_median[:, 3].long()].permute(1, 0)\n            temp_motion = new_points_flow - new_points_homo\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
            "def SingleMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Traditional median filter for motion propagation\\n    @param: x_flow [B, 1, H, W]\\n    @param: y_flow [B, 1, H, W]\\n    @param: pts    [B*topk, 4]\\n    '\n    pts = pts.float()\n    medfilt = MedianPool2d(same=True)\n    (_, _, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points_S = new_points.clone()\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    (Homo, state) = cv2.findHomography(old_points_numpy, new_points_numpy, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((pts[:, 2] - i * cfg.MODEL.PIXELS) ** 2 + (pts[:, 3] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            old_points_median = pts[index[:, 0].long(), :]\n            dominator = old_points_median[:, 3:4] * Homo[2, 0] + old_points_median[:, 2:3] * Homo[2, 1] + Homo[2, 2] + 1e-05\n            x_nominator = old_points_median[:, 3:4] * Homo[0, 0] + old_points_median[:, 2:3] * Homo[0, 1] + Homo[0, 2]\n            y_nominator = old_points_median[:, 3:4] * Homo[1, 0] + old_points_median[:, 2:3] * Homo[1, 1] + Homo[1, 2]\n            new_points_homo = torch.cat([x_nominator / dominator, y_nominator / dominator], -1)\n            new_points_flow = new_points_S[0, :, old_points_median[:, 2].long(), old_points_median[:, 3].long()].permute(1, 0)\n            temp_motion = new_points_flow - new_points_homo\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
            "def SingleMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Traditional median filter for motion propagation\\n    @param: x_flow [B, 1, H, W]\\n    @param: y_flow [B, 1, H, W]\\n    @param: pts    [B*topk, 4]\\n    '\n    pts = pts.float()\n    medfilt = MedianPool2d(same=True)\n    (_, _, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points_S = new_points.clone()\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    (Homo, state) = cv2.findHomography(old_points_numpy, new_points_numpy, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((pts[:, 2] - i * cfg.MODEL.PIXELS) ** 2 + (pts[:, 3] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            old_points_median = pts[index[:, 0].long(), :]\n            dominator = old_points_median[:, 3:4] * Homo[2, 0] + old_points_median[:, 2:3] * Homo[2, 1] + Homo[2, 2] + 1e-05\n            x_nominator = old_points_median[:, 3:4] * Homo[0, 0] + old_points_median[:, 2:3] * Homo[0, 1] + Homo[0, 2]\n            y_nominator = old_points_median[:, 3:4] * Homo[1, 0] + old_points_median[:, 2:3] * Homo[1, 1] + Homo[1, 2]\n            new_points_homo = torch.cat([x_nominator / dominator, y_nominator / dominator], -1)\n            new_points_flow = new_points_S[0, :, old_points_median[:, 2].long(), old_points_median[:, 3].long()].permute(1, 0)\n            temp_motion = new_points_flow - new_points_homo\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
            "def SingleMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Traditional median filter for motion propagation\\n    @param: x_flow [B, 1, H, W]\\n    @param: y_flow [B, 1, H, W]\\n    @param: pts    [B*topk, 4]\\n    '\n    pts = pts.float()\n    medfilt = MedianPool2d(same=True)\n    (_, _, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points_S = new_points.clone()\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    (Homo, state) = cv2.findHomography(old_points_numpy, new_points_numpy, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n    meshes_x = meshes_x.float().permute(1, 0)\n    meshes_y = meshes_y.float().permute(1, 0)\n    meshes_x = meshes_x.to(old_points.device)\n    meshes_y = meshes_y.to(old_points.device)\n    meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n    meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n    meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n    x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / (meshes_projected[2, :, :] + 1e-05)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((pts[:, 2] - i * cfg.MODEL.PIXELS) ** 2 + (pts[:, 3] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            old_points_median = pts[index[:, 0].long(), :]\n            dominator = old_points_median[:, 3:4] * Homo[2, 0] + old_points_median[:, 2:3] * Homo[2, 1] + Homo[2, 2] + 1e-05\n            x_nominator = old_points_median[:, 3:4] * Homo[0, 0] + old_points_median[:, 2:3] * Homo[0, 1] + Homo[0, 2]\n            y_nominator = old_points_median[:, 3:4] * Homo[1, 0] + old_points_median[:, 2:3] * Homo[1, 1] + Homo[1, 2]\n            new_points_homo = torch.cat([x_nominator / dominator, y_nominator / dominator], -1)\n            new_points_flow = new_points_S[0, :, old_points_median[:, 2].long(), old_points_median[:, 3].long()].permute(1, 0)\n            temp_motion = new_points_flow - new_points_homo\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)"
        ]
    },
    {
        "func_name": "MultiMotionPropagate",
        "original": "def MultiMotionPropagate(x_flow, y_flow, pts):\n    \"\"\"\n    Median filter for propagation with multi homography\n    @param: x_flow B, 1, H, W\n    @param: y_flow B, 1, H, W\n    @param: pts    B*topk, 4\n    \"\"\"\n    medfilt = MedianPool2d(same=True)\n    from sklearn.cluster import KMeans\n    pts = pts.float()\n    (B, C, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    old_points_numpy_chosen = old_points_numpy[index, :]\n    new_points_numpy_chosen = new_points_numpy[index, :]\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = new_points_numpy_chosen - old_points_numpy_chosen\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    if np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure:\n        attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n        (Homo_2, _) = cv2.findHomography(old_points_numpy_chosen, new_points_numpy_chosen, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, W, cfg.MODEL.PIXELS), np.arange(0, H, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(new_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n        new_points_projected = torch.from_numpy(new_points_projected).to(old_points.device)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((old_points[:, 0] - i * cfg.MODEL.PIXELS) ** 2 + (old_points[:, 1] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            new_points_homo = new_points_projected[index[:, 0].long(), :]\n            new_points_flow = new_points[index[:, 0].long(), :]\n            temp_motion = -(new_points_homo - new_points_flow)\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
        "mutated": [
            "def MultiMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n    '\\n    Median filter for propagation with multi homography\\n    @param: x_flow B, 1, H, W\\n    @param: y_flow B, 1, H, W\\n    @param: pts    B*topk, 4\\n    '\n    medfilt = MedianPool2d(same=True)\n    from sklearn.cluster import KMeans\n    pts = pts.float()\n    (B, C, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    old_points_numpy_chosen = old_points_numpy[index, :]\n    new_points_numpy_chosen = new_points_numpy[index, :]\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = new_points_numpy_chosen - old_points_numpy_chosen\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    if np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure:\n        attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n        (Homo_2, _) = cv2.findHomography(old_points_numpy_chosen, new_points_numpy_chosen, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, W, cfg.MODEL.PIXELS), np.arange(0, H, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(new_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n        new_points_projected = torch.from_numpy(new_points_projected).to(old_points.device)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((old_points[:, 0] - i * cfg.MODEL.PIXELS) ** 2 + (old_points[:, 1] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            new_points_homo = new_points_projected[index[:, 0].long(), :]\n            new_points_flow = new_points[index[:, 0].long(), :]\n            temp_motion = -(new_points_homo - new_points_flow)\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
            "def MultiMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Median filter for propagation with multi homography\\n    @param: x_flow B, 1, H, W\\n    @param: y_flow B, 1, H, W\\n    @param: pts    B*topk, 4\\n    '\n    medfilt = MedianPool2d(same=True)\n    from sklearn.cluster import KMeans\n    pts = pts.float()\n    (B, C, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    old_points_numpy_chosen = old_points_numpy[index, :]\n    new_points_numpy_chosen = new_points_numpy[index, :]\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = new_points_numpy_chosen - old_points_numpy_chosen\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    if np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure:\n        attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n        (Homo_2, _) = cv2.findHomography(old_points_numpy_chosen, new_points_numpy_chosen, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, W, cfg.MODEL.PIXELS), np.arange(0, H, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(new_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n        new_points_projected = torch.from_numpy(new_points_projected).to(old_points.device)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((old_points[:, 0] - i * cfg.MODEL.PIXELS) ** 2 + (old_points[:, 1] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            new_points_homo = new_points_projected[index[:, 0].long(), :]\n            new_points_flow = new_points[index[:, 0].long(), :]\n            temp_motion = -(new_points_homo - new_points_flow)\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
            "def MultiMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Median filter for propagation with multi homography\\n    @param: x_flow B, 1, H, W\\n    @param: y_flow B, 1, H, W\\n    @param: pts    B*topk, 4\\n    '\n    medfilt = MedianPool2d(same=True)\n    from sklearn.cluster import KMeans\n    pts = pts.float()\n    (B, C, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    old_points_numpy_chosen = old_points_numpy[index, :]\n    new_points_numpy_chosen = new_points_numpy[index, :]\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = new_points_numpy_chosen - old_points_numpy_chosen\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    if np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure:\n        attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n        (Homo_2, _) = cv2.findHomography(old_points_numpy_chosen, new_points_numpy_chosen, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, W, cfg.MODEL.PIXELS), np.arange(0, H, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(new_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n        new_points_projected = torch.from_numpy(new_points_projected).to(old_points.device)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((old_points[:, 0] - i * cfg.MODEL.PIXELS) ** 2 + (old_points[:, 1] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            new_points_homo = new_points_projected[index[:, 0].long(), :]\n            new_points_flow = new_points[index[:, 0].long(), :]\n            temp_motion = -(new_points_homo - new_points_flow)\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
            "def MultiMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Median filter for propagation with multi homography\\n    @param: x_flow B, 1, H, W\\n    @param: y_flow B, 1, H, W\\n    @param: pts    B*topk, 4\\n    '\n    medfilt = MedianPool2d(same=True)\n    from sklearn.cluster import KMeans\n    pts = pts.float()\n    (B, C, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    old_points_numpy_chosen = old_points_numpy[index, :]\n    new_points_numpy_chosen = new_points_numpy[index, :]\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = new_points_numpy_chosen - old_points_numpy_chosen\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    if np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure:\n        attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n        (Homo_2, _) = cv2.findHomography(old_points_numpy_chosen, new_points_numpy_chosen, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, W, cfg.MODEL.PIXELS), np.arange(0, H, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(new_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n        new_points_projected = torch.from_numpy(new_points_projected).to(old_points.device)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((old_points[:, 0] - i * cfg.MODEL.PIXELS) ** 2 + (old_points[:, 1] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            new_points_homo = new_points_projected[index[:, 0].long(), :]\n            new_points_flow = new_points[index[:, 0].long(), :]\n            temp_motion = -(new_points_homo - new_points_flow)\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)",
            "def MultiMotionPropagate(x_flow, y_flow, pts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Median filter for propagation with multi homography\\n    @param: x_flow B, 1, H, W\\n    @param: y_flow B, 1, H, W\\n    @param: pts    B*topk, 4\\n    '\n    medfilt = MedianPool2d(same=True)\n    from sklearn.cluster import KMeans\n    pts = pts.float()\n    (B, C, H, W) = x_flow.shape\n    grids = torch.stack(torch.meshgrid(torch.arange(W), torch.arange(H)), 0).to(x_flow.device).permute(0, 2, 1)\n    grids = grids.unsqueeze(0)\n    grids = grids.float()\n    new_points = grids + torch.cat([x_flow, y_flow], 1)\n    new_points = new_points[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points = grids[0, :, pts[:, 2].long(), pts[:, 3].long()].permute(1, 0)\n    old_points_numpy = old_points.detach().cpu().numpy()\n    new_points_numpy = new_points.detach().cpu().numpy()\n    motion_numpy = new_points_numpy - old_points_numpy\n    pred_Y = KMeans(n_clusters=2, random_state=2).fit_predict(motion_numpy)\n    if np.sum(pred_Y) > cfg.TRAIN.TOPK / 2:\n        pred_Y = 1 - pred_Y\n    cluster1_old_points = old_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    cluster1_new_points = new_points_numpy[(pred_Y == 0).nonzero()[0], :]\n    (Homo, _) = cv2.findHomography(cluster1_old_points, cluster1_new_points, cv2.RANSAC)\n    if Homo is None:\n        Homo = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\n    dominator = Homo[2, 0] * old_points_numpy[:, 0] + Homo[2, 1] * old_points_numpy[:, 1] + Homo[2, 2]\n    new_points_projected = np.stack([(Homo[0, 0] * old_points_numpy[:, 0] + Homo[0, 1] * old_points_numpy[:, 1] + Homo[0, 2]) / dominator, (Homo[1, 0] * old_points_numpy[:, 0] + Homo[1, 1] * old_points_numpy[:, 1] + Homo[1, 2]) / dominator], 1)\n    index = (pred_Y == 1).nonzero()[0]\n    attribute = np.zeros_like(new_points_numpy[:, 0:1])\n    old_points_numpy_chosen = old_points_numpy[index, :]\n    new_points_numpy_chosen = new_points_numpy[index, :]\n    cluster1_motion = cluster1_new_points - cluster1_old_points\n    clsuter2_motion = new_points_numpy_chosen - old_points_numpy_chosen\n    cluster1_meanMotion = np.mean(cluster1_motion, 0)\n    cluster2_meanMotion = np.mean(clsuter2_motion, 0)\n    distanceMeasure = MotionDistanceMeasure(cluster1_meanMotion, cluster2_meanMotion)\n    if np.sum(pred_Y) > cfg.MODEL.THRESHOLDPOINT and distanceMeasure:\n        attribute[index, :] = np.expand_dims(np.ones_like(index), 1)\n        (Homo_2, _) = cv2.findHomography(old_points_numpy_chosen, new_points_numpy_chosen, cv2.RANSAC)\n        if Homo_2 is None:\n            Homo_2 = Homo\n        (meshes_x, meshes_y) = np.meshgrid(np.arange(0, W, cfg.MODEL.PIXELS), np.arange(0, H, cfg.MODEL.PIXELS))\n        x_dominator = Homo[0, 0] * meshes_x + Homo[0, 1] * meshes_y + Homo[0, 2]\n        y_dominator = Homo[1, 0] * meshes_x + Homo[1, 1] * meshes_y + Homo[1, 2]\n        noiminator = Homo[2, 0] * meshes_x + Homo[2, 1] * meshes_y + Homo[2, 2]\n        projected_1 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        x_dominator = Homo_2[0, 0] * meshes_x + Homo_2[0, 1] * meshes_y + Homo_2[0, 2]\n        y_dominator = Homo_2[1, 0] * meshes_x + Homo_2[1, 1] * meshes_y + Homo_2[1, 2]\n        noiminator = Homo_2[2, 0] * meshes_x + Homo_2[2, 1] * meshes_y + Homo_2[2, 2]\n        projected_2 = np.reshape(np.stack([x_dominator / noiminator, y_dominator / noiminator], 2), (-1, 2))\n        distance_x = np.expand_dims(new_points_numpy[:, 0], 0) - np.reshape(meshes_x, (-1, 1))\n        distance_y = np.expand_dims(new_points_numpy[:, 1], 0) - np.reshape(meshes_y, (-1, 1))\n        distance = distance_x ** 2 + distance_y ** 2\n        distance_mask = distance < cfg.MODEL.RADIUS ** 2\n        distance_mask_value = distance_mask.astype(np.float32) * attribute.transpose(1, 0)\n        distance = np.sum(distance_mask_value, 1) / (np.sum(distance_mask, 1) + 1e-09)\n        project_pos = np.reshape(np.expand_dims(distance, 1) * projected_2 + np.expand_dims(1 - distance, 1) * projected_1, (cfg.MODEL.HEIGHT // cfg.MODEL.PIXELS, cfg.MODEL.WIDTH // cfg.MODEL.PIXELS, 2))\n        meshes_projected = torch.from_numpy(project_pos.astype(np.float32)).to(new_points.device).permute(2, 0, 1)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y], 0)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :]\n        homo_cal = HomoCalc(meshes, meshes_projected)\n        project_pts = HomoProj(homo_cal, old_points)\n        new_points_projected = project_pts\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n    else:\n        Homo = torch.from_numpy(Homo.astype(np.float32)).to(old_points.device)\n        (meshes_x, meshes_y) = torch.meshgrid(torch.arange(0, W, cfg.MODEL.PIXELS), torch.arange(0, H, cfg.MODEL.PIXELS))\n        meshes_x = meshes_x.float().permute(1, 0)\n        meshes_y = meshes_y.float().permute(1, 0)\n        meshes_x = meshes_x.to(old_points.device)\n        meshes_y = meshes_y.to(old_points.device)\n        meshes_z = torch.ones_like(meshes_x).to(old_points.device)\n        meshes = torch.stack([meshes_x, meshes_y, meshes_z], 0)\n        meshes_projected = torch.mm(Homo, meshes.view(3, -1)).view(*meshes.shape)\n        x_motions = meshes[0, :, :] - meshes_projected[0, :, :] / meshes_projected[2, :, :]\n        y_motions = meshes[1, :, :] - meshes_projected[1, :, :] / meshes_projected[2, :, :]\n        new_points_projected = torch.from_numpy(new_points_projected).to(old_points.device)\n    temp_x_motion = torch.zeros_like(x_motions)\n    temp_y_motion = torch.zeros_like(x_motions)\n    for i in range(x_motions.shape[0]):\n        for j in range(x_motions.shape[1]):\n            distance = torch.sqrt((old_points[:, 0] - i * cfg.MODEL.PIXELS) ** 2 + (old_points[:, 1] - j * cfg.MODEL.PIXELS) ** 2)\n            distance = distance < cfg.MODEL.RADIUS\n            index = distance.nonzero()\n            if index.shape[0] == 0:\n                continue\n            new_points_homo = new_points_projected[index[:, 0].long(), :]\n            new_points_flow = new_points[index[:, 0].long(), :]\n            temp_motion = -(new_points_homo - new_points_flow)\n            temp_x_motion[i, j] = temp_motion[:, 0].median()\n            temp_y_motion[i, j] = temp_motion[:, 1].median()\n    x_motions = x_motions + temp_x_motion\n    y_motions = y_motions + temp_y_motion\n    x_motion_mesh = medfilt(x_motions.unsqueeze(0).unsqueeze(0))\n    y_motion_mesh = medfilt(y_motions.unsqueeze(0).unsqueeze(0))\n    return torch.cat([x_motion_mesh, y_motion_mesh], 1)"
        ]
    }
]