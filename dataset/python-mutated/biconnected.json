[
    {
        "func_name": "is_biconnected",
        "original": "@not_implemented_for('directed')\n@nx._dispatch\ndef is_biconnected(G):\n    \"\"\"Returns True if the graph is biconnected, False otherwise.\n\n    A graph is biconnected if, and only if, it cannot be disconnected by\n    removing only one node (and all edges incident on that node).  If\n    removing a node increases the number of disconnected components\n    in the graph, that node is called an articulation point, or cut\n    vertex.  A biconnected graph has no articulation points.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        An undirected graph.\n\n    Returns\n    -------\n    biconnected : bool\n        True if the graph is biconnected, False otherwise.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is not undirected.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> print(nx.is_biconnected(G))\n    False\n    >>> G.add_edge(0, 3)\n    >>> print(nx.is_biconnected(G))\n    True\n\n    See Also\n    --------\n    biconnected_components\n    articulation_points\n    biconnected_component_edges\n    is_strongly_connected\n    is_weakly_connected\n    is_connected\n    is_semiconnected\n\n    Notes\n    -----\n    The algorithm to find articulation points and biconnected\n    components is implemented using a non-recursive depth-first-search\n    (DFS) that keeps track of the highest level that back edges reach\n    in the DFS tree.  A node `n` is an articulation point if, and only\n    if, there exists a subtree rooted at `n` such that there is no\n    back edge from any successor of `n` that links to a predecessor of\n    `n` in the DFS tree.  By keeping track of all the edges traversed\n    by the DFS we can obtain the biconnected components because all\n    edges of a bicomponent will be traversed consecutively between\n    articulation points.\n\n    References\n    ----------\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\n       \"Efficient algorithms for graph manipulation\".\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\n\n    \"\"\"\n    bccs = biconnected_components(G)\n    try:\n        bcc = next(bccs)\n    except StopIteration:\n        return False\n    try:\n        next(bccs)\n    except StopIteration:\n        return len(bcc) == len(G)\n    else:\n        return False",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch\ndef is_biconnected(G):\n    if False:\n        i = 10\n    'Returns True if the graph is biconnected, False otherwise.\\n\\n    A graph is biconnected if, and only if, it cannot be disconnected by\\n    removing only one node (and all edges incident on that node).  If\\n    removing a node increases the number of disconnected components\\n    in the graph, that node is called an articulation point, or cut\\n    vertex.  A biconnected graph has no articulation points.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    biconnected : bool\\n        True if the graph is biconnected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> G.add_edge(0, 3)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n\\n    See Also\\n    --------\\n    biconnected_components\\n    articulation_points\\n    biconnected_component_edges\\n    is_strongly_connected\\n    is_weakly_connected\\n    is_connected\\n    is_semiconnected\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n       \"Efficient algorithms for graph manipulation\".\\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    bccs = biconnected_components(G)\n    try:\n        bcc = next(bccs)\n    except StopIteration:\n        return False\n    try:\n        next(bccs)\n    except StopIteration:\n        return len(bcc) == len(G)\n    else:\n        return False",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef is_biconnected(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns True if the graph is biconnected, False otherwise.\\n\\n    A graph is biconnected if, and only if, it cannot be disconnected by\\n    removing only one node (and all edges incident on that node).  If\\n    removing a node increases the number of disconnected components\\n    in the graph, that node is called an articulation point, or cut\\n    vertex.  A biconnected graph has no articulation points.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    biconnected : bool\\n        True if the graph is biconnected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> G.add_edge(0, 3)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n\\n    See Also\\n    --------\\n    biconnected_components\\n    articulation_points\\n    biconnected_component_edges\\n    is_strongly_connected\\n    is_weakly_connected\\n    is_connected\\n    is_semiconnected\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n       \"Efficient algorithms for graph manipulation\".\\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    bccs = biconnected_components(G)\n    try:\n        bcc = next(bccs)\n    except StopIteration:\n        return False\n    try:\n        next(bccs)\n    except StopIteration:\n        return len(bcc) == len(G)\n    else:\n        return False",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef is_biconnected(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns True if the graph is biconnected, False otherwise.\\n\\n    A graph is biconnected if, and only if, it cannot be disconnected by\\n    removing only one node (and all edges incident on that node).  If\\n    removing a node increases the number of disconnected components\\n    in the graph, that node is called an articulation point, or cut\\n    vertex.  A biconnected graph has no articulation points.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    biconnected : bool\\n        True if the graph is biconnected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> G.add_edge(0, 3)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n\\n    See Also\\n    --------\\n    biconnected_components\\n    articulation_points\\n    biconnected_component_edges\\n    is_strongly_connected\\n    is_weakly_connected\\n    is_connected\\n    is_semiconnected\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n       \"Efficient algorithms for graph manipulation\".\\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    bccs = biconnected_components(G)\n    try:\n        bcc = next(bccs)\n    except StopIteration:\n        return False\n    try:\n        next(bccs)\n    except StopIteration:\n        return len(bcc) == len(G)\n    else:\n        return False",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef is_biconnected(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns True if the graph is biconnected, False otherwise.\\n\\n    A graph is biconnected if, and only if, it cannot be disconnected by\\n    removing only one node (and all edges incident on that node).  If\\n    removing a node increases the number of disconnected components\\n    in the graph, that node is called an articulation point, or cut\\n    vertex.  A biconnected graph has no articulation points.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    biconnected : bool\\n        True if the graph is biconnected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> G.add_edge(0, 3)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n\\n    See Also\\n    --------\\n    biconnected_components\\n    articulation_points\\n    biconnected_component_edges\\n    is_strongly_connected\\n    is_weakly_connected\\n    is_connected\\n    is_semiconnected\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n       \"Efficient algorithms for graph manipulation\".\\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    bccs = biconnected_components(G)\n    try:\n        bcc = next(bccs)\n    except StopIteration:\n        return False\n    try:\n        next(bccs)\n    except StopIteration:\n        return len(bcc) == len(G)\n    else:\n        return False",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef is_biconnected(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns True if the graph is biconnected, False otherwise.\\n\\n    A graph is biconnected if, and only if, it cannot be disconnected by\\n    removing only one node (and all edges incident on that node).  If\\n    removing a node increases the number of disconnected components\\n    in the graph, that node is called an articulation point, or cut\\n    vertex.  A biconnected graph has no articulation points.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    biconnected : bool\\n        True if the graph is biconnected, False otherwise.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.path_graph(4)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> G.add_edge(0, 3)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n\\n    See Also\\n    --------\\n    biconnected_components\\n    articulation_points\\n    biconnected_component_edges\\n    is_strongly_connected\\n    is_weakly_connected\\n    is_connected\\n    is_semiconnected\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n       \"Efficient algorithms for graph manipulation\".\\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    bccs = biconnected_components(G)\n    try:\n        bcc = next(bccs)\n    except StopIteration:\n        return False\n    try:\n        next(bccs)\n    except StopIteration:\n        return len(bcc) == len(G)\n    else:\n        return False"
        ]
    },
    {
        "func_name": "biconnected_component_edges",
        "original": "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_component_edges(G):\n    \"\"\"Returns a generator of lists of edges, one list for each biconnected\n    component of the input graph.\n\n    Biconnected components are maximal subgraphs such that the removal of a\n    node (and all edges incident on that node) will not disconnect the\n    subgraph.  Note that nodes may be part of more than one biconnected\n    component.  Those nodes are articulation points, or cut vertices.\n    However, each edge belongs to one, and only one, biconnected component.\n\n    Notice that by convention a dyad is considered a biconnected component.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        An undirected graph.\n\n    Returns\n    -------\n    edges : generator of lists\n        Generator of lists of edges, one list for each bicomponent.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is not undirected.\n\n    Examples\n    --------\n    >>> G = nx.barbell_graph(4, 2)\n    >>> print(nx.is_biconnected(G))\n    False\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\n    >>> len(bicomponents_edges)\n    5\n    >>> G.add_edge(2, 8)\n    >>> print(nx.is_biconnected(G))\n    True\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\n    >>> len(bicomponents_edges)\n    1\n\n    See Also\n    --------\n    is_biconnected,\n    biconnected_components,\n    articulation_points,\n\n    Notes\n    -----\n    The algorithm to find articulation points and biconnected\n    components is implemented using a non-recursive depth-first-search\n    (DFS) that keeps track of the highest level that back edges reach\n    in the DFS tree.  A node `n` is an articulation point if, and only\n    if, there exists a subtree rooted at `n` such that there is no\n    back edge from any successor of `n` that links to a predecessor of\n    `n` in the DFS tree.  By keeping track of all the edges traversed\n    by the DFS we can obtain the biconnected components because all\n    edges of a bicomponent will be traversed consecutively between\n    articulation points.\n\n    References\n    ----------\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\n           \"Efficient algorithms for graph manipulation\".\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\n\n    \"\"\"\n    yield from _biconnected_dfs(G, components=True)",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_component_edges(G):\n    if False:\n        i = 10\n    'Returns a generator of lists of edges, one list for each biconnected\\n    component of the input graph.\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph.  Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.\\n    However, each edge belongs to one, and only one, biconnected component.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    edges : generator of lists\\n        Generator of lists of edges, one list for each bicomponent.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    5\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    1\\n\\n    See Also\\n    --------\\n    is_biconnected,\\n    biconnected_components,\\n    articulation_points,\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    yield from _biconnected_dfs(G, components=True)",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_component_edges(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a generator of lists of edges, one list for each biconnected\\n    component of the input graph.\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph.  Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.\\n    However, each edge belongs to one, and only one, biconnected component.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    edges : generator of lists\\n        Generator of lists of edges, one list for each bicomponent.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    5\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    1\\n\\n    See Also\\n    --------\\n    is_biconnected,\\n    biconnected_components,\\n    articulation_points,\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    yield from _biconnected_dfs(G, components=True)",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_component_edges(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a generator of lists of edges, one list for each biconnected\\n    component of the input graph.\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph.  Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.\\n    However, each edge belongs to one, and only one, biconnected component.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    edges : generator of lists\\n        Generator of lists of edges, one list for each bicomponent.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    5\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    1\\n\\n    See Also\\n    --------\\n    is_biconnected,\\n    biconnected_components,\\n    articulation_points,\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    yield from _biconnected_dfs(G, components=True)",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_component_edges(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a generator of lists of edges, one list for each biconnected\\n    component of the input graph.\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph.  Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.\\n    However, each edge belongs to one, and only one, biconnected component.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    edges : generator of lists\\n        Generator of lists of edges, one list for each bicomponent.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    5\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    1\\n\\n    See Also\\n    --------\\n    is_biconnected,\\n    biconnected_components,\\n    articulation_points,\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    yield from _biconnected_dfs(G, components=True)",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_component_edges(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a generator of lists of edges, one list for each biconnected\\n    component of the input graph.\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph.  Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.\\n    However, each edge belongs to one, and only one, biconnected component.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    edges : generator of lists\\n        Generator of lists of edges, one list for each bicomponent.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    5\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents_edges = list(nx.biconnected_component_edges(G))\\n    >>> len(bicomponents_edges)\\n    1\\n\\n    See Also\\n    --------\\n    is_biconnected,\\n    biconnected_components,\\n    articulation_points,\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    yield from _biconnected_dfs(G, components=True)"
        ]
    },
    {
        "func_name": "biconnected_components",
        "original": "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_components(G):\n    \"\"\"Returns a generator of sets of nodes, one set for each biconnected\n    component of the graph\n\n    Biconnected components are maximal subgraphs such that the removal of a\n    node (and all edges incident on that node) will not disconnect the\n    subgraph. Note that nodes may be part of more than one biconnected\n    component.  Those nodes are articulation points, or cut vertices.  The\n    removal of articulation points will increase the number of connected\n    components of the graph.\n\n    Notice that by convention a dyad is considered a biconnected component.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        An undirected graph.\n\n    Returns\n    -------\n    nodes : generator\n        Generator of sets of nodes, one set for each biconnected component.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is not undirected.\n\n    Examples\n    --------\n    >>> G = nx.lollipop_graph(5, 1)\n    >>> print(nx.is_biconnected(G))\n    False\n    >>> bicomponents = list(nx.biconnected_components(G))\n    >>> len(bicomponents)\n    2\n    >>> G.add_edge(0, 5)\n    >>> print(nx.is_biconnected(G))\n    True\n    >>> bicomponents = list(nx.biconnected_components(G))\n    >>> len(bicomponents)\n    1\n\n    You can generate a sorted list of biconnected components, largest\n    first, using sort.\n\n    >>> G.remove_edge(0, 5)\n    >>> [len(c) for c in sorted(nx.biconnected_components(G), key=len, reverse=True)]\n    [5, 2]\n\n    If you only want the largest connected component, it's more\n    efficient to use max instead of sort.\n\n    >>> Gc = max(nx.biconnected_components(G), key=len)\n\n    To create the components as subgraphs use:\n    ``(G.subgraph(c).copy() for c in biconnected_components(G))``\n\n    See Also\n    --------\n    is_biconnected\n    articulation_points\n    biconnected_component_edges\n    k_components : this function is a special case where k=2\n    bridge_components : similar to this function, but is defined using\n        2-edge-connectivity instead of 2-node-connectivity.\n\n    Notes\n    -----\n    The algorithm to find articulation points and biconnected\n    components is implemented using a non-recursive depth-first-search\n    (DFS) that keeps track of the highest level that back edges reach\n    in the DFS tree.  A node `n` is an articulation point if, and only\n    if, there exists a subtree rooted at `n` such that there is no\n    back edge from any successor of `n` that links to a predecessor of\n    `n` in the DFS tree.  By keeping track of all the edges traversed\n    by the DFS we can obtain the biconnected components because all\n    edges of a bicomponent will be traversed consecutively between\n    articulation points.\n\n    References\n    ----------\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\n           \"Efficient algorithms for graph manipulation\".\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\n\n    \"\"\"\n    for comp in _biconnected_dfs(G, components=True):\n        yield set(chain.from_iterable(comp))",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_components(G):\n    if False:\n        i = 10\n    'Returns a generator of sets of nodes, one set for each biconnected\\n    component of the graph\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph. Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.  The\\n    removal of articulation points will increase the number of connected\\n    components of the graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    nodes : generator\\n        Generator of sets of nodes, one set for each biconnected component.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.lollipop_graph(5, 1)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    2\\n    >>> G.add_edge(0, 5)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    1\\n\\n    You can generate a sorted list of biconnected components, largest\\n    first, using sort.\\n\\n    >>> G.remove_edge(0, 5)\\n    >>> [len(c) for c in sorted(nx.biconnected_components(G), key=len, reverse=True)]\\n    [5, 2]\\n\\n    If you only want the largest connected component, it\\'s more\\n    efficient to use max instead of sort.\\n\\n    >>> Gc = max(nx.biconnected_components(G), key=len)\\n\\n    To create the components as subgraphs use:\\n    ``(G.subgraph(c).copy() for c in biconnected_components(G))``\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    articulation_points\\n    biconnected_component_edges\\n    k_components : this function is a special case where k=2\\n    bridge_components : similar to this function, but is defined using\\n        2-edge-connectivity instead of 2-node-connectivity.\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    for comp in _biconnected_dfs(G, components=True):\n        yield set(chain.from_iterable(comp))",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns a generator of sets of nodes, one set for each biconnected\\n    component of the graph\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph. Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.  The\\n    removal of articulation points will increase the number of connected\\n    components of the graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    nodes : generator\\n        Generator of sets of nodes, one set for each biconnected component.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.lollipop_graph(5, 1)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    2\\n    >>> G.add_edge(0, 5)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    1\\n\\n    You can generate a sorted list of biconnected components, largest\\n    first, using sort.\\n\\n    >>> G.remove_edge(0, 5)\\n    >>> [len(c) for c in sorted(nx.biconnected_components(G), key=len, reverse=True)]\\n    [5, 2]\\n\\n    If you only want the largest connected component, it\\'s more\\n    efficient to use max instead of sort.\\n\\n    >>> Gc = max(nx.biconnected_components(G), key=len)\\n\\n    To create the components as subgraphs use:\\n    ``(G.subgraph(c).copy() for c in biconnected_components(G))``\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    articulation_points\\n    biconnected_component_edges\\n    k_components : this function is a special case where k=2\\n    bridge_components : similar to this function, but is defined using\\n        2-edge-connectivity instead of 2-node-connectivity.\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    for comp in _biconnected_dfs(G, components=True):\n        yield set(chain.from_iterable(comp))",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns a generator of sets of nodes, one set for each biconnected\\n    component of the graph\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph. Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.  The\\n    removal of articulation points will increase the number of connected\\n    components of the graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    nodes : generator\\n        Generator of sets of nodes, one set for each biconnected component.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.lollipop_graph(5, 1)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    2\\n    >>> G.add_edge(0, 5)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    1\\n\\n    You can generate a sorted list of biconnected components, largest\\n    first, using sort.\\n\\n    >>> G.remove_edge(0, 5)\\n    >>> [len(c) for c in sorted(nx.biconnected_components(G), key=len, reverse=True)]\\n    [5, 2]\\n\\n    If you only want the largest connected component, it\\'s more\\n    efficient to use max instead of sort.\\n\\n    >>> Gc = max(nx.biconnected_components(G), key=len)\\n\\n    To create the components as subgraphs use:\\n    ``(G.subgraph(c).copy() for c in biconnected_components(G))``\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    articulation_points\\n    biconnected_component_edges\\n    k_components : this function is a special case where k=2\\n    bridge_components : similar to this function, but is defined using\\n        2-edge-connectivity instead of 2-node-connectivity.\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    for comp in _biconnected_dfs(G, components=True):\n        yield set(chain.from_iterable(comp))",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns a generator of sets of nodes, one set for each biconnected\\n    component of the graph\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph. Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.  The\\n    removal of articulation points will increase the number of connected\\n    components of the graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    nodes : generator\\n        Generator of sets of nodes, one set for each biconnected component.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.lollipop_graph(5, 1)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    2\\n    >>> G.add_edge(0, 5)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    1\\n\\n    You can generate a sorted list of biconnected components, largest\\n    first, using sort.\\n\\n    >>> G.remove_edge(0, 5)\\n    >>> [len(c) for c in sorted(nx.biconnected_components(G), key=len, reverse=True)]\\n    [5, 2]\\n\\n    If you only want the largest connected component, it\\'s more\\n    efficient to use max instead of sort.\\n\\n    >>> Gc = max(nx.biconnected_components(G), key=len)\\n\\n    To create the components as subgraphs use:\\n    ``(G.subgraph(c).copy() for c in biconnected_components(G))``\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    articulation_points\\n    biconnected_component_edges\\n    k_components : this function is a special case where k=2\\n    bridge_components : similar to this function, but is defined using\\n        2-edge-connectivity instead of 2-node-connectivity.\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    for comp in _biconnected_dfs(G, components=True):\n        yield set(chain.from_iterable(comp))",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef biconnected_components(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns a generator of sets of nodes, one set for each biconnected\\n    component of the graph\\n\\n    Biconnected components are maximal subgraphs such that the removal of a\\n    node (and all edges incident on that node) will not disconnect the\\n    subgraph. Note that nodes may be part of more than one biconnected\\n    component.  Those nodes are articulation points, or cut vertices.  The\\n    removal of articulation points will increase the number of connected\\n    components of the graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Returns\\n    -------\\n    nodes : generator\\n        Generator of sets of nodes, one set for each biconnected component.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n    >>> G = nx.lollipop_graph(5, 1)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    2\\n    >>> G.add_edge(0, 5)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> bicomponents = list(nx.biconnected_components(G))\\n    >>> len(bicomponents)\\n    1\\n\\n    You can generate a sorted list of biconnected components, largest\\n    first, using sort.\\n\\n    >>> G.remove_edge(0, 5)\\n    >>> [len(c) for c in sorted(nx.biconnected_components(G), key=len, reverse=True)]\\n    [5, 2]\\n\\n    If you only want the largest connected component, it\\'s more\\n    efficient to use max instead of sort.\\n\\n    >>> Gc = max(nx.biconnected_components(G), key=len)\\n\\n    To create the components as subgraphs use:\\n    ``(G.subgraph(c).copy() for c in biconnected_components(G))``\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    articulation_points\\n    biconnected_component_edges\\n    k_components : this function is a special case where k=2\\n    bridge_components : similar to this function, but is defined using\\n        2-edge-connectivity instead of 2-node-connectivity.\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    for comp in _biconnected_dfs(G, components=True):\n        yield set(chain.from_iterable(comp))"
        ]
    },
    {
        "func_name": "articulation_points",
        "original": "@not_implemented_for('directed')\n@nx._dispatch\ndef articulation_points(G):\n    \"\"\"Yield the articulation points, or cut vertices, of a graph.\n\n    An articulation point or cut vertex is any node whose removal (along with\n    all its incident edges) increases the number of connected components of\n    a graph.  An undirected connected graph without articulation points is\n    biconnected. Articulation points belong to more than one biconnected\n    component of a graph.\n\n    Notice that by convention a dyad is considered a biconnected component.\n\n    Parameters\n    ----------\n    G : NetworkX Graph\n        An undirected graph.\n\n    Yields\n    ------\n    node\n        An articulation point in the graph.\n\n    Raises\n    ------\n    NetworkXNotImplemented\n        If the input graph is not undirected.\n\n    Examples\n    --------\n\n    >>> G = nx.barbell_graph(4, 2)\n    >>> print(nx.is_biconnected(G))\n    False\n    >>> len(list(nx.articulation_points(G)))\n    4\n    >>> G.add_edge(2, 8)\n    >>> print(nx.is_biconnected(G))\n    True\n    >>> len(list(nx.articulation_points(G)))\n    0\n\n    See Also\n    --------\n    is_biconnected\n    biconnected_components\n    biconnected_component_edges\n\n    Notes\n    -----\n    The algorithm to find articulation points and biconnected\n    components is implemented using a non-recursive depth-first-search\n    (DFS) that keeps track of the highest level that back edges reach\n    in the DFS tree.  A node `n` is an articulation point if, and only\n    if, there exists a subtree rooted at `n` such that there is no\n    back edge from any successor of `n` that links to a predecessor of\n    `n` in the DFS tree.  By keeping track of all the edges traversed\n    by the DFS we can obtain the biconnected components because all\n    edges of a bicomponent will be traversed consecutively between\n    articulation points.\n\n    References\n    ----------\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\n           \"Efficient algorithms for graph manipulation\".\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\n\n    \"\"\"\n    seen = set()\n    for articulation in _biconnected_dfs(G, components=False):\n        if articulation not in seen:\n            seen.add(articulation)\n            yield articulation",
        "mutated": [
            "@not_implemented_for('directed')\n@nx._dispatch\ndef articulation_points(G):\n    if False:\n        i = 10\n    'Yield the articulation points, or cut vertices, of a graph.\\n\\n    An articulation point or cut vertex is any node whose removal (along with\\n    all its incident edges) increases the number of connected components of\\n    a graph.  An undirected connected graph without articulation points is\\n    biconnected. Articulation points belong to more than one biconnected\\n    component of a graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Yields\\n    ------\\n    node\\n        An articulation point in the graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> len(list(nx.articulation_points(G)))\\n    4\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> len(list(nx.articulation_points(G)))\\n    0\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    biconnected_components\\n    biconnected_component_edges\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    seen = set()\n    for articulation in _biconnected_dfs(G, components=False):\n        if articulation not in seen:\n            seen.add(articulation)\n            yield articulation",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef articulation_points(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Yield the articulation points, or cut vertices, of a graph.\\n\\n    An articulation point or cut vertex is any node whose removal (along with\\n    all its incident edges) increases the number of connected components of\\n    a graph.  An undirected connected graph without articulation points is\\n    biconnected. Articulation points belong to more than one biconnected\\n    component of a graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Yields\\n    ------\\n    node\\n        An articulation point in the graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> len(list(nx.articulation_points(G)))\\n    4\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> len(list(nx.articulation_points(G)))\\n    0\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    biconnected_components\\n    biconnected_component_edges\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    seen = set()\n    for articulation in _biconnected_dfs(G, components=False):\n        if articulation not in seen:\n            seen.add(articulation)\n            yield articulation",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef articulation_points(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Yield the articulation points, or cut vertices, of a graph.\\n\\n    An articulation point or cut vertex is any node whose removal (along with\\n    all its incident edges) increases the number of connected components of\\n    a graph.  An undirected connected graph without articulation points is\\n    biconnected. Articulation points belong to more than one biconnected\\n    component of a graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Yields\\n    ------\\n    node\\n        An articulation point in the graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> len(list(nx.articulation_points(G)))\\n    4\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> len(list(nx.articulation_points(G)))\\n    0\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    biconnected_components\\n    biconnected_component_edges\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    seen = set()\n    for articulation in _biconnected_dfs(G, components=False):\n        if articulation not in seen:\n            seen.add(articulation)\n            yield articulation",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef articulation_points(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Yield the articulation points, or cut vertices, of a graph.\\n\\n    An articulation point or cut vertex is any node whose removal (along with\\n    all its incident edges) increases the number of connected components of\\n    a graph.  An undirected connected graph without articulation points is\\n    biconnected. Articulation points belong to more than one biconnected\\n    component of a graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Yields\\n    ------\\n    node\\n        An articulation point in the graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> len(list(nx.articulation_points(G)))\\n    4\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> len(list(nx.articulation_points(G)))\\n    0\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    biconnected_components\\n    biconnected_component_edges\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    seen = set()\n    for articulation in _biconnected_dfs(G, components=False):\n        if articulation not in seen:\n            seen.add(articulation)\n            yield articulation",
            "@not_implemented_for('directed')\n@nx._dispatch\ndef articulation_points(G):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Yield the articulation points, or cut vertices, of a graph.\\n\\n    An articulation point or cut vertex is any node whose removal (along with\\n    all its incident edges) increases the number of connected components of\\n    a graph.  An undirected connected graph without articulation points is\\n    biconnected. Articulation points belong to more than one biconnected\\n    component of a graph.\\n\\n    Notice that by convention a dyad is considered a biconnected component.\\n\\n    Parameters\\n    ----------\\n    G : NetworkX Graph\\n        An undirected graph.\\n\\n    Yields\\n    ------\\n    node\\n        An articulation point in the graph.\\n\\n    Raises\\n    ------\\n    NetworkXNotImplemented\\n        If the input graph is not undirected.\\n\\n    Examples\\n    --------\\n\\n    >>> G = nx.barbell_graph(4, 2)\\n    >>> print(nx.is_biconnected(G))\\n    False\\n    >>> len(list(nx.articulation_points(G)))\\n    4\\n    >>> G.add_edge(2, 8)\\n    >>> print(nx.is_biconnected(G))\\n    True\\n    >>> len(list(nx.articulation_points(G)))\\n    0\\n\\n    See Also\\n    --------\\n    is_biconnected\\n    biconnected_components\\n    biconnected_component_edges\\n\\n    Notes\\n    -----\\n    The algorithm to find articulation points and biconnected\\n    components is implemented using a non-recursive depth-first-search\\n    (DFS) that keeps track of the highest level that back edges reach\\n    in the DFS tree.  A node `n` is an articulation point if, and only\\n    if, there exists a subtree rooted at `n` such that there is no\\n    back edge from any successor of `n` that links to a predecessor of\\n    `n` in the DFS tree.  By keeping track of all the edges traversed\\n    by the DFS we can obtain the biconnected components because all\\n    edges of a bicomponent will be traversed consecutively between\\n    articulation points.\\n\\n    References\\n    ----------\\n    .. [1] Hopcroft, J.; Tarjan, R. (1973).\\n           \"Efficient algorithms for graph manipulation\".\\n           Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272\\n\\n    '\n    seen = set()\n    for articulation in _biconnected_dfs(G, components=False):\n        if articulation not in seen:\n            seen.add(articulation)\n            yield articulation"
        ]
    },
    {
        "func_name": "_biconnected_dfs",
        "original": "@not_implemented_for('directed')\ndef _biconnected_dfs(G, components=True):\n    visited = set()\n    for start in G:\n        if start in visited:\n            continue\n        discovery = {start: 0}\n        low = {start: 0}\n        root_children = 0\n        visited.add(start)\n        edge_stack = []\n        stack = [(start, start, iter(G[start]))]\n        edge_index = {}\n        while stack:\n            (grandparent, parent, children) = stack[-1]\n            try:\n                child = next(children)\n                if grandparent == child:\n                    continue\n                if child in visited:\n                    if discovery[child] <= discovery[parent]:\n                        low[parent] = min(low[parent], discovery[child])\n                        if components:\n                            edge_index[parent, child] = len(edge_stack)\n                            edge_stack.append((parent, child))\n                else:\n                    low[child] = discovery[child] = len(discovery)\n                    visited.add(child)\n                    stack.append((parent, child, iter(G[child])))\n                    if components:\n                        edge_index[parent, child] = len(edge_stack)\n                        edge_stack.append((parent, child))\n            except StopIteration:\n                stack.pop()\n                if len(stack) > 1:\n                    if low[parent] >= discovery[grandparent]:\n                        if components:\n                            ind = edge_index[grandparent, parent]\n                            yield edge_stack[ind:]\n                            del edge_stack[ind:]\n                        else:\n                            yield grandparent\n                    low[grandparent] = min(low[parent], low[grandparent])\n                elif stack:\n                    root_children += 1\n                    if components:\n                        ind = edge_index[grandparent, parent]\n                        yield edge_stack[ind:]\n                        del edge_stack[ind:]\n        if not components:\n            if root_children > 1:\n                yield start",
        "mutated": [
            "@not_implemented_for('directed')\ndef _biconnected_dfs(G, components=True):\n    if False:\n        i = 10\n    visited = set()\n    for start in G:\n        if start in visited:\n            continue\n        discovery = {start: 0}\n        low = {start: 0}\n        root_children = 0\n        visited.add(start)\n        edge_stack = []\n        stack = [(start, start, iter(G[start]))]\n        edge_index = {}\n        while stack:\n            (grandparent, parent, children) = stack[-1]\n            try:\n                child = next(children)\n                if grandparent == child:\n                    continue\n                if child in visited:\n                    if discovery[child] <= discovery[parent]:\n                        low[parent] = min(low[parent], discovery[child])\n                        if components:\n                            edge_index[parent, child] = len(edge_stack)\n                            edge_stack.append((parent, child))\n                else:\n                    low[child] = discovery[child] = len(discovery)\n                    visited.add(child)\n                    stack.append((parent, child, iter(G[child])))\n                    if components:\n                        edge_index[parent, child] = len(edge_stack)\n                        edge_stack.append((parent, child))\n            except StopIteration:\n                stack.pop()\n                if len(stack) > 1:\n                    if low[parent] >= discovery[grandparent]:\n                        if components:\n                            ind = edge_index[grandparent, parent]\n                            yield edge_stack[ind:]\n                            del edge_stack[ind:]\n                        else:\n                            yield grandparent\n                    low[grandparent] = min(low[parent], low[grandparent])\n                elif stack:\n                    root_children += 1\n                    if components:\n                        ind = edge_index[grandparent, parent]\n                        yield edge_stack[ind:]\n                        del edge_stack[ind:]\n        if not components:\n            if root_children > 1:\n                yield start",
            "@not_implemented_for('directed')\ndef _biconnected_dfs(G, components=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    visited = set()\n    for start in G:\n        if start in visited:\n            continue\n        discovery = {start: 0}\n        low = {start: 0}\n        root_children = 0\n        visited.add(start)\n        edge_stack = []\n        stack = [(start, start, iter(G[start]))]\n        edge_index = {}\n        while stack:\n            (grandparent, parent, children) = stack[-1]\n            try:\n                child = next(children)\n                if grandparent == child:\n                    continue\n                if child in visited:\n                    if discovery[child] <= discovery[parent]:\n                        low[parent] = min(low[parent], discovery[child])\n                        if components:\n                            edge_index[parent, child] = len(edge_stack)\n                            edge_stack.append((parent, child))\n                else:\n                    low[child] = discovery[child] = len(discovery)\n                    visited.add(child)\n                    stack.append((parent, child, iter(G[child])))\n                    if components:\n                        edge_index[parent, child] = len(edge_stack)\n                        edge_stack.append((parent, child))\n            except StopIteration:\n                stack.pop()\n                if len(stack) > 1:\n                    if low[parent] >= discovery[grandparent]:\n                        if components:\n                            ind = edge_index[grandparent, parent]\n                            yield edge_stack[ind:]\n                            del edge_stack[ind:]\n                        else:\n                            yield grandparent\n                    low[grandparent] = min(low[parent], low[grandparent])\n                elif stack:\n                    root_children += 1\n                    if components:\n                        ind = edge_index[grandparent, parent]\n                        yield edge_stack[ind:]\n                        del edge_stack[ind:]\n        if not components:\n            if root_children > 1:\n                yield start",
            "@not_implemented_for('directed')\ndef _biconnected_dfs(G, components=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    visited = set()\n    for start in G:\n        if start in visited:\n            continue\n        discovery = {start: 0}\n        low = {start: 0}\n        root_children = 0\n        visited.add(start)\n        edge_stack = []\n        stack = [(start, start, iter(G[start]))]\n        edge_index = {}\n        while stack:\n            (grandparent, parent, children) = stack[-1]\n            try:\n                child = next(children)\n                if grandparent == child:\n                    continue\n                if child in visited:\n                    if discovery[child] <= discovery[parent]:\n                        low[parent] = min(low[parent], discovery[child])\n                        if components:\n                            edge_index[parent, child] = len(edge_stack)\n                            edge_stack.append((parent, child))\n                else:\n                    low[child] = discovery[child] = len(discovery)\n                    visited.add(child)\n                    stack.append((parent, child, iter(G[child])))\n                    if components:\n                        edge_index[parent, child] = len(edge_stack)\n                        edge_stack.append((parent, child))\n            except StopIteration:\n                stack.pop()\n                if len(stack) > 1:\n                    if low[parent] >= discovery[grandparent]:\n                        if components:\n                            ind = edge_index[grandparent, parent]\n                            yield edge_stack[ind:]\n                            del edge_stack[ind:]\n                        else:\n                            yield grandparent\n                    low[grandparent] = min(low[parent], low[grandparent])\n                elif stack:\n                    root_children += 1\n                    if components:\n                        ind = edge_index[grandparent, parent]\n                        yield edge_stack[ind:]\n                        del edge_stack[ind:]\n        if not components:\n            if root_children > 1:\n                yield start",
            "@not_implemented_for('directed')\ndef _biconnected_dfs(G, components=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    visited = set()\n    for start in G:\n        if start in visited:\n            continue\n        discovery = {start: 0}\n        low = {start: 0}\n        root_children = 0\n        visited.add(start)\n        edge_stack = []\n        stack = [(start, start, iter(G[start]))]\n        edge_index = {}\n        while stack:\n            (grandparent, parent, children) = stack[-1]\n            try:\n                child = next(children)\n                if grandparent == child:\n                    continue\n                if child in visited:\n                    if discovery[child] <= discovery[parent]:\n                        low[parent] = min(low[parent], discovery[child])\n                        if components:\n                            edge_index[parent, child] = len(edge_stack)\n                            edge_stack.append((parent, child))\n                else:\n                    low[child] = discovery[child] = len(discovery)\n                    visited.add(child)\n                    stack.append((parent, child, iter(G[child])))\n                    if components:\n                        edge_index[parent, child] = len(edge_stack)\n                        edge_stack.append((parent, child))\n            except StopIteration:\n                stack.pop()\n                if len(stack) > 1:\n                    if low[parent] >= discovery[grandparent]:\n                        if components:\n                            ind = edge_index[grandparent, parent]\n                            yield edge_stack[ind:]\n                            del edge_stack[ind:]\n                        else:\n                            yield grandparent\n                    low[grandparent] = min(low[parent], low[grandparent])\n                elif stack:\n                    root_children += 1\n                    if components:\n                        ind = edge_index[grandparent, parent]\n                        yield edge_stack[ind:]\n                        del edge_stack[ind:]\n        if not components:\n            if root_children > 1:\n                yield start",
            "@not_implemented_for('directed')\ndef _biconnected_dfs(G, components=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    visited = set()\n    for start in G:\n        if start in visited:\n            continue\n        discovery = {start: 0}\n        low = {start: 0}\n        root_children = 0\n        visited.add(start)\n        edge_stack = []\n        stack = [(start, start, iter(G[start]))]\n        edge_index = {}\n        while stack:\n            (grandparent, parent, children) = stack[-1]\n            try:\n                child = next(children)\n                if grandparent == child:\n                    continue\n                if child in visited:\n                    if discovery[child] <= discovery[parent]:\n                        low[parent] = min(low[parent], discovery[child])\n                        if components:\n                            edge_index[parent, child] = len(edge_stack)\n                            edge_stack.append((parent, child))\n                else:\n                    low[child] = discovery[child] = len(discovery)\n                    visited.add(child)\n                    stack.append((parent, child, iter(G[child])))\n                    if components:\n                        edge_index[parent, child] = len(edge_stack)\n                        edge_stack.append((parent, child))\n            except StopIteration:\n                stack.pop()\n                if len(stack) > 1:\n                    if low[parent] >= discovery[grandparent]:\n                        if components:\n                            ind = edge_index[grandparent, parent]\n                            yield edge_stack[ind:]\n                            del edge_stack[ind:]\n                        else:\n                            yield grandparent\n                    low[grandparent] = min(low[parent], low[grandparent])\n                elif stack:\n                    root_children += 1\n                    if components:\n                        ind = edge_index[grandparent, parent]\n                        yield edge_stack[ind:]\n                        del edge_stack[ind:]\n        if not components:\n            if root_children > 1:\n                yield start"
        ]
    }
]